/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/jasmine-core/lib/jasmine-core/jasmine.css":
/*!******************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/jasmine-core/lib/jasmine-core/jasmine.css ***!
  \******************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "@charset \"UTF-8\";\nbody {\n  overflow-y: scroll;\n}\n\n.jasmine_html-reporter {\n  width: 100%;\n  background-color: #eee;\n  padding: 5px;\n  margin: -8px;\n  font-size: 11px;\n  font-family: Monaco, \"Lucida Console\", monospace;\n  line-height: 14px;\n  color: #333;\n}\n.jasmine_html-reporter a {\n  text-decoration: none;\n}\n.jasmine_html-reporter a:hover {\n  text-decoration: underline;\n}\n.jasmine_html-reporter p, .jasmine_html-reporter h1, .jasmine_html-reporter h2, .jasmine_html-reporter h3, .jasmine_html-reporter h4, .jasmine_html-reporter h5, .jasmine_html-reporter h6 {\n  margin: 0;\n  line-height: 14px;\n}\n.jasmine_html-reporter .jasmine-banner,\n.jasmine_html-reporter .jasmine-symbol-summary,\n.jasmine_html-reporter .jasmine-summary,\n.jasmine_html-reporter .jasmine-result-message,\n.jasmine_html-reporter .jasmine-spec .jasmine-description,\n.jasmine_html-reporter .jasmine-spec-detail .jasmine-description,\n.jasmine_html-reporter .jasmine-alert .jasmine-bar,\n.jasmine_html-reporter .jasmine-stack-trace {\n  padding-left: 9px;\n  padding-right: 9px;\n}\n.jasmine_html-reporter .jasmine-banner {\n  position: relative;\n}\n.jasmine_html-reporter .jasmine-banner .jasmine-title {\n  background: url(\"data:image/png;base64,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\") no-repeat;\n  background: url(\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgdmVyc2lvbj0iMS4xIgogICB3aWR0aD0iNjgxLjk2MjUyIgogICBoZWlnaHQ9IjE4Ny41IgogICBpZD0ic3ZnMiIKICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhOCI+PHJkZjpSREY+PGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPjxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PjxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz48L2NjOldvcms+PC9yZGY6UkRGPjwvbWV0YWRhdGE+PGRlZnMKICAgICBpZD0iZGVmczYiPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMTgiPjxwYXRoCiAgICAgICAgIGQ9Ik0gMCwxNTAwIDAsMCBsIDU0NTUuNzQsMCAwLDE1MDAgTCAwLDE1MDAgeiIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgaWQ9InBhdGgyMCIgLz48L2NsaXBQYXRoPjwvZGVmcz48ZwogICAgIHRyYW5zZm9ybT0ibWF0cml4KDEuMjUsMCwwLC0xLjI1LDAsMTg3LjUpIgogICAgIGlkPSJnMTAiPjxnCiAgICAgICB0cmFuc2Zvcm09InNjYWxlKDAuMSwwLjEpIgogICAgICAgaWQ9ImcxMiI+PGcKICAgICAgICAgaWQ9ImcxNCI+PGcKICAgICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGgxOCkiCiAgICAgICAgICAgaWQ9ImcxNiI+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMTU0NCw1OTkuNDM0IGMgMC45MiwtNDAuMzUyIDI1LjY4LC04MS42MDIgNzEuNTMsLTgxLjYwMiAyNy41MSwwIDQ3LjY4LDEyLjgzMiA2MS40NCwzNS43NTQgMTIuODMsMjIuOTMgMTIuODMsNTYuODUyIDEyLjgzLDgyLjUyNyBsIDAsMzI5LjE4NCAtNzEuNTIsMCAwLDEwNC41NDMgMjY2LjgzLDAgMCwtMTA0LjU0MyAtNzAuNiwwIDAsLTM0NC43NyBjIDAsLTU4LjY5MSAtMy42OCwtMTA0LjUzMSAtNDQuOTMsLTE1Mi4yMTggLTM2LjY4LC00Mi4xOCAtOTYuMjgsLTY2LjAyIC0xNTMuMTQsLTY2LjAyIC0xMTcuMzcsMCAtMjA3LjI0LDc3Ljk0MSAtMjAyLjY0LDE5Ny4xNDUgbCAxMzAuMiwwIgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMjIiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDIzMDEuNCw2NjIuNjk1IGMgMCw4MC43MDMgLTY2Ljk0LDE0NS44MTMgLTE0Ny42MywxNDUuODEzIC04My40NCwwIC0xNDcuNjMsLTY4Ljc4MSAtMTQ3LjYzLC0xNTEuMzAxIDAsLTc5Ljc4NSA2Ni45NCwtMTQ1LjgwMSAxNDUuOCwtMTQ1LjgwMSA4NC4zNSwwIDE0OS40Niw2Ny44NTIgMTQ5LjQ2LDE1MS4yODkgeiBtIC0xLjgzLC0xODEuNTQ3IGMgLTM1Ljc3LC01NC4wOTcgLTkzLjUzLC03OC44NTkgLTE1Ny43MiwtNzguODU5IC0xNDAuMywwIC0yNTEuMjQsMTE2LjQ0OSAtMjUxLjI0LDI1NC45MTggMCwxNDIuMTI5IDExMy43LDI2MC40MSAyNTYuNzQsMjYwLjQxIDYzLjI3LDAgMTE4LjI5LC0yOS4zMzYgMTUyLjIyLC04Mi41MjMgbCAwLDY5LjY4NyAxNzUuMTQsMCAwLC0xMDQuNTI3IC02MS40NCwwIDAsLTI4MC41OTggNjEuNDQsMCAwLC0xMDQuNTI3IC0xNzUuMTQsMCAwLDY2LjAxOSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDI0IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSAyNjIyLjMzLDU1Ny4yNTggYyAzLjY3LC00NC4wMTYgMzMuMDEsLTczLjM0OCA3OC44NiwtNzMuMzQ4IDMzLjkzLDAgNjYuOTMsMjMuODI0IDY2LjkzLDYwLjUwNCAwLDQ4LjYwNiAtNDUuODQsNTYuODU2IC04My40NCw2Ni45NDEgLTg1LjI4LDIyLjAwNCAtMTc4LjgxLDQ4LjYwNiAtMTc4LjgxLDE1NS44NzkgMCw5My41MzYgNzguODYsMTQ3LjYzMyAxNjUuOTgsMTQ3LjYzMyA0NCwwIDgzLjQzLC05LjE3NiAxMTAuOTQsLTQ0LjAwOCBsIDAsMzMuOTIyIDgyLjUzLDAgMCwtMTMyLjk2NSAtMTA4LjIxLDAgYyAtMS44MywzNC44NTYgLTI4LjQyLDU3Ljc3NCAtNjMuMjYsNTcuNzc0IC0zMC4yNiwwIC02Mi4zNSwtMTcuNDIyIC02Mi4zNSwtNTEuMzQ4IDAsLTQ1Ljg0NyA0NC45MywtNTUuOTMgODAuNjksLTY0LjE4IDg4LjAyLC0yMC4xNzUgMTgyLjQ3LC00Ny42OTUgMTgyLjQ3LC0xNTcuNzM0IDAsLTk5LjAyNyAtODMuNDQsLTE1NC4wMzkgLTE3NS4xMywtMTU0LjAzOSAtNDkuNTMsMCAtOTQuNDYsMTUuNTgyIC0xMjYuNTUsNTMuMTggbCAwLC00MC4zNCAtODUuMjcsMCAwLDE0Mi4xMjkgMTE0LjYyLDAiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGgyNiIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMjk4OC4xOCw4MDAuMjU0IC02My4yNiwwIDAsMTA0LjUyNyAxNjUuMDUsMCAwLC03My4zNTUgYyAzMS4xOCw1MS4zNDcgNzguODYsODUuMjc3IDE0MS4yMSw4NS4yNzcgNjcuODUsMCAxMjQuNzEsLTQxLjI1OCAxNTIuMjEsLTEwMi42OTkgMjYuNiw2Mi4zNTEgOTIuNjIsMTAyLjY5OSAxNjAuNDcsMTAyLjY5OSA1My4xOSwwIDEwNS40NiwtMjIgMTQxLjIxLC02Mi4zNTEgMzguNTIsLTQ0LjkzOCAzOC41MiwtOTMuNTMyIDM4LjUyLC0xNDkuNDU3IGwgMCwtMTg1LjIzOSA2My4yNywwIDAsLTEwNC41MjcgLTIzOC40MiwwIDAsMTA0LjUyNyA2My4yOCwwIDAsMTU3LjcxNSBjIDAsMzIuMTAyIDAsNjAuNTI3IC0xNC42Nyw4OC45NTcgLTE4LjM0LDI2LjU4MiAtNDguNjEsNDAuMzQ0IC03OS43Nyw0MC4zNDQgLTMwLjI2LDAgLTYzLjI4LC0xMi44NDQgLTgyLjUzLC0zNi42NzIgLTIyLjkzLC0yOS4zNTUgLTIyLjkzLC01Ni44NjMgLTIyLjkzLC05Mi42MjkgbCAwLC0xNTcuNzE1IDYzLjI3LDAgMCwtMTA0LjUyNyAtMjM4LjQxLDAgMCwxMDQuNTI3IDYzLjI4LDAgMCwxNTAuMzgzIGMgMCwyOS4zNDggMCw2Ni4wMjMgLTE0LjY3LDkxLjY5OSAtMTUuNTksMjkuMzM2IC00Ny42OSw0NC45MzQgLTgwLjcsNDQuOTM0IC0zMS4xOCwwIC01Ny43NywtMTEuMDA4IC03Ny45NCwtMzUuNzc0IC0yNC43NywtMzAuMjUzIC0yNi42LC02Mi4zNDMgLTI2LjYsLTk5Ljk0MSBsIDAsLTE1MS4zMDEgNjMuMjcsMCAwLC0xMDQuNTI3IC0yMzguNCwwIDAsMTA0LjUyNyA2My4yNiwwIDAsMjgwLjU5OCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDI4IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSAzOTk4LjY2LDk1MS41NDcgLTExMS44NywwIDAsMTE4LjI5MyAxMTEuODcsMCAwLC0xMTguMjkzIHogbSAwLC00MzEuODkxIDYzLjI3LDAgMCwtMTA0LjUyNyAtMjM5LjMzLDAgMCwxMDQuNTI3IDY0LjE5LDAgMCwyODAuNTk4IC02My4yNywwIDAsMTA0LjUyNyAxNzUuMTQsMCAwLC0zODUuMTI1IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzAiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDQxNTkuMTIsODAwLjI1NCAtNjMuMjcsMCAwLDEwNC41MjcgMTc1LjE0LDAgMCwtNjkuNjg3IGMgMjkuMzUsNTQuMTAxIDg0LjM2LDgwLjY5OSAxNDQuODcsODAuNjk5IDUzLjE5LDAgMTA1LjQ1LC0yMi4wMTYgMTQxLjIyLC02MC41MjcgNDAuMzQsLTQ0LjkzNCA0MS4yNiwtODguMDMyIDQxLjI2LC0xNDMuOTU3IGwgMCwtMTkxLjY1MyA2My4yNywwIDAsLTEwNC41MjcgLTIzOC40LDAgMCwxMDQuNTI3IDYzLjI2LDAgMCwxNTguNjM3IGMgMCwzMC4yNjIgMCw2MS40MzQgLTE5LjI2LDg4LjAzNSAtMjAuMTcsMjYuNTgyIC01My4xOCwzOS40MTQgLTg2LjE5LDM5LjQxNCAtMzMuOTMsMCAtNjguNzcsLTEzLjc1IC04OC45NCwtNDEuMjUgLTIxLjA5LC0yNy41IC0yMS4wOSwtNjkuNjg3IC0yMS4wOSwtMTAyLjcwNyBsIDAsLTE0Mi4xMjkgNjMuMjYsMCAwLC0xMDQuNTI3IC0yMzguNCwwIDAsMTA0LjUyNyA2My4yNywwIDAsMjgwLjU5OCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDMyIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA1MDgyLjQ4LDcwMy45NjUgYyAtMTkuMjQsNzAuNjA1IC04MS42LDExNS41NDcgLTE1NC4wNCwxMTUuNTQ3IC02Ni4wNCwwIC0xMjkuMywtNTEuMzQ4IC0xNDMuMDUsLTExNS41NDcgbCAyOTcuMDksMCB6IG0gODUuMjcsLTE0NC44ODMgYyAtMzguNTEsLTkzLjUyMyAtMTI5LjI3LC0xNTYuNzkzIC0yMzEuMDUsLTE1Ni43OTMgLTE0My4wNywwIC0yNTcuNjgsMTExLjg3MSAtMjU3LjY4LDI1NS44MzYgMCwxNDQuODgzIDEwOS4xMiwyNjEuMzI4IDI1NC45MSwyNjEuMzI4IDY3Ljg3LDAgMTM1LjcyLC0zMC4yNTggMTgzLjM5LC03OC44NjMgNDguNjIsLTUxLjM0NCA2OC43OSwtMTEzLjY5NSA2OC43OSwtMTgzLjM4MyBsIC0zLjY3LC0zOS40MzQgLTM5Ni4xMywwIGMgMTQuNjcsLTY3Ljg2MyA3Ny4wMywtMTE3LjM2MyAxNDYuNzIsLTExNy4zNjMgNDguNTksMCA5MC43NiwxOC4zMjggMTE4LjI4LDU4LjY3MiBsIDExNi40NCwwIgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzQiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDY5MC44OTUsODUwLjcwMyA5MC43NSwwIDIyLjU0MywzMS4wMzUgMCwyNDMuMTIyIC0xMzUuODI5LDAgMCwtMjQzLjE0MSAyMi41MzYsLTMxLjAxNiIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDM2IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA2MzIuMzk1LDc0Mi4yNTggMjguMDM5LDg2LjMwNCAtMjIuNTUxLDMxLjA0IC0yMzEuMjIzLDc1LjEyOCAtNDEuOTc2LC0xMjkuMTgzIDIzMS4yNTcsLTc1LjEzNyAzNi40NTQsMTEuODQ4IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzgiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDcxNy40NDksNjUzLjEwNSAtNzMuNDEsNTMuMzYgLTM2LjQ4OCwtMTEuODc1IC0xNDIuOTAzLC0xOTYuNjkyIDEwOS44ODMsLTc5LjgyOCAxNDIuOTE4LDE5Ni43MDMgMCwzOC4zMzIiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGg0MCIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gODI4LjUyLDcwNi40NjUgLTczLjQyNiwtNTMuMzQgMC4wMTEsLTM4LjM1OSBMIDg5OC4wMDQsNDE4LjA3IDEwMDcuOSw0OTcuODk4IDg2NC45NzMsNjk0LjYwOSA4MjguNTIsNzA2LjQ2NSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDQyIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA4MTIuMDg2LDgyOC41ODYgMjguMDU1LC04Ni4zMiAzNi40ODQsLTExLjgzNiAyMzEuMjI1LDc1LjExNyAtNDEuOTcsMTI5LjE4MyAtMjMxLjIzOSwtNzUuMTQgLTIyLjU1NSwtMzEuMDA0IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNDQiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDczNi4zMDEsMTMzNS44OCBjIC0zMjMuMDQ3LDAgLTU4NS44NzUsLTI2Mi43OCAtNTg1Ljg3NSwtNTg1Ljc4MiAwLC0zMjMuMTE4IDI2Mi44MjgsLTU4NS45NzcgNTg1Ljg3NSwtNTg1Ljk3NyAzMjMuMDE5LDAgNTg1LjgwOSwyNjIuODU5IDU4NS44MDksNTg1Ljk3NyAwLDMyMy4wMDIgLTI2Mi43OSw1ODUuNzgyIC01ODUuODA5LDU4NS43ODIgbCAwLDAgeiBtIDAsLTExOC42MSBjIDI1Ny45NzIsMCA0NjcuMTg5LC0yMDkuMTMgNDY3LjE4OSwtNDY3LjE3MiAwLC0yNTguMTI5IC0yMDkuMjE3LC00NjcuMzQ4IC00NjcuMTg5LC00NjcuMzQ4IC0yNTguMDc0LDAgLTQ2Ny4yNTQsMjA5LjIxOSAtNDY3LjI1NCw0NjcuMzQ4IDAsMjU4LjA0MiAyMDkuMTgsNDY3LjE3MiA0NjcuMjU0LDQ2Ny4xNzIiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGg0NiIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMTA5MS4xMyw2MTkuODgzIC0xNzUuNzcxLDU3LjEyMSAxMS42MjksMzUuODA4IDE3NS43NjIsLTU3LjEyMSAtMTEuNjIsLTM1LjgwOCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDQ4IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0iTSA4NjYuOTU3LDkwMi4wNzQgODM2LjUsOTI0LjE5OSA5NDUuMTIxLDEwNzMuNzMgOTc1LjU4NiwxMDUxLjYxIDg2Ni45NTcsOTAyLjA3NCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDUwIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0iTSA2MDcuNDY1LDkwMy40NDUgNDk4Ljg1NSwxMDUyLjk3IDUyOS4zMiwxMDc1LjEgNjM3LjkzLDkyNS41NjYgNjA3LjQ2NSw5MDMuNDQ1IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNTIiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDM4MC42ODgsNjIyLjEyOSAtMTEuNjI2LDM1LjgwMSAxNzUuNzU4LDU3LjA5IDExLjYyMSwtMzUuODAxIC0xNzUuNzUzLC01Ny4wOSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDU0IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA3MTYuMjg5LDM3Ni41OSAzNy42NDA2LDAgMCwxODQuODE2IC0zNy42NDA2LDAgMCwtMTg0LjgxNiB6IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNTYiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjwvZz48L2c+PC9nPjwvZz48L3N2Zz4=\") no-repeat, none;\n  -moz-background-size: 100%;\n  -o-background-size: 100%;\n  -webkit-background-size: 100%;\n  background-size: 100%;\n  display: block;\n  float: left;\n  width: 90px;\n  height: 25px;\n}\n.jasmine_html-reporter .jasmine-banner .jasmine-version {\n  margin-left: 14px;\n  position: relative;\n  top: 6px;\n}\n.jasmine_html-reporter #jasmine_content {\n  position: fixed;\n  right: 100%;\n}\n.jasmine_html-reporter .jasmine-version {\n  color: #aaa;\n}\n.jasmine_html-reporter .jasmine-banner {\n  margin-top: 14px;\n}\n.jasmine_html-reporter .jasmine-duration {\n  color: #fff;\n  float: right;\n  line-height: 28px;\n  padding-right: 9px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary {\n  overflow: hidden;\n  margin: 14px 0;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li {\n  display: inline-block;\n  height: 10px;\n  width: 14px;\n  font-size: 16px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-passed {\n  font-size: 14px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-passed:before {\n  color: #007069;\n  content: \"•\";\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-failed {\n  line-height: 9px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-failed:before {\n  color: #ca3a11;\n  content: \"×\";\n  font-weight: bold;\n  margin-left: -1px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-excluded {\n  font-size: 14px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-excluded:before {\n  color: #bababa;\n  content: \"•\";\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-excluded-no-display {\n  font-size: 14px;\n  display: none;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-pending {\n  line-height: 17px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-pending:before {\n  color: #ba9d37;\n  content: \"*\";\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-empty {\n  font-size: 14px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-empty:before {\n  color: #ba9d37;\n  content: \"•\";\n}\n.jasmine_html-reporter .jasmine-run-options {\n  float: right;\n  margin-right: 5px;\n  border: 1px solid #8a4182;\n  color: #8a4182;\n  position: relative;\n  line-height: 20px;\n}\n.jasmine_html-reporter .jasmine-run-options .jasmine-trigger {\n  cursor: pointer;\n  padding: 8px 16px;\n}\n.jasmine_html-reporter .jasmine-run-options .jasmine-payload {\n  position: absolute;\n  display: none;\n  right: -1px;\n  border: 1px solid #8a4182;\n  background-color: #eee;\n  white-space: nowrap;\n  padding: 4px 8px;\n}\n.jasmine_html-reporter .jasmine-run-options .jasmine-payload.jasmine-open {\n  display: block;\n}\n.jasmine_html-reporter .jasmine-bar {\n  line-height: 28px;\n  font-size: 14px;\n  display: block;\n  color: #eee;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-failed, .jasmine_html-reporter .jasmine-bar.jasmine-errored {\n  background-color: #ca3a11;\n  border-bottom: 1px solid #eee;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-passed {\n  background-color: #007069;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-incomplete {\n  background-color: #bababa;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-skipped {\n  background-color: #bababa;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-warning {\n  margin-top: 14px;\n  margin-bottom: 14px;\n  background-color: #ba9d37;\n  color: #333;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-menu {\n  background-color: #fff;\n  color: #aaa;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-menu a {\n  color: #333;\n}\n.jasmine_html-reporter .jasmine-bar a {\n  color: white;\n}\n.jasmine_html-reporter.jasmine-spec-list .jasmine-bar.jasmine-menu.jasmine-failure-list,\n.jasmine_html-reporter.jasmine-spec-list .jasmine-results .jasmine-failures {\n  display: none;\n}\n.jasmine_html-reporter.jasmine-failure-list .jasmine-bar.jasmine-menu.jasmine-spec-list,\n.jasmine_html-reporter.jasmine-failure-list .jasmine-summary {\n  display: none;\n}\n.jasmine_html-reporter .jasmine-results {\n  margin-top: 14px;\n}\n.jasmine_html-reporter .jasmine-summary {\n  margin-top: 14px;\n}\n.jasmine_html-reporter .jasmine-summary ul {\n  list-style-type: none;\n  margin-left: 14px;\n  padding-top: 0;\n  padding-left: 0;\n}\n.jasmine_html-reporter .jasmine-summary ul.jasmine-suite {\n  margin-top: 7px;\n  margin-bottom: 7px;\n}\n.jasmine_html-reporter .jasmine-summary li.jasmine-passed a {\n  color: #007069;\n}\n.jasmine_html-reporter .jasmine-summary li.jasmine-failed a {\n  color: #ca3a11;\n}\n.jasmine_html-reporter .jasmine-summary li.jasmine-empty a {\n  color: #ba9d37;\n}\n.jasmine_html-reporter .jasmine-summary li.jasmine-pending a {\n  color: #ba9d37;\n}\n.jasmine_html-reporter .jasmine-summary li.jasmine-excluded a {\n  color: #bababa;\n}\n.jasmine_html-reporter .jasmine-specs li.jasmine-passed a:before {\n  content: \"• \";\n}\n.jasmine_html-reporter .jasmine-specs li.jasmine-failed a:before {\n  content: \"× \";\n}\n.jasmine_html-reporter .jasmine-specs li.jasmine-empty a:before {\n  content: \"* \";\n}\n.jasmine_html-reporter .jasmine-specs li.jasmine-pending a:before {\n  content: \"• \";\n}\n.jasmine_html-reporter .jasmine-specs li.jasmine-excluded a:before {\n  content: \"• \";\n}\n.jasmine_html-reporter .jasmine-description + .jasmine-suite {\n  margin-top: 0;\n}\n.jasmine_html-reporter .jasmine-suite {\n  margin-top: 14px;\n}\n.jasmine_html-reporter .jasmine-suite a {\n  color: #333;\n}\n.jasmine_html-reporter .jasmine-failures .jasmine-spec-detail {\n  margin-bottom: 28px;\n}\n.jasmine_html-reporter .jasmine-failures .jasmine-spec-detail .jasmine-description {\n  background-color: #ca3a11;\n  color: white;\n}\n.jasmine_html-reporter .jasmine-failures .jasmine-spec-detail .jasmine-description a {\n  color: white;\n}\n.jasmine_html-reporter .jasmine-result-message {\n  padding-top: 14px;\n  color: #333;\n  white-space: pre-wrap;\n}\n.jasmine_html-reporter .jasmine-result-message span.jasmine-result {\n  display: block;\n}\n.jasmine_html-reporter .jasmine-stack-trace {\n  margin: 5px 0 0 0;\n  max-height: 224px;\n  overflow: auto;\n  line-height: 18px;\n  color: #666;\n  border: 1px solid #ddd;\n  background: white;\n  white-space: pre;\n}\n.jasmine_html-reporter .jasmine-expander a {\n  display: block;\n  margin-left: 14px;\n  color: blue;\n  text-decoration: underline;\n}\n.jasmine_html-reporter .jasmine-expander-contents {\n  display: none;\n}\n.jasmine_html-reporter .jasmine-expanded {\n  padding-bottom: 10px;\n}\n.jasmine_html-reporter .jasmine-expanded .jasmine-expander-contents {\n  display: block;\n  margin-left: 14px;\n  padding: 5px;\n}\n.jasmine_html-reporter .jasmine-debug-log {\n  margin: 5px 0 0 0;\n  padding: 5px;\n  color: #666;\n  border: 1px solid #ddd;\n  background: white;\n}\n.jasmine_html-reporter .jasmine-debug-log table {\n  border-spacing: 0;\n}\n.jasmine_html-reporter .jasmine-debug-log table, .jasmine_html-reporter .jasmine-debug-log th, .jasmine_html-reporter .jasmine-debug-log td {\n  border: 1px solid #ddd;\n}", "",{"version":3,"sources":["webpack://./node_modules/jasmine-core/lib/jasmine-core/jasmine.css"],"names":[],"mappings":"AAAA,gBAAgB;AAChB;EACE,kBAAkB;AACpB;;AAEA;EACE,WAAW;EACX,sBAAsB;EACtB,YAAY;EACZ,YAAY;EACZ,eAAe;EACf,gDAAgD;EAChD,iBAAiB;EACjB,WAAW;AACb;AACA;EACE,qBAAqB;AACvB;AACA;EACE,0BAA0B;AAC5B;AACA;EACE,SAAS;EACT,iBAAiB;AACnB;AACA;;;;;;;;EAQE,iBAAiB;EACjB,kBAAkB;AACpB;AACA;EACE,kBAAkB;AACpB;AACA;EACE,myEAAmyE;EACnyE,ikXAAikX;EACjkX,0BAA0B;EAC1B,wBAAwB;EACxB,6BAA6B;EAC7B,qBAAqB;EACrB,cAAc;EACd,WAAW;EACX,WAAW;EACX,YAAY;AACd;AACA;EACE,iBAAiB;EACjB,kBAAkB;EAClB,QAAQ;AACV;AACA;EACE,eAAe;EACf,WAAW;AACb;AACA;EACE,WAAW;AACb;AACA;EACE,gBAAgB;AAClB;AACA;EACE,WAAW;EACX,YAAY;EACZ,iBAAiB;EACjB,kBAAkB;AACpB;AACA;EACE,gBAAgB;EAChB,cAAc;AAChB;AACA;EACE,qBAAqB;EACrB,YAAY;EACZ,WAAW;EACX,eAAe;AACjB;AACA;EACE,eAAe;AACjB;AACA;EACE,cAAc;EACd,YAAY;AACd;AACA;EACE,gBAAgB;AAClB;AACA;EACE,cAAc;EACd,YAAY;EACZ,iBAAiB;EACjB,iBAAiB;AACnB;AACA;EACE,eAAe;AACjB;AACA;EACE,cAAc;EACd,YAAY;AACd;AACA;EACE,eAAe;EACf,aAAa;AACf;AACA;EACE,iBAAiB;AACnB;AACA;EACE,cAAc;EACd,YAAY;AACd;AACA;EACE,eAAe;AACjB;AACA;EACE,cAAc;EACd,YAAY;AACd;AACA;EACE,YAAY;EACZ,iBAAiB;EACjB,yBAAyB;EACzB,cAAc;EACd,kBAAkB;EAClB,iBAAiB;AACnB;AACA;EACE,eAAe;EACf,iBAAiB;AACnB;AACA;EACE,kBAAkB;EAClB,aAAa;EACb,WAAW;EACX,yBAAyB;EACzB,sBAAsB;EACtB,mBAAmB;EACnB,gBAAgB;AAClB;AACA;EACE,cAAc;AAChB;AACA;EACE,iBAAiB;EACjB,eAAe;EACf,cAAc;EACd,WAAW;AACb;AACA;EACE,yBAAyB;EACzB,6BAA6B;AAC/B;AACA;EACE,yBAAyB;AAC3B;AACA;EACE,yBAAyB;AAC3B;AACA;EACE,yBAAyB;AAC3B;AACA;EACE,gBAAgB;EAChB,mBAAmB;EACnB,yBAAyB;EACzB,WAAW;AACb;AACA;EACE,sBAAsB;EACtB,WAAW;AACb;AACA;EACE,WAAW;AACb;AACA;EACE,YAAY;AACd;AACA;;EAEE,aAAa;AACf;AACA;;EAEE,aAAa;AACf;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,qBAAqB;EACrB,iBAAiB;EACjB,cAAc;EACd,eAAe;AACjB;AACA;EACE,eAAe;EACf,kBAAkB;AACpB;AACA;EACE,cAAc;AAChB;AACA;EACE,cAAc;AAChB;AACA;EACE,cAAc;AAChB;AACA;EACE,cAAc;AAChB;AACA;EACE,cAAc;AAChB;AACA;EACE,aAAa;AACf;AACA;EACE,aAAa;AACf;AACA;EACE,aAAa;AACf;AACA;EACE,aAAa;AACf;AACA;EACE,aAAa;AACf;AACA;EACE,aAAa;AACf;AACA;EACE,gBAAgB;AAClB;AACA;EACE,WAAW;AACb;AACA;EACE,mBAAmB;AACrB;AACA;EACE,yBAAyB;EACzB,YAAY;AACd;AACA;EACE,YAAY;AACd;AACA;EACE,iBAAiB;EACjB,WAAW;EACX,qBAAqB;AACvB;AACA;EACE,cAAc;AAChB;AACA;EACE,iBAAiB;EACjB,iBAAiB;EACjB,cAAc;EACd,iBAAiB;EACjB,WAAW;EACX,sBAAsB;EACtB,iBAAiB;EACjB,gBAAgB;AAClB;AACA;EACE,cAAc;EACd,iBAAiB;EACjB,WAAW;EACX,0BAA0B;AAC5B;AACA;EACE,aAAa;AACf;AACA;EACE,oBAAoB;AACtB;AACA;EACE,cAAc;EACd,iBAAiB;EACjB,YAAY;AACd;AACA;EACE,iBAAiB;EACjB,YAAY;EACZ,WAAW;EACX,sBAAsB;EACtB,iBAAiB;AACnB;AACA;EACE,iBAAiB;AACnB;AACA;EACE,sBAAsB;AACxB","sourcesContent":["@charset \"UTF-8\";\nbody {\n  overflow-y: scroll;\n}\n\n.jasmine_html-reporter {\n  width: 100%;\n  background-color: #eee;\n  padding: 5px;\n  margin: -8px;\n  font-size: 11px;\n  font-family: Monaco, \"Lucida Console\", monospace;\n  line-height: 14px;\n  color: #333;\n}\n.jasmine_html-reporter a {\n  text-decoration: none;\n}\n.jasmine_html-reporter a:hover {\n  text-decoration: underline;\n}\n.jasmine_html-reporter p, .jasmine_html-reporter h1, .jasmine_html-reporter h2, .jasmine_html-reporter h3, .jasmine_html-reporter h4, .jasmine_html-reporter h5, .jasmine_html-reporter h6 {\n  margin: 0;\n  line-height: 14px;\n}\n.jasmine_html-reporter .jasmine-banner,\n.jasmine_html-reporter .jasmine-symbol-summary,\n.jasmine_html-reporter .jasmine-summary,\n.jasmine_html-reporter .jasmine-result-message,\n.jasmine_html-reporter .jasmine-spec .jasmine-description,\n.jasmine_html-reporter .jasmine-spec-detail .jasmine-description,\n.jasmine_html-reporter .jasmine-alert .jasmine-bar,\n.jasmine_html-reporter .jasmine-stack-trace {\n  padding-left: 9px;\n  padding-right: 9px;\n}\n.jasmine_html-reporter .jasmine-banner {\n  position: relative;\n}\n.jasmine_html-reporter .jasmine-banner .jasmine-title {\n  background: url(\"data:image/png;base64,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\") no-repeat;\n  background: url(\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgdmVyc2lvbj0iMS4xIgogICB3aWR0aD0iNjgxLjk2MjUyIgogICBoZWlnaHQ9IjE4Ny41IgogICBpZD0ic3ZnMiIKICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhOCI+PHJkZjpSREY+PGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPjxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PjxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz48L2NjOldvcms+PC9yZGY6UkRGPjwvbWV0YWRhdGE+PGRlZnMKICAgICBpZD0iZGVmczYiPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMTgiPjxwYXRoCiAgICAgICAgIGQ9Ik0gMCwxNTAwIDAsMCBsIDU0NTUuNzQsMCAwLDE1MDAgTCAwLDE1MDAgeiIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgaWQ9InBhdGgyMCIgLz48L2NsaXBQYXRoPjwvZGVmcz48ZwogICAgIHRyYW5zZm9ybT0ibWF0cml4KDEuMjUsMCwwLC0xLjI1LDAsMTg3LjUpIgogICAgIGlkPSJnMTAiPjxnCiAgICAgICB0cmFuc2Zvcm09InNjYWxlKDAuMSwwLjEpIgogICAgICAgaWQ9ImcxMiI+PGcKICAgICAgICAgaWQ9ImcxNCI+PGcKICAgICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGgxOCkiCiAgICAgICAgICAgaWQ9ImcxNiI+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMTU0NCw1OTkuNDM0IGMgMC45MiwtNDAuMzUyIDI1LjY4LC04MS42MDIgNzEuNTMsLTgxLjYwMiAyNy41MSwwIDQ3LjY4LDEyLjgzMiA2MS40NCwzNS43NTQgMTIuODMsMjIuOTMgMTIuODMsNTYuODUyIDEyLjgzLDgyLjUyNyBsIDAsMzI5LjE4NCAtNzEuNTIsMCAwLDEwNC41NDMgMjY2LjgzLDAgMCwtMTA0LjU0MyAtNzAuNiwwIDAsLTM0NC43NyBjIDAsLTU4LjY5MSAtMy42OCwtMTA0LjUzMSAtNDQuOTMsLTE1Mi4yMTggLTM2LjY4LC00Mi4xOCAtOTYuMjgsLTY2LjAyIC0xNTMuMTQsLTY2LjAyIC0xMTcuMzcsMCAtMjA3LjI0LDc3Ljk0MSAtMjAyLjY0LDE5Ny4xNDUgbCAxMzAuMiwwIgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMjIiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDIzMDEuNCw2NjIuNjk1IGMgMCw4MC43MDMgLTY2Ljk0LDE0NS44MTMgLTE0Ny42MywxNDUuODEzIC04My40NCwwIC0xNDcuNjMsLTY4Ljc4MSAtMTQ3LjYzLC0xNTEuMzAxIDAsLTc5Ljc4NSA2Ni45NCwtMTQ1LjgwMSAxNDUuOCwtMTQ1LjgwMSA4NC4zNSwwIDE0OS40Niw2Ny44NTIgMTQ5LjQ2LDE1MS4yODkgeiBtIC0xLjgzLC0xODEuNTQ3IGMgLTM1Ljc3LC01NC4wOTcgLTkzLjUzLC03OC44NTkgLTE1Ny43MiwtNzguODU5IC0xNDAuMywwIC0yNTEuMjQsMTE2LjQ0OSAtMjUxLjI0LDI1NC45MTggMCwxNDIuMTI5IDExMy43LDI2MC40MSAyNTYuNzQsMjYwLjQxIDYzLjI3LDAgMTE4LjI5LC0yOS4zMzYgMTUyLjIyLC04Mi41MjMgbCAwLDY5LjY4NyAxNzUuMTQsMCAwLC0xMDQuNTI3IC02MS40NCwwIDAsLTI4MC41OTggNjEuNDQsMCAwLC0xMDQuNTI3IC0xNzUuMTQsMCAwLDY2LjAxOSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDI0IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSAyNjIyLjMzLDU1Ny4yNTggYyAzLjY3LC00NC4wMTYgMzMuMDEsLTczLjM0OCA3OC44NiwtNzMuMzQ4IDMzLjkzLDAgNjYuOTMsMjMuODI0IDY2LjkzLDYwLjUwNCAwLDQ4LjYwNiAtNDUuODQsNTYuODU2IC04My40NCw2Ni45NDEgLTg1LjI4LDIyLjAwNCAtMTc4LjgxLDQ4LjYwNiAtMTc4LjgxLDE1NS44NzkgMCw5My41MzYgNzguODYsMTQ3LjYzMyAxNjUuOTgsMTQ3LjYzMyA0NCwwIDgzLjQzLC05LjE3NiAxMTAuOTQsLTQ0LjAwOCBsIDAsMzMuOTIyIDgyLjUzLDAgMCwtMTMyLjk2NSAtMTA4LjIxLDAgYyAtMS44MywzNC44NTYgLTI4LjQyLDU3Ljc3NCAtNjMuMjYsNTcuNzc0IC0zMC4yNiwwIC02Mi4zNSwtMTcuNDIyIC02Mi4zNSwtNTEuMzQ4IDAsLTQ1Ljg0NyA0NC45MywtNTUuOTMgODAuNjksLTY0LjE4IDg4LjAyLC0yMC4xNzUgMTgyLjQ3LC00Ny42OTUgMTgyLjQ3LC0xNTcuNzM0IDAsLTk5LjAyNyAtODMuNDQsLTE1NC4wMzkgLTE3NS4xMywtMTU0LjAzOSAtNDkuNTMsMCAtOTQuNDYsMTUuNTgyIC0xMjYuNTUsNTMuMTggbCAwLC00MC4zNCAtODUuMjcsMCAwLDE0Mi4xMjkgMTE0LjYyLDAiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGgyNiIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMjk4OC4xOCw4MDAuMjU0IC02My4yNiwwIDAsMTA0LjUyNyAxNjUuMDUsMCAwLC03My4zNTUgYyAzMS4xOCw1MS4zNDcgNzguODYsODUuMjc3IDE0MS4yMSw4NS4yNzcgNjcuODUsMCAxMjQuNzEsLTQxLjI1OCAxNTIuMjEsLTEwMi42OTkgMjYuNiw2Mi4zNTEgOTIuNjIsMTAyLjY5OSAxNjAuNDcsMTAyLjY5OSA1My4xOSwwIDEwNS40NiwtMjIgMTQxLjIxLC02Mi4zNTEgMzguNTIsLTQ0LjkzOCAzOC41MiwtOTMuNTMyIDM4LjUyLC0xNDkuNDU3IGwgMCwtMTg1LjIzOSA2My4yNywwIDAsLTEwNC41MjcgLTIzOC40MiwwIDAsMTA0LjUyNyA2My4yOCwwIDAsMTU3LjcxNSBjIDAsMzIuMTAyIDAsNjAuNTI3IC0xNC42Nyw4OC45NTcgLTE4LjM0LDI2LjU4MiAtNDguNjEsNDAuMzQ0IC03OS43Nyw0MC4zNDQgLTMwLjI2LDAgLTYzLjI4LC0xMi44NDQgLTgyLjUzLC0zNi42NzIgLTIyLjkzLC0yOS4zNTUgLTIyLjkzLC01Ni44NjMgLTIyLjkzLC05Mi42MjkgbCAwLC0xNTcuNzE1IDYzLjI3LDAgMCwtMTA0LjUyNyAtMjM4LjQxLDAgMCwxMDQuNTI3IDYzLjI4LDAgMCwxNTAuMzgzIGMgMCwyOS4zNDggMCw2Ni4wMjMgLTE0LjY3LDkxLjY5OSAtMTUuNTksMjkuMzM2IC00Ny42OSw0NC45MzQgLTgwLjcsNDQuOTM0IC0zMS4xOCwwIC01Ny43NywtMTEuMDA4IC03Ny45NCwtMzUuNzc0IC0yNC43NywtMzAuMjUzIC0yNi42LC02Mi4zNDMgLTI2LjYsLTk5Ljk0MSBsIDAsLTE1MS4zMDEgNjMuMjcsMCAwLC0xMDQuNTI3IC0yMzguNCwwIDAsMTA0LjUyNyA2My4yNiwwIDAsMjgwLjU5OCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDI4IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSAzOTk4LjY2LDk1MS41NDcgLTExMS44NywwIDAsMTE4LjI5MyAxMTEuODcsMCAwLC0xMTguMjkzIHogbSAwLC00MzEuODkxIDYzLjI3LDAgMCwtMTA0LjUyNyAtMjM5LjMzLDAgMCwxMDQuNTI3IDY0LjE5LDAgMCwyODAuNTk4IC02My4yNywwIDAsMTA0LjUyNyAxNzUuMTQsMCAwLC0zODUuMTI1IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzAiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDQxNTkuMTIsODAwLjI1NCAtNjMuMjcsMCAwLDEwNC41MjcgMTc1LjE0LDAgMCwtNjkuNjg3IGMgMjkuMzUsNTQuMTAxIDg0LjM2LDgwLjY5OSAxNDQuODcsODAuNjk5IDUzLjE5LDAgMTA1LjQ1LC0yMi4wMTYgMTQxLjIyLC02MC41MjcgNDAuMzQsLTQ0LjkzNCA0MS4yNiwtODguMDMyIDQxLjI2LC0xNDMuOTU3IGwgMCwtMTkxLjY1MyA2My4yNywwIDAsLTEwNC41MjcgLTIzOC40LDAgMCwxMDQuNTI3IDYzLjI2LDAgMCwxNTguNjM3IGMgMCwzMC4yNjIgMCw2MS40MzQgLTE5LjI2LDg4LjAzNSAtMjAuMTcsMjYuNTgyIC01My4xOCwzOS40MTQgLTg2LjE5LDM5LjQxNCAtMzMuOTMsMCAtNjguNzcsLTEzLjc1IC04OC45NCwtNDEuMjUgLTIxLjA5LC0yNy41IC0yMS4wOSwtNjkuNjg3IC0yMS4wOSwtMTAyLjcwNyBsIDAsLTE0Mi4xMjkgNjMuMjYsMCAwLC0xMDQuNTI3IC0yMzguNCwwIDAsMTA0LjUyNyA2My4yNywwIDAsMjgwLjU5OCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDMyIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA1MDgyLjQ4LDcwMy45NjUgYyAtMTkuMjQsNzAuNjA1IC04MS42LDExNS41NDcgLTE1NC4wNCwxMTUuNTQ3IC02Ni4wNCwwIC0xMjkuMywtNTEuMzQ4IC0xNDMuMDUsLTExNS41NDcgbCAyOTcuMDksMCB6IG0gODUuMjcsLTE0NC44ODMgYyAtMzguNTEsLTkzLjUyMyAtMTI5LjI3LC0xNTYuNzkzIC0yMzEuMDUsLTE1Ni43OTMgLTE0My4wNywwIC0yNTcuNjgsMTExLjg3MSAtMjU3LjY4LDI1NS44MzYgMCwxNDQuODgzIDEwOS4xMiwyNjEuMzI4IDI1NC45MSwyNjEuMzI4IDY3Ljg3LDAgMTM1LjcyLC0zMC4yNTggMTgzLjM5LC03OC44NjMgNDguNjIsLTUxLjM0NCA2OC43OSwtMTEzLjY5NSA2OC43OSwtMTgzLjM4MyBsIC0zLjY3LC0zOS40MzQgLTM5Ni4xMywwIGMgMTQuNjcsLTY3Ljg2MyA3Ny4wMywtMTE3LjM2MyAxNDYuNzIsLTExNy4zNjMgNDguNTksMCA5MC43NiwxOC4zMjggMTE4LjI4LDU4LjY3MiBsIDExNi40NCwwIgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzQiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDY5MC44OTUsODUwLjcwMyA5MC43NSwwIDIyLjU0MywzMS4wMzUgMCwyNDMuMTIyIC0xMzUuODI5LDAgMCwtMjQzLjE0MSAyMi41MzYsLTMxLjAxNiIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDM2IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA2MzIuMzk1LDc0Mi4yNTggMjguMDM5LDg2LjMwNCAtMjIuNTUxLDMxLjA0IC0yMzEuMjIzLDc1LjEyOCAtNDEuOTc2LC0xMjkuMTgzIDIzMS4yNTcsLTc1LjEzNyAzNi40NTQsMTEuODQ4IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzgiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDcxNy40NDksNjUzLjEwNSAtNzMuNDEsNTMuMzYgLTM2LjQ4OCwtMTEuODc1IC0xNDIuOTAzLC0xOTYuNjkyIDEwOS44ODMsLTc5LjgyOCAxNDIuOTE4LDE5Ni43MDMgMCwzOC4zMzIiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGg0MCIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gODI4LjUyLDcwNi40NjUgLTczLjQyNiwtNTMuMzQgMC4wMTEsLTM4LjM1OSBMIDg5OC4wMDQsNDE4LjA3IDEwMDcuOSw0OTcuODk4IDg2NC45NzMsNjk0LjYwOSA4MjguNTIsNzA2LjQ2NSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDQyIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA4MTIuMDg2LDgyOC41ODYgMjguMDU1LC04Ni4zMiAzNi40ODQsLTExLjgzNiAyMzEuMjI1LDc1LjExNyAtNDEuOTcsMTI5LjE4MyAtMjMxLjIzOSwtNzUuMTQgLTIyLjU1NSwtMzEuMDA0IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNDQiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDczNi4zMDEsMTMzNS44OCBjIC0zMjMuMDQ3LDAgLTU4NS44NzUsLTI2Mi43OCAtNTg1Ljg3NSwtNTg1Ljc4MiAwLC0zMjMuMTE4IDI2Mi44MjgsLTU4NS45NzcgNTg1Ljg3NSwtNTg1Ljk3NyAzMjMuMDE5LDAgNTg1LjgwOSwyNjIuODU5IDU4NS44MDksNTg1Ljk3NyAwLDMyMy4wMDIgLTI2Mi43OSw1ODUuNzgyIC01ODUuODA5LDU4NS43ODIgbCAwLDAgeiBtIDAsLTExOC42MSBjIDI1Ny45NzIsMCA0NjcuMTg5LC0yMDkuMTMgNDY3LjE4OSwtNDY3LjE3MiAwLC0yNTguMTI5IC0yMDkuMjE3LC00NjcuMzQ4IC00NjcuMTg5LC00NjcuMzQ4IC0yNTguMDc0LDAgLTQ2Ny4yNTQsMjA5LjIxOSAtNDY3LjI1NCw0NjcuMzQ4IDAsMjU4LjA0MiAyMDkuMTgsNDY3LjE3MiA0NjcuMjU0LDQ2Ny4xNzIiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGg0NiIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMTA5MS4xMyw2MTkuODgzIC0xNzUuNzcxLDU3LjEyMSAxMS42MjksMzUuODA4IDE3NS43NjIsLTU3LjEyMSAtMTEuNjIsLTM1LjgwOCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDQ4IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0iTSA4NjYuOTU3LDkwMi4wNzQgODM2LjUsOTI0LjE5OSA5NDUuMTIxLDEwNzMuNzMgOTc1LjU4NiwxMDUxLjYxIDg2Ni45NTcsOTAyLjA3NCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDUwIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0iTSA2MDcuNDY1LDkwMy40NDUgNDk4Ljg1NSwxMDUyLjk3IDUyOS4zMiwxMDc1LjEgNjM3LjkzLDkyNS41NjYgNjA3LjQ2NSw5MDMuNDQ1IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNTIiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDM4MC42ODgsNjIyLjEyOSAtMTEuNjI2LDM1LjgwMSAxNzUuNzU4LDU3LjA5IDExLjYyMSwtMzUuODAxIC0xNzUuNzUzLC01Ny4wOSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDU0IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA3MTYuMjg5LDM3Ni41OSAzNy42NDA2LDAgMCwxODQuODE2IC0zNy42NDA2LDAgMCwtMTg0LjgxNiB6IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNTYiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjwvZz48L2c+PC9nPjwvZz48L3N2Zz4=\") no-repeat, none;\n  -moz-background-size: 100%;\n  -o-background-size: 100%;\n  -webkit-background-size: 100%;\n  background-size: 100%;\n  display: block;\n  float: left;\n  width: 90px;\n  height: 25px;\n}\n.jasmine_html-reporter .jasmine-banner .jasmine-version {\n  margin-left: 14px;\n  position: relative;\n  top: 6px;\n}\n.jasmine_html-reporter #jasmine_content {\n  position: fixed;\n  right: 100%;\n}\n.jasmine_html-reporter .jasmine-version {\n  color: #aaa;\n}\n.jasmine_html-reporter .jasmine-banner {\n  margin-top: 14px;\n}\n.jasmine_html-reporter .jasmine-duration {\n  color: #fff;\n  float: right;\n  line-height: 28px;\n  padding-right: 9px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary {\n  overflow: hidden;\n  margin: 14px 0;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li {\n  display: inline-block;\n  height: 10px;\n  width: 14px;\n  font-size: 16px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-passed {\n  font-size: 14px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-passed:before {\n  color: #007069;\n  content: \"•\";\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-failed {\n  line-height: 9px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-failed:before {\n  color: #ca3a11;\n  content: \"×\";\n  font-weight: bold;\n  margin-left: -1px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-excluded {\n  font-size: 14px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-excluded:before {\n  color: #bababa;\n  content: \"•\";\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-excluded-no-display {\n  font-size: 14px;\n  display: none;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-pending {\n  line-height: 17px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-pending:before {\n  color: #ba9d37;\n  content: \"*\";\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-empty {\n  font-size: 14px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-empty:before {\n  color: #ba9d37;\n  content: \"•\";\n}\n.jasmine_html-reporter .jasmine-run-options {\n  float: right;\n  margin-right: 5px;\n  border: 1px solid #8a4182;\n  color: #8a4182;\n  position: relative;\n  line-height: 20px;\n}\n.jasmine_html-reporter .jasmine-run-options .jasmine-trigger {\n  cursor: pointer;\n  padding: 8px 16px;\n}\n.jasmine_html-reporter .jasmine-run-options .jasmine-payload {\n  position: absolute;\n  display: none;\n  right: -1px;\n  border: 1px solid #8a4182;\n  background-color: #eee;\n  white-space: nowrap;\n  padding: 4px 8px;\n}\n.jasmine_html-reporter .jasmine-run-options .jasmine-payload.jasmine-open {\n  display: block;\n}\n.jasmine_html-reporter .jasmine-bar {\n  line-height: 28px;\n  font-size: 14px;\n  display: block;\n  color: #eee;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-failed, .jasmine_html-reporter .jasmine-bar.jasmine-errored {\n  background-color: #ca3a11;\n  border-bottom: 1px solid #eee;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-passed {\n  background-color: #007069;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-incomplete {\n  background-color: #bababa;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-skipped {\n  background-color: #bababa;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-warning {\n  margin-top: 14px;\n  margin-bottom: 14px;\n  background-color: #ba9d37;\n  color: #333;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-menu {\n  background-color: #fff;\n  color: #aaa;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-menu a {\n  color: #333;\n}\n.jasmine_html-reporter .jasmine-bar a {\n  color: white;\n}\n.jasmine_html-reporter.jasmine-spec-list .jasmine-bar.jasmine-menu.jasmine-failure-list,\n.jasmine_html-reporter.jasmine-spec-list .jasmine-results .jasmine-failures {\n  display: none;\n}\n.jasmine_html-reporter.jasmine-failure-list .jasmine-bar.jasmine-menu.jasmine-spec-list,\n.jasmine_html-reporter.jasmine-failure-list .jasmine-summary {\n  display: none;\n}\n.jasmine_html-reporter .jasmine-results {\n  margin-top: 14px;\n}\n.jasmine_html-reporter .jasmine-summary {\n  margin-top: 14px;\n}\n.jasmine_html-reporter .jasmine-summary ul {\n  list-style-type: none;\n  margin-left: 14px;\n  padding-top: 0;\n  padding-left: 0;\n}\n.jasmine_html-reporter .jasmine-summary ul.jasmine-suite {\n  margin-top: 7px;\n  margin-bottom: 7px;\n}\n.jasmine_html-reporter .jasmine-summary li.jasmine-passed a {\n  color: #007069;\n}\n.jasmine_html-reporter .jasmine-summary li.jasmine-failed a {\n  color: #ca3a11;\n}\n.jasmine_html-reporter .jasmine-summary li.jasmine-empty a {\n  color: #ba9d37;\n}\n.jasmine_html-reporter .jasmine-summary li.jasmine-pending a {\n  color: #ba9d37;\n}\n.jasmine_html-reporter .jasmine-summary li.jasmine-excluded a {\n  color: #bababa;\n}\n.jasmine_html-reporter .jasmine-specs li.jasmine-passed a:before {\n  content: \"• \";\n}\n.jasmine_html-reporter .jasmine-specs li.jasmine-failed a:before {\n  content: \"× \";\n}\n.jasmine_html-reporter .jasmine-specs li.jasmine-empty a:before {\n  content: \"* \";\n}\n.jasmine_html-reporter .jasmine-specs li.jasmine-pending a:before {\n  content: \"• \";\n}\n.jasmine_html-reporter .jasmine-specs li.jasmine-excluded a:before {\n  content: \"• \";\n}\n.jasmine_html-reporter .jasmine-description + .jasmine-suite {\n  margin-top: 0;\n}\n.jasmine_html-reporter .jasmine-suite {\n  margin-top: 14px;\n}\n.jasmine_html-reporter .jasmine-suite a {\n  color: #333;\n}\n.jasmine_html-reporter .jasmine-failures .jasmine-spec-detail {\n  margin-bottom: 28px;\n}\n.jasmine_html-reporter .jasmine-failures .jasmine-spec-detail .jasmine-description {\n  background-color: #ca3a11;\n  color: white;\n}\n.jasmine_html-reporter .jasmine-failures .jasmine-spec-detail .jasmine-description a {\n  color: white;\n}\n.jasmine_html-reporter .jasmine-result-message {\n  padding-top: 14px;\n  color: #333;\n  white-space: pre-wrap;\n}\n.jasmine_html-reporter .jasmine-result-message span.jasmine-result {\n  display: block;\n}\n.jasmine_html-reporter .jasmine-stack-trace {\n  margin: 5px 0 0 0;\n  max-height: 224px;\n  overflow: auto;\n  line-height: 18px;\n  color: #666;\n  border: 1px solid #ddd;\n  background: white;\n  white-space: pre;\n}\n.jasmine_html-reporter .jasmine-expander a {\n  display: block;\n  margin-left: 14px;\n  color: blue;\n  text-decoration: underline;\n}\n.jasmine_html-reporter .jasmine-expander-contents {\n  display: none;\n}\n.jasmine_html-reporter .jasmine-expanded {\n  padding-bottom: 10px;\n}\n.jasmine_html-reporter .jasmine-expanded .jasmine-expander-contents {\n  display: block;\n  margin-left: 14px;\n  padding: 5px;\n}\n.jasmine_html-reporter .jasmine-debug-log {\n  margin: 5px 0 0 0;\n  padding: 5px;\n  color: #666;\n  border: 1px solid #ddd;\n  background: white;\n}\n.jasmine_html-reporter .jasmine-debug-log table {\n  border-spacing: 0;\n}\n.jasmine_html-reporter .jasmine-debug-log table, .jasmine_html-reporter .jasmine-debug-log th, .jasmine_html-reporter .jasmine-debug-log td {\n  border: 1px solid #ddd;\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";

      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }

      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }

      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }

      content += cssWithMappingToString(item);

      if (needLayer) {
        content += "}";
      }

      if (item[2]) {
        content += "}";
      }

      if (item[4]) {
        content += "}";
      }

      return content;
    }).join("");
  }; // import a list of modules into the list


  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }

      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }

      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }

      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/jasmine-core/lib/jasmine-core/boot0.js":
/*!*************************************************************!*\
  !*** ./node_modules/jasmine-core/lib/jasmine-core/boot0.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/*
Copyright (c) 2008-2022 Pivotal Labs

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
/**
 This file starts the process of "booting" Jasmine. It initializes Jasmine,
 makes its globals available, and creates the env. This file should be loaded
 after `jasmine.js` and `jasmine_html.js`, but before `boot1.js` or any project
 source files or spec files are loaded.
 */
(function() {
  var jasmineRequire = window.jasmineRequire || __webpack_require__(/*! ./jasmine.js */ "./node_modules/jasmine-core/lib/jasmine-core/jasmine.js");

  /**
   * ## Require &amp; Instantiate
   *
   * Require Jasmine's core files. Specifically, this requires and attaches all of Jasmine's code to the `jasmine` reference.
   */
  var jasmine = jasmineRequire.core(jasmineRequire),
    global = jasmine.getGlobal();
  global.jasmine = jasmine;

  /**
   * Since this is being run in a browser and the results should populate to an HTML page, require the HTML-specific Jasmine code, injecting the same reference.
   */
  jasmineRequire.html(jasmine);

  /**
   * Create the Jasmine environment. This is used to run all specs in a project.
   */
  var env = jasmine.getEnv();

  /**
   * ## The Global Interface
   *
   * Build up the functions that will be exposed as the Jasmine public interface. A project can customize, rename or alias any of these functions as desired, provided the implementation remains unchanged.
   */
  var jasmineInterface = jasmineRequire.interface(jasmine, env);

  /**
   * Add all of the Jasmine global/public interface to the global scope, so a project can use the public interface directly. For example, calling `describe` in specs instead of `jasmine.getEnv().describe`.
   */
  for (var property in jasmineInterface) {
    global[property] = jasmineInterface[property];
  }
})();


/***/ }),

/***/ "./node_modules/jasmine-core/lib/jasmine-core/boot1.js":
/*!*************************************************************!*\
  !*** ./node_modules/jasmine-core/lib/jasmine-core/boot1.js ***!
  \*************************************************************/
/***/ (() => {

/*
Copyright (c) 2008-2022 Pivotal Labs

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
/**
 This file finishes 'booting' Jasmine, performing all of the necessary
 initialization before executing the loaded environment and all of a project's
 specs. This file should be loaded after `boot0.js` but before any project
 source files or spec files are loaded. Thus this file can also be used to
 customize Jasmine for a project.

 If a project is using Jasmine via the standalone distribution, this file can
 be customized directly. If you only wish to configure the Jasmine env, you
 can load another file that calls `jasmine.getEnv().configure({...})`
 after `boot0.js` is loaded and before this file is loaded.
 */

(function() {
  var env = jasmine.getEnv();

  /**
   * ## Runner Parameters
   *
   * More browser specific code - wrap the query string in an object and to allow for getting/setting parameters from the runner user interface.
   */

  var queryString = new jasmine.QueryString({
    getWindowLocation: function() {
      return window.location;
    }
  });

  var filterSpecs = !!queryString.getParam('spec');

  var config = {
    stopOnSpecFailure: queryString.getParam('stopOnSpecFailure'),
    stopSpecOnExpectationFailure: queryString.getParam(
      'stopSpecOnExpectationFailure'
    ),
    hideDisabled: queryString.getParam('hideDisabled')
  };

  var random = queryString.getParam('random');

  if (random !== undefined && random !== '') {
    config.random = random;
  }

  var seed = queryString.getParam('seed');
  if (seed) {
    config.seed = seed;
  }

  /**
   * ## Reporters
   * The `HtmlReporter` builds all of the HTML UI for the runner page. This reporter paints the dots, stars, and x's for specs, as well as all spec names and all failures (if any).
   */
  var htmlReporter = new jasmine.HtmlReporter({
    env: env,
    navigateWithNewParam: function(key, value) {
      return queryString.navigateWithNewParam(key, value);
    },
    addToExistingQueryString: function(key, value) {
      return queryString.fullStringWithNewParam(key, value);
    },
    getContainer: function() {
      return document.body;
    },
    createElement: function() {
      return document.createElement.apply(document, arguments);
    },
    createTextNode: function() {
      return document.createTextNode.apply(document, arguments);
    },
    timer: new jasmine.Timer(),
    filterSpecs: filterSpecs
  });

  /**
   * The `jsApiReporter` also receives spec results, and is used by any environment that needs to extract the results  from JavaScript.
   */
  env.addReporter(jsApiReporter);
  env.addReporter(htmlReporter);

  /**
   * Filter which specs will be run by matching the start of the full name against the `spec` query param.
   */
  var specFilter = new jasmine.HtmlSpecFilter({
    filterString: function() {
      return queryString.getParam('spec');
    }
  });

  config.specFilter = function(spec) {
    return specFilter.matches(spec.getFullName());
  };

  env.configure(config);

  /**
   * ## Execution
   *
   * Replace the browser window's `onload`, ensure it's called, and then run all of the loaded specs. This includes initializing the `HtmlReporter` instance and then executing the loaded Jasmine environment. All of this will happen after all of the specs are loaded.
   */
  var currentWindowOnload = window.onload;

  window.onload = function() {
    if (currentWindowOnload) {
      currentWindowOnload();
    }
    htmlReporter.initialize();
    env.execute();
  };
})();


/***/ }),

/***/ "./node_modules/jasmine-core/lib/jasmine-core/jasmine-html.js":
/*!********************************************************************!*\
  !*** ./node_modules/jasmine-core/lib/jasmine-core/jasmine-html.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/*
Copyright (c) 2008-2022 Pivotal Labs

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
var jasmineRequire = window.jasmineRequire || __webpack_require__(/*! ./jasmine.js */ "./node_modules/jasmine-core/lib/jasmine-core/jasmine.js");

jasmineRequire.html = function(j$) {
  j$.ResultsNode = jasmineRequire.ResultsNode();
  j$.HtmlReporter = jasmineRequire.HtmlReporter(j$);
  j$.QueryString = jasmineRequire.QueryString();
  j$.HtmlSpecFilter = jasmineRequire.HtmlSpecFilter();
};

jasmineRequire.HtmlReporter = function(j$) {
  function ResultsStateBuilder() {
    this.topResults = new j$.ResultsNode({}, '', null);
    this.currentParent = this.topResults;
    this.specsExecuted = 0;
    this.failureCount = 0;
    this.pendingSpecCount = 0;
  }

  ResultsStateBuilder.prototype.suiteStarted = function(result) {
    this.currentParent.addChild(result, 'suite');
    this.currentParent = this.currentParent.last();
  };

  ResultsStateBuilder.prototype.suiteDone = function(result) {
    this.currentParent.updateResult(result);
    if (this.currentParent !== this.topResults) {
      this.currentParent = this.currentParent.parent;
    }

    if (result.status === 'failed') {
      this.failureCount++;
    }
  };

  ResultsStateBuilder.prototype.specStarted = function(result) {};

  ResultsStateBuilder.prototype.specDone = function(result) {
    this.currentParent.addChild(result, 'spec');

    if (result.status !== 'excluded') {
      this.specsExecuted++;
    }

    if (result.status === 'failed') {
      this.failureCount++;
    }

    if (result.status == 'pending') {
      this.pendingSpecCount++;
    }
  };

  ResultsStateBuilder.prototype.jasmineDone = function(result) {
    if (result.failedExpectations) {
      this.failureCount += result.failedExpectations.length;
    }
  };

  function HtmlReporter(options) {
    var config = function() {
        return (options.env && options.env.configuration()) || {};
      },
      getContainer = options.getContainer,
      createElement = options.createElement,
      createTextNode = options.createTextNode,
      navigateWithNewParam = options.navigateWithNewParam || function() {},
      addToExistingQueryString =
        options.addToExistingQueryString || defaultQueryString,
      filterSpecs = options.filterSpecs,
      htmlReporterMain,
      symbols,
      deprecationWarnings = [];

    this.initialize = function() {
      clearPrior();
      htmlReporterMain = createDom(
        'div',
        { className: 'jasmine_html-reporter' },
        createDom(
          'div',
          { className: 'jasmine-banner' },
          createDom('a', {
            className: 'jasmine-title',
            href: 'http://jasmine.github.io/',
            target: '_blank'
          }),
          createDom('span', { className: 'jasmine-version' }, j$.version)
        ),
        createDom('ul', { className: 'jasmine-symbol-summary' }),
        createDom('div', { className: 'jasmine-alert' }),
        createDom(
          'div',
          { className: 'jasmine-results' },
          createDom('div', { className: 'jasmine-failures' })
        )
      );
      getContainer().appendChild(htmlReporterMain);
    };

    var totalSpecsDefined;
    this.jasmineStarted = function(options) {
      totalSpecsDefined = options.totalSpecsDefined || 0;
    };

    var summary = createDom('div', { className: 'jasmine-summary' });

    var stateBuilder = new ResultsStateBuilder();

    this.suiteStarted = function(result) {
      stateBuilder.suiteStarted(result);
    };

    this.suiteDone = function(result) {
      stateBuilder.suiteDone(result);

      if (result.status === 'failed') {
        failures.push(failureDom(result));
      }
      addDeprecationWarnings(result, 'suite');
    };

    this.specStarted = function(result) {
      stateBuilder.specStarted(result);
    };

    var failures = [];
    this.specDone = function(result) {
      stateBuilder.specDone(result);

      if (noExpectations(result)) {
        var noSpecMsg = "Spec '" + result.fullName + "' has no expectations.";
        if (result.status === 'failed') {
          console.error(noSpecMsg);
        } else {
          console.warn(noSpecMsg);
        }
      }

      if (!symbols) {
        symbols = find('.jasmine-symbol-summary');
      }

      symbols.appendChild(
        createDom('li', {
          className: this.displaySpecInCorrectFormat(result),
          id: 'spec_' + result.id,
          title: result.fullName
        })
      );

      if (result.status === 'failed') {
        failures.push(failureDom(result));
      }

      addDeprecationWarnings(result, 'spec');
    };

    this.displaySpecInCorrectFormat = function(result) {
      return noExpectations(result) && result.status === 'passed'
        ? 'jasmine-empty'
        : this.resultStatus(result.status);
    };

    this.resultStatus = function(status) {
      if (status === 'excluded') {
        return config().hideDisabled
          ? 'jasmine-excluded-no-display'
          : 'jasmine-excluded';
      }
      return 'jasmine-' + status;
    };

    this.jasmineDone = function(doneResult) {
      stateBuilder.jasmineDone(doneResult);
      var banner = find('.jasmine-banner');
      var alert = find('.jasmine-alert');
      var order = doneResult && doneResult.order;
      var i;
      alert.appendChild(
        createDom(
          'span',
          { className: 'jasmine-duration' },
          'finished in ' + doneResult.totalTime / 1000 + 's'
        )
      );

      banner.appendChild(optionsMenu(config()));

      if (stateBuilder.specsExecuted < totalSpecsDefined) {
        var skippedMessage =
          'Ran ' +
          stateBuilder.specsExecuted +
          ' of ' +
          totalSpecsDefined +
          ' specs - run all';
        // include window.location.pathname to fix issue with karma-jasmine-html-reporter in angular: see https://github.com/jasmine/jasmine/issues/1906
        var skippedLink =
          (window.location.pathname || '') +
          addToExistingQueryString('spec', '');
        alert.appendChild(
          createDom(
            'span',
            { className: 'jasmine-bar jasmine-skipped' },
            createDom(
              'a',
              { href: skippedLink, title: 'Run all specs' },
              skippedMessage
            )
          )
        );
      }
      var statusBarMessage = '';
      var statusBarClassName = 'jasmine-overall-result jasmine-bar ';
      var globalFailures = (doneResult && doneResult.failedExpectations) || [];
      var failed = stateBuilder.failureCount + globalFailures.length > 0;

      if (totalSpecsDefined > 0 || failed) {
        statusBarMessage +=
          pluralize('spec', stateBuilder.specsExecuted) +
          ', ' +
          pluralize('failure', stateBuilder.failureCount);
        if (stateBuilder.pendingSpecCount) {
          statusBarMessage +=
            ', ' + pluralize('pending spec', stateBuilder.pendingSpecCount);
        }
      }

      if (doneResult.overallStatus === 'passed') {
        statusBarClassName += ' jasmine-passed ';
      } else if (doneResult.overallStatus === 'incomplete') {
        statusBarClassName += ' jasmine-incomplete ';
        statusBarMessage =
          'Incomplete: ' +
          doneResult.incompleteReason +
          ', ' +
          statusBarMessage;
      } else {
        statusBarClassName += ' jasmine-failed ';
      }

      var seedBar;
      if (order && order.random) {
        seedBar = createDom(
          'span',
          { className: 'jasmine-seed-bar' },
          ', randomized with seed ',
          createDom(
            'a',
            {
              title: 'randomized with seed ' + order.seed,
              href: seedHref(order.seed)
            },
            order.seed
          )
        );
      }

      alert.appendChild(
        createDom(
          'span',
          { className: statusBarClassName },
          statusBarMessage,
          seedBar
        )
      );

      var errorBarClassName = 'jasmine-bar jasmine-errored';
      var afterAllMessagePrefix = 'AfterAll ';

      for (i = 0; i < globalFailures.length; i++) {
        alert.appendChild(
          createDom(
            'span',
            { className: errorBarClassName },
            globalFailureMessage(globalFailures[i])
          )
        );
      }

      function globalFailureMessage(failure) {
        if (failure.globalErrorType === 'load') {
          var prefix = 'Error during loading: ' + failure.message;

          if (failure.filename) {
            return (
              prefix + ' in ' + failure.filename + ' line ' + failure.lineno
            );
          } else {
            return prefix;
          }
        } else if (failure.globalErrorType === 'afterAll') {
          return afterAllMessagePrefix + failure.message;
        } else {
          return failure.message;
        }
      }

      addDeprecationWarnings(doneResult);

      for (i = 0; i < deprecationWarnings.length; i++) {
        var children = [],
          context;

        switch (deprecationWarnings[i].runnableType) {
          case 'spec':
            context = '(in spec: ' + deprecationWarnings[i].runnableName + ')';
            break;
          case 'suite':
            context = '(in suite: ' + deprecationWarnings[i].runnableName + ')';
            break;
          default:
            context = '';
        }

        deprecationWarnings[i].message.split('\n').forEach(function(line) {
          children.push(line);
          children.push(createDom('br'));
        });

        children[0] = 'DEPRECATION: ' + children[0];
        children.push(context);

        if (deprecationWarnings[i].stack) {
          children.push(createExpander(deprecationWarnings[i].stack));
        }

        alert.appendChild(
          createDom(
            'span',
            { className: 'jasmine-bar jasmine-warning' },
            children
          )
        );
      }

      var results = find('.jasmine-results');
      results.appendChild(summary);

      summaryList(stateBuilder.topResults, summary);

      if (failures.length) {
        alert.appendChild(
          createDom(
            'span',
            { className: 'jasmine-menu jasmine-bar jasmine-spec-list' },
            createDom('span', {}, 'Spec List | '),
            createDom(
              'a',
              { className: 'jasmine-failures-menu', href: '#' },
              'Failures'
            )
          )
        );
        alert.appendChild(
          createDom(
            'span',
            { className: 'jasmine-menu jasmine-bar jasmine-failure-list' },
            createDom(
              'a',
              { className: 'jasmine-spec-list-menu', href: '#' },
              'Spec List'
            ),
            createDom('span', {}, ' | Failures ')
          )
        );

        find('.jasmine-failures-menu').onclick = function() {
          setMenuModeTo('jasmine-failure-list');
          return false;
        };
        find('.jasmine-spec-list-menu').onclick = function() {
          setMenuModeTo('jasmine-spec-list');
          return false;
        };

        setMenuModeTo('jasmine-failure-list');

        var failureNode = find('.jasmine-failures');
        for (i = 0; i < failures.length; i++) {
          failureNode.appendChild(failures[i]);
        }
      }
    };

    return this;

    function failureDom(result) {
      var failure = createDom(
        'div',
        { className: 'jasmine-spec-detail jasmine-failed' },
        failureDescription(result, stateBuilder.currentParent),
        createDom('div', { className: 'jasmine-messages' })
      );
      var messages = failure.childNodes[1];

      for (var i = 0; i < result.failedExpectations.length; i++) {
        var expectation = result.failedExpectations[i];
        messages.appendChild(
          createDom(
            'div',
            { className: 'jasmine-result-message' },
            expectation.message
          )
        );
        messages.appendChild(
          createDom(
            'div',
            { className: 'jasmine-stack-trace' },
            expectation.stack
          )
        );
      }

      if (result.failedExpectations.length === 0) {
        messages.appendChild(
          createDom(
            'div',
            { className: 'jasmine-result-message' },
            'Spec has no expectations'
          )
        );
      }

      if (result.debugLogs) {
        messages.appendChild(debugLogTable(result.debugLogs));
      }

      return failure;
    }

    function debugLogTable(debugLogs) {
      var tbody = createDom('tbody');

      debugLogs.forEach(function(entry) {
        tbody.appendChild(
          createDom(
            'tr',
            {},
            createDom('td', {}, entry.timestamp.toString()),
            createDom('td', {}, entry.message)
          )
        );
      });

      return createDom(
        'div',
        { className: 'jasmine-debug-log' },
        createDom(
          'div',
          { className: 'jasmine-debug-log-header' },
          'Debug logs'
        ),
        createDom(
          'table',
          {},
          createDom(
            'thead',
            {},
            createDom(
              'tr',
              {},
              createDom('th', {}, 'Time (ms)'),
              createDom('th', {}, 'Message')
            )
          ),
          tbody
        )
      );
    }

    function summaryList(resultsTree, domParent) {
      var specListNode;
      for (var i = 0; i < resultsTree.children.length; i++) {
        var resultNode = resultsTree.children[i];
        if (filterSpecs && !hasActiveSpec(resultNode)) {
          continue;
        }
        if (resultNode.type === 'suite') {
          var suiteListNode = createDom(
            'ul',
            { className: 'jasmine-suite', id: 'suite-' + resultNode.result.id },
            createDom(
              'li',
              {
                className:
                  'jasmine-suite-detail jasmine-' + resultNode.result.status
              },
              createDom(
                'a',
                { href: specHref(resultNode.result) },
                resultNode.result.description
              )
            )
          );

          summaryList(resultNode, suiteListNode);
          domParent.appendChild(suiteListNode);
        }
        if (resultNode.type === 'spec') {
          if (domParent.getAttribute('class') !== 'jasmine-specs') {
            specListNode = createDom('ul', { className: 'jasmine-specs' });
            domParent.appendChild(specListNode);
          }
          var specDescription = resultNode.result.description;
          if (noExpectations(resultNode.result)) {
            specDescription = 'SPEC HAS NO EXPECTATIONS ' + specDescription;
          }
          if (
            resultNode.result.status === 'pending' &&
            resultNode.result.pendingReason !== ''
          ) {
            specDescription =
              specDescription +
              ' PENDING WITH MESSAGE: ' +
              resultNode.result.pendingReason;
          }
          specListNode.appendChild(
            createDom(
              'li',
              {
                className: 'jasmine-' + resultNode.result.status,
                id: 'spec-' + resultNode.result.id
              },
              createDom(
                'a',
                { href: specHref(resultNode.result) },
                specDescription
              )
            )
          );
        }
      }
    }

    function optionsMenu(config) {
      var optionsMenuDom = createDom(
        'div',
        { className: 'jasmine-run-options' },
        createDom('span', { className: 'jasmine-trigger' }, 'Options'),
        createDom(
          'div',
          { className: 'jasmine-payload' },
          createDom(
            'div',
            { className: 'jasmine-stop-on-failure' },
            createDom('input', {
              className: 'jasmine-fail-fast',
              id: 'jasmine-fail-fast',
              type: 'checkbox'
            }),
            createDom(
              'label',
              { className: 'jasmine-label', for: 'jasmine-fail-fast' },
              'stop execution on spec failure'
            )
          ),
          createDom(
            'div',
            { className: 'jasmine-throw-failures' },
            createDom('input', {
              className: 'jasmine-throw',
              id: 'jasmine-throw-failures',
              type: 'checkbox'
            }),
            createDom(
              'label',
              { className: 'jasmine-label', for: 'jasmine-throw-failures' },
              'stop spec on expectation failure'
            )
          ),
          createDom(
            'div',
            { className: 'jasmine-random-order' },
            createDom('input', {
              className: 'jasmine-random',
              id: 'jasmine-random-order',
              type: 'checkbox'
            }),
            createDom(
              'label',
              { className: 'jasmine-label', for: 'jasmine-random-order' },
              'run tests in random order'
            )
          ),
          createDom(
            'div',
            { className: 'jasmine-hide-disabled' },
            createDom('input', {
              className: 'jasmine-disabled',
              id: 'jasmine-hide-disabled',
              type: 'checkbox'
            }),
            createDom(
              'label',
              { className: 'jasmine-label', for: 'jasmine-hide-disabled' },
              'hide disabled tests'
            )
          )
        )
      );

      var failFastCheckbox = optionsMenuDom.querySelector('#jasmine-fail-fast');
      failFastCheckbox.checked = config.stopOnSpecFailure;
      failFastCheckbox.onclick = function() {
        navigateWithNewParam('stopOnSpecFailure', !config.stopOnSpecFailure);
      };

      var throwCheckbox = optionsMenuDom.querySelector(
        '#jasmine-throw-failures'
      );
      throwCheckbox.checked = config.stopSpecOnExpectationFailure;
      throwCheckbox.onclick = function() {
        navigateWithNewParam(
          'stopSpecOnExpectationFailure',
          !config.stopSpecOnExpectationFailure
        );
      };

      var randomCheckbox = optionsMenuDom.querySelector(
        '#jasmine-random-order'
      );
      randomCheckbox.checked = config.random;
      randomCheckbox.onclick = function() {
        navigateWithNewParam('random', !config.random);
      };

      var hideDisabled = optionsMenuDom.querySelector('#jasmine-hide-disabled');
      hideDisabled.checked = config.hideDisabled;
      hideDisabled.onclick = function() {
        navigateWithNewParam('hideDisabled', !config.hideDisabled);
      };

      var optionsTrigger = optionsMenuDom.querySelector('.jasmine-trigger'),
        optionsPayload = optionsMenuDom.querySelector('.jasmine-payload'),
        isOpen = /\bjasmine-open\b/;

      optionsTrigger.onclick = function() {
        if (isOpen.test(optionsPayload.className)) {
          optionsPayload.className = optionsPayload.className.replace(
            isOpen,
            ''
          );
        } else {
          optionsPayload.className += ' jasmine-open';
        }
      };

      return optionsMenuDom;
    }

    function failureDescription(result, suite) {
      var wrapper = createDom(
        'div',
        { className: 'jasmine-description' },
        createDom(
          'a',
          { title: result.description, href: specHref(result) },
          result.description
        )
      );
      var suiteLink;

      while (suite && suite.parent) {
        wrapper.insertBefore(createTextNode(' > '), wrapper.firstChild);
        suiteLink = createDom(
          'a',
          { href: suiteHref(suite) },
          suite.result.description
        );
        wrapper.insertBefore(suiteLink, wrapper.firstChild);

        suite = suite.parent;
      }

      return wrapper;
    }

    function suiteHref(suite) {
      var els = [];

      while (suite && suite.parent) {
        els.unshift(suite.result.description);
        suite = suite.parent;
      }

      // include window.location.pathname to fix issue with karma-jasmine-html-reporter in angular: see https://github.com/jasmine/jasmine/issues/1906
      return (
        (window.location.pathname || '') +
        addToExistingQueryString('spec', els.join(' '))
      );
    }

    function addDeprecationWarnings(result, runnableType) {
      if (result && result.deprecationWarnings) {
        for (var i = 0; i < result.deprecationWarnings.length; i++) {
          var warning = result.deprecationWarnings[i].message;
          deprecationWarnings.push({
            message: warning,
            stack: result.deprecationWarnings[i].stack,
            runnableName: result.fullName,
            runnableType: runnableType
          });
        }
      }
    }

    function createExpander(stackTrace) {
      var expandLink = createDom('a', { href: '#' }, 'Show stack trace');
      var root = createDom(
        'div',
        { className: 'jasmine-expander' },
        expandLink,
        createDom(
          'div',
          { className: 'jasmine-expander-contents jasmine-stack-trace' },
          stackTrace
        )
      );

      expandLink.addEventListener('click', function(e) {
        e.preventDefault();

        if (root.classList.contains('jasmine-expanded')) {
          root.classList.remove('jasmine-expanded');
          expandLink.textContent = 'Show stack trace';
        } else {
          root.classList.add('jasmine-expanded');
          expandLink.textContent = 'Hide stack trace';
        }
      });

      return root;
    }

    function find(selector) {
      return getContainer().querySelector('.jasmine_html-reporter ' + selector);
    }

    function clearPrior() {
      // return the reporter
      var oldReporter = find('');

      if (oldReporter) {
        getContainer().removeChild(oldReporter);
      }
    }

    function createDom(type, attrs, childrenArrayOrVarArgs) {
      var el = createElement(type),
        children,
        i;

      if (j$.isArray_(childrenArrayOrVarArgs)) {
        children = childrenArrayOrVarArgs;
      } else {
        children = [];

        for (i = 2; i < arguments.length; i++) {
          children.push(arguments[i]);
        }
      }

      for (i = 0; i < children.length; i++) {
        var child = children[i];

        if (typeof child === 'string') {
          el.appendChild(createTextNode(child));
        } else {
          if (child) {
            el.appendChild(child);
          }
        }
      }

      for (var attr in attrs) {
        if (attr == 'className') {
          el[attr] = attrs[attr];
        } else {
          el.setAttribute(attr, attrs[attr]);
        }
      }

      return el;
    }

    function pluralize(singular, count) {
      var word = count == 1 ? singular : singular + 's';

      return '' + count + ' ' + word;
    }

    function specHref(result) {
      // include window.location.pathname to fix issue with karma-jasmine-html-reporter in angular: see https://github.com/jasmine/jasmine/issues/1906
      return (
        (window.location.pathname || '') +
        addToExistingQueryString('spec', result.fullName)
      );
    }

    function seedHref(seed) {
      // include window.location.pathname to fix issue with karma-jasmine-html-reporter in angular: see https://github.com/jasmine/jasmine/issues/1906
      return (
        (window.location.pathname || '') +
        addToExistingQueryString('seed', seed)
      );
    }

    function defaultQueryString(key, value) {
      return '?' + key + '=' + value;
    }

    function setMenuModeTo(mode) {
      htmlReporterMain.setAttribute('class', 'jasmine_html-reporter ' + mode);
    }

    function noExpectations(result) {
      var allExpectations =
        result.failedExpectations.length + result.passedExpectations.length;

      return (
        allExpectations === 0 &&
        (result.status === 'passed' || result.status === 'failed')
      );
    }

    function hasActiveSpec(resultNode) {
      if (resultNode.type == 'spec' && resultNode.result.status != 'excluded') {
        return true;
      }

      if (resultNode.type == 'suite') {
        for (var i = 0, j = resultNode.children.length; i < j; i++) {
          if (hasActiveSpec(resultNode.children[i])) {
            return true;
          }
        }
      }
    }
  }

  return HtmlReporter;
};

jasmineRequire.HtmlSpecFilter = function() {
  function HtmlSpecFilter(options) {
    var filterString =
      options &&
      options.filterString() &&
      options.filterString().replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
    var filterPattern = new RegExp(filterString);

    this.matches = function(specName) {
      return filterPattern.test(specName);
    };
  }

  return HtmlSpecFilter;
};

jasmineRequire.ResultsNode = function() {
  function ResultsNode(result, type, parent) {
    this.result = result;
    this.type = type;
    this.parent = parent;

    this.children = [];

    this.addChild = function(result, type) {
      this.children.push(new ResultsNode(result, type, this));
    };

    this.last = function() {
      return this.children[this.children.length - 1];
    };

    this.updateResult = function(result) {
      this.result = result;
    };
  }

  return ResultsNode;
};

jasmineRequire.QueryString = function() {
  function QueryString(options) {
    this.navigateWithNewParam = function(key, value) {
      options.getWindowLocation().search = this.fullStringWithNewParam(
        key,
        value
      );
    };

    this.fullStringWithNewParam = function(key, value) {
      var paramMap = queryStringToParamMap();
      paramMap[key] = value;
      return toQueryString(paramMap);
    };

    this.getParam = function(key) {
      return queryStringToParamMap()[key];
    };

    return this;

    function toQueryString(paramMap) {
      var qStrPairs = [];
      for (var prop in paramMap) {
        qStrPairs.push(
          encodeURIComponent(prop) + '=' + encodeURIComponent(paramMap[prop])
        );
      }
      return '?' + qStrPairs.join('&');
    }

    function queryStringToParamMap() {
      var paramStr = options.getWindowLocation().search.substring(1),
        params = [],
        paramMap = {};

      if (paramStr.length > 0) {
        params = paramStr.split('&');
        for (var i = 0; i < params.length; i++) {
          var p = params[i].split('=');
          var value = decodeURIComponent(p[1]);
          if (value === 'true' || value === 'false') {
            value = JSON.parse(value);
          }
          paramMap[decodeURIComponent(p[0])] = value;
        }
      }

      return paramMap;
    }
  }

  return QueryString;
};


/***/ }),

/***/ "./node_modules/jasmine-core/lib/jasmine-core/jasmine.js":
/*!***************************************************************!*\
  !*** ./node_modules/jasmine-core/lib/jasmine-core/jasmine.js ***!
  \***************************************************************/
/***/ (function(module, exports, __webpack_require__) {

/*
Copyright (c) 2008-2022 Pivotal Labs

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
// eslint-disable-next-line no-unused-vars
var getJasmineRequireObj = (function(jasmineGlobal) {
  var jasmineRequire;

  if (
     true &&
    module.exports &&
    typeof exports !== 'undefined'
  ) {
    if (typeof __webpack_require__.g !== 'undefined') {
      jasmineGlobal = __webpack_require__.g;
    } else {
      jasmineGlobal = {};
    }
    jasmineRequire = exports;
  } else {
    if (
      typeof window !== 'undefined' &&
      typeof window.toString === 'function' &&
      window.toString() === '[object GjsGlobal]'
    ) {
      jasmineGlobal = window;
    }
    jasmineRequire = jasmineGlobal.jasmineRequire = {};
  }

  function getJasmineRequire() {
    return jasmineRequire;
  }

  getJasmineRequire().core = function(jRequire) {
    var j$ = {};

    jRequire.base(j$, jasmineGlobal);
    j$.util = jRequire.util(j$);
    j$.errors = jRequire.errors();
    j$.formatErrorMsg = jRequire.formatErrorMsg();
    j$.Any = jRequire.Any(j$);
    j$.Anything = jRequire.Anything(j$);
    j$.CallTracker = jRequire.CallTracker(j$);
    j$.MockDate = jRequire.MockDate(j$);
    j$.getClearStack = jRequire.clearStack(j$);
    j$.Clock = jRequire.Clock();
    j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler(j$);
    j$.Deprecator = jRequire.Deprecator(j$);
    j$.Env = jRequire.Env(j$);
    j$.StackTrace = jRequire.StackTrace(j$);
    j$.ExceptionFormatter = jRequire.ExceptionFormatter(j$);
    j$.ExpectationFilterChain = jRequire.ExpectationFilterChain();
    j$.Expector = jRequire.Expector(j$);
    j$.Expectation = jRequire.Expectation(j$);
    j$.buildExpectationResult = jRequire.buildExpectationResult(j$);
    j$.JsApiReporter = jRequire.JsApiReporter(j$);
    j$.makePrettyPrinter = jRequire.makePrettyPrinter(j$);
    j$.basicPrettyPrinter_ = j$.makePrettyPrinter();
    j$.MatchersUtil = jRequire.MatchersUtil(j$);
    j$.ObjectContaining = jRequire.ObjectContaining(j$);
    j$.ArrayContaining = jRequire.ArrayContaining(j$);
    j$.ArrayWithExactContents = jRequire.ArrayWithExactContents(j$);
    j$.MapContaining = jRequire.MapContaining(j$);
    j$.SetContaining = jRequire.SetContaining(j$);
    j$.QueueRunner = jRequire.QueueRunner(j$);
    j$.NeverSkipPolicy = jRequire.NeverSkipPolicy(j$);
    j$.SkipAfterBeforeAllErrorPolicy = jRequire.SkipAfterBeforeAllErrorPolicy(
      j$
    );
    j$.CompleteOnFirstErrorSkipPolicy = jRequire.CompleteOnFirstErrorSkipPolicy(
      j$
    );
    j$.ReportDispatcher = jRequire.ReportDispatcher(j$);
    j$.Spec = jRequire.Spec(j$);
    j$.Spy = jRequire.Spy(j$);
    j$.SpyFactory = jRequire.SpyFactory(j$);
    j$.SpyRegistry = jRequire.SpyRegistry(j$);
    j$.SpyStrategy = jRequire.SpyStrategy(j$);
    j$.StringMatching = jRequire.StringMatching(j$);
    j$.StringContaining = jRequire.StringContaining(j$);
    j$.UserContext = jRequire.UserContext(j$);
    j$.Suite = jRequire.Suite(j$);
    j$.Timer = jRequire.Timer();
    j$.TreeProcessor = jRequire.TreeProcessor();
    j$.version = jRequire.version();
    j$.Order = jRequire.Order();
    j$.DiffBuilder = jRequire.DiffBuilder(j$);
    j$.NullDiffBuilder = jRequire.NullDiffBuilder(j$);
    j$.ObjectPath = jRequire.ObjectPath(j$);
    j$.MismatchTree = jRequire.MismatchTree(j$);
    j$.GlobalErrors = jRequire.GlobalErrors(j$);

    j$.Truthy = jRequire.Truthy(j$);
    j$.Falsy = jRequire.Falsy(j$);
    j$.Empty = jRequire.Empty(j$);
    j$.NotEmpty = jRequire.NotEmpty(j$);

    j$.matchers = jRequire.requireMatchers(jRequire, j$);
    j$.asyncMatchers = jRequire.requireAsyncMatchers(jRequire, j$);

    return j$;
  };

  return getJasmineRequire;
})(this);

getJasmineRequireObj().requireMatchers = function(jRequire, j$) {
  var availableMatchers = [
      'nothing',
      'toBe',
      'toBeCloseTo',
      'toBeDefined',
      'toBeInstanceOf',
      'toBeFalse',
      'toBeFalsy',
      'toBeGreaterThan',
      'toBeGreaterThanOrEqual',
      'toBeLessThan',
      'toBeLessThanOrEqual',
      'toBeNaN',
      'toBeNegativeInfinity',
      'toBeNull',
      'toBePositiveInfinity',
      'toBeTrue',
      'toBeTruthy',
      'toBeUndefined',
      'toContain',
      'toEqual',
      'toHaveSize',
      'toHaveBeenCalled',
      'toHaveBeenCalledBefore',
      'toHaveBeenCalledOnceWith',
      'toHaveBeenCalledTimes',
      'toHaveBeenCalledWith',
      'toHaveClass',
      'toMatch',
      'toThrow',
      'toThrowError',
      'toThrowMatching'
    ],
    matchers = {};

  for (var i = 0; i < availableMatchers.length; i++) {
    var name = availableMatchers[i];
    matchers[name] = jRequire[name](j$);
  }

  return matchers;
};

getJasmineRequireObj().base = function(j$, jasmineGlobal) {
  j$.unimplementedMethod_ = function() {
    throw new Error('unimplemented method');
  };

  /**
   * Maximum object depth the pretty printer will print to.
   * Set this to a lower value to speed up pretty printing if you have large objects.
   * @name jasmine.MAX_PRETTY_PRINT_DEPTH
   * @default 8
   * @since 1.3.0
   */
  j$.MAX_PRETTY_PRINT_DEPTH = 8;
  /**
   * Maximum number of array elements to display when pretty printing objects.
   * This will also limit the number of keys and values displayed for an object.
   * Elements past this number will be ellipised.
   * @name jasmine.MAX_PRETTY_PRINT_ARRAY_LENGTH
   * @default 50
   * @since 2.7.0
   */
  j$.MAX_PRETTY_PRINT_ARRAY_LENGTH = 50;
  /**
   * Maximum number of characters to display when pretty printing objects.
   * Characters past this number will be ellipised.
   * @name jasmine.MAX_PRETTY_PRINT_CHARS
   * @default 100
   * @since 2.9.0
   */
  j$.MAX_PRETTY_PRINT_CHARS = 1000;
  /**
   * Default number of milliseconds Jasmine will wait for an asynchronous spec,
   * before, or after function to complete. This can be overridden on a case by
   * case basis by passing a time limit as the third argument to {@link it},
   * {@link beforeEach}, {@link afterEach}, {@link beforeAll}, or
   * {@link afterAll}. The value must be no greater than the largest number of
   * milliseconds supported by setTimeout, which is usually 2147483647.
   *
   * While debugging tests, you may want to set this to a large number (or pass
   * a large number to one of the functions mentioned above) so that Jasmine
   * does not move on to after functions or the next spec while you're debugging.
   * @name jasmine.DEFAULT_TIMEOUT_INTERVAL
   * @default 5000
   * @since 1.3.0
   */
  var DEFAULT_TIMEOUT_INTERVAL = 5000;
  Object.defineProperty(j$, 'DEFAULT_TIMEOUT_INTERVAL', {
    get: function() {
      return DEFAULT_TIMEOUT_INTERVAL;
    },
    set: function(newValue) {
      j$.util.validateTimeout(newValue, 'jasmine.DEFAULT_TIMEOUT_INTERVAL');
      DEFAULT_TIMEOUT_INTERVAL = newValue;
    }
  });

  j$.getGlobal = function() {
    return jasmineGlobal;
  };

  /**
   * Get the currently booted Jasmine Environment.
   *
   * @name jasmine.getEnv
   * @since 1.3.0
   * @function
   * @return {Env}
   */
  j$.getEnv = function(options) {
    var env = (j$.currentEnv_ = j$.currentEnv_ || new j$.Env(options));
    //jasmine. singletons in here (setTimeout blah blah).
    return env;
  };

  j$.isArray_ = function(value) {
    return j$.isA_('Array', value);
  };

  j$.isObject_ = function(value) {
    return (
      !j$.util.isUndefined(value) && value !== null && j$.isA_('Object', value)
    );
  };

  j$.isString_ = function(value) {
    return j$.isA_('String', value);
  };

  j$.isNumber_ = function(value) {
    return j$.isA_('Number', value);
  };

  j$.isFunction_ = function(value) {
    return j$.isA_('Function', value);
  };

  j$.isAsyncFunction_ = function(value) {
    return j$.isA_('AsyncFunction', value);
  };

  j$.isGeneratorFunction_ = function(value) {
    return j$.isA_('GeneratorFunction', value);
  };

  j$.isTypedArray_ = function(value) {
    return (
      j$.isA_('Float32Array', value) ||
      j$.isA_('Float64Array', value) ||
      j$.isA_('Int16Array', value) ||
      j$.isA_('Int32Array', value) ||
      j$.isA_('Int8Array', value) ||
      j$.isA_('Uint16Array', value) ||
      j$.isA_('Uint32Array', value) ||
      j$.isA_('Uint8Array', value) ||
      j$.isA_('Uint8ClampedArray', value)
    );
  };

  j$.isA_ = function(typeName, value) {
    return j$.getType_(value) === '[object ' + typeName + ']';
  };

  j$.isError_ = function(value) {
    if (!value) {
      return false;
    }

    if (value instanceof Error) {
      return true;
    }

    return typeof value.stack === 'string' && typeof value.message === 'string';
  };

  j$.isAsymmetricEqualityTester_ = function(obj) {
    return obj ? j$.isA_('Function', obj.asymmetricMatch) : false;
  };

  j$.getType_ = function(value) {
    return Object.prototype.toString.apply(value);
  };

  j$.isDomNode = function(obj) {
    // Node is a function, because constructors
    return typeof jasmineGlobal.Node !== 'undefined'
      ? obj instanceof jasmineGlobal.Node
      : obj !== null &&
          typeof obj === 'object' &&
          typeof obj.nodeType === 'number' &&
          typeof obj.nodeName === 'string';
    // return obj.nodeType > 0;
  };

  j$.isMap = function(obj) {
    return (
      obj !== null &&
      typeof obj !== 'undefined' &&
      obj.constructor === jasmineGlobal.Map
    );
  };

  j$.isSet = function(obj) {
    return (
      obj !== null &&
      typeof obj !== 'undefined' &&
      obj.constructor === jasmineGlobal.Set
    );
  };

  j$.isWeakMap = function(obj) {
    return (
      obj !== null &&
      typeof obj !== 'undefined' &&
      obj.constructor === jasmineGlobal.WeakMap
    );
  };

  j$.isURL = function(obj) {
    return (
      obj !== null &&
      typeof obj !== 'undefined' &&
      obj.constructor === jasmineGlobal.URL
    );
  };

  j$.isIterable_ = function(value) {
    return value && !!value[Symbol.iterator];
  };

  j$.isDataView = function(obj) {
    return (
      obj !== null &&
      typeof obj !== 'undefined' &&
      obj.constructor === jasmineGlobal.DataView
    );
  };

  j$.isPromise = function(obj) {
    return !!obj && obj.constructor === jasmineGlobal.Promise;
  };

  j$.isPromiseLike = function(obj) {
    return !!obj && j$.isFunction_(obj.then);
  };

  j$.fnNameFor = function(func) {
    if (func.name) {
      return func.name;
    }

    var matches =
      func.toString().match(/^\s*function\s*(\w+)\s*\(/) ||
      func.toString().match(/^\s*\[object\s*(\w+)Constructor\]/);

    return matches ? matches[1] : '<anonymous>';
  };

  j$.isPending_ = function(promise) {
    var sentinel = {};
    return Promise.race([promise, Promise.resolve(sentinel)]).then(
      function(result) {
        return result === sentinel;
      },
      function() {
        return false;
      }
    );
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared is an instance of the specified class/constructor.
   * @name jasmine.any
   * @since 1.3.0
   * @function
   * @param {Constructor} clazz - The constructor to check against.
   */
  j$.any = function(clazz) {
    return new j$.Any(clazz);
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared is not `null` and not `undefined`.
   * @name jasmine.anything
   * @since 2.2.0
   * @function
   */
  j$.anything = function() {
    return new j$.Anything();
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared is `true` or anything truthy.
   * @name jasmine.truthy
   * @since 3.1.0
   * @function
   */
  j$.truthy = function() {
    return new j$.Truthy();
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared is  `null`, `undefined`, `0`, `false` or anything falsey.
   * @name jasmine.falsy
   * @since 3.1.0
   * @function
   */
  j$.falsy = function() {
    return new j$.Falsy();
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared is empty.
   * @name jasmine.empty
   * @since 3.1.0
   * @function
   */
  j$.empty = function() {
    return new j$.Empty();
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared is not empty.
   * @name jasmine.notEmpty
   * @since 3.1.0
   * @function
   */
  j$.notEmpty = function() {
    return new j$.NotEmpty();
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared contains at least the keys and values.
   * @name jasmine.objectContaining
   * @since 1.3.0
   * @function
   * @param {Object} sample - The subset of properties that _must_ be in the actual.
   */
  j$.objectContaining = function(sample) {
    return new j$.ObjectContaining(sample);
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value is a `String` that matches the `RegExp` or `String`.
   * @name jasmine.stringMatching
   * @since 2.2.0
   * @function
   * @param {RegExp|String} expected
   */
  j$.stringMatching = function(expected) {
    return new j$.StringMatching(expected);
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value is a `String` that contains the specified `String`.
   * @name jasmine.stringContaining
   * @since 3.10.0
   * @function
   * @param {String} expected
   */
  j$.stringContaining = function(expected) {
    return new j$.StringContaining(expected);
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value is an `Array` that contains at least the elements in the sample.
   * @name jasmine.arrayContaining
   * @since 2.2.0
   * @function
   * @param {Array} sample
   */
  j$.arrayContaining = function(sample) {
    return new j$.ArrayContaining(sample);
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value is an `Array` that contains all of the elements in the sample in any order.
   * @name jasmine.arrayWithExactContents
   * @since 2.8.0
   * @function
   * @param {Array} sample
   */
  j$.arrayWithExactContents = function(sample) {
    return new j$.ArrayWithExactContents(sample);
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if every key/value pair in the sample passes the deep equality comparison
   * with at least one key/value pair in the actual value being compared
   * @name jasmine.mapContaining
   * @since 3.5.0
   * @function
   * @param {Map} sample - The subset of items that _must_ be in the actual.
   */
  j$.mapContaining = function(sample) {
    return new j$.MapContaining(sample);
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if every item in the sample passes the deep equality comparison
   * with at least one item in the actual value being compared
   * @name jasmine.setContaining
   * @since 3.5.0
   * @function
   * @param {Set} sample - The subset of items that _must_ be in the actual.
   */
  j$.setContaining = function(sample) {
    return new j$.SetContaining(sample);
  };

  /**
   * Determines whether the provided function is a Jasmine spy.
   * @name jasmine.isSpy
   * @since 2.0.0
   * @function
   * @param {Function} putativeSpy - The function to check.
   * @return {Boolean}
   */
  j$.isSpy = function(putativeSpy) {
    if (!putativeSpy) {
      return false;
    }
    return (
      putativeSpy.and instanceof j$.SpyStrategy &&
      putativeSpy.calls instanceof j$.CallTracker
    );
  };

  /**
   * Logs a message for use in debugging. If the spec fails, trace messages
   * will be included in the {@link SpecResult|result} passed to the
   * reporter's specDone method.
   *
   * This method should be called only when a spec (including any associated
   * beforeEach or afterEach functions) is running.
   * @function
   * @name jasmine.debugLog
   * @since 4.0.0
   * @param {String} msg - The message to log
   */
  j$.debugLog = function(msg) {
    j$.getEnv().debugLog(msg);
  };
};

getJasmineRequireObj().util = function(j$) {
  var util = {};

  util.inherit = function(childClass, parentClass) {
    var Subclass = function() {};
    Subclass.prototype = parentClass.prototype;
    childClass.prototype = new Subclass();
  };

  util.argsToArray = function(args) {
    var arrayOfArgs = [];
    for (var i = 0; i < args.length; i++) {
      arrayOfArgs.push(args[i]);
    }
    return arrayOfArgs;
  };

  util.isUndefined = function(obj) {
    return obj === void 0;
  };

  util.arrayContains = function(array, search) {
    var i = array.length;
    while (i--) {
      if (array[i] === search) {
        return true;
      }
    }
    return false;
  };

  util.clone = function(obj) {
    if (Object.prototype.toString.apply(obj) === '[object Array]') {
      return obj.slice();
    }

    var cloned = {};
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        cloned[prop] = obj[prop];
      }
    }

    return cloned;
  };

  util.cloneArgs = function(args) {
    var clonedArgs = [];
    var argsAsArray = j$.util.argsToArray(args);
    for (var i = 0; i < argsAsArray.length; i++) {
      var str = Object.prototype.toString.apply(argsAsArray[i]),
        primitives = /^\[object (Boolean|String|RegExp|Number)/;

      // All falsey values are either primitives, `null`, or `undefined.
      if (!argsAsArray[i] || str.match(primitives)) {
        clonedArgs.push(argsAsArray[i]);
      } else {
        clonedArgs.push(j$.util.clone(argsAsArray[i]));
      }
    }
    return clonedArgs;
  };

  util.getPropertyDescriptor = function(obj, methodName) {
    var descriptor,
      proto = obj;

    do {
      descriptor = Object.getOwnPropertyDescriptor(proto, methodName);
      proto = Object.getPrototypeOf(proto);
    } while (!descriptor && proto);

    return descriptor;
  };

  util.objectDifference = function(obj, toRemove) {
    var diff = {};

    for (var key in obj) {
      if (util.has(obj, key) && !util.has(toRemove, key)) {
        diff[key] = obj[key];
      }
    }

    return diff;
  };

  util.has = function(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  };

  util.errorWithStack = function errorWithStack() {
    // Don't throw and catch. That makes it harder for users to debug their
    // code with exception breakpoints, and it's unnecessary since all
    // supported environments populate new Error().stack
    return new Error();
  };

  function callerFile() {
    var trace = new j$.StackTrace(util.errorWithStack());
    return trace.frames[2].file;
  }

  util.jasmineFile = (function() {
    var result;

    return function() {
      if (!result) {
        result = callerFile();
      }

      return result;
    };
  })();

  function StopIteration() {}
  StopIteration.prototype = Object.create(Error.prototype);
  StopIteration.prototype.constructor = StopIteration;

  util.validateTimeout = function(timeout, msgPrefix) {
    // Timeouts are implemented with setTimeout, which only supports a limited
    // range of values. The limit is unspecified, as is the behavior when it's
    // exceeded. But on all currently supported JS runtimes, setTimeout calls
    // the callback immediately when the timeout is greater than 2147483647
    // (the maximum value of a signed 32 bit integer).
    var max = 2147483647;

    if (timeout > max) {
      throw new Error(
        (msgPrefix || 'Timeout value') + ' cannot be greater than ' + max
      );
    }
  };

  return util;
};

getJasmineRequireObj().Spec = function(j$) {
  /**
   * @interface Spec
   * @see Configuration#specFilter
   * @since 2.0.0
   */
  function Spec(attrs) {
    this.expectationFactory = attrs.expectationFactory;
    this.asyncExpectationFactory = attrs.asyncExpectationFactory;
    this.resultCallback = attrs.resultCallback || function() {};
    /**
     * The unique ID of this spec.
     * @name Spec#id
     * @readonly
     * @type {string}
     * @since 2.0.0
     */
    this.id = attrs.id;
    /**
     * The description passed to the {@link it} that created this spec.
     * @name Spec#description
     * @readonly
     * @type {string}
     * @since 2.0.0
     */
    this.description = attrs.description || '';
    this.queueableFn = attrs.queueableFn;
    this.beforeAndAfterFns =
      attrs.beforeAndAfterFns ||
      function() {
        return { befores: [], afters: [] };
      };
    this.userContext =
      attrs.userContext ||
      function() {
        return {};
      };
    this.onStart = attrs.onStart || function() {};
    this.autoCleanClosures =
      attrs.autoCleanClosures === undefined ? true : !!attrs.autoCleanClosures;
    this.getSpecName =
      attrs.getSpecName ||
      function() {
        return '';
      };
    this.expectationResultFactory =
      attrs.expectationResultFactory || function() {};
    this.onLateError = attrs.onLateError || function() {};
    this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};
    this.catchingExceptions =
      attrs.catchingExceptions ||
      function() {
        return true;
      };
    this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;
    this.timer = attrs.timer || new j$.Timer();

    if (!this.queueableFn.fn) {
      this.exclude();
    }

    /**
     * @typedef SpecResult
     * @property {Int} id - The unique id of this spec.
     * @property {String} description - The description passed to the {@link it} that created this spec.
     * @property {String} fullName - The full description including all ancestors of this spec.
     * @property {Expectation[]} failedExpectations - The list of expectations that failed during execution of this spec.
     * @property {Expectation[]} passedExpectations - The list of expectations that passed during execution of this spec.
     * @property {Expectation[]} deprecationWarnings - The list of deprecation warnings that occurred during execution this spec.
     * @property {String} pendingReason - If the spec is {@link pending}, this will be the reason.
     * @property {String} status - Once the spec has completed, this string represents the pass/fail status of this spec.
     * @property {number} duration - The time in ms used by the spec execution, including any before/afterEach.
     * @property {Object} properties - User-supplied properties, if any, that were set using {@link Env#setSpecProperty}
     * @property {DebugLogEntry[]|null} debugLogs - Messages, if any, that were logged using {@link jasmine.debugLog} during a failing spec.
     * @since 2.0.0
     */
    this.result = {
      id: this.id,
      description: this.description,
      fullName: this.getFullName(),
      failedExpectations: [],
      passedExpectations: [],
      deprecationWarnings: [],
      pendingReason: '',
      duration: null,
      properties: null,
      debugLogs: null
    };
  }

  Spec.prototype.addExpectationResult = function(passed, data, isError) {
    var expectationResult = this.expectationResultFactory(data);
    if (passed) {
      this.result.passedExpectations.push(expectationResult);
    } else {
      this.result.failedExpectations.push(expectationResult);

      if (this.throwOnExpectationFailure && !isError) {
        throw new j$.errors.ExpectationFailed();
      }
    }
  };

  Spec.prototype.setSpecProperty = function(key, value) {
    this.result.properties = this.result.properties || {};
    this.result.properties[key] = value;
  };

  Spec.prototype.expect = function(actual) {
    return this.expectationFactory(actual, this);
  };

  Spec.prototype.expectAsync = function(actual) {
    return this.asyncExpectationFactory(actual, this);
  };

  Spec.prototype.execute = function(onComplete, excluded, failSpecWithNoExp) {
    var self = this;

    var onStart = {
      fn: function(done) {
        self.timer.start();
        self.onStart(self, done);
      }
    };

    var complete = {
      fn: function(done) {
        if (self.autoCleanClosures) {
          self.queueableFn.fn = null;
        }
        self.result.status = self.status(excluded, failSpecWithNoExp);
        self.result.duration = self.timer.elapsed();

        if (self.result.status !== 'failed') {
          self.result.debugLogs = null;
        }

        self.resultCallback(self.result, done);
      },
      type: 'specCleanup'
    };

    var fns = this.beforeAndAfterFns();

    var runnerConfig = {
      isLeaf: true,
      queueableFns: [...fns.befores, this.queueableFn, ...fns.afters],
      onException: function() {
        self.onException.apply(self, arguments);
      },
      onMultipleDone: function() {
        // Issue a deprecation. Include the context ourselves and pass
        // ignoreRunnable: true, since getting here always means that we've already
        // moved on and the current runnable isn't the one that caused the problem.
        self.onLateError(
          new Error(
            'An asynchronous spec, beforeEach, or afterEach function called its ' +
              "'done' callback more than once.\n(in spec: " +
              self.getFullName() +
              ')'
          )
        );
      },
      onComplete: function() {
        if (self.result.status === 'failed') {
          onComplete(new j$.StopExecutionError('spec failed'));
        } else {
          onComplete();
        }
      },
      userContext: this.userContext(),
      runnableName: this.getFullName.bind(this)
    };

    if (this.markedPending || excluded === true) {
      runnerConfig.queueableFns = [];
    }

    runnerConfig.queueableFns.unshift(onStart);
    runnerConfig.queueableFns.push(complete);

    this.queueRunnerFactory(runnerConfig);
  };

  Spec.prototype.reset = function() {
    this.result = {
      id: this.id,
      description: this.description,
      fullName: this.getFullName(),
      failedExpectations: [],
      passedExpectations: [],
      deprecationWarnings: [],
      pendingReason: this.excludeMessage,
      duration: null,
      properties: null,
      debugLogs: null
    };
    this.markedPending = this.markedExcluding;
  };

  Spec.prototype.onException = function onException(e) {
    if (Spec.isPendingSpecException(e)) {
      this.pend(extractCustomPendingMessage(e));
      return;
    }

    if (e instanceof j$.errors.ExpectationFailed) {
      return;
    }

    this.addExpectationResult(
      false,
      {
        matcherName: '',
        passed: false,
        expected: '',
        actual: '',
        error: e
      },
      true
    );
  };

  /*
   * Marks state as pending
   * @param {string} [message] An optional reason message
   */
  Spec.prototype.pend = function(message) {
    this.markedPending = true;
    if (message) {
      this.result.pendingReason = message;
    }
  };

  /*
   * Like {@link Spec#pend}, but pending state will survive {@link Spec#reset}
   * Useful for fit, xit, where pending state remains.
   * @param {string} [message] An optional reason message
   */
  Spec.prototype.exclude = function(message) {
    this.markedExcluding = true;
    if (this.message) {
      this.excludeMessage = message;
    }
    this.pend(message);
  };

  Spec.prototype.getResult = function() {
    this.result.status = this.status();
    return this.result;
  };

  Spec.prototype.status = function(excluded, failSpecWithNoExpectations) {
    if (excluded === true) {
      return 'excluded';
    }

    if (this.markedPending) {
      return 'pending';
    }

    if (
      this.result.failedExpectations.length > 0 ||
      (failSpecWithNoExpectations &&
        this.result.failedExpectations.length +
          this.result.passedExpectations.length ===
          0)
    ) {
      return 'failed';
    }

    return 'passed';
  };

  /**
   * The full description including all ancestors of this spec.
   * @name Spec#getFullName
   * @function
   * @returns {string}
   * @since 2.0.0
   */
  Spec.prototype.getFullName = function() {
    return this.getSpecName(this);
  };

  Spec.prototype.addDeprecationWarning = function(deprecation) {
    if (typeof deprecation === 'string') {
      deprecation = { message: deprecation };
    }
    this.result.deprecationWarnings.push(
      this.expectationResultFactory(deprecation)
    );
  };

  Spec.prototype.debugLog = function(msg) {
    if (!this.result.debugLogs) {
      this.result.debugLogs = [];
    }

    /**
     * @typedef DebugLogEntry
     * @property {String} message - The message that was passed to {@link jasmine.debugLog}.
     * @property {number} timestamp - The time when the entry was added, in
     * milliseconds from the spec's start time
     */
    this.result.debugLogs.push({
      message: msg,
      timestamp: this.timer.elapsed()
    });
  };

  var extractCustomPendingMessage = function(e) {
    var fullMessage = e.toString(),
      boilerplateStart = fullMessage.indexOf(Spec.pendingSpecExceptionMessage),
      boilerplateEnd =
        boilerplateStart + Spec.pendingSpecExceptionMessage.length;

    return fullMessage.substr(boilerplateEnd);
  };

  Spec.pendingSpecExceptionMessage = '=> marked Pending';

  Spec.isPendingSpecException = function(e) {
    return !!(
      e &&
      e.toString &&
      e.toString().indexOf(Spec.pendingSpecExceptionMessage) !== -1
    );
  };

  /**
   * @interface Spec
   * @see Configuration#specFilter
   */
  Object.defineProperty(Spec.prototype, 'metadata', {
    get: function() {
      if (!this.metadata_) {
        this.metadata_ = {
          /**
           * The unique ID of this spec.
           * @name Spec#id
           * @readonly
           * @type {string}
           */
          id: this.id,

          /**
           * The description passed to the {@link it} that created this spec.
           * @name Spec#description
           * @readonly
           * @type {string}
           */
          description: this.description,

          /**
           * The full description including all ancestors of this spec.
           * @name Spec#getFullName
           * @function
           * @returns {string}
           */
          getFullName: this.getFullName.bind(this)
        };
      }

      return this.metadata_;
    }
  });

  return Spec;
};

/*jshint bitwise: false*/

getJasmineRequireObj().Order = function() {
  function Order(options) {
    this.random = 'random' in options ? options.random : true;
    var seed = (this.seed = options.seed || generateSeed());
    this.sort = this.random ? randomOrder : naturalOrder;

    function naturalOrder(items) {
      return items;
    }

    function randomOrder(items) {
      var copy = items.slice();
      copy.sort(function(a, b) {
        return jenkinsHash(seed + a.id) - jenkinsHash(seed + b.id);
      });
      return copy;
    }

    function generateSeed() {
      return String(Math.random()).slice(-5);
    }

    // Bob Jenkins One-at-a-Time Hash algorithm is a non-cryptographic hash function
    // used to get a different output when the key changes slightly.
    // We use your return to sort the children randomly in a consistent way when
    // used in conjunction with a seed

    function jenkinsHash(key) {
      var hash, i;
      for (hash = i = 0; i < key.length; ++i) {
        hash += key.charCodeAt(i);
        hash += hash << 10;
        hash ^= hash >> 6;
      }
      hash += hash << 3;
      hash ^= hash >> 11;
      hash += hash << 15;
      return hash;
    }
  }

  return Order;
};

getJasmineRequireObj().Env = function(j$) {
  /**
   * @class Env
   * @since 2.0.0
   * @classdesc The Jasmine environment.<br>
   * _Note:_ Do not construct this directly. You can obtain the Env instance by
   * calling {@link jasmine.getEnv}.
   * @hideconstructor
   */
  function Env(options) {
    options = options || {};

    var self = this;
    var global = options.global || j$.getGlobal();

    var totalSpecsDefined = 0;

    var realSetTimeout = global.setTimeout;
    var realClearTimeout = global.clearTimeout;
    var clearStack = j$.getClearStack(global);
    this.clock = new j$.Clock(
      global,
      function() {
        return new j$.DelayedFunctionScheduler();
      },
      new j$.MockDate(global)
    );

    var runnableResources = {};

    var currentSpec = null;
    var currentlyExecutingSuites = [];
    var currentDeclarationSuite = null;
    var hasFailures = false;

    /**
     * This represents the available options to configure Jasmine.
     * Options that are not provided will use their default values.
     * @see Env#configure
     * @interface Configuration
     * @since 3.3.0
     */
    var config = {
      /**
       * Whether to randomize spec execution order
       * @name Configuration#random
       * @since 3.3.0
       * @type Boolean
       * @default true
       */
      random: true,
      /**
       * Seed to use as the basis of randomization.
       * Null causes the seed to be determined randomly at the start of execution.
       * @name Configuration#seed
       * @since 3.3.0
       * @type (number|string)
       * @default null
       */
      seed: null,
      /**
       * Whether to stop execution of the suite after the first spec failure
       * @name Configuration#stopOnSpecFailure
       * @since 3.9.0
       * @type Boolean
       * @default false
       */
      stopOnSpecFailure: false,
      /**
       * Whether to fail the spec if it ran no expectations. By default
       * a spec that ran no expectations is reported as passed. Setting this
       * to true will report such spec as a failure.
       * @name Configuration#failSpecWithNoExpectations
       * @since 3.5.0
       * @type Boolean
       * @default false
       */
      failSpecWithNoExpectations: false,
      /**
       * Whether to cause specs to only have one expectation failure.
       * @name Configuration#stopSpecOnExpectationFailure
       * @since 3.3.0
       * @type Boolean
       * @default false
       */
      stopSpecOnExpectationFailure: false,
      /**
       * A function that takes a spec and returns true if it should be executed
       * or false if it should be skipped.
       * @callback SpecFilter
       * @param {Spec} spec - The spec that the filter is being applied to.
       * @return boolean
       */
      /**
       * Function to use to filter specs
       * @name Configuration#specFilter
       * @since 3.3.0
       * @type SpecFilter
       * @default A function that always returns true.
       */
      specFilter: function() {
        return true;
      },
      /**
       * Whether or not reporters should hide disabled specs from their output.
       * Currently only supported by Jasmine's HTMLReporter
       * @name Configuration#hideDisabled
       * @since 3.3.0
       * @type Boolean
       * @default false
       */
      hideDisabled: false,
      /**
       * Clean closures when a suite is done running (done by clearing the stored function reference).
       * This prevents memory leaks, but you won't be able to run jasmine multiple times.
       * @name Configuration#autoCleanClosures
       * @since 3.10.0
       * @type boolean
       * @default true
       */
      autoCleanClosures: true,
      /**
       * Whether or not to issue warnings for certain deprecated functionality
       * every time it's used. If not set or set to false, deprecation warnings
       * for methods that tend to be called frequently will be issued only once
       * or otherwise throttled to to prevent the suite output from being flooded
       * with warnings.
       * @name Configuration#verboseDeprecations
       * @since 3.6.0
       * @type Boolean
       * @default false
       */
      verboseDeprecations: false
    };

    var currentSuite = function() {
      return currentlyExecutingSuites[currentlyExecutingSuites.length - 1];
    };

    var currentRunnable = function() {
      return currentSpec || currentSuite();
    };

    var globalErrors = null;

    var installGlobalErrors = function() {
      if (globalErrors) {
        return;
      }

      globalErrors = new j$.GlobalErrors();
      globalErrors.install();
    };

    if (!options.suppressLoadErrors) {
      installGlobalErrors();
      globalErrors.pushListener(function(
        message,
        filename,
        lineno,
        colNo,
        err
      ) {
        topSuite.result.failedExpectations.push({
          passed: false,
          globalErrorType: 'load',
          message: message,
          stack: err && err.stack,
          filename: filename,
          lineno: lineno
        });
      });
    }

    /**
     * Configure your jasmine environment
     * @name Env#configure
     * @since 3.3.0
     * @argument {Configuration} configuration
     * @function
     */
    this.configure = function(configuration) {
      var booleanProps = [
        'random',
        'failSpecWithNoExpectations',
        'hideDisabled',
        'stopOnSpecFailure',
        'stopSpecOnExpectationFailure',
        'autoCleanClosures'
      ];

      booleanProps.forEach(function(prop) {
        if (typeof configuration[prop] !== 'undefined') {
          config[prop] = !!configuration[prop];
        }
      });

      if (configuration.specFilter) {
        config.specFilter = configuration.specFilter;
      }

      if (typeof configuration.seed !== 'undefined') {
        config.seed = configuration.seed;
      }

      if (configuration.hasOwnProperty('verboseDeprecations')) {
        config.verboseDeprecations = configuration.verboseDeprecations;
        deprecator.verboseDeprecations(config.verboseDeprecations);
      }
    };

    /**
     * Get the current configuration for your jasmine environment
     * @name Env#configuration
     * @since 3.3.0
     * @function
     * @returns {Configuration}
     */
    this.configuration = function() {
      var result = {};
      for (var property in config) {
        result[property] = config[property];
      }
      return result;
    };

    this.setDefaultSpyStrategy = function(defaultStrategyFn) {
      if (!currentRunnable()) {
        throw new Error(
          'Default spy strategy must be set in a before function or a spec'
        );
      }
      runnableResources[
        currentRunnable().id
      ].defaultStrategyFn = defaultStrategyFn;
    };

    this.addSpyStrategy = function(name, fn) {
      if (!currentRunnable()) {
        throw new Error(
          'Custom spy strategies must be added in a before function or a spec'
        );
      }
      runnableResources[currentRunnable().id].customSpyStrategies[name] = fn;
    };

    this.addCustomEqualityTester = function(tester) {
      if (!currentRunnable()) {
        throw new Error(
          'Custom Equalities must be added in a before function or a spec'
        );
      }
      runnableResources[currentRunnable().id].customEqualityTesters.push(
        tester
      );
    };

    this.addMatchers = function(matchersToAdd) {
      if (!currentRunnable()) {
        throw new Error(
          'Matchers must be added in a before function or a spec'
        );
      }
      var customMatchers =
        runnableResources[currentRunnable().id].customMatchers;

      for (var matcherName in matchersToAdd) {
        customMatchers[matcherName] = matchersToAdd[matcherName];
      }
    };

    this.addAsyncMatchers = function(matchersToAdd) {
      if (!currentRunnable()) {
        throw new Error(
          'Async Matchers must be added in a before function or a spec'
        );
      }
      var customAsyncMatchers =
        runnableResources[currentRunnable().id].customAsyncMatchers;

      for (var matcherName in matchersToAdd) {
        customAsyncMatchers[matcherName] = matchersToAdd[matcherName];
      }
    };

    this.addCustomObjectFormatter = function(formatter) {
      if (!currentRunnable()) {
        throw new Error(
          'Custom object formatters must be added in a before function or a spec'
        );
      }

      runnableResources[currentRunnable().id].customObjectFormatters.push(
        formatter
      );
    };

    j$.Expectation.addCoreMatchers(j$.matchers);
    j$.Expectation.addAsyncCoreMatchers(j$.asyncMatchers);

    var nextSpecId = 0;
    var getNextSpecId = function() {
      return 'spec' + nextSpecId++;
    };

    var nextSuiteId = 0;
    var getNextSuiteId = function() {
      return 'suite' + nextSuiteId++;
    };

    var makePrettyPrinter = function() {
      var customObjectFormatters =
        runnableResources[currentRunnable().id].customObjectFormatters;
      return j$.makePrettyPrinter(customObjectFormatters);
    };

    var makeMatchersUtil = function() {
      const cr = currentRunnable();

      if (cr) {
        const customEqualityTesters =
          runnableResources[cr.id].customEqualityTesters;
        return new j$.MatchersUtil({
          customTesters: customEqualityTesters,
          pp: makePrettyPrinter()
        });
      } else {
        return new j$.MatchersUtil({ pp: j$.basicPrettyPrinter_ });
      }
    };

    var expectationFactory = function(actual, spec) {
      return j$.Expectation.factory({
        matchersUtil: makeMatchersUtil(),
        customMatchers: runnableResources[spec.id].customMatchers,
        actual: actual,
        addExpectationResult: addExpectationResult
      });

      function addExpectationResult(passed, result) {
        return spec.addExpectationResult(passed, result);
      }
    };

    function recordLateError(error) {
      const result = expectationResultFactory({
        error,
        passed: false,
        matcherName: '',
        expected: '',
        actual: ''
      });
      result.globalErrorType = 'lateError';
      topSuite.result.failedExpectations.push(result);
    }

    function recordLateExpectation(runable, runableType, result) {
      var delayedExpectationResult = {};
      Object.keys(result).forEach(function(k) {
        delayedExpectationResult[k] = result[k];
      });
      delayedExpectationResult.passed = false;
      delayedExpectationResult.globalErrorType = 'lateExpectation';
      delayedExpectationResult.message =
        runableType +
        ' "' +
        runable.getFullName() +
        '" ran a "' +
        result.matcherName +
        '" expectation after it finished.\n';

      if (result.message) {
        delayedExpectationResult.message +=
          'Message: "' + result.message + '"\n';
      }

      delayedExpectationResult.message +=
        '1. Did you forget to return or await the result of expectAsync?\n' +
        '2. Was done() invoked before an async operation completed?\n' +
        '3. Did an expectation follow a call to done()?';

      topSuite.result.failedExpectations.push(delayedExpectationResult);
    }

    var asyncExpectationFactory = function(actual, spec, runableType) {
      return j$.Expectation.asyncFactory({
        matchersUtil: makeMatchersUtil(),
        customAsyncMatchers: runnableResources[spec.id].customAsyncMatchers,
        actual: actual,
        addExpectationResult: addExpectationResult
      });

      function addExpectationResult(passed, result) {
        if (currentRunnable() !== spec) {
          recordLateExpectation(spec, runableType, result);
        }
        return spec.addExpectationResult(passed, result);
      }
    };
    var suiteAsyncExpectationFactory = function(actual, suite) {
      return asyncExpectationFactory(actual, suite, 'Suite');
    };

    var specAsyncExpectationFactory = function(actual, suite) {
      return asyncExpectationFactory(actual, suite, 'Spec');
    };

    var defaultResourcesForRunnable = function(id, parentRunnableId) {
      var resources = {
        spies: [],
        customEqualityTesters: [],
        customMatchers: {},
        customAsyncMatchers: {},
        customSpyStrategies: {},
        defaultStrategyFn: undefined,
        customObjectFormatters: []
      };

      if (runnableResources[parentRunnableId]) {
        resources.customEqualityTesters = j$.util.clone(
          runnableResources[parentRunnableId].customEqualityTesters
        );
        resources.customMatchers = j$.util.clone(
          runnableResources[parentRunnableId].customMatchers
        );
        resources.customAsyncMatchers = j$.util.clone(
          runnableResources[parentRunnableId].customAsyncMatchers
        );
        resources.customObjectFormatters = j$.util.clone(
          runnableResources[parentRunnableId].customObjectFormatters
        );
        resources.customSpyStrategies = j$.util.clone(
          runnableResources[parentRunnableId].customSpyStrategies
        );
        resources.defaultStrategyFn =
          runnableResources[parentRunnableId].defaultStrategyFn;
      }

      runnableResources[id] = resources;
    };

    var clearResourcesForRunnable = function(id) {
      spyRegistry.clearSpies();
      delete runnableResources[id];
    };

    var beforeAndAfterFns = function(targetSuite) {
      return function() {
        var befores = [],
          afters = [],
          suite = targetSuite;

        while (suite) {
          befores = befores.concat(suite.beforeFns);
          afters = afters.concat(suite.afterFns);

          suite = suite.parentSuite;
        }

        return {
          befores: befores.reverse(),
          afters: afters
        };
      };
    };

    var getSpecName = function(spec, suite) {
      var fullName = [spec.description],
        suiteFullName = suite.getFullName();

      if (suiteFullName !== '') {
        fullName.unshift(suiteFullName);
      }
      return fullName.join(' ');
    };

    // TODO: we may just be able to pass in the fn instead of wrapping here
    var buildExpectationResult = j$.buildExpectationResult,
      exceptionFormatter = new j$.ExceptionFormatter(),
      expectationResultFactory = function(attrs) {
        attrs.messageFormatter = exceptionFormatter.message;
        attrs.stackFormatter = exceptionFormatter.stack;

        return buildExpectationResult(attrs);
      };

    /**
     * Causes a deprecation warning to be logged to the console and reported to
     * reporters.
     *
     * The optional second parameter is an object that can have either of the
     * following properties:
     *
     * omitStackTrace: Whether to omit the stack trace. Optional. Defaults to
     * false. This option is ignored if the deprecation is an Error. Set this
     * when the stack trace will not contain anything that helps the user find
     * the source of the deprecation.
     *
     * ignoreRunnable: Whether to log the deprecation on the root suite, ignoring
     * the spec or suite that's running when it happens. Optional. Defaults to
     * false.
     *
     * @name Env#deprecated
     * @since 2.99
     * @function
     * @param {String|Error} deprecation The deprecation message
     * @param {Object} [options] Optional extra options, as described above
     */
    this.deprecated = function(deprecation, options) {
      var runnable = currentRunnable() || topSuite;
      deprecator.addDeprecationWarning(runnable, deprecation, options);
    };

    var queueRunnerFactory = function(options, args) {
      if (options.isLeaf) {
        // A spec
        options.SkipPolicy = j$.CompleteOnFirstErrorSkipPolicy;
      } else if (options.isReporter) {
        // A reporter queue
        options.SkipPolicy = j$.NeverSkipPolicy;
      } else {
        // A suite
        if (config.stopOnSpecFailure) {
          options.SkipPolicy = j$.CompleteOnFirstErrorSkipPolicy;
        } else {
          options.SkipPolicy = j$.SkipAfterBeforeAllErrorPolicy;
        }
      }

      options.clearStack = options.clearStack || clearStack;
      options.timeout = {
        setTimeout: realSetTimeout,
        clearTimeout: realClearTimeout
      };
      options.fail = self.fail;
      options.globalErrors = globalErrors;
      options.onException =
        options.onException ||
        function(e) {
          (currentRunnable() || topSuite).onException(e);
        };
      options.deprecated = self.deprecated;

      new j$.QueueRunner(options).execute(args);
    };

    var topSuite = new j$.Suite({
      id: getNextSuiteId(),
      description: 'Jasmine__TopLevel__Suite',
      expectationFactory: expectationFactory,
      asyncExpectationFactory: suiteAsyncExpectationFactory,
      expectationResultFactory: expectationResultFactory,
      autoCleanClosures: config.autoCleanClosures,
      onLateError: recordLateError
    });
    var deprecator = new j$.Deprecator(topSuite);
    currentDeclarationSuite = topSuite;

    /**
     * Provides the root suite, through which all suites and specs can be
     * accessed.
     * @function
     * @name Env#topSuite
     * @return {Suite} the root suite
     * @since 2.0.0
     */
    this.topSuite = function() {
      return topSuite.metadata;
    };

    /**
     * This represents the available reporter callback for an object passed to {@link Env#addReporter}.
     * @interface Reporter
     * @see custom_reporter
     */
    var reporter = new j$.ReportDispatcher(
      [
        /**
         * `jasmineStarted` is called after all of the specs have been loaded, but just before execution starts.
         * @function
         * @name Reporter#jasmineStarted
         * @param {JasmineStartedInfo} suiteInfo Information about the full Jasmine suite that is being run
         * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.
         * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.
         * @see async
         */
        'jasmineStarted',
        /**
         * When the entire suite has finished execution `jasmineDone` is called
         * @function
         * @name Reporter#jasmineDone
         * @param {JasmineDoneInfo} suiteInfo Information about the full Jasmine suite that just finished running.
         * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.
         * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.
         * @see async
         */
        'jasmineDone',
        /**
         * `suiteStarted` is invoked when a `describe` starts to run
         * @function
         * @name Reporter#suiteStarted
         * @param {SuiteResult} result Information about the individual {@link describe} being run
         * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.
         * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.
         * @see async
         */
        'suiteStarted',
        /**
         * `suiteDone` is invoked when all of the child specs and suites for a given suite have been run
         *
         * While jasmine doesn't require any specific functions, not defining a `suiteDone` will make it impossible for a reporter to know when a suite has failures in an `afterAll`.
         * @function
         * @name Reporter#suiteDone
         * @param {SuiteResult} result
         * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.
         * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.
         * @see async
         */
        'suiteDone',
        /**
         * `specStarted` is invoked when an `it` starts to run (including associated `beforeEach` functions)
         * @function
         * @name Reporter#specStarted
         * @param {SpecResult} result Information about the individual {@link it} being run
         * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.
         * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.
         * @see async
         */
        'specStarted',
        /**
         * `specDone` is invoked when an `it` and its associated `beforeEach` and `afterEach` functions have been run.
         *
         * While jasmine doesn't require any specific functions, not defining a `specDone` will make it impossible for a reporter to know when a spec has failed.
         * @function
         * @name Reporter#specDone
         * @param {SpecResult} result
         * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.
         * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.
         * @see async
         */
        'specDone'
      ],
      queueRunnerFactory,
      recordLateError
    );

    /**
     * Executes the specs.
     *
     * If called with no parameters or with a falsy value as the first parameter,
     * all specs will be executed except those that are excluded by a
     * [spec filter]{@link Configuration#specFilter} or other mechanism. If the
     * first parameter is a list of spec/suite IDs, only those specs/suites will
     * be run.
     *
     * Both parameters are optional, but a completion callback is only valid as
     * the second parameter. To specify a completion callback but not a list of
     * specs/suites to run, pass null or undefined as the first parameter. The
     * completion callback is supported for backward compatibility. In most
     * cases it will be more convenient to use the returned promise instead.
     *
     * execute should not be called more than once unless the env has been
     * configured with `{autoCleanClosures: false}`.
     *
     * execute returns a promise. The promise will be resolved to the same
     * {@link JasmineDoneInfo|overall result} that's passed to a reporter's
     * `jasmineDone` method, even if the suite did not pass. To determine
     * whether the suite passed, check the value that the promise resolves to
     * or use a {@link Reporter}.
     *
     * @name Env#execute
     * @since 2.0.0
     * @function
     * @param {(string[])=} runnablesToRun IDs of suites and/or specs to run
     * @param {Function=} onComplete Function that will be called after all specs have run
     * @return {Promise<JasmineDoneInfo>}
     */
    this.execute = function(runnablesToRun, onComplete) {
      if (this._executedBefore) {
        topSuite.reset();
      }
      this._executedBefore = true;
      defaultResourcesForRunnable(topSuite.id);
      installGlobalErrors();

      if (!runnablesToRun) {
        if (focusedRunnables.length) {
          runnablesToRun = focusedRunnables;
        } else {
          runnablesToRun = [topSuite.id];
        }
      }

      var order = new j$.Order({
        random: config.random,
        seed: config.seed
      });

      var processor = new j$.TreeProcessor({
        tree: topSuite,
        runnableIds: runnablesToRun,
        queueRunnerFactory: queueRunnerFactory,
        failSpecWithNoExpectations: config.failSpecWithNoExpectations,
        nodeStart: function(suite, next) {
          currentlyExecutingSuites.push(suite);
          defaultResourcesForRunnable(suite.id, suite.parentSuite.id);
          reporter.suiteStarted(suite.result, next);
          suite.startTimer();
        },
        nodeComplete: function(suite, result, next) {
          if (suite !== currentSuite()) {
            throw new Error('Tried to complete the wrong suite');
          }

          clearResourcesForRunnable(suite.id);
          currentlyExecutingSuites.pop();

          if (result.status === 'failed') {
            hasFailures = true;
          }
          suite.endTimer();

          if (suite.hadBeforeAllFailure) {
            reportChildrenOfBeforeAllFailure(suite).then(function() {
              reporter.suiteDone(result, next);
            });
          } else {
            reporter.suiteDone(result, next);
          }
        },
        orderChildren: function(node) {
          return order.sort(node.children);
        },
        excludeNode: function(spec) {
          return !config.specFilter(spec);
        }
      });

      if (!processor.processTree().valid) {
        throw new Error(
          'Invalid order: would cause a beforeAll or afterAll to be run multiple times'
        );
      }

      var jasmineTimer = new j$.Timer();
      jasmineTimer.start();

      return new Promise(function(resolve) {
        runAll(function(jasmineDoneInfo) {
          if (onComplete) {
            onComplete();
          }

          resolve(jasmineDoneInfo);
        });
      });

      function runAll(done) {
        /**
         * Information passed to the {@link Reporter#jasmineStarted} event.
         * @typedef JasmineStartedInfo
         * @property {Int} totalSpecsDefined - The total number of specs defined in this suite.
         * @property {Order} order - Information about the ordering (random or not) of this execution of the suite.
         * @since 2.0.0
         */
        reporter.jasmineStarted(
          {
            totalSpecsDefined: totalSpecsDefined,
            order: order
          },
          function() {
            currentlyExecutingSuites.push(topSuite);

            processor.execute(function() {
              (async function() {
                if (topSuite.hadBeforeAllFailure) {
                  await reportChildrenOfBeforeAllFailure(topSuite);
                }

                clearResourcesForRunnable(topSuite.id);
                currentlyExecutingSuites.pop();
                var overallStatus, incompleteReason;

                if (
                  hasFailures ||
                  topSuite.result.failedExpectations.length > 0
                ) {
                  overallStatus = 'failed';
                } else if (focusedRunnables.length > 0) {
                  overallStatus = 'incomplete';
                  incompleteReason = 'fit() or fdescribe() was found';
                } else if (totalSpecsDefined === 0) {
                  overallStatus = 'incomplete';
                  incompleteReason = 'No specs found';
                } else {
                  overallStatus = 'passed';
                }

                /**
                 * Information passed to the {@link Reporter#jasmineDone} event.
                 * @typedef JasmineDoneInfo
                 * @property {OverallStatus} overallStatus - The overall result of the suite: 'passed', 'failed', or 'incomplete'.
                 * @property {Int} totalTime - The total time (in ms) that it took to execute the suite
                 * @property {IncompleteReason} incompleteReason - Explanation of why the suite was incomplete.
                 * @property {Order} order - Information about the ordering (random or not) of this execution of the suite.
                 * @property {Expectation[]} failedExpectations - List of expectations that failed in an {@link afterAll} at the global level.
                 * @property {Expectation[]} deprecationWarnings - List of deprecation warnings that occurred at the global level.
                 * @since 2.4.0
                 */
                const jasmineDoneInfo = {
                  overallStatus: overallStatus,
                  totalTime: jasmineTimer.elapsed(),
                  incompleteReason: incompleteReason,
                  order: order,
                  failedExpectations: topSuite.result.failedExpectations,
                  deprecationWarnings: topSuite.result.deprecationWarnings
                };
                reporter.jasmineDone(jasmineDoneInfo, function() {
                  done(jasmineDoneInfo);
                });
              })();
            });
          }
        );
      }

      async function reportChildrenOfBeforeAllFailure(suite) {
        for (const child of suite.children) {
          if (child instanceof j$.Suite) {
            await new Promise(function(resolve) {
              reporter.suiteStarted(child.result, resolve);
            });
            await reportChildrenOfBeforeAllFailure(child);

            // Marking the suite passed is consistent with how suites that
            // contain failed specs but no suite-level failures are reported.
            child.result.status = 'passed';

            await new Promise(function(resolve) {
              reporter.suiteDone(child.result, resolve);
            });
          } else {
            /* a spec */
            await new Promise(function(resolve) {
              reporter.specStarted(child.result, resolve);
            });

            child.addExpectationResult(
              false,
              {
                passed: false,
                message:
                  'Not run because a beforeAll function failed. The ' +
                  'beforeAll failure will be reported on the suite that ' +
                  'caused it.'
              },
              true
            );
            child.result.status = 'failed';

            await new Promise(function(resolve) {
              reporter.specDone(child.result, resolve);
            });
          }
        }
      }
    };

    /**
     * Add a custom reporter to the Jasmine environment.
     * @name Env#addReporter
     * @since 2.0.0
     * @function
     * @param {Reporter} reporterToAdd The reporter to be added.
     * @see custom_reporter
     */
    this.addReporter = function(reporterToAdd) {
      reporter.addReporter(reporterToAdd);
    };

    /**
     * Provide a fallback reporter if no other reporters have been specified.
     * @name Env#provideFallbackReporter
     * @since 2.5.0
     * @function
     * @param {Reporter} reporterToAdd The reporter
     * @see custom_reporter
     */
    this.provideFallbackReporter = function(reporterToAdd) {
      reporter.provideFallbackReporter(reporterToAdd);
    };

    /**
     * Clear all registered reporters
     * @name Env#clearReporters
     * @since 2.5.2
     * @function
     */
    this.clearReporters = function() {
      reporter.clearReporters();
    };

    var spyFactory = new j$.SpyFactory(
      function getCustomStrategies() {
        var runnable = currentRunnable();

        if (runnable) {
          return runnableResources[runnable.id].customSpyStrategies;
        }

        return {};
      },
      function getDefaultStrategyFn() {
        var runnable = currentRunnable();

        if (runnable) {
          return runnableResources[runnable.id].defaultStrategyFn;
        }

        return undefined;
      },
      makeMatchersUtil
    );

    var spyRegistry = new j$.SpyRegistry({
      currentSpies: function() {
        if (!currentRunnable()) {
          throw new Error(
            'Spies must be created in a before function or a spec'
          );
        }
        return runnableResources[currentRunnable().id].spies;
      },
      createSpy: function(name, originalFn) {
        return self.createSpy(name, originalFn);
      }
    });

    /**
     * Configures whether Jasmine should allow the same function to be spied on
     * more than once during the execution of a spec. By default, spying on
     * a function that is already a spy will cause an error.
     * @name Env#allowRespy
     * @function
     * @since 2.5.0
     * @param {boolean} allow Whether to allow respying
     */
    this.allowRespy = function(allow) {
      spyRegistry.allowRespy(allow);
    };

    this.spyOn = function() {
      return spyRegistry.spyOn.apply(spyRegistry, arguments);
    };

    this.spyOnProperty = function() {
      return spyRegistry.spyOnProperty.apply(spyRegistry, arguments);
    };

    this.spyOnAllFunctions = function() {
      return spyRegistry.spyOnAllFunctions.apply(spyRegistry, arguments);
    };

    this.createSpy = function(name, originalFn) {
      if (arguments.length === 1 && j$.isFunction_(name)) {
        originalFn = name;
        name = originalFn.name;
      }

      return spyFactory.createSpy(name, originalFn);
    };

    this.createSpyObj = function(baseName, methodNames, propertyNames) {
      return spyFactory.createSpyObj(baseName, methodNames, propertyNames);
    };

    var ensureIsFunction = function(fn, caller) {
      if (!j$.isFunction_(fn)) {
        throw new Error(
          caller + ' expects a function argument; received ' + j$.getType_(fn)
        );
      }
    };

    var ensureIsFunctionOrAsync = function(fn, caller) {
      if (!j$.isFunction_(fn) && !j$.isAsyncFunction_(fn)) {
        throw new Error(
          caller + ' expects a function argument; received ' + j$.getType_(fn)
        );
      }
    };

    function ensureIsNotNested(method) {
      var runnable = currentRunnable();
      if (runnable !== null && runnable !== undefined) {
        throw new Error(
          "'" + method + "' should only be used in 'describe' function"
        );
      }
    }

    var suiteFactory = function(description) {
      var suite = new j$.Suite({
        id: getNextSuiteId(),
        description: description,
        parentSuite: currentDeclarationSuite,
        timer: new j$.Timer(),
        expectationFactory: expectationFactory,
        asyncExpectationFactory: suiteAsyncExpectationFactory,
        expectationResultFactory: expectationResultFactory,
        throwOnExpectationFailure: config.stopSpecOnExpectationFailure,
        autoCleanClosures: config.autoCleanClosures,
        onLateError: recordLateError
      });

      return suite;
    };

    this.describe = function(description, specDefinitions) {
      ensureIsNotNested('describe');
      ensureIsFunction(specDefinitions, 'describe');
      var suite = suiteFactory(description);
      if (specDefinitions.length > 0) {
        throw new Error('describe does not expect any arguments');
      }
      if (currentDeclarationSuite.markedExcluding) {
        suite.exclude();
      }
      addSpecsToSuite(suite, specDefinitions);
      if (suite.parentSuite && !suite.children.length) {
        throw new Error('describe with no children (describe() or it())');
      }
      return suite.metadata;
    };

    this.xdescribe = function(description, specDefinitions) {
      ensureIsNotNested('xdescribe');
      ensureIsFunction(specDefinitions, 'xdescribe');
      var suite = suiteFactory(description);
      suite.exclude();
      addSpecsToSuite(suite, specDefinitions);
      return suite.metadata;
    };

    var focusedRunnables = [];

    this.fdescribe = function(description, specDefinitions) {
      ensureIsNotNested('fdescribe');
      ensureIsFunction(specDefinitions, 'fdescribe');
      var suite = suiteFactory(description);
      suite.isFocused = true;

      focusedRunnables.push(suite.id);
      unfocusAncestor();
      addSpecsToSuite(suite, specDefinitions);

      return suite.metadata;
    };

    function addSpecsToSuite(suite, specDefinitions) {
      var parentSuite = currentDeclarationSuite;
      parentSuite.addChild(suite);
      currentDeclarationSuite = suite;

      var declarationError = null;
      try {
        specDefinitions();
      } catch (e) {
        declarationError = e;
      }

      if (declarationError) {
        suite.onException(declarationError);
      }

      currentDeclarationSuite = parentSuite;
    }

    function findFocusedAncestor(suite) {
      while (suite) {
        if (suite.isFocused) {
          return suite.id;
        }
        suite = suite.parentSuite;
      }

      return null;
    }

    function unfocusAncestor() {
      var focusedAncestor = findFocusedAncestor(currentDeclarationSuite);
      if (focusedAncestor) {
        for (var i = 0; i < focusedRunnables.length; i++) {
          if (focusedRunnables[i] === focusedAncestor) {
            focusedRunnables.splice(i, 1);
            break;
          }
        }
      }
    }

    var specFactory = function(description, fn, suite, timeout) {
      totalSpecsDefined++;
      var spec = new j$.Spec({
        id: getNextSpecId(),
        beforeAndAfterFns: beforeAndAfterFns(suite),
        expectationFactory: expectationFactory,
        asyncExpectationFactory: specAsyncExpectationFactory,
        onLateError: recordLateError,
        resultCallback: specResultCallback,
        getSpecName: function(spec) {
          return getSpecName(spec, suite);
        },
        onStart: specStarted,
        description: description,
        expectationResultFactory: expectationResultFactory,
        queueRunnerFactory: queueRunnerFactory,
        userContext: function() {
          return suite.clonedSharedUserContext();
        },
        queueableFn: {
          fn: fn,
          timeout: timeout || 0
        },
        throwOnExpectationFailure: config.stopSpecOnExpectationFailure,
        autoCleanClosures: config.autoCleanClosures,
        timer: new j$.Timer()
      });
      return spec;

      function specResultCallback(result, next) {
        clearResourcesForRunnable(spec.id);
        currentSpec = null;

        if (result.status === 'failed') {
          hasFailures = true;
        }

        reporter.specDone(result, next);
      }

      function specStarted(spec, next) {
        currentSpec = spec;
        defaultResourcesForRunnable(spec.id, suite.id);
        reporter.specStarted(spec.result, next);
      }
    };

    this.it_ = function(description, fn, timeout) {
      ensureIsNotNested('it');
      // it() sometimes doesn't have a fn argument, so only check the type if
      // it's given.
      if (arguments.length > 1 && typeof fn !== 'undefined') {
        ensureIsFunctionOrAsync(fn, 'it');
      }

      if (timeout) {
        j$.util.validateTimeout(timeout);
      }

      var spec = specFactory(description, fn, currentDeclarationSuite, timeout);
      if (currentDeclarationSuite.markedExcluding) {
        spec.exclude();
      }
      currentDeclarationSuite.addChild(spec);

      return spec;
    };

    this.it = function(description, fn, timeout) {
      const spec = this.it_(description, fn, timeout);
      return spec.metadata;
    };

    this.xit = function(description, fn, timeout) {
      ensureIsNotNested('xit');
      // xit(), like it(), doesn't always have a fn argument, so only check the
      // type when needed.
      if (arguments.length > 1 && typeof fn !== 'undefined') {
        ensureIsFunctionOrAsync(fn, 'xit');
      }
      var spec = this.it_.apply(this, arguments);
      spec.exclude('Temporarily disabled with xit');
      return spec.metadata;
    };

    this.fit = function(description, fn, timeout) {
      ensureIsNotNested('fit');
      ensureIsFunctionOrAsync(fn, 'fit');

      if (timeout) {
        j$.util.validateTimeout(timeout);
      }
      var spec = specFactory(description, fn, currentDeclarationSuite, timeout);
      currentDeclarationSuite.addChild(spec);
      focusedRunnables.push(spec.id);
      unfocusAncestor();
      return spec.metadata;
    };

    /**
     * Sets a user-defined property that will be provided to reporters as part of the properties field of {@link SpecResult}
     * @name Env#setSpecProperty
     * @since 3.6.0
     * @function
     * @param {String} key The name of the property
     * @param {*} value The value of the property
     */
    this.setSpecProperty = function(key, value) {
      if (!currentRunnable() || currentRunnable() == currentSuite()) {
        throw new Error(
          "'setSpecProperty' was used when there was no current spec"
        );
      }
      currentRunnable().setSpecProperty(key, value);
    };

    /**
     * Sets a user-defined property that will be provided to reporters as part of the properties field of {@link SuiteResult}
     * @name Env#setSuiteProperty
     * @since 3.6.0
     * @function
     * @param {String} key The name of the property
     * @param {*} value The value of the property
     */
    this.setSuiteProperty = function(key, value) {
      if (!currentSuite()) {
        throw new Error(
          "'setSuiteProperty' was used when there was no current suite"
        );
      }
      currentSuite().setSuiteProperty(key, value);
    };

    this.debugLog = function(msg) {
      var maybeSpec = currentRunnable();

      if (!maybeSpec || !maybeSpec.debugLog) {
        throw new Error("'debugLog' was called when there was no current spec");
      }

      maybeSpec.debugLog(msg);
    };

    this.expect = function(actual) {
      if (!currentRunnable()) {
        throw new Error(
          "'expect' was used when there was no current spec, this could be because an asynchronous test timed out"
        );
      }

      return currentRunnable().expect(actual);
    };

    this.expectAsync = function(actual) {
      if (!currentRunnable()) {
        throw new Error(
          "'expectAsync' was used when there was no current spec, this could be because an asynchronous test timed out"
        );
      }

      return currentRunnable().expectAsync(actual);
    };

    this.beforeEach = function(beforeEachFunction, timeout) {
      ensureIsNotNested('beforeEach');
      ensureIsFunctionOrAsync(beforeEachFunction, 'beforeEach');

      if (timeout) {
        j$.util.validateTimeout(timeout);
      }

      currentDeclarationSuite.beforeEach({
        fn: beforeEachFunction,
        timeout: timeout || 0
      });
    };

    this.beforeAll = function(beforeAllFunction, timeout) {
      ensureIsNotNested('beforeAll');
      ensureIsFunctionOrAsync(beforeAllFunction, 'beforeAll');

      if (timeout) {
        j$.util.validateTimeout(timeout);
      }

      currentDeclarationSuite.beforeAll({
        fn: beforeAllFunction,
        timeout: timeout || 0
      });
    };

    this.afterEach = function(afterEachFunction, timeout) {
      ensureIsNotNested('afterEach');
      ensureIsFunctionOrAsync(afterEachFunction, 'afterEach');

      if (timeout) {
        j$.util.validateTimeout(timeout);
      }

      afterEachFunction.isCleanup = true;
      currentDeclarationSuite.afterEach({
        fn: afterEachFunction,
        timeout: timeout || 0
      });
    };

    this.afterAll = function(afterAllFunction, timeout) {
      ensureIsNotNested('afterAll');
      ensureIsFunctionOrAsync(afterAllFunction, 'afterAll');

      if (timeout) {
        j$.util.validateTimeout(timeout);
      }

      currentDeclarationSuite.afterAll({
        fn: afterAllFunction,
        timeout: timeout || 0
      });
    };

    this.pending = function(message) {
      var fullMessage = j$.Spec.pendingSpecExceptionMessage;
      if (message) {
        fullMessage += message;
      }
      throw fullMessage;
    };

    this.fail = function(error) {
      if (!currentRunnable()) {
        throw new Error(
          "'fail' was used when there was no current spec, this could be because an asynchronous test timed out"
        );
      }

      var message = 'Failed';
      if (error) {
        message += ': ';
        if (error.message) {
          message += error.message;
        } else if (j$.isString_(error)) {
          message += error;
        } else {
          // pretty print all kind of objects. This includes arrays.
          message += makePrettyPrinter()(error);
        }
      }

      currentRunnable().addExpectationResult(false, {
        matcherName: '',
        passed: false,
        expected: '',
        actual: '',
        message: message,
        error: error && error.message ? error : null
      });

      if (config.stopSpecOnExpectationFailure) {
        throw new Error(message);
      }
    };

    this.cleanup_ = function() {
      if (globalErrors) {
        globalErrors.uninstall();
      }
    };
  }

  return Env;
};

getJasmineRequireObj().JsApiReporter = function(j$) {
  /**
   * @name jsApiReporter
   * @classdesc {@link Reporter} added by default in `boot.js` to record results for retrieval in javascript code. An instance is made available as `jsApiReporter` on the global object.
   * @class
   * @hideconstructor
   */
  function JsApiReporter(options) {
    var timer = options.timer || new j$.Timer(),
      status = 'loaded';

    this.started = false;
    this.finished = false;
    this.runDetails = {};

    this.jasmineStarted = function() {
      this.started = true;
      status = 'started';
      timer.start();
    };

    var executionTime;

    this.jasmineDone = function(runDetails) {
      this.finished = true;
      this.runDetails = runDetails;
      executionTime = timer.elapsed();
      status = 'done';
    };

    /**
     * Get the current status for the Jasmine environment.
     * @name jsApiReporter#status
     * @since 2.0.0
     * @function
     * @return {String} - One of `loaded`, `started`, or `done`
     */
    this.status = function() {
      return status;
    };

    var suites = [],
      suites_hash = {};

    this.suiteStarted = function(result) {
      suites_hash[result.id] = result;
    };

    this.suiteDone = function(result) {
      storeSuite(result);
    };

    /**
     * Get the results for a set of suites.
     *
     * Retrievable in slices for easier serialization.
     * @name jsApiReporter#suiteResults
     * @since 2.1.0
     * @function
     * @param {Number} index - The position in the suites list to start from.
     * @param {Number} length - Maximum number of suite results to return.
     * @return {SuiteResult[]}
     */
    this.suiteResults = function(index, length) {
      return suites.slice(index, index + length);
    };

    function storeSuite(result) {
      suites.push(result);
      suites_hash[result.id] = result;
    }

    /**
     * Get all of the suites in a single object, with their `id` as the key.
     * @name jsApiReporter#suites
     * @since 2.0.0
     * @function
     * @return {Object} - Map of suite id to {@link SuiteResult}
     */
    this.suites = function() {
      return suites_hash;
    };

    var specs = [];

    this.specDone = function(result) {
      specs.push(result);
    };

    /**
     * Get the results for a set of specs.
     *
     * Retrievable in slices for easier serialization.
     * @name jsApiReporter#specResults
     * @since 2.0.0
     * @function
     * @param {Number} index - The position in the specs list to start from.
     * @param {Number} length - Maximum number of specs results to return.
     * @return {SpecResult[]}
     */
    this.specResults = function(index, length) {
      return specs.slice(index, index + length);
    };

    /**
     * Get all spec results.
     * @name jsApiReporter#specs
     * @since 2.0.0
     * @function
     * @return {SpecResult[]}
     */
    this.specs = function() {
      return specs;
    };

    /**
     * Get the number of milliseconds it took for the full Jasmine suite to run.
     * @name jsApiReporter#executionTime
     * @since 2.0.0
     * @function
     * @return {Number}
     */
    this.executionTime = function() {
      return executionTime;
    };
  }

  return JsApiReporter;
};

getJasmineRequireObj().Any = function(j$) {
  function Any(expectedObject) {
    if (typeof expectedObject === 'undefined') {
      throw new TypeError(
        'jasmine.any() expects to be passed a constructor function. ' +
          'Please pass one or use jasmine.anything() to match any object.'
      );
    }
    this.expectedObject = expectedObject;
  }

  Any.prototype.asymmetricMatch = function(other) {
    if (this.expectedObject == String) {
      return typeof other == 'string' || other instanceof String;
    }

    if (this.expectedObject == Number) {
      return typeof other == 'number' || other instanceof Number;
    }

    if (this.expectedObject == Function) {
      return typeof other == 'function' || other instanceof Function;
    }

    if (this.expectedObject == Object) {
      return other !== null && typeof other == 'object';
    }

    if (this.expectedObject == Boolean) {
      return typeof other == 'boolean';
    }

    /* jshint -W122 */
    /* global Symbol */
    if (typeof Symbol != 'undefined' && this.expectedObject == Symbol) {
      return typeof other == 'symbol';
    }
    /* jshint +W122 */

    return other instanceof this.expectedObject;
  };

  Any.prototype.jasmineToString = function() {
    return '<jasmine.any(' + j$.fnNameFor(this.expectedObject) + ')>';
  };

  return Any;
};

getJasmineRequireObj().Anything = function(j$) {
  function Anything() {}

  Anything.prototype.asymmetricMatch = function(other) {
    return !j$.util.isUndefined(other) && other !== null;
  };

  Anything.prototype.jasmineToString = function() {
    return '<jasmine.anything>';
  };

  return Anything;
};

getJasmineRequireObj().ArrayContaining = function(j$) {
  function ArrayContaining(sample) {
    this.sample = sample;
  }

  ArrayContaining.prototype.asymmetricMatch = function(other, matchersUtil) {
    if (!j$.isArray_(this.sample)) {
      throw new Error(
        'You must provide an array to arrayContaining, not ' +
          j$.basicPrettyPrinter_(this.sample) +
          '.'
      );
    }

    // If the actual parameter is not an array, we can fail immediately, since it couldn't
    // possibly be an "array containing" anything. However, we also want an empty sample
    // array to match anything, so we need to double-check we aren't in that case
    if (!j$.isArray_(other) && this.sample.length > 0) {
      return false;
    }

    for (var i = 0; i < this.sample.length; i++) {
      var item = this.sample[i];
      if (!matchersUtil.contains(other, item)) {
        return false;
      }
    }

    return true;
  };

  ArrayContaining.prototype.jasmineToString = function(pp) {
    return '<jasmine.arrayContaining(' + pp(this.sample) + ')>';
  };

  return ArrayContaining;
};

getJasmineRequireObj().ArrayWithExactContents = function(j$) {
  function ArrayWithExactContents(sample) {
    this.sample = sample;
  }

  ArrayWithExactContents.prototype.asymmetricMatch = function(
    other,
    matchersUtil
  ) {
    if (!j$.isArray_(this.sample)) {
      throw new Error(
        'You must provide an array to arrayWithExactContents, not ' +
          j$.basicPrettyPrinter_(this.sample) +
          '.'
      );
    }

    if (this.sample.length !== other.length) {
      return false;
    }

    for (var i = 0; i < this.sample.length; i++) {
      var item = this.sample[i];
      if (!matchersUtil.contains(other, item)) {
        return false;
      }
    }

    return true;
  };

  ArrayWithExactContents.prototype.jasmineToString = function(pp) {
    return '<jasmine.arrayWithExactContents(' + pp(this.sample) + ')>';
  };

  return ArrayWithExactContents;
};

getJasmineRequireObj().Empty = function(j$) {
  function Empty() {}

  Empty.prototype.asymmetricMatch = function(other) {
    if (j$.isString_(other) || j$.isArray_(other) || j$.isTypedArray_(other)) {
      return other.length === 0;
    }

    if (j$.isMap(other) || j$.isSet(other)) {
      return other.size === 0;
    }

    if (j$.isObject_(other)) {
      return Object.keys(other).length === 0;
    }
    return false;
  };

  Empty.prototype.jasmineToString = function() {
    return '<jasmine.empty>';
  };

  return Empty;
};

getJasmineRequireObj().Falsy = function(j$) {
  function Falsy() {}

  Falsy.prototype.asymmetricMatch = function(other) {
    return !other;
  };

  Falsy.prototype.jasmineToString = function() {
    return '<jasmine.falsy>';
  };

  return Falsy;
};

getJasmineRequireObj().MapContaining = function(j$) {
  function MapContaining(sample) {
    if (!j$.isMap(sample)) {
      throw new Error(
        'You must provide a map to `mapContaining`, not ' +
          j$.basicPrettyPrinter_(sample)
      );
    }

    this.sample = sample;
  }

  MapContaining.prototype.asymmetricMatch = function(other, matchersUtil) {
    if (!j$.isMap(other)) return false;

    for (const [key, value] of this.sample) {
      // for each key/value pair in `sample`
      // there should be at least one pair in `other` whose key and value both match
      var hasMatch = false;
      for (const [oKey, oValue] of other) {
        if (
          matchersUtil.equals(oKey, key) &&
          matchersUtil.equals(oValue, value)
        ) {
          hasMatch = true;
          break;
        }
      }

      if (!hasMatch) {
        return false;
      }
    }

    return true;
  };

  MapContaining.prototype.jasmineToString = function(pp) {
    return '<jasmine.mapContaining(' + pp(this.sample) + ')>';
  };

  return MapContaining;
};

getJasmineRequireObj().NotEmpty = function(j$) {
  function NotEmpty() {}

  NotEmpty.prototype.asymmetricMatch = function(other) {
    if (j$.isString_(other) || j$.isArray_(other) || j$.isTypedArray_(other)) {
      return other.length !== 0;
    }

    if (j$.isMap(other) || j$.isSet(other)) {
      return other.size !== 0;
    }

    if (j$.isObject_(other)) {
      return Object.keys(other).length !== 0;
    }

    return false;
  };

  NotEmpty.prototype.jasmineToString = function() {
    return '<jasmine.notEmpty>';
  };

  return NotEmpty;
};

getJasmineRequireObj().ObjectContaining = function(j$) {
  function ObjectContaining(sample) {
    this.sample = sample;
  }

  function hasProperty(obj, property) {
    if (!obj || typeof obj !== 'object') {
      return false;
    }

    if (Object.prototype.hasOwnProperty.call(obj, property)) {
      return true;
    }

    return hasProperty(Object.getPrototypeOf(obj), property);
  }

  ObjectContaining.prototype.asymmetricMatch = function(other, matchersUtil) {
    if (typeof this.sample !== 'object') {
      throw new Error(
        "You must provide an object to objectContaining, not '" +
          this.sample +
          "'."
      );
    }
    if (typeof other !== 'object') {
      return false;
    }

    for (var property in this.sample) {
      if (
        !hasProperty(other, property) ||
        !matchersUtil.equals(this.sample[property], other[property])
      ) {
        return false;
      }
    }

    return true;
  };

  ObjectContaining.prototype.valuesForDiff_ = function(other, pp) {
    if (!j$.isObject_(other)) {
      return {
        self: this.jasmineToString(pp),
        other: other
      };
    }

    var filteredOther = {};
    Object.keys(this.sample).forEach(function(k) {
      // eq short-circuits comparison of objects that have different key sets,
      // so include all keys even if undefined.
      filteredOther[k] = other[k];
    });

    return {
      self: this.sample,
      other: filteredOther
    };
  };

  ObjectContaining.prototype.jasmineToString = function(pp) {
    return '<jasmine.objectContaining(' + pp(this.sample) + ')>';
  };

  return ObjectContaining;
};

getJasmineRequireObj().SetContaining = function(j$) {
  function SetContaining(sample) {
    if (!j$.isSet(sample)) {
      throw new Error(
        'You must provide a set to `setContaining`, not ' +
          j$.basicPrettyPrinter_(sample)
      );
    }

    this.sample = sample;
  }

  SetContaining.prototype.asymmetricMatch = function(other, matchersUtil) {
    if (!j$.isSet(other)) return false;

    for (const item of this.sample) {
      // for each item in `sample` there should be at least one matching item in `other`
      // (not using `matchersUtil.contains` because it compares set members by reference,
      // not by deep value equality)
      var hasMatch = false;
      for (const oItem of other) {
        if (matchersUtil.equals(oItem, item)) {
          hasMatch = true;
          break;
        }
      }

      if (!hasMatch) {
        return false;
      }
    }

    return true;
  };

  SetContaining.prototype.jasmineToString = function(pp) {
    return '<jasmine.setContaining(' + pp(this.sample) + ')>';
  };

  return SetContaining;
};

getJasmineRequireObj().StringContaining = function(j$) {
  function StringContaining(expected) {
    if (!j$.isString_(expected)) {
      throw new Error('Expected is not a String');
    }

    this.expected = expected;
  }

  StringContaining.prototype.asymmetricMatch = function(other) {
    if (!j$.isString_(other)) {
      // Arrays, etc. don't match no matter what their indexOf returns.
      return false;
    }

    return other.indexOf(this.expected) !== -1;
  };

  StringContaining.prototype.jasmineToString = function() {
    return '<jasmine.stringContaining("' + this.expected + '")>';
  };

  return StringContaining;
};

getJasmineRequireObj().StringMatching = function(j$) {
  function StringMatching(expected) {
    if (!j$.isString_(expected) && !j$.isA_('RegExp', expected)) {
      throw new Error('Expected is not a String or a RegExp');
    }

    this.regexp = new RegExp(expected);
  }

  StringMatching.prototype.asymmetricMatch = function(other) {
    return this.regexp.test(other);
  };

  StringMatching.prototype.jasmineToString = function() {
    return '<jasmine.stringMatching(' + this.regexp + ')>';
  };

  return StringMatching;
};

getJasmineRequireObj().Truthy = function(j$) {
  function Truthy() {}

  Truthy.prototype.asymmetricMatch = function(other) {
    return !!other;
  };

  Truthy.prototype.jasmineToString = function() {
    return '<jasmine.truthy>';
  };

  return Truthy;
};

getJasmineRequireObj().CallTracker = function(j$) {
  /**
   * @namespace Spy#calls
   * @since 2.0.0
   */
  function CallTracker() {
    var calls = [];
    var opts = {};

    this.track = function(context) {
      if (opts.cloneArgs) {
        context.args = j$.util.cloneArgs(context.args);
      }
      calls.push(context);
    };

    /**
     * Check whether this spy has been invoked.
     * @name Spy#calls#any
     * @since 2.0.0
     * @function
     * @return {Boolean}
     */
    this.any = function() {
      return !!calls.length;
    };

    /**
     * Get the number of invocations of this spy.
     * @name Spy#calls#count
     * @since 2.0.0
     * @function
     * @return {Integer}
     */
    this.count = function() {
      return calls.length;
    };

    /**
     * Get the arguments that were passed to a specific invocation of this spy.
     * @name Spy#calls#argsFor
     * @since 2.0.0
     * @function
     * @param {Integer} index The 0-based invocation index.
     * @return {Array}
     */
    this.argsFor = function(index) {
      var call = calls[index];
      return call ? call.args : [];
    };

    /**
     * Get the "this" object that was passed to a specific invocation of this spy.
     * @name Spy#calls#thisFor
     * @since 3.8.0
     * @function
     * @param {Integer} index The 0-based invocation index.
     * @return {Object?}
     */
    this.thisFor = function(index) {
      var call = calls[index];
      return call ? call.object : undefined;
    };

    /**
     * Get the raw calls array for this spy.
     * @name Spy#calls#all
     * @since 2.0.0
     * @function
     * @return {Spy.callData[]}
     */
    this.all = function() {
      return calls;
    };

    /**
     * Get all of the arguments for each invocation of this spy in the order they were received.
     * @name Spy#calls#allArgs
     * @since 2.0.0
     * @function
     * @return {Array}
     */
    this.allArgs = function() {
      var callArgs = [];
      for (var i = 0; i < calls.length; i++) {
        callArgs.push(calls[i].args);
      }

      return callArgs;
    };

    /**
     * Get the first invocation of this spy.
     * @name Spy#calls#first
     * @since 2.0.0
     * @function
     * @return {ObjecSpy.callData}
     */
    this.first = function() {
      return calls[0];
    };

    /**
     * Get the most recent invocation of this spy.
     * @name Spy#calls#mostRecent
     * @since 2.0.0
     * @function
     * @return {ObjecSpy.callData}
     */
    this.mostRecent = function() {
      return calls[calls.length - 1];
    };

    /**
     * Reset this spy as if it has never been called.
     * @name Spy#calls#reset
     * @since 2.0.0
     * @function
     */
    this.reset = function() {
      calls = [];
    };

    /**
     * Set this spy to do a shallow clone of arguments passed to each invocation.
     * @name Spy#calls#saveArgumentsByValue
     * @since 2.5.0
     * @function
     */
    this.saveArgumentsByValue = function() {
      opts.cloneArgs = true;
    };
  }

  return CallTracker;
};

getJasmineRequireObj().clearStack = function(j$) {
  var maxInlineCallCount = 10;

  function messageChannelImpl(global, setTimeout) {
    var channel = new global.MessageChannel(),
      head = {},
      tail = head;

    var taskRunning = false;
    channel.port1.onmessage = function() {
      head = head.next;
      var task = head.task;
      delete head.task;

      if (taskRunning) {
        global.setTimeout(task, 0);
      } else {
        try {
          taskRunning = true;
          task();
        } finally {
          taskRunning = false;
        }
      }
    };

    var currentCallCount = 0;
    return function clearStack(fn) {
      currentCallCount++;

      if (currentCallCount < maxInlineCallCount) {
        tail = tail.next = { task: fn };
        channel.port2.postMessage(0);
      } else {
        currentCallCount = 0;
        setTimeout(fn);
      }
    };
  }

  function getClearStack(global) {
    var currentCallCount = 0;
    var realSetTimeout = global.setTimeout;
    var setTimeoutImpl = function clearStack(fn) {
      Function.prototype.apply.apply(realSetTimeout, [global, [fn, 0]]);
    };

    if (j$.isFunction_(global.setImmediate)) {
      var realSetImmediate = global.setImmediate;
      return function(fn) {
        currentCallCount++;

        if (currentCallCount < maxInlineCallCount) {
          realSetImmediate(fn);
        } else {
          currentCallCount = 0;

          setTimeoutImpl(fn);
        }
      };
    } else if (!j$.util.isUndefined(global.MessageChannel)) {
      return messageChannelImpl(global, setTimeoutImpl);
    } else {
      return setTimeoutImpl;
    }
  }

  return getClearStack;
};

getJasmineRequireObj().Clock = function() {
  /* global process */
  var NODE_JS =
    typeof process !== 'undefined' &&
    process.versions &&
    typeof process.versions.node === 'string';

  /**
   * @class Clock
   * @since 1.3.0
   * @classdesc Jasmine's mock clock is used when testing time dependent code.<br>
   * _Note:_ Do not construct this directly. You can get the current clock with
   * {@link jasmine.clock}.
   * @hideconstructor
   */
  function Clock(global, delayedFunctionSchedulerFactory, mockDate) {
    var self = this,
      realTimingFunctions = {
        setTimeout: global.setTimeout,
        clearTimeout: global.clearTimeout,
        setInterval: global.setInterval,
        clearInterval: global.clearInterval
      },
      fakeTimingFunctions = {
        setTimeout: setTimeout,
        clearTimeout: clearTimeout,
        setInterval: setInterval,
        clearInterval: clearInterval
      },
      installed = false,
      delayedFunctionScheduler,
      timer;

    self.FakeTimeout = FakeTimeout;

    /**
     * Install the mock clock over the built-in methods.
     * @name Clock#install
     * @since 2.0.0
     * @function
     * @return {Clock}
     */
    self.install = function() {
      if (!originalTimingFunctionsIntact()) {
        throw new Error(
          'Jasmine Clock was unable to install over custom global timer functions. Is the clock already installed?'
        );
      }
      replace(global, fakeTimingFunctions);
      timer = fakeTimingFunctions;
      delayedFunctionScheduler = delayedFunctionSchedulerFactory();
      installed = true;

      return self;
    };

    /**
     * Uninstall the mock clock, returning the built-in methods to their places.
     * @name Clock#uninstall
     * @since 2.0.0
     * @function
     */
    self.uninstall = function() {
      delayedFunctionScheduler = null;
      mockDate.uninstall();
      replace(global, realTimingFunctions);

      timer = realTimingFunctions;
      installed = false;
    };

    /**
     * Execute a function with a mocked Clock
     *
     * The clock will be {@link Clock#install|install}ed before the function is called and {@link Clock#uninstall|uninstall}ed in a `finally` after the function completes.
     * @name Clock#withMock
     * @since 2.3.0
     * @function
     * @param {Function} closure The function to be called.
     */
    self.withMock = function(closure) {
      this.install();
      try {
        closure();
      } finally {
        this.uninstall();
      }
    };

    /**
     * Instruct the installed Clock to also mock the date returned by `new Date()`
     * @name Clock#mockDate
     * @since 2.1.0
     * @function
     * @param {Date} [initialDate=now] The `Date` to provide.
     */
    self.mockDate = function(initialDate) {
      mockDate.install(initialDate);
    };

    self.setTimeout = function(fn, delay, params) {
      return Function.prototype.apply.apply(timer.setTimeout, [
        global,
        arguments
      ]);
    };

    self.setInterval = function(fn, delay, params) {
      return Function.prototype.apply.apply(timer.setInterval, [
        global,
        arguments
      ]);
    };

    self.clearTimeout = function(id) {
      return Function.prototype.call.apply(timer.clearTimeout, [global, id]);
    };

    self.clearInterval = function(id) {
      return Function.prototype.call.apply(timer.clearInterval, [global, id]);
    };

    /**
     * Tick the Clock forward, running any enqueued timeouts along the way
     * @name Clock#tick
     * @since 1.3.0
     * @function
     * @param {int} millis The number of milliseconds to tick.
     */
    self.tick = function(millis) {
      if (installed) {
        delayedFunctionScheduler.tick(millis, function(millis) {
          mockDate.tick(millis);
        });
      } else {
        throw new Error(
          'Mock clock is not installed, use jasmine.clock().install()'
        );
      }
    };

    return self;

    function originalTimingFunctionsIntact() {
      return (
        global.setTimeout === realTimingFunctions.setTimeout &&
        global.clearTimeout === realTimingFunctions.clearTimeout &&
        global.setInterval === realTimingFunctions.setInterval &&
        global.clearInterval === realTimingFunctions.clearInterval
      );
    }

    function replace(dest, source) {
      for (var prop in source) {
        dest[prop] = source[prop];
      }
    }

    function setTimeout(fn, delay) {
      if (!NODE_JS) {
        return delayedFunctionScheduler.scheduleFunction(
          fn,
          delay,
          argSlice(arguments, 2)
        );
      }

      var timeout = new FakeTimeout();

      delayedFunctionScheduler.scheduleFunction(
        fn,
        delay,
        argSlice(arguments, 2),
        false,
        timeout
      );

      return timeout;
    }

    function clearTimeout(id) {
      return delayedFunctionScheduler.removeFunctionWithId(id);
    }

    function setInterval(fn, interval) {
      if (!NODE_JS) {
        return delayedFunctionScheduler.scheduleFunction(
          fn,
          interval,
          argSlice(arguments, 2),
          true
        );
      }

      var timeout = new FakeTimeout();

      delayedFunctionScheduler.scheduleFunction(
        fn,
        interval,
        argSlice(arguments, 2),
        true,
        timeout
      );

      return timeout;
    }

    function clearInterval(id) {
      return delayedFunctionScheduler.removeFunctionWithId(id);
    }

    function argSlice(argsObj, n) {
      return Array.prototype.slice.call(argsObj, n);
    }
  }

  /**
   * Mocks Node.js Timeout class
   */
  function FakeTimeout() {}

  FakeTimeout.prototype.ref = function() {
    return this;
  };

  FakeTimeout.prototype.unref = function() {
    return this;
  };

  return Clock;
};

getJasmineRequireObj().CompleteOnFirstErrorSkipPolicy = function(j$) {
  function CompleteOnFirstErrorSkipPolicy(queueableFns) {
    this.queueableFns_ = queueableFns;
    this.erroredFnIx_ = null;
  }

  CompleteOnFirstErrorSkipPolicy.prototype.skipTo = function(lastRanFnIx) {
    let i;

    for (
      i = lastRanFnIx + 1;
      i < this.queueableFns_.length && this.shouldSkip_(i);
      i++
    ) {}
    return i;
  };

  CompleteOnFirstErrorSkipPolicy.prototype.fnErrored = function(fnIx) {
    this.erroredFnIx_ = fnIx;
  };

  CompleteOnFirstErrorSkipPolicy.prototype.shouldSkip_ = function(fnIx) {
    if (this.erroredFnIx_ === null) {
      return false;
    }

    const fn = this.queueableFns_[fnIx];
    const candidateSuite = fn.suite;
    const errorSuite = this.queueableFns_[this.erroredFnIx_].suite;
    const wasCleanupFn =
      fn.type === 'afterEach' ||
      fn.type === 'afterAll' ||
      fn.type === 'specCleanup';
    return (
      !wasCleanupFn ||
      (candidateSuite && isDescendent(candidateSuite, errorSuite))
    );
  };

  function isDescendent(candidate, ancestor) {
    if (!candidate.parentSuite) {
      return false;
    } else if (candidate.parentSuite === ancestor) {
      return true;
    } else {
      return isDescendent(candidate.parentSuite, ancestor);
    }
  }

  return CompleteOnFirstErrorSkipPolicy;
};

getJasmineRequireObj().DelayedFunctionScheduler = function(j$) {
  function DelayedFunctionScheduler() {
    var self = this;
    var scheduledLookup = [];
    var scheduledFunctions = {};
    var currentTime = 0;
    var delayedFnCount = 0;
    var deletedKeys = [];

    self.tick = function(millis, tickDate) {
      millis = millis || 0;
      var endTime = currentTime + millis;

      runScheduledFunctions(endTime, tickDate);
    };

    self.scheduleFunction = function(
      funcToCall,
      millis,
      params,
      recurring,
      timeoutKey,
      runAtMillis
    ) {
      var f;
      if (typeof funcToCall === 'string') {
        /* jshint evil: true */
        f = function() {
          return eval(funcToCall);
        };
        /* jshint evil: false */
      } else {
        f = funcToCall;
      }

      millis = millis || 0;
      timeoutKey = timeoutKey || ++delayedFnCount;
      runAtMillis = runAtMillis || currentTime + millis;

      var funcToSchedule = {
        runAtMillis: runAtMillis,
        funcToCall: f,
        recurring: recurring,
        params: params,
        timeoutKey: timeoutKey,
        millis: millis
      };

      if (runAtMillis in scheduledFunctions) {
        scheduledFunctions[runAtMillis].push(funcToSchedule);
      } else {
        scheduledFunctions[runAtMillis] = [funcToSchedule];
        scheduledLookup.push(runAtMillis);
        scheduledLookup.sort(function(a, b) {
          return a - b;
        });
      }

      return timeoutKey;
    };

    self.removeFunctionWithId = function(timeoutKey) {
      deletedKeys.push(timeoutKey);

      for (var runAtMillis in scheduledFunctions) {
        var funcs = scheduledFunctions[runAtMillis];
        var i = indexOfFirstToPass(funcs, function(func) {
          return func.timeoutKey === timeoutKey;
        });

        if (i > -1) {
          if (funcs.length === 1) {
            delete scheduledFunctions[runAtMillis];
            deleteFromLookup(runAtMillis);
          } else {
            funcs.splice(i, 1);
          }

          // intervals get rescheduled when executed, so there's never more
          // than a single scheduled function with a given timeoutKey
          break;
        }
      }
    };

    return self;

    function indexOfFirstToPass(array, testFn) {
      var index = -1;

      for (var i = 0; i < array.length; ++i) {
        if (testFn(array[i])) {
          index = i;
          break;
        }
      }

      return index;
    }

    function deleteFromLookup(key) {
      var value = Number(key);
      var i = indexOfFirstToPass(scheduledLookup, function(millis) {
        return millis === value;
      });

      if (i > -1) {
        scheduledLookup.splice(i, 1);
      }
    }

    function reschedule(scheduledFn) {
      self.scheduleFunction(
        scheduledFn.funcToCall,
        scheduledFn.millis,
        scheduledFn.params,
        true,
        scheduledFn.timeoutKey,
        scheduledFn.runAtMillis + scheduledFn.millis
      );
    }

    function forEachFunction(funcsToRun, callback) {
      for (var i = 0; i < funcsToRun.length; ++i) {
        callback(funcsToRun[i]);
      }
    }

    function runScheduledFunctions(endTime, tickDate) {
      tickDate = tickDate || function() {};
      if (scheduledLookup.length === 0 || scheduledLookup[0] > endTime) {
        if (endTime >= currentTime) {
          tickDate(endTime - currentTime);
          currentTime = endTime;
        }
        return;
      }

      do {
        deletedKeys = [];
        var newCurrentTime = scheduledLookup.shift();
        if (newCurrentTime >= currentTime) {
          tickDate(newCurrentTime - currentTime);
          currentTime = newCurrentTime;
        }

        var funcsToRun = scheduledFunctions[currentTime];

        delete scheduledFunctions[currentTime];

        forEachFunction(funcsToRun, function(funcToRun) {
          if (funcToRun.recurring) {
            reschedule(funcToRun);
          }
        });

        forEachFunction(funcsToRun, function(funcToRun) {
          if (j$.util.arrayContains(deletedKeys, funcToRun.timeoutKey)) {
            // skip a timeoutKey deleted whilst we were running
            return;
          }
          funcToRun.funcToCall.apply(null, funcToRun.params || []);
        });
        deletedKeys = [];
      } while (
        scheduledLookup.length > 0 &&
        // checking first if we're out of time prevents setTimeout(0)
        // scheduled in a funcToRun from forcing an extra iteration
        currentTime !== endTime &&
        scheduledLookup[0] <= endTime
      );

      // ran out of functions to call, but still time left on the clock
      if (endTime >= currentTime) {
        tickDate(endTime - currentTime);
        currentTime = endTime;
      }
    }
  }

  return DelayedFunctionScheduler;
};

getJasmineRequireObj().Deprecator = function(j$) {
  function Deprecator(topSuite) {
    this.topSuite_ = topSuite;
    this.verbose_ = false;
    this.toSuppress_ = [];
  }

  var verboseNote =
    'Note: This message will be shown only once. Set the verboseDeprecations ' +
    'config property to true to see every occurrence.';

  Deprecator.prototype.verboseDeprecations = function(enabled) {
    this.verbose_ = enabled;
  };

  // runnable is a spec or a suite.
  // deprecation is a string or an Error.
  // See Env#deprecated for a description of the options argument.
  Deprecator.prototype.addDeprecationWarning = function(
    runnable,
    deprecation,
    options
  ) {
    options = options || {};

    if (!this.verbose_ && !j$.isError_(deprecation)) {
      if (this.toSuppress_.indexOf(deprecation) !== -1) {
        return;
      }
      this.toSuppress_.push(deprecation);
    }

    this.log_(runnable, deprecation, options);
    this.report_(runnable, deprecation, options);
  };

  Deprecator.prototype.log_ = function(runnable, deprecation, options) {
    var context;

    if (j$.isError_(deprecation)) {
      console.error(deprecation);
      return;
    }

    if (runnable === this.topSuite_ || options.ignoreRunnable) {
      context = '';
    } else if (runnable.children) {
      context = ' (in suite: ' + runnable.getFullName() + ')';
    } else {
      context = ' (in spec: ' + runnable.getFullName() + ')';
    }

    if (!options.omitStackTrace) {
      context += '\n' + this.stackTrace_();
    }

    if (!this.verbose_) {
      context += '\n' + verboseNote;
    }

    console.error('DEPRECATION: ' + deprecation + context);
  };

  Deprecator.prototype.stackTrace_ = function() {
    var formatter = new j$.ExceptionFormatter();
    return formatter.stack(j$.util.errorWithStack()).replace(/^Error\n/m, '');
  };

  Deprecator.prototype.report_ = function(runnable, deprecation, options) {
    if (options.ignoreRunnable) {
      runnable = this.topSuite_;
    }

    if (j$.isError_(deprecation)) {
      runnable.addDeprecationWarning(deprecation);
      return;
    }

    if (!this.verbose_) {
      deprecation += '\n' + verboseNote;
    }

    runnable.addDeprecationWarning({
      message: deprecation,
      omitStackTrace: options.omitStackTrace || false
    });
  };

  return Deprecator;
};

getJasmineRequireObj().errors = function() {
  function ExpectationFailed() {}

  ExpectationFailed.prototype = new Error();
  ExpectationFailed.prototype.constructor = ExpectationFailed;

  return {
    ExpectationFailed: ExpectationFailed
  };
};

getJasmineRequireObj().ExceptionFormatter = function(j$) {
  var ignoredProperties = [
    'name',
    'message',
    'stack',
    'fileName',
    'sourceURL',
    'line',
    'lineNumber',
    'column',
    'description',
    'jasmineMessage'
  ];

  function ExceptionFormatter(options) {
    var jasmineFile = (options && options.jasmineFile) || j$.util.jasmineFile();
    this.message = function(error) {
      var message = '';

      if (error.jasmineMessage) {
        message += error.jasmineMessage;
      } else if (error.name && error.message) {
        message += error.name + ': ' + error.message;
      } else if (error.message) {
        message += error.message;
      } else {
        message += error.toString() + ' thrown';
      }

      if (error.fileName || error.sourceURL) {
        message += ' in ' + (error.fileName || error.sourceURL);
      }

      if (error.line || error.lineNumber) {
        message += ' (line ' + (error.line || error.lineNumber) + ')';
      }

      return message;
    };

    this.stack = function(error, { omitMessage } = {}) {
      if (!error || !error.stack) {
        return null;
      }

      var stackTrace = new j$.StackTrace(error);
      var lines = filterJasmine(stackTrace);
      var result = '';

      if (stackTrace.message && !omitMessage) {
        lines.unshift(stackTrace.message);
      }

      result += formatProperties(error);
      result += lines.join('\n');

      return result;
    };

    function filterJasmine(stackTrace) {
      var result = [],
        jasmineMarker =
          stackTrace.style === 'webkit' ? '<Jasmine>' : '    at <Jasmine>';

      stackTrace.frames.forEach(function(frame) {
        if (frame.file !== jasmineFile) {
          result.push(frame.raw);
        } else if (result[result.length - 1] !== jasmineMarker) {
          result.push(jasmineMarker);
        }
      });

      return result;
    }

    function formatProperties(error) {
      if (!(error instanceof Object)) {
        return;
      }

      var result = {};
      var empty = true;

      for (var prop in error) {
        if (j$.util.arrayContains(ignoredProperties, prop)) {
          continue;
        }
        result[prop] = error[prop];
        empty = false;
      }

      if (!empty) {
        return 'error properties: ' + j$.basicPrettyPrinter_(result) + '\n';
      }

      return '';
    }
  }

  return ExceptionFormatter;
};

getJasmineRequireObj().Expectation = function(j$) {
  /**
   * Matchers that come with Jasmine out of the box.
   * @namespace matchers
   */
  function Expectation(options) {
    this.expector = new j$.Expector(options);

    var customMatchers = options.customMatchers || {};
    for (var matcherName in customMatchers) {
      this[matcherName] = wrapSyncCompare(
        matcherName,
        customMatchers[matcherName]
      );
    }
  }

  /**
   * Add some context for an {@link expect}
   * @function
   * @name matchers#withContext
   * @since 3.3.0
   * @param {String} message - Additional context to show when the matcher fails
   * @return {matchers}
   */
  Expectation.prototype.withContext = function withContext(message) {
    return addFilter(this, new ContextAddingFilter(message));
  };

  /**
   * Invert the matcher following this {@link expect}
   * @member
   * @name matchers#not
   * @since 1.3.0
   * @type {matchers}
   * @example
   * expect(something).not.toBe(true);
   */
  Object.defineProperty(Expectation.prototype, 'not', {
    get: function() {
      return addFilter(this, syncNegatingFilter);
    }
  });

  /**
   * Asynchronous matchers that operate on an actual value which is a promise,
   * and return a promise.
   *
   * Most async matchers will wait indefinitely for the promise to be resolved
   * or rejected, resulting in a spec timeout if that never happens. If you
   * expect that the promise will already be resolved or rejected at the time
   * the matcher is called, you can use the {@link async-matchers#already}
   * modifier to get a faster failure with a more helpful message.
   *
   * Note: Specs must await the result of each async matcher, return the
   * promise returned by the matcher, or return a promise that's derived from
   * the one returned by the matcher. Otherwise the matcher will not be
   * evaluated before the spec completes.
   *
   * @example
   * // Good
   * await expectAsync(aPromise).toBeResolved();
   * @example
   * // Good
   * return expectAsync(aPromise).toBeResolved();
   * @example
   * // Good
   * return expectAsync(aPromise).toBeResolved()
   *  .then(function() {
   *    // more spec code
   *  });
   * @example
   * // Bad
   * expectAsync(aPromise).toBeResolved();
   * @namespace async-matchers
   */
  function AsyncExpectation(options) {
    this.expector = new j$.Expector(options);

    var customAsyncMatchers = options.customAsyncMatchers || {};
    for (var matcherName in customAsyncMatchers) {
      this[matcherName] = wrapAsyncCompare(
        matcherName,
        customAsyncMatchers[matcherName]
      );
    }
  }

  /**
   * Add some context for an {@link expectAsync}
   * @function
   * @name async-matchers#withContext
   * @since 3.3.0
   * @param {String} message - Additional context to show when the async matcher fails
   * @return {async-matchers}
   */
  AsyncExpectation.prototype.withContext = function withContext(message) {
    return addFilter(this, new ContextAddingFilter(message));
  };

  /**
   * Invert the matcher following this {@link expectAsync}
   * @member
   * @name async-matchers#not
   * @type {async-matchers}
   * @example
   * await expectAsync(myPromise).not.toBeResolved();
   * @example
   * return expectAsync(myPromise).not.toBeResolved();
   */
  Object.defineProperty(AsyncExpectation.prototype, 'not', {
    get: function() {
      return addFilter(this, asyncNegatingFilter);
    }
  });

  /**
   * Fail as soon as possible if the actual is pending.
   * Otherwise evaluate the matcher.
   * @member
   * @name async-matchers#already
   * @since 3.8.0
   * @type {async-matchers}
   * @example
   * await expectAsync(myPromise).already.toBeResolved();
   * @example
   * return expectAsync(myPromise).already.toBeResolved();
   */
  Object.defineProperty(AsyncExpectation.prototype, 'already', {
    get: function() {
      return addFilter(this, expectSettledPromiseFilter);
    }
  });

  function wrapSyncCompare(name, matcherFactory) {
    return function() {
      var result = this.expector.compare(name, matcherFactory, arguments);
      this.expector.processResult(result);
    };
  }

  function wrapAsyncCompare(name, matcherFactory) {
    return function() {
      var self = this;

      // Capture the call stack here, before we go async, so that it will contain
      // frames that are relevant to the user instead of just parts of Jasmine.
      var errorForStack = j$.util.errorWithStack();

      return this.expector
        .compare(name, matcherFactory, arguments)
        .then(function(result) {
          self.expector.processResult(result, errorForStack);
        });
    };
  }

  function addCoreMatchers(prototype, matchers, wrapper) {
    for (var matcherName in matchers) {
      var matcher = matchers[matcherName];
      prototype[matcherName] = wrapper(matcherName, matcher);
    }
  }

  function addFilter(source, filter) {
    var result = Object.create(source);
    result.expector = source.expector.addFilter(filter);
    return result;
  }

  function negatedFailureMessage(result, matcherName, args, matchersUtil) {
    if (result.message) {
      if (j$.isFunction_(result.message)) {
        return result.message();
      } else {
        return result.message;
      }
    }

    args = args.slice();
    args.unshift(true);
    args.unshift(matcherName);
    return matchersUtil.buildFailureMessage.apply(matchersUtil, args);
  }

  function negate(result) {
    result.pass = !result.pass;
    return result;
  }

  var syncNegatingFilter = {
    selectComparisonFunc: function(matcher) {
      function defaultNegativeCompare() {
        return negate(matcher.compare.apply(null, arguments));
      }

      return matcher.negativeCompare || defaultNegativeCompare;
    },
    buildFailureMessage: negatedFailureMessage
  };

  var asyncNegatingFilter = {
    selectComparisonFunc: function(matcher) {
      function defaultNegativeCompare() {
        return matcher.compare.apply(this, arguments).then(negate);
      }

      return matcher.negativeCompare || defaultNegativeCompare;
    },
    buildFailureMessage: negatedFailureMessage
  };

  var expectSettledPromiseFilter = {
    selectComparisonFunc: function(matcher) {
      return function(actual) {
        var matcherArgs = arguments;

        return j$.isPending_(actual).then(function(isPending) {
          if (isPending) {
            return {
              pass: false,
              message:
                'Expected a promise to be settled (via ' +
                'expectAsync(...).already) but it was pending.'
            };
          } else {
            return matcher.compare.apply(null, matcherArgs);
          }
        });
      };
    }
  };

  function ContextAddingFilter(message) {
    this.message = message;
  }

  ContextAddingFilter.prototype.modifyFailureMessage = function(msg) {
    var nl = msg.indexOf('\n');

    if (nl === -1) {
      return this.message + ': ' + msg;
    } else {
      return this.message + ':\n' + indent(msg);
    }
  };

  function indent(s) {
    return s.replace(/^/gm, '    ');
  }

  return {
    factory: function(options) {
      return new Expectation(options || {});
    },
    addCoreMatchers: function(matchers) {
      addCoreMatchers(Expectation.prototype, matchers, wrapSyncCompare);
    },
    asyncFactory: function(options) {
      return new AsyncExpectation(options || {});
    },
    addAsyncCoreMatchers: function(matchers) {
      addCoreMatchers(AsyncExpectation.prototype, matchers, wrapAsyncCompare);
    }
  };
};

getJasmineRequireObj().ExpectationFilterChain = function() {
  function ExpectationFilterChain(maybeFilter, prev) {
    this.filter_ = maybeFilter;
    this.prev_ = prev;
  }

  ExpectationFilterChain.prototype.addFilter = function(filter) {
    return new ExpectationFilterChain(filter, this);
  };

  ExpectationFilterChain.prototype.selectComparisonFunc = function(matcher) {
    return this.callFirst_('selectComparisonFunc', arguments).result;
  };

  ExpectationFilterChain.prototype.buildFailureMessage = function(
    result,
    matcherName,
    args,
    matchersUtil
  ) {
    return this.callFirst_('buildFailureMessage', arguments).result;
  };

  ExpectationFilterChain.prototype.modifyFailureMessage = function(msg) {
    var result = this.callFirst_('modifyFailureMessage', arguments).result;
    return result || msg;
  };

  ExpectationFilterChain.prototype.callFirst_ = function(fname, args) {
    var prevResult;

    if (this.prev_) {
      prevResult = this.prev_.callFirst_(fname, args);

      if (prevResult.found) {
        return prevResult;
      }
    }

    if (this.filter_ && this.filter_[fname]) {
      return {
        found: true,
        result: this.filter_[fname].apply(this.filter_, args)
      };
    }

    return { found: false };
  };

  return ExpectationFilterChain;
};

//TODO: expectation result may make more sense as a presentation of an expectation.
getJasmineRequireObj().buildExpectationResult = function(j$) {
  function buildExpectationResult(options) {
    var messageFormatter = options.messageFormatter || function() {},
      stackFormatter = options.stackFormatter || function() {};

    /**
     * @typedef Expectation
     * @property {String} matcherName - The name of the matcher that was executed for this expectation.
     * @property {String} message - The failure message for the expectation.
     * @property {String} stack - The stack trace for the failure if available.
     * @property {Boolean} passed - Whether the expectation passed or failed.
     * @property {Object} expected - If the expectation failed, what was the expected value.
     * @property {Object} actual - If the expectation failed, what actual value was produced.
     * @property {String|undefined} globalErrorType - The type of an error that
     * is reported on the top suite. Valid values are undefined, "afterAll",
     * "load", "lateExpectation", and "lateError".
     */
    var result = {
      matcherName: options.matcherName,
      message: message(),
      stack: options.omitStackTrace ? '' : stack(),
      passed: options.passed
    };

    if (!result.passed) {
      result.expected = options.expected;
      result.actual = options.actual;

      if (options.error && !j$.isString_(options.error)) {
        if ('code' in options.error) {
          result.code = options.error.code;
        }

        if (
          options.error.code === 'ERR_ASSERTION' &&
          options.expected === '' &&
          options.actual === ''
        ) {
          result.expected = options.error.expected;
          result.actual = options.error.actual;
          result.matcherName = 'assert ' + options.error.operator;
        }
      }
    }

    return result;

    function message() {
      if (options.passed) {
        return 'Passed.';
      } else if (options.message) {
        return options.message;
      } else if (options.error) {
        return messageFormatter(options.error);
      }
      return '';
    }

    function stack() {
      if (options.passed) {
        return '';
      }

      var error = options.error;
      if (!error) {
        if (options.errorForStack) {
          error = options.errorForStack;
        } else if (options.stack) {
          error = options;
        } else {
          try {
            throw new Error(message());
          } catch (e) {
            error = e;
          }
        }
      }
      // Omit the message from the stack trace because it will be
      // included elsewhere.
      return stackFormatter(error, { omitMessage: true });
    }
  }

  return buildExpectationResult;
};

getJasmineRequireObj().Expector = function(j$) {
  function Expector(options) {
    this.matchersUtil = options.matchersUtil || {
      buildFailureMessage: function() {}
    };
    this.actual = options.actual;
    this.addExpectationResult = options.addExpectationResult || function() {};
    this.filters = new j$.ExpectationFilterChain();
  }

  Expector.prototype.instantiateMatcher = function(
    matcherName,
    matcherFactory,
    args
  ) {
    this.matcherName = matcherName;
    this.args = Array.prototype.slice.call(args, 0);
    this.expected = this.args.slice(0);

    this.args.unshift(this.actual);

    var matcher = matcherFactory(this.matchersUtil);

    var comparisonFunc = this.filters.selectComparisonFunc(matcher);
    return comparisonFunc || matcher.compare;
  };

  Expector.prototype.buildMessage = function(result) {
    var self = this;

    if (result.pass) {
      return '';
    }

    var msg = this.filters.buildFailureMessage(
      result,
      this.matcherName,
      this.args,
      this.matchersUtil,
      defaultMessage
    );
    return this.filters.modifyFailureMessage(msg || defaultMessage());

    function defaultMessage() {
      if (!result.message) {
        var args = self.args.slice();
        args.unshift(false);
        args.unshift(self.matcherName);
        return self.matchersUtil.buildFailureMessage.apply(
          self.matchersUtil,
          args
        );
      } else if (j$.isFunction_(result.message)) {
        return result.message();
      } else {
        return result.message;
      }
    }
  };

  Expector.prototype.compare = function(matcherName, matcherFactory, args) {
    var matcherCompare = this.instantiateMatcher(
      matcherName,
      matcherFactory,
      args
    );
    return matcherCompare.apply(null, this.args);
  };

  Expector.prototype.addFilter = function(filter) {
    var result = Object.create(this);
    result.filters = this.filters.addFilter(filter);
    return result;
  };

  Expector.prototype.processResult = function(result, errorForStack) {
    var message = this.buildMessage(result);

    if (this.expected.length === 1) {
      this.expected = this.expected[0];
    }

    this.addExpectationResult(result.pass, {
      matcherName: this.matcherName,
      passed: result.pass,
      message: message,
      error: errorForStack ? undefined : result.error,
      errorForStack: errorForStack || undefined,
      actual: this.actual,
      expected: this.expected // TODO: this may need to be arrayified/sliced
    });
  };

  return Expector;
};

getJasmineRequireObj().formatErrorMsg = function() {
  function generateErrorMsg(domain, usage) {
    var usageDefinition = usage ? '\nUsage: ' + usage : '';

    return function errorMsg(msg) {
      return domain + ' : ' + msg + usageDefinition;
    };
  }

  return generateErrorMsg;
};

getJasmineRequireObj().GlobalErrors = function(j$) {
  function GlobalErrors(global) {
    var handlers = [];
    global = global || j$.getGlobal();

    var onerror = function onerror() {
      var handler = handlers[handlers.length - 1];

      if (handler) {
        handler.apply(null, Array.prototype.slice.call(arguments, 0));
      } else {
        throw arguments[0];
      }
    };

    this.originalHandlers = {};
    this.jasmineHandlers = {};
    this.installOne_ = function installOne_(errorType, jasmineMessage) {
      function taggedOnError(error) {
        var substituteMsg;

        if (j$.isError_(error)) {
          error.jasmineMessage = jasmineMessage + ': ' + error;
        } else {
          if (error) {
            substituteMsg = jasmineMessage + ': ' + error;
          } else {
            substituteMsg = jasmineMessage + ' with no error or message';
          }

          if (errorType === 'unhandledRejection') {
            substituteMsg +=
              '\n' +
              '(Tip: to get a useful stack trace, use ' +
              'Promise.reject(new Error(...)) instead of Promise.reject(' +
              (error ? '...' : '') +
              ').)';
          }

          error = new Error(substituteMsg);
        }

        var handler = handlers[handlers.length - 1];

        if (handler) {
          handler(error);
        } else {
          throw error;
        }
      }

      this.originalHandlers[errorType] = global.process.listeners(errorType);
      this.jasmineHandlers[errorType] = taggedOnError;

      global.process.removeAllListeners(errorType);
      global.process.on(errorType, taggedOnError);

      this.uninstall = function uninstall() {
        var errorTypes = Object.keys(this.originalHandlers);
        for (var iType = 0; iType < errorTypes.length; iType++) {
          var errorType = errorTypes[iType];
          global.process.removeListener(
            errorType,
            this.jasmineHandlers[errorType]
          );
          for (var i = 0; i < this.originalHandlers[errorType].length; i++) {
            global.process.on(errorType, this.originalHandlers[errorType][i]);
          }
          delete this.originalHandlers[errorType];
          delete this.jasmineHandlers[errorType];
        }
      };
    };

    this.install = function install() {
      if (
        global.process &&
        global.process.listeners &&
        j$.isFunction_(global.process.on)
      ) {
        this.installOne_('uncaughtException', 'Uncaught exception');
        this.installOne_('unhandledRejection', 'Unhandled promise rejection');
      } else {
        var originalHandler = global.onerror;
        global.onerror = onerror;

        var browserRejectionHandler = function browserRejectionHandler(event) {
          if (j$.isError_(event.reason)) {
            event.reason.jasmineMessage =
              'Unhandled promise rejection: ' + event.reason;
            global.onerror(event.reason);
          } else {
            global.onerror('Unhandled promise rejection: ' + event.reason);
          }
        };

        if (global.addEventListener) {
          global.addEventListener(
            'unhandledrejection',
            browserRejectionHandler
          );
        }

        this.uninstall = function uninstall() {
          global.onerror = originalHandler;
          if (global.removeEventListener) {
            global.removeEventListener(
              'unhandledrejection',
              browserRejectionHandler
            );
          }
        };
      }
    };

    this.pushListener = function pushListener(listener) {
      handlers.push(listener);
    };

    this.popListener = function popListener(listener) {
      if (!listener) {
        throw new Error('popListener expects a listener');
      }

      handlers.pop();
    };
  }

  return GlobalErrors;
};

getJasmineRequireObj().toBePending = function(j$) {
  /**
   * Expect a promise to be pending, i.e. the promise is neither resolved nor rejected.
   * @function
   * @async
   * @name async-matchers#toBePending
   * @since 3.6
   * @example
   * await expectAsync(aPromise).toBePending();
   */
  return function toBePending() {
    return {
      compare: function(actual) {
        if (!j$.isPromiseLike(actual)) {
          throw new Error('Expected toBePending to be called on a promise.');
        }
        var want = {};
        return Promise.race([actual, Promise.resolve(want)]).then(
          function(got) {
            return { pass: want === got };
          },
          function() {
            return { pass: false };
          }
        );
      }
    };
  };
};

getJasmineRequireObj().toBeRejected = function(j$) {
  /**
   * Expect a promise to be rejected.
   * @function
   * @async
   * @name async-matchers#toBeRejected
   * @since 3.1.0
   * @example
   * await expectAsync(aPromise).toBeRejected();
   * @example
   * return expectAsync(aPromise).toBeRejected();
   */
  return function toBeRejected() {
    return {
      compare: function(actual) {
        if (!j$.isPromiseLike(actual)) {
          throw new Error('Expected toBeRejected to be called on a promise.');
        }
        return actual.then(
          function() {
            return { pass: false };
          },
          function() {
            return { pass: true };
          }
        );
      }
    };
  };
};

getJasmineRequireObj().toBeRejectedWith = function(j$) {
  /**
   * Expect a promise to be rejected with a value equal to the expected, using deep equality comparison.
   * @function
   * @async
   * @name async-matchers#toBeRejectedWith
   * @since 3.3.0
   * @param {Object} expected - Value that the promise is expected to be rejected with
   * @example
   * await expectAsync(aPromise).toBeRejectedWith({prop: 'value'});
   * @example
   * return expectAsync(aPromise).toBeRejectedWith({prop: 'value'});
   */
  return function toBeRejectedWith(matchersUtil) {
    return {
      compare: function(actualPromise, expectedValue) {
        if (!j$.isPromiseLike(actualPromise)) {
          throw new Error(
            'Expected toBeRejectedWith to be called on a promise.'
          );
        }

        function prefix(passed) {
          return (
            'Expected a promise ' +
            (passed ? 'not ' : '') +
            'to be rejected with ' +
            matchersUtil.pp(expectedValue)
          );
        }

        return actualPromise.then(
          function() {
            return {
              pass: false,
              message: prefix(false) + ' but it was resolved.'
            };
          },
          function(actualValue) {
            if (matchersUtil.equals(actualValue, expectedValue)) {
              return {
                pass: true,
                message: prefix(true) + '.'
              };
            } else {
              return {
                pass: false,
                message:
                  prefix(false) +
                  ' but it was rejected with ' +
                  matchersUtil.pp(actualValue) +
                  '.'
              };
            }
          }
        );
      }
    };
  };
};

getJasmineRequireObj().toBeRejectedWithError = function(j$) {
  /**
   * Expect a promise to be rejected with a value matched to the expected
   * @function
   * @async
   * @name async-matchers#toBeRejectedWithError
   * @since 3.5.0
   * @param {Error} [expected] - `Error` constructor the object that was thrown needs to be an instance of. If not provided, `Error` will be used.
   * @param {RegExp|String} [message] - The message that should be set on the thrown `Error`
   * @example
   * await expectAsync(aPromise).toBeRejectedWithError(MyCustomError, 'Error message');
   * await expectAsync(aPromise).toBeRejectedWithError(MyCustomError, /Error message/);
   * await expectAsync(aPromise).toBeRejectedWithError(MyCustomError);
   * await expectAsync(aPromise).toBeRejectedWithError('Error message');
   * return expectAsync(aPromise).toBeRejectedWithError(/Error message/);
   */
  return function toBeRejectedWithError(matchersUtil) {
    return {
      compare: function(actualPromise, arg1, arg2) {
        if (!j$.isPromiseLike(actualPromise)) {
          throw new Error(
            'Expected toBeRejectedWithError to be called on a promise.'
          );
        }

        var expected = getExpectedFromArgs(arg1, arg2, matchersUtil);

        return actualPromise.then(
          function() {
            return {
              pass: false,
              message: 'Expected a promise to be rejected but it was resolved.'
            };
          },
          function(actualValue) {
            return matchError(actualValue, expected, matchersUtil);
          }
        );
      }
    };
  };

  function matchError(actual, expected, matchersUtil) {
    if (!j$.isError_(actual)) {
      return fail(expected, 'rejected with ' + matchersUtil.pp(actual));
    }

    if (!(actual instanceof expected.error)) {
      return fail(
        expected,
        'rejected with type ' + j$.fnNameFor(actual.constructor)
      );
    }

    var actualMessage = actual.message;

    if (
      actualMessage === expected.message ||
      typeof expected.message === 'undefined'
    ) {
      return pass(expected);
    }

    if (
      expected.message instanceof RegExp &&
      expected.message.test(actualMessage)
    ) {
      return pass(expected);
    }

    return fail(expected, 'rejected with ' + matchersUtil.pp(actual));
  }

  function pass(expected) {
    return {
      pass: true,
      message:
        'Expected a promise not to be rejected with ' +
        expected.printValue +
        ', but it was.'
    };
  }

  function fail(expected, message) {
    return {
      pass: false,
      message:
        'Expected a promise to be rejected with ' +
        expected.printValue +
        ' but it was ' +
        message +
        '.'
    };
  }

  function getExpectedFromArgs(arg1, arg2, matchersUtil) {
    var error, message;

    if (isErrorConstructor(arg1)) {
      error = arg1;
      message = arg2;
    } else {
      error = Error;
      message = arg1;
    }

    return {
      error: error,
      message: message,
      printValue:
        j$.fnNameFor(error) +
        (typeof message === 'undefined' ? '' : ': ' + matchersUtil.pp(message))
    };
  }

  function isErrorConstructor(value) {
    return (
      typeof value === 'function' &&
      (value === Error || j$.isError_(value.prototype))
    );
  }
};

getJasmineRequireObj().toBeResolved = function(j$) {
  /**
   * Expect a promise to be resolved.
   * @function
   * @async
   * @name async-matchers#toBeResolved
   * @since 3.1.0
   * @example
   * await expectAsync(aPromise).toBeResolved();
   * @example
   * return expectAsync(aPromise).toBeResolved();
   */
  return function toBeResolved(matchersUtil) {
    return {
      compare: function(actual) {
        if (!j$.isPromiseLike(actual)) {
          throw new Error('Expected toBeResolved to be called on a promise.');
        }

        return actual.then(
          function() {
            return { pass: true };
          },
          function(e) {
            return {
              pass: false,
              message:
                'Expected a promise to be resolved but it was ' +
                'rejected with ' +
                matchersUtil.pp(e) +
                '.'
            };
          }
        );
      }
    };
  };
};

getJasmineRequireObj().toBeResolvedTo = function(j$) {
  /**
   * Expect a promise to be resolved to a value equal to the expected, using deep equality comparison.
   * @function
   * @async
   * @name async-matchers#toBeResolvedTo
   * @since 3.1.0
   * @param {Object} expected - Value that the promise is expected to resolve to
   * @example
   * await expectAsync(aPromise).toBeResolvedTo({prop: 'value'});
   * @example
   * return expectAsync(aPromise).toBeResolvedTo({prop: 'value'});
   */
  return function toBeResolvedTo(matchersUtil) {
    return {
      compare: function(actualPromise, expectedValue) {
        if (!j$.isPromiseLike(actualPromise)) {
          throw new Error('Expected toBeResolvedTo to be called on a promise.');
        }

        function prefix(passed) {
          return (
            'Expected a promise ' +
            (passed ? 'not ' : '') +
            'to be resolved to ' +
            matchersUtil.pp(expectedValue)
          );
        }

        return actualPromise.then(
          function(actualValue) {
            if (matchersUtil.equals(actualValue, expectedValue)) {
              return {
                pass: true,
                message: prefix(true) + '.'
              };
            } else {
              return {
                pass: false,
                message:
                  prefix(false) +
                  ' but it was resolved to ' +
                  matchersUtil.pp(actualValue) +
                  '.'
              };
            }
          },
          function(e) {
            return {
              pass: false,
              message:
                prefix(false) +
                ' but it was rejected with ' +
                matchersUtil.pp(e) +
                '.'
            };
          }
        );
      }
    };
  };
};

getJasmineRequireObj().DiffBuilder = function(j$) {
  return function DiffBuilder(config) {
    var prettyPrinter = (config || {}).prettyPrinter || j$.makePrettyPrinter(),
      mismatches = new j$.MismatchTree(),
      path = new j$.ObjectPath(),
      actualRoot = undefined,
      expectedRoot = undefined;

    return {
      setRoots: function(actual, expected) {
        actualRoot = actual;
        expectedRoot = expected;
      },

      recordMismatch: function(formatter) {
        mismatches.add(path, formatter);
      },

      getMessage: function() {
        var messages = [];

        mismatches.traverse(function(path, isLeaf, formatter) {
          var actualCustom,
            expectedCustom,
            useCustom,
            derefResult = dereferencePath(
              path,
              actualRoot,
              expectedRoot,
              prettyPrinter
            ),
            actual = derefResult.actual,
            expected = derefResult.expected;

          if (formatter) {
            messages.push(formatter(actual, expected, path, prettyPrinter));
            return true;
          }

          actualCustom = prettyPrinter.customFormat_(actual);
          expectedCustom = prettyPrinter.customFormat_(expected);
          useCustom = !(
            j$.util.isUndefined(actualCustom) &&
            j$.util.isUndefined(expectedCustom)
          );

          if (useCustom) {
            messages.push(
              wrapPrettyPrinted(actualCustom, expectedCustom, path)
            );
            return false; // don't recurse further
          }

          if (isLeaf) {
            messages.push(
              defaultFormatter(actual, expected, path, prettyPrinter)
            );
          }

          return true;
        });

        return messages.join('\n');
      },

      withPath: function(pathComponent, block) {
        var oldPath = path;
        path = path.add(pathComponent);
        block();
        path = oldPath;
      }
    };

    function defaultFormatter(actual, expected, path, prettyPrinter) {
      return wrapPrettyPrinted(
        prettyPrinter(actual),
        prettyPrinter(expected),
        path
      );
    }

    function wrapPrettyPrinted(actual, expected, path) {
      return (
        'Expected ' +
        path +
        (path.depth() ? ' = ' : '') +
        actual +
        ' to equal ' +
        expected +
        '.'
      );
    }
  };

  function dereferencePath(objectPath, actual, expected, pp) {
    function handleAsymmetricExpected() {
      if (
        j$.isAsymmetricEqualityTester_(expected) &&
        j$.isFunction_(expected.valuesForDiff_)
      ) {
        var asymmetricResult = expected.valuesForDiff_(actual, pp);
        expected = asymmetricResult.self;
        actual = asymmetricResult.other;
      }
    }

    var i;
    handleAsymmetricExpected();

    for (i = 0; i < objectPath.components.length; i++) {
      actual = actual[objectPath.components[i]];
      expected = expected[objectPath.components[i]];
      handleAsymmetricExpected();
    }

    return { actual: actual, expected: expected };
  }
};

getJasmineRequireObj().MatchersUtil = function(j$) {
  /**
   * @class MatchersUtil
   * @classdesc Utilities for use in implementing matchers.<br>
   * _Note:_ Do not construct this directly. Jasmine will construct one and
   * pass it to matchers and asymmetric equality testers.
   * @hideconstructor
   */
  function MatchersUtil(options) {
    options = options || {};
    this.customTesters_ = options.customTesters || [];
    /**
     * Formats a value for use in matcher failure messages and similar contexts,
     * taking into account the current set of custom value formatters.
     * @function
     * @name MatchersUtil#pp
     * @since 3.6.0
     * @param {*} value The value to pretty-print
     * @return {string} The pretty-printed value
     */
    this.pp = options.pp || function() {};
  }

  /**
   * Determines whether `haystack` contains `needle`, using the same comparison
   * logic as {@link MatchersUtil#equals}.
   * @function
   * @name MatchersUtil#contains
   * @since 2.0.0
   * @param {*} haystack The collection to search
   * @param {*} needle The value to search for
   * @returns {boolean} True if `needle` was found in `haystack`
   */
  MatchersUtil.prototype.contains = function(haystack, needle) {
    if (!haystack) {
      return false;
    }

    if (j$.isSet(haystack)) {
      // Try .has() first. It should be faster in cases where
      // needle === something in haystack. Fall back to .equals() comparison
      // if that fails.
      if (haystack.has(needle)) {
        return true;
      }
    }

    if (j$.isIterable_(haystack) && !j$.isString_(haystack)) {
      // Arrays, Sets, etc.
      for (const candidate of haystack) {
        if (this.equals(candidate, needle)) {
          return true;
        }
      }

      return false;
    }

    if (haystack.indexOf) {
      // Mainly strings
      return haystack.indexOf(needle) >= 0;
    }

    if (j$.isNumber_(haystack.length)) {
      // Objects that are shaped like arrays but aren't iterable
      for (var i = 0; i < haystack.length; i++) {
        if (this.equals(haystack[i], needle)) {
          return true;
        }
      }
    }

    return false;
  };

  MatchersUtil.prototype.buildFailureMessage = function() {
    var self = this;
    var args = Array.prototype.slice.call(arguments, 0),
      matcherName = args[0],
      isNot = args[1],
      actual = args[2],
      expected = args.slice(3),
      englishyPredicate = matcherName.replace(/[A-Z]/g, function(s) {
        return ' ' + s.toLowerCase();
      });

    var message =
      'Expected ' +
      self.pp(actual) +
      (isNot ? ' not ' : ' ') +
      englishyPredicate;

    if (expected.length > 0) {
      for (var i = 0; i < expected.length; i++) {
        if (i > 0) {
          message += ',';
        }
        message += ' ' + self.pp(expected[i]);
      }
    }

    return message + '.';
  };

  MatchersUtil.prototype.asymmetricDiff_ = function(
    a,
    b,
    aStack,
    bStack,
    diffBuilder
  ) {
    if (j$.isFunction_(b.valuesForDiff_)) {
      var values = b.valuesForDiff_(a, this.pp);
      this.eq_(values.other, values.self, aStack, bStack, diffBuilder);
    } else {
      diffBuilder.recordMismatch();
    }
  };

  MatchersUtil.prototype.asymmetricMatch_ = function(
    a,
    b,
    aStack,
    bStack,
    diffBuilder
  ) {
    var asymmetricA = j$.isAsymmetricEqualityTester_(a),
      asymmetricB = j$.isAsymmetricEqualityTester_(b),
      result;

    if (asymmetricA === asymmetricB) {
      return undefined;
    }

    if (asymmetricA) {
      result = a.asymmetricMatch(b, this);
      if (!result) {
        diffBuilder.recordMismatch();
      }
      return result;
    }

    if (asymmetricB) {
      result = b.asymmetricMatch(a, this);
      if (!result) {
        this.asymmetricDiff_(a, b, aStack, bStack, diffBuilder);
      }
      return result;
    }
  };

  /**
   * Determines whether two values are deeply equal to each other.
   * @function
   * @name MatchersUtil#equals
   * @since 2.0.0
   * @param {*} a The first value to compare
   * @param {*} b The second value to compare
   * @returns {boolean} True if the values are equal
   */
  MatchersUtil.prototype.equals = function(a, b, diffBuilder) {
    diffBuilder = diffBuilder || j$.NullDiffBuilder();
    diffBuilder.setRoots(a, b);

    return this.eq_(a, b, [], [], diffBuilder);
  };

  // Equality function lovingly adapted from isEqual in
  //   [Underscore](http://underscorejs.org)
  MatchersUtil.prototype.eq_ = function(a, b, aStack, bStack, diffBuilder) {
    var result = true,
      self = this,
      i;

    var asymmetricResult = this.asymmetricMatch_(
      a,
      b,
      aStack,
      bStack,
      diffBuilder
    );
    if (!j$.util.isUndefined(asymmetricResult)) {
      return asymmetricResult;
    }

    for (i = 0; i < this.customTesters_.length; i++) {
      var customTesterResult = this.customTesters_[i](a, b);
      if (!j$.util.isUndefined(customTesterResult)) {
        if (!customTesterResult) {
          diffBuilder.recordMismatch();
        }
        return customTesterResult;
      }
    }

    if (a instanceof Error && b instanceof Error) {
      result = a.message == b.message;
      if (!result) {
        diffBuilder.recordMismatch();
      }
      return result;
    }

    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) {
      result = a !== 0 || 1 / a == 1 / b;
      if (!result) {
        diffBuilder.recordMismatch();
      }
      return result;
    }
    // A strict comparison is necessary because `null == undefined`.
    if (a === null || b === null) {
      result = a === b;
      if (!result) {
        diffBuilder.recordMismatch();
      }
      return result;
    }
    var className = Object.prototype.toString.call(a);
    if (className != Object.prototype.toString.call(b)) {
      diffBuilder.recordMismatch();
      return false;
    }
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        result = a == String(b);
        if (!result) {
          diffBuilder.recordMismatch();
        }
        return result;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        result =
          a != +a ? b != +b : a === 0 && b === 0 ? 1 / a == 1 / b : a == +b;
        if (!result) {
          diffBuilder.recordMismatch();
        }
        return result;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        result = +a == +b;
        if (!result) {
          diffBuilder.recordMismatch();
        }
        return result;
      case '[object ArrayBuffer]':
        // If we have an instance of ArrayBuffer the Uint8Array ctor
        // will be defined as well
        return self.eq_(
          new Uint8Array(a),
          new Uint8Array(b),
          aStack,
          bStack,
          diffBuilder
        );
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return (
          a.source == b.source &&
          a.global == b.global &&
          a.multiline == b.multiline &&
          a.ignoreCase == b.ignoreCase
        );
    }
    if (typeof a != 'object' || typeof b != 'object') {
      diffBuilder.recordMismatch();
      return false;
    }

    var aIsDomNode = j$.isDomNode(a);
    var bIsDomNode = j$.isDomNode(b);
    if (aIsDomNode && bIsDomNode) {
      // At first try to use DOM3 method isEqualNode
      result = a.isEqualNode(b);
      if (!result) {
        diffBuilder.recordMismatch();
      }
      return result;
    }
    if (aIsDomNode || bIsDomNode) {
      diffBuilder.recordMismatch();
      return false;
    }

    var aIsPromise = j$.isPromise(a);
    var bIsPromise = j$.isPromise(b);
    if (aIsPromise && bIsPromise) {
      return a === b;
    }

    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) {
        return bStack[length] == b;
      }
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0;
    // Recursively compare objects and arrays.
    // Compare array lengths to determine if a deep comparison is necessary.
    if (className == '[object Array]') {
      var aLength = a.length;
      var bLength = b.length;

      diffBuilder.withPath('length', function() {
        if (aLength !== bLength) {
          diffBuilder.recordMismatch();
          result = false;
        }
      });

      for (i = 0; i < aLength || i < bLength; i++) {
        diffBuilder.withPath(i, function() {
          if (i >= bLength) {
            diffBuilder.recordMismatch(
              actualArrayIsLongerFormatter.bind(null, self.pp)
            );
            result = false;
          } else {
            result =
              self.eq_(
                i < aLength ? a[i] : void 0,
                i < bLength ? b[i] : void 0,
                aStack,
                bStack,
                diffBuilder
              ) && result;
          }
        });
      }
      if (!result) {
        return false;
      }
    } else if (j$.isMap(a) && j$.isMap(b)) {
      if (a.size != b.size) {
        diffBuilder.recordMismatch();
        return false;
      }

      var keysA = [];
      var keysB = [];
      a.forEach(function(valueA, keyA) {
        keysA.push(keyA);
      });
      b.forEach(function(valueB, keyB) {
        keysB.push(keyB);
      });

      // For both sets of keys, check they map to equal values in both maps.
      // Keep track of corresponding keys (in insertion order) in order to handle asymmetric obj keys.
      var mapKeys = [keysA, keysB];
      var cmpKeys = [keysB, keysA];
      var mapIter, mapKey, mapValueA, mapValueB;
      var cmpIter, cmpKey;
      for (i = 0; result && i < mapKeys.length; i++) {
        mapIter = mapKeys[i];
        cmpIter = cmpKeys[i];

        for (var j = 0; result && j < mapIter.length; j++) {
          mapKey = mapIter[j];
          cmpKey = cmpIter[j];
          mapValueA = a.get(mapKey);

          // Only use the cmpKey when one of the keys is asymmetric and the corresponding key matches,
          // otherwise explicitly look up the mapKey in the other Map since we want keys with unique
          // obj identity (that are otherwise equal) to not match.
          if (
            j$.isAsymmetricEqualityTester_(mapKey) ||
            (j$.isAsymmetricEqualityTester_(cmpKey) &&
              this.eq_(mapKey, cmpKey, aStack, bStack, j$.NullDiffBuilder()))
          ) {
            mapValueB = b.get(cmpKey);
          } else {
            mapValueB = b.get(mapKey);
          }
          result = this.eq_(
            mapValueA,
            mapValueB,
            aStack,
            bStack,
            j$.NullDiffBuilder()
          );
        }
      }

      if (!result) {
        diffBuilder.recordMismatch();
        return false;
      }
    } else if (j$.isSet(a) && j$.isSet(b)) {
      if (a.size != b.size) {
        diffBuilder.recordMismatch();
        return false;
      }

      var valuesA = [];
      a.forEach(function(valueA) {
        valuesA.push(valueA);
      });
      var valuesB = [];
      b.forEach(function(valueB) {
        valuesB.push(valueB);
      });

      // For both sets, check they are all contained in the other set
      var setPairs = [[valuesA, valuesB], [valuesB, valuesA]];
      var stackPairs = [[aStack, bStack], [bStack, aStack]];
      var baseValues, baseValue, baseStack;
      var otherValues, otherValue, otherStack;
      var found;
      var prevStackSize;
      for (i = 0; result && i < setPairs.length; i++) {
        baseValues = setPairs[i][0];
        otherValues = setPairs[i][1];
        baseStack = stackPairs[i][0];
        otherStack = stackPairs[i][1];
        // For each value in the base set...
        for (var k = 0; result && k < baseValues.length; k++) {
          baseValue = baseValues[k];
          found = false;
          // ... test that it is present in the other set
          for (var l = 0; !found && l < otherValues.length; l++) {
            otherValue = otherValues[l];
            prevStackSize = baseStack.length;
            // compare by value equality
            found = this.eq_(
              baseValue,
              otherValue,
              baseStack,
              otherStack,
              j$.NullDiffBuilder()
            );
            if (!found && prevStackSize !== baseStack.length) {
              baseStack.splice(prevStackSize);
              otherStack.splice(prevStackSize);
            }
          }
          result = result && found;
        }
      }

      if (!result) {
        diffBuilder.recordMismatch();
        return false;
      }
    } else if (j$.isURL(a) && j$.isURL(b)) {
      // URLs have no enumrable properties, so the default object comparison
      // would consider any two URLs to be equal.
      return a.toString() === b.toString();
    } else {
      // Objects with different constructors are not equivalent, but `Object`s
      // or `Array`s from different frames are.
      var aCtor = a.constructor,
        bCtor = b.constructor;
      if (
        aCtor !== bCtor &&
        isFunction(aCtor) &&
        isFunction(bCtor) &&
        a instanceof aCtor &&
        b instanceof bCtor &&
        !(aCtor instanceof aCtor && bCtor instanceof bCtor)
      ) {
        diffBuilder.recordMismatch(
          constructorsAreDifferentFormatter.bind(null, this.pp)
        );
        return false;
      }
    }

    // Deep compare objects.
    var aKeys = keys(a, className == '[object Array]'),
      key;
    size = aKeys.length;

    // Ensure that both objects contain the same number of properties before comparing deep equality.
    if (keys(b, className == '[object Array]').length !== size) {
      diffBuilder.recordMismatch(
        objectKeysAreDifferentFormatter.bind(null, this.pp)
      );
      return false;
    }

    for (i = 0; i < size; i++) {
      key = aKeys[i];
      // Deep compare each member
      if (!j$.util.has(b, key)) {
        diffBuilder.recordMismatch(
          objectKeysAreDifferentFormatter.bind(null, this.pp)
        );
        result = false;
        continue;
      }

      diffBuilder.withPath(key, function() {
        if (!self.eq_(a[key], b[key], aStack, bStack, diffBuilder)) {
          result = false;
        }
      });
    }

    if (!result) {
      return false;
    }

    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();

    return result;
  };

  function keys(obj, isArray) {
    var allKeys = Object.keys
      ? Object.keys(obj)
      : (function(o) {
          var keys = [];
          for (var key in o) {
            if (j$.util.has(o, key)) {
              keys.push(key);
            }
          }
          return keys;
        })(obj);

    if (!isArray) {
      return allKeys;
    }

    if (allKeys.length === 0) {
      return allKeys;
    }

    var extraKeys = [];
    for (var i = 0; i < allKeys.length; i++) {
      if (!/^[0-9]+$/.test(allKeys[i])) {
        extraKeys.push(allKeys[i]);
      }
    }

    return extraKeys;
  }

  function isFunction(obj) {
    return typeof obj === 'function';
  }

  function objectKeysAreDifferentFormatter(pp, actual, expected, path) {
    var missingProperties = j$.util.objectDifference(expected, actual),
      extraProperties = j$.util.objectDifference(actual, expected),
      missingPropertiesMessage = formatKeyValuePairs(pp, missingProperties),
      extraPropertiesMessage = formatKeyValuePairs(pp, extraProperties),
      messages = [];

    if (!path.depth()) {
      path = 'object';
    }

    if (missingPropertiesMessage.length) {
      messages.push(
        'Expected ' + path + ' to have properties' + missingPropertiesMessage
      );
    }

    if (extraPropertiesMessage.length) {
      messages.push(
        'Expected ' + path + ' not to have properties' + extraPropertiesMessage
      );
    }

    return messages.join('\n');
  }

  function constructorsAreDifferentFormatter(pp, actual, expected, path) {
    if (!path.depth()) {
      path = 'object';
    }

    return (
      'Expected ' +
      path +
      ' to be a kind of ' +
      j$.fnNameFor(expected.constructor) +
      ', but was ' +
      pp(actual) +
      '.'
    );
  }

  function actualArrayIsLongerFormatter(pp, actual, expected, path) {
    return (
      'Unexpected ' +
      path +
      (path.depth() ? ' = ' : '') +
      pp(actual) +
      ' in array.'
    );
  }

  function formatKeyValuePairs(pp, obj) {
    var formatted = '';
    for (var key in obj) {
      formatted += '\n    ' + key + ': ' + pp(obj[key]);
    }
    return formatted;
  }

  return MatchersUtil;
};

/**
 * @interface AsymmetricEqualityTester
 * @classdesc An asymmetric equality tester is an object that can match multiple
 * objects. Examples include jasmine.any() and jasmine.stringMatching(). Jasmine
 * includes a number of built-in asymmetric equality testers, such as
 * {@link jasmine.objectContaining}. User-defined asymmetric equality testers are
 * also supported.
 *
 * Asymmetric equality testers work with any matcher, including user-defined
 * custom matchers, that uses {@link MatchersUtil#equals} or
 * {@link MatchersUtil#contains}.
 *
 * @example
 * function numberDivisibleBy(divisor) {
 *   return {
 *     asymmetricMatch: function(n) {
 *       return typeof n === 'number' && n % divisor === 0;
 *     },
 *     jasmineToString: function() {
 *       return `<a number divisible by ${divisor}>`;
 *     }
 *   };
 * }
 *
 * var actual = {
 *   n: 2,
 *   otherFields: "don't care"
 * };
 *
 * expect(actual).toEqual(jasmine.objectContaining({n: numberDivisibleBy(2)}));
 * @see custom_asymmetric_equality_testers
 * @since 2.0.0
 */
/**
 * Determines whether a value matches this tester
 * @function
 * @name AsymmetricEqualityTester#asymmetricMatch
 * @param value {any} The value to test
 * @param matchersUtil {MatchersUtil} utilities for testing equality, etc
 * @return {Boolean}
 */
/**
 * Returns a string representation of this tester to use in matcher failure messages
 * @function
 * @name AsymmetricEqualityTester#jasmineToString
 * @param pp {function} Function that takes a value and returns a pretty-printed representation
 * @return {String}
 */

getJasmineRequireObj().MismatchTree = function(j$) {
  /*
    To be able to apply custom object formatters at all possible levels of an
    object graph, DiffBuilder needs to be able to know not just where the
    mismatch occurred but also all ancestors of the mismatched value in both
    the expected and actual object graphs. MismatchTree maintains that context
    and provides it via the traverse method.
   */
  function MismatchTree(path) {
    this.path = path || new j$.ObjectPath([]);
    this.formatter = undefined;
    this.children = [];
    this.isMismatch = false;
  }

  MismatchTree.prototype.add = function(path, formatter) {
    var key, child;

    if (path.depth() === 0) {
      this.formatter = formatter;
      this.isMismatch = true;
    } else {
      key = path.components[0];
      path = path.shift();
      child = this.child(key);

      if (!child) {
        child = new MismatchTree(this.path.add(key));
        this.children.push(child);
      }

      child.add(path, formatter);
    }
  };

  MismatchTree.prototype.traverse = function(visit) {
    var i,
      hasChildren = this.children.length > 0;

    if (this.isMismatch || hasChildren) {
      if (visit(this.path, !hasChildren, this.formatter)) {
        for (i = 0; i < this.children.length; i++) {
          this.children[i].traverse(visit);
        }
      }
    }
  };

  MismatchTree.prototype.child = function(key) {
    var i, pathEls;

    for (i = 0; i < this.children.length; i++) {
      pathEls = this.children[i].path.components;
      if (pathEls[pathEls.length - 1] === key) {
        return this.children[i];
      }
    }
  };

  return MismatchTree;
};

getJasmineRequireObj().nothing = function() {
  /**
   * {@link expect} nothing explicitly.
   * @function
   * @name matchers#nothing
   * @since 2.8.0
   * @example
   * expect().nothing();
   */
  function nothing() {
    return {
      compare: function() {
        return {
          pass: true
        };
      }
    };
  }

  return nothing;
};

getJasmineRequireObj().NullDiffBuilder = function(j$) {
  return function() {
    return {
      withPath: function(_, block) {
        block();
      },
      setRoots: function() {},
      recordMismatch: function() {}
    };
  };
};

getJasmineRequireObj().ObjectPath = function(j$) {
  function ObjectPath(components) {
    this.components = components || [];
  }

  ObjectPath.prototype.toString = function() {
    if (this.components.length) {
      return '$' + map(this.components, formatPropertyAccess).join('');
    } else {
      return '';
    }
  };

  ObjectPath.prototype.add = function(component) {
    return new ObjectPath(this.components.concat([component]));
  };

  ObjectPath.prototype.shift = function() {
    return new ObjectPath(this.components.slice(1));
  };

  ObjectPath.prototype.depth = function() {
    return this.components.length;
  };

  function formatPropertyAccess(prop) {
    if (typeof prop === 'number') {
      return '[' + prop + ']';
    }

    if (isValidIdentifier(prop)) {
      return '.' + prop;
    }

    return "['" + prop + "']";
  }

  function map(array, fn) {
    var results = [];
    for (var i = 0; i < array.length; i++) {
      results.push(fn(array[i]));
    }
    return results;
  }

  function isValidIdentifier(string) {
    return /^[A-Za-z\$_][A-Za-z0-9\$_]*$/.test(string);
  }

  return ObjectPath;
};

getJasmineRequireObj().requireAsyncMatchers = function(jRequire, j$) {
  var availableMatchers = [
      'toBePending',
      'toBeResolved',
      'toBeRejected',
      'toBeResolvedTo',
      'toBeRejectedWith',
      'toBeRejectedWithError'
    ],
    matchers = {};

  for (var i = 0; i < availableMatchers.length; i++) {
    var name = availableMatchers[i];
    matchers[name] = jRequire[name](j$);
  }

  return matchers;
};

getJasmineRequireObj().toBe = function(j$) {
  /**
   * {@link expect} the actual value to be `===` to the expected value.
   * @function
   * @name matchers#toBe
   * @since 1.3.0
   * @param {Object} expected - The expected value to compare against.
   * @example
   * expect(thing).toBe(realThing);
   */
  function toBe(matchersUtil) {
    var tip =
      ' Tip: To check for deep equality, use .toEqual() instead of .toBe().';

    return {
      compare: function(actual, expected) {
        var result = {
          pass: actual === expected
        };

        if (typeof expected === 'object') {
          result.message =
            matchersUtil.buildFailureMessage(
              'toBe',
              result.pass,
              actual,
              expected
            ) + tip;
        }

        return result;
      }
    };
  }

  return toBe;
};

getJasmineRequireObj().toBeCloseTo = function() {
  /**
   * {@link expect} the actual value to be within a specified precision of the expected value.
   * @function
   * @name matchers#toBeCloseTo
   * @since 1.3.0
   * @param {Object} expected - The expected value to compare against.
   * @param {Number} [precision=2] - The number of decimal points to check.
   * @example
   * expect(number).toBeCloseTo(42.2, 3);
   */
  function toBeCloseTo() {
    return {
      compare: function(actual, expected, precision) {
        if (precision !== 0) {
          precision = precision || 2;
        }

        if (expected === null || actual === null) {
          throw new Error(
            'Cannot use toBeCloseTo with null. Arguments evaluated to: ' +
              'expect(' +
              actual +
              ').toBeCloseTo(' +
              expected +
              ').'
          );
        }

        var pow = Math.pow(10, precision + 1);
        var delta = Math.abs(expected - actual);
        var maxDelta = Math.pow(10, -precision) / 2;

        return {
          pass: Math.round(delta * pow) <= maxDelta * pow
        };
      }
    };
  }

  return toBeCloseTo;
};

getJasmineRequireObj().toBeDefined = function() {
  /**
   * {@link expect} the actual value to be defined. (Not `undefined`)
   * @function
   * @name matchers#toBeDefined
   * @since 1.3.0
   * @example
   * expect(result).toBeDefined();
   */
  function toBeDefined() {
    return {
      compare: function(actual) {
        return {
          pass: void 0 !== actual
        };
      }
    };
  }

  return toBeDefined;
};

getJasmineRequireObj().toBeFalse = function() {
  /**
   * {@link expect} the actual value to be `false`.
   * @function
   * @name matchers#toBeFalse
   * @since 3.5.0
   * @example
   * expect(result).toBeFalse();
   */
  function toBeFalse() {
    return {
      compare: function(actual) {
        return {
          pass: actual === false
        };
      }
    };
  }

  return toBeFalse;
};

getJasmineRequireObj().toBeFalsy = function() {
  /**
   * {@link expect} the actual value to be falsy
   * @function
   * @name matchers#toBeFalsy
   * @since 2.0.0
   * @example
   * expect(result).toBeFalsy();
   */
  function toBeFalsy() {
    return {
      compare: function(actual) {
        return {
          pass: !actual
        };
      }
    };
  }

  return toBeFalsy;
};

getJasmineRequireObj().toBeGreaterThan = function() {
  /**
   * {@link expect} the actual value to be greater than the expected value.
   * @function
   * @name matchers#toBeGreaterThan
   * @since 2.0.0
   * @param {Number} expected - The value to compare against.
   * @example
   * expect(result).toBeGreaterThan(3);
   */
  function toBeGreaterThan() {
    return {
      compare: function(actual, expected) {
        return {
          pass: actual > expected
        };
      }
    };
  }

  return toBeGreaterThan;
};

getJasmineRequireObj().toBeGreaterThanOrEqual = function() {
  /**
   * {@link expect} the actual value to be greater than or equal to the expected value.
   * @function
   * @name matchers#toBeGreaterThanOrEqual
   * @since 2.0.0
   * @param {Number} expected - The expected value to compare against.
   * @example
   * expect(result).toBeGreaterThanOrEqual(25);
   */
  function toBeGreaterThanOrEqual() {
    return {
      compare: function(actual, expected) {
        return {
          pass: actual >= expected
        };
      }
    };
  }

  return toBeGreaterThanOrEqual;
};

getJasmineRequireObj().toBeInstanceOf = function(j$) {
  var usageError = j$.formatErrorMsg(
    '<toBeInstanceOf>',
    'expect(value).toBeInstanceOf(<ConstructorFunction>)'
  );

  /**
   * {@link expect} the actual to be an instance of the expected class
   * @function
   * @name matchers#toBeInstanceOf
   * @since 3.5.0
   * @param {Object} expected - The class or constructor function to check for
   * @example
   * expect('foo').toBeInstanceOf(String);
   * expect(3).toBeInstanceOf(Number);
   * expect(new Error()).toBeInstanceOf(Error);
   */
  function toBeInstanceOf(matchersUtil) {
    return {
      compare: function(actual, expected) {
        var actualType =
            actual && actual.constructor
              ? j$.fnNameFor(actual.constructor)
              : matchersUtil.pp(actual),
          expectedType = expected
            ? j$.fnNameFor(expected)
            : matchersUtil.pp(expected),
          expectedMatcher,
          pass;

        try {
          expectedMatcher = new j$.Any(expected);
          pass = expectedMatcher.asymmetricMatch(actual);
        } catch (error) {
          throw new Error(
            usageError('Expected value is not a constructor function')
          );
        }

        if (pass) {
          return {
            pass: true,
            message:
              'Expected instance of ' +
              actualType +
              ' not to be an instance of ' +
              expectedType
          };
        } else {
          return {
            pass: false,
            message:
              'Expected instance of ' +
              actualType +
              ' to be an instance of ' +
              expectedType
          };
        }
      }
    };
  }

  return toBeInstanceOf;
};

getJasmineRequireObj().toBeLessThan = function() {
  /**
   * {@link expect} the actual value to be less than the expected value.
   * @function
   * @name matchers#toBeLessThan
   * @since 2.0.0
   * @param {Number} expected - The expected value to compare against.
   * @example
   * expect(result).toBeLessThan(0);
   */
  function toBeLessThan() {
    return {
      compare: function(actual, expected) {
        return {
          pass: actual < expected
        };
      }
    };
  }

  return toBeLessThan;
};

getJasmineRequireObj().toBeLessThanOrEqual = function() {
  /**
   * {@link expect} the actual value to be less than or equal to the expected value.
   * @function
   * @name matchers#toBeLessThanOrEqual
   * @since 2.0.0
   * @param {Number} expected - The expected value to compare against.
   * @example
   * expect(result).toBeLessThanOrEqual(123);
   */
  function toBeLessThanOrEqual() {
    return {
      compare: function(actual, expected) {
        return {
          pass: actual <= expected
        };
      }
    };
  }

  return toBeLessThanOrEqual;
};

getJasmineRequireObj().toBeNaN = function(j$) {
  /**
   * {@link expect} the actual value to be `NaN` (Not a Number).
   * @function
   * @name matchers#toBeNaN
   * @since 1.3.0
   * @example
   * expect(thing).toBeNaN();
   */
  function toBeNaN(matchersUtil) {
    return {
      compare: function(actual) {
        var result = {
          pass: actual !== actual
        };

        if (result.pass) {
          result.message = 'Expected actual not to be NaN.';
        } else {
          result.message = function() {
            return 'Expected ' + matchersUtil.pp(actual) + ' to be NaN.';
          };
        }

        return result;
      }
    };
  }

  return toBeNaN;
};

getJasmineRequireObj().toBeNegativeInfinity = function(j$) {
  /**
   * {@link expect} the actual value to be `-Infinity` (-infinity).
   * @function
   * @name matchers#toBeNegativeInfinity
   * @since 2.6.0
   * @example
   * expect(thing).toBeNegativeInfinity();
   */
  function toBeNegativeInfinity(matchersUtil) {
    return {
      compare: function(actual) {
        var result = {
          pass: actual === Number.NEGATIVE_INFINITY
        };

        if (result.pass) {
          result.message = 'Expected actual not to be -Infinity.';
        } else {
          result.message = function() {
            return 'Expected ' + matchersUtil.pp(actual) + ' to be -Infinity.';
          };
        }

        return result;
      }
    };
  }

  return toBeNegativeInfinity;
};

getJasmineRequireObj().toBeNull = function() {
  /**
   * {@link expect} the actual value to be `null`.
   * @function
   * @name matchers#toBeNull
   * @since 1.3.0
   * @example
   * expect(result).toBeNull();
   */
  function toBeNull() {
    return {
      compare: function(actual) {
        return {
          pass: actual === null
        };
      }
    };
  }

  return toBeNull;
};

getJasmineRequireObj().toBePositiveInfinity = function(j$) {
  /**
   * {@link expect} the actual value to be `Infinity` (infinity).
   * @function
   * @name matchers#toBePositiveInfinity
   * @since 2.6.0
   * @example
   * expect(thing).toBePositiveInfinity();
   */
  function toBePositiveInfinity(matchersUtil) {
    return {
      compare: function(actual) {
        var result = {
          pass: actual === Number.POSITIVE_INFINITY
        };

        if (result.pass) {
          result.message = 'Expected actual not to be Infinity.';
        } else {
          result.message = function() {
            return 'Expected ' + matchersUtil.pp(actual) + ' to be Infinity.';
          };
        }

        return result;
      }
    };
  }

  return toBePositiveInfinity;
};

getJasmineRequireObj().toBeTrue = function() {
  /**
   * {@link expect} the actual value to be `true`.
   * @function
   * @name matchers#toBeTrue
   * @since 3.5.0
   * @example
   * expect(result).toBeTrue();
   */
  function toBeTrue() {
    return {
      compare: function(actual) {
        return {
          pass: actual === true
        };
      }
    };
  }

  return toBeTrue;
};

getJasmineRequireObj().toBeTruthy = function() {
  /**
   * {@link expect} the actual value to be truthy.
   * @function
   * @name matchers#toBeTruthy
   * @since 2.0.0
   * @example
   * expect(thing).toBeTruthy();
   */
  function toBeTruthy() {
    return {
      compare: function(actual) {
        return {
          pass: !!actual
        };
      }
    };
  }

  return toBeTruthy;
};

getJasmineRequireObj().toBeUndefined = function() {
  /**
   * {@link expect} the actual value to be `undefined`.
   * @function
   * @name matchers#toBeUndefined
   * @since 1.3.0
   * @example
   * expect(result).toBeUndefined():
   */
  function toBeUndefined() {
    return {
      compare: function(actual) {
        return {
          pass: void 0 === actual
        };
      }
    };
  }

  return toBeUndefined;
};

getJasmineRequireObj().toContain = function() {
  /**
   * {@link expect} the actual value to contain a specific value.
   * @function
   * @name matchers#toContain
   * @since 2.0.0
   * @param {Object} expected - The value to look for.
   * @example
   * expect(array).toContain(anElement);
   * expect(string).toContain(substring);
   */
  function toContain(matchersUtil) {
    return {
      compare: function(actual, expected) {
        return {
          pass: matchersUtil.contains(actual, expected)
        };
      }
    };
  }

  return toContain;
};

getJasmineRequireObj().toEqual = function(j$) {
  /**
   * {@link expect} the actual value to be equal to the expected, using deep equality comparison.
   * @function
   * @name matchers#toEqual
   * @since 1.3.0
   * @param {Object} expected - Expected value
   * @example
   * expect(bigObject).toEqual({"foo": ['bar', 'baz']});
   */
  function toEqual(matchersUtil) {
    return {
      compare: function(actual, expected) {
        var result = {
            pass: false
          },
          diffBuilder = j$.DiffBuilder({ prettyPrinter: matchersUtil.pp });

        result.pass = matchersUtil.equals(actual, expected, diffBuilder);

        // TODO: only set error message if test fails
        result.message = diffBuilder.getMessage();

        return result;
      }
    };
  }

  return toEqual;
};

getJasmineRequireObj().toHaveBeenCalled = function(j$) {
  var getErrorMsg = j$.formatErrorMsg(
    '<toHaveBeenCalled>',
    'expect(<spyObj>).toHaveBeenCalled()'
  );

  /**
   * {@link expect} the actual (a {@link Spy}) to have been called.
   * @function
   * @name matchers#toHaveBeenCalled
   * @since 1.3.0
   * @example
   * expect(mySpy).toHaveBeenCalled();
   * expect(mySpy).not.toHaveBeenCalled();
   */
  function toHaveBeenCalled(matchersUtil) {
    return {
      compare: function(actual) {
        var result = {};

        if (!j$.isSpy(actual)) {
          throw new Error(
            getErrorMsg(
              'Expected a spy, but got ' + matchersUtil.pp(actual) + '.'
            )
          );
        }

        if (arguments.length > 1) {
          throw new Error(
            getErrorMsg('Does not take arguments, use toHaveBeenCalledWith')
          );
        }

        result.pass = actual.calls.any();

        result.message = result.pass
          ? 'Expected spy ' + actual.and.identity + ' not to have been called.'
          : 'Expected spy ' + actual.and.identity + ' to have been called.';

        return result;
      }
    };
  }

  return toHaveBeenCalled;
};

getJasmineRequireObj().toHaveBeenCalledBefore = function(j$) {
  var getErrorMsg = j$.formatErrorMsg(
    '<toHaveBeenCalledBefore>',
    'expect(<spyObj>).toHaveBeenCalledBefore(<spyObj>)'
  );

  /**
   * {@link expect} the actual value (a {@link Spy}) to have been called before another {@link Spy}.
   * @function
   * @name matchers#toHaveBeenCalledBefore
   * @since 2.6.0
   * @param {Spy} expected - {@link Spy} that should have been called after the `actual` {@link Spy}.
   * @example
   * expect(mySpy).toHaveBeenCalledBefore(otherSpy);
   */
  function toHaveBeenCalledBefore(matchersUtil) {
    return {
      compare: function(firstSpy, latterSpy) {
        if (!j$.isSpy(firstSpy)) {
          throw new Error(
            getErrorMsg(
              'Expected a spy, but got ' + matchersUtil.pp(firstSpy) + '.'
            )
          );
        }
        if (!j$.isSpy(latterSpy)) {
          throw new Error(
            getErrorMsg(
              'Expected a spy, but got ' + matchersUtil.pp(latterSpy) + '.'
            )
          );
        }

        var result = { pass: false };

        if (!firstSpy.calls.count()) {
          result.message =
            'Expected spy ' + firstSpy.and.identity + ' to have been called.';
          return result;
        }
        if (!latterSpy.calls.count()) {
          result.message =
            'Expected spy ' + latterSpy.and.identity + ' to have been called.';
          return result;
        }

        var latest1stSpyCall = firstSpy.calls.mostRecent().invocationOrder;
        var first2ndSpyCall = latterSpy.calls.first().invocationOrder;

        result.pass = latest1stSpyCall < first2ndSpyCall;

        if (result.pass) {
          result.message =
            'Expected spy ' +
            firstSpy.and.identity +
            ' to not have been called before spy ' +
            latterSpy.and.identity +
            ', but it was';
        } else {
          var first1stSpyCall = firstSpy.calls.first().invocationOrder;
          var latest2ndSpyCall = latterSpy.calls.mostRecent().invocationOrder;

          if (first1stSpyCall < first2ndSpyCall) {
            result.message =
              'Expected latest call to spy ' +
              firstSpy.and.identity +
              ' to have been called before first call to spy ' +
              latterSpy.and.identity +
              ' (no interleaved calls)';
          } else if (latest2ndSpyCall > latest1stSpyCall) {
            result.message =
              'Expected first call to spy ' +
              latterSpy.and.identity +
              ' to have been called after latest call to spy ' +
              firstSpy.and.identity +
              ' (no interleaved calls)';
          } else {
            result.message =
              'Expected spy ' +
              firstSpy.and.identity +
              ' to have been called before spy ' +
              latterSpy.and.identity;
          }
        }

        return result;
      }
    };
  }

  return toHaveBeenCalledBefore;
};

getJasmineRequireObj().toHaveBeenCalledOnceWith = function(j$) {
  var getErrorMsg = j$.formatErrorMsg(
    '<toHaveBeenCalledOnceWith>',
    'expect(<spyObj>).toHaveBeenCalledOnceWith(...arguments)'
  );

  /**
   * {@link expect} the actual (a {@link Spy}) to have been called exactly once, and exactly with the particular arguments.
   * @function
   * @name matchers#toHaveBeenCalledOnceWith
   * @since 3.6.0
   * @param {...Object} - The arguments to look for
   * @example
   * expect(mySpy).toHaveBeenCalledOnceWith('foo', 'bar', 2);
   */
  function toHaveBeenCalledOnceWith(util) {
    return {
      compare: function() {
        var args = Array.prototype.slice.call(arguments, 0),
          actual = args[0],
          expectedArgs = args.slice(1);

        if (!j$.isSpy(actual)) {
          throw new Error(
            getErrorMsg('Expected a spy, but got ' + util.pp(actual) + '.')
          );
        }

        var prettyPrintedCalls = actual.calls
          .allArgs()
          .map(function(argsForCall) {
            return '  ' + util.pp(argsForCall);
          });

        if (
          actual.calls.count() === 1 &&
          util.contains(actual.calls.allArgs(), expectedArgs)
        ) {
          return {
            pass: true,
            message:
              'Expected spy ' +
              actual.and.identity +
              ' to have been called 0 times, multiple times, or once, but with arguments different from:\n' +
              '  ' +
              util.pp(expectedArgs) +
              '\n' +
              'But the actual call was:\n' +
              prettyPrintedCalls.join(',\n') +
              '.\n\n'
          };
        }

        function getDiffs() {
          return actual.calls.allArgs().map(function(argsForCall, callIx) {
            var diffBuilder = new j$.DiffBuilder();
            util.equals(argsForCall, expectedArgs, diffBuilder);
            return diffBuilder.getMessage();
          });
        }

        function butString() {
          switch (actual.calls.count()) {
            case 0:
              return 'But it was never called.\n\n';
            case 1:
              return (
                'But the actual call was:\n' +
                prettyPrintedCalls.join(',\n') +
                '.\n' +
                getDiffs().join('\n') +
                '\n\n'
              );
            default:
              return (
                'But the actual calls were:\n' +
                prettyPrintedCalls.join(',\n') +
                '.\n\n'
              );
          }
        }

        return {
          pass: false,
          message:
            'Expected spy ' +
            actual.and.identity +
            ' to have been called only once, and with given args:\n' +
            '  ' +
            util.pp(expectedArgs) +
            '\n' +
            butString()
        };
      }
    };
  }

  return toHaveBeenCalledOnceWith;
};

getJasmineRequireObj().toHaveBeenCalledTimes = function(j$) {
  var getErrorMsg = j$.formatErrorMsg(
    '<toHaveBeenCalledTimes>',
    'expect(<spyObj>).toHaveBeenCalledTimes(<Number>)'
  );

  /**
   * {@link expect} the actual (a {@link Spy}) to have been called the specified number of times.
   * @function
   * @name matchers#toHaveBeenCalledTimes
   * @since 2.4.0
   * @param {Number} expected - The number of invocations to look for.
   * @example
   * expect(mySpy).toHaveBeenCalledTimes(3);
   */
  function toHaveBeenCalledTimes(matchersUtil) {
    return {
      compare: function(actual, expected) {
        if (!j$.isSpy(actual)) {
          throw new Error(
            getErrorMsg(
              'Expected a spy, but got ' + matchersUtil.pp(actual) + '.'
            )
          );
        }

        var args = Array.prototype.slice.call(arguments, 0),
          result = { pass: false };

        if (!j$.isNumber_(expected)) {
          throw new Error(
            getErrorMsg(
              'The expected times failed is a required argument and must be a number.'
            )
          );
        }

        actual = args[0];
        var calls = actual.calls.count();
        var timesMessage = expected === 1 ? 'once' : expected + ' times';
        result.pass = calls === expected;
        result.message = result.pass
          ? 'Expected spy ' +
            actual.and.identity +
            ' not to have been called ' +
            timesMessage +
            '. It was called ' +
            calls +
            ' times.'
          : 'Expected spy ' +
            actual.and.identity +
            ' to have been called ' +
            timesMessage +
            '. It was called ' +
            calls +
            ' times.';
        return result;
      }
    };
  }

  return toHaveBeenCalledTimes;
};

getJasmineRequireObj().toHaveBeenCalledWith = function(j$) {
  var getErrorMsg = j$.formatErrorMsg(
    '<toHaveBeenCalledWith>',
    'expect(<spyObj>).toHaveBeenCalledWith(...arguments)'
  );

  /**
   * {@link expect} the actual (a {@link Spy}) to have been called with particular arguments at least once.
   * @function
   * @name matchers#toHaveBeenCalledWith
   * @since 1.3.0
   * @param {...Object} - The arguments to look for
   * @example
   * expect(mySpy).toHaveBeenCalledWith('foo', 'bar', 2);
   */
  function toHaveBeenCalledWith(matchersUtil) {
    return {
      compare: function() {
        var args = Array.prototype.slice.call(arguments, 0),
          actual = args[0],
          expectedArgs = args.slice(1),
          result = { pass: false };

        if (!j$.isSpy(actual)) {
          throw new Error(
            getErrorMsg(
              'Expected a spy, but got ' + matchersUtil.pp(actual) + '.'
            )
          );
        }

        if (!actual.calls.any()) {
          result.message = function() {
            return (
              'Expected spy ' +
              actual.and.identity +
              ' to have been called with:\n' +
              '  ' +
              matchersUtil.pp(expectedArgs) +
              '\nbut it was never called.'
            );
          };
          return result;
        }

        if (matchersUtil.contains(actual.calls.allArgs(), expectedArgs)) {
          result.pass = true;
          result.message = function() {
            return (
              'Expected spy ' +
              actual.and.identity +
              ' not to have been called with:\n' +
              '  ' +
              matchersUtil.pp(expectedArgs) +
              '\nbut it was.'
            );
          };
        } else {
          result.message = function() {
            var prettyPrintedCalls = actual.calls
              .allArgs()
              .map(function(argsForCall) {
                return '  ' + matchersUtil.pp(argsForCall);
              });

            var diffs = actual.calls
              .allArgs()
              .map(function(argsForCall, callIx) {
                var diffBuilder = new j$.DiffBuilder();
                matchersUtil.equals(argsForCall, expectedArgs, diffBuilder);
                return (
                  'Call ' +
                  callIx +
                  ':\n' +
                  diffBuilder.getMessage().replace(/^/gm, '  ')
                );
              });

            return (
              'Expected spy ' +
              actual.and.identity +
              ' to have been called with:\n' +
              '  ' +
              matchersUtil.pp(expectedArgs) +
              '\n' +
              '' +
              'but actual calls were:\n' +
              prettyPrintedCalls.join(',\n') +
              '.\n\n' +
              diffs.join('\n')
            );
          };
        }

        return result;
      }
    };
  }

  return toHaveBeenCalledWith;
};

getJasmineRequireObj().toHaveClass = function(j$) {
  /**
   * {@link expect} the actual value to be a DOM element that has the expected class
   * @function
   * @name matchers#toHaveClass
   * @since 3.0.0
   * @param {Object} expected - The class name to test for
   * @example
   * var el = document.createElement('div');
   * el.className = 'foo bar baz';
   * expect(el).toHaveClass('bar');
   */
  function toHaveClass(matchersUtil) {
    return {
      compare: function(actual, expected) {
        if (!isElement(actual)) {
          throw new Error(matchersUtil.pp(actual) + ' is not a DOM element');
        }

        return {
          pass: actual.classList.contains(expected)
        };
      }
    };
  }

  function isElement(maybeEl) {
    return (
      maybeEl && maybeEl.classList && j$.isFunction_(maybeEl.classList.contains)
    );
  }

  return toHaveClass;
};

getJasmineRequireObj().toHaveSize = function(j$) {
  /**
   * {@link expect} the actual size to be equal to the expected, using array-like length or object keys size.
   * @function
   * @name matchers#toHaveSize
   * @since 3.6.0
   * @param {Object} expected - Expected size
   * @example
   * array = [1,2];
   * expect(array).toHaveSize(2);
   */
  function toHaveSize() {
    return {
      compare: function(actual, expected) {
        var result = {
          pass: false
        };

        if (
          j$.isA_('WeakSet', actual) ||
          j$.isWeakMap(actual) ||
          j$.isDataView(actual)
        ) {
          throw new Error('Cannot get size of ' + actual + '.');
        }

        if (j$.isSet(actual) || j$.isMap(actual)) {
          result.pass = actual.size === expected;
        } else if (isLength(actual.length)) {
          result.pass = actual.length === expected;
        } else {
          result.pass = Object.keys(actual).length === expected;
        }

        return result;
      }
    };
  }

  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  function isLength(value) {
    return (
      typeof value == 'number' &&
      value > -1 &&
      value % 1 === 0 &&
      value <= MAX_SAFE_INTEGER
    );
  }

  return toHaveSize;
};

getJasmineRequireObj().toMatch = function(j$) {
  var getErrorMsg = j$.formatErrorMsg(
    '<toMatch>',
    'expect(<expectation>).toMatch(<string> || <regexp>)'
  );

  /**
   * {@link expect} the actual value to match a regular expression
   * @function
   * @name matchers#toMatch
   * @since 1.3.0
   * @param {RegExp|String} expected - Value to look for in the string.
   * @example
   * expect("my string").toMatch(/string$/);
   * expect("other string").toMatch("her");
   */
  function toMatch() {
    return {
      compare: function(actual, expected) {
        if (!j$.isString_(expected) && !j$.isA_('RegExp', expected)) {
          throw new Error(getErrorMsg('Expected is not a String or a RegExp'));
        }

        var regexp = new RegExp(expected);

        return {
          pass: regexp.test(actual)
        };
      }
    };
  }

  return toMatch;
};

getJasmineRequireObj().toThrow = function(j$) {
  var getErrorMsg = j$.formatErrorMsg(
    '<toThrow>',
    'expect(function() {<expectation>}).toThrow()'
  );

  /**
   * {@link expect} a function to `throw` something.
   * @function
   * @name matchers#toThrow
   * @since 2.0.0
   * @param {Object} [expected] - Value that should be thrown. If not provided, simply the fact that something was thrown will be checked.
   * @example
   * expect(function() { return 'things'; }).toThrow('foo');
   * expect(function() { return 'stuff'; }).toThrow();
   */
  function toThrow(matchersUtil) {
    return {
      compare: function(actual, expected) {
        var result = { pass: false },
          threw = false,
          thrown;

        if (typeof actual != 'function') {
          throw new Error(getErrorMsg('Actual is not a Function'));
        }

        try {
          actual();
        } catch (e) {
          threw = true;
          thrown = e;
        }

        if (!threw) {
          result.message = 'Expected function to throw an exception.';
          return result;
        }

        if (arguments.length == 1) {
          result.pass = true;
          result.message = function() {
            return (
              'Expected function not to throw, but it threw ' +
              matchersUtil.pp(thrown) +
              '.'
            );
          };

          return result;
        }

        if (matchersUtil.equals(thrown, expected)) {
          result.pass = true;
          result.message = function() {
            return (
              'Expected function not to throw ' +
              matchersUtil.pp(expected) +
              '.'
            );
          };
        } else {
          result.message = function() {
            return (
              'Expected function to throw ' +
              matchersUtil.pp(expected) +
              ', but it threw ' +
              matchersUtil.pp(thrown) +
              '.'
            );
          };
        }

        return result;
      }
    };
  }

  return toThrow;
};

getJasmineRequireObj().toThrowError = function(j$) {
  var getErrorMsg = j$.formatErrorMsg(
    '<toThrowError>',
    'expect(function() {<expectation>}).toThrowError(<ErrorConstructor>, <message>)'
  );

  /**
   * {@link expect} a function to `throw` an `Error`.
   * @function
   * @name matchers#toThrowError
   * @since 2.0.0
   * @param {Error} [expected] - `Error` constructor the object that was thrown needs to be an instance of. If not provided, `Error` will be used.
   * @param {RegExp|String} [message] - The message that should be set on the thrown `Error`
   * @example
   * expect(function() { return 'things'; }).toThrowError(MyCustomError, 'message');
   * expect(function() { return 'things'; }).toThrowError(MyCustomError, /bar/);
   * expect(function() { return 'stuff'; }).toThrowError(MyCustomError);
   * expect(function() { return 'other'; }).toThrowError(/foo/);
   * expect(function() { return 'other'; }).toThrowError();
   */
  function toThrowError(matchersUtil) {
    return {
      compare: function(actual) {
        var errorMatcher = getMatcher.apply(null, arguments),
          thrown;

        if (typeof actual != 'function') {
          throw new Error(getErrorMsg('Actual is not a Function'));
        }

        try {
          actual();
          return fail('Expected function to throw an Error.');
        } catch (e) {
          thrown = e;
        }

        if (!j$.isError_(thrown)) {
          return fail(function() {
            return (
              'Expected function to throw an Error, but it threw ' +
              matchersUtil.pp(thrown) +
              '.'
            );
          });
        }

        return errorMatcher.match(thrown);
      }
    };

    function getMatcher() {
      var expected, errorType;

      if (arguments[2]) {
        errorType = arguments[1];
        expected = arguments[2];
        if (!isAnErrorType(errorType)) {
          throw new Error(getErrorMsg('Expected error type is not an Error.'));
        }

        return exactMatcher(expected, errorType);
      } else if (arguments[1]) {
        expected = arguments[1];

        if (isAnErrorType(arguments[1])) {
          return exactMatcher(null, arguments[1]);
        } else {
          return exactMatcher(arguments[1], null);
        }
      } else {
        return anyMatcher();
      }
    }

    function anyMatcher() {
      return {
        match: function(error) {
          return pass(
            'Expected function not to throw an Error, but it threw ' +
              j$.fnNameFor(error) +
              '.'
          );
        }
      };
    }

    function exactMatcher(expected, errorType) {
      if (expected && !isStringOrRegExp(expected)) {
        if (errorType) {
          throw new Error(
            getErrorMsg('Expected error message is not a string or RegExp.')
          );
        } else {
          throw new Error(
            getErrorMsg('Expected is not an Error, string, or RegExp.')
          );
        }
      }

      function messageMatch(message) {
        if (typeof expected == 'string') {
          return expected == message;
        } else {
          return expected.test(message);
        }
      }

      var errorTypeDescription = errorType
        ? j$.fnNameFor(errorType)
        : 'an exception';

      function thrownDescription(thrown) {
        var thrownName = errorType
            ? j$.fnNameFor(thrown.constructor)
            : 'an exception',
          thrownMessage = '';

        if (expected) {
          thrownMessage = ' with message ' + matchersUtil.pp(thrown.message);
        }

        return thrownName + thrownMessage;
      }

      function messageDescription() {
        if (expected === null) {
          return '';
        } else if (expected instanceof RegExp) {
          return ' with a message matching ' + matchersUtil.pp(expected);
        } else {
          return ' with message ' + matchersUtil.pp(expected);
        }
      }

      function matches(error) {
        return (
          (errorType === null || error instanceof errorType) &&
          (expected === null || messageMatch(error.message))
        );
      }

      return {
        match: function(thrown) {
          if (matches(thrown)) {
            return pass(function() {
              return (
                'Expected function not to throw ' +
                errorTypeDescription +
                messageDescription() +
                '.'
              );
            });
          } else {
            return fail(function() {
              return (
                'Expected function to throw ' +
                errorTypeDescription +
                messageDescription() +
                ', but it threw ' +
                thrownDescription(thrown) +
                '.'
              );
            });
          }
        }
      };
    }

    function isStringOrRegExp(potential) {
      return potential instanceof RegExp || typeof potential == 'string';
    }

    function isAnErrorType(type) {
      if (typeof type !== 'function') {
        return false;
      }

      var Surrogate = function() {};
      Surrogate.prototype = type.prototype;
      return j$.isError_(new Surrogate());
    }
  }

  function pass(message) {
    return {
      pass: true,
      message: message
    };
  }

  function fail(message) {
    return {
      pass: false,
      message: message
    };
  }

  return toThrowError;
};

getJasmineRequireObj().toThrowMatching = function(j$) {
  var usageError = j$.formatErrorMsg(
    '<toThrowMatching>',
    'expect(function() {<expectation>}).toThrowMatching(<Predicate>)'
  );

  /**
   * {@link expect} a function to `throw` something matching a predicate.
   * @function
   * @name matchers#toThrowMatching
   * @since 3.0.0
   * @param {Function} predicate - A function that takes the thrown exception as its parameter and returns true if it matches.
   * @example
   * expect(function() { throw new Error('nope'); }).toThrowMatching(function(thrown) { return thrown.message === 'nope'; });
   */
  function toThrowMatching(matchersUtil) {
    return {
      compare: function(actual, predicate) {
        var thrown;

        if (typeof actual !== 'function') {
          throw new Error(usageError('Actual is not a Function'));
        }

        if (typeof predicate !== 'function') {
          throw new Error(usageError('Predicate is not a Function'));
        }

        try {
          actual();
          return fail('Expected function to throw an exception.');
        } catch (e) {
          thrown = e;
        }

        if (predicate(thrown)) {
          return pass(
            'Expected function not to throw an exception matching a predicate.'
          );
        } else {
          return fail(function() {
            return (
              'Expected function to throw an exception matching a predicate, ' +
              'but it threw ' +
              thrownDescription(thrown) +
              '.'
            );
          });
        }
      }
    };

    function thrownDescription(thrown) {
      if (thrown && thrown.constructor) {
        return (
          j$.fnNameFor(thrown.constructor) +
          ' with message ' +
          matchersUtil.pp(thrown.message)
        );
      } else {
        return matchersUtil.pp(thrown);
      }
    }
  }

  function pass(message) {
    return {
      pass: true,
      message: message
    };
  }

  function fail(message) {
    return {
      pass: false,
      message: message
    };
  }

  return toThrowMatching;
};

getJasmineRequireObj().MockDate = function(j$) {
  function MockDate(global) {
    var self = this;
    var currentTime = 0;

    if (!global || !global.Date) {
      self.install = function() {};
      self.tick = function() {};
      self.uninstall = function() {};
      return self;
    }

    var GlobalDate = global.Date;

    self.install = function(mockDate) {
      if (mockDate instanceof GlobalDate) {
        currentTime = mockDate.getTime();
      } else {
        if (!j$.util.isUndefined(mockDate)) {
          throw new Error(
            'The argument to jasmine.clock().mockDate(), if specified, ' +
              'should be a Date instance.'
          );
        }

        currentTime = new GlobalDate().getTime();
      }

      global.Date = FakeDate;
    };

    self.tick = function(millis) {
      millis = millis || 0;
      currentTime = currentTime + millis;
    };

    self.uninstall = function() {
      currentTime = 0;
      global.Date = GlobalDate;
    };

    createDateProperties();

    return self;

    function FakeDate() {
      switch (arguments.length) {
        case 0:
          return new GlobalDate(currentTime);
        case 1:
          return new GlobalDate(arguments[0]);
        case 2:
          return new GlobalDate(arguments[0], arguments[1]);
        case 3:
          return new GlobalDate(arguments[0], arguments[1], arguments[2]);
        case 4:
          return new GlobalDate(
            arguments[0],
            arguments[1],
            arguments[2],
            arguments[3]
          );
        case 5:
          return new GlobalDate(
            arguments[0],
            arguments[1],
            arguments[2],
            arguments[3],
            arguments[4]
          );
        case 6:
          return new GlobalDate(
            arguments[0],
            arguments[1],
            arguments[2],
            arguments[3],
            arguments[4],
            arguments[5]
          );
        default:
          return new GlobalDate(
            arguments[0],
            arguments[1],
            arguments[2],
            arguments[3],
            arguments[4],
            arguments[5],
            arguments[6]
          );
      }
    }

    function createDateProperties() {
      FakeDate.prototype = GlobalDate.prototype;

      FakeDate.now = function() {
        return currentTime;
      };

      FakeDate.toSource = GlobalDate.toSource;
      FakeDate.toString = GlobalDate.toString;
      FakeDate.parse = GlobalDate.parse;
      FakeDate.UTC = GlobalDate.UTC;
    }
  }

  return MockDate;
};

getJasmineRequireObj().NeverSkipPolicy = function(j$) {
  function NeverSkipPolicy(queueableFns) {}

  NeverSkipPolicy.prototype.skipTo = function(lastRanFnIx) {
    return lastRanFnIx + 1;
  };

  NeverSkipPolicy.prototype.fnErrored = function(fnIx) {};

  return NeverSkipPolicy;
};

getJasmineRequireObj().makePrettyPrinter = function(j$) {
  function SinglePrettyPrintRun(customObjectFormatters, pp) {
    this.customObjectFormatters_ = customObjectFormatters;
    this.ppNestLevel_ = 0;
    this.seen = [];
    this.length = 0;
    this.stringParts = [];
    this.pp_ = pp;
  }

  function hasCustomToString(value) {
    // value.toString !== Object.prototype.toString if value has no custom toString but is from another context (e.g.
    // iframe, web worker)
    try {
      return (
        j$.isFunction_(value.toString) &&
        value.toString !== Object.prototype.toString &&
        value.toString() !== Object.prototype.toString.call(value)
      );
    } catch (e) {
      // The custom toString() threw.
      return true;
    }
  }

  SinglePrettyPrintRun.prototype.format = function(value) {
    this.ppNestLevel_++;
    try {
      var customFormatResult = this.applyCustomFormatters_(value);

      if (customFormatResult) {
        this.emitScalar(customFormatResult);
      } else if (j$.util.isUndefined(value)) {
        this.emitScalar('undefined');
      } else if (value === null) {
        this.emitScalar('null');
      } else if (value === 0 && 1 / value === -Infinity) {
        this.emitScalar('-0');
      } else if (value === j$.getGlobal()) {
        this.emitScalar('<global>');
      } else if (value.jasmineToString) {
        this.emitScalar(value.jasmineToString(this.pp_));
      } else if (typeof value === 'string') {
        this.emitString(value);
      } else if (j$.isSpy(value)) {
        this.emitScalar('spy on ' + value.and.identity);
      } else if (j$.isSpy(value.toString)) {
        this.emitScalar('spy on ' + value.toString.and.identity);
      } else if (value instanceof RegExp) {
        this.emitScalar(value.toString());
      } else if (typeof value === 'function') {
        this.emitScalar('Function');
      } else if (j$.isDomNode(value)) {
        if (value.tagName) {
          this.emitDomElement(value);
        } else {
          this.emitScalar('HTMLNode');
        }
      } else if (value instanceof Date) {
        this.emitScalar('Date(' + value + ')');
      } else if (j$.isSet(value)) {
        this.emitSet(value);
      } else if (j$.isMap(value)) {
        this.emitMap(value);
      } else if (j$.isTypedArray_(value)) {
        this.emitTypedArray(value);
      } else if (
        value.toString &&
        typeof value === 'object' &&
        !j$.isArray_(value) &&
        hasCustomToString(value)
      ) {
        try {
          this.emitScalar(value.toString());
        } catch (e) {
          this.emitScalar('has-invalid-toString-method');
        }
      } else if (j$.util.arrayContains(this.seen, value)) {
        this.emitScalar(
          '<circular reference: ' +
            (j$.isArray_(value) ? 'Array' : 'Object') +
            '>'
        );
      } else if (j$.isArray_(value) || j$.isA_('Object', value)) {
        this.seen.push(value);
        if (j$.isArray_(value)) {
          this.emitArray(value);
        } else {
          this.emitObject(value);
        }
        this.seen.pop();
      } else {
        this.emitScalar(value.toString());
      }
    } catch (e) {
      if (this.ppNestLevel_ > 1 || !(e instanceof MaxCharsReachedError)) {
        throw e;
      }
    } finally {
      this.ppNestLevel_--;
    }
  };

  SinglePrettyPrintRun.prototype.applyCustomFormatters_ = function(value) {
    return customFormat(value, this.customObjectFormatters_);
  };

  SinglePrettyPrintRun.prototype.iterateObject = function(obj, fn) {
    var objKeys = keys(obj, j$.isArray_(obj));
    var isGetter = function isGetter(prop) {};

    if (obj.__lookupGetter__) {
      isGetter = function isGetter(prop) {
        var getter = obj.__lookupGetter__(prop);
        return !j$.util.isUndefined(getter) && getter !== null;
      };
    }
    var length = Math.min(objKeys.length, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);
    for (var i = 0; i < length; i++) {
      var property = objKeys[i];
      fn(property, isGetter(property));
    }

    return objKeys.length > length;
  };

  SinglePrettyPrintRun.prototype.emitScalar = function(value) {
    this.append(value);
  };

  SinglePrettyPrintRun.prototype.emitString = function(value) {
    this.append("'" + value + "'");
  };

  SinglePrettyPrintRun.prototype.emitArray = function(array) {
    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {
      this.append('Array');
      return;
    }
    var length = Math.min(array.length, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);
    this.append('[ ');
    for (var i = 0; i < length; i++) {
      if (i > 0) {
        this.append(', ');
      }
      this.format(array[i]);
    }
    if (array.length > length) {
      this.append(', ...');
    }

    var self = this;
    var first = array.length === 0;
    var truncated = this.iterateObject(array, function(property, isGetter) {
      if (first) {
        first = false;
      } else {
        self.append(', ');
      }

      self.formatProperty(array, property, isGetter);
    });

    if (truncated) {
      this.append(', ...');
    }

    this.append(' ]');
  };

  SinglePrettyPrintRun.prototype.emitSet = function(set) {
    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {
      this.append('Set');
      return;
    }
    this.append('Set( ');
    var size = Math.min(set.size, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);
    var i = 0;
    set.forEach(function(value, key) {
      if (i >= size) {
        return;
      }
      if (i > 0) {
        this.append(', ');
      }
      this.format(value);

      i++;
    }, this);
    if (set.size > size) {
      this.append(', ...');
    }
    this.append(' )');
  };

  SinglePrettyPrintRun.prototype.emitMap = function(map) {
    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {
      this.append('Map');
      return;
    }
    this.append('Map( ');
    var size = Math.min(map.size, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);
    var i = 0;
    map.forEach(function(value, key) {
      if (i >= size) {
        return;
      }
      if (i > 0) {
        this.append(', ');
      }
      this.format([key, value]);

      i++;
    }, this);
    if (map.size > size) {
      this.append(', ...');
    }
    this.append(' )');
  };

  SinglePrettyPrintRun.prototype.emitObject = function(obj) {
    var ctor = obj.constructor,
      constructorName;

    constructorName =
      typeof ctor === 'function' && obj instanceof ctor
        ? j$.fnNameFor(obj.constructor)
        : 'null';

    this.append(constructorName);

    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {
      return;
    }

    var self = this;
    this.append('({ ');
    var first = true;

    var truncated = this.iterateObject(obj, function(property, isGetter) {
      if (first) {
        first = false;
      } else {
        self.append(', ');
      }

      self.formatProperty(obj, property, isGetter);
    });

    if (truncated) {
      this.append(', ...');
    }

    this.append(' })');
  };

  SinglePrettyPrintRun.prototype.emitTypedArray = function(arr) {
    var constructorName = j$.fnNameFor(arr.constructor),
      limitedArray = Array.prototype.slice.call(
        arr,
        0,
        j$.MAX_PRETTY_PRINT_ARRAY_LENGTH
      ),
      itemsString = Array.prototype.join.call(limitedArray, ', ');

    if (limitedArray.length !== arr.length) {
      itemsString += ', ...';
    }

    this.append(constructorName + ' [ ' + itemsString + ' ]');
  };

  SinglePrettyPrintRun.prototype.emitDomElement = function(el) {
    var tagName = el.tagName.toLowerCase(),
      attrs = el.attributes,
      i,
      len = attrs.length,
      out = '<' + tagName,
      attr;

    for (i = 0; i < len; i++) {
      attr = attrs[i];
      out += ' ' + attr.name;

      if (attr.value !== '') {
        out += '="' + attr.value + '"';
      }
    }

    out += '>';

    if (el.childElementCount !== 0 || el.textContent !== '') {
      out += '...</' + tagName + '>';
    }

    this.append(out);
  };

  SinglePrettyPrintRun.prototype.formatProperty = function(
    obj,
    property,
    isGetter
  ) {
    this.append(property);
    this.append(': ');
    if (isGetter) {
      this.append('<getter>');
    } else {
      this.format(obj[property]);
    }
  };

  SinglePrettyPrintRun.prototype.append = function(value) {
    // This check protects us from the rare case where an object has overriden
    // `toString()` with an invalid implementation (returning a non-string).
    if (typeof value !== 'string') {
      value = Object.prototype.toString.call(value);
    }

    var result = truncate(value, j$.MAX_PRETTY_PRINT_CHARS - this.length);
    this.length += result.value.length;
    this.stringParts.push(result.value);

    if (result.truncated) {
      throw new MaxCharsReachedError();
    }
  };

  function truncate(s, maxlen) {
    if (s.length <= maxlen) {
      return { value: s, truncated: false };
    }

    s = s.substring(0, maxlen - 4) + ' ...';
    return { value: s, truncated: true };
  }

  function MaxCharsReachedError() {
    this.message =
      'Exceeded ' +
      j$.MAX_PRETTY_PRINT_CHARS +
      ' characters while pretty-printing a value';
  }

  MaxCharsReachedError.prototype = new Error();

  function keys(obj, isArray) {
    var allKeys = Object.keys
      ? Object.keys(obj)
      : (function(o) {
          var keys = [];
          for (var key in o) {
            if (j$.util.has(o, key)) {
              keys.push(key);
            }
          }
          return keys;
        })(obj);

    if (!isArray) {
      return allKeys;
    }

    if (allKeys.length === 0) {
      return allKeys;
    }

    var extraKeys = [];
    for (var i = 0; i < allKeys.length; i++) {
      if (!/^[0-9]+$/.test(allKeys[i])) {
        extraKeys.push(allKeys[i]);
      }
    }

    return extraKeys;
  }

  function customFormat(value, customObjectFormatters) {
    var i, result;

    for (i = 0; i < customObjectFormatters.length; i++) {
      result = customObjectFormatters[i](value);

      if (result !== undefined) {
        return result;
      }
    }
  }

  return function(customObjectFormatters) {
    customObjectFormatters = customObjectFormatters || [];

    var pp = function(value) {
      var prettyPrinter = new SinglePrettyPrintRun(customObjectFormatters, pp);
      prettyPrinter.format(value);
      return prettyPrinter.stringParts.join('');
    };

    pp.customFormat_ = function(value) {
      return customFormat(value, customObjectFormatters);
    };

    return pp;
  };
};

getJasmineRequireObj().QueueRunner = function(j$) {
  var nextid = 1;

  function StopExecutionError() {}
  StopExecutionError.prototype = new Error();
  j$.StopExecutionError = StopExecutionError;

  function once(fn, onTwice) {
    var called = false;
    return function(arg) {
      if (called) {
        if (onTwice) {
          onTwice();
        }
      } else {
        called = true;
        // Direct call using single parameter, because cleanup/next does not need more
        fn(arg);
      }
      return null;
    };
  }

  function fallbackOnMultipleDone() {
    console.error(
      new Error(
        "An asynchronous function called its 'done' " +
          'callback more than once, in a QueueRunner without a onMultipleDone ' +
          'handler.'
      )
    );
  }

  function emptyFn() {}

  function QueueRunner(attrs) {
    this.id_ = nextid++;
    this.queueableFns = attrs.queueableFns || [];
    this.onComplete = attrs.onComplete || emptyFn;
    this.clearStack =
      attrs.clearStack ||
      function(fn) {
        fn();
      };
    this.onException = attrs.onException || emptyFn;
    this.onMultipleDone = attrs.onMultipleDone || fallbackOnMultipleDone;
    this.userContext = attrs.userContext || new j$.UserContext();
    this.timeout = attrs.timeout || {
      setTimeout: setTimeout,
      clearTimeout: clearTimeout
    };
    this.fail = attrs.fail || emptyFn;
    this.globalErrors = attrs.globalErrors || {
      pushListener: emptyFn,
      popListener: emptyFn
    };

    const SkipPolicy = attrs.SkipPolicy || j$.NeverSkipPolicy;
    this.skipPolicy_ = new SkipPolicy(this.queueableFns);
    this.errored_ = false;

    if (typeof this.onComplete !== 'function') {
      throw new Error('invalid onComplete ' + JSON.stringify(this.onComplete));
    }
    this.deprecated = attrs.deprecated;
  }

  QueueRunner.prototype.execute = function() {
    var self = this;
    this.handleFinalError = function(message, source, lineno, colno, error) {
      // Older browsers would send the error as the first parameter. HTML5
      // specifies the the five parameters above. The error instance should
      // be preffered, otherwise the call stack would get lost.
      self.onException(error || message);
    };
    this.globalErrors.pushListener(this.handleFinalError);
    this.run(0);
  };

  QueueRunner.prototype.clearTimeout = function(timeoutId) {
    Function.prototype.apply.apply(this.timeout.clearTimeout, [
      j$.getGlobal(),
      [timeoutId]
    ]);
  };

  QueueRunner.prototype.setTimeout = function(fn, timeout) {
    return Function.prototype.apply.apply(this.timeout.setTimeout, [
      j$.getGlobal(),
      [fn, timeout]
    ]);
  };

  QueueRunner.prototype.attempt = function attempt(iterativeIndex) {
    var self = this,
      completedSynchronously = true,
      handleError = function handleError(error) {
        // TODO probably shouldn't next() right away here.
        // That makes debugging async failures much more confusing.
        onException(error);
      },
      cleanup = once(function cleanup() {
        if (timeoutId !== void 0) {
          self.clearTimeout(timeoutId);
        }
        self.globalErrors.popListener(handleError);
      }),
      next = once(
        function next(err) {
          cleanup();

          if (typeof err !== 'undefined') {
            if (!(err instanceof StopExecutionError) && !err.jasmineMessage) {
              self.fail(err);
            }
            self.recordError_(iterativeIndex);
          }

          function runNext() {
            self.run(self.nextFnIx_(iterativeIndex));
          }

          if (completedSynchronously) {
            self.setTimeout(runNext);
          } else {
            runNext();
          }
        },
        function() {
          try {
            if (!timedOut) {
              self.onMultipleDone();
            }
          } catch (error) {
            // Any error we catch here is probably due to a bug in Jasmine,
            // and it's not likely to end up anywhere useful if we let it
            // propagate. Log it so it can at least show up when debugging.
            console.error(error);
          }
        }
      ),
      timedOut = false,
      queueableFn = self.queueableFns[iterativeIndex],
      timeoutId,
      maybeThenable;

    next.fail = function nextFail() {
      self.fail.apply(null, arguments);
      self.recordError_(iterativeIndex);
      next();
    };

    self.globalErrors.pushListener(handleError);

    if (queueableFn.timeout !== undefined) {
      var timeoutInterval = queueableFn.timeout || j$.DEFAULT_TIMEOUT_INTERVAL;
      timeoutId = self.setTimeout(function() {
        timedOut = true;
        var error = new Error(
          'Timeout - Async function did not complete within ' +
            timeoutInterval +
            'ms ' +
            (queueableFn.timeout
              ? '(custom timeout)'
              : '(set by jasmine.DEFAULT_TIMEOUT_INTERVAL)')
        );
        // TODO Need to decide what to do about a successful completion after a
        //   timeout. That should probably not be a deprecation, and maybe not
        //   an error in 4.0. (But a diagnostic of some sort might be helpful.)
        onException(error);
        next();
      }, timeoutInterval);
    }

    try {
      if (queueableFn.fn.length === 0) {
        maybeThenable = queueableFn.fn.call(self.userContext);

        if (maybeThenable && j$.isFunction_(maybeThenable.then)) {
          maybeThenable.then(
            wrapInPromiseResolutionHandler(next),
            onPromiseRejection
          );
          completedSynchronously = false;
          return { completedSynchronously: false };
        }
      } else {
        maybeThenable = queueableFn.fn.call(self.userContext, next);
        this.diagnoseConflictingAsync_(queueableFn.fn, maybeThenable);
        completedSynchronously = false;
        return { completedSynchronously: false };
      }
    } catch (e) {
      onException(e);
      self.recordError_(iterativeIndex);
    }

    cleanup();
    return { completedSynchronously: true };

    function onException(e) {
      self.onException(e);
      self.recordError_(iterativeIndex);
    }

    function onPromiseRejection(e) {
      onException(e);
      next();
    }
  };

  QueueRunner.prototype.run = function(recursiveIndex) {
    var length = this.queueableFns.length,
      self = this,
      iterativeIndex;

    for (
      iterativeIndex = recursiveIndex;
      iterativeIndex < length;
      iterativeIndex = this.nextFnIx_(iterativeIndex)
    ) {
      var result = this.attempt(iterativeIndex);

      if (!result.completedSynchronously) {
        return;
      }
    }

    this.clearStack(function() {
      self.globalErrors.popListener(self.handleFinalError);

      if (self.errored_) {
        self.onComplete(new StopExecutionError());
      } else {
        self.onComplete();
      }
    });
  };

  QueueRunner.prototype.nextFnIx_ = function(currentFnIx) {
    const result = this.skipPolicy_.skipTo(currentFnIx);

    if (result === currentFnIx) {
      throw new Error("Can't skip to the same queueable fn that just finished");
    }

    return result;
  };

  QueueRunner.prototype.recordError_ = function(currentFnIx) {
    this.errored_ = true;
    this.skipPolicy_.fnErrored(currentFnIx);
  };

  QueueRunner.prototype.diagnoseConflictingAsync_ = function(fn, retval) {
    var msg;

    if (retval && j$.isFunction_(retval.then)) {
      // Issue a warning that matches the user's code.
      // Omit the stack trace because there's almost certainly no user code
      // on the stack at this point.
      if (j$.isAsyncFunction_(fn)) {
        this.onException(
          'An asynchronous before/it/after ' +
            'function was defined with the async keyword but also took a ' +
            'done callback. Either remove the done callback (recommended) or ' +
            'remove the async keyword.'
        );
      } else {
        this.onException(
          'An asynchronous before/it/after ' +
            'function took a done callback but also returned a promise. ' +
            'Either remove the done callback (recommended) or change the ' +
            'function to not return a promise.'
        );
      }

      this.deprecated(msg, { omitStackTrace: true });
    }
  };

  function wrapInPromiseResolutionHandler(fn) {
    return function(maybeArg) {
      if (j$.isError_(maybeArg)) {
        fn(maybeArg);
      } else {
        fn();
      }
    };
  }

  return QueueRunner;
};

getJasmineRequireObj().ReportDispatcher = function(j$) {
  function ReportDispatcher(methods, queueRunnerFactory, onLateError) {
    var dispatchedMethods = methods || [];

    for (var i = 0; i < dispatchedMethods.length; i++) {
      var method = dispatchedMethods[i];
      this[method] = (function(m) {
        return function() {
          dispatch(m, arguments);
        };
      })(method);
    }

    var reporters = [];
    var fallbackReporter = null;

    this.addReporter = function(reporter) {
      reporters.push(reporter);
    };

    this.provideFallbackReporter = function(reporter) {
      fallbackReporter = reporter;
    };

    this.clearReporters = function() {
      reporters = [];
    };

    return this;

    function dispatch(method, args) {
      if (reporters.length === 0 && fallbackReporter !== null) {
        reporters.push(fallbackReporter);
      }
      var onComplete = args[args.length - 1];
      args = j$.util.argsToArray(args).splice(0, args.length - 1);
      var fns = [];
      for (var i = 0; i < reporters.length; i++) {
        var reporter = reporters[i];
        addFn(fns, reporter, method, args);
      }

      queueRunnerFactory({
        queueableFns: fns,
        onComplete: onComplete,
        isReporter: true,
        onMultipleDone: function() {
          onLateError(
            new Error(
              "An asynchronous reporter callback called its 'done' callback " +
                'more than once.'
            )
          );
        }
      });
    }

    function addFn(fns, reporter, method, args) {
      var fn = reporter[method];
      if (!fn) {
        return;
      }

      var thisArgs = j$.util.cloneArgs(args);
      if (fn.length <= 1) {
        fns.push({
          fn: function() {
            return fn.apply(reporter, thisArgs);
          }
        });
      } else {
        fns.push({
          fn: function(done) {
            return fn.apply(reporter, thisArgs.concat([done]));
          }
        });
      }
    }
  }

  return ReportDispatcher;
};

getJasmineRequireObj().interface = function(jasmine, env) {
  var jasmineInterface = {
    /**
     * Callback passed to parts of the Jasmine base interface.
     *
     * By default Jasmine assumes this function completes synchronously.
     * If you have code that you need to test asynchronously, you can declare that you receive a `done` callback, return a Promise, or use the `async` keyword if it is supported in your environment.
     * @callback implementationCallback
     * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.
     * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.
     */

    /**
     * Create a group of specs (often called a suite).
     *
     * Calls to `describe` can be nested within other calls to compose your suite as a tree.
     * @name describe
     * @since 1.3.0
     * @function
     * @global
     * @param {String} description Textual description of the group
     * @param {Function} specDefinitions Function for Jasmine to invoke that will define inner suites and specs
     */
    describe: function(description, specDefinitions) {
      return env.describe(description, specDefinitions);
    },

    /**
     * A temporarily disabled [`describe`]{@link describe}
     *
     * Specs within an `xdescribe` will be marked pending and not executed
     * @name xdescribe
     * @since 1.3.0
     * @function
     * @global
     * @param {String} description Textual description of the group
     * @param {Function} specDefinitions Function for Jasmine to invoke that will define inner suites and specs
     */
    xdescribe: function(description, specDefinitions) {
      return env.xdescribe(description, specDefinitions);
    },

    /**
     * A focused [`describe`]{@link describe}
     *
     * If suites or specs are focused, only those that are focused will be executed
     * @see fit
     * @name fdescribe
     * @since 2.1.0
     * @function
     * @global
     * @param {String} description Textual description of the group
     * @param {Function} specDefinitions Function for Jasmine to invoke that will define inner suites and specs
     */
    fdescribe: function(description, specDefinitions) {
      return env.fdescribe(description, specDefinitions);
    },

    /**
     * Define a single spec. A spec should contain one or more {@link expect|expectations} that test the state of the code.
     *
     * A spec whose expectations all succeed will be passing and a spec with any failures will fail.
     * The name `it` is a pronoun for the test target, not an abbreviation of anything. It makes the
     * spec more readable by connecting the function name `it` and the argument `description` as a
     * complete sentence.
     * @name it
     * @since 1.3.0
     * @function
     * @global
     * @param {String} description Textual description of what this spec is checking
     * @param {implementationCallback} [testFunction] Function that contains the code of your test. If not provided the test will be `pending`.
     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async spec.
     * @see async
     */
    it: function() {
      return env.it.apply(env, arguments);
    },

    /**
     * A temporarily disabled [`it`]{@link it}
     *
     * The spec will report as `pending` and will not be executed.
     * @name xit
     * @since 1.3.0
     * @function
     * @global
     * @param {String} description Textual description of what this spec is checking.
     * @param {implementationCallback} [testFunction] Function that contains the code of your test. Will not be executed.
     */
    xit: function() {
      return env.xit.apply(env, arguments);
    },

    /**
     * A focused [`it`]{@link it}
     *
     * If suites or specs are focused, only those that are focused will be executed.
     * @name fit
     * @since 2.1.0
     * @function
     * @global
     * @param {String} description Textual description of what this spec is checking.
     * @param {implementationCallback} testFunction Function that contains the code of your test.
     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async spec.
     * @see async
     */
    fit: function() {
      return env.fit.apply(env, arguments);
    },

    /**
     * Run some shared setup before each of the specs in the {@link describe} in which it is called.
     * @name beforeEach
     * @since 1.3.0
     * @function
     * @global
     * @param {implementationCallback} [function] Function that contains the code to setup your specs.
     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async beforeEach.
     * @see async
     */
    beforeEach: function() {
      return env.beforeEach.apply(env, arguments);
    },

    /**
     * Run some shared teardown after each of the specs in the {@link describe} in which it is called.
     * @name afterEach
     * @since 1.3.0
     * @function
     * @global
     * @param {implementationCallback} [function] Function that contains the code to teardown your specs.
     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async afterEach.
     * @see async
     */
    afterEach: function() {
      return env.afterEach.apply(env, arguments);
    },

    /**
     * Run some shared setup once before all of the specs in the {@link describe} are run.
     *
     * _Note:_ Be careful, sharing the setup from a beforeAll makes it easy to accidentally leak state between your specs so that they erroneously pass or fail.
     * @name beforeAll
     * @since 2.1.0
     * @function
     * @global
     * @param {implementationCallback} [function] Function that contains the code to setup your specs.
     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async beforeAll.
     * @see async
     */
    beforeAll: function() {
      return env.beforeAll.apply(env, arguments);
    },

    /**
     * Run some shared teardown once after all of the specs in the {@link describe} are run.
     *
     * _Note:_ Be careful, sharing the teardown from a afterAll makes it easy to accidentally leak state between your specs so that they erroneously pass or fail.
     * @name afterAll
     * @since 2.1.0
     * @function
     * @global
     * @param {implementationCallback} [function] Function that contains the code to teardown your specs.
     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async afterAll.
     * @see async
     */
    afterAll: function() {
      return env.afterAll.apply(env, arguments);
    },

    /**
     * Sets a user-defined property that will be provided to reporters as part of the properties field of {@link SpecResult}
     * @name setSpecProperty
     * @since 3.6.0
     * @function
     * @param {String} key The name of the property
     * @param {*} value The value of the property
     */
    setSpecProperty: function(key, value) {
      return env.setSpecProperty(key, value);
    },

    /**
     * Sets a user-defined property that will be provided to reporters as part of the properties field of {@link SuiteResult}
     * @name setSuiteProperty
     * @since 3.6.0
     * @function
     * @param {String} key The name of the property
     * @param {*} value The value of the property
     */
    setSuiteProperty: function(key, value) {
      return env.setSuiteProperty(key, value);
    },

    /**
     * Create an expectation for a spec.
     * @name expect
     * @since 1.3.0
     * @function
     * @global
     * @param {Object} actual - Actual computed value to test expectations against.
     * @return {matchers}
     */
    expect: function(actual) {
      return env.expect(actual);
    },

    /**
     * Create an asynchronous expectation for a spec. Note that the matchers
     * that are provided by an asynchronous expectation all return promises
     * which must be either returned from the spec or waited for using `await`
     * in order for Jasmine to associate them with the correct spec.
     * @name expectAsync
     * @since 3.3.0
     * @function
     * @global
     * @param {Object} actual - Actual computed value to test expectations against.
     * @return {async-matchers}
     * @example
     * await expectAsync(somePromise).toBeResolved();
     * @example
     * return expectAsync(somePromise).toBeResolved();
     */
    expectAsync: function(actual) {
      return env.expectAsync(actual);
    },

    /**
     * Mark a spec as pending, expectation results will be ignored.
     * @name pending
     * @since 2.0.0
     * @function
     * @global
     * @param {String} [message] - Reason the spec is pending.
     */
    pending: function() {
      return env.pending.apply(env, arguments);
    },

    /**
     * Explicitly mark a spec as failed.
     * @name fail
     * @since 2.1.0
     * @function
     * @global
     * @param {String|Error} [error] - Reason for the failure.
     */
    fail: function() {
      return env.fail.apply(env, arguments);
    },

    /**
     * Install a spy onto an existing object.
     * @name spyOn
     * @since 1.3.0
     * @function
     * @global
     * @param {Object} obj - The object upon which to install the {@link Spy}.
     * @param {String} methodName - The name of the method to replace with a {@link Spy}.
     * @returns {Spy}
     */
    spyOn: function(obj, methodName) {
      return env.spyOn(obj, methodName);
    },

    /**
     * Install a spy on a property installed with `Object.defineProperty` onto an existing object.
     * @name spyOnProperty
     * @since 2.6.0
     * @function
     * @global
     * @param {Object} obj - The object upon which to install the {@link Spy}
     * @param {String} propertyName - The name of the property to replace with a {@link Spy}.
     * @param {String} [accessType=get] - The access type (get|set) of the property to {@link Spy} on.
     * @returns {Spy}
     */
    spyOnProperty: function(obj, methodName, accessType) {
      return env.spyOnProperty(obj, methodName, accessType);
    },

    /**
     * Installs spies on all writable and configurable properties of an object.
     * @name spyOnAllFunctions
     * @since 3.2.1
     * @function
     * @global
     * @param {Object} obj - The object upon which to install the {@link Spy}s
     * @param {boolean} includeNonEnumerable - Whether or not to add spies to non-enumerable properties
     * @returns {Object} the spied object
     */
    spyOnAllFunctions: function(obj, includeNonEnumerable) {
      return env.spyOnAllFunctions(obj, includeNonEnumerable);
    },

    jsApiReporter: new jasmine.JsApiReporter({
      timer: new jasmine.Timer()
    }),

    /**
     * @namespace jasmine
     */
    jasmine: jasmine
  };

  /**
   * Add a custom equality tester for the current scope of specs.
   *
   * _Note:_ This is only callable from within a {@link beforeEach}, {@link it}, or {@link beforeAll}.
   * @name jasmine.addCustomEqualityTester
   * @since 2.0.0
   * @function
   * @param {Function} tester - A function which takes two arguments to compare and returns a `true` or `false` comparison result if it knows how to compare them, and `undefined` otherwise.
   * @see custom_equality
   */
  jasmine.addCustomEqualityTester = function(tester) {
    env.addCustomEqualityTester(tester);
  };

  /**
   * Add custom matchers for the current scope of specs.
   *
   * _Note:_ This is only callable from within a {@link beforeEach}, {@link it}, or {@link beforeAll}.
   * @name jasmine.addMatchers
   * @since 2.0.0
   * @function
   * @param {Object} matchers - Keys from this object will be the new matcher names.
   * @see custom_matcher
   */
  jasmine.addMatchers = function(matchers) {
    return env.addMatchers(matchers);
  };

  /**
   * Add custom async matchers for the current scope of specs.
   *
   * _Note:_ This is only callable from within a {@link beforeEach}, {@link it}, or {@link beforeAll}.
   * @name jasmine.addAsyncMatchers
   * @since 3.5.0
   * @function
   * @param {Object} matchers - Keys from this object will be the new async matcher names.
   * @see custom_matcher
   */
  jasmine.addAsyncMatchers = function(matchers) {
    return env.addAsyncMatchers(matchers);
  };

  /**
   * Add a custom object formatter for the current scope of specs.
   *
   * _Note:_ This is only callable from within a {@link beforeEach}, {@link it}, or {@link beforeAll}.
   * @name jasmine.addCustomObjectFormatter
   * @since 3.6.0
   * @function
   * @param {Function} formatter - A function which takes a value to format and returns a string if it knows how to format it, and `undefined` otherwise.
   * @see custom_object_formatters
   */
  jasmine.addCustomObjectFormatter = function(formatter) {
    return env.addCustomObjectFormatter(formatter);
  };

  /**
   * Get the currently booted mock {Clock} for this Jasmine environment.
   * @name jasmine.clock
   * @since 2.0.0
   * @function
   * @returns {Clock}
   */
  jasmine.clock = function() {
    return env.clock;
  };

  /**
   * Create a bare {@link Spy} object. This won't be installed anywhere and will not have any implementation behind it.
   * @name jasmine.createSpy
   * @since 1.3.0
   * @function
   * @param {String} [name] - Name to give the spy. This will be displayed in failure messages.
   * @param {Function} [originalFn] - Function to act as the real implementation.
   * @return {Spy}
   */
  jasmine.createSpy = function(name, originalFn) {
    return env.createSpy(name, originalFn);
  };

  /**
   * Create an object with multiple {@link Spy}s as its members.
   * @name jasmine.createSpyObj
   * @since 1.3.0
   * @function
   * @param {String} [baseName] - Base name for the spies in the object.
   * @param {String[]|Object} methodNames - Array of method names to create spies for, or Object whose keys will be method names and values the {@link Spy#and#returnValue|returnValue}.
   * @param {String[]|Object} [propertyNames] - Array of property names to create spies for, or Object whose keys will be propertynames and values the {@link Spy#and#returnValue|returnValue}.
   * @return {Object}
   */
  jasmine.createSpyObj = function(baseName, methodNames, propertyNames) {
    return env.createSpyObj(baseName, methodNames, propertyNames);
  };

  /**
   * Add a custom spy strategy for the current scope of specs.
   *
   * _Note:_ This is only callable from within a {@link beforeEach}, {@link it}, or {@link beforeAll}.
   * @name jasmine.addSpyStrategy
   * @since 3.5.0
   * @function
   * @param {String} name - The name of the strategy (i.e. what you call from `and`)
   * @param {Function} factory - Factory function that returns the plan to be executed.
   */
  jasmine.addSpyStrategy = function(name, factory) {
    return env.addSpyStrategy(name, factory);
  };

  /**
   * Set the default spy strategy for the current scope of specs.
   *
   * _Note:_ This is only callable from within a {@link beforeEach}, {@link it}, or {@link beforeAll}.
   * @name jasmine.setDefaultSpyStrategy
   * @function
   * @param {Function} defaultStrategyFn - a function that assigns a strategy
   * @example
   * beforeEach(function() {
   *   jasmine.setDefaultSpyStrategy(and => and.returnValue(true));
   * });
   */
  jasmine.setDefaultSpyStrategy = function(defaultStrategyFn) {
    return env.setDefaultSpyStrategy(defaultStrategyFn);
  };

  return jasmineInterface;
};

getJasmineRequireObj().SkipAfterBeforeAllErrorPolicy = function(j$) {
  function SkipAfterBeforeAllErrorPolicy(queueableFns) {
    this.queueableFns_ = queueableFns;
    this.skipping_ = false;
  }

  SkipAfterBeforeAllErrorPolicy.prototype.skipTo = function(lastRanFnIx) {
    if (this.skipping_) {
      return this.nextAfterAllAfter_(lastRanFnIx);
    } else {
      return lastRanFnIx + 1;
    }
  };

  SkipAfterBeforeAllErrorPolicy.prototype.nextAfterAllAfter_ = function(i) {
    for (
      i++;
      i < this.queueableFns_.length &&
      this.queueableFns_[i].type !== 'afterAll';
      i++
    ) {}
    return i;
  };

  SkipAfterBeforeAllErrorPolicy.prototype.fnErrored = function(fnIx) {
    if (this.queueableFns_[fnIx].type === 'beforeAll') {
      this.skipping_ = true;
      // Failures need to be reported for each contained spec. But we can't do
      // that from here because reporting is async. This function isn't async
      // (and can't be without greatly complicating QueueRunner). Mark the
      // failure so that the code that reports the suite result (which is
      // already async) can detect the failure and report the specs.
      this.queueableFns_[fnIx].suite.hadBeforeAllFailure = true;
    }
  };

  return SkipAfterBeforeAllErrorPolicy;
};

getJasmineRequireObj().Spy = function(j$) {
  var nextOrder = (function() {
    var order = 0;

    return function() {
      return order++;
    };
  })();

  /**
   * @classdesc _Note:_ Do not construct this directly. Use {@link spyOn},
   * {@link spyOnProperty}, {@link jasmine.createSpy}, or
   * {@link jasmine.createSpyObj} instead.
   * @class Spy
   * @hideconstructor
   */
  function Spy(name, matchersUtil, optionals) {
    const { originalFn, customStrategies, defaultStrategyFn } = optionals || {};

    var numArgs = typeof originalFn === 'function' ? originalFn.length : 0,
      wrapper = makeFunc(numArgs, function(context, args, invokeNew) {
        return spy(context, args, invokeNew);
      }),
      strategyDispatcher = new SpyStrategyDispatcher(
        {
          name: name,
          fn: originalFn,
          getSpy: function() {
            return wrapper;
          },
          customStrategies: customStrategies
        },
        matchersUtil
      ),
      callTracker = new j$.CallTracker(),
      spy = function(context, args, invokeNew) {
        /**
         * @name Spy.callData
         * @property {object} object - `this` context for the invocation.
         * @property {number} invocationOrder - Order of the invocation.
         * @property {Array} args - The arguments passed for this invocation.
         * @property returnValue - The value that was returned from this invocation.
         */
        var callData = {
          object: context,
          invocationOrder: nextOrder(),
          args: Array.prototype.slice.apply(args)
        };

        callTracker.track(callData);
        var returnValue = strategyDispatcher.exec(context, args, invokeNew);
        callData.returnValue = returnValue;

        return returnValue;
      };

    function makeFunc(length, fn) {
      switch (length) {
        case 1:
          return function wrap1(a) {
            return fn(this, arguments, this instanceof wrap1);
          };
        case 2:
          return function wrap2(a, b) {
            return fn(this, arguments, this instanceof wrap2);
          };
        case 3:
          return function wrap3(a, b, c) {
            return fn(this, arguments, this instanceof wrap3);
          };
        case 4:
          return function wrap4(a, b, c, d) {
            return fn(this, arguments, this instanceof wrap4);
          };
        case 5:
          return function wrap5(a, b, c, d, e) {
            return fn(this, arguments, this instanceof wrap5);
          };
        case 6:
          return function wrap6(a, b, c, d, e, f) {
            return fn(this, arguments, this instanceof wrap6);
          };
        case 7:
          return function wrap7(a, b, c, d, e, f, g) {
            return fn(this, arguments, this instanceof wrap7);
          };
        case 8:
          return function wrap8(a, b, c, d, e, f, g, h) {
            return fn(this, arguments, this instanceof wrap8);
          };
        case 9:
          return function wrap9(a, b, c, d, e, f, g, h, i) {
            return fn(this, arguments, this instanceof wrap9);
          };
        default:
          return function wrap() {
            return fn(this, arguments, this instanceof wrap);
          };
      }
    }

    for (var prop in originalFn) {
      if (prop === 'and' || prop === 'calls') {
        throw new Error(
          "Jasmine spies would overwrite the 'and' and 'calls' properties on the object being spied upon"
        );
      }

      wrapper[prop] = originalFn[prop];
    }

    /**
     * @member {SpyStrategy} - Accesses the default strategy for the spy. This strategy will be used
     * whenever the spy is called with arguments that don't match any strategy
     * created with {@link Spy#withArgs}.
     * @name Spy#and
     * @since 2.0.0
     * @example
     * spyOn(someObj, 'func').and.returnValue(42);
     */
    wrapper.and = strategyDispatcher.and;
    /**
     * Specifies a strategy to be used for calls to the spy that have the
     * specified arguments.
     * @name Spy#withArgs
     * @since 3.0.0
     * @function
     * @param {...*} args - The arguments to match
     * @type {SpyStrategy}
     * @example
     * spyOn(someObj, 'func').withArgs(1, 2, 3).and.returnValue(42);
     * someObj.func(1, 2, 3); // returns 42
     */
    wrapper.withArgs = function() {
      return strategyDispatcher.withArgs.apply(strategyDispatcher, arguments);
    };
    wrapper.calls = callTracker;

    if (defaultStrategyFn) {
      defaultStrategyFn(wrapper.and);
    }

    return wrapper;
  }

  function SpyStrategyDispatcher(strategyArgs, matchersUtil) {
    var baseStrategy = new j$.SpyStrategy(strategyArgs);
    var argsStrategies = new StrategyDict(function() {
      return new j$.SpyStrategy(strategyArgs);
    }, matchersUtil);

    this.and = baseStrategy;

    this.exec = function(spy, args, invokeNew) {
      var strategy = argsStrategies.get(args);

      if (!strategy) {
        if (argsStrategies.any() && !baseStrategy.isConfigured()) {
          throw new Error(
            "Spy '" +
              strategyArgs.name +
              "' received a call with arguments " +
              j$.basicPrettyPrinter_(Array.prototype.slice.call(args)) +
              ' but all configured strategies specify other arguments.'
          );
        } else {
          strategy = baseStrategy;
        }
      }

      return strategy.exec(spy, args, invokeNew);
    };

    this.withArgs = function() {
      return { and: argsStrategies.getOrCreate(arguments) };
    };
  }

  function StrategyDict(strategyFactory, matchersUtil) {
    this.strategies = [];
    this.strategyFactory = strategyFactory;
    this.matchersUtil = matchersUtil;
  }

  StrategyDict.prototype.any = function() {
    return this.strategies.length > 0;
  };

  StrategyDict.prototype.getOrCreate = function(args) {
    var strategy = this.get(args);

    if (!strategy) {
      strategy = this.strategyFactory();
      this.strategies.push({
        args: args,
        strategy: strategy
      });
    }

    return strategy;
  };

  StrategyDict.prototype.get = function(args) {
    var i;

    for (i = 0; i < this.strategies.length; i++) {
      if (this.matchersUtil.equals(args, this.strategies[i].args)) {
        return this.strategies[i].strategy;
      }
    }
  };

  return Spy;
};

getJasmineRequireObj().SpyFactory = function(j$) {
  function SpyFactory(
    getCustomStrategies,
    getDefaultStrategyFn,
    getMatchersUtil
  ) {
    var self = this;

    this.createSpy = function(name, originalFn) {
      return j$.Spy(name, getMatchersUtil(), {
        originalFn,
        customStrategies: getCustomStrategies(),
        defaultStrategyFn: getDefaultStrategyFn()
      });
    };

    this.createSpyObj = function(baseName, methodNames, propertyNames) {
      var baseNameIsCollection =
        j$.isObject_(baseName) || j$.isArray_(baseName);

      if (baseNameIsCollection) {
        propertyNames = methodNames;
        methodNames = baseName;
        baseName = 'unknown';
      }

      var obj = {};
      var spy, descriptor;

      var methods = normalizeKeyValues(methodNames);
      for (var i = 0; i < methods.length; i++) {
        spy = obj[methods[i][0]] = self.createSpy(
          baseName + '.' + methods[i][0]
        );
        if (methods[i].length > 1) {
          spy.and.returnValue(methods[i][1]);
        }
      }

      var properties = normalizeKeyValues(propertyNames);
      for (var i = 0; i < properties.length; i++) {
        descriptor = {
          enumerable: true,
          get: self.createSpy(baseName + '.' + properties[i][0] + '.get'),
          set: self.createSpy(baseName + '.' + properties[i][0] + '.set')
        };
        if (properties[i].length > 1) {
          descriptor.get.and.returnValue(properties[i][1]);
          descriptor.set.and.returnValue(properties[i][1]);
        }
        Object.defineProperty(obj, properties[i][0], descriptor);
      }

      if (methods.length === 0 && properties.length === 0) {
        throw 'createSpyObj requires a non-empty array or object of method names to create spies for';
      }

      return obj;
    };
  }

  function normalizeKeyValues(object) {
    var result = [];
    if (j$.isArray_(object)) {
      for (var i = 0; i < object.length; i++) {
        result.push([object[i]]);
      }
    } else if (j$.isObject_(object)) {
      for (var key in object) {
        if (object.hasOwnProperty(key)) {
          result.push([key, object[key]]);
        }
      }
    }
    return result;
  }

  return SpyFactory;
};

getJasmineRequireObj().SpyRegistry = function(j$) {
  var spyOnMsg = j$.formatErrorMsg('<spyOn>', 'spyOn(<object>, <methodName>)');
  var spyOnPropertyMsg = j$.formatErrorMsg(
    '<spyOnProperty>',
    'spyOnProperty(<object>, <propName>, [accessType])'
  );

  function SpyRegistry(options) {
    options = options || {};
    var global = options.global || j$.getGlobal();
    var createSpy = options.createSpy;
    var currentSpies =
      options.currentSpies ||
      function() {
        return [];
      };

    this.allowRespy = function(allow) {
      this.respy = allow;
    };

    this.spyOn = function(obj, methodName) {
      var getErrorMsg = spyOnMsg;

      if (j$.util.isUndefined(obj) || obj === null) {
        throw new Error(
          getErrorMsg(
            'could not find an object to spy upon for ' + methodName + '()'
          )
        );
      }

      if (j$.util.isUndefined(methodName) || methodName === null) {
        throw new Error(getErrorMsg('No method name supplied'));
      }

      if (j$.util.isUndefined(obj[methodName])) {
        throw new Error(getErrorMsg(methodName + '() method does not exist'));
      }

      if (obj[methodName] && j$.isSpy(obj[methodName])) {
        if (this.respy) {
          return obj[methodName];
        } else {
          throw new Error(
            getErrorMsg(methodName + ' has already been spied upon')
          );
        }
      }

      var descriptor = Object.getOwnPropertyDescriptor(obj, methodName);

      if (descriptor && !(descriptor.writable || descriptor.set)) {
        throw new Error(
          getErrorMsg(methodName + ' is not declared writable or has no setter')
        );
      }

      var originalMethod = obj[methodName],
        spiedMethod = createSpy(methodName, originalMethod),
        restoreStrategy;

      if (
        Object.prototype.hasOwnProperty.call(obj, methodName) ||
        (obj === global && methodName === 'onerror')
      ) {
        restoreStrategy = function() {
          obj[methodName] = originalMethod;
        };
      } else {
        restoreStrategy = function() {
          if (!delete obj[methodName]) {
            obj[methodName] = originalMethod;
          }
        };
      }

      currentSpies().push({
        restoreObjectToOriginalState: restoreStrategy
      });

      obj[methodName] = spiedMethod;

      return spiedMethod;
    };

    this.spyOnProperty = function(obj, propertyName, accessType) {
      var getErrorMsg = spyOnPropertyMsg;

      accessType = accessType || 'get';

      if (j$.util.isUndefined(obj)) {
        throw new Error(
          getErrorMsg(
            'spyOn could not find an object to spy upon for ' +
              propertyName +
              ''
          )
        );
      }

      if (j$.util.isUndefined(propertyName)) {
        throw new Error(getErrorMsg('No property name supplied'));
      }

      var descriptor = j$.util.getPropertyDescriptor(obj, propertyName);

      if (!descriptor) {
        throw new Error(getErrorMsg(propertyName + ' property does not exist'));
      }

      if (!descriptor.configurable) {
        throw new Error(
          getErrorMsg(propertyName + ' is not declared configurable')
        );
      }

      if (!descriptor[accessType]) {
        throw new Error(
          getErrorMsg(
            'Property ' +
              propertyName +
              ' does not have access type ' +
              accessType
          )
        );
      }

      if (j$.isSpy(descriptor[accessType])) {
        if (this.respy) {
          return descriptor[accessType];
        } else {
          throw new Error(
            getErrorMsg(
              propertyName + '#' + accessType + ' has already been spied upon'
            )
          );
        }
      }

      var originalDescriptor = j$.util.clone(descriptor),
        spy = createSpy(propertyName, descriptor[accessType]),
        restoreStrategy;

      if (Object.prototype.hasOwnProperty.call(obj, propertyName)) {
        restoreStrategy = function() {
          Object.defineProperty(obj, propertyName, originalDescriptor);
        };
      } else {
        restoreStrategy = function() {
          delete obj[propertyName];
        };
      }

      currentSpies().push({
        restoreObjectToOriginalState: restoreStrategy
      });

      descriptor[accessType] = spy;

      Object.defineProperty(obj, propertyName, descriptor);

      return spy;
    };

    this.spyOnAllFunctions = function(obj, includeNonEnumerable) {
      if (j$.util.isUndefined(obj)) {
        throw new Error(
          'spyOnAllFunctions could not find an object to spy upon'
        );
      }

      var pointer = obj,
        propsToSpyOn = [],
        properties,
        propertiesToSkip = [];

      while (
        pointer &&
        (!includeNonEnumerable || pointer !== Object.prototype)
      ) {
        properties = getProps(pointer, includeNonEnumerable);
        properties = properties.filter(function(prop) {
          return propertiesToSkip.indexOf(prop) === -1;
        });
        propertiesToSkip = propertiesToSkip.concat(properties);
        propsToSpyOn = propsToSpyOn.concat(
          getSpyableFunctionProps(pointer, properties)
        );
        pointer = Object.getPrototypeOf(pointer);
      }

      for (var i = 0; i < propsToSpyOn.length; i++) {
        this.spyOn(obj, propsToSpyOn[i]);
      }

      return obj;
    };

    this.clearSpies = function() {
      var spies = currentSpies();
      for (var i = spies.length - 1; i >= 0; i--) {
        var spyEntry = spies[i];
        spyEntry.restoreObjectToOriginalState();
      }
    };
  }

  function getProps(obj, includeNonEnumerable) {
    var enumerableProperties = Object.keys(obj);

    if (!includeNonEnumerable) {
      return enumerableProperties;
    }

    return Object.getOwnPropertyNames(obj).filter(function(prop) {
      return (
        prop !== 'constructor' ||
        enumerableProperties.indexOf('constructor') > -1
      );
    });
  }

  function getSpyableFunctionProps(obj, propertiesToCheck) {
    var props = [],
      prop;
    for (var i = 0; i < propertiesToCheck.length; i++) {
      prop = propertiesToCheck[i];
      if (
        Object.prototype.hasOwnProperty.call(obj, prop) &&
        isSpyableProp(obj, prop)
      ) {
        props.push(prop);
      }
    }
    return props;
  }

  function isSpyableProp(obj, prop) {
    var value, descriptor;
    try {
      value = obj[prop];
    } catch (e) {
      return false;
    }
    if (value instanceof Function) {
      descriptor = Object.getOwnPropertyDescriptor(obj, prop);
      return (descriptor.writable || descriptor.set) && descriptor.configurable;
    }
    return false;
  }

  return SpyRegistry;
};

getJasmineRequireObj().SpyStrategy = function(j$) {
  /**
   * @interface SpyStrategy
   */
  function SpyStrategy(options) {
    options = options || {};

    var self = this;

    /**
     * Get the identifying information for the spy.
     * @name SpyStrategy#identity
     * @since 3.0.0
     * @member
     * @type {String}
     */
    this.identity = options.name || 'unknown';
    this.originalFn = options.fn || function() {};
    this.getSpy = options.getSpy || function() {};
    this.plan = this._defaultPlan = function() {};

    var k,
      cs = options.customStrategies || {};
    for (k in cs) {
      if (j$.util.has(cs, k) && !this[k]) {
        this[k] = createCustomPlan(cs[k]);
      }
    }

    /**
     * Tell the spy to return a promise resolving to the specified value when invoked.
     * @name SpyStrategy#resolveTo
     * @since 3.5.0
     * @function
     * @param {*} value The value to return.
     */
    this.resolveTo = function(value) {
      self.plan = function() {
        return Promise.resolve(value);
      };
      return self.getSpy();
    };

    /**
     * Tell the spy to return a promise rejecting with the specified value when invoked.
     * @name SpyStrategy#rejectWith
     * @since 3.5.0
     * @function
     * @param {*} value The value to return.
     */
    this.rejectWith = function(value) {
      self.plan = function() {
        return Promise.reject(value);
      };
      return self.getSpy();
    };
  }

  function createCustomPlan(factory) {
    return function() {
      var plan = factory.apply(null, arguments);

      if (!j$.isFunction_(plan)) {
        throw new Error('Spy strategy must return a function');
      }

      this.plan = plan;
      return this.getSpy();
    };
  }

  /**
   * Execute the current spy strategy.
   * @name SpyStrategy#exec
   * @since 2.0.0
   * @function
   */
  SpyStrategy.prototype.exec = function(context, args, invokeNew) {
    var contextArgs = [context].concat(
      args ? Array.prototype.slice.call(args) : []
    );
    var target = this.plan.bind.apply(this.plan, contextArgs);

    return invokeNew ? new target() : target();
  };

  /**
   * Tell the spy to call through to the real implementation when invoked.
   * @name SpyStrategy#callThrough
   * @since 2.0.0
   * @function
   */
  SpyStrategy.prototype.callThrough = function() {
    this.plan = this.originalFn;
    return this.getSpy();
  };

  /**
   * Tell the spy to return the value when invoked.
   * @name SpyStrategy#returnValue
   * @since 2.0.0
   * @function
   * @param {*} value The value to return.
   */
  SpyStrategy.prototype.returnValue = function(value) {
    this.plan = function() {
      return value;
    };
    return this.getSpy();
  };

  /**
   * Tell the spy to return one of the specified values (sequentially) each time the spy is invoked.
   * @name SpyStrategy#returnValues
   * @since 2.1.0
   * @function
   * @param {...*} values - Values to be returned on subsequent calls to the spy.
   */
  SpyStrategy.prototype.returnValues = function() {
    var values = Array.prototype.slice.call(arguments);
    this.plan = function() {
      return values.shift();
    };
    return this.getSpy();
  };

  /**
   * Tell the spy to throw an error when invoked.
   * @name SpyStrategy#throwError
   * @since 2.0.0
   * @function
   * @param {Error|Object|String} something Thing to throw
   */
  SpyStrategy.prototype.throwError = function(something) {
    var error = j$.isString_(something) ? new Error(something) : something;
    this.plan = function() {
      throw error;
    };
    return this.getSpy();
  };

  /**
   * Tell the spy to call a fake implementation when invoked.
   * @name SpyStrategy#callFake
   * @since 2.0.0
   * @function
   * @param {Function} fn The function to invoke with the passed parameters.
   */
  SpyStrategy.prototype.callFake = function(fn) {
    if (
      !(
        j$.isFunction_(fn) ||
        j$.isAsyncFunction_(fn) ||
        j$.isGeneratorFunction_(fn)
      )
    ) {
      throw new Error(
        'Argument passed to callFake should be a function, got ' + fn
      );
    }
    this.plan = fn;
    return this.getSpy();
  };

  /**
   * Tell the spy to do nothing when invoked. This is the default.
   * @name SpyStrategy#stub
   * @since 2.0.0
   * @function
   */
  SpyStrategy.prototype.stub = function(fn) {
    this.plan = function() {};
    return this.getSpy();
  };

  SpyStrategy.prototype.isConfigured = function() {
    return this.plan !== this._defaultPlan;
  };

  return SpyStrategy;
};

getJasmineRequireObj().StackTrace = function(j$) {
  function StackTrace(error) {
    var lines = error.stack.split('\n').filter(function(line) {
      return line !== '';
    });

    var extractResult = extractMessage(error.message, lines);

    if (extractResult) {
      this.message = extractResult.message;
      lines = extractResult.remainder;
    }

    var parseResult = tryParseFrames(lines);
    this.frames = parseResult.frames;
    this.style = parseResult.style;
  }

  var framePatterns = [
    // Node, Chrome, Edge
    // e.g. "   at QueueRunner.run (http://localhost:8888/__jasmine__/jasmine.js:4320:20)"
    // Note that the "function name" can include a surprisingly large set of
    // characters, including angle brackets and square brackets.
    {
      re: /^\s*at ([^\)]+) \(([^\)]+)\)$/,
      fnIx: 1,
      fileLineColIx: 2,
      style: 'v8'
    },

    // NodeJS alternate form, often mixed in with the Chrome style
    // e.g. "  at /some/path:4320:20
    { re: /\s*at (.+)$/, fileLineColIx: 1, style: 'v8' },

    // PhantomJS on OS X, Safari, Firefox
    // e.g. "run@http://localhost:8888/__jasmine__/jasmine.js:4320:27"
    // or "http://localhost:8888/__jasmine__/jasmine.js:4320:27"
    {
      re: /^(?:(([^@\s]+)@)|@)?([^\s]+)$/,
      fnIx: 2,
      fileLineColIx: 3,
      style: 'webkit'
    }
  ];

  // regexes should capture the function name (if any) as group 1
  // and the file, line, and column as group 2.
  function tryParseFrames(lines) {
    var style = null;
    var frames = lines.map(function(line) {
      var convertedLine = first(framePatterns, function(pattern) {
        var overallMatch = line.match(pattern.re),
          fileLineColMatch;
        if (!overallMatch) {
          return null;
        }

        fileLineColMatch = overallMatch[pattern.fileLineColIx].match(
          /^(.*):(\d+):\d+$/
        );
        if (!fileLineColMatch) {
          return null;
        }

        style = style || pattern.style;
        return {
          raw: line,
          file: fileLineColMatch[1],
          line: parseInt(fileLineColMatch[2], 10),
          func: overallMatch[pattern.fnIx]
        };
      });

      return convertedLine || { raw: line };
    });

    return {
      style: style,
      frames: frames
    };
  }

  function first(items, fn) {
    var i, result;

    for (i = 0; i < items.length; i++) {
      result = fn(items[i]);

      if (result) {
        return result;
      }
    }
  }

  function extractMessage(message, stackLines) {
    var len = messagePrefixLength(message, stackLines);

    if (len > 0) {
      return {
        message: stackLines.slice(0, len).join('\n'),
        remainder: stackLines.slice(len)
      };
    }
  }

  function messagePrefixLength(message, stackLines) {
    if (!stackLines[0].match(/^\w*Error/)) {
      return 0;
    }

    var messageLines = message.split('\n');
    var i;

    for (i = 1; i < messageLines.length; i++) {
      if (messageLines[i] !== stackLines[i]) {
        return 0;
      }
    }

    return messageLines.length;
  }

  return StackTrace;
};

getJasmineRequireObj().Suite = function(j$) {
  /**
   * @interface Suite
   * @see Env#topSuite
   * @since 2.0.0
   */
  function Suite(attrs) {
    this.env = attrs.env;
    /**
     * The unique ID of this suite.
     * @name Suite#id
     * @readonly
     * @type {string}
     * @since 2.0.0
     */
    this.id = attrs.id;
    this.parentSuite = attrs.parentSuite;
    /**
     * The description passed to the {@link describe} that created this suite.
     * @name Suite#description
     * @readonly
     * @type {string}
     * @since 2.0.0
     */
    this.description = attrs.description;
    this.expectationFactory = attrs.expectationFactory;
    this.asyncExpectationFactory = attrs.asyncExpectationFactory;
    this.expectationResultFactory = attrs.expectationResultFactory;
    this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;
    this.autoCleanClosures =
      attrs.autoCleanClosures === undefined ? true : !!attrs.autoCleanClosures;
    this.onLateError = attrs.onLateError;

    this.beforeFns = [];
    this.afterFns = [];
    this.beforeAllFns = [];
    this.afterAllFns = [];
    this.timer = attrs.timer || new j$.Timer();

    /**
     * The suite's children.
     * @name Suite#children
     * @type {Array.<(Spec|Suite)>}
     * @since 2.0.0
     */
    this.children = [];

    this.reset();
  }

  Suite.prototype.setSuiteProperty = function(key, value) {
    this.result.properties = this.result.properties || {};
    this.result.properties[key] = value;
  };

  Suite.prototype.expect = function(actual) {
    return this.expectationFactory(actual, this);
  };

  Suite.prototype.expectAsync = function(actual) {
    return this.asyncExpectationFactory(actual, this);
  };

  /**
   * The full description including all ancestors of this suite.
   * @name Suite#getFullName
   * @function
   * @returns {string}
   * @since 2.0.0
   */
  Suite.prototype.getFullName = function() {
    var fullName = [];
    for (
      var parentSuite = this;
      parentSuite;
      parentSuite = parentSuite.parentSuite
    ) {
      if (parentSuite.parentSuite) {
        fullName.unshift(parentSuite.description);
      }
    }
    return fullName.join(' ');
  };

  /*
   * Mark the suite with "pending" status
   */
  Suite.prototype.pend = function() {
    this.markedPending = true;
  };

  /*
   * Like {@link Suite#pend}, but pending state will survive {@link Spec#reset}
   * Useful for fdescribe, xdescribe, where pending state should remain.
   */
  Suite.prototype.exclude = function() {
    this.pend();
    this.markedExcluding = true;
  };

  Suite.prototype.beforeEach = function(fn) {
    this.beforeFns.unshift({ ...fn, suite: this });
  };

  Suite.prototype.beforeAll = function(fn) {
    this.beforeAllFns.push({ ...fn, type: 'beforeAll', suite: this });
  };

  Suite.prototype.afterEach = function(fn) {
    this.afterFns.unshift({ ...fn, suite: this, type: 'afterEach' });
  };

  Suite.prototype.afterAll = function(fn) {
    this.afterAllFns.unshift({ ...fn, type: 'afterAll' });
  };

  Suite.prototype.startTimer = function() {
    this.timer.start();
  };

  Suite.prototype.endTimer = function() {
    this.result.duration = this.timer.elapsed();
  };

  function removeFns(queueableFns) {
    for (var i = 0; i < queueableFns.length; i++) {
      queueableFns[i].fn = null;
    }
  }

  Suite.prototype.cleanupBeforeAfter = function() {
    if (this.autoCleanClosures) {
      removeFns(this.beforeAllFns);
      removeFns(this.afterAllFns);
      removeFns(this.beforeFns);
      removeFns(this.afterFns);
    }
  };

  Suite.prototype.reset = function() {
    /**
     * @typedef SuiteResult
     * @property {Int} id - The unique id of this suite.
     * @property {String} description - The description text passed to the {@link describe} that made this suite.
     * @property {String} fullName - The full description including all ancestors of this suite.
     * @property {Expectation[]} failedExpectations - The list of expectations that failed in an {@link afterAll} for this suite.
     * @property {Expectation[]} deprecationWarnings - The list of deprecation warnings that occurred on this suite.
     * @property {String} status - Once the suite has completed, this string represents the pass/fail status of this suite.
     * @property {number} duration - The time in ms for Suite execution, including any before/afterAll, before/afterEach.
     * @property {Object} properties - User-supplied properties, if any, that were set using {@link Env#setSuiteProperty}
     * @since 2.0.0
     */
    this.result = {
      id: this.id,
      description: this.description,
      fullName: this.getFullName(),
      failedExpectations: [],
      deprecationWarnings: [],
      duration: null,
      properties: null
    };
    this.markedPending = this.markedExcluding;
    this.children.forEach(function(child) {
      child.reset();
    });
  };

  Suite.prototype.addChild = function(child) {
    this.children.push(child);
  };

  Suite.prototype.status = function() {
    if (this.markedPending) {
      return 'pending';
    }

    if (this.result.failedExpectations.length > 0) {
      return 'failed';
    } else {
      return 'passed';
    }
  };

  Suite.prototype.canBeReentered = function() {
    return this.beforeAllFns.length === 0 && this.afterAllFns.length === 0;
  };

  Suite.prototype.getResult = function() {
    this.result.status = this.status();
    return this.result;
  };

  Suite.prototype.sharedUserContext = function() {
    if (!this.sharedContext) {
      this.sharedContext = this.parentSuite
        ? this.parentSuite.clonedSharedUserContext()
        : new j$.UserContext();
    }

    return this.sharedContext;
  };

  Suite.prototype.clonedSharedUserContext = function() {
    return j$.UserContext.fromExisting(this.sharedUserContext());
  };

  Suite.prototype.onException = function() {
    if (arguments[0] instanceof j$.errors.ExpectationFailed) {
      return;
    }

    var data = {
      matcherName: '',
      passed: false,
      expected: '',
      actual: '',
      error: arguments[0]
    };
    var failedExpectation = this.expectationResultFactory(data);

    if (!this.parentSuite) {
      failedExpectation.globalErrorType = 'afterAll';
    }

    this.result.failedExpectations.push(failedExpectation);
  };

  Suite.prototype.onMultipleDone = function() {
    let msg;

    // Issue a deprecation. Include the context ourselves and pass
    // ignoreRunnable: true, since getting here always means that we've already
    // moved on and the current runnable isn't the one that caused the problem.
    if (this.parentSuite) {
      msg =
        "An asynchronous beforeAll or afterAll function called its 'done' " +
        'callback more than once.\n' +
        '(in suite: ' +
        this.getFullName() +
        ')';
    } else {
      msg =
        'A top-level beforeAll or afterAll function called its ' +
        "'done' callback more than once.";
    }

    this.onLateError(new Error(msg));
  };

  Suite.prototype.addExpectationResult = function() {
    if (isFailure(arguments)) {
      var data = arguments[1];
      this.result.failedExpectations.push(this.expectationResultFactory(data));
      if (this.throwOnExpectationFailure) {
        throw new j$.errors.ExpectationFailed();
      }
    }
  };

  Suite.prototype.addDeprecationWarning = function(deprecation) {
    if (typeof deprecation === 'string') {
      deprecation = { message: deprecation };
    }
    this.result.deprecationWarnings.push(
      this.expectationResultFactory(deprecation)
    );
  };

  Object.defineProperty(Suite.prototype, 'metadata', {
    get: function() {
      if (!this.metadata_) {
        this.metadata_ = new SuiteMetadata(this);
      }

      return this.metadata_;
    }
  });

  /**
   * @interface Suite
   * @see Env#topSuite
   */
  function SuiteMetadata(suite) {
    this.suite_ = suite;
    /**
     * The unique ID of this suite.
     * @name Suite#id
     * @readonly
     * @type {string}
     */
    this.id = suite.id;

    /**
     * The parent of this suite, or null if this is the top suite.
     * @name Suite#parentSuite
     * @readonly
     * @type {Suite}
     */
    this.parentSuite = suite.parentSuite ? suite.parentSuite.metadata : null;

    /**
     * The description passed to the {@link describe} that created this suite.
     * @name Suite#description
     * @readonly
     * @type {string}
     */
    this.description = suite.description;
  }

  /**
   * The full description including all ancestors of this suite.
   * @name Suite#getFullName
   * @function
   * @returns {string}
   */
  SuiteMetadata.prototype.getFullName = function() {
    return this.suite_.getFullName();
  };

  /**
   * The suite's children.
   * @name Suite#children
   * @type {Array.<(Spec|Suite)>}
   */
  Object.defineProperty(SuiteMetadata.prototype, 'children', {
    get: function() {
      return this.suite_.children.map(child => child.metadata);
    }
  });

  function isFailure(args) {
    return !args[0];
  }

  return Suite;
};

getJasmineRequireObj().Timer = function() {
  var defaultNow = (function(Date) {
    return function() {
      return new Date().getTime();
    };
  })(Date);

  function Timer(options) {
    options = options || {};

    var now = options.now || defaultNow,
      startTime;

    this.start = function() {
      startTime = now();
    };

    this.elapsed = function() {
      return now() - startTime;
    };
  }

  return Timer;
};

getJasmineRequireObj().TreeProcessor = function() {
  function TreeProcessor(attrs) {
    var tree = attrs.tree,
      runnableIds = attrs.runnableIds,
      queueRunnerFactory = attrs.queueRunnerFactory,
      nodeStart = attrs.nodeStart || function() {},
      nodeComplete = attrs.nodeComplete || function() {},
      failSpecWithNoExpectations = !!attrs.failSpecWithNoExpectations,
      orderChildren =
        attrs.orderChildren ||
        function(node) {
          return node.children;
        },
      excludeNode =
        attrs.excludeNode ||
        function(node) {
          return false;
        },
      stats = { valid: true },
      processed = false,
      defaultMin = Infinity,
      defaultMax = 1 - Infinity;

    this.processTree = function() {
      processNode(tree, true);
      processed = true;
      return stats;
    };

    this.execute = function(done) {
      if (!processed) {
        this.processTree();
      }

      if (!stats.valid) {
        throw 'invalid order';
      }

      var childFns = wrapChildren(tree, 0);

      queueRunnerFactory({
        queueableFns: childFns,
        userContext: tree.sharedUserContext(),
        onException: function() {
          tree.onException.apply(tree, arguments);
        },
        onComplete: done,
        onMultipleDone: tree.onMultipleDone
          ? tree.onMultipleDone.bind(tree)
          : null
      });
    };

    function runnableIndex(id) {
      for (var i = 0; i < runnableIds.length; i++) {
        if (runnableIds[i] === id) {
          return i;
        }
      }
    }

    function processNode(node, parentExcluded) {
      var executableIndex = runnableIndex(node.id);

      if (executableIndex !== undefined) {
        parentExcluded = false;
      }

      if (!node.children) {
        var excluded = parentExcluded || excludeNode(node);
        stats[node.id] = {
          excluded: excluded,
          willExecute: !excluded && !node.markedPending,
          segments: [
            {
              index: 0,
              owner: node,
              nodes: [node],
              min: startingMin(executableIndex),
              max: startingMax(executableIndex)
            }
          ]
        };
      } else {
        var hasExecutableChild = false;

        var orderedChildren = orderChildren(node);

        for (var i = 0; i < orderedChildren.length; i++) {
          var child = orderedChildren[i];

          processNode(child, parentExcluded);

          if (!stats.valid) {
            return;
          }

          var childStats = stats[child.id];

          hasExecutableChild = hasExecutableChild || childStats.willExecute;
        }

        stats[node.id] = {
          excluded: parentExcluded,
          willExecute: hasExecutableChild
        };

        segmentChildren(node, orderedChildren, stats[node.id], executableIndex);

        if (!node.canBeReentered() && stats[node.id].segments.length > 1) {
          stats = { valid: false };
        }
      }
    }

    function startingMin(executableIndex) {
      return executableIndex === undefined ? defaultMin : executableIndex;
    }

    function startingMax(executableIndex) {
      return executableIndex === undefined ? defaultMax : executableIndex;
    }

    function segmentChildren(
      node,
      orderedChildren,
      nodeStats,
      executableIndex
    ) {
      var currentSegment = {
          index: 0,
          owner: node,
          nodes: [],
          min: startingMin(executableIndex),
          max: startingMax(executableIndex)
        },
        result = [currentSegment],
        lastMax = defaultMax,
        orderedChildSegments = orderChildSegments(orderedChildren);

      function isSegmentBoundary(minIndex) {
        return (
          lastMax !== defaultMax &&
          minIndex !== defaultMin &&
          lastMax < minIndex - 1
        );
      }

      for (var i = 0; i < orderedChildSegments.length; i++) {
        var childSegment = orderedChildSegments[i],
          maxIndex = childSegment.max,
          minIndex = childSegment.min;

        if (isSegmentBoundary(minIndex)) {
          currentSegment = {
            index: result.length,
            owner: node,
            nodes: [],
            min: defaultMin,
            max: defaultMax
          };
          result.push(currentSegment);
        }

        currentSegment.nodes.push(childSegment);
        currentSegment.min = Math.min(currentSegment.min, minIndex);
        currentSegment.max = Math.max(currentSegment.max, maxIndex);
        lastMax = maxIndex;
      }

      nodeStats.segments = result;
    }

    function orderChildSegments(children) {
      var specifiedOrder = [],
        unspecifiedOrder = [];

      for (var i = 0; i < children.length; i++) {
        var child = children[i],
          segments = stats[child.id].segments;

        for (var j = 0; j < segments.length; j++) {
          var seg = segments[j];

          if (seg.min === defaultMin) {
            unspecifiedOrder.push(seg);
          } else {
            specifiedOrder.push(seg);
          }
        }
      }

      specifiedOrder.sort(function(a, b) {
        return a.min - b.min;
      });

      return specifiedOrder.concat(unspecifiedOrder);
    }

    function executeNode(node, segmentNumber) {
      if (node.children) {
        return {
          fn: function(done) {
            var onStart = {
              fn: function(next) {
                nodeStart(node, next);
              }
            };

            queueRunnerFactory({
              onComplete: function() {
                var args = Array.prototype.slice.call(arguments, [0]);
                node.cleanupBeforeAfter();
                nodeComplete(node, node.getResult(), function() {
                  done.apply(undefined, args);
                });
              },
              queueableFns: [onStart].concat(wrapChildren(node, segmentNumber)),
              userContext: node.sharedUserContext(),
              onException: function() {
                node.onException.apply(node, arguments);
              },
              onMultipleDone: node.onMultipleDone
                ? node.onMultipleDone.bind(node)
                : null
            });
          }
        };
      } else {
        return {
          fn: function(done) {
            node.execute(
              done,
              stats[node.id].excluded,
              failSpecWithNoExpectations
            );
          }
        };
      }
    }

    function wrapChildren(node, segmentNumber) {
      var result = [],
        segmentChildren = stats[node.id].segments[segmentNumber].nodes;

      for (var i = 0; i < segmentChildren.length; i++) {
        result.push(
          executeNode(segmentChildren[i].owner, segmentChildren[i].index)
        );
      }

      if (!stats[node.id].willExecute) {
        return result;
      }

      return node.beforeAllFns.concat(result).concat(node.afterAllFns);
    }
  }

  return TreeProcessor;
};

getJasmineRequireObj().UserContext = function(j$) {
  function UserContext() {}

  UserContext.fromExisting = function(oldContext) {
    var context = new UserContext();

    for (var prop in oldContext) {
      if (oldContext.hasOwnProperty(prop)) {
        context[prop] = oldContext[prop];
      }
    }

    return context;
  };

  return UserContext;
};

getJasmineRequireObj().version = function() {
  return '4.0.1';
};


/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/compute-voxels.wgsl":
/*!***********************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/compute-voxels.wgsl ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("struct Permutations {\n  Perm : array<i32, 512>,\n};\n\n@binding(0) @group(0)\nvar<storage, read> perm : Permutations;\n\nstruct CornerMaterials {\n  cornerMaterials : array<u32>,\n};\n\n@binding(1) @group(0)\nvar<storage, read_write> cornerMaterials: CornerMaterials;\n\nstruct VoxelMaterials {\n  voxelMaterials : array<u32>,\n};\n\n@binding(2) @group(0)\nvar<storage, read_write> voxelMaterials: VoxelMaterials;\n\nstruct CornerIndex {\n  cornerCount : u32,\n  cornerIndexes : array<u32>\n};\n\n@binding(3) @group(0)\nvar<storage, read_write> cornerIndex: CornerIndex;\n\nstruct GPUVOX\n{\n\tvoxMin: vec3<f32>,\n\tcorners: f32,\n\tvertPoint: vec3<f32>,\n\tavgNormal: vec3<f32>,\n\tnumPoints: f32\n};\nstruct GPUVOXS {\n  voxels : array<GPUVOX>,\n};\n\n@binding(4) @group(0)\nvar<storage, read_write> voxels: GPUVOXS;\n\nstruct UniformBufferObject {\n  chunkPosition : vec3<f32>,\n  stride : f32,\n\twidth: u32\n};\n\n@binding(5) @group(0)\nvar<uniform> uniforms : UniformBufferObject;\n\nlet CHILD_MIN_OFFSETS: array<vec3<u32>, 8> = array<vec3<u32>, 8>\n(\n  vec3<u32>(0u, 0u, 0u),\n  vec3<u32>(0u, 0u, 1u),\n  vec3<u32>(0u, 1u, 0u),\n  vec3<u32>(0u, 1u, 1u),\n  vec3<u32>(1u, 0u, 0u),\n  vec3<u32>(1u, 0u, 1u),\n  vec3<u32>(1u, 1u, 0u),\n  vec3<u32>(1u, 1u, 1u)\n);\n\nlet edgevmap: array<vec2<i32>, 12> = array<vec2<i32>, 12>\n(\n\tvec2<i32>(0,4), vec2<i32>(1,5), vec2<i32>(2,6), vec2<i32>(3,7),\n\tvec2<i32>(0,2), vec2<i32>(1,3), vec2<i32>(4,6), vec2<i32>(5,7),\n\tvec2<i32>(0,1), vec2<i32>(2,3), vec2<i32>(4,5), vec2<i32>(6,7)\n);\n\nfn random(i: vec2<f32>) -> f32 {\n  return fract(sin(dot(i,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nfn Vec3Dot(a: vec3<f32>, b: vec3<f32>) -> f32\n{\n\treturn (a.x * b.x) + (a.y * b.y) + (a.z * b.z);\n}\n\nlet Grad3: array<vec3<f32>, 12> = array<vec3<f32>, 12>(\n\tvec3<f32>(1.0,1.0,0.0), vec3<f32>(-1.0,1.0,0.0), vec3<f32>(1.0,-1.0,0.0), vec3<f32>(-1.0,-1.0,0.0),\n\tvec3<f32>(1.0,0.0,1.0), vec3<f32>(-1.0,0.0,1.0), vec3<f32>(1.0,0.0,-1.0), vec3<f32>(-1.0,0.0,-1.0),\n\tvec3<f32>(0.0,1.0,1.0), vec3<f32>(0.0,-1.0,1.0), vec3<f32>(0.0,1.0,-1.0), vec3<f32>(0.0,-1.0,-1.0)\n);\n\nfn Perlin(x1: f32, y1: f32, z1: f32) -> f32\n{\n\tvar X: i32 = 0;\n\tif (x1 > 0.0) {\n\t\tX = i32(x1);\n\t} else {\n\t\tX = i32(x1) - 1;\n\t}\n\n\tvar Y: i32 = 0;\n\tif (y1 > 0.0) {\n\t\tY = i32(y1);\n\t} else {\n\t\tY = i32(y1) - 1;\n\t}\n\n\tvar Z: i32 = 0;\n\tif (z1 > 0.0) {\n\t\tZ = i32(z1);\n\t} else {\n\t\tZ = i32(z1) - 1;\n\t}\n\t\n\tlet x: f32 = x1 - f32(X);\n\tlet y: f32 = y1 - f32(Y);\n\tlet z: f32 = z1 - f32(Z);\n\t\n\tX = X & 255;\n\tY = Y & 255;\n\tZ = Z & 255;\n\t\n\tlet gi000: i32 = (perm.Perm[X + perm.Perm[Y + perm.Perm[Z] ] ] % 12);\n\tlet gi001: i32 = (perm.Perm[X + perm.Perm[Y + perm.Perm[Z + 1] ] ] % 12);\n\tlet gi010: i32 = (perm.Perm[X + perm.Perm[Y + 1 + perm.Perm[Z] ] ] % 12);\n\tlet gi011: i32 = (perm.Perm[X + perm.Perm[Y + 1 + perm.Perm[Z + 1] ] ] % 12);\n\tlet gi100: i32 = (perm.Perm[X + 1 + perm.Perm[Y + perm.Perm[Z] ] ] % 12);\n\tlet gi101: i32 = (perm.Perm[X + 1 + perm.Perm[Y + perm.Perm[Z + 1] ] ] % 12);\n\tlet gi110: i32 = (perm.Perm[X + 1 + perm.Perm[Y + 1 + perm.Perm[Z] ] ] % 12);\n\tlet gi111: i32 = (perm.Perm[X + 1 + perm.Perm[Y + 1 + perm.Perm[Z + 1] ] ] % 12);\n\n\tlet n000: f32 = dot(Grad3[gi000], vec3<f32>(x, y, z));\n\tlet n100: f32 = dot(Grad3[gi100], vec3<f32>(x - 1.0, y, z));\n\tlet n010: f32 = dot(Grad3[gi010], vec3<f32>(x, y - 1.0, z));\n\tlet n110: f32 = dot(Grad3[gi110], vec3<f32>(x - 1.0, y - 1.0, z));\n\tlet n001: f32 = dot(Grad3[gi001], vec3<f32>(x, y, z - 1.0));\n\tlet n101: f32 = dot(Grad3[gi101], vec3<f32>(x - 1.0, y, z - 1.0));\n\tlet n011: f32 = dot(Grad3[gi011], vec3<f32>(x, y - 1.0, z - 1.0));\n\tlet n111: f32 = dot(Grad3[gi111], vec3<f32>(x - 1.0, y - 1.0, z - 1.0));\n\t\n\tlet u: f32 = f32(x * x * x * (x * (x * 6.0 - 15.0) + 10.0));\n\tlet v: f32 = f32(y * y * y * (y * (y * 6.0 - 15.0) + 10.0));\n\tlet w: f32 = f32(z * z * z * (z * (z * 6.0 - 15.0) + 10.0));\n\tlet nx00: f32 = mix(n000, n100, u);\n\tlet nx01: f32 = mix(n001, n101, u);\n\tlet nx10: f32 = mix(n010, n110, u);\n\tlet nx11: f32 = mix(n011, n111, u);\n\tlet nxy0: f32 = mix(nx00, nx10, v);\n\tlet nxy1: f32 = mix(nx01, nx11, v);\n\tlet nxyz: f32 = mix(nxy0, nxy1, w);\n\t\n\treturn nxyz;\n}\n\nfn FractalNoise(octaves: i32, frequency: f32, lacunarity: f32, persistence: f32, position: vec3<f32>) -> f32\n{\n\tlet SCALE: f32 = 1.0 / 128.0;\n\tvar p: vec3<f32> = position * SCALE;\n\tvar nois: f32 = 0.0;\n\n\tvar amplitude: f32 = 1.0;\n\tp = p * frequency;\n\n\tvar i: i32 = 0;\n\tloop {\n\t\tif (i >= octaves) { break; }\n\n\t\tnois = nois + Perlin(p.x, p.y, p.z) * amplitude;\n\t\tp = p * lacunarity;\n\t\tamplitude = amplitude * persistence;\n\n\t\tcontinuing {\n\t\t\ti = i + 1;\n\t\t}\n\t}\n\t\n\treturn nois;\n}\n\nfn FractalNoise1(frequency: f32, lacunarity: f32, persistence: f32, position: vec3<f32>) -> f32\n{\n\tlet SCALE: f32 = 1.0 / 128.0;\n\tvar p: vec3<f32> = position * SCALE;\n\tvar nois: f32 = 0.0;\n\n\tvar amplitude: f32 = 1.0;\n\tp = p * frequency;\n\t\n\tnois = nois + Perlin(p.x, p.y, p.z) * amplitude;\n\tp = p * lacunarity;\n\tamplitude = amplitude * persistence;\n\t\n\treturn nois;\n}\n\nfn CalculateNoiseValue(pos: vec3<f32>, scale: f32) -> f32\n{\n\treturn FractalNoise(4, 0.5343, 2.2324, 0.68324, pos * scale);\n}\n\nfn CLerp(a: f32, b: f32, t: f32) -> f32\n{\n\treturn (1.0 - t) * a + t * b;\n}\n\n// SVD\n\nlet SVD_NUM_SWEEPS: i32 = 4;\nlet PSUEDO_INVERSE_THRESHOLD: f32 = 0.00000001;\n\nfn svd_mul_matrix_vec(m: mat3x3<f32>, b: vec4<f32>) -> vec4<f32>\n{\n\tvar a: mat3x3<f32> = m;\n\t\n\treturn vec4<f32>(\n\t\tdot(vec4<f32>(a[0][0], a[0][1], a[0][2], 0.0), b),\n\t\tdot(vec4<f32>(a[1][0], a[1][1], a[1][2], 0.0), b),\n\t\tdot(vec4<f32>(a[2][0], a[2][1], a[2][2], 0.0), b),\n\t\t0.0\n\t);\n}\n\nfn givens_coeffs_sym(a_pp: f32, a_pq: f32, a_qq: f32) -> vec2<f32>\n{\n\tif (a_pq == 0.0) {\n\t\treturn vec2<f32>(1.0, 0.0);\n\t}\n\t\n\tlet tau: f32 = (a_qq - a_pp) / (2.0 * a_pq);\n\tlet stt: f32 = sqrt(1.0 + tau * tau);\n\tvar tan: f32;\n\tif ((tau >= 0.0)) {\n\t\ttan = (tau + stt);\n\t} else {\n\t\ttan = (tau - stt);\n\t}\n\ttan = 1.0 / tan;\n\n\tlet c: f32 = inverseSqrt(1.0 + tan * tan);\n\tlet s: f32 = tan * c;\n\n\treturn vec2<f32>(c, s);\n}\n\nfn svd_rotate_xy(x: f32, y: f32, c: f32, s: f32) -> vec2<f32>\n{\n\treturn vec2<f32>(c * x - s * y, s * x + c * y);\n}\n\nfn svd_rotateq_xy(x: f32, y: f32, z: f32, c: f32, s: f32) -> vec2<f32>\n{\n\tlet cc: f32 = c * c;\n\tlet ss: f32 = s * s;\n\tlet mx: f32 = 2.0 * c * s * z;\n\n\treturn vec2<f32>(\n\t\tcc * x - mx + ss * y,\n\t\tss * x + mx + cc * z\n\t);\n}\n\nvar<private> vtav: mat3x3<f32>;\nvar<private> v: mat3x3<f32>;\nvar<private> ATA: array<f32, 6>;\nvar<private> Atb: vec4<f32>;\nvar<private> pointaccum: vec4<f32>;\nvar<private> btb: f32;\n\nfn svd_rotate(a: i32, b: i32)\n{\n\tif (vtav[a][b] == 0.0) { return; }\n\n\n\t\n\tlet coeffs: vec2<f32> = givens_coeffs_sym(vtav[a][a], vtav[a][b], vtav[b][b]);\n\tlet c: f32 = coeffs.x;\n\tlet s: f32 = coeffs.y;\n\t\n\tlet rot1: vec2<f32> = svd_rotateq_xy(vtav[a][a], vtav[b][b], vtav[a][b], c, s);\n\tvtav[a][a] = rot1.x;\n\tvtav[b][b] = rot1.y;\n\t\n\tlet rot2: vec2<f32> = svd_rotate_xy(vtav[0][3-b], vtav[1-a][2], c, s);\n\tvtav[0][3-b] = rot2.x; \n\tvtav[1-a][2] = rot2.y;\n\t\n\tvtav[a][b] = 0.0;\n\t\n\tlet rot3: vec2<f32> = svd_rotate_xy(v[0][a], v[0][b], c, s);\n\tv[0][a] = rot3.x; v[0][b] = rot3.y;\n\t\n\tlet rot4: vec2<f32> = svd_rotate_xy(v[1][a], v[1][b], c, s);\n\tv[1][a] = rot4.x; v[1][b] = rot4.y;\n\t\n\tlet rot5: vec2<f32> = svd_rotate_xy(v[2][a], v[2][b], c, s);\n\tv[2][a] = rot5.x; v[2][b] = rot5.y;\n}\n\nfn svd_solve_sym(b: array<f32, 6>) -> vec4<f32>\n{\n\tvar a: array<f32, 6> = b;\n\t\n\tvtav = mat3x3<f32>( \n\t\tvec3<f32>(a[0], a[1], a[2]), \n\t\tvec3<f32>(0.0, a[3], a[4]), \n\t\tvec3<f32>(0.0, 0.0, a[5])\n\t);\n\n\tvar i: i32;\n\tloop {\n\t\tif (i >= SVD_NUM_SWEEPS) { break; }\n\n\t\tsvd_rotate(0, 1);\n\t\tsvd_rotate(0, 2);\n\t\tsvd_rotate(1, 2);\n\n\t\tcontinuing {\n\t\t\ti = i + 1;\n\t\t}\n\t}\n\n\tvar copy: mat3x3<f32> = vtav;\n\treturn vec4<f32>(copy[0][0], copy[1][1], copy[2][2], 0.0);\n}\n\n\nfn svd_invdet(x: f32, tol: f32) -> f32\n{\n\tif (abs(x) < tol || abs(1.0 / x) < tol) {\n\t\treturn 0.0;\n\t}\n\treturn (1.0 / x);\n}\n\nfn svd_pseudoinverse(sigma: vec4<f32>, c: mat3x3<f32>) -> mat3x3<f32>\n{\n\tlet d0: f32 = svd_invdet(sigma.x, PSUEDO_INVERSE_THRESHOLD);\n\tlet d1: f32 = svd_invdet(sigma.y, PSUEDO_INVERSE_THRESHOLD);\n\tlet d2: f32 = svd_invdet(sigma.z, PSUEDO_INVERSE_THRESHOLD);\n\n\tvar copy: mat3x3<f32> = c;\n\n\treturn mat3x3<f32> (\n\t\tvec3<f32>(\n\t\t\tcopy[0][0] * d0 * copy[0][0] + copy[0][1] * d1 * copy[0][1] + copy[0][2] * d2 * copy[0][2],\n\t\t\tcopy[0][0] * d0 * copy[1][0] + copy[0][1] * d1 * copy[1][1] + copy[0][2] * d2 * copy[1][2],\n\t\t\tcopy[0][0] * d0 * copy[2][0] + copy[0][1] * d1 * copy[2][1] + copy[0][2] * d2 * copy[2][2]\n\t\t),\n\t\tvec3<f32>(\n\t\t\tcopy[1][0] * d0 * copy[0][0] + copy[1][1] * d1 * copy[0][1] + copy[1][2] * d2 * copy[0][2],\n\t\t\tcopy[1][0] * d0 * copy[1][0] + copy[1][1] * d1 * copy[1][1] + copy[1][2] * d2 * copy[1][2],\n\t\t\tcopy[1][0] * d0 * copy[2][0] + copy[1][1] * d1 * copy[2][1] + copy[1][2] * d2 * copy[2][2]\n\t\t),\n\t\tvec3<f32>(\n\t\t\tcopy[2][0] * d0 * copy[0][0] + copy[2][1] * d1 * copy[0][1] + copy[2][2] * d2 * copy[0][2],\n\t\t\tcopy[2][0] * d0 * copy[1][0] + copy[2][1] * d1 * copy[1][1] + copy[2][2] * d2 * copy[1][2],\n\t\t\tcopy[2][0] * d0 * copy[2][0] + copy[2][1] * d1 * copy[2][1] + copy[2][2] * d2 * copy[2][2]\n\t\t),\n\t);\n}\n\nfn svd_solve_ATA_Atb(a: vec4<f32>) -> vec4<f32>\n{\n\tv = mat3x3<f32>(vec3<f32>(1.0, 0.0, 0.0), vec3<f32>(0.0, 1.0, 0.0), vec3<f32>(0.0, 0.0, 1.0));\n\t\n\tlet sigma: vec4<f32> = svd_solve_sym(ATA);\n\t\n\tlet Vinv: mat3x3<f32> = svd_pseudoinverse(sigma, v);\n\treturn svd_mul_matrix_vec(Vinv, a);\n}\n\nfn svd_vmul_sym(v: vec4<f32>) -> vec4<f32>\n{\n\tlet A_row_x: vec4<f32> = vec4<f32>(ATA[0], ATA[1], ATA[2], 0.0);\n\treturn vec4<f32> (\n\t\tdot(A_row_x, v),\n\t\tATA[1] * v.x + ATA[3] * v.y + ATA[4] * v.z,\n\t\tATA[2] * v.x + ATA[4] * v.y + ATA[5] * v.z,\n\t\t0.0\n\t);\n}\n\n\n// // QEF\n\nfn qef_add(n: vec4<f32>, p: vec4<f32>)\n{\n\tATA[0] = ATA[0] + n.x * n.x;\n\tATA[1] = ATA[1] + n.x * n.y;\n\tATA[2] = ATA[2] + n.x * n.z;\n\tATA[3] = ATA[3] + n.y * n.y;\n\tATA[4] = ATA[4] + n.y * n.z;\n\tATA[5] = ATA[5] + n.z * n.z;\n\t\n\tlet b: f32 = dot(p, n);\n\tAtb.x = Atb.x +n.x * b;\n\tAtb.y = Atb.y +n.y * b;\n\tAtb.z = Atb.z +n.z * b;\n\tbtb = btb + b * b;\n\t\n\tpointaccum.x = pointaccum.x +p.x;\n\tpointaccum.y = pointaccum.y +p.y;\n\tpointaccum.z = pointaccum.z +p.z;\n\tpointaccum.w = pointaccum.w +1.0;\n}\n\nfn qef_calc_error(x: vec4<f32>) -> f32\n{\n\tvar tmp: vec4<f32> = svd_vmul_sym(x);\n\ttmp = Atb - tmp;\n\t\n\treturn dot(tmp, tmp);\n}\n\nfn qef_solve() -> vec4<f32>\n{\n\tlet masspoint: vec4<f32> = vec4<f32>(pointaccum.x / pointaccum.w, pointaccum.y / pointaccum.w, pointaccum.z / pointaccum.w, pointaccum.w / pointaccum.w);\n\t\n\tvar A_mp: vec4<f32> = svd_vmul_sym(masspoint);\n\tA_mp = Atb - A_mp;\n\t\n\tlet x: vec4<f32> = svd_solve_ATA_Atb(A_mp);\n\t\n\tlet error: f32 = qef_calc_error(x);\n\tlet r: vec4<f32> = x + masspoint;\n\t\n\treturn vec4<f32>(r.x, r.y, r.z, error);\n}\n\n#import density\n\nfn ApproximateZeroCrossingPosition(p0: vec3<f32>, p1: vec3<f32>) -> vec3<f32>\n{\n\tvar minValue: f32 = 100000.0;\n\tvar t: f32 = 0.0;\n\tvar currentT: f32 = 0.0;\n\tlet steps: f32 = 8.0;\n\tlet increment: f32 = 1.0 / steps;\n\tloop {\n\t\tif (currentT > 1.0) { break; }\n\n\t\tlet p: vec3<f32> = p0 + ((p1 - p0) * currentT);\n\t\tlet density: f32 = abs(getDensity(p));\n\t\tif (density < minValue)\n\t\t{\n\t\t\tminValue = density;\n\t\t\tt = currentT;\n\t\t}\n\n\t\tcontinuing {\n\t\t\tcurrentT = currentT + increment;\n\t\t}\n\t}\n\n\treturn p0 + ((p1 - p0) * t);\n}\n\nfn CalculateSurfaceNormal(p: vec3<f32>) -> vec3<f32>\n{\n\tlet H: f32 = uniforms.stride; // This needs to scale based on something...\n\tlet dx: f32 = getDensity(p + vec3<f32>(H, 0.0, 0.0)) - getDensity(p - vec3<f32>(H, 0.0, 0.0));\n\tlet dy: f32 = getDensity(p + vec3<f32>(0.0, H, 0.0)) - getDensity(p - vec3<f32>(0.0, H, 0.0));\n\tlet dz: f32 = getDensity(p + vec3<f32>(0.0, 0.0, H)) - getDensity(p - vec3<f32>(0.0, 0.0, H));\n\n\treturn normalize(vec3<f32>(dx, dy, dz));\n}\n\n@compute @workgroup_size(128)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n\tlet trueIndex: u32 = GlobalInvocationID.x;\n\n\tif (trueIndex < cornerIndex.cornerCount)\n\t{\n\t\tlet ures: u32 = 32u;\n\n\t\tlet nodeSize: u32 = u32(uniforms.stride);\n\n\t\tlet voxelIndex: u32 = cornerIndex.cornerIndexes[trueIndex];\n\t\tlet z: u32 = voxelIndex / (ures * ures);\n\t\tlet y: u32 = (voxelIndex - (z * ures * ures)) / ures;\n\t\tlet x: u32 = voxelIndex - (z * ures * ures) - (y * ures);\n\n\t\tlet corners: u32 = voxelMaterials.voxelMaterials[voxelIndex];\n\n\t\tlet nodePos: vec3<f32> = (vec3<f32>(f32(x), f32(y), f32 (z)) * uniforms.stride) + uniforms.chunkPosition;\n\t\tvoxels.voxels[trueIndex].voxMin = nodePos;\n\t\tlet MAX_CROSSINGS: i32 = 6;\n\t\tvar edgeCount: i32 = 0;\n\n\t\tpointaccum = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n\t\tATA = array<f32, 6>(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\n\t\tAtb = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n\t\tvar averageNormal: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);\n\t\tbtb = 0.0;\n\n\t\tvar j: i32 = 0;\n\t\tloop {\n\t\t\tif (!(j < 12 && edgeCount <= MAX_CROSSINGS)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlet c1: i32 = edgevmap[j].x;\n\t\t\tlet c2: i32 = edgevmap[j].y;\n\n\t\t\tlet m1: u32 = (corners >> u32(c1)) & 1u;\n\t\t\tlet m2: u32 = (corners >> u32(c2)) & 1u;\n\n\t\t\tif (!((m1 == 0u && m2 == 0u) || (m1 == 1u && m2 == 1u)))\n\t\t\t{\n\t\t\t\tlet p1: vec3<f32> = nodePos + vec3<f32>(f32(CHILD_MIN_OFFSETS[c1].x * nodeSize), f32(CHILD_MIN_OFFSETS[c1].y * nodeSize), f32(CHILD_MIN_OFFSETS[c1].z * nodeSize));\n\t\t\t\tlet p2: vec3<f32> = nodePos + vec3<f32>(f32(CHILD_MIN_OFFSETS[c2].x * nodeSize), f32(CHILD_MIN_OFFSETS[c2].y * nodeSize), f32(CHILD_MIN_OFFSETS[c2].z * nodeSize));\n\t\t\t\tlet p: vec3<f32> = ApproximateZeroCrossingPosition(p1, p2);\n\t\t\t\tlet n: vec3<f32> = CalculateSurfaceNormal(p);\n\n\t\t\t\tqef_add(vec4<f32>(n.x, n.y, n.z, 0.0), vec4<f32>(p.x, p.y, p.z, 0.0));\n\n\t\t\t\taverageNormal = averageNormal + n;\n\n\t\t\t\tedgeCount = edgeCount + 1;\n\t\t\t}\n\n\t\t\tcontinuing {\n\t\t\t\tj = j + 1;\n\t\t\t}\n\t\t}\n\n\n\t\taverageNormal = normalize(averageNormal / vec3<f32>(f32(edgeCount), f32(edgeCount), f32(edgeCount)));\n\n\t\tlet com: vec3<f32> = vec3<f32>(pointaccum.x / pointaccum.w, pointaccum.y / pointaccum.w, pointaccum.z / pointaccum.w);\n\n\t\tlet result: vec4<f32> = qef_solve();\n\t\tvar solved_position: vec3<f32> = result.xyz;\n\t\tlet error: f32 = result.w;\n\n\n\t\tlet Min: vec3<f32> = nodePos;\n\t\tlet Max: vec3<f32> = nodePos + vec3<f32>(1.0, 1.0, 1.0);\n\t\tif (solved_position.x < Min.x || solved_position.x > Max.x ||\n\t\t\t\tsolved_position.y < Min.y || solved_position.y > Max.y ||\n\t\t\t\tsolved_position.z < Min.z || solved_position.z > Max.z)\n\t\t{\n\t\t\tsolved_position = com;\n\t\t}\n\n\t\tvoxels.voxels[trueIndex].vertPoint = solved_position;\n\t\tvoxels.voxels[trueIndex].avgNormal = averageNormal;\n\t\tvoxels.voxels[trueIndex].numPoints = f32(edgeCount);\n\t\tvoxels.voxels[trueIndex].corners = f32(voxelMaterials.voxelMaterials[voxelIndex]);\n\t}\n}\n\n@compute @workgroup_size(1)\nfn computeMaterials(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n\t\tlet width = uniforms.width;\n    let index: u32 = GlobalInvocationID.z * width * width + GlobalInvocationID.y * width + GlobalInvocationID.x;\n    let cornerPos: vec3<f32> = vec3<f32>(f32(GlobalInvocationID.x) * uniforms.stride, f32(GlobalInvocationID.y) * uniforms.stride, f32(GlobalInvocationID.z) * uniforms.stride);\n\n    let density: f32 = getDensity(cornerPos + uniforms.chunkPosition);\n\n\t\tif (density < 0.0) {\n\t\t\tif (length(cornerPos + uniforms.chunkPosition) < 2000.0) {\n        //cornerMaterials.cornerMaterials[index] = u32(random(vec2(f32(index))) * 255.0) + 1;\n\t\t\t  cornerMaterials.cornerMaterials[index] = 256u;\n\t\t\t} else {\n        cornerMaterials.cornerMaterials[index] = u32(length(cornerPos) / uniforms.stride * 256.0);\n\t\t\t}\n\t\t} else {\n\t\t\tcornerMaterials.cornerMaterials[index] = 0u;\n\t\t}\n}");

/***/ }),

/***/ "./node_modules/seedrandom/index.js":
/*!******************************************!*\
  !*** ./node_modules/seedrandom/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

// alea, a 53-bit multiply-with-carry generator by Johannes Baagøe.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea = __webpack_require__(/*! ./lib/alea */ "./node_modules/seedrandom/lib/alea.js");

// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128 = __webpack_require__(/*! ./lib/xor128 */ "./node_modules/seedrandom/lib/xor128.js");

// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow = __webpack_require__(/*! ./lib/xorwow */ "./node_modules/seedrandom/lib/xorwow.js");

// xorshift7, by François Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7 = __webpack_require__(/*! ./lib/xorshift7 */ "./node_modules/seedrandom/lib/xorshift7.js");

// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096 = __webpack_require__(/*! ./lib/xor4096 */ "./node_modules/seedrandom/lib/xor4096.js");

// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei = __webpack_require__(/*! ./lib/tychei */ "./node_modules/seedrandom/lib/tychei.js");

// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr = __webpack_require__(/*! ./seedrandom */ "./node_modules/seedrandom/seedrandom.js");

sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;

module.exports = sr;


/***/ }),

/***/ "./node_modules/seedrandom/lib/alea.js":
/*!*********************************************!*\
  !*** ./node_modules/seedrandom/lib/alea.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -

// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



(function(global, module, define) {

function Alea(seed) {
  var me = this, mash = Mash();

  me.next = function() {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) { me.s0 += 1; }
  me.s1 -= mash(seed);
  if (me.s1 < 0) { me.s1 += 1; }
  me.s2 -= mash(seed);
  if (me.s2 < 0) { me.s2 += 1; }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function impl(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; }
  prng.double = function() {
    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
  };
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function(data) {
    data = String(data);
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}


if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.alea = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ }),

/***/ "./node_modules/seedrandom/lib/tychei.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/lib/tychei.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var b = me.b, c = me.c, d = me.d, a = me.a;
    b = (b << 25) ^ (b >>> 7) ^ c;
    c = (c - d) | 0;
    d = (d << 24) ^ (d >>> 8) ^ a;
    a = (a - b) | 0;
    me.b = b = (b << 20) ^ (b >>> 12) ^ c;
    me.c = c = (c - d) | 0;
    me.d = (d << 16) ^ (c >>> 16) ^ a;
    return me.a = (a - b) | 0;
  };

  /* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */

  me.a = 0;
  me.b = 0;
  me.c = 2654435769 | 0;
  me.d = 1367130551;

  if (seed === Math.floor(seed)) {
    // Integer seed.
    me.a = (seed / 0x100000000) | 0;
    me.b = seed | 0;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 20; k++) {
    me.b ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.a = f.a;
  t.b = f.b;
  t.c = f.c;
  t.d = f.d;
  return t;
};

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.tychei = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ }),

/***/ "./node_modules/seedrandom/lib/xor128.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/lib/xor128.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;

  // Set up generator function.
  me.next = function() {
    var t = me.x ^ (me.x << 11);
    me.x = me.y;
    me.y = me.z;
    me.z = me.w;
    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
  };

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xor128 = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ }),

/***/ "./node_modules/seedrandom/lib/xor4096.js":
/*!************************************************!*\
  !*** ./node_modules/seedrandom/lib/xor4096.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1004.3115v1.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    var w = me.w,
        X = me.X, i = me.i, t, v;
    // Update Weyl generator.
    me.w = w = (w + 0x61c88647) | 0;
    // Update xor generator.
    v = X[(i + 34) & 127];
    t = X[i = ((i + 1) & 127)];
    v ^= v << 13;
    t ^= t << 17;
    v ^= v >>> 15;
    t ^= t >>> 12;
    // Update Xor generator array state.
    v = X[i] = v ^ t;
    me.i = i;
    // Result is the combination.
    return (v + (w ^ (w >>> 16))) | 0;
  };

  function init(me, seed) {
    var t, v, i, j, w, X = [], limit = 128;
    if (seed === (seed | 0)) {
      // Numeric seeds initialize v, which is used to generates X.
      v = seed;
      seed = null;
    } else {
      // String seeds are mixed into v and X one character at a time.
      seed = seed + '\0';
      v = 0;
      limit = Math.max(limit, seed.length);
    }
    // Initialize circular array and weyl value.
    for (i = 0, j = -32; j < limit; ++j) {
      // Put the unicode characters into the array, and shuffle them.
      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
      // After 32 shuffles, take v as the starting w value.
      if (j === 0) w = v;
      v ^= v << 10;
      v ^= v >>> 15;
      v ^= v << 4;
      v ^= v >>> 13;
      if (j >= 0) {
        w = (w + 0x61c88647) | 0;     // Weyl.
        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
        i = (0 == t) ? i + 1 : 0;     // Count zeroes.
      }
    }
    // We have detected all zeroes; make the key nonzero.
    if (i >= 128) {
      X[(seed && seed.length || 0) & 127] = -1;
    }
    // Run the generator 512 times to further mix the state before using it.
    // Factoring this as a function slows the main generator, so it is just
    // unrolled here.  The weyl generator is not advanced while warming up.
    i = 127;
    for (j = 4 * 128; j > 0; --j) {
      v = X[(i + 34) & 127];
      t = X[i = ((i + 1) & 127)];
      v ^= v << 13;
      t ^= t << 17;
      v ^= v >>> 15;
      t ^= t >>> 12;
      X[i] = v ^ t;
    }
    // Storing state as object members is faster than using closure variables.
    me.w = w;
    me.X = X;
    me.i = i;
  }

  init(me, seed);
}

function copy(f, t) {
  t.i = f.i;
  t.w = f.w;
  t.X = f.X.slice();
  return t;
};

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.X) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xor4096 = impl;
}

})(
  this,                                     // window object or global
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);


/***/ }),

/***/ "./node_modules/seedrandom/lib/xorshift7.js":
/*!**************************************************!*\
  !*** ./node_modules/seedrandom/lib/xorshift7.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xorshift7" algorithm by
// François Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    // Update xor generator.
    var X = me.x, i = me.i, t, v, w;
    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
    X[i] = v;
    me.i = (i + 1) & 7;
    return v;
  };

  function init(me, seed) {
    var j, w, X = [];

    if (seed === (seed | 0)) {
      // Seed state array using a 32-bit integer.
      w = X[0] = seed;
    } else {
      // Seed state using a string.
      seed = '' + seed;
      for (j = 0; j < seed.length; ++j) {
        X[j & 7] = (X[j & 7] << 15) ^
            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
      }
    }
    // Enforce an array length of 8, not all zeroes.
    while (X.length < 8) X.push(0);
    for (j = 0; j < 8 && X[j] === 0; ++j);
    if (j == 8) w = X[7] = -1; else w = X[j];

    me.x = X;
    me.i = 0;

    // Discard an initial 256 values.
    for (j = 256; j > 0; --j) {
      me.next();
    }
  }

  init(me, seed);
}

function copy(f, t) {
  t.x = f.x.slice();
  t.i = f.i;
  return t;
}

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.x) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xorshift7 = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);



/***/ }),

/***/ "./node_modules/seedrandom/lib/xorwow.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/lib/xorwow.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var t = (me.x ^ (me.x >>> 2));
    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
    return (me.d = (me.d + 362437 | 0)) +
       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
  };

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;
  me.v = 0;

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    if (k == strseed.length) {
      me.d = me.x << 10 ^ me.x >>> 4;
    }
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  t.v = f.v;
  t.d = f.d;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xorwow = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ }),

/***/ "./node_modules/seedrandom/seedrandom.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/seedrandom.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
Copyright 2019 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function (global, pool, math) {
//
// The following constants are related to IEEE 754 limits.
//

var width = 256,        // each RC4 output is 0 <= x < 256
    chunks = 6,         // at least six RC4 outputs for each double
    digits = 52,        // there are 52 significant digits in a double
    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
    startdenom = math.pow(width, chunks),
    significance = math.pow(2, digits),
    overflow = significance * 2,
    mask = width - 1,
    nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed, options, callback) {
  var key = [];
  options = (options == true) ? { entropy: true } : (options || {});

  // Flatten the seed string or build one from local entropy if needed.
  var shortseed = mixkey(flatten(
    options.entropy ? [seed, tostring(pool)] :
    (seed == null) ? autoseed() : seed, 3), key);

  // Use the seed to initialize an ARC4 generator.
  var arc4 = new ARC4(key);

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.
  var prng = function() {
    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
        d = startdenom,                 //   and denominator d = 2 ^ 48.
        x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  prng.int32 = function() { return arc4.g(4) | 0; }
  prng.quick = function() { return arc4.g(4) / 0x100000000; }
  prng.double = prng;

  // Mix the randomness into accumulated entropy.
  mixkey(tostring(arc4.S), pool);

  // Calling convention: what to return as a function of prng, seed, is_math.
  return (options.pass || callback ||
      function(prng, seed, is_math_call, state) {
        if (state) {
          // Load the arc4 state from the given state if it has an S array.
          if (state.S) { copy(state, arc4); }
          // Only provide the .state method if requested via options.state.
          prng.state = function() { return copy(arc4, {}); }
        }

        // If called as a method of Math (Math.seedrandom()), mutate
        // Math.random because that is how seedrandom.js has worked since v1.0.
        if (is_math_call) { math[rngname] = prng; return seed; }

        // Otherwise, it is a newer calling convention, so return the
        // prng directly.
        else return prng;
      })(
  prng,
  shortseed,
  'global' in options ? options.global : (this == math),
  options.state);
}

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key) {
  var t, keylen = key.length,
      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) {
    s[i] = i++;
  }
  for (i = 0; i < width; i++) {
    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
    s[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  (me.g = function(count) {
    // Using instance members instead of closure state nearly doubles speed.
    var t, r = 0,
        i = me.i, j = me.j, s = me.S;
    while (count--) {
      t = s[i = mask & (i + 1)];
      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
    }
    me.i = i; me.j = j;
    return r;
    // For robust unpredictability, the function call below automatically
    // discards an initial batch of values.  This is called RC4-drop[256].
    // See http://google.com/search?q=rsa+fluhrer+response&btnI
  })(width);
}

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f, t) {
  t.i = f.i;
  t.j = f.j;
  t.S = f.S.slice();
  return t;
};

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
  var result = [], typ = (typeof obj), prop;
  if (depth && typ == 'object') {
    for (prop in obj) {
      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
    }
  }
  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
  var stringseed = seed + '', smear, j = 0;
  while (j < stringseed.length) {
    key[mask & j] =
      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
  }
  return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed() {
  try {
    var out;
    if (nodecrypto && (out = nodecrypto.randomBytes)) {
      // The use of 'out' to remember randomBytes makes tight minified code.
      out = out(width);
    } else {
      out = new Uint8Array(width);
      (global.crypto || global.msCrypto).getRandomValues(out);
    }
    return tostring(out);
  } catch (e) {
    var browser = global.navigator,
        plugins = browser && browser.plugins;
    return [+new Date, global, plugins, global.screen, tostring(pool)];
  }
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
  return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if ( true && module.exports) {
  module.exports = seedrandom;
  // When in node.js, try using crypto package for autoseeding.
  try {
    nodecrypto = __webpack_require__(/*! crypto */ "?8465");
  } catch (ex) {}
} else if (true) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return seedrandom; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}


// End anonymous scope, and pass initial values.
})(
  // global: `self` in browsers (including strict mode and web workers),
  // otherwise `this` in Node and other environments
  (typeof self !== 'undefined') ? self : this,
  [],     // pool: entropy pool starts empty
  Math    // math: package containing random, pow, and seedrandom
);


/***/ }),

/***/ "./node_modules/jasmine-core/lib/jasmine-core/jasmine.css":
/*!****************************************************************!*\
  !*** ./node_modules/jasmine-core/lib/jasmine-core/jasmine.css ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _css_loader_dist_cjs_js_jasmine_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../css-loader/dist/cjs.js!./jasmine.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/jasmine-core/lib/jasmine-core/jasmine.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_jasmine_css__WEBPACK_IMPORTED_MODULE_6__.default, options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_jasmine_css__WEBPACK_IMPORTED_MODULE_6__.default && _css_loader_dist_cjs_js_jasmine_css__WEBPACK_IMPORTED_MODULE_6__.default.locals ? _css_loader_dist_cjs_js_jasmine_css__WEBPACK_IMPORTED_MODULE_6__.default.locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";


var stylesInDOM = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };

    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);

  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }

      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };

  return updater;
}

module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();

        stylesInDOM.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


var memo = {};
/* istanbul ignore next  */

function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }

    memo[target] = styleTarget;
  }

  return memo[target];
}
/* istanbul ignore next  */


function insertBySelector(insert, style) {
  var target = getTarget(insert);

  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }

  target.appendChild(style);
}

module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}

module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;

  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}

module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";

  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }

  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }

  var needLayer = typeof obj.layer !== "undefined";

  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }

  css += obj.css;

  if (needLayer) {
    css += "}";
  }

  if (obj.media) {
    css += "}";
  }

  if (obj.supports) {
    css += "}";
  }

  var sourceMap = obj.sourceMap;

  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  options.styleTagTransform(css, styleElement, options.options);
}

function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }

  styleElement.parentNode.removeChild(styleElement);
}
/* istanbul ignore next  */


function domAPI(options) {
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}

module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }

    styleElement.appendChild(document.createTextNode(css));
  }
}

module.exports = styleTagTransform;

/***/ }),

/***/ "./src/compute-voxels.test.ts":
/*!************************************!*\
  !*** ./src/compute-voxels.test.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _raw_loader_compute_voxels_wgsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !!raw-loader!./compute-voxels.wgsl */ "./node_modules/raw-loader/dist/cjs.js!./src/compute-voxels.wgsl");
/* harmony import */ var seedrandom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! seedrandom */ "./node_modules/seedrandom/index.js");
/* harmony import */ var seedrandom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(seedrandom__WEBPACK_IMPORTED_MODULE_1__);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};


describe('compute-voxels', function () {
    describe('computeMaterials', function () {
        var materials;
        beforeAll(function () { return __awaiter(void 0, void 0, void 0, function () {
            var adapter, device, density, computeVoxels, computePipeline, permutations, random, i, i, permutationsBuffer, cornerMaterials, cornerMaterialsRead, uniformBufferSize, uniformBuffer, computeBindGroup, computeEncoder, computePassEncoder, copyEncoder, buffer, uniform, queue, arrayBuffer;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, navigator.gpu.requestAdapter()];
                    case 1:
                        adapter = _a.sent();
                        return [4 /*yield*/, adapter.requestDevice()];
                    case 2:
                        device = _a.sent();
                        density = "fn getDensity(worldPosition: vec3<f32>) -> f32 { \n        if (worldPosition.y < 3.0) {\n          return -1.0;\n        } else {\n          return 1.0;\n        }\n       }";
                        computeVoxels = _raw_loader_compute_voxels_wgsl__WEBPACK_IMPORTED_MODULE_0__.default.replace("#import density", density);
                        return [4 /*yield*/, device.createComputePipelineAsync({
                                layout: 'auto',
                                compute: {
                                    module: device.createShaderModule({
                                        code: computeVoxels,
                                    }),
                                    entryPoint: 'computeMaterials',
                                },
                            })];
                    case 3:
                        computePipeline = _a.sent();
                        permutations = new Int32Array(512);
                        random = new (seedrandom__WEBPACK_IMPORTED_MODULE_1___default())(6452);
                        for (i = 0; i < 256; i++)
                            permutations[i] = (256 * (random()));
                        for (i = 256; i < 512; i++)
                            permutations[i] = permutations[i - 256];
                        permutationsBuffer = device.createBuffer({
                            size: permutations.byteLength,
                            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                            mappedAtCreation: true,
                        });
                        new Int32Array(permutationsBuffer.getMappedRange()).set(permutations);
                        permutationsBuffer.unmap();
                        cornerMaterials = device.createBuffer({
                            size: Uint32Array.BYTES_PER_ELEMENT * 5 * 5 * 5,
                            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
                            mappedAtCreation: false,
                        });
                        cornerMaterialsRead = device.createBuffer({
                            size: Uint32Array.BYTES_PER_ELEMENT * 5 * 5 * 5,
                            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
                        });
                        uniformBufferSize = 4 * 5;
                        uniformBuffer = device.createBuffer({
                            size: uniformBufferSize,
                            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
                        });
                        computeBindGroup = device.createBindGroup({
                            layout: computePipeline.getBindGroupLayout(0),
                            entries: [
                                {
                                    binding: 1,
                                    resource: {
                                        buffer: cornerMaterials
                                    },
                                },
                                {
                                    binding: 5,
                                    resource: {
                                        buffer: uniformBuffer
                                    },
                                }
                            ]
                        });
                        computeEncoder = device.createCommandEncoder();
                        computePassEncoder = computeEncoder.beginComputePass();
                        computePassEncoder.setPipeline(computePipeline);
                        computePassEncoder.setBindGroup(0, computeBindGroup);
                        computePassEncoder.dispatchWorkgroups(5, 5, 5);
                        computePassEncoder.end();
                        copyEncoder = device.createCommandEncoder();
                        copyEncoder.copyBufferToBuffer(cornerMaterials, 0, cornerMaterialsRead, 0, Uint32Array.BYTES_PER_ELEMENT * 5 * 5 * 5);
                        buffer = new ArrayBuffer(4 * 5);
                        uniform = new Float32Array(buffer, 0, 4);
                        uniform[3] = 1;
                        new Uint32Array(buffer, 16, 1)[0] = 5;
                        device.queue.writeBuffer(uniformBuffer, 0, buffer, 0, buffer.byteLength);
                        queue = device.queue.onSubmittedWorkDone();
                        device.queue.submit([computeEncoder.finish(), copyEncoder.finish()]);
                        return [4 /*yield*/, queue];
                    case 4:
                        _a.sent();
                        return [4 /*yield*/, cornerMaterialsRead.mapAsync(GPUMapMode.READ)];
                    case 5:
                        _a.sent();
                        arrayBuffer = cornerMaterialsRead.getMappedRange();
                        materials = new Uint32Array(arrayBuffer).slice();
                        cornerMaterialsRead.unmap();
                        return [2 /*return*/];
                }
            });
        }); });
        it('then materials is not null', function () {
            var expectedResult = new Uint32Array(5 * 5 * 5);
            for (var x = 0; x < 5; x++)
                for (var y = 0; y < 5; y++)
                    for (var z = 0; z < 5; z++) {
                        expectedResult[z * 5 * 5 + y * 5 + x] = y < 3 ? 1 : 0;
                    }
            expect(materials).toEqual(expectedResult);
        });
    });
});


/***/ }),

/***/ "./src/renderer.test.ts":
/*!******************************!*\
  !*** ./src/renderer.test.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./renderer */ "./src/renderer.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};

describe('Renderer', function () {
    var canvas;
    beforeEach(function () {
        canvas = document.getElementById('canvas');
    });
    it('should not throw when initialized', function () { return __awaiter(void 0, void 0, void 0, function () {
        var renderer;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    renderer = new _renderer__WEBPACK_IMPORTED_MODULE_0__.default();
                    return [4 /*yield*/, expectAsync(renderer.init(canvas)).toBeResolved()];
                case 1:
                    _a.sent();
                    expect(function () { return renderer.configure(canvas.width, canvas.height); }).not.toThrow();
                    expect(function () { return renderer.render(function () { }); }).not.toThrow();
                    return [2 /*return*/];
            }
        });
    }); });
});


/***/ }),

/***/ "./src/renderer.ts":
/*!*************************!*\
  !*** ./src/renderer.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var Renderer = /** @class */ (function () {
    function Renderer() {
    }
    Renderer.prototype.init = function (canvas) {
        return __awaiter(this, void 0, void 0, function () {
            var adapter, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, navigator.gpu.requestAdapter()];
                    case 1:
                        adapter = _b.sent();
                        _a = this;
                        return [4 /*yield*/, adapter.requestDevice()];
                    case 2:
                        _a.device = _b.sent();
                        this.context = canvas.getContext('webgpu');
                        this.presentationFormat = navigator.gpu.getPreferredCanvasFormat();
                        return [2 /*return*/];
                }
            });
        });
    };
    Renderer.prototype.configure = function (width, height) {
        this.context.configure({
            device: this.device,
            format: this.presentationFormat,
            alphaMode: 'opaque'
        });
        this.depthTexture = this.device.createTexture({
            size: { width: width, height: height },
            format: 'depth24plus-stencil8',
            usage: GPUTextureUsage.RENDER_ATTACHMENT,
        });
    };
    Renderer.prototype.render = function (callback) {
        var commandEncoder = this.device.createCommandEncoder();
        var textureView = this.context.getCurrentTexture().createView();
        var renderPassDescriptor = {
            colorAttachments: [
                {
                    view: textureView,
                    clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },
                    loadOp: 'clear',
                    storeOp: 'store'
                }
            ],
            depthStencilAttachment: {
                view: this.depthTexture.createView(),
                depthClearValue: 1.0,
                depthLoadOp: 'clear',
                depthStoreOp: 'store',
                stencilClearValue: 0,
                stencilLoadOp: 'clear',
                stencilStoreOp: 'store',
            }
        };
        var passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
        callback(passEncoder);
        passEncoder.end();
        this.device.queue.submit([commandEncoder.finish()]);
    };
    return Renderer;
}());
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Renderer);


/***/ }),

/***/ "./src/tests.ts":
/*!**********************!*\
  !*** ./src/tests.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jasmine_core_lib_jasmine_core_jasmine_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jasmine-core/lib/jasmine-core/jasmine.css */ "./node_modules/jasmine-core/lib/jasmine-core/jasmine.css");
/* harmony import */ var jasmine_core_lib_jasmine_core_jasmine_html_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jasmine-core/lib/jasmine-core/jasmine-html.js */ "./node_modules/jasmine-core/lib/jasmine-core/jasmine-html.js");
/* harmony import */ var jasmine_core_lib_jasmine_core_jasmine_html_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jasmine_core_lib_jasmine_core_jasmine_html_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var jasmine_core_lib_jasmine_core_boot0_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jasmine-core/lib/jasmine-core/boot0.js */ "./node_modules/jasmine-core/lib/jasmine-core/boot0.js");
/* harmony import */ var jasmine_core_lib_jasmine_core_boot0_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jasmine_core_lib_jasmine_core_boot0_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var jasmine_core_lib_jasmine_core_boot1_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! jasmine-core/lib/jasmine-core/boot1.js */ "./node_modules/jasmine-core/lib/jasmine-core/boot1.js");
/* harmony import */ var jasmine_core_lib_jasmine_core_boot1_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(jasmine_core_lib_jasmine_core_boot1_js__WEBPACK_IMPORTED_MODULE_3__);




// @ts-ignore
var tests = __webpack_require__("./src sync recursive .test.(j|t)s$");
var testFiles = tests.keys();
for (var test in testFiles) {
    tests(testFiles[test]);
}


/***/ }),

/***/ "./src/world-generator.test.ts":
/*!*************************************!*\
  !*** ./src/world-generator.test.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _world_generator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./world-generator */ "./src/world-generator.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};

describe('World Generator', function () {
    var worldGenerator;
    beforeEach(function () {
        worldGenerator = new _world_generator__WEBPACK_IMPORTED_MODULE_0__.default(8);
    });
    describe('when init is called', function () {
        var info;
        beforeEach(function () {
            info = worldGenerator.init(3, 20, 43);
        });
        it('position is rounded to nearest stride', function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                expect(info.x).toEqual(0);
                expect(info.y).toEqual(24);
                expect(info.z).toEqual(40);
                return [2 /*return*/];
            });
        }); });
        it('current stride defaults to minimum stride', function () {
            expect(info.stride).toEqual(8);
        });
        it('previousOffset is correct', function () {
            expect(info.previousOffset).toEqual(-4);
        });
        it('layer is correct', function () {
            expect(info.layer).toEqual(1);
        });
    });
    describe('when next is called', function () {
        it('returns origin position', function () {
            var _a = __read(worldGenerator.next({
                x: 0, y: 0, z: 0, stride: 8, iteration: 0, layer: 1, previousOffset: -4
            }), 2), result = _a[0], info = _a[1];
            expect(result).toEqual({
                x: -4, y: -4, z: -4, stride: 8
            });
            expect(info).toEqual({
                x: 0, y: 0, z: 0, stride: 8, iteration: 1, layer: 1, previousOffset: -4
            });
        });
        it('returns origin position for iteration 1', function () {
            var _a = __read(worldGenerator.next({
                x: 0, y: 0, z: 0, stride: 8, iteration: 1, layer: 1, previousOffset: -4
            }), 2), result = _a[0], info = _a[1];
            expect(result).toEqual({
                x: -4, y: -4, z: 4, stride: 8
            });
            expect(info).toEqual({
                x: 0, y: 0, z: 0, stride: 8, iteration: 2, layer: 1, previousOffset: -4
            });
        });
        it('returns origin position for second layer', function () {
            var _a = __read(worldGenerator.next({
                x: 0, y: 0, z: 0, stride: 8, iteration: 0, layer: 2, previousOffset: -4
            }), 2), result = _a[0], info = _a[1];
            expect(result).toEqual({
                x: -12, y: -12, z: -12, stride: 8
            });
            expect(info).toEqual({
                x: 0, y: 0, z: 0, stride: 8, iteration: 1, layer: 2, previousOffset: -4
            });
        });
        it('returns origin position for second layer second iteration', function () {
            var _a = __read(worldGenerator.next({
                x: 0, y: 0, z: 0, stride: 8, iteration: 6, layer: 2, previousOffset: -4
            }), 2), result = _a[0], info = _a[1];
            expect(result).toEqual({
                x: -12, y: -4, z: 4, stride: 8
            });
            expect(info).toEqual({
                x: 0, y: 0, z: 0, stride: 8, iteration: 7, layer: 2, previousOffset: -4
            });
        });
        it('offsets position by root', function () {
            var _a = __read(worldGenerator.next({
                x: 40, y: 24, z: 32, stride: 8, iteration: 0, layer: 1, previousOffset: -4
            }), 2), result = _a[0], info = _a[1];
            expect(result).toEqual({
                x: 36, y: 20, z: 28, stride: 8
            });
            expect(info).toEqual({
                x: 40, y: 24, z: 32, stride: 8, iteration: 1, layer: 1, previousOffset: -4
            });
        });
        it('offsets position by iteration', function () {
            var _a = __read(worldGenerator.next({
                x: 40, y: 24, z: 32, stride: 8, iteration: 1, layer: 1, previousOffset: -4
            }), 2), result = _a[0], info = _a[1];
            expect(result).toEqual({
                x: 36, y: 20, z: 36, stride: 8
            });
            expect(info).toEqual({
                x: 40, y: 24, z: 32, stride: 8, iteration: 2, layer: 1, previousOffset: -4
            });
        });
        it('offsets position by last iteration', function () {
            var _a = __read(worldGenerator.next({
                x: 40, y: 24, z: 32, stride: 8, iteration: 7, layer: 1, previousOffset: -4
            }), 2), result = _a[0], info = _a[1];
            expect(result).toEqual({
                x: 44, y: 28, z: 36, stride: 8
            });
            expect(info).toEqual({
                x: 40, y: 24, z: 32, stride: 8, iteration: 0, layer: 2, previousOffset: -4
            });
        });
        it('offsets position by last layer', function () {
            var _a = __read(worldGenerator.next({
                x: 40, y: 24, z: 32, stride: 8, iteration: 55, layer: 2, previousOffset: -4
            }), 2), result = _a[0], info = _a[1];
            expect(result).toEqual({
                x: 52, y: 36, z: 44, stride: 8
            });
            expect(info).toEqual({
                x: 40, y: 24, z: 32, stride: 16, iteration: 0, layer: 1, previousOffset: 8
            });
        });
        it('returns correct position for next stride', function () {
            var _a = __read(worldGenerator.next({
                x: 0, y: 0, z: 0, stride: 16, iteration: 0, layer: 1, previousOffset: 8
            }), 2), result = _a[0], info = _a[1];
            expect(result).toEqual({
                x: -24, y: -24, z: -24, stride: 16
            });
            expect(info).toEqual({
                x: 0, y: 0, z: 0, stride: 16, iteration: 1, layer: 1, previousOffset: 8
            });
        });
        it('returns correct position 32/0/1', function () {
            var _a = __read(worldGenerator.next({
                x: 0, y: 0, z: 0, stride: 32, iteration: 0, layer: 1, previousOffset: 48
            }), 2), result = _a[0], info = _a[1];
            expect(result).toEqual({
                x: -80, y: -80, z: -80, stride: 32
            });
            expect(info).toEqual({
                x: 0, y: 0, z: 0, stride: 32, iteration: 1, layer: 1, previousOffset: 48
            });
        });
    });
    describe('when radius is called', function () {
        var expectedResults = [
            { layer: 1, stride: 8, previousOffset: -4, result: 4 },
            { layer: 2, stride: 8, previousOffset: -4, result: 12 },
            { layer: 1, stride: 16, previousOffset: 8, result: 24 },
            { layer: 2, stride: 16, previousOffset: 8, result: 40 },
            { layer: -2, stride: 16, previousOffset: 8, result: -40 },
        ];
        var _loop_1 = function (i) {
            var _a = expectedResults[i], layer = _a.layer, stride = _a.stride, previousOffset = _a.previousOffset, result = _a.result;
            it("then ring ".concat(i + 1, " is correct"), function () {
                expect(worldGenerator.radius(layer, stride, previousOffset)).toEqual(result);
            });
        };
        for (var i = 0; i < expectedResults.length; i++) {
            _loop_1(i);
        }
    });
    describe('when layerRadius is called', function () {
        var expectedResults = [
            { layer: 1, stride: 8, result: 1 },
            { layer: 2, stride: 8, result: 2 },
            { layer: 1, stride: 16, result: 2 },
            { layer: 2, stride: 16, result: 3 },
            { layer: 3, stride: 16, result: 4 },
            { layer: 1, stride: 32, result: 3 },
            { layer: 2, stride: 32, result: 4 },
        ];
        var _loop_2 = function (i) {
            var _a = expectedResults[i], layer = _a.layer, stride = _a.stride, result = _a.result;
            it("then ring ".concat(i + 1, " is correct"), function () {
                expect(worldGenerator.layerRadius(layer, stride)).toEqual(result);
            });
        };
        for (var i = 0; i < expectedResults.length; i++) {
            _loop_2(i);
        }
    });
    describe('when layerCount is called', function () {
        it('returns 2 for first stride', function () {
            expect(worldGenerator.layerCount(8)).toEqual(2);
        });
        it('returns 3 for second stride', function () {
            expect(worldGenerator.layerCount(16)).toEqual(3);
        });
        it('returns 2 for subsequent strides', function () {
            for (var i = 32; i < 1024; i += i) {
                expect(worldGenerator.layerCount(i)).toEqual(2);
            }
        });
    });
    describe('generate points', function () {
        it('returns the correct values', function () {
            expect((0,_world_generator__WEBPACK_IMPORTED_MODULE_0__.generatePoints)(1)).toEqual([
                { x: -1, y: -1, z: -1 },
                { x: -1, y: -1, z: 1 },
                { x: -1, y: 1, z: -1 },
                { x: -1, y: 1, z: 1 },
                { x: 1, y: -1, z: -1 },
                { x: 1, y: -1, z: 1 },
                { x: 1, y: 1, z: -1 },
                { x: 1, y: 1, z: 1 },
            ]);
        });
        it('returns the correct values 2', function () {
            expect((0,_world_generator__WEBPACK_IMPORTED_MODULE_0__.generatePoints)(2).length).toEqual(56);
        });
    });
});


/***/ }),

/***/ "./src/world-generator.ts":
/*!********************************!*\
  !*** ./src/world-generator.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "generatePoints": () => (/* binding */ generatePoints),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
function fixPoint(i) {
    if (i >= 0)
        return i + 1;
    return i;
}
function generatePoints(radius) {
    var points = [];
    var diameter = radius * 2;
    for (var x = 0; x < diameter; x++)
        for (var y = 0; y < diameter; y++)
            for (var z = 0; z < diameter; z++) {
                if (!(x === 0 || x === diameter - 1 || y === 0 || y === diameter - 1 || z === 0 || z === diameter - 1)) {
                    continue;
                }
                var point = {
                    x: fixPoint(x - radius),
                    y: fixPoint(y - radius),
                    z: fixPoint(z - radius)
                };
                points.push(point);
            }
    return points;
}
var points = [];
for (var i = 0; i <= 6; i++) {
    points[i] = generatePoints(i);
}
var WorldGenerator = /** @class */ (function () {
    function WorldGenerator(minStride) {
        this.minStride = minStride;
    }
    WorldGenerator.prototype.init = function (x, y, z) {
        return {
            x: Math.round(x / this.minStride) * this.minStride,
            y: Math.round(y / this.minStride) * this.minStride,
            z: Math.round(z / this.minStride) * this.minStride,
            stride: this.minStride,
            iteration: 0,
            layer: 1,
            previousOffset: -1 * this.minStride / 2
        };
    };
    WorldGenerator.prototype.layerRadius = function (layer, stride) {
        if (stride === this.minStride) {
            return layer;
        }
        if (stride === this.minStride * 2) {
            return layer + 1;
        }
        return layer + 2;
    };
    WorldGenerator.prototype.radius = function (layer, stride, previousOffset) {
        return Math.sign(layer) * (previousOffset + (Math.abs(layer) * stride));
    };
    WorldGenerator.prototype.layerCount = function (stride) {
        if (stride == this.minStride * 2)
            return 3;
        return 2;
    };
    WorldGenerator.prototype.next = function (info) {
        var offsets = points[this.layerRadius(info.layer, info.stride)];
        var offset = offsets[info.iteration];
        var halfStride = info.stride / 2;
        var iteration = info.iteration + 1;
        var layer = info.layer;
        var stride = info.stride;
        var previousOffset = info.previousOffset;
        if (iteration >= offsets.length) {
            iteration = 0;
            layer++;
            var layerCount = this.layerCount(info.stride);
            if (layer > layerCount) {
                layer = 1;
                stride *= 2;
                previousOffset = this.radius(info.layer, info.stride, info.previousOffset) - info.stride / 2;
            }
        }
        return [
            {
                x: info.stride * offset.x + info.x - Math.sign(offset.x) * halfStride,
                y: info.stride * offset.y + info.y - Math.sign(offset.y) * halfStride,
                z: info.stride * offset.z + info.z - Math.sign(offset.z) * halfStride,
                stride: info.stride
            },
            __assign(__assign({}, info), { iteration: iteration, layer: layer, stride: stride, previousOffset: previousOffset })
        ];
    };
    return WorldGenerator;
}());
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WorldGenerator);


/***/ }),

/***/ "./src sync recursive .test.(j|t)s$":
/*!*********************************!*\
  !*** ./src/ sync .test.(j|t)s$ ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./compute-voxels.test.ts": "./src/compute-voxels.test.ts",
	"./renderer.test.ts": "./src/renderer.test.ts",
	"./world-generator.test.ts": "./src/world-generator.test.ts"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./src sync recursive .test.(j|t)s$";

/***/ }),

/***/ "?8465":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd define */
/******/ 	(() => {
/******/ 		__webpack_require__.amdD = function () {
/******/ 			throw new Error('define cannot be used indirect');
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./src/tests.ts");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL25vZGVfbW9kdWxlcy9qYXNtaW5lLWNvcmUvbGliL2phc21pbmUtY29yZS9qYXNtaW5lLmNzcyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qcyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL25vZGVfbW9kdWxlcy9qYXNtaW5lLWNvcmUvbGliL2phc21pbmUtY29yZS9ib290MC5qcyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL25vZGVfbW9kdWxlcy9qYXNtaW5lLWNvcmUvbGliL2phc21pbmUtY29yZS9ib290MS5qcyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL25vZGVfbW9kdWxlcy9qYXNtaW5lLWNvcmUvbGliL2phc21pbmUtY29yZS9qYXNtaW5lLWh0bWwuanMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvLi9ub2RlX21vZHVsZXMvamFzbWluZS1jb3JlL2xpYi9qYXNtaW5lLWNvcmUvamFzbWluZS5qcyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL3NyYy9jb21wdXRlLXZveGVscy53Z3NsIiwid2VicGFjazovL3dlYmdwdS1jb21wdXRlLy4vbm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIvYWxlYS5qcyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL25vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi90eWNoZWkuanMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yMTI4LmpzIiwid2VicGFjazovL3dlYmdwdS1jb21wdXRlLy4vbm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vbGliL3hvcjQwOTYuanMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yc2hpZnQ3LmpzIiwid2VicGFjazovL3dlYmdwdS1jb21wdXRlLy4vbm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vbGliL3hvcndvdy5qcyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL25vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL3NlZWRyYW5kb20uanMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvLi9ub2RlX21vZHVsZXMvamFzbWluZS1jb3JlL2xpYi9qYXNtaW5lLWNvcmUvamFzbWluZS5jc3M/NGU4ZiIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzIiwid2VicGFjazovL3dlYmdwdS1jb21wdXRlLy4vc3JjL2NvbXB1dGUtdm94ZWxzLnRlc3QudHMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvLi9zcmMvcmVuZGVyZXIudGVzdC50cyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL3NyYy9yZW5kZXJlci50cyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL3NyYy90ZXN0cy50cyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL3NyYy93b3JsZC1nZW5lcmF0b3IudGVzdC50cyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL3NyYy93b3JsZC1nZW5lcmF0b3IudHMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvL2hvbWUvcnVubmVyL3dvcmsvd2ViZ3B1LXdvcmxkL3dlYmdwdS13b3JsZC9zcmN8c3luY3wvLnRlc3QuKGp8dClzJC8iLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvaWdub3JlZHxjcnlwdG8iLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvd2VicGFjay9ydW50aW1lL2FtZCBkZWZpbmUiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvd2VicGFjay9ydW50aW1lL2FtZCBvcHRpb25zIiwid2VicGFjazovL3dlYmdwdS1jb21wdXRlL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL3dlYmdwdS1jb21wdXRlL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL3dlYmdwdS1jb21wdXRlL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS93ZWJwYWNrL3J1bnRpbWUvbm9kZSBtb2R1bGUgZGVjb3JhdG9yIiwid2VicGFjazovL3dlYmdwdS1jb21wdXRlL3dlYnBhY2svc3RhcnR1cCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNtRztBQUNqQjtBQUNsRiw4QkFBOEIsc0VBQTJCLENBQUMsK0VBQXFDO0FBQy9GO0FBQ0EsNkRBQTZELFFBQVEsdUJBQXVCLEdBQUcsNEJBQTRCLGdCQUFnQiwyQkFBMkIsaUJBQWlCLGlCQUFpQixvQkFBb0IsdURBQXVELHNCQUFzQixnQkFBZ0IsR0FBRyw0QkFBNEIsMEJBQTBCLEdBQUcsa0NBQWtDLCtCQUErQixHQUFHLDhMQUE4TCxjQUFjLHNCQUFzQixHQUFHLHdaQUF3WixzQkFBc0IsdUJBQXVCLEdBQUcsMENBQTBDLHVCQUF1QixHQUFHLHlEQUF5RCxxQ0FBcUMscXdFQUFxd0UseUNBQXlDLCtoWEFBK2hYLCtCQUErQiw2QkFBNkIsa0NBQWtDLDBCQUEwQixtQkFBbUIsZ0JBQWdCLGdCQUFnQixpQkFBaUIsR0FBRywyREFBMkQsc0JBQXNCLHVCQUF1QixhQUFhLEdBQUcsMkNBQTJDLG9CQUFvQixnQkFBZ0IsR0FBRywyQ0FBMkMsZ0JBQWdCLEdBQUcsMENBQTBDLHFCQUFxQixHQUFHLDRDQUE0QyxnQkFBZ0IsaUJBQWlCLHNCQUFzQix1QkFBdUIsR0FBRyxrREFBa0QscUJBQXFCLG1CQUFtQixHQUFHLHFEQUFxRCwwQkFBMEIsaUJBQWlCLGdCQUFnQixvQkFBb0IsR0FBRyxvRUFBb0Usb0JBQW9CLEdBQUcsMkVBQTJFLG1CQUFtQixtQkFBbUIsR0FBRyxvRUFBb0UscUJBQXFCLEdBQUcsMkVBQTJFLG1CQUFtQixtQkFBbUIsc0JBQXNCLHNCQUFzQixHQUFHLHNFQUFzRSxvQkFBb0IsR0FBRyw2RUFBNkUsbUJBQW1CLG1CQUFtQixHQUFHLGlGQUFpRixvQkFB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VUFBVSxLQUFLLEtBQUssVUFBVSxNQUFNLEtBQUssVUFBVSxVQUFVLEtBQUssS0FBSyxVQUFVLFlBQVksYUFBYSxXQUFXLFlBQVksYUFBYSxNQUFNLEtBQUssVUFBVSxZQUFZLE1BQU0sS0FBSyxZQUFZLFdBQVcsVUFBVSxZQUFZLGFBQWEsYUFBYSxhQUFhLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxZQUFZLFdBQVcsVUFBVSxVQUFVLEtBQUssS0FBSyxZQUFZLGFBQWEsTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLFlBQVksYUFBYSxhQUFhLFdBQVcsS0FBSyxLQUFLLFlBQVksV0FBVyxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLE1BQU0sVUFBVSxLQUFLLE1BQU0sVUFBVSxLQUFLLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxhQUFhLFdBQVcsVUFBVSxNQUFNLEtBQUssVUFBVSxZQUFZLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxZQUFZLE1BQU0sS0FBSyxVQUFVLEtBQUssS0FBSyxZQUFZLE1BQU0sS0FBSyxZQUFZLFdBQVcsS0FBSyxLQUFLLFVBQVUsS0FBSyxLQUFLLFlBQVksV0FBVyxZQUFZLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxZQUFZLGFBQWEsV0FBVyxZQUFZLFdBQVcsWUFBWSxhQUFhLGFBQWEsTUFBTSxLQUFLLFVBQVUsWUFBWSxXQUFXLFlBQVksTUFBTSxLQUFLLFVBQVUsS0FBSyxLQUFLLFlBQVksTUFBTSxLQUFLLFVBQVUsWUFBWSxXQUFXLEtBQUssS0FBSyxZQUFZLFdBQVcsVUFBVSxZQUFZLGFBQWEs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QUNBLEU7Ozs7Ozs7Ozs7QUNyQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxtQkFBTyxDQUFDLDZFQUFjOztBQUV0RTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7O0FDL0REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrREFBK0QsSUFBSTtBQUNuRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFF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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIscUJBQXFCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7OztBQzk3QkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEtBQTZCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUJBQU07QUFDckIsc0JBQXNCLHFCQUFNO0FBQzVCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsOEJBQThCO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFNBQVM7QUFDM0UsTUFBTSxpQkFBaUIsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0I7QUFDN0QsTUFBTSxlQUFlO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLG9DQUFvQyw2QkFBNkI7QUFDakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiwrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2QkFBNkI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkdBQTJHO0FBQzNHO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkdBQTJHO0FBQzNHO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG9CQUFvQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0QkFBNEIsc0NBQXNDLGdDQUFnQztBQUM1SDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsSUFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQ0FBa0MsY0FBYyxLQUFLO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLCtDQUErQztBQUMvQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2Q0FBNkM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixXQUFXO0FBQ1g7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsV0FBVztBQUNYO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLG1EQUFtRCxjQUFjO0FBQ2pFO0FBQ0Esb0RBQW9ELGNBQWM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsaURBQWlELGNBQWM7QUFDL0Q7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGVBQWUsa0NBQWtDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixhQUFhLEVBQUU7QUFDZixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixhQUFhLEVBQUU7QUFDZixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxnQ0FBZ0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLGlCQUFpQiw0QkFBNEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOEJBQThCO0FBQy9DO0FBQ0E7O0FBRUEsdUJBQXVCLDhCQUE4QjtBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0JBQStCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUNBQWlDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQ0FBa0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrQkFBK0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsK0JBQStC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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLGFBQWE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLGFBQWE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLGFBQWE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxhQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxhQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxhQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sYUFBYTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLGFBQWE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sYUFBYTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLGFBQWE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sYUFBYTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxhQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLGFBQWE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sYUFBYTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxnQ0FBZ0Msc0JBQXNCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCx3Q0FBd0MsaUNBQWlDOztBQUV6RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sYUFBYSxnQkFBZ0IsVUFBVTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sYUFBYSxzQkFBc0IsVUFBVSxzQ0FBc0MsVUFBVTtBQUNuRztBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUksYUFBYSxVQUFVLGtEQUFrRCxVQUFVO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sYUFBYSxnQkFBZ0IsVUFBVTtBQUM3QztBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLGFBQWEsZ0JBQWdCLFVBQVU7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZUFBZSxtQ0FBbUM7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLLG1EQUFtRDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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RUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLFNBQVMsRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFDO2FBQ3hFLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLDBCQUEwQixFQUFFO1lBQ3pCLGdCQUFpQixjQUFjLENBQUMsSUFBSSxDQUFDO2dCQUN2QyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLFNBQVMsRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFDO2FBQzNFLENBQUMsTUFGRyxNQUFNLFVBQUUsSUFBSSxRQUVmLENBQUM7WUFFSCxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDO2dCQUNyQixDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsQ0FBQzthQUMvQixDQUFDLENBQUM7WUFFSCxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDO2dCQUNuQixDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLFNBQVMsRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFDO2FBQzNFLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLCtCQUErQixFQUFFO1lBQzlCLGdCQUFpQixjQUFjLENBQUMsSUFBSSxDQUFDO2dCQUN2QyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLFNBQVMsRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFDO2FBQzNFLENBQUMsTUFGRyxNQUFNLFVBQUUsSUFBSSxRQUVmLENBQUM7WUFFSCxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDO2dCQUNyQixDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsQ0FBQzthQUMvQixDQUFDLENBQUM7WUFFSCxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDO2dCQUNuQixDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLFNBQVMsRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFDO2FBQzNFLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLG9DQUFvQyxFQUFFO1lBQ25DLGdCQUFpQixjQUFjLENBQUMsSUFBSSxDQUFDO2dCQUN2QyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLFNBQVMsRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFDO2FBQzNFLENBQUMsTUFGRyxNQUFNLFVBQUUsSUFBSSxRQUVmLENBQUM7WUFFSCxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDO2dCQUNyQixDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsQ0FBQzthQUMvQixDQUFDLENBQUM7WUFFSCxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDO2dCQUNuQixDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFB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QSxFOzs7OztXQ0ZBLDhCOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxnQ0FBZ0MsWUFBWTtXQUM1QztXQUNBLEU7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx3Q0FBd0MseUNBQXlDO1dBQ2pGO1dBQ0E7V0FDQSxFOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsRUFBRTtXQUNGO1dBQ0E7V0FDQSxDQUFDLEk7Ozs7O1dDUEQsd0Y7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0Esc0RBQXNELGtCQUFrQjtXQUN4RTtXQUNBLCtDQUErQyxjQUFjO1dBQzdELEU7Ozs7O1dDTkE7V0FDQTtXQUNBO1dBQ0E7V0FDQSxFOzs7O1VDSkE7VUFDQTtVQUNBO1VBQ0EiLCJmaWxlIjoidGVzdHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCJAY2hhcnNldCBcXFwiVVRGLThcXFwiO1xcbmJvZHkge1xcbiAgb3ZlcmZsb3cteTogc2Nyb2xsO1xcbn1cXG5cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VlZTtcXG4gIHBhZGRpbmc6IDVweDtcXG4gIG1hcmdpbjogLThweDtcXG4gIGZvbnQtc2l6ZTogMTFweDtcXG4gIGZvbnQtZmFtaWx5OiBNb25hY28sIFxcXCJMdWNpZGEgQ29uc29sZVxcXCIsIG1vbm9zcGFjZTtcXG4gIGxpbmUtaGVpZ2h0OiAxNHB4O1xcbiAgY29sb3I6ICMzMzM7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgYSB7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgYTpob3ZlciB7XFxuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciBwLCAuamFzbWluZV9odG1sLXJlcG9ydGVyIGgxLCAuamFzbWluZV9odG1sLXJlcG9ydGVyIGgyLCAuamFzbWluZV9odG1sLXJlcG9ydGVyIGgzLCAuamFzbWluZV9odG1sLXJlcG9ydGVyIGg0LCAuamFzbWluZV9odG1sLXJlcG9ydGVyIGg1LCAuamFzbWluZV9odG1sLXJlcG9ydGVyIGg2IHtcXG4gIG1hcmdpbjogMDtcXG4gIGxpbmUtaGVpZ2h0OiAxNHB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhbm5lcixcXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5LFxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3VtbWFyeSxcXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXJlc3VsdC1tZXNzYWdlLFxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3BlYyAuamFzbWluZS1kZXNjcmlwdGlvbixcXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXNwZWMtZGV0YWlsIC5qYXNtaW5lLWRlc2NyaXB0aW9uLFxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYWxlcnQgLmphc21pbmUtYmFyLFxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3RhY2stdHJhY2Uge1xcbiAgcGFkZGluZy1sZWZ0OiA5cHg7XFxuICBwYWRkaW5nLXJpZ2h0OiA5cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFubmVyIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYW5uZXIgLmphc21pbmUtdGl0bGUge1xcbiAgYmFja2dyb3VuZDogdXJsKFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUZvQUFBQVpDQU1BQUFDR3VzbnlBQUFDZGxCTVZFWC8vLy8vQVArQWdJQ3FWYXFBUUlDWk01bUFWWUNTU1pLQVFJQ09PWTZBVFlDTFJvdUFRSUNKTzRtU1NZQ0lSSWlQUUlDSFBJZU9SNENHUTRhTVFJQ0dQWWFMUm9DRlE0V0tRSUNQUFlXSlJZQ09Rb1NKUUlDTlBvU0lSSUNNUW9TSFFJQ0hSSUNLUW9PSFFJQ0tQb09KTzRPSlFZT01RSUNNUTRDSVFZS0xRSUNJUG9LTFE0Q0tRSUNOUG9LSlFJU01RNEtKUW9TTFFZS0pRSVNMUTRLSVFvU0tRWUtJUUlDSVFJU01Rb1NLUVlLTFFJT0xRb09KUVlHTFFJT0tRSU9NUW9HS1FZT0xRWUdLUUlPTFFvR0pRWU9KUUlPS1FZR0pRSU9LUW9HS1FJR0xRSUtMUTRLS1FvR0xRWUtKUUlHS1FZS0pRSUdLUUlLSlFvR0tRWUtMUUlHS1FZS0xRSU9KUW9LS1FvT0pRWUtLUUlPSlFvS0tRb09LUUlPTFFvS0tRWU9MUVlLSlFJT0tRb0tLUVlLS1FvS0pRWU9LUVlLTFFJT0tRb0tMUVlPS1FZS0xRSU9KUW9HS1FZS0pRWUdKUW9HS1FZS0xRb0dMUVlHS1FvR0pRWUtLUVlHSlFJS0tRb0dKUVlLTFFJS0tRWUdMUVlLS1FZR0tRWUdLUVlLSlFZT0tRb0tKUVlPS1FZS0xRWU9MUVlPS1FZS0xRWU9LUW9LS1FZS0tRWU9LUVlPSlFZS0tRWUtMUVlLS1FJS0tRb0tLUVlLS1FZS0tRb0tKUUlLS1FZS0xRWUtLUVlLS1FJS0tRWUtLUVlLS1FZS0tRSUtLUVlLSlFZR0xRWUdLUVlLS1FZS0tRWUdLUUlLS1FZR0tRWU9KUW9LS1FZT0xRWUtLUVlPS1FvS0tRWUtLUW9LS1FZS0tRWUtKUVlLTFFZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLSlFZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLTFFZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS21JRHBFQUFBQTBYUlNUbE1BQVFJREJBVUdCd2dKQ2dzTURRNFBFQkVTRXhRVkZoY1lHUm9iSEIwZUh5QWlJeVFsSnljb0tpc3NMUzR3TVRRMU5qYzRPVG83UER3K1AwQkNRMFJJU1VwTFRFMU9VRk5VVlZkWVdGbGFXMTVmWUdGaVkyWm5hR2xxYTJ4dGIzQnhjbk4wZG5oNWVudDhmWDUvZ0lHQ2hJV0lpb3lOam8rUWtaT1VsWmFZbVpxYm5KMmVvS0dpbzZXbXFLbXNyYTZ2c0xHenRyZTR1YnE3dkwyK3dNSER4TWpKeXN2TnpzL1EwZExVMXRmWTJkdmMzdC9nNGVMajVlYm42T25xNit6dDd1L3c4dlAwOWZiMytQbjYrL3o5L3ZrVlFYQUFBQU1hU1VSQlZIaGU1ZFh4VjFOMUdNZnh6MkFCYkRnSUFtNVZESk95VkRJSkxVTWFWcEJXVVpVYUdibXFvR3BaUlNpR2lSV3A2S29aNUFCMFpZNTBSSW1aUUlsYWhLa01ZWHYvUjkwZEJ2RVQvckpmT3IzT3VjOHY5OXpQZWM1OXp2ZjU2ait2WUtsVmlTZjcyNTBYNE1yM08yOVRncTA4QmRHQjREaGNla0VKNVlrUUtGc2dXWmR0ajlKcFYrSTh4UGpMRnFrcnNFSXFPOFBIU3BpczM2aldhemNxakVzZkpqa3ZSc3NWVTM3U2RJT3U0WENmNXZFSlBzbndKcG5STlU5Sm14aE1rOGwxZ2VoSXJxN2hURmp6T0QrVmY4ODYyOXFLTUpWTmx0SW5GZVJleFJReUpsTmVxZDFpR0RsU3pySVVJeVhieUZmbTNSWXByY1FSZTdscXRXeUdZYmZjNmRUMFIydm1kT09rWDN1NTVDMXJQMzdmdGlIK3REYnk0ci9SQlQwdzhUeUVrcitlcEI5WGdQRG1TWVlXYnJoQ3VGWWFJeXczZkRRQVhUblNraCtBTm9maUhtV2Y5bCtGWTFJOTBGZFFUZXRzdE8wMG8yM25vdnpWc0o3dUIzL0M1VGtialJ3WjVKZXJ3VjRpUldxOUhGYkZNYUsvZDBUWXFheVJpUVB1SXh4UzNCdThKV1U5MC82MHRLaTd2a2hhem5lejBhL1RiVk9LajVDYU9aaDZmV0c2L0x5djlCL1pMUjFndy9TL2ZwYmVWRDNNQ1cxbGk2U3ZXRE9uNjV0cjk5L3V2V3RCUzBYRG00czF0K3NPSHBHMGtwQkt4L2w3N3dPU254THBjeDZUWG1YTFRQUU9LWU9mOVExZGZyOC9TSjJtRmRDdmwxWWw5M0RpSFVadlhlTEpiR1N6WXU1Z1ZKMnNsYlNha09SOGR4Q3E1YWRRMm9GTHFzRTlFeDNMNHFRTzBlT1BlVTV4NTZieXBYcDRvblNFYjVPa0lDWDZsRGF0NTVUZW96dE5LUWNKYWFrcno5S0NiOTVvRDY5SUtxK3lLVzRYUGprbmFTNTJWMFRacUUyY1R0WGpjSFNDUm1VTzg4ZSs4NWhqM0VQNzRpOXA4cHlsdzdseGdNRHl5bDZPVjdaZWpuak5NZmF0dTg3THhSYkgwSVMzNWd0MmE0WmptR3BWQmRLSzNXcjZJTms4aldXU0dxYkE1NUNLZ2pCUkM2RTl3Nzh5ZFRnM0FCUzNBRlYxUU4wWTRBYTJwZ0VqV25RVVJqOUwwYXlLNlIyeXNFcXhIVUt6WW5MdnZ5VStpOUtNMkpISnpFNHZ5Wk95RGNPd09zeVNhamVMUGM4c052UEprRmx5SmQyMHdwcUF6WmVBZlozb1d5YnhkK1AvM2orU0czdVNCZGYyVlFBQUFBQkpSVTVFcmtKZ2dnPT1cXFwiKSBuby1yZXBlYXQ7XFxuICBiYWNrZ3JvdW5kOiB1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaVZWUkdMVGdpSUhOMFlXNWtZV3h2Ym1VOUltNXZJajgrQ2p3aExTMGdRM0psWVhSbFpDQjNhWFJvSUVsdWEzTmpZWEJsSUNob2RIUndPaTh2ZDNkM0xtbHVhM05qWVhCbExtOXlaeThwSUMwdFBnb0tQSE4yWndvZ0lDQjRiV3h1Y3pwa1l6MGlhSFIwY0RvdkwzQjFjbXd1YjNKbkwyUmpMMlZzWlcxbGJuUnpMekV1TVM4aUNpQWdJSGh0Ykc1ek9tTmpQU0pvZEhSd09pOHZZM0psWVhScGRtVmpiMjF0YjI1ekxtOXlaeTl1Y3lNaUNpQWdJSGh0Ykc1ek9uSmtaajBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TVRrNU9TOHdNaTh5TWkxeVpHWXRjM2x1ZEdGNExXNXpJeUlLSUNBZ2VHMXNibk02YzNablBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SUtJQ0FnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUNCNGJXeHVjenBwYm10elkyRndaVDBpYUhSMGNEb3ZMM2QzZHk1cGJtdHpZMkZ3WlM1dmNtY3ZibUZ0WlhOd1lXTmxjeTlwYm10elkyRndaU0lLSUNBZ2RtVnljMmx2YmowaU1TNHhJZ29nSUNCM2FXUjBhRDBpTmpneExqazJNalV5SWdvZ0lDQm9aV2xuYUhROUlqRTROeTQxSWdvZ0lDQnBaRDBpYzNabk1pSUtJQ0FnZUcxc09uTndZV05sUFNKd2NtVnpaWEoyWlNJK1BHMWxkR0ZrWVhSaENpQWdJQ0FnYVdROUltMWxkR0ZrWVhSaE9DSStQSEprWmpwU1JFWStQR05qT2xkdmNtc0tJQ0FnSUNBZ0lDQWdjbVJtT21GaWIzVjBQU0lpUGp4a1l6cG1iM0p0WVhRK2FXMWhaMlV2YzNabkszaHRiRHd2WkdNNlptOXliV0YwUGp4a1l6cDBlWEJsQ2lBZ0lDQWdJQ0FnSUNBZ2NtUm1PbkpsYzI5MWNtTmxQU0pvZEhSd09pOHZjSFZ5YkM1dmNtY3ZaR012WkdOdGFYUjVjR1V2VTNScGJHeEpiV0ZuWlNJZ0x6NDhMMk5qT2xkdmNtcytQQzl5WkdZNlVrUkdQand2YldWMFlXUmhkR0UrUEdSbFpuTUtJQ0FnSUNCcFpEMGlaR1ZtY3pZaVBqeGpiR2x3VUdGMGFBb2dJQ0FnSUNBZ2FXUTlJbU5zYVhCUVlYUm9NVGdpUGp4d1lYUm9DaUFnSUNBZ0lDQWdJR1E5SWswZ01Dd3hOVEF3SURBc01DQnNJRFUwTlRVdU56UXNNQ0F3TERFMU1EQWdUQ0F3TERFMU1EQWdlaUlLSUNBZ0lDQWdJQ0FnYVc1cmMyTmhjR1U2WTI5dWJtVmpkRzl5TFdOMWNuWmhkSFZ5WlQwaU1DSUtJQ0FnSUNBZ0lDQWdhV1E5SW5CaGRHZ3lNQ0lnTHo0OEwyTnNhWEJRWVhSb1Bqd3ZaR1ZtY3o0OFp3b2dJQ0FnSUhSeVlXNXpabTl5YlQwaWJXRjBjbWw0S0RFdU1qVXNNQ3d3TEMweExqSTFMREFzTVRnM0xqVXBJZ29nSUNBZ0lHbGtQU0puTVRBaVBqeG5DaUFnSUNBZ0lDQjBjbUZ1YzJadmNtMDlJbk5qWVd4bEtEQXVNU3d3TGpFcElnb2dJQ0FnSUNBZ2FXUTlJbWN4TWlJK1BHY0tJQ0FnSUNBZ0lDQWdhV1E5SW1jeE5DSStQR2NLSUNBZ0lDQWdJQ0FnSUNCamJHbHdMWEJoZEdnOUluVnliQ2dqWTJ4cGNGQmhkR2d4T0NraUNpQWdJQ0FnSUNBZ0lDQWdhV1E5SW1jeE5pSStQSEJoZEdnS0lDQWdJQ0FnSUNBZ0lDQWdJR1E5SW0wZ01UVTBOQ3cxT1RrdU5ETTBJR01nTUM0NU1pd3ROREF1TXpVeUlESTFMalk0TEMwNE1TNDJNRElnTnpFdU5UTXNMVGd4TGpZd01pQXlOeTQxTVN3d0lEUTNMalk0TERFeUxqZ3pNaUEyTVM0ME5Dd3pOUzQzTlRRZ01USXVPRE1zTWpJdU9UTWdNVEl1T0RNc05UWXVPRFV5SURFeUxqZ3pMRGd5TGpVeU55QnNJREFzTXpJNUxqRTROQ0F0TnpFdU5USXNNQ0F3TERFd05DNDFORE1nTWpZMkxqZ3pMREFnTUN3dE1UQTBMalUwTXlBdE56QXVOaXd3SURBc0xUTTBOQzQzTnlCaklEQXNMVFU0TGpZNU1TQXRNeTQyT0N3dE1UQTBMalV6TVNBdE5EUXVPVE1zTFRFMU1pNHlNVGdnTFRNMkxqWTRMQzAwTWk0eE9DQXRPVFl1TWpnc0xUWTJMakF5SUMweE5UTXVNVFFzTFRZMkxqQXlJQzB4TVRjdU16Y3NNQ0F0TWpBM0xqSTBMRGMzTGprME1TQXRNakF5TGpZMExERTVOeTR4TkRVZ2JDQXhNekF1TWl3d0lnb2dJQ0FnSUNBZ0lDQWdJQ0FnYVc1cmMyTmhjR1U2WTI5dWJtVmpkRzl5TFdOMWNuWmhkSFZ5WlQwaU1DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsa1BTSndZWFJvTWpJaUNpQWdJQ0FnSUNBZ0lDQWdJQ0J6ZEhsc1pUMGlabWxzYkRvak9HRTBNVGd5TzJacGJHd3RiM0JoWTJsMGVUb3hPMlpwYkd3dGNuVnNaVHB1YjI1NlpYSnZPM04wY205clpUcHViMjVsSWlBdlBqeHdZWFJvQ2lBZ0lDQWdJQ0FnSUNBZ0lDQmtQU0p0SURJek1ERXVOQ3cyTmpJdU5qazFJR01nTUN3NE1DNDNNRE1nTFRZMkxqazBMREUwTlM0NE1UTWdMVEUwTnk0Mk15d3hORFV1T0RFeklDMDRNeTQwTkN3d0lDMHhORGN1TmpNc0xUWTRMamM0TVNBdE1UUTNMall6TEMweE5URXVNekF4SURBc0xUYzVMamM0TlNBMk5pNDVOQ3d0TVRRMUxqZ3dNU0F4TkRVdU9Dd3RNVFExTGpnd01TQTROQzR6TlN3d0lERTBPUzQwTml3Mk55NDROVElnTVRRNUxqUTJMREUxTVM0eU9Ea2dlaUJ0SUMweExqZ3pMQzB4T0RFdU5UUTNJR01nTFRNMUxqYzNMQzAxTkM0d09UY2dMVGt6TGpVekxDMDNPQzQ0TlRrZ0xURTFOeTQzTWl3dE56Z3VPRFU1SUMweE5EQXVNeXd3SUMweU5URXVNalFzTVRFMkxqUTBPU0F0TWpVeExqSTBMREkxTkM0NU1UZ2dNQ3d4TkRJdU1USTVJREV4TXk0M0xESTJNQzQwTVNBeU5UWXVOelFzTWpZd0xqUXhJRFl6TGpJM0xEQWdNVEU0TGpJNUxDMHlPUzR6TXpZZ01UVXlMakl5TEMwNE1pNDFNak1nYkNBd0xEWTVMalk0TnlBeE56VXVNVFFzTUNBd0xDMHhNRFF1TlRJM0lDMDJNUzQwTkN3d0lEQXNMVEk0TUM0MU9UZ2dOakV1TkRRc01DQXdMQzB4TURRdU5USTNJQzB4TnpVdU1UUXNNQ0F3TERZMkxqQXhPU0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbHVhM05qWVhCbE9tTnZibTVsWTNSdmNpMWpkWEoyWVhSMWNtVTlJakFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBaRDBpY0dGMGFESTBJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2MzUjViR1U5SW1acGJHdzZJemhoTkRFNE1qdG1hV3hzTFc5d1lXTnBkSGs2TVR0bWFXeHNMWEoxYkdVNmJtOXVlbVZ5Ynp0emRISnZhMlU2Ym05dVpTSWdMejQ4Y0dGMGFBb2dJQ0FnSUNBZ0lDQWdJQ0FnWkQwaWJTQXlOakl5TGpNekxEVTFOeTR5TlRnZ1l5QXpMalkzTEMwME5DNHdNVFlnTXpNdU1ERXNMVGN6TGpNME9DQTNPQzQ0Tml3dE56TXVNelE0SURNekxqa3pMREFnTmpZdU9UTXNNak11T0RJMElEWTJMamt6TERZd0xqVXdOQ0F3TERRNExqWXdOaUF0TkRVdU9EUXNOVFl1T0RVMklDMDRNeTQwTkN3Mk5pNDVOREVnTFRnMUxqSTRMREl5TGpBd05DQXRNVGM0TGpneExEUTRMall3TmlBdE1UYzRMamd4TERFMU5TNDROemtnTUN3NU15NDFNellnTnpndU9EWXNNVFEzTGpZek15QXhOalV1T1Rnc01UUTNMall6TXlBME5Dd3dJRGd6TGpRekxDMDVMakUzTmlBeE1UQXVPVFFzTFRRMExqQXdPQ0JzSURBc016TXVPVEl5SURneUxqVXpMREFnTUN3dE1UTXlMamsyTlNBdE1UQTRMakl4TERBZ1l5QXRNUzQ0TXl3ek5DNDROVFlnTFRJNExqUXlMRFUzTGpjM05DQXROak11TWpZc05UY3VOemMwSUMwek1DNHlOaXd3SUMwMk1pNHpOU3d0TVRjdU5ESXlJQzAyTWk0ek5Td3ROVEV1TXpRNElEQXNMVFExTGpnME55QTBOQzQ1TXl3dE5UVXVPVE1nT0RBdU5qa3NMVFkwTGpFNElEZzRMakF5TEMweU1DNHhOelVnTVRneUxqUTNMQzAwTnk0Mk9UVWdNVGd5TGpRM0xDMHhOVGN1TnpNMElEQXNMVGs1TGpBeU55QXRPRE11TkRRc0xURTFOQzR3TXprZ0xURTNOUzR4TXl3dE1UVTBMakF6T1NBdE5Ea3VOVE1zTUNBdE9UUXVORFlzTVRVdU5UZ3lJQzB4TWpZdU5UVXNOVE11TVRnZ2JDQXdMQzAwTUM0ek5DQXRPRFV1TWpjc01DQXdMREUwTWk0eE1qa2dNVEUwTGpZeUxEQWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcGJtdHpZMkZ3WlRwamIyNXVaV04wYjNJdFkzVnlkbUYwZFhKbFBTSXdJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXUTlJbkJoZEdneU5pSUtJQ0FnSUNBZ0lDQWdJQ0FnSUhOMGVXeGxQU0ptYVd4c09pTTRZVFF4T0RJN1ptbHNiQzF2Y0dGamFYUjVPakU3Wm1sc2JDMXlkV3hsT201dmJucGxjbTg3YzNSeWIydGxPbTV2Ym1VaUlDOCtQSEJoZEdnS0lDQWdJQ0FnSUNBZ0lDQWdJR1E5SW0wZ01qazRPQzR4T0N3NE1EQXVNalUwSUMwMk15NHlOaXd3SURBc01UQTBMalV5TnlBeE5qVXVNRFVzTUNBd0xDMDNNeTR6TlRVZ1l5QXpNUzR4T0N3MU1TNHpORGNnTnpndU9EWXNPRFV1TWpjM0lERTBNUzR5TVN3NE5TNHlOemNnTmpjdU9EVXNNQ0F4TWpRdU56RXNMVFF4TGpJMU9DQXhOVEl1TWpFc0xURXdNaTQyT1RrZ01qWXVOaXcyTWk0ek5URWdPVEl1TmpJc01UQXlMalk1T1NBeE5qQXVORGNzTVRBeUxqWTVPU0ExTXk0eE9Td3dJREV3TlM0ME5pd3RNaklnTVRReExqSXhMQzAyTWk0ek5URWdNemd1TlRJc0xUUTBMamt6T0NBek9DNDFNaXd0T1RNdU5UTXlJRE00TGpVeUxDMHhORGt1TkRVM0lHd2dNQ3d0TVRnMUxqSXpPU0EyTXk0eU55d3dJREFzTFRFd05DNDFNamNnTFRJek9DNDBNaXd3SURBc01UQTBMalV5TnlBMk15NHlPQ3d3SURBc01UVTNMamN4TlNCaklEQXNNekl1TVRBeUlEQXNOakF1TlRJM0lDMHhOQzQyTnl3NE9DNDVOVGNnTFRFNExqTTBMREkyTGpVNE1pQXRORGd1TmpFc05EQXVNelEwSUMwM09TNDNOeXcwTUM0ek5EUWdMVE13TGpJMkxEQWdMVFl6TGpJNExDMHhNaTQ0TkRRZ0xUZ3lMalV6TEMwek5pNDJOeklnTFRJeUxqa3pMQzB5T1M0ek5UVWdMVEl5TGprekxDMDFOaTQ0TmpNZ0xUSXlMamt6TEMwNU1pNDJNamtnYkNBd0xDMHhOVGN1TnpFMUlEWXpMakkzTERBZ01Dd3RNVEEwTGpVeU55QXRNak00TGpReExEQWdNQ3d4TURRdU5USTNJRFl6TGpJNExEQWdNQ3d4TlRBdU16Z3pJR01nTUN3eU9TNHpORGdnTUN3Mk5pNHdNak1nTFRFMExqWTNMRGt4TGpZNU9TQXRNVFV1TlRrc01qa3VNek0ySUMwME55NDJPU3cwTkM0NU16UWdMVGd3TGpjc05EUXVPVE0wSUMwek1TNHhPQ3d3SUMwMU55NDNOeXd0TVRFdU1EQTRJQzAzTnk0NU5Dd3RNelV1TnpjMElDMHlOQzQzTnl3dE16QXVNalV6SUMweU5pNDJMQzAyTWk0ek5ETWdMVEkyTGpZc0xUazVMamswTVNCc0lEQXNMVEUxTVM0ek1ERWdOak11TWpjc01DQXdMQzB4TURRdU5USTNJQzB5TXpndU5Dd3dJREFzTVRBMExqVXlOeUEyTXk0eU5pd3dJREFzTWpnd0xqVTVPQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbHVhM05qWVhCbE9tTnZibTVsWTNSdmNpMWpkWEoyWVhSMWNtVTlJakFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBaRDBpY0dGMGFESTRJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2MzUjViR1U5SW1acGJHdzZJemhoTkRFNE1qdG1hV3hzTFc5d1lXTnBkSGs2TVR0bWFXeHNMWEoxYkdVNmJtOXVlbVZ5Ynp0emRISnZhMlU2Ym05dVpTSWdMejQ4Y0dGMGFBb2dJQ0FnSUNBZ0lDQWdJQ0FnWkQwaWJTQXpPVGs0TGpZMkxEazFNUzQxTkRjZ0xURXhNUzQ0Tnl3d0lEQXNNVEU0TGpJNU15QXhNVEV1T0Rjc01DQXdMQzB4TVRndU1qa3pJSG9nYlNBd0xDMDBNekV1T0RreElEWXpMakkzTERBZ01Dd3RNVEEwTGpVeU55QXRNak01TGpNekxEQWdNQ3d4TURRdU5USTNJRFkwTGpFNUxEQWdNQ3d5T0RBdU5UazRJQzAyTXk0eU55d3dJREFzTVRBMExqVXlOeUF4TnpVdU1UUXNNQ0F3TEMwek9EVXVNVEkxSWdvZ0lDQWdJQ0FnSUNBZ0lDQWdhVzVyYzJOaGNHVTZZMjl1Ym1WamRHOXlMV04xY25aaGRIVnlaVDBpTUNJS0lDQWdJQ0FnSUNBZ0lDQWdJR2xrUFNKd1lYUm9NekFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnpkSGxzWlQwaVptbHNiRG9qT0dFME1UZ3lPMlpwYkd3dGIzQmhZMmwwZVRveE8yWnBiR3d0Y25Wc1pUcHViMjU2WlhKdk8zTjBjbTlyWlRwdWIyNWxJaUF2UGp4d1lYUm9DaUFnSUNBZ0lDQWdJQ0FnSUNCa1BTSnRJRFF4TlRrdU1USXNPREF3TGpJMU5DQXROak11TWpjc01DQXdMREV3TkM0MU1qY2dNVGMxTGpFMExEQWdNQ3d0TmprdU5qZzNJR01nTWprdU16VXNOVFF1TVRBeElEZzBMak0yTERnd0xqWTVPU0F4TkRRdU9EY3NPREF1TmprNUlEVXpMakU1TERBZ01UQTFMalExTEMweU1pNHdNVFlnTVRReExqSXlMQzAyTUM0MU1qY2dOREF1TXpRc0xUUTBMamt6TkNBME1TNHlOaXd0T0RndU1ETXlJRFF4TGpJMkxDMHhORE11T1RVM0lHd2dNQ3d0TVRreExqWTFNeUEyTXk0eU55d3dJREFzTFRFd05DNDFNamNnTFRJek9DNDBMREFnTUN3eE1EUXVOVEkzSURZekxqSTJMREFnTUN3eE5UZ3VOak0zSUdNZ01Dd3pNQzR5TmpJZ01DdzJNUzQwTXpRZ0xURTVMakkyTERnNExqQXpOU0F0TWpBdU1UY3NNall1TlRneUlDMDFNeTR4T0N3ek9TNDBNVFFnTFRnMkxqRTVMRE01TGpReE5DQXRNek11T1RNc01DQXROamd1Tnpjc0xURXpMamMxSUMwNE9DNDVOQ3d0TkRFdU1qVWdMVEl4TGpBNUxDMHlOeTQxSUMweU1TNHdPU3d0TmprdU5qZzNJQzB5TVM0d09Td3RNVEF5TGpjd055QnNJREFzTFRFME1pNHhNamtnTmpNdU1qWXNNQ0F3TEMweE1EUXVOVEkzSUMweU16Z3VOQ3d3SURBc01UQTBMalV5TnlBMk15NHlOeXd3SURBc01qZ3dMalU1T0NJS0lDQWdJQ0FnSUNBZ0lDQWdJR2x1YTNOallYQmxPbU52Ym01bFkzUnZjaTFqZFhKMllYUjFjbVU5SWpBaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwWkQwaWNHRjBhRE15SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdjM1I1YkdVOUltWnBiR3c2SXpoaE5ERTRNanRtYVd4c0xXOXdZV05wZEhrNk1UdG1hV3hzTFhKMWJHVTZibTl1ZW1WeWJ6dHpkSEp2YTJVNmJtOXVaU0lnTHo0OGNHRjBhQW9nSUNBZ0lDQWdJQ0FnSUNBZ1pEMGliU0ExTURneUxqUTRMRGN3TXk0NU5qVWdZeUF0TVRrdU1qUXNOekF1TmpBMUlDMDRNUzQyTERFeE5TNDFORGNnTFRFMU5DNHdOQ3d4TVRVdU5UUTNJQzAyTmk0d05Dd3dJQzB4TWprdU15d3ROVEV1TXpRNElDMHhORE11TURVc0xURXhOUzQxTkRjZ2JDQXlPVGN1TURrc01DQjZJRzBnT0RVdU1qY3NMVEUwTkM0NE9ETWdZeUF0TXpndU5URXNMVGt6TGpVeU15QXRNVEk1TGpJM0xDMHhOVFl1TnpreklDMHlNekV1TURVc0xURTFOaTQzT1RNZ0xURTBNeTR3Tnl3d0lDMHlOVGN1Tmpnc01URXhMamczTVNBdE1qVTNMalk0TERJMU5TNDRNellnTUN3eE5EUXVPRGd6SURFd09TNHhNaXd5TmpFdU16STRJREkxTkM0NU1Td3lOakV1TXpJNElEWTNMamczTERBZ01UTTFMamN5TEMwek1DNHlOVGdnTVRnekxqTTVMQzAzT0M0NE5qTWdORGd1TmpJc0xUVXhMak0wTkNBMk9DNDNPU3d0TVRFekxqWTVOU0EyT0M0M09Td3RNVGd6TGpNNE15QnNJQzB6TGpZM0xDMHpPUzQwTXpRZ0xUTTVOaTR4TXl3d0lHTWdNVFF1Tmpjc0xUWTNMamcyTXlBM055NHdNeXd0TVRFM0xqTTJNeUF4TkRZdU56SXNMVEV4Tnk0ek5qTWdORGd1TlRrc01DQTVNQzQzTml3eE9DNHpNamdnTVRFNExqSTRMRFU0TGpZM01pQnNJREV4Tmk0ME5Dd3dJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXNXJjMk5oY0dVNlkyOXVibVZqZEc5eUxXTjFjblpoZEhWeVpUMGlNQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbGtQU0p3WVhSb016UWlDaUFnSUNBZ0lDQWdJQ0FnSUNCemRIbHNaVDBpWm1sc2JEb2pPR0UwTVRneU8yWnBiR3d0YjNCaFkybDBlVG94TzJacGJHd3RjblZzWlRwdWIyNTZaWEp2TzNOMGNtOXJaVHB1YjI1bElpQXZQanh3WVhSb0NpQWdJQ0FnSUNBZ0lDQWdJQ0JrUFNKdElEWTVNQzQ0T1RVc09EVXdMamN3TXlBNU1DNDNOU3d3SURJeUxqVTBNeXd6TVM0d016VWdNQ3d5TkRNdU1USXlJQzB4TXpVdU9ESTVMREFnTUN3dE1qUXpMakUwTVNBeU1pNDFNellzTFRNeExqQXhOaUlLSUNBZ0lDQWdJQ0FnSUNBZ0lHbHVhM05qWVhCbE9tTnZibTVsWTNSdmNpMWpkWEoyWVhSMWNtVTlJakFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBaRDBpY0dGMGFETTJJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2MzUjViR1U5SW1acGJHdzZJemhoTkRFNE1qdG1hV3hzTFc5d1lXTnBkSGs2TVR0bWFXeHNMWEoxYkdVNmJtOXVlbVZ5Ynp0emRISnZhMlU2Ym05dVpTSWdMejQ4Y0dGMGFBb2dJQ0FnSUNBZ0lDQWdJQ0FnWkQwaWJTQTJNekl1TXprMUxEYzBNaTR5TlRnZ01qZ3VNRE01TERnMkxqTXdOQ0F0TWpJdU5UVXhMRE14TGpBMElDMHlNekV1TWpJekxEYzFMakV5T0NBdE5ERXVPVGMyTEMweE1qa3VNVGd6SURJek1TNHlOVGNzTFRjMUxqRXpOeUF6Tmk0ME5UUXNNVEV1T0RRNElnb2dJQ0FnSUNBZ0lDQWdJQ0FnYVc1cmMyTmhjR1U2WTI5dWJtVmpkRzl5TFdOMWNuWmhkSFZ5WlQwaU1DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsa1BTSndZWFJvTXpnaUNpQWdJQ0FnSUNBZ0lDQWdJQ0J6ZEhsc1pUMGlabWxzYkRvak9HRTBNVGd5TzJacGJHd3RiM0JoWTJsMGVUb3hPMlpwYkd3dGNuVnNaVHB1YjI1NlpYSnZPM04wY205clpUcHViMjVsSWlBdlBqeHdZWFJvQ2lBZ0lDQWdJQ0FnSUNBZ0lDQmtQU0p0SURjeE55NDBORGtzTmpVekxqRXdOU0F0TnpNdU5ERXNOVE11TXpZZ0xUTTJMalE0T0N3dE1URXVPRGMxSUMweE5ESXVPVEF6TEMweE9UWXVOamt5SURFd09TNDRPRE1zTFRjNUxqZ3lPQ0F4TkRJdU9URTRMREU1Tmk0M01ETWdNQ3d6T0M0ek16SWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcGJtdHpZMkZ3WlRwamIyNXVaV04wYjNJdFkzVnlkbUYwZFhKbFBTSXdJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXUTlJbkJoZEdnME1DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUhOMGVXeGxQU0ptYVd4c09pTTRZVFF4T0RJN1ptbHNiQzF2Y0dGamFYUjVPakU3Wm1sc2JDMXlkV3hsT201dmJucGxjbTg3YzNSeWIydGxPbTV2Ym1VaUlDOCtQSEJoZEdnS0lDQWdJQ0FnSUNBZ0lDQWdJR1E5SW0wZ09ESTRMalV5TERjd05pNDBOalVnTFRjekxqUXlOaXd0TlRNdU16UWdNQzR3TVRFc0xUTTRMak0xT1NCTUlEZzVPQzR3TURRc05ERTRMakEzSURFd01EY3VPU3cwT1RjdU9EazRJRGcyTkM0NU56TXNOamswTGpZd09TQTRNamd1TlRJc056QTJMalEyTlNJS0lDQWdJQ0FnSUNBZ0lDQWdJR2x1YTNOallYQmxPbU52Ym01bFkzUnZjaTFqZFhKMllYUjFjbVU5SWpBaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwWkQwaWNHRjBhRFF5SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdjM1I1YkdVOUltWnBiR3c2SXpoaE5ERTRNanRtYVd4c0xXOXdZV05wZEhrNk1UdG1hV3hzTFhKMWJHVTZibTl1ZW1WeWJ6dHpkSEp2YTJVNmJtOXVaU0lnTHo0OGNHRjBhQW9nSUNBZ0lDQWdJQ0FnSUNBZ1pEMGliU0E0TVRJdU1EZzJMRGd5T0M0MU9EWWdNamd1TURVMUxDMDROaTR6TWlBek5pNDBPRFFzTFRFeExqZ3pOaUF5TXpFdU1qSTFMRGMxTGpFeE55QXROREV1T1Rjc01USTVMakU0TXlBdE1qTXhMakl6T1N3dE56VXVNVFFnTFRJeUxqVTFOU3d0TXpFdU1EQTBJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXNXJjMk5oY0dVNlkyOXVibVZqZEc5eUxXTjFjblpoZEhWeVpUMGlNQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbGtQU0p3WVhSb05EUWlDaUFnSUNBZ0lDQWdJQ0FnSUNCemRIbHNaVDBpWm1sc2JEb2pPR0UwTVRneU8yWnBiR3d0YjNCaFkybDBlVG94TzJacGJHd3RjblZzWlRwdWIyNTZaWEp2TzNOMGNtOXJaVHB1YjI1bElpQXZQanh3WVhSb0NpQWdJQ0FnSUNBZ0lDQWdJQ0JrUFNKdElEY3pOaTR6TURFc01UTXpOUzQ0T0NCaklDMHpNak11TURRM0xEQWdMVFU0TlM0NE56VXNMVEkyTWk0M09DQXROVGcxTGpnM05Td3ROVGcxTGpjNE1pQXdMQzB6TWpNdU1URTRJREkyTWk0NE1qZ3NMVFU0TlM0NU56Y2dOVGcxTGpnM05Td3ROVGcxTGprM055QXpNak11TURFNUxEQWdOVGcxTGpnd09Td3lOakl1T0RVNUlEVTROUzQ0TURrc05UZzFMamszTnlBd0xETXlNeTR3TURJZ0xUSTJNaTQzT1N3MU9EVXVOemd5SUMwMU9EVXVPREE1TERVNE5TNDNPRElnYkNBd0xEQWdlaUJ0SURBc0xURXhPQzQyTVNCaklESTFOeTQ1TnpJc01DQTBOamN1TVRnNUxDMHlNRGt1TVRNZ05EWTNMakU0T1N3dE5EWTNMakUzTWlBd0xDMHlOVGd1TVRJNUlDMHlNRGt1TWpFM0xDMDBOamN1TXpRNElDMDBOamN1TVRnNUxDMDBOamN1TXpRNElDMHlOVGd1TURjMExEQWdMVFEyTnk0eU5UUXNNakE1TGpJeE9TQXRORFkzTGpJMU5DdzBOamN1TXpRNElEQXNNalU0TGpBME1pQXlNRGt1TVRnc05EWTNMakUzTWlBME5qY3VNalUwTERRMk55NHhOeklpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBibXR6WTJGd1pUcGpiMjV1WldOMGIzSXRZM1Z5ZG1GMGRYSmxQU0l3SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdhV1E5SW5CaGRHZzBOaUlLSUNBZ0lDQWdJQ0FnSUNBZ0lITjBlV3hsUFNKbWFXeHNPaU00WVRReE9ESTdabWxzYkMxdmNHRmphWFI1T2pFN1ptbHNiQzF5ZFd4bE9tNXZibnBsY204N2MzUnliMnRsT201dmJtVWlJQzgrUEhCaGRHZ0tJQ0FnSUNBZ0lDQWdJQ0FnSUdROUltMGdNVEE1TVM0eE15dzJNVGt1T0RneklDMHhOelV1TnpjeExEVTNMakV5TVNBeE1TNDJNamtzTXpVdU9EQTRJREUzTlM0M05qSXNMVFUzTGpFeU1TQXRNVEV1TmpJc0xUTTFMamd3T0NJS0lDQWdJQ0FnSUNBZ0lDQWdJR2x1YTNOallYQmxPbU52Ym01bFkzUnZjaTFqZFhKMllYUjFjbVU5SWpBaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwWkQwaWNHRjBhRFE0SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdjM1I1YkdVOUltWnBiR3c2SXpoaE5ERTRNanRtYVd4c0xXOXdZV05wZEhrNk1UdG1hV3hzTFhKMWJHVTZibTl1ZW1WeWJ6dHpkSEp2YTJVNmJtOXVaU0lnTHo0OGNHRjBhQW9nSUNBZ0lDQWdJQ0FnSUNBZ1pEMGlUU0E0TmpZdU9UVTNMRGt3TWk0d056UWdPRE0yTGpVc09USTBMakU1T1NBNU5EVXVNVEl4TERFd056TXVOek1nT1RjMUxqVTROaXd4TURVeExqWXhJRGcyTmk0NU5UY3NPVEF5TGpBM05DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsdWEzTmpZWEJsT21OdmJtNWxZM1J2Y2kxamRYSjJZWFIxY21VOUlqQWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcFpEMGljR0YwYURVd0lnb2dJQ0FnSUNBZ0lDQWdJQ0FnYzNSNWJHVTlJbVpwYkd3Nkl6aGhOREU0TWp0bWFXeHNMVzl3WVdOcGRIazZNVHRtYVd4c0xYSjFiR1U2Ym05dWVtVnlienR6ZEhKdmEyVTZibTl1WlNJZ0x6NDhjR0YwYUFvZ0lDQWdJQ0FnSUNBZ0lDQWdaRDBpVFNBMk1EY3VORFkxTERrd015NDBORFVnTkRrNExqZzFOU3d4TURVeUxqazNJRFV5T1M0ek1pd3hNRGMxTGpFZ05qTTNMamt6TERreU5TNDFOallnTmpBM0xqUTJOU3c1TURNdU5EUTFJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXNXJjMk5oY0dVNlkyOXVibVZqZEc5eUxXTjFjblpoZEhWeVpUMGlNQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbGtQU0p3WVhSb05USWlDaUFnSUNBZ0lDQWdJQ0FnSUNCemRIbHNaVDBpWm1sc2JEb2pPR0UwTVRneU8yWnBiR3d0YjNCaFkybDBlVG94TzJacGJHd3RjblZzWlRwdWIyNTZaWEp2TzNOMGNtOXJaVHB1YjI1bElpQXZQanh3WVhSb0NpQWdJQ0FnSUNBZ0lDQWdJQ0JrUFNKdElETTRNQzQyT0Rnc05qSXlMakV5T1NBdE1URXVOakkyTERNMUxqZ3dNU0F4TnpVdU56VTRMRFUzTGpBNUlERXhMall5TVN3dE16VXVPREF4SUMweE56VXVOelV6TEMwMU55NHdPU0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbHVhM05qWVhCbE9tTnZibTVsWTNSdmNpMWpkWEoyWVhSMWNtVTlJakFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBaRDBpY0dGMGFEVTBJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2MzUjViR1U5SW1acGJHdzZJemhoTkRFNE1qdG1hV3hzTFc5d1lXTnBkSGs2TVR0bWFXeHNMWEoxYkdVNmJtOXVlbVZ5Ynp0emRISnZhMlU2Ym05dVpTSWdMejQ4Y0dGMGFBb2dJQ0FnSUNBZ0lDQWdJQ0FnWkQwaWJTQTNNVFl1TWpnNUxETTNOaTQxT1NBek55NDJOREEyTERBZ01Dd3hPRFF1T0RFMklDMHpOeTQyTkRBMkxEQWdNQ3d0TVRnMExqZ3hOaUI2SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdhVzVyYzJOaGNHVTZZMjl1Ym1WamRHOXlMV04xY25aaGRIVnlaVDBpTUNJS0lDQWdJQ0FnSUNBZ0lDQWdJR2xrUFNKd1lYUm9OVFlpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnpkSGxzWlQwaVptbHNiRG9qT0dFME1UZ3lPMlpwYkd3dGIzQmhZMmwwZVRveE8yWnBiR3d0Y25Wc1pUcHViMjU2WlhKdk8zTjBjbTlyWlRwdWIyNWxJaUF2UGp3dlp6NDhMMmMrUEM5blBqd3ZaejQ4TDNOMlp6ND1cXFwiKSBuby1yZXBlYXQsIG5vbmU7XFxuICAtbW96LWJhY2tncm91bmQtc2l6ZTogMTAwJTtcXG4gIC1vLWJhY2tncm91bmQtc2l6ZTogMTAwJTtcXG4gIC13ZWJraXQtYmFja2dyb3VuZC1zaXplOiAxMDAlO1xcbiAgYmFja2dyb3VuZC1zaXplOiAxMDAlO1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBmbG9hdDogbGVmdDtcXG4gIHdpZHRoOiA5MHB4O1xcbiAgaGVpZ2h0OiAyNXB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhbm5lciAuamFzbWluZS12ZXJzaW9uIHtcXG4gIG1hcmdpbi1sZWZ0OiAxNHB4O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgdG9wOiA2cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgI2phc21pbmVfY29udGVudCB7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICByaWdodDogMTAwJTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS12ZXJzaW9uIHtcXG4gIGNvbG9yOiAjYWFhO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhbm5lciB7XFxuICBtYXJnaW4tdG9wOiAxNHB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWR1cmF0aW9uIHtcXG4gIGNvbG9yOiAjZmZmO1xcbiAgZmxvYXQ6IHJpZ2h0O1xcbiAgbGluZS1oZWlnaHQ6IDI4cHg7XFxuICBwYWRkaW5nLXJpZ2h0OiA5cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkge1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIG1hcmdpbjogMTRweCAwO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGhlaWdodDogMTBweDtcXG4gIHdpZHRoOiAxNHB4O1xcbiAgZm9udC1zaXplOiAxNnB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpLmphc21pbmUtcGFzc2VkIHtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaS5qYXNtaW5lLXBhc3NlZDpiZWZvcmUge1xcbiAgY29sb3I6ICMwMDcwNjk7XFxuICBjb250ZW50OiBcXFwi4oCiXFxcIjtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaS5qYXNtaW5lLWZhaWxlZCB7XFxuICBsaW5lLWhlaWdodDogOXB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpLmphc21pbmUtZmFpbGVkOmJlZm9yZSB7XFxuICBjb2xvcjogI2NhM2ExMTtcXG4gIGNvbnRlbnQ6IFxcXCLDl1xcXCI7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIG1hcmdpbi1sZWZ0OiAtMXB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpLmphc21pbmUtZXhjbHVkZWQge1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpLmphc21pbmUtZXhjbHVkZWQ6YmVmb3JlIHtcXG4gIGNvbG9yOiAjYmFiYWJhO1xcbiAgY29udGVudDogXFxcIuKAolxcXCI7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkgbGkuamFzbWluZS1leGNsdWRlZC1uby1kaXNwbGF5IHtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkgbGkuamFzbWluZS1wZW5kaW5nIHtcXG4gIGxpbmUtaGVpZ2h0OiAxN3B4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpLmphc21pbmUtcGVuZGluZzpiZWZvcmUge1xcbiAgY29sb3I6ICNiYTlkMzc7XFxuICBjb250ZW50OiBcXFwiKlxcXCI7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkgbGkuamFzbWluZS1lbXB0eSB7XFxuICBmb250LXNpemU6IDE0cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkgbGkuamFzbWluZS1lbXB0eTpiZWZvcmUge1xcbiAgY29sb3I6ICNiYTlkMzc7XFxuICBjb250ZW50OiBcXFwi4oCiXFxcIjtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1ydW4tb3B0aW9ucyB7XFxuICBmbG9hdDogcmlnaHQ7XFxuICBtYXJnaW4tcmlnaHQ6IDVweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICM4YTQxODI7XFxuICBjb2xvcjogIzhhNDE4MjtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGxpbmUtaGVpZ2h0OiAyMHB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXJ1bi1vcHRpb25zIC5qYXNtaW5lLXRyaWdnZXIge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgcGFkZGluZzogOHB4IDE2cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtcnVuLW9wdGlvbnMgLmphc21pbmUtcGF5bG9hZCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBkaXNwbGF5OiBub25lO1xcbiAgcmlnaHQ6IC0xcHg7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjOGE0MTgyO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VlZTtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuICBwYWRkaW5nOiA0cHggOHB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXJ1bi1vcHRpb25zIC5qYXNtaW5lLXBheWxvYWQuamFzbWluZS1vcGVuIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhciB7XFxuICBsaW5lLWhlaWdodDogMjhweDtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgY29sb3I6ICNlZWU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFyLmphc21pbmUtZmFpbGVkLCAuamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhci5qYXNtaW5lLWVycm9yZWQge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2NhM2ExMTtcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZWVlO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhci5qYXNtaW5lLXBhc3NlZCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDA3MDY5O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhci5qYXNtaW5lLWluY29tcGxldGUge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2JhYmFiYTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYXIuamFzbWluZS1za2lwcGVkIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNiYWJhYmE7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFyLmphc21pbmUtd2FybmluZyB7XFxuICBtYXJnaW4tdG9wOiAxNHB4O1xcbiAgbWFyZ2luLWJvdHRvbTogMTRweDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNiYTlkMzc7XFxuICBjb2xvcjogIzMzMztcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYXIuamFzbWluZS1tZW51IHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICBjb2xvcjogI2FhYTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYXIuamFzbWluZS1tZW51IGEge1xcbiAgY29sb3I6ICMzMzM7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFyIGEge1xcbiAgY29sb3I6IHdoaXRlO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyLmphc21pbmUtc3BlYy1saXN0IC5qYXNtaW5lLWJhci5qYXNtaW5lLW1lbnUuamFzbWluZS1mYWlsdXJlLWxpc3QsXFxuLmphc21pbmVfaHRtbC1yZXBvcnRlci5qYXNtaW5lLXNwZWMtbGlzdCAuamFzbWluZS1yZXN1bHRzIC5qYXNtaW5lLWZhaWx1cmVzIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIuamFzbWluZS1mYWlsdXJlLWxpc3QgLmphc21pbmUtYmFyLmphc21pbmUtbWVudS5qYXNtaW5lLXNwZWMtbGlzdCxcXG4uamFzbWluZV9odG1sLXJlcG9ydGVyLmphc21pbmUtZmFpbHVyZS1saXN0IC5qYXNtaW5lLXN1bW1hcnkge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1yZXN1bHRzIHtcXG4gIG1hcmdpbi10b3A6IDE0cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3VtbWFyeSB7XFxuICBtYXJnaW4tdG9wOiAxNHB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1bW1hcnkgdWwge1xcbiAgbGlzdC1zdHlsZS10eXBlOiBub25lO1xcbiAgbWFyZ2luLWxlZnQ6IDE0cHg7XFxuICBwYWRkaW5nLXRvcDogMDtcXG4gIHBhZGRpbmctbGVmdDogMDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdW1tYXJ5IHVsLmphc21pbmUtc3VpdGUge1xcbiAgbWFyZ2luLXRvcDogN3B4O1xcbiAgbWFyZ2luLWJvdHRvbTogN3B4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1bW1hcnkgbGkuamFzbWluZS1wYXNzZWQgYSB7XFxuICBjb2xvcjogIzAwNzA2OTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdW1tYXJ5IGxpLmphc21pbmUtZmFpbGVkIGEge1xcbiAgY29sb3I6ICNjYTNhMTE7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3VtbWFyeSBsaS5qYXNtaW5lLWVtcHR5IGEge1xcbiAgY29sb3I6ICNiYTlkMzc7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3VtbWFyeSBsaS5qYXNtaW5lLXBlbmRpbmcgYSB7XFxuICBjb2xvcjogI2JhOWQzNztcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdW1tYXJ5IGxpLmphc21pbmUtZXhjbHVkZWQgYSB7XFxuICBjb2xvcjogI2JhYmFiYTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zcGVjcyBsaS5qYXNtaW5lLXBhc3NlZCBhOmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwi4oCiIFxcXCI7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3BlY3MgbGkuamFzbWluZS1mYWlsZWQgYTpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIsOXIFxcXCI7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3BlY3MgbGkuamFzbWluZS1lbXB0eSBhOmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwiKiBcXFwiO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXNwZWNzIGxpLmphc21pbmUtcGVuZGluZyBhOmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwi4oCiIFxcXCI7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3BlY3MgbGkuamFzbWluZS1leGNsdWRlZCBhOmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwi4oCiIFxcXCI7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZGVzY3JpcHRpb24gKyAuamFzbWluZS1zdWl0ZSB7XFxuICBtYXJnaW4tdG9wOiAwO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1aXRlIHtcXG4gIG1hcmdpbi10b3A6IDE0cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3VpdGUgYSB7XFxuICBjb2xvcjogIzMzMztcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1mYWlsdXJlcyAuamFzbWluZS1zcGVjLWRldGFpbCB7XFxuICBtYXJnaW4tYm90dG9tOiAyOHB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWZhaWx1cmVzIC5qYXNtaW5lLXNwZWMtZGV0YWlsIC5qYXNtaW5lLWRlc2NyaXB0aW9uIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNjYTNhMTE7XFxuICBjb2xvcjogd2hpdGU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZmFpbHVyZXMgLmphc21pbmUtc3BlYy1kZXRhaWwgLmphc21pbmUtZGVzY3JpcHRpb24gYSB7XFxuICBjb2xvcjogd2hpdGU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtcmVzdWx0LW1lc3NhZ2Uge1xcbiAgcGFkZGluZy10b3A6IDE0cHg7XFxuICBjb2xvcjogIzMzMztcXG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1yZXN1bHQtbWVzc2FnZSBzcGFuLmphc21pbmUtcmVzdWx0IHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN0YWNrLXRyYWNlIHtcXG4gIG1hcmdpbjogNXB4IDAgMCAwO1xcbiAgbWF4LWhlaWdodDogMjI0cHg7XFxuICBvdmVyZmxvdzogYXV0bztcXG4gIGxpbmUtaGVpZ2h0OiAxOHB4O1xcbiAgY29sb3I6ICM2NjY7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZGRkO1xcbiAgYmFja2dyb3VuZDogd2hpdGU7XFxuICB3aGl0ZS1zcGFjZTogcHJlO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWV4cGFuZGVyIGEge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBtYXJnaW4tbGVmdDogMTRweDtcXG4gIGNvbG9yOiBibHVlO1xcbiAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZXhwYW5kZXItY29udGVudHMge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1leHBhbmRlZCB7XFxuICBwYWRkaW5nLWJvdHRvbTogMTBweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1leHBhbmRlZCAuamFzbWluZS1leHBhbmRlci1jb250ZW50cyB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIG1hcmdpbi1sZWZ0OiAxNHB4O1xcbiAgcGFkZGluZzogNXB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWRlYnVnLWxvZyB7XFxuICBtYXJnaW46IDVweCAwIDAgMDtcXG4gIHBhZGRpbmc6IDVweDtcXG4gIGNvbG9yOiAjNjY2O1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2RkZDtcXG4gIGJhY2tncm91bmQ6IHdoaXRlO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWRlYnVnLWxvZyB0YWJsZSB7XFxuICBib3JkZXItc3BhY2luZzogMDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1kZWJ1Zy1sb2cgdGFibGUsIC5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZGVidWctbG9nIHRoLCAuamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWRlYnVnLWxvZyB0ZCB7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZGRkO1xcbn1cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9ub2RlX21vZHVsZXMvamFzbWluZS1jb3JlL2xpYi9qYXNtaW5lLWNvcmUvamFzbWluZS5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEsZ0JBQWdCO0FBQ2hCO0VBQ0Usa0JBQWtCO0FBQ3BCOztBQUVBO0VBQ0UsV0FBVztFQUNYLHNCQUFzQjtFQUN0QixZQUFZO0VBQ1osWUFBWTtFQUNaLGVBQWU7RUFDZixnREFBZ0Q7RUFDaEQsaUJBQWlCO0VBQ2pCLFdBQVc7QUFDYjtBQUNBO0VBQ0UscUJBQXFCO0FBQ3ZCO0FBQ0E7RUFDRSwwQkFBMEI7QUFDNUI7QUFDQTtFQUNFLFNBQVM7RUFDVCxpQkFBaUI7QUFDbkI7QUFDQTs7Ozs7Ozs7RUFRRSxpQkFBaUI7RUFDakIsa0JBQWtCO0FBQ3BCO0FBQ0E7RUFDRSxrQkFBa0I7QUFDcEI7QUFDQTtFQUNFLG15RUFBbXlFO0VBQ255RSxpa1hBQWlrWDtFQUNqa1gsMEJBQTBCO0VBQzFCLHdCQUF3QjtFQUN4Qiw2QkFBNkI7RUFDN0IscUJBQXFCO0VBQ3JCLGNBQWM7RUFDZCxXQUFXO0VBQ1gsV0FBVztFQUNYLFlBQVk7QUFDZDtBQUNBO0VBQ0UsaUJBQWlCO0VBQ2pCLGtCQUFrQjtFQUNsQixRQUFRO0FBQ1Y7QUFDQTtFQUNFLGVBQWU7RUFDZixXQUFXO0FBQ2I7QUFDQTtFQUNFLFdBQVc7QUFDYjtBQUNBO0VBQ0UsZ0JBQWdCO0FBQ2xCO0FBQ0E7RUFDRSxXQUFXO0VBQ1gsWUFBWTtFQUNaLGlCQUFpQjtFQUNqQixrQkFBa0I7QUFDcEI7QUFDQTtFQUNFLGdCQUFnQjtFQUNo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QUFpQjtBQUNuQjtBQUNBO0VBQ0UsaUJBQWlCO0FBQ25CO0FBQ0E7RUFDRSxzQkFBc0I7QUFDeEJcIixcInNvdXJjZXNDb250ZW50XCI6W1wiQGNoYXJzZXQgXFxcIlVURi04XFxcIjtcXG5ib2R5IHtcXG4gIG92ZXJmbG93LXk6IHNjcm9sbDtcXG59XFxuXFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlZWU7XFxuICBwYWRkaW5nOiA1cHg7XFxuICBtYXJnaW46IC04cHg7XFxuICBmb250LXNpemU6IDExcHg7XFxuICBmb250LWZhbWlseTogTW9uYWNvLCBcXFwiTHVjaWRhIENvbnNvbGVcXFwiLCBtb25vc3BhY2U7XFxuICBsaW5lLWhlaWdodDogMTRweDtcXG4gIGNvbG9yOiAjMzMzO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIGEge1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIGE6aG92ZXIge1xcbiAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgcCwgLmphc21pbmVfaHRtbC1yZXBvcnRlciBoMSwgLmphc21pbmVfaHRtbC1yZXBvcnRlciBoMiwgLmphc21pbmVfaHRtbC1yZXBvcnRlciBoMywgLmphc21pbmVfaHRtbC1yZXBvcnRlciBoNCwgLmphc21pbmVfaHRtbC1yZXBvcnRlciBoNSwgLmphc21pbmVfaHRtbC1yZXBvcnRlciBoNiB7XFxuICBtYXJnaW46IDA7XFxuICBsaW5lLWhlaWdodDogMTRweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYW5uZXIsXFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSxcXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1bW1hcnksXFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1yZXN1bHQtbWVzc2FnZSxcXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXNwZWMgLmphc21pbmUtZGVzY3JpcHRpb24sXFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zcGVjLWRldGFpbCAuamFzbWluZS1kZXNjcmlwdGlvbixcXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWFsZXJ0IC5qYXNtaW5lLWJhcixcXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN0YWNrLXRyYWNlIHtcXG4gIHBhZGRpbmctbGVmdDogOXB4O1xcbiAgcGFkZGluZy1yaWdodDogOXB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhbm5lciB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFubmVyIC5qYXNtaW5lLXRpdGxlIHtcXG4gIGJhY2tncm91bmQ6IHVybChcXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFGb0FBQUFaQ0FNQUFBQ0d1c255QUFBQ2RsQk1WRVgvLy8vL0FQK0FnSUNxVmFxQVFJQ1pNNW1BVllDU1NaS0FRSUNPT1k2QVRZQ0xSb3VBUUlDSk80bVNTWUNJUklpUFFJQ0hQSWVPUjRDR1E0YU1RSUNHUFlhTFJvQ0ZRNFdLUUlDUFBZV0pSWUNPUW9TSlFJQ05Qb1NJUklDTVFvU0hRSUNIUklDS1FvT0hRSUNLUG9PSk80T0pRWU9NUUlDTVE0Q0lRWUtMUUlDSVBvS0xRNENLUUlDTlBvS0pRSVNNUTRLSlFvU0xRWUtKUUlTTFE0S0lRb1NLUVlLSVFJQ0lRSVNNUW9TS1FZS0xRSU9MUW9PSlFZR0xRSU9LUUlPTVFvR0tRWU9MUVlHS1FJT0xRb0dKUVlPSlFJT0tRWUdKUUlPS1FvR0tRSUdMUUlLTFE0S0tRb0dMUVlLSlFJR0tRWUtKUUlHS1FJS0pRb0dLUVlLTFFJR0tRWUtMUUlPSlFvS0tRb09KUVlLS1FJT0pRb0tLUW9PS1FJT0xRb0tLUVlPTFFZS0pRSU9LUW9LS1FZS0tRb0tKUVlPS1FZS0xRSU9LUW9LTFFZT0tRWUtMUUlPSlFvR0tRWUtKUVlHSlFvR0tRWUtMUW9HTFFZR0tRb0dKUVlLS1FZR0pRSUtLUW9HSlFZS0xRSUtLUVlHTFFZS0tRWUdLUVlHS1FZS0pRWU9LUW9LSlFZT0tRWUtMUVlPTFFZT0tRWUtMUVlPS1FvS0tRWUtLUVlPS1FZT0pRWUtLUVlLTFFZS0tRSUtLUW9LS1FZS0tRWUtLUW9LSlFJS0tRWUtMUVlLS1FZS0tRSUtLUVlLS1FZS0tRWUtLUUlLS1FZS0pRWUdMUVlHS1FZS0tRWUtLUVlHS1FJS0tRWUdLUVlPSlFvS0tRWU9MUVlLS1FZT0tRb0tLUVlLS1FvS0tRWUtLUVlLSlFZS0xRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0pRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0xRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUttSURwRUFBQUEwWFJTVGxNQUFRSURCQVVHQndnSkNnc01EUTRQRUJFU0V4UVZGaGNZR1JvYkhCMGVIeUFpSXlRbEp5Y29LaXNzTFM0d01UUTFOamM0T1RvN1BEdytQMEJDUTBSSVNVcExURTFPVUZOVVZWZFlXRmxhVzE1ZllHRmlZMlpuYUdscWEyeHRiM0J4Y25OMGRuaDVlbnQ4Zlg1L2dJR0NoSVdJaW95TmpvK1FrWk9VbFphWW1acWJuSjJlb0tHaW82V21xS21zcmE2dnNMR3p0cmU0dWJxN3ZMMit3TUhEeE1qSnlzdk56cy9RMGRMVTF0ZlkyZHZjM3QvZzRlTGo1ZWJuNk9ucTYrenQ3dS93OHZQMDlmYjMrUG42Ky96OS92a1ZRWEFBQUFNYVNVUkJWSGhlNWRYeFYxTjFHTWZ4ejJBQmJEZ0lBbTVWREpPeVZESUpMVU1hVnBCV1VaVWFHYm1xb0dwWlJTaUdpUldwNktvWjVBQjBaWTUwUkltWlFJbGFoS2tNWVh2L1I5MGRCdkVUL3JKZk9yM091Yzh2OTl6UGVjNTl6dmY1NmordllLbFZpU2Y3MjUwWDRNcjNPMjlUZ3EwOEJkR0I0RGhjZWtFSjVZa1FLRnNnV1pkdGo5SnBWK0k4eFBqTEZxa3JzRUlxTzhQSFNwaXMzNmpXYXpjcWpFc2ZKamt2UnNzVlUzN1NkSU91NFhDZjV2RUpQc253SnBuUk5VOUpteGhNazhsMWdlaElycTdoVEZqek9EK1ZmODg2MjlxS01KVk5sdEluRmVSZXhSUXlKbE5lcWQxaUdEbFN6cklVSXlYYnlGZm0zUllwcmNRUmU3bHF0V3lHWWJmYzZkVDBSMnZtZE9Pa1gzdTU1QzFyUDM3ZnRpSCt0RGJ5NHIvUkJUMHc4VHlFa3IrZXBCOVhnUERtU1lZV2JyaEN1RllhSXl3M2ZEUUFYVG5Ta2grQU5vZmlIbVdmOWwrRlkxSTkwRmRRVGV0c3RPMDBvMjNub3Z6VnNKN3VCMy9DNVRrYmpSd1o1SmVyd1Y0aVJXcTlIRmJGTWFLL2QwVFlxYXlSaVFQdUl4eFMzQnU4SldVOTAvNjB0S2k3dmtoYXpuZXowYS9UYlZPS2o1Q2FPWmg2ZldHNi9MeXY5Qi9aTFIxZ3cvUy9mcGJlVkQzTUNXMWxpNlN2V0RPbjY1dHI5OS91dld0QlMwWERtNHMxdCtzT0hwRzBrcEJLeC9sNzd3T1NueExwY3g2VFhtWExUUFFPS1lPZjlRMWRmcjgvU0oybUZkQ3ZsMVlsOTNEaUhVWnZYZUxKYkdTell1NWdWSjJzbGJTYWtPUjhkeENxNWFkUTJvRkxxc0U5RXgzTDRxUU8wZU9QZVU1eDU2YnlwWHA0b25TRWI1T2tJQ1g2bERhdDU1VGVvenROS1FjSmFha3J6OUtDYjk1b0Q2OUlLcSt5S1c0WFBqa25hUzUyVjBUWnFFMmNUdFhqY0hTQ1JtVU84OGUrODVoajNFUDc0aTlwOHB5bHc3bHhnTUR5eWw2T1Y3WmVqbmpOTWZhdHU4N0x4UmJIMElTMzVndDJhNFpqbUdwVkJkS0szV3I2SU5rOGpXV1NHcWJBNTVDS2dqQlJDNkU5dzc4eWRUZzNBQlMzQUZWMVFOMFk0QWEycGdFalduUVVSajlMMGF5SzZSMnlzRXF4SFVLelluTHZ2eVUraTlLTTJKSEp6RTR2eVpPeURjT3dPc3lTYWplTFBjOHNOdlBKa0ZseUpkMjB3cHFBelplQWZaM29XeWJ4ZCtQLzNqK1NHM3VTQmRmMlZRQUFBQUJKUlU1RXJrSmdnZz09XFxcIikgbm8tcmVwZWF0O1xcbiAgYmFja2dyb3VuZDogdXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBEOTRiV3dnZG1WeWMybHZiajBpTVM0d0lpQmxibU52WkdsdVp6MGlWVlJHTFRnaUlITjBZVzVrWVd4dmJtVTlJbTV2SWo4K0Nqd2hMUzBnUTNKbFlYUmxaQ0IzYVhSb0lFbHVhM05qWVhCbElDaG9kSFJ3T2k4dmQzZDNMbWx1YTNOallYQmxMbTl5Wnk4cElDMHRQZ29LUEhOMlp3b2dJQ0I0Yld4dWN6cGtZejBpYUhSMGNEb3ZMM0IxY213dWIzSm5MMlJqTDJWc1pXMWxiblJ6THpFdU1TOGlDaUFnSUhodGJHNXpPbU5qUFNKb2RIUndPaTh2WTNKbFlYUnBkbVZqYjIxdGIyNXpMbTl5Wnk5dWN5TWlDaUFnSUhodGJHNXpPbkprWmowaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1UazVPUzh3TWk4eU1pMXlaR1l0YzNsdWRHRjRMVzV6SXlJS0lDQWdlRzFzYm5NNmMzWm5QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUlLSUNBZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWdvZ0lDQjRiV3h1Y3pwcGJtdHpZMkZ3WlQwaWFIUjBjRG92TDNkM2R5NXBibXR6WTJGd1pTNXZjbWN2Ym1GdFpYTndZV05sY3k5cGJtdHpZMkZ3WlNJS0lDQWdkbVZ5YzJsdmJqMGlNUzR4SWdvZ0lDQjNhV1IwYUQwaU5qZ3hMamsyTWpVeUlnb2dJQ0JvWldsbmFIUTlJakU0Tnk0MUlnb2dJQ0JwWkQwaWMzWm5NaUlLSUNBZ2VHMXNPbk53WVdObFBTSndjbVZ6WlhKMlpTSStQRzFsZEdGa1lYUmhDaUFnSUNBZ2FXUTlJbTFsZEdGa1lYUmhPQ0krUEhKa1pqcFNSRVkrUEdOak9sZHZjbXNLSUNBZ0lDQWdJQ0FnY21SbU9tRmliM1YwUFNJaVBqeGtZenBtYjNKdFlYUSthVzFoWjJVdmMzWm5LM2h0YkR3dlpHTTZabTl5YldGMFBqeGtZenAwZVhCbENpQWdJQ0FnSUNBZ0lDQWdjbVJtT25KbGMyOTFjbU5sUFNKb2RIUndPaTh2Y0hWeWJDNXZjbWN2WkdNdlpHTnRhWFI1Y0dVdlUzUnBiR3hKYldGblpTSWdMejQ4TDJOak9sZHZjbXMrUEM5eVpHWTZVa1JHUGp3dmJXVjBZV1JoZEdFK1BHUmxabk1LSUNBZ0lDQnBaRDBpWkdWbWN6WWlQanhqYkdsd1VHRjBhQW9nSUNBZ0lDQWdhV1E5SW1Oc2FYQlFZWFJvTVRnaVBqeHdZWFJvQ2lBZ0lDQWdJQ0FnSUdROUlrMGdNQ3d4TlRBd0lEQXNNQ0JzSURVME5UVXVOelFzTUNBd0xERTFNREFnVENBd0xERTFNREFnZWlJS0lDQWdJQ0FnSUNBZ2FXNXJjMk5oY0dVNlkyOXVibVZqZEc5eUxXTjFjblpoZEhWeVpUMGlNQ0lLSUNBZ0lDQWdJQ0FnYVdROUluQmhkR2d5TUNJZ0x6NDhMMk5zYVhCUVlYUm9Qand2WkdWbWN6NDhad29nSUNBZ0lIUnlZVzV6Wm05eWJUMGliV0YwY21sNEtERXVNalVzTUN3d0xDMHhMakkxTERBc01UZzNMalVwSWdvZ0lDQWdJR2xrUFNKbk1UQWlQanhuQ2lBZ0lDQWdJQ0IwY21GdWMyWnZjbTA5SW5OallXeGxLREF1TVN3d0xqRXBJZ29nSUNBZ0lDQWdhV1E5SW1jeE1pSStQR2NLSUNBZ0lDQWdJQ0FnYVdROUltY3hOQ0krUEdjS0lDQWdJQ0FnSUNBZ0lDQmpiR2x3TFhCaGRHZzlJblZ5YkNnalkyeHBjRkJoZEdneE9Da2lDaUFnSUNBZ0lDQWdJQ0FnYVdROUltY3hOaUkrUEhCaGRHZ0tJQ0FnSUNBZ0lDQWdJQ0FnSUdROUltMGdNVFUwTkN3MU9Ua3VORE0wSUdNZ01DNDVNaXd0TkRBdU16VXlJREkxTGpZNExDMDRNUzQyTURJZ056RXVOVE1zTFRneExqWXdNaUF5Tnk0MU1Td3dJRFEzTGpZNExERXlMamd6TWlBMk1TNDBOQ3d6TlM0M05UUWdNVEl1T0RNc01qSXVPVE1nTVRJdU9ETXNOVFl1T0RVeUlERXlMamd6TERneUxqVXlOeUJzSURBc016STVMakU0TkNBdE56RXVOVElzTUNBd0xERXdOQzQxTkRNZ01qWTJMamd6TERBZ01Dd3RNVEEwTGpVME15QXROekF1Tml3d0lEQXNMVE0wTkM0M055QmpJREFzTFRVNExqWTVNU0F0TXk0Mk9Dd3RNVEEwTGpVek1TQXRORFF1T1RNc0xURTFNaTR5TVRnZ0xUTTJMalk0TEMwME1pNHhPQ0F0T1RZdU1qZ3NMVFkyTGpBeUlDMHhOVE11TVRRc0xUWTJMakF5SUMweE1UY3VNemNzTUNBdE1qQTNMakkwTERjM0xqazBNU0F0TWpBeUxqWTBMREU1Tnk0eE5EVWdiQ0F4TXpBdU1pd3dJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXNXJjMk5oY0dVNlkyOXVibVZqZEc5eUxXTjFjblpoZEhWeVpUMGlNQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbGtQU0p3WVhSb01qSWlDaUFnSUNBZ0lDQWdJQ0FnSUNCemRIbHNaVDBpWm1sc2JEb2pPR0UwTVRneU8yWnBiR3d0YjNCaFkybDBlVG94TzJacGJHd3RjblZzWlRwdWIyNTZaWEp2TzNOMGNtOXJaVHB1YjI1bElpQXZQanh3WVhSb0NpQWdJQ0FnSUNBZ0lDQWdJQ0JrUFNKdElESXpNREV1TkN3Mk5qSXVOamsxSUdNZ01DdzRNQzQzTURNZ0xUWTJMamswTERFME5TNDRNVE1nTFRFME55NDJNeXd4TkRVdU9ERXpJQzA0TXk0ME5Dd3dJQzB4TkRjdU5qTXNMVFk0TGpjNE1TQXRNVFEzTGpZekxDMHhOVEV1TXpBeElEQXNMVGM1TGpjNE5TQTJOaTQ1TkN3dE1UUTFMamd3TVNBeE5EVXVPQ3d0TVRRMUxqZ3dNU0E0TkM0ek5Td3dJREUwT1M0ME5pdzJOeTQ0TlRJZ01UUTVMalEyTERFMU1TNHlPRGtnZWlCdElDMHhMamd6TEMweE9ERXVOVFEzSUdNZ0xUTTFMamMzTEMwMU5DNHdPVGNnTFRrekxqVXpMQzAzT0M0NE5Ua2dMVEUxTnk0M01pd3ROemd1T0RVNUlDMHhOREF1TXl3d0lDMHlOVEV1TWpRc01URTJMalEwT1NBdE1qVXhMakkwTERJMU5DNDVNVGdnTUN3eE5ESXVNVEk1SURFeE15NDNMREkyTUM0ME1TQXlOVFl1TnpRc01qWXdMalF4SURZekxqSTNMREFnTVRFNExqSTVMQzB5T1M0ek16WWdNVFV5TGpJeUxDMDRNaTQxTWpNZ2JDQXdMRFk1TGpZNE55QXhOelV1TVRRc01DQXdMQzB4TURRdU5USTNJQzAyTVM0ME5Dd3dJREFzTFRJNE1DNDFPVGdnTmpFdU5EUXNNQ0F3TEMweE1EUXVOVEkzSUMweE56VXVNVFFzTUNBd0xEWTJMakF4T1NJS0lDQWdJQ0FnSUNBZ0lDQWdJR2x1YTNOallYQmxPbU52Ym01bFkzUnZjaTFqZFhKMllYUjFjbVU5SWpBaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwWkQwaWNHRjBhREkwSWdvZ0lDQWdJQ0FnSUNBZ0lDQWdjM1I1YkdVOUltWnBiR3c2SXpoaE5ERTRNanRtYVd4c0xXOXdZV05wZEhrNk1UdG1hV3hzTFhKMWJHVTZibTl1ZW1WeWJ6dHpkSEp2YTJVNmJtOXVaU0lnTHo0OGNHRjBhQW9nSUNBZ0lDQWdJQ0FnSUNBZ1pEMGliU0F5TmpJeUxqTXpMRFUxTnk0eU5UZ2dZeUF6TGpZM0xDMDBOQzR3TVRZZ016TXVNREVzTFRjekxqTTBPQ0EzT0M0NE5pd3ROek11TXpRNElETXpMamt6TERBZ05qWXVPVE1zTWpNdU9ESTBJRFkyTGprekxEWXdMalV3TkNBd0xEUTRMall3TmlBdE5EVXVPRFFzTlRZdU9EVTJJQzA0TXk0ME5DdzJOaTQ1TkRFZ0xUZzFMakk0TERJeUxqQXdOQ0F0TVRjNExqZ3hMRFE0TGpZd05pQXRNVGM0TGpneExERTFOUzQ0TnprZ01DdzVNeTQxTXpZZ056Z3VPRFlzTVRRM0xqWXpNeUF4TmpVdU9UZ3NNVFEzTGpZek15QTBOQ3d3SURnekxqUXpMQzA1TGpFM05pQXhNVEF1T1RRc0xUUTBMakF3T0NCc0lEQXNNek11T1RJeUlEZ3lMalV6TERBZ01Dd3RNVE15TGprMk5TQXRNVEE0TGpJeExEQWdZeUF0TVM0NE15d3pOQzQ0TlRZZ0xUSTRMalF5TERVM0xqYzNOQ0F0TmpNdU1qWXNOVGN1TnpjMElDMHpNQzR5Tml3d0lDMDJNaTR6TlN3dE1UY3VOREl5SUMwMk1pNHpOU3d0TlRFdU16UTRJREFzTFRRMUxqZzBOeUEwTkM0NU15d3ROVFV1T1RNZ09EQXVOamtzTFRZMExqRTRJRGc0TGpBeUxDMHlNQzR4TnpVZ01UZ3lMalEzTEMwME55NDJPVFVnTVRneUxqUTNMQzB4TlRjdU56TTBJREFzTFRrNUxqQXlOeUF0T0RNdU5EUXNMVEUxTkM0d016a2dMVEUzTlM0eE15d3RNVFUwTGpBek9TQXRORGt1TlRNc01DQXRPVFF1TkRZc01UVXVOVGd5SUMweE1qWXVOVFVzTlRNdU1UZ2diQ0F3TEMwME1DNHpOQ0F0T0RVdU1qY3NNQ0F3TERFME1pNHhNamtnTVRFMExqWXlMREFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBibXR6WTJGd1pUcGpiMjV1WldOMGIzSXRZM1Z5ZG1GMGRYSmxQU0l3SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdhV1E5SW5CaGRHZ3lOaUlLSUNBZ0lDQWdJQ0FnSUNBZ0lITjBlV3hsUFNKbWFXeHNPaU00WVRReE9ESTdabWxzYkMxdmNHRmphWFI1T2pFN1ptbHNiQzF5ZFd4bE9tNXZibnBsY204N2MzUnliMnRsT201dmJtVWlJQzgrUEhCaGRHZ0tJQ0FnSUNBZ0lDQWdJQ0FnSUdROUltMGdNams0T0M0eE9DdzRNREF1TWpVMElDMDJNeTR5Tml3d0lEQXNNVEEwTGpVeU55QXhOalV1TURVc01DQXdMQzAzTXk0ek5UVWdZeUF6TVM0eE9DdzFNUzR6TkRjZ056Z3VPRFlzT0RVdU1qYzNJREUwTVM0eU1TdzROUzR5TnpjZ05qY3VPRFVzTUNBeE1qUXVOekVzTFRReExqSTFPQ0F4TlRJdU1qRXNMVEV3TWk0Mk9Ua2dNall1Tml3Mk1pNHpOVEVnT1RJdU5qSXNNVEF5TGpZNU9TQXhOakF1TkRjc01UQXlMalk1T1NBMU15NHhPU3d3SURFd05TNDBOaXd0TWpJZ01UUXhMakl4TEMwMk1pNHpOVEVnTXpndU5USXNMVFEwTGprek9DQXpPQzQxTWl3dE9UTXVOVE15SURNNExqVXlMQzB4TkRrdU5EVTNJR3dnTUN3dE1UZzFMakl6T1NBMk15NHlOeXd3SURBc0xURXdOQzQxTWpjZ0xUSXpPQzQwTWl3d0lEQXNNVEEwTGpVeU55QTJNeTR5T0N3d0lEQXNNVFUzTGpjeE5TQmpJREFzTXpJdU1UQXlJREFzTmpBdU5USTNJQzB4TkM0Mk55dzRPQzQ1TlRjZ0xURTRMak0wTERJMkxqVTRNaUF0TkRndU5qRXNOREF1TXpRMElDMDNPUzQzTnl3ME1DNHpORFFnTFRNd0xqSTJMREFnTFRZekxqSTRMQzB4TWk0NE5EUWdMVGd5TGpVekxDMHpOaTQyTnpJZ0xUSXlMamt6TEMweU9TNHpOVFVnTFRJeUxqa3pMQzAxTmk0NE5qTWdMVEl5TGprekxDMDVNaTQyTWprZ2JDQXdMQzB4TlRjdU56RTFJRFl6TGpJM0xEQWdNQ3d0TVRBMExqVXlOeUF0TWpNNExqUXhMREFnTUN3eE1EUXVOVEkzSURZekxqSTRMREFnTUN3eE5UQXVNemd6SUdNZ01Dd3lPUzR6TkRnZ01DdzJOaTR3TWpNZ0xURTBMalkzTERreExqWTVPU0F0TVRVdU5Ua3NNamt1TXpNMklDMDBOeTQyT1N3ME5DNDVNelFnTFRnd0xqY3NORFF1T1RNMElDMHpNUzR4T0N3d0lDMDFOeTQzTnl3dE1URXVNREE0SUMwM055NDVOQ3d0TXpVdU56YzBJQzB5TkM0M055d3RNekF1TWpVeklDMHlOaTQyTEMwMk1pNHpORE1nTFRJMkxqWXNMVGs1TGprME1TQnNJREFzTFRFMU1TNHpNREVnTmpNdU1qY3NNQ0F3TEMweE1EUXVOVEkzSUMweU16Z3VOQ3d3SURBc01UQTBMalV5TnlBMk15NHlOaXd3SURBc01qZ3dMalU1T0NJS0lDQWdJQ0FnSUNBZ0lDQWdJR2x1YTNOallYQmxPbU52Ym01bFkzUnZjaTFqZFhKMllYUjFjbVU5SWpBaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwWkQwaWNHRjBhREk0SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdjM1I1YkdVOUltWnBiR3c2SXpoaE5ERTRNanRtYVd4c0xXOXdZV05wZEhrNk1UdG1hV3hzTFhKMWJHVTZibTl1ZW1WeWJ6dHpkSEp2YTJVNmJtOXVaU0lnTHo0OGNHRjBhQW9nSUNBZ0lDQWdJQ0FnSUNBZ1pEMGliU0F6T1RrNExqWTJMRGsxTVM0MU5EY2dMVEV4TVM0NE55d3dJREFzTVRFNExqSTVNeUF4TVRFdU9EY3NNQ0F3TEMweE1UZ3VNamt6SUhvZ2JTQXdMQzAwTXpFdU9Ea3hJRFl6TGpJM0xEQWdNQ3d0TVRBMExqVXlOeUF0TWpNNUxqTXpMREFnTUN3eE1EUXVOVEkzSURZMExqRTVMREFnTUN3eU9EQXVOVGs0SUMwMk15NHlOeXd3SURBc01UQTBMalV5TnlBeE56VXVNVFFzTUNBd0xDMHpPRFV1TVRJMUlnb2dJQ0FnSUNBZ0lDQWdJQ0FnYVc1cmMyTmhjR1U2WTI5dWJtVmpkRzl5TFdOMWNuWmhkSFZ5WlQwaU1DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsa1BTSndZWFJvTXpBaUNpQWdJQ0FnSUNBZ0lDQWdJQ0J6ZEhsc1pUMGlabWxzYkRvak9HRTBNVGd5TzJacGJHd3RiM0JoWTJsMGVUb3hPMlpwYkd3dGNuVnNaVHB1YjI1NlpYSnZPM04wY205clpUcHViMjVsSWlBdlBqeHdZWFJvQ2lBZ0lDQWdJQ0FnSUNBZ0lDQmtQU0p0SURReE5Ua3VNVElzT0RBd0xqSTFOQ0F0TmpNdU1qY3NNQ0F3TERFd05DNDFNamNnTVRjMUxqRTBMREFnTUN3dE5qa3VOamczSUdNZ01qa3VNelVzTlRRdU1UQXhJRGcwTGpNMkxEZ3dMalk1T1NBeE5EUXVPRGNzT0RBdU5qazVJRFV6TGpFNUxEQWdNVEExTGpRMUxDMHlNaTR3TVRZZ01UUXhMakl5TEMwMk1DNDFNamNnTkRBdU16UXNMVFEwTGprek5DQTBNUzR5Tml3dE9EZ3VNRE15SURReExqSTJMQzB4TkRNdU9UVTNJR3dnTUN3dE1Ua3hMalkxTXlBMk15NHlOeXd3SURBc0xURXdOQzQxTWpjZ0xUSXpPQzQwTERBZ01Dd3hNRFF1TlRJM0lEWXpMakkyTERBZ01Dd3hOVGd1TmpNM0lHTWdNQ3d6TUM0eU5qSWdNQ3cyTVM0ME16UWdMVEU1TGpJMkxEZzRMakF6TlNBdE1qQXVNVGNzTWpZdU5UZ3lJQzAxTXk0eE9Dd3pPUzQwTVRRZ0xUZzJMakU1TERNNUxqUXhOQ0F0TXpNdU9UTXNNQ0F0TmpndU56Y3NMVEV6TGpjMUlDMDRPQzQ1TkN3dE5ERXVNalVnTFRJeExqQTVMQzB5Tnk0MUlDMHlNUzR3T1N3dE5qa3VOamczSUMweU1TNHdPU3d0TVRBeUxqY3dOeUJzSURBc0xURTBNaTR4TWprZ05qTXVNallzTUNBd0xDMHhNRFF1TlRJM0lDMHlNemd1TkN3d0lEQXNNVEEwTGpVeU55QTJNeTR5Tnl3d0lEQXNNamd3TGpVNU9DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsdWEzTmpZWEJsT21OdmJtNWxZM1J2Y2kxamRYSjJZWFIxY21VOUlqQWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcFpEMGljR0YwYURNeUlnb2dJQ0FnSUNBZ0lDQWdJQ0FnYzNSNWJHVTlJbVpwYkd3Nkl6aGhOREU0TWp0bWFXeHNMVzl3WVdOcGRIazZNVHRtYVd4c0xYSjFiR1U2Ym05dWVtVnlienR6ZEhKdmEyVTZibTl1WlNJZ0x6NDhjR0YwYUFvZ0lDQWdJQ0FnSUNBZ0lDQWdaRDBpYlNBMU1EZ3lMalE0TERjd015NDVOalVnWXlBdE1Ua3VNalFzTnpBdU5qQTFJQzA0TVM0MkxERXhOUzQxTkRjZ0xURTFOQzR3TkN3eE1UVXVOVFEzSUMwMk5pNHdOQ3d3SUMweE1qa3VNeXd0TlRFdU16UTRJQzB4TkRNdU1EVXNMVEV4TlM0MU5EY2diQ0F5T1RjdU1Ea3NNQ0I2SUcwZ09EVXVNamNzTFRFME5DNDRPRE1nWXlBdE16Z3VOVEVzTFRrekxqVXlNeUF0TVRJNUxqSTNMQzB4TlRZdU56a3pJQzB5TXpFdU1EVXNMVEUxTmk0M09UTWdMVEUwTXk0d055d3dJQzB5TlRjdU5qZ3NNVEV4TGpnM01TQXRNalUzTGpZNExESTFOUzQ0TXpZZ01Dd3hORFF1T0RneklERXdPUzR4TWl3eU5qRXVNekk0SURJMU5DNDVNU3d5TmpFdU16STRJRFkzTGpnM0xEQWdNVE0xTGpjeUxDMHpNQzR5TlRnZ01UZ3pMak01TEMwM09DNDROak1nTkRndU5qSXNMVFV4TGpNME5DQTJPQzQzT1N3dE1URXpMalk1TlNBMk9DNDNPU3d0TVRnekxqTTRNeUJzSUMwekxqWTNMQzB6T1M0ME16UWdMVE01Tmk0eE15d3dJR01nTVRRdU5qY3NMVFkzTGpnMk15QTNOeTR3TXl3dE1URTNMak0yTXlBeE5EWXVOeklzTFRFeE55NHpOak1nTkRndU5Ua3NNQ0E1TUM0M05pd3hPQzR6TWpnZ01URTRMakk0TERVNExqWTNNaUJzSURFeE5pNDBOQ3d3SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdhVzVyYzJOaGNHVTZZMjl1Ym1WamRHOXlMV04xY25aaGRIVnlaVDBpTUNJS0lDQWdJQ0FnSUNBZ0lDQWdJR2xrUFNKd1lYUm9NelFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnpkSGxzWlQwaVptbHNiRG9qT0dFME1UZ3lPMlpwYkd3dGIzQmhZMmwwZVRveE8yWnBiR3d0Y25Wc1pUcHViMjU2WlhKdk8zTjBjbTlyWlRwdWIyNWxJaUF2UGp4d1lYUm9DaUFnSUNBZ0lDQWdJQ0FnSUNCa1BTSnRJRFk1TUM0NE9UVXNPRFV3TGpjd015QTVNQzQzTlN3d0lESXlMalUwTXl3ek1TNHdNelVnTUN3eU5ETXVNVEl5SUMweE16VXVPREk1TERBZ01Dd3RNalF6TGpFME1TQXlNaTQxTXpZc0xUTXhMakF4TmlJS0lDQWdJQ0FnSUNBZ0lDQWdJR2x1YTNOallYQmxPbU52Ym01bFkzUnZjaTFqZFhKMllYUjFjbVU5SWpBaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwWkQwaWNHRjBhRE0ySWdvZ0lDQWdJQ0FnSUNBZ0lDQWdjM1I1YkdVOUltWnBiR3c2SXpoaE5ERTRNanRtYVd4c0xXOXdZV05wZEhrNk1UdG1hV3hzTFhKMWJHVTZibTl1ZW1WeWJ6dHpkSEp2YTJVNmJtOXVaU0lnTHo0OGNHRjBhQW9nSUNBZ0lDQWdJQ0FnSUNBZ1pEMGliU0EyTXpJdU16azFMRGMwTWk0eU5UZ2dNamd1TURNNUxEZzJMak13TkNBdE1qSXVOVFV4TERNeExqQTBJQzB5TXpFdU1qSXpMRGMxTGpFeU9DQXROREV1T1RjMkxDMHhNamt1TVRneklESXpNUzR5TlRjc0xUYzFMakV6TnlBek5pNDBOVFFzTVRFdU9EUTRJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXNXJjMk5oY0dVNlkyOXVibVZqZEc5eUxXTjFjblpoZEhWeVpUMGlNQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbGtQU0p3WVhSb016Z2lDaUFnSUNBZ0lDQWdJQ0FnSUNCemRIbHNaVDBpWm1sc2JEb2pPR0UwTVRneU8yWnBiR3d0YjNCaFkybDBlVG94TzJacGJHd3RjblZzWlRwdWIyNTZaWEp2TzNOMGNtOXJaVHB1YjI1bElpQXZQanh3WVhSb0NpQWdJQ0FnSUNBZ0lDQWdJQ0JrUFNKdElEY3hOeTQwTkRrc05qVXpMakV3TlNBdE56TXVOREVzTlRNdU16WWdMVE0yTGpRNE9Dd3RNVEV1T0RjMUlDMHhOREl1T1RBekxDMHhPVFl1TmpreUlERXdPUzQ0T0RNc0xUYzVMamd5T0NBeE5ESXVPVEU0TERFNU5pNDNNRE1nTUN3ek9DNHpNeklpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBibXR6WTJGd1pUcGpiMjV1WldOMGIzSXRZM1Z5ZG1GMGRYSmxQU0l3SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdhV1E5SW5CaGRHZzBNQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lITjBlV3hsUFNKbWFXeHNPaU00WVRReE9ESTdabWxzYkMxdmNHRmphWFI1T2pFN1ptbHNiQzF5ZFd4bE9tNXZibnBsY204N2MzUnliMnRsT201dmJtVWlJQzgrUEhCaGRHZ0tJQ0FnSUNBZ0lDQWdJQ0FnSUdROUltMGdPREk0TGpVeUxEY3dOaTQwTmpVZ0xUY3pMalF5Tml3dE5UTXVNelFnTUM0d01URXNMVE00TGpNMU9TQk1JRGc1T0M0d01EUXNOREU0TGpBM0lERXdNRGN1T1N3ME9UY3VPRGs0SURnMk5DNDVOek1zTmprMExqWXdPU0E0TWpndU5USXNOekEyTGpRMk5TSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsdWEzTmpZWEJsT21OdmJtNWxZM1J2Y2kxamRYSjJZWFIxY21VOUlqQWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcFpEMGljR0YwYURReUlnb2dJQ0FnSUNBZ0lDQWdJQ0FnYzNSNWJHVTlJbVpwYkd3Nkl6aGhOREU0TWp0bWFXeHNMVzl3WVdOcGRIazZNVHRtYVd4c0xYSjFiR1U2Ym05dWVtVnlienR6ZEhKdmEyVTZibTl1WlNJZ0x6NDhjR0YwYUFvZ0lDQWdJQ0FnSUNBZ0lDQWdaRDBpYlNBNE1USXVNRGcyTERneU9DNDFPRFlnTWpndU1EVTFMQzA0Tmk0ek1pQXpOaTQwT0RRc0xURXhMamd6TmlBeU16RXVNakkxTERjMUxqRXhOeUF0TkRFdU9UY3NNVEk1TGpFNE15QXRNak14TGpJek9Td3ROelV1TVRRZ0xUSXlMalUxTlN3dE16RXVNREEwSWdvZ0lDQWdJQ0FnSUNBZ0lDQWdhVzVyYzJOaGNHVTZZMjl1Ym1WamRHOXlMV04xY25aaGRIVnlaVDBpTUNJS0lDQWdJQ0FnSUNBZ0lDQWdJR2xrUFNKd1lYUm9ORFFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnpkSGxzWlQwaVptbHNiRG9qT0dFME1UZ3lPMlpwYkd3dGIzQmhZMmwwZVRveE8yWnBiR3d0Y25Wc1pUcHViMjU2WlhKdk8zTjBjbTlyWlRwdWIyNWxJaUF2UGp4d1lYUm9DaUFnSUNBZ0lDQWdJQ0FnSUNCa1BTSnRJRGN6Tmk0ek1ERXNNVE16TlM0NE9DQmpJQzB6TWpNdU1EUTNMREFnTFRVNE5TNDROelVzTFRJMk1pNDNPQ0F0TlRnMUxqZzNOU3d0TlRnMUxqYzRNaUF3TEMwek1qTXVNVEU0SURJMk1pNDRNamdzTFRVNE5TNDVOemNnTlRnMUxqZzNOU3d0TlRnMUxqazNOeUF6TWpNdU1ERTVMREFnTlRnMUxqZ3dPU3d5TmpJdU9EVTVJRFU0TlM0NE1Ea3NOVGcxTGprM055QXdMRE15TXk0d01ESWdMVEkyTWk0M09TdzFPRFV1TnpneUlDMDFPRFV1T0RBNUxEVTROUzQzT0RJZ2JDQXdMREFnZWlCdElEQXNMVEV4T0M0Mk1TQmpJREkxTnk0NU56SXNNQ0EwTmpjdU1UZzVMQzB5TURrdU1UTWdORFkzTGpFNE9Td3RORFkzTGpFM01pQXdMQzB5TlRndU1USTVJQzB5TURrdU1qRTNMQzAwTmpjdU16UTRJQzAwTmpjdU1UZzVMQzAwTmpjdU16UTRJQzB5TlRndU1EYzBMREFnTFRRMk55NHlOVFFzTWpBNUxqSXhPU0F0TkRZM0xqSTFOQ3cwTmpjdU16UTRJREFzTWpVNExqQTBNaUF5TURrdU1UZ3NORFkzTGpFM01pQTBOamN1TWpVMExEUTJOeTR4TnpJaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwYm10elkyRndaVHBqYjI1dVpXTjBiM0l0WTNWeWRtRjBkWEpsUFNJd0lnb2dJQ0FnSUNBZ0lDQWdJQ0FnYVdROUluQmhkR2cwTmlJS0lDQWdJQ0FnSUNBZ0lDQWdJSE4wZVd4bFBTSm1hV3hzT2lNNFlUUXhPREk3Wm1sc2JDMXZjR0ZqYVhSNU9qRTdabWxzYkMxeWRXeGxPbTV2Ym5wbGNtODdjM1J5YjJ0bE9tNXZibVVpSUM4K1BIQmhkR2dLSUNBZ0lDQWdJQ0FnSUNBZ0lHUTlJbTBnTVRBNU1TNHhNeXcyTVRrdU9EZ3pJQzB4TnpVdU56Y3hMRFUzTGpFeU1TQXhNUzQyTWprc016VXVPREE0SURFM05TNDNOaklzTFRVM0xqRXlNU0F0TVRFdU5qSXNMVE0xTGpnd09DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsdWEzTmpZWEJsT21OdmJtNWxZM1J2Y2kxamRYSjJZWFIxY21VOUlqQWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcFpEMGljR0YwYURRNElnb2dJQ0FnSUNBZ0lDQWdJQ0FnYzNSNWJHVTlJbVpwYkd3Nkl6aGhOREU0TWp0bWFXeHNMVzl3WVdOcGRIazZNVHRtYVd4c0xYSjFiR1U2Ym05dWVtVnlienR6ZEhKdmEyVTZibTl1WlNJZ0x6NDhjR0YwYUFvZ0lDQWdJQ0FnSUNBZ0lDQWdaRDBpVFNBNE5qWXVPVFUzTERrd01pNHdOelFnT0RNMkxqVXNPVEkwTGpFNU9TQTVORFV1TVRJeExERXdOek11TnpNZ09UYzFMalU0Tml3eE1EVXhMall4SURnMk5pNDVOVGNzT1RBeUxqQTNOQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbHVhM05qWVhCbE9tTnZibTVsWTNSdmNpMWpkWEoyWVhSMWNtVTlJakFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBaRDBpY0dGMGFEVXdJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2MzUjViR1U5SW1acGJHdzZJemhoTkRFNE1qdG1hV3hzTFc5d1lXTnBkSGs2TVR0bWFXeHNMWEoxYkdVNmJtOXVlbVZ5Ynp0emRISnZhMlU2Ym05dVpTSWdMejQ4Y0dGMGFBb2dJQ0FnSUNBZ0lDQWdJQ0FnWkQwaVRTQTJNRGN1TkRZMUxEa3dNeTQwTkRVZ05EazRMamcxTlN3eE1EVXlMamszSURVeU9TNHpNaXd4TURjMUxqRWdOak0zTGprekxEa3lOUzQxTmpZZ05qQTNMalEyTlN3NU1ETXVORFExSWdvZ0lDQWdJQ0FnSUNBZ0lDQWdhVzVyYzJOaGNHVTZZMjl1Ym1WamRHOXlMV04xY25aaGRIVnlaVDBpTUNJS0lDQWdJQ0FnSUNBZ0lDQWdJR2xrUFNKd1lYUm9OVElpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnpkSGxzWlQwaVptbHNiRG9qT0dFME1UZ3lPMlpwYkd3dGIzQmhZMmwwZVRveE8yWnBiR3d0Y25Wc1pUcHViMjU2WlhKdk8zTjBjbTlyWlRwdWIyNWxJaUF2UGp4d1lYUm9DaUFnSUNBZ0lDQWdJQ0FnSUNCa1BTSnRJRE00TUM0Mk9EZ3NOakl5TGpFeU9TQXRNVEV1TmpJMkxETTFMamd3TVNBeE56VXVOelU0TERVM0xqQTVJREV4TGpZeU1Td3RNelV1T0RBeElDMHhOelV1TnpVekxDMDFOeTR3T1NJS0lDQWdJQ0FnSUNBZ0lDQWdJR2x1YTNOallYQmxPbU52Ym01bFkzUnZjaTFqZFhKMllYUjFjbVU5SWpBaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwWkQwaWNHRjBhRFUwSWdvZ0lDQWdJQ0FnSUNBZ0lDQWdjM1I1YkdVOUltWnBiR3c2SXpoaE5ERTRNanRtYVd4c0xXOXdZV05wZEhrNk1UdG1hV3hzTFhKMWJHVTZibTl1ZW1WeWJ6dHpkSEp2YTJVNmJtOXVaU0lnTHo0OGNHRjBhQW9nSUNBZ0lDQWdJQ0FnSUNBZ1pEMGliU0EzTVRZdU1qZzVMRE0zTmk0MU9TQXpOeTQyTkRBMkxEQWdNQ3d4T0RRdU9ERTJJQzB6Tnk0Mk5EQTJMREFnTUN3dE1UZzBMamd4TmlCNklnb2dJQ0FnSUNBZ0lDQWdJQ0FnYVc1cmMyTmhjR1U2WTI5dWJtVmpkRzl5TFdOMWNuWmhkSFZ5WlQwaU1DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsa1BTSndZWFJvTlRZaUNpQWdJQ0FnSUNBZ0lDQWdJQ0J6ZEhsc1pUMGlabWxzYkRvak9HRTBNVGd5TzJacGJHd3RiM0JoWTJsMGVUb3hPMlpwYkd3dGNuVnNaVHB1YjI1NlpYSnZPM04wY205clpUcHViMjVsSWlBdlBqd3ZaejQ4TDJjK1BDOW5Qand2Wno0OEwzTjJaejQ9XFxcIikgbm8tcmVwZWF0LCBub25lO1xcbiAgLW1vei1iYWNrZ3JvdW5kLXNpemU6IDEwMCU7XFxuICAtby1iYWNrZ3JvdW5kLXNpemU6IDEwMCU7XFxuICAtd2Via2l0LWJhY2tncm91bmQtc2l6ZTogMTAwJTtcXG4gIGJhY2tncm91bmQtc2l6ZTogMTAwJTtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICB3aWR0aDogOTBweDtcXG4gIGhlaWdodDogMjVweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYW5uZXIgLmphc21pbmUtdmVyc2lvbiB7XFxuICBtYXJnaW4tbGVmdDogMTRweDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHRvcDogNnB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyICNqYXNtaW5lX2NvbnRlbnQge1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgcmlnaHQ6IDEwMCU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtdmVyc2lvbiB7XFxuICBjb2xvcjogI2FhYTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYW5uZXIge1xcbiAgbWFyZ2luLXRvcDogMTRweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1kdXJhdGlvbiB7XFxuICBjb2xvcjogI2ZmZjtcXG4gIGZsb2F0OiByaWdodDtcXG4gIGxpbmUtaGVpZ2h0OiAyOHB4O1xcbiAgcGFkZGluZy1yaWdodDogOXB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IHtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBtYXJnaW46IDE0cHggMDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaSB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBoZWlnaHQ6IDEwcHg7XFxuICB3aWR0aDogMTRweDtcXG4gIGZvbnQtc2l6ZTogMTZweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaS5qYXNtaW5lLXBhc3NlZCB7XFxuICBmb250LXNpemU6IDE0cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkgbGkuamFzbWluZS1wYXNzZWQ6YmVmb3JlIHtcXG4gIGNvbG9yOiAjMDA3MDY5O1xcbiAgY29udGVudDogXFxcIuKAolxcXCI7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkgbGkuamFzbWluZS1mYWlsZWQge1xcbiAgbGluZS1oZWlnaHQ6IDlweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaS5qYXNtaW5lLWZhaWxlZDpiZWZvcmUge1xcbiAgY29sb3I6ICNjYTNhMTE7XFxuICBjb250ZW50OiBcXFwiw5dcXFwiO1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBtYXJnaW4tbGVmdDogLTFweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaS5qYXNtaW5lLWV4Y2x1ZGVkIHtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaS5qYXNtaW5lLWV4Y2x1ZGVkOmJlZm9yZSB7XFxuICBjb2xvcjogI2JhYmFiYTtcXG4gIGNvbnRlbnQ6IFxcXCLigKJcXFwiO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpLmphc21pbmUtZXhjbHVkZWQtbm8tZGlzcGxheSB7XFxuICBmb250LXNpemU6IDE0cHg7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpLmphc21pbmUtcGVuZGluZyB7XFxuICBsaW5lLWhlaWdodDogMTdweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaS5qYXNtaW5lLXBlbmRpbmc6YmVmb3JlIHtcXG4gIGNvbG9yOiAjYmE5ZDM3O1xcbiAgY29udGVudDogXFxcIipcXFwiO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpLmphc21pbmUtZW1wdHkge1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpLmphc21pbmUtZW1wdHk6YmVmb3JlIHtcXG4gIGNvbG9yOiAjYmE5ZDM3O1xcbiAgY29udGVudDogXFxcIuKAolxcXCI7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtcnVuLW9wdGlvbnMge1xcbiAgZmxvYXQ6IHJpZ2h0O1xcbiAgbWFyZ2luLXJpZ2h0OiA1cHg7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjOGE0MTgyO1xcbiAgY29sb3I6ICM4YTQxODI7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBsaW5lLWhlaWdodDogMjBweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1ydW4tb3B0aW9ucyAuamFzbWluZS10cmlnZ2VyIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIHBhZGRpbmc6IDhweCAxNnB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXJ1bi1vcHRpb25zIC5qYXNtaW5lLXBheWxvYWQge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIHJpZ2h0OiAtMXB4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgIzhhNDE4MjtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlZWU7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgcGFkZGluZzogNHB4IDhweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1ydW4tb3B0aW9ucyAuamFzbWluZS1wYXlsb2FkLmphc21pbmUtb3BlbiB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYXIge1xcbiAgbGluZS1oZWlnaHQ6IDI4cHg7XFxuICBmb250LXNpemU6IDE0cHg7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGNvbG9yOiAjZWVlO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhci5qYXNtaW5lLWZhaWxlZCwgLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYXIuamFzbWluZS1lcnJvcmVkIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNjYTNhMTE7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2VlZTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYXIuamFzbWluZS1wYXNzZWQge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzAwNzA2OTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYXIuamFzbWluZS1pbmNvbXBsZXRlIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNiYWJhYmE7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFyLmphc21pbmUtc2tpcHBlZCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjYmFiYWJhO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhci5qYXNtaW5lLXdhcm5pbmcge1xcbiAgbWFyZ2luLXRvcDogMTRweDtcXG4gIG1hcmdpbi1ib3R0b206IDE0cHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjYmE5ZDM3O1xcbiAgY29sb3I6ICMzMzM7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFyLmphc21pbmUtbWVudSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgY29sb3I6ICNhYWE7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFyLmphc21pbmUtbWVudSBhIHtcXG4gIGNvbG9yOiAjMzMzO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhciBhIHtcXG4gIGNvbG9yOiB3aGl0ZTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlci5qYXNtaW5lLXNwZWMtbGlzdCAuamFzbWluZS1iYXIuamFzbWluZS1tZW51Lmphc21pbmUtZmFpbHVyZS1saXN0LFxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIuamFzbWluZS1zcGVjLWxpc3QgLmphc21pbmUtcmVzdWx0cyAuamFzbWluZS1mYWlsdXJlcyB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyLmphc21pbmUtZmFpbHVyZS1saXN0IC5qYXNtaW5lLWJhci5qYXNtaW5lLW1lbnUuamFzbWluZS1zcGVjLWxpc3QsXFxuLmphc21pbmVfaHRtbC1yZXBvcnRlci5qYXNtaW5lLWZhaWx1cmUtbGlzdCAuamFzbWluZS1zdW1tYXJ5IHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtcmVzdWx0cyB7XFxuICBtYXJnaW4tdG9wOiAxNHB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1bW1hcnkge1xcbiAgbWFyZ2luLXRvcDogMTRweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdW1tYXJ5IHVsIHtcXG4gIGxpc3Qtc3R5bGUtdHlwZTogbm9uZTtcXG4gIG1hcmdpbi1sZWZ0OiAxNHB4O1xcbiAgcGFkZGluZy10b3A6IDA7XFxuICBwYWRkaW5nLWxlZnQ6IDA7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3VtbWFyeSB1bC5qYXNtaW5lLXN1aXRlIHtcXG4gIG1hcmdpbi10b3A6IDdweDtcXG4gIG1hcmdpbi1ib3R0b206IDdweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdW1tYXJ5IGxpLmphc21pbmUtcGFzc2VkIGEge1xcbiAgY29sb3I6ICMwMDcwNjk7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3VtbWFyeSBsaS5qYXNtaW5lLWZhaWxlZCBhIHtcXG4gIGNvbG9yOiAjY2EzYTExO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1bW1hcnkgbGkuamFzbWluZS1lbXB0eSBhIHtcXG4gIGNvbG9yOiAjYmE5ZDM3O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1bW1hcnkgbGkuamFzbWluZS1wZW5kaW5nIGEge1xcbiAgY29sb3I6ICNiYTlkMzc7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3VtbWFyeSBsaS5qYXNtaW5lLWV4Y2x1ZGVkIGEge1xcbiAgY29sb3I6ICNiYWJhYmE7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3BlY3MgbGkuamFzbWluZS1wYXNzZWQgYTpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIuKAoiBcXFwiO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXNwZWNzIGxpLmphc21pbmUtZmFpbGVkIGE6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCLDlyBcXFwiO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXNwZWNzIGxpLmphc21pbmUtZW1wdHkgYTpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIiogXFxcIjtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zcGVjcyBsaS5qYXNtaW5lLXBlbmRpbmcgYTpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIuKAoiBcXFwiO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXNwZWNzIGxpLmphc21pbmUtZXhjbHVkZWQgYTpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIuKAoiBcXFwiO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWRlc2NyaXB0aW9uICsgLmphc21pbmUtc3VpdGUge1xcbiAgbWFyZ2luLXRvcDogMDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdWl0ZSB7XFxuICBtYXJnaW4tdG9wOiAxNHB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1aXRlIGEge1xcbiAgY29sb3I6ICMzMzM7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZmFpbHVyZXMgLmphc21pbmUtc3BlYy1kZXRhaWwge1xcbiAgbWFyZ2luLWJvdHRvbTogMjhweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1mYWlsdXJlcyAuamFzbWluZS1zcGVjLWRldGFpbCAuamFzbWluZS1kZXNjcmlwdGlvbiB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjY2EzYTExO1xcbiAgY29sb3I6IHdoaXRlO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWZhaWx1cmVzIC5qYXNtaW5lLXNwZWMtZGV0YWlsIC5qYXNtaW5lLWRlc2NyaXB0aW9uIGEge1xcbiAgY29sb3I6IHdoaXRlO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXJlc3VsdC1tZXNzYWdlIHtcXG4gIHBhZGRpbmctdG9wOiAxNHB4O1xcbiAgY29sb3I6ICMzMzM7XFxuICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtcmVzdWx0LW1lc3NhZ2Ugc3Bhbi5qYXNtaW5lLXJlc3VsdCB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdGFjay10cmFjZSB7XFxuICBtYXJnaW46IDVweCAwIDAgMDtcXG4gIG1heC1oZWlnaHQ6IDIyNHB4O1xcbiAgb3ZlcmZsb3c6IGF1dG87XFxuICBsaW5lLWhlaWdodDogMThweDtcXG4gIGNvbG9yOiAjNjY2O1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2RkZDtcXG4gIGJhY2tncm91bmQ6IHdoaXRlO1xcbiAgd2hpdGUtc3BhY2U6IHByZTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1leHBhbmRlciBhIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgbWFyZ2luLWxlZnQ6IDE0cHg7XFxuICBjb2xvcjogYmx1ZTtcXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWV4cGFuZGVyLWNvbnRlbnRzIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZXhwYW5kZWQge1xcbiAgcGFkZGluZy1ib3R0b206IDEwcHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZXhwYW5kZWQgLmphc21pbmUtZXhwYW5kZXItY29udGVudHMge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBtYXJnaW4tbGVmdDogMTRweDtcXG4gIHBhZGRpbmc6IDVweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1kZWJ1Zy1sb2cge1xcbiAgbWFyZ2luOiA1cHggMCAwIDA7XFxuICBwYWRkaW5nOiA1cHg7XFxuICBjb2xvcjogIzY2NjtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNkZGQ7XFxuICBiYWNrZ3JvdW5kOiB3aGl0ZTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1kZWJ1Zy1sb2cgdGFibGUge1xcbiAgYm9yZGVyLXNwYWNpbmc6IDA7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZGVidWctbG9nIHRhYmxlLCAuamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWRlYnVnLWxvZyB0aCwgLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1kZWJ1Zy1sb2cgdGQge1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2RkZDtcXG59XCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzV2l0aE1hcHBpbmdUb1N0cmluZykge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBpdGVtWzVdICE9PSBcInVuZGVmaW5lZFwiO1xuXG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpO1xuICAgICAgfVxuXG4gICAgICBjb250ZW50ICs9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSk7XG5cbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbihcIlwiKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIGkobW9kdWxlcywgbWVkaWEsIGRlZHVwZSwgc3VwcG9ydHMsIGxheWVyKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCB1bmRlZmluZWRdXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXNba11bMF07XG5cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfayA9IDA7IF9rIDwgbW9kdWxlcy5sZW5ndGg7IF9rKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2tdKTtcblxuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGxheWVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbVs1XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3VwcG9ydHMpIHtcbiAgICAgICAgaWYgKCFpdGVtWzRdKSB7XG4gICAgICAgICAgaXRlbVs0XSA9IFwiXCIuY29uY2F0KHN1cHBvcnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNF0gPSBzdXBwb3J0cztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlbSkge1xuICB2YXIgY29udGVudCA9IGl0ZW1bMV07XG4gIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblxuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGNzc01hcHBpbmcpKSkpO1xuICAgIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbiAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290IHx8IFwiXCIpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oXCJcXG5cIik7XG59OyIsIi8qXG5Db3B5cmlnaHQgKGMpIDIwMDgtMjAyMiBQaXZvdGFsIExhYnNcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG5hIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcblwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xud2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG5wZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbnRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG5NRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxuTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxuT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG5XSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG4vKipcbiBUaGlzIGZpbGUgc3RhcnRzIHRoZSBwcm9jZXNzIG9mIFwiYm9vdGluZ1wiIEphc21pbmUuIEl0IGluaXRpYWxpemVzIEphc21pbmUsXG4gbWFrZXMgaXRzIGdsb2JhbHMgYXZhaWxhYmxlLCBhbmQgY3JlYXRlcyB0aGUgZW52LiBUaGlzIGZpbGUgc2hvdWxkIGJlIGxvYWRlZFxuIGFmdGVyIGBqYXNtaW5lLmpzYCBhbmQgYGphc21pbmVfaHRtbC5qc2AsIGJ1dCBiZWZvcmUgYGJvb3QxLmpzYCBvciBhbnkgcHJvamVjdFxuIHNvdXJjZSBmaWxlcyBvciBzcGVjIGZpbGVzIGFyZSBsb2FkZWQuXG4gKi9cbihmdW5jdGlvbigpIHtcbiAgdmFyIGphc21pbmVSZXF1aXJlID0gd2luZG93Lmphc21pbmVSZXF1aXJlIHx8IHJlcXVpcmUoJy4vamFzbWluZS5qcycpO1xuXG4gIC8qKlxuICAgKiAjIyBSZXF1aXJlICZhbXA7IEluc3RhbnRpYXRlXG4gICAqXG4gICAqIFJlcXVpcmUgSmFzbWluZSdzIGNvcmUgZmlsZXMuIFNwZWNpZmljYWxseSwgdGhpcyByZXF1aXJlcyBhbmQgYXR0YWNoZXMgYWxsIG9mIEphc21pbmUncyBjb2RlIHRvIHRoZSBgamFzbWluZWAgcmVmZXJlbmNlLlxuICAgKi9cbiAgdmFyIGphc21pbmUgPSBqYXNtaW5lUmVxdWlyZS5jb3JlKGphc21pbmVSZXF1aXJlKSxcbiAgICBnbG9iYWwgPSBqYXNtaW5lLmdldEdsb2JhbCgpO1xuICBnbG9iYWwuamFzbWluZSA9IGphc21pbmU7XG5cbiAgLyoqXG4gICAqIFNpbmNlIHRoaXMgaXMgYmVpbmcgcnVuIGluIGEgYnJvd3NlciBhbmQgdGhlIHJlc3VsdHMgc2hvdWxkIHBvcHVsYXRlIHRvIGFuIEhUTUwgcGFnZSwgcmVxdWlyZSB0aGUgSFRNTC1zcGVjaWZpYyBKYXNtaW5lIGNvZGUsIGluamVjdGluZyB0aGUgc2FtZSByZWZlcmVuY2UuXG4gICAqL1xuICBqYXNtaW5lUmVxdWlyZS5odG1sKGphc21pbmUpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIEphc21pbmUgZW52aXJvbm1lbnQuIFRoaXMgaXMgdXNlZCB0byBydW4gYWxsIHNwZWNzIGluIGEgcHJvamVjdC5cbiAgICovXG4gIHZhciBlbnYgPSBqYXNtaW5lLmdldEVudigpO1xuXG4gIC8qKlxuICAgKiAjIyBUaGUgR2xvYmFsIEludGVyZmFjZVxuICAgKlxuICAgKiBCdWlsZCB1cCB0aGUgZnVuY3Rpb25zIHRoYXQgd2lsbCBiZSBleHBvc2VkIGFzIHRoZSBKYXNtaW5lIHB1YmxpYyBpbnRlcmZhY2UuIEEgcHJvamVjdCBjYW4gY3VzdG9taXplLCByZW5hbWUgb3IgYWxpYXMgYW55IG9mIHRoZXNlIGZ1bmN0aW9ucyBhcyBkZXNpcmVkLCBwcm92aWRlZCB0aGUgaW1wbGVtZW50YXRpb24gcmVtYWlucyB1bmNoYW5nZWQuXG4gICAqL1xuICB2YXIgamFzbWluZUludGVyZmFjZSA9IGphc21pbmVSZXF1aXJlLmludGVyZmFjZShqYXNtaW5lLCBlbnYpO1xuXG4gIC8qKlxuICAgKiBBZGQgYWxsIG9mIHRoZSBKYXNtaW5lIGdsb2JhbC9wdWJsaWMgaW50ZXJmYWNlIHRvIHRoZSBnbG9iYWwgc2NvcGUsIHNvIGEgcHJvamVjdCBjYW4gdXNlIHRoZSBwdWJsaWMgaW50ZXJmYWNlIGRpcmVjdGx5LiBGb3IgZXhhbXBsZSwgY2FsbGluZyBgZGVzY3JpYmVgIGluIHNwZWNzIGluc3RlYWQgb2YgYGphc21pbmUuZ2V0RW52KCkuZGVzY3JpYmVgLlxuICAgKi9cbiAgZm9yICh2YXIgcHJvcGVydHkgaW4gamFzbWluZUludGVyZmFjZSkge1xuICAgIGdsb2JhbFtwcm9wZXJ0eV0gPSBqYXNtaW5lSW50ZXJmYWNlW3Byb3BlcnR5XTtcbiAgfVxufSkoKTtcbiIsIi8qXG5Db3B5cmlnaHQgKGMpIDIwMDgtMjAyMiBQaXZvdGFsIExhYnNcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG5hIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcblwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xud2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG5wZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbnRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG5NRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxuTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxuT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG5XSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG4vKipcbiBUaGlzIGZpbGUgZmluaXNoZXMgJ2Jvb3RpbmcnIEphc21pbmUsIHBlcmZvcm1pbmcgYWxsIG9mIHRoZSBuZWNlc3NhcnlcbiBpbml0aWFsaXphdGlvbiBiZWZvcmUgZXhlY3V0aW5nIHRoZSBsb2FkZWQgZW52aXJvbm1lbnQgYW5kIGFsbCBvZiBhIHByb2plY3Qnc1xuIHNwZWNzLiBUaGlzIGZpbGUgc2hvdWxkIGJlIGxvYWRlZCBhZnRlciBgYm9vdDAuanNgIGJ1dCBiZWZvcmUgYW55IHByb2plY3RcbiBzb3VyY2UgZmlsZXMgb3Igc3BlYyBmaWxlcyBhcmUgbG9hZGVkLiBUaHVzIHRoaXMgZmlsZSBjYW4gYWxzbyBiZSB1c2VkIHRvXG4gY3VzdG9taXplIEphc21pbmUgZm9yIGEgcHJvamVjdC5cblxuIElmIGEgcHJvamVjdCBpcyB1c2luZyBKYXNtaW5lIHZpYSB0aGUgc3RhbmRhbG9uZSBkaXN0cmlidXRpb24sIHRoaXMgZmlsZSBjYW5cbiBiZSBjdXN0b21pemVkIGRpcmVjdGx5LiBJZiB5b3Ugb25seSB3aXNoIHRvIGNvbmZpZ3VyZSB0aGUgSmFzbWluZSBlbnYsIHlvdVxuIGNhbiBsb2FkIGFub3RoZXIgZmlsZSB0aGF0IGNhbGxzIGBqYXNtaW5lLmdldEVudigpLmNvbmZpZ3VyZSh7Li4ufSlgXG4gYWZ0ZXIgYGJvb3QwLmpzYCBpcyBsb2FkZWQgYW5kIGJlZm9yZSB0aGlzIGZpbGUgaXMgbG9hZGVkLlxuICovXG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIGVudiA9IGphc21pbmUuZ2V0RW52KCk7XG5cbiAgLyoqXG4gICAqICMjIFJ1bm5lciBQYXJhbWV0ZXJzXG4gICAqXG4gICAqIE1vcmUgYnJvd3NlciBzcGVjaWZpYyBjb2RlIC0gd3JhcCB0aGUgcXVlcnkgc3RyaW5nIGluIGFuIG9iamVjdCBhbmQgdG8gYWxsb3cgZm9yIGdldHRpbmcvc2V0dGluZyBwYXJhbWV0ZXJzIGZyb20gdGhlIHJ1bm5lciB1c2VyIGludGVyZmFjZS5cbiAgICovXG5cbiAgdmFyIHF1ZXJ5U3RyaW5nID0gbmV3IGphc21pbmUuUXVlcnlTdHJpbmcoe1xuICAgIGdldFdpbmRvd0xvY2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb247XG4gICAgfVxuICB9KTtcblxuICB2YXIgZmlsdGVyU3BlY3MgPSAhIXF1ZXJ5U3RyaW5nLmdldFBhcmFtKCdzcGVjJyk7XG5cbiAgdmFyIGNvbmZpZyA9IHtcbiAgICBzdG9wT25TcGVjRmFpbHVyZTogcXVlcnlTdHJpbmcuZ2V0UGFyYW0oJ3N0b3BPblNwZWNGYWlsdXJlJyksXG4gICAgc3RvcFNwZWNPbkV4cGVjdGF0aW9uRmFpbHVyZTogcXVlcnlTdHJpbmcuZ2V0UGFyYW0oXG4gICAgICAnc3RvcFNwZWNPbkV4cGVjdGF0aW9uRmFpbHVyZSdcbiAgICApLFxuICAgIGhpZGVEaXNhYmxlZDogcXVlcnlTdHJpbmcuZ2V0UGFyYW0oJ2hpZGVEaXNhYmxlZCcpXG4gIH07XG5cbiAgdmFyIHJhbmRvbSA9IHF1ZXJ5U3RyaW5nLmdldFBhcmFtKCdyYW5kb20nKTtcblxuICBpZiAocmFuZG9tICE9PSB1bmRlZmluZWQgJiYgcmFuZG9tICE9PSAnJykge1xuICAgIGNvbmZpZy5yYW5kb20gPSByYW5kb207XG4gIH1cblxuICB2YXIgc2VlZCA9IHF1ZXJ5U3RyaW5nLmdldFBhcmFtKCdzZWVkJyk7XG4gIGlmIChzZWVkKSB7XG4gICAgY29uZmlnLnNlZWQgPSBzZWVkO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIFJlcG9ydGVyc1xuICAgKiBUaGUgYEh0bWxSZXBvcnRlcmAgYnVpbGRzIGFsbCBvZiB0aGUgSFRNTCBVSSBmb3IgdGhlIHJ1bm5lciBwYWdlLiBUaGlzIHJlcG9ydGVyIHBhaW50cyB0aGUgZG90cywgc3RhcnMsIGFuZCB4J3MgZm9yIHNwZWNzLCBhcyB3ZWxsIGFzIGFsbCBzcGVjIG5hbWVzIGFuZCBhbGwgZmFpbHVyZXMgKGlmIGFueSkuXG4gICAqL1xuICB2YXIgaHRtbFJlcG9ydGVyID0gbmV3IGphc21pbmUuSHRtbFJlcG9ydGVyKHtcbiAgICBlbnY6IGVudixcbiAgICBuYXZpZ2F0ZVdpdGhOZXdQYXJhbTogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHF1ZXJ5U3RyaW5nLm5hdmlnYXRlV2l0aE5ld1BhcmFtKGtleSwgdmFsdWUpO1xuICAgIH0sXG4gICAgYWRkVG9FeGlzdGluZ1F1ZXJ5U3RyaW5nOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gcXVlcnlTdHJpbmcuZnVsbFN0cmluZ1dpdGhOZXdQYXJhbShrZXksIHZhbHVlKTtcbiAgICB9LFxuICAgIGdldENvbnRhaW5lcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgICB9LFxuICAgIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQuYXBwbHkoZG9jdW1lbnQsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBjcmVhdGVUZXh0Tm9kZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUuYXBwbHkoZG9jdW1lbnQsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICB0aW1lcjogbmV3IGphc21pbmUuVGltZXIoKSxcbiAgICBmaWx0ZXJTcGVjczogZmlsdGVyU3BlY3NcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoZSBganNBcGlSZXBvcnRlcmAgYWxzbyByZWNlaXZlcyBzcGVjIHJlc3VsdHMsIGFuZCBpcyB1c2VkIGJ5IGFueSBlbnZpcm9ubWVudCB0aGF0IG5lZWRzIHRvIGV4dHJhY3QgdGhlIHJlc3VsdHMgIGZyb20gSmF2YVNjcmlwdC5cbiAgICovXG4gIGVudi5hZGRSZXBvcnRlcihqc0FwaVJlcG9ydGVyKTtcbiAgZW52LmFkZFJlcG9ydGVyKGh0bWxSZXBvcnRlcik7XG5cbiAgLyoqXG4gICAqIEZpbHRlciB3aGljaCBzcGVjcyB3aWxsIGJlIHJ1biBieSBtYXRjaGluZyB0aGUgc3RhcnQgb2YgdGhlIGZ1bGwgbmFtZSBhZ2FpbnN0IHRoZSBgc3BlY2AgcXVlcnkgcGFyYW0uXG4gICAqL1xuICB2YXIgc3BlY0ZpbHRlciA9IG5ldyBqYXNtaW5lLkh0bWxTcGVjRmlsdGVyKHtcbiAgICBmaWx0ZXJTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHF1ZXJ5U3RyaW5nLmdldFBhcmFtKCdzcGVjJyk7XG4gICAgfVxuICB9KTtcblxuICBjb25maWcuc3BlY0ZpbHRlciA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICByZXR1cm4gc3BlY0ZpbHRlci5tYXRjaGVzKHNwZWMuZ2V0RnVsbE5hbWUoKSk7XG4gIH07XG5cbiAgZW52LmNvbmZpZ3VyZShjb25maWcpO1xuXG4gIC8qKlxuICAgKiAjIyBFeGVjdXRpb25cbiAgICpcbiAgICogUmVwbGFjZSB0aGUgYnJvd3NlciB3aW5kb3cncyBgb25sb2FkYCwgZW5zdXJlIGl0J3MgY2FsbGVkLCBhbmQgdGhlbiBydW4gYWxsIG9mIHRoZSBsb2FkZWQgc3BlY3MuIFRoaXMgaW5jbHVkZXMgaW5pdGlhbGl6aW5nIHRoZSBgSHRtbFJlcG9ydGVyYCBpbnN0YW5jZSBhbmQgdGhlbiBleGVjdXRpbmcgdGhlIGxvYWRlZCBKYXNtaW5lIGVudmlyb25tZW50LiBBbGwgb2YgdGhpcyB3aWxsIGhhcHBlbiBhZnRlciBhbGwgb2YgdGhlIHNwZWNzIGFyZSBsb2FkZWQuXG4gICAqL1xuICB2YXIgY3VycmVudFdpbmRvd09ubG9hZCA9IHdpbmRvdy5vbmxvYWQ7XG5cbiAgd2luZG93Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChjdXJyZW50V2luZG93T25sb2FkKSB7XG4gICAgICBjdXJyZW50V2luZG93T25sb2FkKCk7XG4gICAgfVxuICAgIGh0bWxSZXBvcnRlci5pbml0aWFsaXplKCk7XG4gICAgZW52LmV4ZWN1dGUoKTtcbiAgfTtcbn0pKCk7XG4iLCIvKlxuQ29weXJpZ2h0IChjKSAyMDA4LTIwMjIgUGl2b3RhbCBMYWJzXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG5cIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbndpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbmRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xucGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG50aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG5pbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbkVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbk5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkVcbkxJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cbk9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xudmFyIGphc21pbmVSZXF1aXJlID0gd2luZG93Lmphc21pbmVSZXF1aXJlIHx8IHJlcXVpcmUoJy4vamFzbWluZS5qcycpO1xuXG5qYXNtaW5lUmVxdWlyZS5odG1sID0gZnVuY3Rpb24oaiQpIHtcbiAgaiQuUmVzdWx0c05vZGUgPSBqYXNtaW5lUmVxdWlyZS5SZXN1bHRzTm9kZSgpO1xuICBqJC5IdG1sUmVwb3J0ZXIgPSBqYXNtaW5lUmVxdWlyZS5IdG1sUmVwb3J0ZXIoaiQpO1xuICBqJC5RdWVyeVN0cmluZyA9IGphc21pbmVSZXF1aXJlLlF1ZXJ5U3RyaW5nKCk7XG4gIGokLkh0bWxTcGVjRmlsdGVyID0gamFzbWluZVJlcXVpcmUuSHRtbFNwZWNGaWx0ZXIoKTtcbn07XG5cbmphc21pbmVSZXF1aXJlLkh0bWxSZXBvcnRlciA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIFJlc3VsdHNTdGF0ZUJ1aWxkZXIoKSB7XG4gICAgdGhpcy50b3BSZXN1bHRzID0gbmV3IGokLlJlc3VsdHNOb2RlKHt9LCAnJywgbnVsbCk7XG4gICAgdGhpcy5jdXJyZW50UGFyZW50ID0gdGhpcy50b3BSZXN1bHRzO1xuICAgIHRoaXMuc3BlY3NFeGVjdXRlZCA9IDA7XG4gICAgdGhpcy5mYWlsdXJlQ291bnQgPSAwO1xuICAgIHRoaXMucGVuZGluZ1NwZWNDb3VudCA9IDA7XG4gIH1cblxuICBSZXN1bHRzU3RhdGVCdWlsZGVyLnByb3RvdHlwZS5zdWl0ZVN0YXJ0ZWQgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICB0aGlzLmN1cnJlbnRQYXJlbnQuYWRkQ2hpbGQocmVzdWx0LCAnc3VpdGUnKTtcbiAgICB0aGlzLmN1cnJlbnRQYXJlbnQgPSB0aGlzLmN1cnJlbnRQYXJlbnQubGFzdCgpO1xuICB9O1xuXG4gIFJlc3VsdHNTdGF0ZUJ1aWxkZXIucHJvdG90eXBlLnN1aXRlRG9uZSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIHRoaXMuY3VycmVudFBhcmVudC51cGRhdGVSZXN1bHQocmVzdWx0KTtcbiAgICBpZiAodGhpcy5jdXJyZW50UGFyZW50ICE9PSB0aGlzLnRvcFJlc3VsdHMpIHtcbiAgICAgIHRoaXMuY3VycmVudFBhcmVudCA9IHRoaXMuY3VycmVudFBhcmVudC5wYXJlbnQ7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09ICdmYWlsZWQnKSB7XG4gICAgICB0aGlzLmZhaWx1cmVDb3VudCsrO1xuICAgIH1cbiAgfTtcblxuICBSZXN1bHRzU3RhdGVCdWlsZGVyLnByb3RvdHlwZS5zcGVjU3RhcnRlZCA9IGZ1bmN0aW9uKHJlc3VsdCkge307XG5cbiAgUmVzdWx0c1N0YXRlQnVpbGRlci5wcm90b3R5cGUuc3BlY0RvbmUgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICB0aGlzLmN1cnJlbnRQYXJlbnQuYWRkQ2hpbGQocmVzdWx0LCAnc3BlYycpO1xuXG4gICAgaWYgKHJlc3VsdC5zdGF0dXMgIT09ICdleGNsdWRlZCcpIHtcbiAgICAgIHRoaXMuc3BlY3NFeGVjdXRlZCsrO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZmFpbGVkJykge1xuICAgICAgdGhpcy5mYWlsdXJlQ291bnQrKztcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0LnN0YXR1cyA9PSAncGVuZGluZycpIHtcbiAgICAgIHRoaXMucGVuZGluZ1NwZWNDb3VudCsrO1xuICAgIH1cbiAgfTtcblxuICBSZXN1bHRzU3RhdGVCdWlsZGVyLnByb3RvdHlwZS5qYXNtaW5lRG9uZSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zKSB7XG4gICAgICB0aGlzLmZhaWx1cmVDb3VudCArPSByZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gSHRtbFJlcG9ydGVyKG9wdGlvbnMpIHtcbiAgICB2YXIgY29uZmlnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5lbnYgJiYgb3B0aW9ucy5lbnYuY29uZmlndXJhdGlvbigpKSB8fCB7fTtcbiAgICAgIH0sXG4gICAgICBnZXRDb250YWluZXIgPSBvcHRpb25zLmdldENvbnRhaW5lcixcbiAgICAgIGNyZWF0ZUVsZW1lbnQgPSBvcHRpb25zLmNyZWF0ZUVsZW1lbnQsXG4gICAgICBjcmVhdGVUZXh0Tm9kZSA9IG9wdGlvbnMuY3JlYXRlVGV4dE5vZGUsXG4gICAgICBuYXZpZ2F0ZVdpdGhOZXdQYXJhbSA9IG9wdGlvbnMubmF2aWdhdGVXaXRoTmV3UGFyYW0gfHwgZnVuY3Rpb24oKSB7fSxcbiAgICAgIGFkZFRvRXhpc3RpbmdRdWVyeVN0cmluZyA9XG4gICAgICAgIG9wdGlvbnMuYWRkVG9FeGlzdGluZ1F1ZXJ5U3RyaW5nIHx8IGRlZmF1bHRRdWVyeVN0cmluZyxcbiAgICAgIGZpbHRlclNwZWNzID0gb3B0aW9ucy5maWx0ZXJTcGVjcyxcbiAgICAgIGh0bWxSZXBvcnRlck1haW4sXG4gICAgICBzeW1ib2xzLFxuICAgICAgZGVwcmVjYXRpb25XYXJuaW5ncyA9IFtdO1xuXG4gICAgdGhpcy5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICBjbGVhclByaW9yKCk7XG4gICAgICBodG1sUmVwb3J0ZXJNYWluID0gY3JlYXRlRG9tKFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lX2h0bWwtcmVwb3J0ZXInIH0sXG4gICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmUtYmFubmVyJyB9LFxuICAgICAgICAgIGNyZWF0ZURvbSgnYScsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2phc21pbmUtdGl0bGUnLFxuICAgICAgICAgICAgaHJlZjogJ2h0dHA6Ly9qYXNtaW5lLmdpdGh1Yi5pby8nLFxuICAgICAgICAgICAgdGFyZ2V0OiAnX2JsYW5rJ1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGNyZWF0ZURvbSgnc3BhbicsIHsgY2xhc3NOYW1lOiAnamFzbWluZS12ZXJzaW9uJyB9LCBqJC52ZXJzaW9uKVxuICAgICAgICApLFxuICAgICAgICBjcmVhdGVEb20oJ3VsJywgeyBjbGFzc05hbWU6ICdqYXNtaW5lLXN5bWJvbC1zdW1tYXJ5JyB9KSxcbiAgICAgICAgY3JlYXRlRG9tKCdkaXYnLCB7IGNsYXNzTmFtZTogJ2phc21pbmUtYWxlcnQnIH0pLFxuICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lLXJlc3VsdHMnIH0sXG4gICAgICAgICAgY3JlYXRlRG9tKCdkaXYnLCB7IGNsYXNzTmFtZTogJ2phc21pbmUtZmFpbHVyZXMnIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBnZXRDb250YWluZXIoKS5hcHBlbmRDaGlsZChodG1sUmVwb3J0ZXJNYWluKTtcbiAgICB9O1xuXG4gICAgdmFyIHRvdGFsU3BlY3NEZWZpbmVkO1xuICAgIHRoaXMuamFzbWluZVN0YXJ0ZWQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0b3RhbFNwZWNzRGVmaW5lZCA9IG9wdGlvbnMudG90YWxTcGVjc0RlZmluZWQgfHwgMDtcbiAgICB9O1xuXG4gICAgdmFyIHN1bW1hcnkgPSBjcmVhdGVEb20oJ2RpdicsIHsgY2xhc3NOYW1lOiAnamFzbWluZS1zdW1tYXJ5JyB9KTtcblxuICAgIHZhciBzdGF0ZUJ1aWxkZXIgPSBuZXcgUmVzdWx0c1N0YXRlQnVpbGRlcigpO1xuXG4gICAgdGhpcy5zdWl0ZVN0YXJ0ZWQgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIHN0YXRlQnVpbGRlci5zdWl0ZVN0YXJ0ZWQocmVzdWx0KTtcbiAgICB9O1xuXG4gICAgdGhpcy5zdWl0ZURvbmUgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIHN0YXRlQnVpbGRlci5zdWl0ZURvbmUocmVzdWx0KTtcblxuICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgIGZhaWx1cmVzLnB1c2goZmFpbHVyZURvbShyZXN1bHQpKTtcbiAgICAgIH1cbiAgICAgIGFkZERlcHJlY2F0aW9uV2FybmluZ3MocmVzdWx0LCAnc3VpdGUnKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zcGVjU3RhcnRlZCA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgc3RhdGVCdWlsZGVyLnNwZWNTdGFydGVkKHJlc3VsdCk7XG4gICAgfTtcblxuICAgIHZhciBmYWlsdXJlcyA9IFtdO1xuICAgIHRoaXMuc3BlY0RvbmUgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIHN0YXRlQnVpbGRlci5zcGVjRG9uZShyZXN1bHQpO1xuXG4gICAgICBpZiAobm9FeHBlY3RhdGlvbnMocmVzdWx0KSkge1xuICAgICAgICB2YXIgbm9TcGVjTXNnID0gXCJTcGVjICdcIiArIHJlc3VsdC5mdWxsTmFtZSArIFwiJyBoYXMgbm8gZXhwZWN0YXRpb25zLlwiO1xuICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKG5vU3BlY01zZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKG5vU3BlY01zZyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFzeW1ib2xzKSB7XG4gICAgICAgIHN5bWJvbHMgPSBmaW5kKCcuamFzbWluZS1zeW1ib2wtc3VtbWFyeScpO1xuICAgICAgfVxuXG4gICAgICBzeW1ib2xzLmFwcGVuZENoaWxkKFxuICAgICAgICBjcmVhdGVEb20oJ2xpJywge1xuICAgICAgICAgIGNsYXNzTmFtZTogdGhpcy5kaXNwbGF5U3BlY0luQ29ycmVjdEZvcm1hdChyZXN1bHQpLFxuICAgICAgICAgIGlkOiAnc3BlY18nICsgcmVzdWx0LmlkLFxuICAgICAgICAgIHRpdGxlOiByZXN1bHQuZnVsbE5hbWVcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZmFpbGVkJykge1xuICAgICAgICBmYWlsdXJlcy5wdXNoKGZhaWx1cmVEb20ocmVzdWx0KSk7XG4gICAgICB9XG5cbiAgICAgIGFkZERlcHJlY2F0aW9uV2FybmluZ3MocmVzdWx0LCAnc3BlYycpO1xuICAgIH07XG5cbiAgICB0aGlzLmRpc3BsYXlTcGVjSW5Db3JyZWN0Rm9ybWF0ID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICByZXR1cm4gbm9FeHBlY3RhdGlvbnMocmVzdWx0KSAmJiByZXN1bHQuc3RhdHVzID09PSAncGFzc2VkJ1xuICAgICAgICA/ICdqYXNtaW5lLWVtcHR5J1xuICAgICAgICA6IHRoaXMucmVzdWx0U3RhdHVzKHJlc3VsdC5zdGF0dXMpO1xuICAgIH07XG5cbiAgICB0aGlzLnJlc3VsdFN0YXR1cyA9IGZ1bmN0aW9uKHN0YXR1cykge1xuICAgICAgaWYgKHN0YXR1cyA9PT0gJ2V4Y2x1ZGVkJykge1xuICAgICAgICByZXR1cm4gY29uZmlnKCkuaGlkZURpc2FibGVkXG4gICAgICAgICAgPyAnamFzbWluZS1leGNsdWRlZC1uby1kaXNwbGF5J1xuICAgICAgICAgIDogJ2phc21pbmUtZXhjbHVkZWQnO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdqYXNtaW5lLScgKyBzdGF0dXM7XG4gICAgfTtcblxuICAgIHRoaXMuamFzbWluZURvbmUgPSBmdW5jdGlvbihkb25lUmVzdWx0KSB7XG4gICAgICBzdGF0ZUJ1aWxkZXIuamFzbWluZURvbmUoZG9uZVJlc3VsdCk7XG4gICAgICB2YXIgYmFubmVyID0gZmluZCgnLmphc21pbmUtYmFubmVyJyk7XG4gICAgICB2YXIgYWxlcnQgPSBmaW5kKCcuamFzbWluZS1hbGVydCcpO1xuICAgICAgdmFyIG9yZGVyID0gZG9uZVJlc3VsdCAmJiBkb25lUmVzdWx0Lm9yZGVyO1xuICAgICAgdmFyIGk7XG4gICAgICBhbGVydC5hcHBlbmRDaGlsZChcbiAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmUtZHVyYXRpb24nIH0sXG4gICAgICAgICAgJ2ZpbmlzaGVkIGluICcgKyBkb25lUmVzdWx0LnRvdGFsVGltZSAvIDEwMDAgKyAncydcbiAgICAgICAgKVxuICAgICAgKTtcblxuICAgICAgYmFubmVyLmFwcGVuZENoaWxkKG9wdGlvbnNNZW51KGNvbmZpZygpKSk7XG5cbiAgICAgIGlmIChzdGF0ZUJ1aWxkZXIuc3BlY3NFeGVjdXRlZCA8IHRvdGFsU3BlY3NEZWZpbmVkKSB7XG4gICAgICAgIHZhciBza2lwcGVkTWVzc2FnZSA9XG4gICAgICAgICAgJ1JhbiAnICtcbiAgICAgICAgICBzdGF0ZUJ1aWxkZXIuc3BlY3NFeGVjdXRlZCArXG4gICAgICAgICAgJyBvZiAnICtcbiAgICAgICAgICB0b3RhbFNwZWNzRGVmaW5lZCArXG4gICAgICAgICAgJyBzcGVjcyAtIHJ1biBhbGwnO1xuICAgICAgICAvLyBpbmNsdWRlIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSB0byBmaXggaXNzdWUgd2l0aCBrYXJtYS1qYXNtaW5lLWh0bWwtcmVwb3J0ZXIgaW4gYW5ndWxhcjogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNtaW5lL2phc21pbmUvaXNzdWVzLzE5MDZcbiAgICAgICAgdmFyIHNraXBwZWRMaW5rID1cbiAgICAgICAgICAod2luZG93LmxvY2F0aW9uLnBhdGhuYW1lIHx8ICcnKSArXG4gICAgICAgICAgYWRkVG9FeGlzdGluZ1F1ZXJ5U3RyaW5nKCdzcGVjJywgJycpO1xuICAgICAgICBhbGVydC5hcHBlbmRDaGlsZChcbiAgICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmUtYmFyIGphc21pbmUtc2tpcHBlZCcgfSxcbiAgICAgICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgICB7IGhyZWY6IHNraXBwZWRMaW5rLCB0aXRsZTogJ1J1biBhbGwgc3BlY3MnIH0sXG4gICAgICAgICAgICAgIHNraXBwZWRNZXNzYWdlXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdmFyIHN0YXR1c0Jhck1lc3NhZ2UgPSAnJztcbiAgICAgIHZhciBzdGF0dXNCYXJDbGFzc05hbWUgPSAnamFzbWluZS1vdmVyYWxsLXJlc3VsdCBqYXNtaW5lLWJhciAnO1xuICAgICAgdmFyIGdsb2JhbEZhaWx1cmVzID0gKGRvbmVSZXN1bHQgJiYgZG9uZVJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMpIHx8IFtdO1xuICAgICAgdmFyIGZhaWxlZCA9IHN0YXRlQnVpbGRlci5mYWlsdXJlQ291bnQgKyBnbG9iYWxGYWlsdXJlcy5sZW5ndGggPiAwO1xuXG4gICAgICBpZiAodG90YWxTcGVjc0RlZmluZWQgPiAwIHx8IGZhaWxlZCkge1xuICAgICAgICBzdGF0dXNCYXJNZXNzYWdlICs9XG4gICAgICAgICAgcGx1cmFsaXplKCdzcGVjJywgc3RhdGVCdWlsZGVyLnNwZWNzRXhlY3V0ZWQpICtcbiAgICAgICAgICAnLCAnICtcbiAgICAgICAgICBwbHVyYWxpemUoJ2ZhaWx1cmUnLCBzdGF0ZUJ1aWxkZXIuZmFpbHVyZUNvdW50KTtcbiAgICAgICAgaWYgKHN0YXRlQnVpbGRlci5wZW5kaW5nU3BlY0NvdW50KSB7XG4gICAgICAgICAgc3RhdHVzQmFyTWVzc2FnZSArPVxuICAgICAgICAgICAgJywgJyArIHBsdXJhbGl6ZSgncGVuZGluZyBzcGVjJywgc3RhdGVCdWlsZGVyLnBlbmRpbmdTcGVjQ291bnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkb25lUmVzdWx0Lm92ZXJhbGxTdGF0dXMgPT09ICdwYXNzZWQnKSB7XG4gICAgICAgIHN0YXR1c0JhckNsYXNzTmFtZSArPSAnIGphc21pbmUtcGFzc2VkICc7XG4gICAgICB9IGVsc2UgaWYgKGRvbmVSZXN1bHQub3ZlcmFsbFN0YXR1cyA9PT0gJ2luY29tcGxldGUnKSB7XG4gICAgICAgIHN0YXR1c0JhckNsYXNzTmFtZSArPSAnIGphc21pbmUtaW5jb21wbGV0ZSAnO1xuICAgICAgICBzdGF0dXNCYXJNZXNzYWdlID1cbiAgICAgICAgICAnSW5jb21wbGV0ZTogJyArXG4gICAgICAgICAgZG9uZVJlc3VsdC5pbmNvbXBsZXRlUmVhc29uICtcbiAgICAgICAgICAnLCAnICtcbiAgICAgICAgICBzdGF0dXNCYXJNZXNzYWdlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdHVzQmFyQ2xhc3NOYW1lICs9ICcgamFzbWluZS1mYWlsZWQgJztcbiAgICAgIH1cblxuICAgICAgdmFyIHNlZWRCYXI7XG4gICAgICBpZiAob3JkZXIgJiYgb3JkZXIucmFuZG9tKSB7XG4gICAgICAgIHNlZWRCYXIgPSBjcmVhdGVEb20oXG4gICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZS1zZWVkLWJhcicgfSxcbiAgICAgICAgICAnLCByYW5kb21pemVkIHdpdGggc2VlZCAnLFxuICAgICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGl0bGU6ICdyYW5kb21pemVkIHdpdGggc2VlZCAnICsgb3JkZXIuc2VlZCxcbiAgICAgICAgICAgICAgaHJlZjogc2VlZEhyZWYob3JkZXIuc2VlZClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcmRlci5zZWVkXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBhbGVydC5hcHBlbmRDaGlsZChcbiAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICB7IGNsYXNzTmFtZTogc3RhdHVzQmFyQ2xhc3NOYW1lIH0sXG4gICAgICAgICAgc3RhdHVzQmFyTWVzc2FnZSxcbiAgICAgICAgICBzZWVkQmFyXG4gICAgICAgIClcbiAgICAgICk7XG5cbiAgICAgIHZhciBlcnJvckJhckNsYXNzTmFtZSA9ICdqYXNtaW5lLWJhciBqYXNtaW5lLWVycm9yZWQnO1xuICAgICAgdmFyIGFmdGVyQWxsTWVzc2FnZVByZWZpeCA9ICdBZnRlckFsbCAnO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZ2xvYmFsRmFpbHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYWxlcnQuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IGVycm9yQmFyQ2xhc3NOYW1lIH0sXG4gICAgICAgICAgICBnbG9iYWxGYWlsdXJlTWVzc2FnZShnbG9iYWxGYWlsdXJlc1tpXSlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdsb2JhbEZhaWx1cmVNZXNzYWdlKGZhaWx1cmUpIHtcbiAgICAgICAgaWYgKGZhaWx1cmUuZ2xvYmFsRXJyb3JUeXBlID09PSAnbG9hZCcpIHtcbiAgICAgICAgICB2YXIgcHJlZml4ID0gJ0Vycm9yIGR1cmluZyBsb2FkaW5nOiAnICsgZmFpbHVyZS5tZXNzYWdlO1xuXG4gICAgICAgICAgaWYgKGZhaWx1cmUuZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIHByZWZpeCArICcgaW4gJyArIGZhaWx1cmUuZmlsZW5hbWUgKyAnIGxpbmUgJyArIGZhaWx1cmUubGluZW5vXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmYWlsdXJlLmdsb2JhbEVycm9yVHlwZSA9PT0gJ2FmdGVyQWxsJykge1xuICAgICAgICAgIHJldHVybiBhZnRlckFsbE1lc3NhZ2VQcmVmaXggKyBmYWlsdXJlLm1lc3NhZ2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhaWx1cmUubWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhZGREZXByZWNhdGlvbldhcm5pbmdzKGRvbmVSZXN1bHQpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZGVwcmVjYXRpb25XYXJuaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXSxcbiAgICAgICAgICBjb250ZXh0O1xuXG4gICAgICAgIHN3aXRjaCAoZGVwcmVjYXRpb25XYXJuaW5nc1tpXS5ydW5uYWJsZVR5cGUpIHtcbiAgICAgICAgICBjYXNlICdzcGVjJzpcbiAgICAgICAgICAgIGNvbnRleHQgPSAnKGluIHNwZWM6ICcgKyBkZXByZWNhdGlvbldhcm5pbmdzW2ldLnJ1bm5hYmxlTmFtZSArICcpJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3N1aXRlJzpcbiAgICAgICAgICAgIGNvbnRleHQgPSAnKGluIHN1aXRlOiAnICsgZGVwcmVjYXRpb25XYXJuaW5nc1tpXS5ydW5uYWJsZU5hbWUgKyAnKSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29udGV4dCA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5nc1tpXS5tZXNzYWdlLnNwbGl0KCdcXG4nKS5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGxpbmUpO1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goY3JlYXRlRG9tKCdicicpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2hpbGRyZW5bMF0gPSAnREVQUkVDQVRJT046ICcgKyBjaGlsZHJlblswXTtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChjb250ZXh0KTtcblxuICAgICAgICBpZiAoZGVwcmVjYXRpb25XYXJuaW5nc1tpXS5zdGFjaykge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goY3JlYXRlRXhwYW5kZXIoZGVwcmVjYXRpb25XYXJuaW5nc1tpXS5zdGFjaykpO1xuICAgICAgICB9XG5cbiAgICAgICAgYWxlcnQuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lLWJhciBqYXNtaW5lLXdhcm5pbmcnIH0sXG4gICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdHMgPSBmaW5kKCcuamFzbWluZS1yZXN1bHRzJyk7XG4gICAgICByZXN1bHRzLmFwcGVuZENoaWxkKHN1bW1hcnkpO1xuXG4gICAgICBzdW1tYXJ5TGlzdChzdGF0ZUJ1aWxkZXIudG9wUmVzdWx0cywgc3VtbWFyeSk7XG5cbiAgICAgIGlmIChmYWlsdXJlcy5sZW5ndGgpIHtcbiAgICAgICAgYWxlcnQuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lLW1lbnUgamFzbWluZS1iYXIgamFzbWluZS1zcGVjLWxpc3QnIH0sXG4gICAgICAgICAgICBjcmVhdGVEb20oJ3NwYW4nLCB7fSwgJ1NwZWMgTGlzdCB8ICcpLFxuICAgICAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICAgICAnYScsXG4gICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZS1mYWlsdXJlcy1tZW51JywgaHJlZjogJyMnIH0sXG4gICAgICAgICAgICAgICdGYWlsdXJlcydcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIGFsZXJ0LmFwcGVuZENoaWxkKFxuICAgICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZS1tZW51IGphc21pbmUtYmFyIGphc21pbmUtZmFpbHVyZS1saXN0JyB9LFxuICAgICAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICAgICAnYScsXG4gICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZS1zcGVjLWxpc3QtbWVudScsIGhyZWY6ICcjJyB9LFxuICAgICAgICAgICAgICAnU3BlYyBMaXN0J1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGNyZWF0ZURvbSgnc3BhbicsIHt9LCAnIHwgRmFpbHVyZXMgJylcbiAgICAgICAgICApXG4gICAgICAgICk7XG5cbiAgICAgICAgZmluZCgnLmphc21pbmUtZmFpbHVyZXMtbWVudScpLm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZXRNZW51TW9kZVRvKCdqYXNtaW5lLWZhaWx1cmUtbGlzdCcpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgZmluZCgnLmphc21pbmUtc3BlYy1saXN0LW1lbnUnKS5vbmNsaWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2V0TWVudU1vZGVUbygnamFzbWluZS1zcGVjLWxpc3QnKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2V0TWVudU1vZGVUbygnamFzbWluZS1mYWlsdXJlLWxpc3QnKTtcblxuICAgICAgICB2YXIgZmFpbHVyZU5vZGUgPSBmaW5kKCcuamFzbWluZS1mYWlsdXJlcycpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZmFpbHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBmYWlsdXJlTm9kZS5hcHBlbmRDaGlsZChmYWlsdXJlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgICBmdW5jdGlvbiBmYWlsdXJlRG9tKHJlc3VsdCkge1xuICAgICAgdmFyIGZhaWx1cmUgPSBjcmVhdGVEb20oXG4gICAgICAgICdkaXYnLFxuICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmUtc3BlYy1kZXRhaWwgamFzbWluZS1mYWlsZWQnIH0sXG4gICAgICAgIGZhaWx1cmVEZXNjcmlwdGlvbihyZXN1bHQsIHN0YXRlQnVpbGRlci5jdXJyZW50UGFyZW50KSxcbiAgICAgICAgY3JlYXRlRG9tKCdkaXYnLCB7IGNsYXNzTmFtZTogJ2phc21pbmUtbWVzc2FnZXMnIH0pXG4gICAgICApO1xuICAgICAgdmFyIG1lc3NhZ2VzID0gZmFpbHVyZS5jaGlsZE5vZGVzWzFdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGV4cGVjdGF0aW9uID0gcmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9uc1tpXTtcbiAgICAgICAgbWVzc2FnZXMuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmUtcmVzdWx0LW1lc3NhZ2UnIH0sXG4gICAgICAgICAgICBleHBlY3RhdGlvbi5tZXNzYWdlXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBtZXNzYWdlcy5hcHBlbmRDaGlsZChcbiAgICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZS1zdGFjay10cmFjZScgfSxcbiAgICAgICAgICAgIGV4cGVjdGF0aW9uLnN0YWNrXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbWVzc2FnZXMuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmUtcmVzdWx0LW1lc3NhZ2UnIH0sXG4gICAgICAgICAgICAnU3BlYyBoYXMgbm8gZXhwZWN0YXRpb25zJ1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdC5kZWJ1Z0xvZ3MpIHtcbiAgICAgICAgbWVzc2FnZXMuYXBwZW5kQ2hpbGQoZGVidWdMb2dUYWJsZShyZXN1bHQuZGVidWdMb2dzKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWlsdXJlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlYnVnTG9nVGFibGUoZGVidWdMb2dzKSB7XG4gICAgICB2YXIgdGJvZHkgPSBjcmVhdGVEb20oJ3Rib2R5Jyk7XG5cbiAgICAgIGRlYnVnTG9ncy5mb3JFYWNoKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgIHRib2R5LmFwcGVuZENoaWxkKFxuICAgICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAgICd0cicsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIGNyZWF0ZURvbSgndGQnLCB7fSwgZW50cnkudGltZXN0YW1wLnRvU3RyaW5nKCkpLFxuICAgICAgICAgICAgY3JlYXRlRG9tKCd0ZCcsIHt9LCBlbnRyeS5tZXNzYWdlKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gY3JlYXRlRG9tKFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lLWRlYnVnLWxvZycgfSxcbiAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICdkaXYnLFxuICAgICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZS1kZWJ1Zy1sb2ctaGVhZGVyJyB9LFxuICAgICAgICAgICdEZWJ1ZyBsb2dzJ1xuICAgICAgICApLFxuICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgJ3RhYmxlJyxcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgICAndGhlYWQnLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgICAgICd0cicsXG4gICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICBjcmVhdGVEb20oJ3RoJywge30sICdUaW1lIChtcyknKSxcbiAgICAgICAgICAgICAgY3JlYXRlRG9tKCd0aCcsIHt9LCAnTWVzc2FnZScpXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSxcbiAgICAgICAgICB0Ym9keVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1bW1hcnlMaXN0KHJlc3VsdHNUcmVlLCBkb21QYXJlbnQpIHtcbiAgICAgIHZhciBzcGVjTGlzdE5vZGU7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdHNUcmVlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByZXN1bHROb2RlID0gcmVzdWx0c1RyZWUuY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChmaWx0ZXJTcGVjcyAmJiAhaGFzQWN0aXZlU3BlYyhyZXN1bHROb2RlKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHROb2RlLnR5cGUgPT09ICdzdWl0ZScpIHtcbiAgICAgICAgICB2YXIgc3VpdGVMaXN0Tm9kZSA9IGNyZWF0ZURvbShcbiAgICAgICAgICAgICd1bCcsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmUtc3VpdGUnLCBpZDogJ3N1aXRlLScgKyByZXN1bHROb2RlLnJlc3VsdC5pZCB9LFxuICAgICAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICAgICAnbGknLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOlxuICAgICAgICAgICAgICAgICAgJ2phc21pbmUtc3VpdGUtZGV0YWlsIGphc21pbmUtJyArIHJlc3VsdE5vZGUucmVzdWx0LnN0YXR1c1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgICAgIHsgaHJlZjogc3BlY0hyZWYocmVzdWx0Tm9kZS5yZXN1bHQpIH0sXG4gICAgICAgICAgICAgICAgcmVzdWx0Tm9kZS5yZXN1bHQuZGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBzdW1tYXJ5TGlzdChyZXN1bHROb2RlLCBzdWl0ZUxpc3ROb2RlKTtcbiAgICAgICAgICBkb21QYXJlbnQuYXBwZW5kQ2hpbGQoc3VpdGVMaXN0Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdE5vZGUudHlwZSA9PT0gJ3NwZWMnKSB7XG4gICAgICAgICAgaWYgKGRvbVBhcmVudC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgIT09ICdqYXNtaW5lLXNwZWNzJykge1xuICAgICAgICAgICAgc3BlY0xpc3ROb2RlID0gY3JlYXRlRG9tKCd1bCcsIHsgY2xhc3NOYW1lOiAnamFzbWluZS1zcGVjcycgfSk7XG4gICAgICAgICAgICBkb21QYXJlbnQuYXBwZW5kQ2hpbGQoc3BlY0xpc3ROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHNwZWNEZXNjcmlwdGlvbiA9IHJlc3VsdE5vZGUucmVzdWx0LmRlc2NyaXB0aW9uO1xuICAgICAgICAgIGlmIChub0V4cGVjdGF0aW9ucyhyZXN1bHROb2RlLnJlc3VsdCkpIHtcbiAgICAgICAgICAgIHNwZWNEZXNjcmlwdGlvbiA9ICdTUEVDIEhBUyBOTyBFWFBFQ1RBVElPTlMgJyArIHNwZWNEZXNjcmlwdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcmVzdWx0Tm9kZS5yZXN1bHQuc3RhdHVzID09PSAncGVuZGluZycgJiZcbiAgICAgICAgICAgIHJlc3VsdE5vZGUucmVzdWx0LnBlbmRpbmdSZWFzb24gIT09ICcnXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBzcGVjRGVzY3JpcHRpb24gPVxuICAgICAgICAgICAgICBzcGVjRGVzY3JpcHRpb24gK1xuICAgICAgICAgICAgICAnIFBFTkRJTkcgV0lUSCBNRVNTQUdFOiAnICtcbiAgICAgICAgICAgICAgcmVzdWx0Tm9kZS5yZXN1bHQucGVuZGluZ1JlYXNvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3BlY0xpc3ROb2RlLmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICAgICAnbGknLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnamFzbWluZS0nICsgcmVzdWx0Tm9kZS5yZXN1bHQuc3RhdHVzLFxuICAgICAgICAgICAgICAgIGlkOiAnc3BlYy0nICsgcmVzdWx0Tm9kZS5yZXN1bHQuaWRcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICAgICB7IGhyZWY6IHNwZWNIcmVmKHJlc3VsdE5vZGUucmVzdWx0KSB9LFxuICAgICAgICAgICAgICAgIHNwZWNEZXNjcmlwdGlvblxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9wdGlvbnNNZW51KGNvbmZpZykge1xuICAgICAgdmFyIG9wdGlvbnNNZW51RG9tID0gY3JlYXRlRG9tKFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lLXJ1bi1vcHRpb25zJyB9LFxuICAgICAgICBjcmVhdGVEb20oJ3NwYW4nLCB7IGNsYXNzTmFtZTogJ2phc21pbmUtdHJpZ2dlcicgfSwgJ09wdGlvbnMnKSxcbiAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICdkaXYnLFxuICAgICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZS1wYXlsb2FkJyB9LFxuICAgICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lLXN0b3Atb24tZmFpbHVyZScgfSxcbiAgICAgICAgICAgIGNyZWF0ZURvbSgnaW5wdXQnLCB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2phc21pbmUtZmFpbC1mYXN0JyxcbiAgICAgICAgICAgICAgaWQ6ICdqYXNtaW5lLWZhaWwtZmFzdCcsXG4gICAgICAgICAgICAgIHR5cGU6ICdjaGVja2JveCdcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICAgICAnbGFiZWwnLFxuICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmUtbGFiZWwnLCBmb3I6ICdqYXNtaW5lLWZhaWwtZmFzdCcgfSxcbiAgICAgICAgICAgICAgJ3N0b3AgZXhlY3V0aW9uIG9uIHNwZWMgZmFpbHVyZSdcbiAgICAgICAgICAgIClcbiAgICAgICAgICApLFxuICAgICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lLXRocm93LWZhaWx1cmVzJyB9LFxuICAgICAgICAgICAgY3JlYXRlRG9tKCdpbnB1dCcsIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnamFzbWluZS10aHJvdycsXG4gICAgICAgICAgICAgIGlkOiAnamFzbWluZS10aHJvdy1mYWlsdXJlcycsXG4gICAgICAgICAgICAgIHR5cGU6ICdjaGVja2JveCdcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICAgICAnbGFiZWwnLFxuICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmUtbGFiZWwnLCBmb3I6ICdqYXNtaW5lLXRocm93LWZhaWx1cmVzJyB9LFxuICAgICAgICAgICAgICAnc3RvcCBzcGVjIG9uIGV4cGVjdGF0aW9uIGZhaWx1cmUnXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSxcbiAgICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZS1yYW5kb20tb3JkZXInIH0sXG4gICAgICAgICAgICBjcmVhdGVEb20oJ2lucHV0Jywge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6ICdqYXNtaW5lLXJhbmRvbScsXG4gICAgICAgICAgICAgIGlkOiAnamFzbWluZS1yYW5kb20tb3JkZXInLFxuICAgICAgICAgICAgICB0eXBlOiAnY2hlY2tib3gnXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAgICAgJ2xhYmVsJyxcbiAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lLWxhYmVsJywgZm9yOiAnamFzbWluZS1yYW5kb20tb3JkZXInIH0sXG4gICAgICAgICAgICAgICdydW4gdGVzdHMgaW4gcmFuZG9tIG9yZGVyJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgICksXG4gICAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmUtaGlkZS1kaXNhYmxlZCcgfSxcbiAgICAgICAgICAgIGNyZWF0ZURvbSgnaW5wdXQnLCB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2phc21pbmUtZGlzYWJsZWQnLFxuICAgICAgICAgICAgICBpZDogJ2phc21pbmUtaGlkZS1kaXNhYmxlZCcsXG4gICAgICAgICAgICAgIHR5cGU6ICdjaGVja2JveCdcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICAgICAnbGFiZWwnLFxuICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmUtbGFiZWwnLCBmb3I6ICdqYXNtaW5lLWhpZGUtZGlzYWJsZWQnIH0sXG4gICAgICAgICAgICAgICdoaWRlIGRpc2FibGVkIHRlc3RzJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKTtcblxuICAgICAgdmFyIGZhaWxGYXN0Q2hlY2tib3ggPSBvcHRpb25zTWVudURvbS5xdWVyeVNlbGVjdG9yKCcjamFzbWluZS1mYWlsLWZhc3QnKTtcbiAgICAgIGZhaWxGYXN0Q2hlY2tib3guY2hlY2tlZCA9IGNvbmZpZy5zdG9wT25TcGVjRmFpbHVyZTtcbiAgICAgIGZhaWxGYXN0Q2hlY2tib3gub25jbGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBuYXZpZ2F0ZVdpdGhOZXdQYXJhbSgnc3RvcE9uU3BlY0ZhaWx1cmUnLCAhY29uZmlnLnN0b3BPblNwZWNGYWlsdXJlKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciB0aHJvd0NoZWNrYm94ID0gb3B0aW9uc01lbnVEb20ucXVlcnlTZWxlY3RvcihcbiAgICAgICAgJyNqYXNtaW5lLXRocm93LWZhaWx1cmVzJ1xuICAgICAgKTtcbiAgICAgIHRocm93Q2hlY2tib3guY2hlY2tlZCA9IGNvbmZpZy5zdG9wU3BlY09uRXhwZWN0YXRpb25GYWlsdXJlO1xuICAgICAgdGhyb3dDaGVja2JveC5vbmNsaWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG5hdmlnYXRlV2l0aE5ld1BhcmFtKFxuICAgICAgICAgICdzdG9wU3BlY09uRXhwZWN0YXRpb25GYWlsdXJlJyxcbiAgICAgICAgICAhY29uZmlnLnN0b3BTcGVjT25FeHBlY3RhdGlvbkZhaWx1cmVcbiAgICAgICAgKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciByYW5kb21DaGVja2JveCA9IG9wdGlvbnNNZW51RG9tLnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICcjamFzbWluZS1yYW5kb20tb3JkZXInXG4gICAgICApO1xuICAgICAgcmFuZG9tQ2hlY2tib3guY2hlY2tlZCA9IGNvbmZpZy5yYW5kb207XG4gICAgICByYW5kb21DaGVja2JveC5vbmNsaWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG5hdmlnYXRlV2l0aE5ld1BhcmFtKCdyYW5kb20nLCAhY29uZmlnLnJhbmRvbSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgaGlkZURpc2FibGVkID0gb3B0aW9uc01lbnVEb20ucXVlcnlTZWxlY3RvcignI2phc21pbmUtaGlkZS1kaXNhYmxlZCcpO1xuICAgICAgaGlkZURpc2FibGVkLmNoZWNrZWQgPSBjb25maWcuaGlkZURpc2FibGVkO1xuICAgICAgaGlkZURpc2FibGVkLm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbmF2aWdhdGVXaXRoTmV3UGFyYW0oJ2hpZGVEaXNhYmxlZCcsICFjb25maWcuaGlkZURpc2FibGVkKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBvcHRpb25zVHJpZ2dlciA9IG9wdGlvbnNNZW51RG9tLnF1ZXJ5U2VsZWN0b3IoJy5qYXNtaW5lLXRyaWdnZXInKSxcbiAgICAgICAgb3B0aW9uc1BheWxvYWQgPSBvcHRpb25zTWVudURvbS5xdWVyeVNlbGVjdG9yKCcuamFzbWluZS1wYXlsb2FkJyksXG4gICAgICAgIGlzT3BlbiA9IC9cXGJqYXNtaW5lLW9wZW5cXGIvO1xuXG4gICAgICBvcHRpb25zVHJpZ2dlci5vbmNsaWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChpc09wZW4udGVzdChvcHRpb25zUGF5bG9hZC5jbGFzc05hbWUpKSB7XG4gICAgICAgICAgb3B0aW9uc1BheWxvYWQuY2xhc3NOYW1lID0gb3B0aW9uc1BheWxvYWQuY2xhc3NOYW1lLnJlcGxhY2UoXG4gICAgICAgICAgICBpc09wZW4sXG4gICAgICAgICAgICAnJ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9uc1BheWxvYWQuY2xhc3NOYW1lICs9ICcgamFzbWluZS1vcGVuJztcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIG9wdGlvbnNNZW51RG9tO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZhaWx1cmVEZXNjcmlwdGlvbihyZXN1bHQsIHN1aXRlKSB7XG4gICAgICB2YXIgd3JhcHBlciA9IGNyZWF0ZURvbShcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZS1kZXNjcmlwdGlvbicgfSxcbiAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICdhJyxcbiAgICAgICAgICB7IHRpdGxlOiByZXN1bHQuZGVzY3JpcHRpb24sIGhyZWY6IHNwZWNIcmVmKHJlc3VsdCkgfSxcbiAgICAgICAgICByZXN1bHQuZGVzY3JpcHRpb25cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHZhciBzdWl0ZUxpbms7XG5cbiAgICAgIHdoaWxlIChzdWl0ZSAmJiBzdWl0ZS5wYXJlbnQpIHtcbiAgICAgICAgd3JhcHBlci5pbnNlcnRCZWZvcmUoY3JlYXRlVGV4dE5vZGUoJyA+ICcpLCB3cmFwcGVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICBzdWl0ZUxpbmsgPSBjcmVhdGVEb20oXG4gICAgICAgICAgJ2EnLFxuICAgICAgICAgIHsgaHJlZjogc3VpdGVIcmVmKHN1aXRlKSB9LFxuICAgICAgICAgIHN1aXRlLnJlc3VsdC5kZXNjcmlwdGlvblxuICAgICAgICApO1xuICAgICAgICB3cmFwcGVyLmluc2VydEJlZm9yZShzdWl0ZUxpbmssIHdyYXBwZXIuZmlyc3RDaGlsZCk7XG5cbiAgICAgICAgc3VpdGUgPSBzdWl0ZS5wYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1aXRlSHJlZihzdWl0ZSkge1xuICAgICAgdmFyIGVscyA9IFtdO1xuXG4gICAgICB3aGlsZSAoc3VpdGUgJiYgc3VpdGUucGFyZW50KSB7XG4gICAgICAgIGVscy51bnNoaWZ0KHN1aXRlLnJlc3VsdC5kZXNjcmlwdGlvbik7XG4gICAgICAgIHN1aXRlID0gc3VpdGUucGFyZW50O1xuICAgICAgfVxuXG4gICAgICAvLyBpbmNsdWRlIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSB0byBmaXggaXNzdWUgd2l0aCBrYXJtYS1qYXNtaW5lLWh0bWwtcmVwb3J0ZXIgaW4gYW5ndWxhcjogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNtaW5lL2phc21pbmUvaXNzdWVzLzE5MDZcbiAgICAgIHJldHVybiAoXG4gICAgICAgICh3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgfHwgJycpICtcbiAgICAgICAgYWRkVG9FeGlzdGluZ1F1ZXJ5U3RyaW5nKCdzcGVjJywgZWxzLmpvaW4oJyAnKSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkRGVwcmVjYXRpb25XYXJuaW5ncyhyZXN1bHQsIHJ1bm5hYmxlVHlwZSkge1xuICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuZGVwcmVjYXRpb25XYXJuaW5ncykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5kZXByZWNhdGlvbldhcm5pbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHdhcm5pbmcgPSByZXN1bHQuZGVwcmVjYXRpb25XYXJuaW5nc1tpXS5tZXNzYWdlO1xuICAgICAgICAgIGRlcHJlY2F0aW9uV2FybmluZ3MucHVzaCh7XG4gICAgICAgICAgICBtZXNzYWdlOiB3YXJuaW5nLFxuICAgICAgICAgICAgc3RhY2s6IHJlc3VsdC5kZXByZWNhdGlvbldhcm5pbmdzW2ldLnN0YWNrLFxuICAgICAgICAgICAgcnVubmFibGVOYW1lOiByZXN1bHQuZnVsbE5hbWUsXG4gICAgICAgICAgICBydW5uYWJsZVR5cGU6IHJ1bm5hYmxlVHlwZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRXhwYW5kZXIoc3RhY2tUcmFjZSkge1xuICAgICAgdmFyIGV4cGFuZExpbmsgPSBjcmVhdGVEb20oJ2EnLCB7IGhyZWY6ICcjJyB9LCAnU2hvdyBzdGFjayB0cmFjZScpO1xuICAgICAgdmFyIHJvb3QgPSBjcmVhdGVEb20oXG4gICAgICAgICdkaXYnLFxuICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmUtZXhwYW5kZXInIH0sXG4gICAgICAgIGV4cGFuZExpbmssXG4gICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmUtZXhwYW5kZXItY29udGVudHMgamFzbWluZS1zdGFjay10cmFjZScgfSxcbiAgICAgICAgICBzdGFja1RyYWNlXG4gICAgICAgIClcbiAgICAgICk7XG5cbiAgICAgIGV4cGFuZExpbmsuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAocm9vdC5jbGFzc0xpc3QuY29udGFpbnMoJ2phc21pbmUtZXhwYW5kZWQnKSkge1xuICAgICAgICAgIHJvb3QuY2xhc3NMaXN0LnJlbW92ZSgnamFzbWluZS1leHBhbmRlZCcpO1xuICAgICAgICAgIGV4cGFuZExpbmsudGV4dENvbnRlbnQgPSAnU2hvdyBzdGFjayB0cmFjZSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm9vdC5jbGFzc0xpc3QuYWRkKCdqYXNtaW5lLWV4cGFuZGVkJyk7XG4gICAgICAgICAgZXhwYW5kTGluay50ZXh0Q29udGVudCA9ICdIaWRlIHN0YWNrIHRyYWNlJztcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByb290O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmQoc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBnZXRDb250YWluZXIoKS5xdWVyeVNlbGVjdG9yKCcuamFzbWluZV9odG1sLXJlcG9ydGVyICcgKyBzZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJQcmlvcigpIHtcbiAgICAgIC8vIHJldHVybiB0aGUgcmVwb3J0ZXJcbiAgICAgIHZhciBvbGRSZXBvcnRlciA9IGZpbmQoJycpO1xuXG4gICAgICBpZiAob2xkUmVwb3J0ZXIpIHtcbiAgICAgICAgZ2V0Q29udGFpbmVyKCkucmVtb3ZlQ2hpbGQob2xkUmVwb3J0ZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURvbSh0eXBlLCBhdHRycywgY2hpbGRyZW5BcnJheU9yVmFyQXJncykge1xuICAgICAgdmFyIGVsID0gY3JlYXRlRWxlbWVudCh0eXBlKSxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIGk7XG5cbiAgICAgIGlmIChqJC5pc0FycmF5XyhjaGlsZHJlbkFycmF5T3JWYXJBcmdzKSkge1xuICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuQXJyYXlPclZhckFyZ3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZHJlbiA9IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoY3JlYXRlVGV4dE5vZGUoY2hpbGQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgYXR0ciBpbiBhdHRycykge1xuICAgICAgICBpZiAoYXR0ciA9PSAnY2xhc3NOYW1lJykge1xuICAgICAgICAgIGVsW2F0dHJdID0gYXR0cnNbYXR0cl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJzW2F0dHJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGx1cmFsaXplKHNpbmd1bGFyLCBjb3VudCkge1xuICAgICAgdmFyIHdvcmQgPSBjb3VudCA9PSAxID8gc2luZ3VsYXIgOiBzaW5ndWxhciArICdzJztcblxuICAgICAgcmV0dXJuICcnICsgY291bnQgKyAnICcgKyB3b3JkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNwZWNIcmVmKHJlc3VsdCkge1xuICAgICAgLy8gaW5jbHVkZSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgdG8gZml4IGlzc3VlIHdpdGgga2FybWEtamFzbWluZS1odG1sLXJlcG9ydGVyIGluIGFuZ3VsYXI6IHNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzbWluZS9qYXNtaW5lL2lzc3Vlcy8xOTA2XG4gICAgICByZXR1cm4gKFxuICAgICAgICAod2luZG93LmxvY2F0aW9uLnBhdGhuYW1lIHx8ICcnKSArXG4gICAgICAgIGFkZFRvRXhpc3RpbmdRdWVyeVN0cmluZygnc3BlYycsIHJlc3VsdC5mdWxsTmFtZSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VlZEhyZWYoc2VlZCkge1xuICAgICAgLy8gaW5jbHVkZSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgdG8gZml4IGlzc3VlIHdpdGgga2FybWEtamFzbWluZS1odG1sLXJlcG9ydGVyIGluIGFuZ3VsYXI6IHNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzbWluZS9qYXNtaW5lL2lzc3Vlcy8xOTA2XG4gICAgICByZXR1cm4gKFxuICAgICAgICAod2luZG93LmxvY2F0aW9uLnBhdGhuYW1lIHx8ICcnKSArXG4gICAgICAgIGFkZFRvRXhpc3RpbmdRdWVyeVN0cmluZygnc2VlZCcsIHNlZWQpXG4gICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRRdWVyeVN0cmluZyhrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gJz8nICsga2V5ICsgJz0nICsgdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0TWVudU1vZGVUbyhtb2RlKSB7XG4gICAgICBodG1sUmVwb3J0ZXJNYWluLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnamFzbWluZV9odG1sLXJlcG9ydGVyICcgKyBtb2RlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub0V4cGVjdGF0aW9ucyhyZXN1bHQpIHtcbiAgICAgIHZhciBhbGxFeHBlY3RhdGlvbnMgPVxuICAgICAgICByZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zLmxlbmd0aCArIHJlc3VsdC5wYXNzZWRFeHBlY3RhdGlvbnMubGVuZ3RoO1xuXG4gICAgICByZXR1cm4gKFxuICAgICAgICBhbGxFeHBlY3RhdGlvbnMgPT09IDAgJiZcbiAgICAgICAgKHJlc3VsdC5zdGF0dXMgPT09ICdwYXNzZWQnIHx8IHJlc3VsdC5zdGF0dXMgPT09ICdmYWlsZWQnKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNBY3RpdmVTcGVjKHJlc3VsdE5vZGUpIHtcbiAgICAgIGlmIChyZXN1bHROb2RlLnR5cGUgPT0gJ3NwZWMnICYmIHJlc3VsdE5vZGUucmVzdWx0LnN0YXR1cyAhPSAnZXhjbHVkZWQnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0Tm9kZS50eXBlID09ICdzdWl0ZScpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSByZXN1bHROb2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgIGlmIChoYXNBY3RpdmVTcGVjKHJlc3VsdE5vZGUuY2hpbGRyZW5baV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gSHRtbFJlcG9ydGVyO1xufTtcblxuamFzbWluZVJlcXVpcmUuSHRtbFNwZWNGaWx0ZXIgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gSHRtbFNwZWNGaWx0ZXIob3B0aW9ucykge1xuICAgIHZhciBmaWx0ZXJTdHJpbmcgPVxuICAgICAgb3B0aW9ucyAmJlxuICAgICAgb3B0aW9ucy5maWx0ZXJTdHJpbmcoKSAmJlxuICAgICAgb3B0aW9ucy5maWx0ZXJTdHJpbmcoKS5yZXBsYWNlKC9bLVtcXF17fSgpKis/LixcXFxcXiR8I1xcc10vZywgJ1xcXFwkJicpO1xuICAgIHZhciBmaWx0ZXJQYXR0ZXJuID0gbmV3IFJlZ0V4cChmaWx0ZXJTdHJpbmcpO1xuXG4gICAgdGhpcy5tYXRjaGVzID0gZnVuY3Rpb24oc3BlY05hbWUpIHtcbiAgICAgIHJldHVybiBmaWx0ZXJQYXR0ZXJuLnRlc3Qoc3BlY05hbWUpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gSHRtbFNwZWNGaWx0ZXI7XG59O1xuXG5qYXNtaW5lUmVxdWlyZS5SZXN1bHRzTm9kZSA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBSZXN1bHRzTm9kZShyZXN1bHQsIHR5cGUsIHBhcmVudCkge1xuICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG5cbiAgICB0aGlzLmFkZENoaWxkID0gZnVuY3Rpb24ocmVzdWx0LCB0eXBlKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2gobmV3IFJlc3VsdHNOb2RlKHJlc3VsdCwgdHlwZSwgdGhpcykpO1xuICAgIH07XG5cbiAgICB0aGlzLmxhc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgfTtcblxuICAgIHRoaXMudXBkYXRlUmVzdWx0ID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIFJlc3VsdHNOb2RlO1xufTtcblxuamFzbWluZVJlcXVpcmUuUXVlcnlTdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gUXVlcnlTdHJpbmcob3B0aW9ucykge1xuICAgIHRoaXMubmF2aWdhdGVXaXRoTmV3UGFyYW0gPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICBvcHRpb25zLmdldFdpbmRvd0xvY2F0aW9uKCkuc2VhcmNoID0gdGhpcy5mdWxsU3RyaW5nV2l0aE5ld1BhcmFtKFxuICAgICAgICBrZXksXG4gICAgICAgIHZhbHVlXG4gICAgICApO1xuICAgIH07XG5cbiAgICB0aGlzLmZ1bGxTdHJpbmdXaXRoTmV3UGFyYW0gPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgcGFyYW1NYXAgPSBxdWVyeVN0cmluZ1RvUGFyYW1NYXAoKTtcbiAgICAgIHBhcmFtTWFwW2tleV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0b1F1ZXJ5U3RyaW5nKHBhcmFtTWFwKTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRQYXJhbSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIHF1ZXJ5U3RyaW5nVG9QYXJhbU1hcCgpW2tleV07XG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gICAgZnVuY3Rpb24gdG9RdWVyeVN0cmluZyhwYXJhbU1hcCkge1xuICAgICAgdmFyIHFTdHJQYWlycyA9IFtdO1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBwYXJhbU1hcCkge1xuICAgICAgICBxU3RyUGFpcnMucHVzaChcbiAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQocHJvcCkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQocGFyYW1NYXBbcHJvcF0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gJz8nICsgcVN0clBhaXJzLmpvaW4oJyYnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBxdWVyeVN0cmluZ1RvUGFyYW1NYXAoKSB7XG4gICAgICB2YXIgcGFyYW1TdHIgPSBvcHRpb25zLmdldFdpbmRvd0xvY2F0aW9uKCkuc2VhcmNoLnN1YnN0cmluZygxKSxcbiAgICAgICAgcGFyYW1zID0gW10sXG4gICAgICAgIHBhcmFtTWFwID0ge307XG5cbiAgICAgIGlmIChwYXJhbVN0ci5sZW5ndGggPiAwKSB7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtU3RyLnNwbGl0KCcmJyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHAgPSBwYXJhbXNbaV0uc3BsaXQoJz0nKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQocFsxXSk7XG4gICAgICAgICAgaWYgKHZhbHVlID09PSAndHJ1ZScgfHwgdmFsdWUgPT09ICdmYWxzZScpIHtcbiAgICAgICAgICAgIHZhbHVlID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmFtTWFwW2RlY29kZVVSSUNvbXBvbmVudChwWzBdKV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyYW1NYXA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFF1ZXJ5U3RyaW5nO1xufTtcbiIsIi8qXG5Db3B5cmlnaHQgKGMpIDIwMDgtMjAyMiBQaXZvdGFsIExhYnNcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG5hIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcblwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xud2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG5wZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbnRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG5NRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxuTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxuT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG5XSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbnZhciBnZXRKYXNtaW5lUmVxdWlyZU9iaiA9IChmdW5jdGlvbihqYXNtaW5lR2xvYmFsKSB7XG4gIHZhciBqYXNtaW5lUmVxdWlyZTtcblxuICBpZiAoXG4gICAgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBtb2R1bGUuZXhwb3J0cyAmJlxuICAgIHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJ1xuICApIHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGphc21pbmVHbG9iYWwgPSBnbG9iYWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGphc21pbmVHbG9iYWwgPSB7fTtcbiAgICB9XG4gICAgamFzbWluZVJlcXVpcmUgPSBleHBvcnRzO1xuICB9IGVsc2Uge1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2Ygd2luZG93LnRvU3RyaW5nID09PSAnZnVuY3Rpb24nICYmXG4gICAgICB3aW5kb3cudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgR2pzR2xvYmFsXSdcbiAgICApIHtcbiAgICAgIGphc21pbmVHbG9iYWwgPSB3aW5kb3c7XG4gICAgfVxuICAgIGphc21pbmVSZXF1aXJlID0gamFzbWluZUdsb2JhbC5qYXNtaW5lUmVxdWlyZSA9IHt9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SmFzbWluZVJlcXVpcmUoKSB7XG4gICAgcmV0dXJuIGphc21pbmVSZXF1aXJlO1xuICB9XG5cbiAgZ2V0SmFzbWluZVJlcXVpcmUoKS5jb3JlID0gZnVuY3Rpb24oalJlcXVpcmUpIHtcbiAgICB2YXIgaiQgPSB7fTtcblxuICAgIGpSZXF1aXJlLmJhc2UoaiQsIGphc21pbmVHbG9iYWwpO1xuICAgIGokLnV0aWwgPSBqUmVxdWlyZS51dGlsKGokKTtcbiAgICBqJC5lcnJvcnMgPSBqUmVxdWlyZS5lcnJvcnMoKTtcbiAgICBqJC5mb3JtYXRFcnJvck1zZyA9IGpSZXF1aXJlLmZvcm1hdEVycm9yTXNnKCk7XG4gICAgaiQuQW55ID0galJlcXVpcmUuQW55KGokKTtcbiAgICBqJC5Bbnl0aGluZyA9IGpSZXF1aXJlLkFueXRoaW5nKGokKTtcbiAgICBqJC5DYWxsVHJhY2tlciA9IGpSZXF1aXJlLkNhbGxUcmFja2VyKGokKTtcbiAgICBqJC5Nb2NrRGF0ZSA9IGpSZXF1aXJlLk1vY2tEYXRlKGokKTtcbiAgICBqJC5nZXRDbGVhclN0YWNrID0galJlcXVpcmUuY2xlYXJTdGFjayhqJCk7XG4gICAgaiQuQ2xvY2sgPSBqUmVxdWlyZS5DbG9jaygpO1xuICAgIGokLkRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlciA9IGpSZXF1aXJlLkRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlcihqJCk7XG4gICAgaiQuRGVwcmVjYXRvciA9IGpSZXF1aXJlLkRlcHJlY2F0b3IoaiQpO1xuICAgIGokLkVudiA9IGpSZXF1aXJlLkVudihqJCk7XG4gICAgaiQuU3RhY2tUcmFjZSA9IGpSZXF1aXJlLlN0YWNrVHJhY2UoaiQpO1xuICAgIGokLkV4Y2VwdGlvbkZvcm1hdHRlciA9IGpSZXF1aXJlLkV4Y2VwdGlvbkZvcm1hdHRlcihqJCk7XG4gICAgaiQuRXhwZWN0YXRpb25GaWx0ZXJDaGFpbiA9IGpSZXF1aXJlLkV4cGVjdGF0aW9uRmlsdGVyQ2hhaW4oKTtcbiAgICBqJC5FeHBlY3RvciA9IGpSZXF1aXJlLkV4cGVjdG9yKGokKTtcbiAgICBqJC5FeHBlY3RhdGlvbiA9IGpSZXF1aXJlLkV4cGVjdGF0aW9uKGokKTtcbiAgICBqJC5idWlsZEV4cGVjdGF0aW9uUmVzdWx0ID0galJlcXVpcmUuYnVpbGRFeHBlY3RhdGlvblJlc3VsdChqJCk7XG4gICAgaiQuSnNBcGlSZXBvcnRlciA9IGpSZXF1aXJlLkpzQXBpUmVwb3J0ZXIoaiQpO1xuICAgIGokLm1ha2VQcmV0dHlQcmludGVyID0galJlcXVpcmUubWFrZVByZXR0eVByaW50ZXIoaiQpO1xuICAgIGokLmJhc2ljUHJldHR5UHJpbnRlcl8gPSBqJC5tYWtlUHJldHR5UHJpbnRlcigpO1xuICAgIGokLk1hdGNoZXJzVXRpbCA9IGpSZXF1aXJlLk1hdGNoZXJzVXRpbChqJCk7XG4gICAgaiQuT2JqZWN0Q29udGFpbmluZyA9IGpSZXF1aXJlLk9iamVjdENvbnRhaW5pbmcoaiQpO1xuICAgIGokLkFycmF5Q29udGFpbmluZyA9IGpSZXF1aXJlLkFycmF5Q29udGFpbmluZyhqJCk7XG4gICAgaiQuQXJyYXlXaXRoRXhhY3RDb250ZW50cyA9IGpSZXF1aXJlLkFycmF5V2l0aEV4YWN0Q29udGVudHMoaiQpO1xuICAgIGokLk1hcENvbnRhaW5pbmcgPSBqUmVxdWlyZS5NYXBDb250YWluaW5nKGokKTtcbiAgICBqJC5TZXRDb250YWluaW5nID0galJlcXVpcmUuU2V0Q29udGFpbmluZyhqJCk7XG4gICAgaiQuUXVldWVSdW5uZXIgPSBqUmVxdWlyZS5RdWV1ZVJ1bm5lcihqJCk7XG4gICAgaiQuTmV2ZXJTa2lwUG9saWN5ID0galJlcXVpcmUuTmV2ZXJTa2lwUG9saWN5KGokKTtcbiAgICBqJC5Ta2lwQWZ0ZXJCZWZvcmVBbGxFcnJvclBvbGljeSA9IGpSZXF1aXJlLlNraXBBZnRlckJlZm9yZUFsbEVycm9yUG9saWN5KFxuICAgICAgaiRcbiAgICApO1xuICAgIGokLkNvbXBsZXRlT25GaXJzdEVycm9yU2tpcFBvbGljeSA9IGpSZXF1aXJlLkNvbXBsZXRlT25GaXJzdEVycm9yU2tpcFBvbGljeShcbiAgICAgIGokXG4gICAgKTtcbiAgICBqJC5SZXBvcnREaXNwYXRjaGVyID0galJlcXVpcmUuUmVwb3J0RGlzcGF0Y2hlcihqJCk7XG4gICAgaiQuU3BlYyA9IGpSZXF1aXJlLlNwZWMoaiQpO1xuICAgIGokLlNweSA9IGpSZXF1aXJlLlNweShqJCk7XG4gICAgaiQuU3B5RmFjdG9yeSA9IGpSZXF1aXJlLlNweUZhY3RvcnkoaiQpO1xuICAgIGokLlNweVJlZ2lzdHJ5ID0galJlcXVpcmUuU3B5UmVnaXN0cnkoaiQpO1xuICAgIGokLlNweVN0cmF0ZWd5ID0galJlcXVpcmUuU3B5U3RyYXRlZ3koaiQpO1xuICAgIGokLlN0cmluZ01hdGNoaW5nID0galJlcXVpcmUuU3RyaW5nTWF0Y2hpbmcoaiQpO1xuICAgIGokLlN0cmluZ0NvbnRhaW5pbmcgPSBqUmVxdWlyZS5TdHJpbmdDb250YWluaW5nKGokKTtcbiAgICBqJC5Vc2VyQ29udGV4dCA9IGpSZXF1aXJlLlVzZXJDb250ZXh0KGokKTtcbiAgICBqJC5TdWl0ZSA9IGpSZXF1aXJlLlN1aXRlKGokKTtcbiAgICBqJC5UaW1lciA9IGpSZXF1aXJlLlRpbWVyKCk7XG4gICAgaiQuVHJlZVByb2Nlc3NvciA9IGpSZXF1aXJlLlRyZWVQcm9jZXNzb3IoKTtcbiAgICBqJC52ZXJzaW9uID0galJlcXVpcmUudmVyc2lvbigpO1xuICAgIGokLk9yZGVyID0galJlcXVpcmUuT3JkZXIoKTtcbiAgICBqJC5EaWZmQnVpbGRlciA9IGpSZXF1aXJlLkRpZmZCdWlsZGVyKGokKTtcbiAgICBqJC5OdWxsRGlmZkJ1aWxkZXIgPSBqUmVxdWlyZS5OdWxsRGlmZkJ1aWxkZXIoaiQpO1xuICAgIGokLk9iamVjdFBhdGggPSBqUmVxdWlyZS5PYmplY3RQYXRoKGokKTtcbiAgICBqJC5NaXNtYXRjaFRyZWUgPSBqUmVxdWlyZS5NaXNtYXRjaFRyZWUoaiQpO1xuICAgIGokLkdsb2JhbEVycm9ycyA9IGpSZXF1aXJlLkdsb2JhbEVycm9ycyhqJCk7XG5cbiAgICBqJC5UcnV0aHkgPSBqUmVxdWlyZS5UcnV0aHkoaiQpO1xuICAgIGokLkZhbHN5ID0galJlcXVpcmUuRmFsc3koaiQpO1xuICAgIGokLkVtcHR5ID0galJlcXVpcmUuRW1wdHkoaiQpO1xuICAgIGokLk5vdEVtcHR5ID0galJlcXVpcmUuTm90RW1wdHkoaiQpO1xuXG4gICAgaiQubWF0Y2hlcnMgPSBqUmVxdWlyZS5yZXF1aXJlTWF0Y2hlcnMoalJlcXVpcmUsIGokKTtcbiAgICBqJC5hc3luY01hdGNoZXJzID0galJlcXVpcmUucmVxdWlyZUFzeW5jTWF0Y2hlcnMoalJlcXVpcmUsIGokKTtcblxuICAgIHJldHVybiBqJDtcbiAgfTtcblxuICByZXR1cm4gZ2V0SmFzbWluZVJlcXVpcmU7XG59KSh0aGlzKTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5yZXF1aXJlTWF0Y2hlcnMgPSBmdW5jdGlvbihqUmVxdWlyZSwgaiQpIHtcbiAgdmFyIGF2YWlsYWJsZU1hdGNoZXJzID0gW1xuICAgICAgJ25vdGhpbmcnLFxuICAgICAgJ3RvQmUnLFxuICAgICAgJ3RvQmVDbG9zZVRvJyxcbiAgICAgICd0b0JlRGVmaW5lZCcsXG4gICAgICAndG9CZUluc3RhbmNlT2YnLFxuICAgICAgJ3RvQmVGYWxzZScsXG4gICAgICAndG9CZUZhbHN5JyxcbiAgICAgICd0b0JlR3JlYXRlclRoYW4nLFxuICAgICAgJ3RvQmVHcmVhdGVyVGhhbk9yRXF1YWwnLFxuICAgICAgJ3RvQmVMZXNzVGhhbicsXG4gICAgICAndG9CZUxlc3NUaGFuT3JFcXVhbCcsXG4gICAgICAndG9CZU5hTicsXG4gICAgICAndG9CZU5lZ2F0aXZlSW5maW5pdHknLFxuICAgICAgJ3RvQmVOdWxsJyxcbiAgICAgICd0b0JlUG9zaXRpdmVJbmZpbml0eScsXG4gICAgICAndG9CZVRydWUnLFxuICAgICAgJ3RvQmVUcnV0aHknLFxuICAgICAgJ3RvQmVVbmRlZmluZWQnLFxuICAgICAgJ3RvQ29udGFpbicsXG4gICAgICAndG9FcXVhbCcsXG4gICAgICAndG9IYXZlU2l6ZScsXG4gICAgICAndG9IYXZlQmVlbkNhbGxlZCcsXG4gICAgICAndG9IYXZlQmVlbkNhbGxlZEJlZm9yZScsXG4gICAgICAndG9IYXZlQmVlbkNhbGxlZE9uY2VXaXRoJyxcbiAgICAgICd0b0hhdmVCZWVuQ2FsbGVkVGltZXMnLFxuICAgICAgJ3RvSGF2ZUJlZW5DYWxsZWRXaXRoJyxcbiAgICAgICd0b0hhdmVDbGFzcycsXG4gICAgICAndG9NYXRjaCcsXG4gICAgICAndG9UaHJvdycsXG4gICAgICAndG9UaHJvd0Vycm9yJyxcbiAgICAgICd0b1Rocm93TWF0Y2hpbmcnXG4gICAgXSxcbiAgICBtYXRjaGVycyA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXZhaWxhYmxlTWF0Y2hlcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmFtZSA9IGF2YWlsYWJsZU1hdGNoZXJzW2ldO1xuICAgIG1hdGNoZXJzW25hbWVdID0galJlcXVpcmVbbmFtZV0oaiQpO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXJzO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5iYXNlID0gZnVuY3Rpb24oaiQsIGphc21pbmVHbG9iYWwpIHtcbiAgaiQudW5pbXBsZW1lbnRlZE1ldGhvZF8gPSBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuaW1wbGVtZW50ZWQgbWV0aG9kJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1heGltdW0gb2JqZWN0IGRlcHRoIHRoZSBwcmV0dHkgcHJpbnRlciB3aWxsIHByaW50IHRvLlxuICAgKiBTZXQgdGhpcyB0byBhIGxvd2VyIHZhbHVlIHRvIHNwZWVkIHVwIHByZXR0eSBwcmludGluZyBpZiB5b3UgaGF2ZSBsYXJnZSBvYmplY3RzLlxuICAgKiBAbmFtZSBqYXNtaW5lLk1BWF9QUkVUVFlfUFJJTlRfREVQVEhcbiAgICogQGRlZmF1bHQgOFxuICAgKiBAc2luY2UgMS4zLjBcbiAgICovXG4gIGokLk1BWF9QUkVUVFlfUFJJTlRfREVQVEggPSA4O1xuICAvKipcbiAgICogTWF4aW11bSBudW1iZXIgb2YgYXJyYXkgZWxlbWVudHMgdG8gZGlzcGxheSB3aGVuIHByZXR0eSBwcmludGluZyBvYmplY3RzLlxuICAgKiBUaGlzIHdpbGwgYWxzbyBsaW1pdCB0aGUgbnVtYmVyIG9mIGtleXMgYW5kIHZhbHVlcyBkaXNwbGF5ZWQgZm9yIGFuIG9iamVjdC5cbiAgICogRWxlbWVudHMgcGFzdCB0aGlzIG51bWJlciB3aWxsIGJlIGVsbGlwaXNlZC5cbiAgICogQG5hbWUgamFzbWluZS5NQVhfUFJFVFRZX1BSSU5UX0FSUkFZX0xFTkdUSFxuICAgKiBAZGVmYXVsdCA1MFxuICAgKiBAc2luY2UgMi43LjBcbiAgICovXG4gIGokLk1BWF9QUkVUVFlfUFJJTlRfQVJSQVlfTEVOR1RIID0gNTA7XG4gIC8qKlxuICAgKiBNYXhpbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIGRpc3BsYXkgd2hlbiBwcmV0dHkgcHJpbnRpbmcgb2JqZWN0cy5cbiAgICogQ2hhcmFjdGVycyBwYXN0IHRoaXMgbnVtYmVyIHdpbGwgYmUgZWxsaXBpc2VkLlxuICAgKiBAbmFtZSBqYXNtaW5lLk1BWF9QUkVUVFlfUFJJTlRfQ0hBUlNcbiAgICogQGRlZmF1bHQgMTAwXG4gICAqIEBzaW5jZSAyLjkuMFxuICAgKi9cbiAgaiQuTUFYX1BSRVRUWV9QUklOVF9DSEFSUyA9IDEwMDA7XG4gIC8qKlxuICAgKiBEZWZhdWx0IG51bWJlciBvZiBtaWxsaXNlY29uZHMgSmFzbWluZSB3aWxsIHdhaXQgZm9yIGFuIGFzeW5jaHJvbm91cyBzcGVjLFxuICAgKiBiZWZvcmUsIG9yIGFmdGVyIGZ1bmN0aW9uIHRvIGNvbXBsZXRlLiBUaGlzIGNhbiBiZSBvdmVycmlkZGVuIG9uIGEgY2FzZSBieVxuICAgKiBjYXNlIGJhc2lzIGJ5IHBhc3NpbmcgYSB0aW1lIGxpbWl0IGFzIHRoZSB0aGlyZCBhcmd1bWVudCB0byB7QGxpbmsgaXR9LFxuICAgKiB7QGxpbmsgYmVmb3JlRWFjaH0sIHtAbGluayBhZnRlckVhY2h9LCB7QGxpbmsgYmVmb3JlQWxsfSwgb3JcbiAgICoge0BsaW5rIGFmdGVyQWxsfS4gVGhlIHZhbHVlIG11c3QgYmUgbm8gZ3JlYXRlciB0aGFuIHRoZSBsYXJnZXN0IG51bWJlciBvZlxuICAgKiBtaWxsaXNlY29uZHMgc3VwcG9ydGVkIGJ5IHNldFRpbWVvdXQsIHdoaWNoIGlzIHVzdWFsbHkgMjE0NzQ4MzY0Ny5cbiAgICpcbiAgICogV2hpbGUgZGVidWdnaW5nIHRlc3RzLCB5b3UgbWF5IHdhbnQgdG8gc2V0IHRoaXMgdG8gYSBsYXJnZSBudW1iZXIgKG9yIHBhc3NcbiAgICogYSBsYXJnZSBudW1iZXIgdG8gb25lIG9mIHRoZSBmdW5jdGlvbnMgbWVudGlvbmVkIGFib3ZlKSBzbyB0aGF0IEphc21pbmVcbiAgICogZG9lcyBub3QgbW92ZSBvbiB0byBhZnRlciBmdW5jdGlvbnMgb3IgdGhlIG5leHQgc3BlYyB3aGlsZSB5b3UncmUgZGVidWdnaW5nLlxuICAgKiBAbmFtZSBqYXNtaW5lLkRFRkFVTFRfVElNRU9VVF9JTlRFUlZBTFxuICAgKiBAZGVmYXVsdCA1MDAwXG4gICAqIEBzaW5jZSAxLjMuMFxuICAgKi9cbiAgdmFyIERFRkFVTFRfVElNRU9VVF9JTlRFUlZBTCA9IDUwMDA7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShqJCwgJ0RFRkFVTFRfVElNRU9VVF9JTlRFUlZBTCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIERFRkFVTFRfVElNRU9VVF9JTlRFUlZBTDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAgICAgIGokLnV0aWwudmFsaWRhdGVUaW1lb3V0KG5ld1ZhbHVlLCAnamFzbWluZS5ERUZBVUxUX1RJTUVPVVRfSU5URVJWQUwnKTtcbiAgICAgIERFRkFVTFRfVElNRU9VVF9JTlRFUlZBTCA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgaiQuZ2V0R2xvYmFsID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGphc21pbmVHbG9iYWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudGx5IGJvb3RlZCBKYXNtaW5lIEVudmlyb25tZW50LlxuICAgKlxuICAgKiBAbmFtZSBqYXNtaW5lLmdldEVudlxuICAgKiBAc2luY2UgMS4zLjBcbiAgICogQGZ1bmN0aW9uXG4gICAqIEByZXR1cm4ge0Vudn1cbiAgICovXG4gIGokLmdldEVudiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgZW52ID0gKGokLmN1cnJlbnRFbnZfID0gaiQuY3VycmVudEVudl8gfHwgbmV3IGokLkVudihvcHRpb25zKSk7XG4gICAgLy9qYXNtaW5lLiBzaW5nbGV0b25zIGluIGhlcmUgKHNldFRpbWVvdXQgYmxhaCBibGFoKS5cbiAgICByZXR1cm4gZW52O1xuICB9O1xuXG4gIGokLmlzQXJyYXlfID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gaiQuaXNBXygnQXJyYXknLCB2YWx1ZSk7XG4gIH07XG5cbiAgaiQuaXNPYmplY3RfID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgIWokLnV0aWwuaXNVbmRlZmluZWQodmFsdWUpICYmIHZhbHVlICE9PSBudWxsICYmIGokLmlzQV8oJ09iamVjdCcsIHZhbHVlKVxuICAgICk7XG4gIH07XG5cbiAgaiQuaXNTdHJpbmdfID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gaiQuaXNBXygnU3RyaW5nJywgdmFsdWUpO1xuICB9O1xuXG4gIGokLmlzTnVtYmVyXyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGokLmlzQV8oJ051bWJlcicsIHZhbHVlKTtcbiAgfTtcblxuICBqJC5pc0Z1bmN0aW9uXyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGokLmlzQV8oJ0Z1bmN0aW9uJywgdmFsdWUpO1xuICB9O1xuXG4gIGokLmlzQXN5bmNGdW5jdGlvbl8gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBqJC5pc0FfKCdBc3luY0Z1bmN0aW9uJywgdmFsdWUpO1xuICB9O1xuXG4gIGokLmlzR2VuZXJhdG9yRnVuY3Rpb25fID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gaiQuaXNBXygnR2VuZXJhdG9yRnVuY3Rpb24nLCB2YWx1ZSk7XG4gIH07XG5cbiAgaiQuaXNUeXBlZEFycmF5XyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGokLmlzQV8oJ0Zsb2F0MzJBcnJheScsIHZhbHVlKSB8fFxuICAgICAgaiQuaXNBXygnRmxvYXQ2NEFycmF5JywgdmFsdWUpIHx8XG4gICAgICBqJC5pc0FfKCdJbnQxNkFycmF5JywgdmFsdWUpIHx8XG4gICAgICBqJC5pc0FfKCdJbnQzMkFycmF5JywgdmFsdWUpIHx8XG4gICAgICBqJC5pc0FfKCdJbnQ4QXJyYXknLCB2YWx1ZSkgfHxcbiAgICAgIGokLmlzQV8oJ1VpbnQxNkFycmF5JywgdmFsdWUpIHx8XG4gICAgICBqJC5pc0FfKCdVaW50MzJBcnJheScsIHZhbHVlKSB8fFxuICAgICAgaiQuaXNBXygnVWludDhBcnJheScsIHZhbHVlKSB8fFxuICAgICAgaiQuaXNBXygnVWludDhDbGFtcGVkQXJyYXknLCB2YWx1ZSlcbiAgICApO1xuICB9O1xuXG4gIGokLmlzQV8gPSBmdW5jdGlvbih0eXBlTmFtZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gaiQuZ2V0VHlwZV8odmFsdWUpID09PSAnW29iamVjdCAnICsgdHlwZU5hbWUgKyAnXSc7XG4gIH07XG5cbiAgaiQuaXNFcnJvcl8gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS5zdGFjayA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT09ICdzdHJpbmcnO1xuICB9O1xuXG4gIGokLmlzQXN5bW1ldHJpY0VxdWFsaXR5VGVzdGVyXyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPyBqJC5pc0FfKCdGdW5jdGlvbicsIG9iai5hc3ltbWV0cmljTWF0Y2gpIDogZmFsc2U7XG4gIH07XG5cbiAgaiQuZ2V0VHlwZV8gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHZhbHVlKTtcbiAgfTtcblxuICBqJC5pc0RvbU5vZGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICAvLyBOb2RlIGlzIGEgZnVuY3Rpb24sIGJlY2F1c2UgY29uc3RydWN0b3JzXG4gICAgcmV0dXJuIHR5cGVvZiBqYXNtaW5lR2xvYmFsLk5vZGUgIT09ICd1bmRlZmluZWQnXG4gICAgICA/IG9iaiBpbnN0YW5jZW9mIGphc21pbmVHbG9iYWwuTm9kZVxuICAgICAgOiBvYmogIT09IG51bGwgJiZcbiAgICAgICAgICB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgIHR5cGVvZiBvYmoubm9kZVR5cGUgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgdHlwZW9mIG9iai5ub2RlTmFtZSA9PT0gJ3N0cmluZyc7XG4gICAgLy8gcmV0dXJuIG9iai5ub2RlVHlwZSA+IDA7XG4gIH07XG5cbiAgaiQuaXNNYXAgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gKFxuICAgICAgb2JqICE9PSBudWxsICYmXG4gICAgICB0eXBlb2Ygb2JqICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yID09PSBqYXNtaW5lR2xvYmFsLk1hcFxuICAgICk7XG4gIH07XG5cbiAgaiQuaXNTZXQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gKFxuICAgICAgb2JqICE9PSBudWxsICYmXG4gICAgICB0eXBlb2Ygb2JqICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yID09PSBqYXNtaW5lR2xvYmFsLlNldFxuICAgICk7XG4gIH07XG5cbiAgaiQuaXNXZWFrTWFwID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIG9iaiAhPT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIG9iaiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3RvciA9PT0gamFzbWluZUdsb2JhbC5XZWFrTWFwXG4gICAgKTtcbiAgfTtcblxuICBqJC5pc1VSTCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAoXG4gICAgICBvYmogIT09IG51bGwgJiZcbiAgICAgIHR5cGVvZiBvYmogIT09ICd1bmRlZmluZWQnICYmXG4gICAgICBvYmouY29uc3RydWN0b3IgPT09IGphc21pbmVHbG9iYWwuVVJMXG4gICAgKTtcbiAgfTtcblxuICBqJC5pc0l0ZXJhYmxlXyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmICEhdmFsdWVbU3ltYm9sLml0ZXJhdG9yXTtcbiAgfTtcblxuICBqJC5pc0RhdGFWaWV3ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIG9iaiAhPT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIG9iaiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3RvciA9PT0gamFzbWluZUdsb2JhbC5EYXRhVmlld1xuICAgICk7XG4gIH07XG5cbiAgaiQuaXNQcm9taXNlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhb2JqICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gamFzbWluZUdsb2JhbC5Qcm9taXNlO1xuICB9O1xuXG4gIGokLmlzUHJvbWlzZUxpa2UgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISFvYmogJiYgaiQuaXNGdW5jdGlvbl8ob2JqLnRoZW4pO1xuICB9O1xuXG4gIGokLmZuTmFtZUZvciA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICBpZiAoZnVuYy5uYW1lKSB7XG4gICAgICByZXR1cm4gZnVuYy5uYW1lO1xuICAgIH1cblxuICAgIHZhciBtYXRjaGVzID1cbiAgICAgIGZ1bmMudG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvblxccyooXFx3KylcXHMqXFwoLykgfHxcbiAgICAgIGZ1bmMudG9TdHJpbmcoKS5tYXRjaCgvXlxccypcXFtvYmplY3RcXHMqKFxcdyspQ29uc3RydWN0b3JcXF0vKTtcblxuICAgIHJldHVybiBtYXRjaGVzID8gbWF0Y2hlc1sxXSA6ICc8YW5vbnltb3VzPic7XG4gIH07XG5cbiAgaiQuaXNQZW5kaW5nXyA9IGZ1bmN0aW9uKHByb21pc2UpIHtcbiAgICB2YXIgc2VudGluZWwgPSB7fTtcbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtwcm9taXNlLCBQcm9taXNlLnJlc29sdmUoc2VudGluZWwpXSkudGhlbihcbiAgICAgIGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0ID09PSBzZW50aW5lbDtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiB7QGxpbmsgQXN5bW1ldHJpY0VxdWFsaXR5VGVzdGVyfSwgdXNhYmxlIGluIGFueSB7QGxpbmsgbWF0Y2hlcnN8bWF0Y2hlcn0gdGhhdCB1c2VzIEphc21pbmUncyBlcXVhbGl0eSAoZS5nLiB7QGxpbmsgbWF0Y2hlcnMjdG9FcXVhbHx0b0VxdWFsfSwge0BsaW5rIG1hdGNoZXJzI3RvQ29udGFpbnx0b0NvbnRhaW59LCBvciB7QGxpbmsgbWF0Y2hlcnMjdG9IYXZlQmVlbkNhbGxlZFdpdGh8dG9IYXZlQmVlbkNhbGxlZFdpdGh9KSxcbiAgICogdGhhdCB3aWxsIHN1Y2NlZWQgaWYgdGhlIGFjdHVhbCB2YWx1ZSBiZWluZyBjb21wYXJlZCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgc3BlY2lmaWVkIGNsYXNzL2NvbnN0cnVjdG9yLlxuICAgKiBAbmFtZSBqYXNtaW5lLmFueVxuICAgKiBAc2luY2UgMS4zLjBcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Q29uc3RydWN0b3J9IGNsYXp6IC0gVGhlIGNvbnN0cnVjdG9yIHRvIGNoZWNrIGFnYWluc3QuXG4gICAqL1xuICBqJC5hbnkgPSBmdW5jdGlvbihjbGF6eikge1xuICAgIHJldHVybiBuZXcgaiQuQW55KGNsYXp6KTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFuIHtAbGluayBBc3ltbWV0cmljRXF1YWxpdHlUZXN0ZXJ9LCB1c2FibGUgaW4gYW55IHtAbGluayBtYXRjaGVyc3xtYXRjaGVyfSB0aGF0IHVzZXMgSmFzbWluZSdzIGVxdWFsaXR5IChlLmcuIHtAbGluayBtYXRjaGVycyN0b0VxdWFsfHRvRXF1YWx9LCB7QGxpbmsgbWF0Y2hlcnMjdG9Db250YWlufHRvQ29udGFpbn0sIG9yIHtAbGluayBtYXRjaGVycyN0b0hhdmVCZWVuQ2FsbGVkV2l0aHx0b0hhdmVCZWVuQ2FsbGVkV2l0aH0pLFxuICAgKiB0aGF0IHdpbGwgc3VjY2VlZCBpZiB0aGUgYWN0dWFsIHZhbHVlIGJlaW5nIGNvbXBhcmVkIGlzIG5vdCBgbnVsbGAgYW5kIG5vdCBgdW5kZWZpbmVkYC5cbiAgICogQG5hbWUgamFzbWluZS5hbnl0aGluZ1xuICAgKiBAc2luY2UgMi4yLjBcbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBqJC5hbnl0aGluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgaiQuQW55dGhpbmcoKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFuIHtAbGluayBBc3ltbWV0cmljRXF1YWxpdHlUZXN0ZXJ9LCB1c2FibGUgaW4gYW55IHtAbGluayBtYXRjaGVyc3xtYXRjaGVyfSB0aGF0IHVzZXMgSmFzbWluZSdzIGVxdWFsaXR5IChlLmcuIHtAbGluayBtYXRjaGVycyN0b0VxdWFsfHRvRXF1YWx9LCB7QGxpbmsgbWF0Y2hlcnMjdG9Db250YWlufHRvQ29udGFpbn0sIG9yIHtAbGluayBtYXRjaGVycyN0b0hhdmVCZWVuQ2FsbGVkV2l0aHx0b0hhdmVCZWVuQ2FsbGVkV2l0aH0pLFxuICAgKiB0aGF0IHdpbGwgc3VjY2VlZCBpZiB0aGUgYWN0dWFsIHZhbHVlIGJlaW5nIGNvbXBhcmVkIGlzIGB0cnVlYCBvciBhbnl0aGluZyB0cnV0aHkuXG4gICAqIEBuYW1lIGphc21pbmUudHJ1dGh5XG4gICAqIEBzaW5jZSAzLjEuMFxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIGokLnRydXRoeSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgaiQuVHJ1dGh5KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiB7QGxpbmsgQXN5bW1ldHJpY0VxdWFsaXR5VGVzdGVyfSwgdXNhYmxlIGluIGFueSB7QGxpbmsgbWF0Y2hlcnN8bWF0Y2hlcn0gdGhhdCB1c2VzIEphc21pbmUncyBlcXVhbGl0eSAoZS5nLiB7QGxpbmsgbWF0Y2hlcnMjdG9FcXVhbHx0b0VxdWFsfSwge0BsaW5rIG1hdGNoZXJzI3RvQ29udGFpbnx0b0NvbnRhaW59LCBvciB7QGxpbmsgbWF0Y2hlcnMjdG9IYXZlQmVlbkNhbGxlZFdpdGh8dG9IYXZlQmVlbkNhbGxlZFdpdGh9KSxcbiAgICogdGhhdCB3aWxsIHN1Y2NlZWQgaWYgdGhlIGFjdHVhbCB2YWx1ZSBiZWluZyBjb21wYXJlZCBpcyAgYG51bGxgLCBgdW5kZWZpbmVkYCwgYDBgLCBgZmFsc2VgIG9yIGFueXRoaW5nIGZhbHNleS5cbiAgICogQG5hbWUgamFzbWluZS5mYWxzeVxuICAgKiBAc2luY2UgMy4xLjBcbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBqJC5mYWxzeSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgaiQuRmFsc3koKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFuIHtAbGluayBBc3ltbWV0cmljRXF1YWxpdHlUZXN0ZXJ9LCB1c2FibGUgaW4gYW55IHtAbGluayBtYXRjaGVyc3xtYXRjaGVyfSB0aGF0IHVzZXMgSmFzbWluZSdzIGVxdWFsaXR5IChlLmcuIHtAbGluayBtYXRjaGVycyN0b0VxdWFsfHRvRXF1YWx9LCB7QGxpbmsgbWF0Y2hlcnMjdG9Db250YWlufHRvQ29udGFpbn0sIG9yIHtAbGluayBtYXRjaGVycyN0b0hhdmVCZWVuQ2FsbGVkV2l0aHx0b0hhdmVCZWVuQ2FsbGVkV2l0aH0pLFxuICAgKiB0aGF0IHdpbGwgc3VjY2VlZCBpZiB0aGUgYWN0dWFsIHZhbHVlIGJlaW5nIGNvbXBhcmVkIGlzIGVtcHR5LlxuICAgKiBAbmFtZSBqYXNtaW5lLmVtcHR5XG4gICAqIEBzaW5jZSAzLjEuMFxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIGokLmVtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBqJC5FbXB0eSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYW4ge0BsaW5rIEFzeW1tZXRyaWNFcXVhbGl0eVRlc3Rlcn0sIHVzYWJsZSBpbiBhbnkge0BsaW5rIG1hdGNoZXJzfG1hdGNoZXJ9IHRoYXQgdXNlcyBKYXNtaW5lJ3MgZXF1YWxpdHkgKGUuZy4ge0BsaW5rIG1hdGNoZXJzI3RvRXF1YWx8dG9FcXVhbH0sIHtAbGluayBtYXRjaGVycyN0b0NvbnRhaW58dG9Db250YWlufSwgb3Ige0BsaW5rIG1hdGNoZXJzI3RvSGF2ZUJlZW5DYWxsZWRXaXRofHRvSGF2ZUJlZW5DYWxsZWRXaXRofSksXG4gICAqIHRoYXQgd2lsbCBzdWNjZWVkIGlmIHRoZSBhY3R1YWwgdmFsdWUgYmVpbmcgY29tcGFyZWQgaXMgbm90IGVtcHR5LlxuICAgKiBAbmFtZSBqYXNtaW5lLm5vdEVtcHR5XG4gICAqIEBzaW5jZSAzLjEuMFxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIGokLm5vdEVtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBqJC5Ob3RFbXB0eSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYW4ge0BsaW5rIEFzeW1tZXRyaWNFcXVhbGl0eVRlc3Rlcn0sIHVzYWJsZSBpbiBhbnkge0BsaW5rIG1hdGNoZXJzfG1hdGNoZXJ9IHRoYXQgdXNlcyBKYXNtaW5lJ3MgZXF1YWxpdHkgKGUuZy4ge0BsaW5rIG1hdGNoZXJzI3RvRXF1YWx8dG9FcXVhbH0sIHtAbGluayBtYXRjaGVycyN0b0NvbnRhaW58dG9Db250YWlufSwgb3Ige0BsaW5rIG1hdGNoZXJzI3RvSGF2ZUJlZW5DYWxsZWRXaXRofHRvSGF2ZUJlZW5DYWxsZWRXaXRofSksXG4gICAqIHRoYXQgd2lsbCBzdWNjZWVkIGlmIHRoZSBhY3R1YWwgdmFsdWUgYmVpbmcgY29tcGFyZWQgY29udGFpbnMgYXQgbGVhc3QgdGhlIGtleXMgYW5kIHZhbHVlcy5cbiAgICogQG5hbWUgamFzbWluZS5vYmplY3RDb250YWluaW5nXG4gICAqIEBzaW5jZSAxLjMuMFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IHNhbXBsZSAtIFRoZSBzdWJzZXQgb2YgcHJvcGVydGllcyB0aGF0IF9tdXN0XyBiZSBpbiB0aGUgYWN0dWFsLlxuICAgKi9cbiAgaiQub2JqZWN0Q29udGFpbmluZyA9IGZ1bmN0aW9uKHNhbXBsZSkge1xuICAgIHJldHVybiBuZXcgaiQuT2JqZWN0Q29udGFpbmluZyhzYW1wbGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYW4ge0BsaW5rIEFzeW1tZXRyaWNFcXVhbGl0eVRlc3Rlcn0sIHVzYWJsZSBpbiBhbnkge0BsaW5rIG1hdGNoZXJzfG1hdGNoZXJ9IHRoYXQgdXNlcyBKYXNtaW5lJ3MgZXF1YWxpdHkgKGUuZy4ge0BsaW5rIG1hdGNoZXJzI3RvRXF1YWx8dG9FcXVhbH0sIHtAbGluayBtYXRjaGVycyN0b0NvbnRhaW58dG9Db250YWlufSwgb3Ige0BsaW5rIG1hdGNoZXJzI3RvSGF2ZUJlZW5DYWxsZWRXaXRofHRvSGF2ZUJlZW5DYWxsZWRXaXRofSksXG4gICAqIHRoYXQgd2lsbCBzdWNjZWVkIGlmIHRoZSBhY3R1YWwgdmFsdWUgaXMgYSBgU3RyaW5nYCB0aGF0IG1hdGNoZXMgdGhlIGBSZWdFeHBgIG9yIGBTdHJpbmdgLlxuICAgKiBAbmFtZSBqYXNtaW5lLnN0cmluZ01hdGNoaW5nXG4gICAqIEBzaW5jZSAyLjIuMFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtSZWdFeHB8U3RyaW5nfSBleHBlY3RlZFxuICAgKi9cbiAgaiQuc3RyaW5nTWF0Y2hpbmcgPSBmdW5jdGlvbihleHBlY3RlZCkge1xuICAgIHJldHVybiBuZXcgaiQuU3RyaW5nTWF0Y2hpbmcoZXhwZWN0ZWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYW4ge0BsaW5rIEFzeW1tZXRyaWNFcXVhbGl0eVRlc3Rlcn0sIHVzYWJsZSBpbiBhbnkge0BsaW5rIG1hdGNoZXJzfG1hdGNoZXJ9IHRoYXQgdXNlcyBKYXNtaW5lJ3MgZXF1YWxpdHkgKGUuZy4ge0BsaW5rIG1hdGNoZXJzI3RvRXF1YWx8dG9FcXVhbH0sIHtAbGluayBtYXRjaGVycyN0b0NvbnRhaW58dG9Db250YWlufSwgb3Ige0BsaW5rIG1hdGNoZXJzI3RvSGF2ZUJlZW5DYWxsZWRXaXRofHRvSGF2ZUJlZW5DYWxsZWRXaXRofSksXG4gICAqIHRoYXQgd2lsbCBzdWNjZWVkIGlmIHRoZSBhY3R1YWwgdmFsdWUgaXMgYSBgU3RyaW5nYCB0aGF0IGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgYFN0cmluZ2AuXG4gICAqIEBuYW1lIGphc21pbmUuc3RyaW5nQ29udGFpbmluZ1xuICAgKiBAc2luY2UgMy4xMC4wXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXhwZWN0ZWRcbiAgICovXG4gIGokLnN0cmluZ0NvbnRhaW5pbmcgPSBmdW5jdGlvbihleHBlY3RlZCkge1xuICAgIHJldHVybiBuZXcgaiQuU3RyaW5nQ29udGFpbmluZyhleHBlY3RlZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiB7QGxpbmsgQXN5bW1ldHJpY0VxdWFsaXR5VGVzdGVyfSwgdXNhYmxlIGluIGFueSB7QGxpbmsgbWF0Y2hlcnN8bWF0Y2hlcn0gdGhhdCB1c2VzIEphc21pbmUncyBlcXVhbGl0eSAoZS5nLiB7QGxpbmsgbWF0Y2hlcnMjdG9FcXVhbHx0b0VxdWFsfSwge0BsaW5rIG1hdGNoZXJzI3RvQ29udGFpbnx0b0NvbnRhaW59LCBvciB7QGxpbmsgbWF0Y2hlcnMjdG9IYXZlQmVlbkNhbGxlZFdpdGh8dG9IYXZlQmVlbkNhbGxlZFdpdGh9KSxcbiAgICogdGhhdCB3aWxsIHN1Y2NlZWQgaWYgdGhlIGFjdHVhbCB2YWx1ZSBpcyBhbiBgQXJyYXlgIHRoYXQgY29udGFpbnMgYXQgbGVhc3QgdGhlIGVsZW1lbnRzIGluIHRoZSBzYW1wbGUuXG4gICAqIEBuYW1lIGphc21pbmUuYXJyYXlDb250YWluaW5nXG4gICAqIEBzaW5jZSAyLjIuMFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheX0gc2FtcGxlXG4gICAqL1xuICBqJC5hcnJheUNvbnRhaW5pbmcgPSBmdW5jdGlvbihzYW1wbGUpIHtcbiAgICByZXR1cm4gbmV3IGokLkFycmF5Q29udGFpbmluZyhzYW1wbGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYW4ge0BsaW5rIEFzeW1tZXRyaWNFcXVhbGl0eVRlc3Rlcn0sIHVzYWJsZSBpbiBhbnkge0BsaW5rIG1hdGNoZXJzfG1hdGNoZXJ9IHRoYXQgdXNlcyBKYXNtaW5lJ3MgZXF1YWxpdHkgKGUuZy4ge0BsaW5rIG1hdGNoZXJzI3RvRXF1YWx8dG9FcXVhbH0sIHtAbGluayBtYXRjaGVycyN0b0NvbnRhaW58dG9Db250YWlufSwgb3Ige0BsaW5rIG1hdGNoZXJzI3RvSGF2ZUJlZW5DYWxsZWRXaXRofHRvSGF2ZUJlZW5DYWxsZWRXaXRofSksXG4gICAqIHRoYXQgd2lsbCBzdWNjZWVkIGlmIHRoZSBhY3R1YWwgdmFsdWUgaXMgYW4gYEFycmF5YCB0aGF0IGNvbnRhaW5zIGFsbCBvZiB0aGUgZWxlbWVudHMgaW4gdGhlIHNhbXBsZSBpbiBhbnkgb3JkZXIuXG4gICAqIEBuYW1lIGphc21pbmUuYXJyYXlXaXRoRXhhY3RDb250ZW50c1xuICAgKiBAc2luY2UgMi44LjBcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNhbXBsZVxuICAgKi9cbiAgaiQuYXJyYXlXaXRoRXhhY3RDb250ZW50cyA9IGZ1bmN0aW9uKHNhbXBsZSkge1xuICAgIHJldHVybiBuZXcgaiQuQXJyYXlXaXRoRXhhY3RDb250ZW50cyhzYW1wbGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYW4ge0BsaW5rIEFzeW1tZXRyaWNFcXVhbGl0eVRlc3Rlcn0sIHVzYWJsZSBpbiBhbnkge0BsaW5rIG1hdGNoZXJzfG1hdGNoZXJ9IHRoYXQgdXNlcyBKYXNtaW5lJ3MgZXF1YWxpdHkgKGUuZy4ge0BsaW5rIG1hdGNoZXJzI3RvRXF1YWx8dG9FcXVhbH0sIHtAbGluayBtYXRjaGVycyN0b0NvbnRhaW58dG9Db250YWlufSwgb3Ige0BsaW5rIG1hdGNoZXJzI3RvSGF2ZUJlZW5DYWxsZWRXaXRofHRvSGF2ZUJlZW5DYWxsZWRXaXRofSksXG4gICAqIHRoYXQgd2lsbCBzdWNjZWVkIGlmIGV2ZXJ5IGtleS92YWx1ZSBwYWlyIGluIHRoZSBzYW1wbGUgcGFzc2VzIHRoZSBkZWVwIGVxdWFsaXR5IGNvbXBhcmlzb25cbiAgICogd2l0aCBhdCBsZWFzdCBvbmUga2V5L3ZhbHVlIHBhaXIgaW4gdGhlIGFjdHVhbCB2YWx1ZSBiZWluZyBjb21wYXJlZFxuICAgKiBAbmFtZSBqYXNtaW5lLm1hcENvbnRhaW5pbmdcbiAgICogQHNpbmNlIDMuNS4wXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge01hcH0gc2FtcGxlIC0gVGhlIHN1YnNldCBvZiBpdGVtcyB0aGF0IF9tdXN0XyBiZSBpbiB0aGUgYWN0dWFsLlxuICAgKi9cbiAgaiQubWFwQ29udGFpbmluZyA9IGZ1bmN0aW9uKHNhbXBsZSkge1xuICAgIHJldHVybiBuZXcgaiQuTWFwQ29udGFpbmluZyhzYW1wbGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYW4ge0BsaW5rIEFzeW1tZXRyaWNFcXVhbGl0eVRlc3Rlcn0sIHVzYWJsZSBpbiBhbnkge0BsaW5rIG1hdGNoZXJzfG1hdGNoZXJ9IHRoYXQgdXNlcyBKYXNtaW5lJ3MgZXF1YWxpdHkgKGUuZy4ge0BsaW5rIG1hdGNoZXJzI3RvRXF1YWx8dG9FcXVhbH0sIHtAbGluayBtYXRjaGVycyN0b0NvbnRhaW58dG9Db250YWlufSwgb3Ige0BsaW5rIG1hdGNoZXJzI3RvSGF2ZUJlZW5DYWxsZWRXaXRofHRvSGF2ZUJlZW5DYWxsZWRXaXRofSksXG4gICAqIHRoYXQgd2lsbCBzdWNjZWVkIGlmIGV2ZXJ5IGl0ZW0gaW4gdGhlIHNhbXBsZSBwYXNzZXMgdGhlIGRlZXAgZXF1YWxpdHkgY29tcGFyaXNvblxuICAgKiB3aXRoIGF0IGxlYXN0IG9uZSBpdGVtIGluIHRoZSBhY3R1YWwgdmFsdWUgYmVpbmcgY29tcGFyZWRcbiAgICogQG5hbWUgamFzbWluZS5zZXRDb250YWluaW5nXG4gICAqIEBzaW5jZSAzLjUuMFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTZXR9IHNhbXBsZSAtIFRoZSBzdWJzZXQgb2YgaXRlbXMgdGhhdCBfbXVzdF8gYmUgaW4gdGhlIGFjdHVhbC5cbiAgICovXG4gIGokLnNldENvbnRhaW5pbmcgPSBmdW5jdGlvbihzYW1wbGUpIHtcbiAgICByZXR1cm4gbmV3IGokLlNldENvbnRhaW5pbmcoc2FtcGxlKTtcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBpcyBhIEphc21pbmUgc3B5LlxuICAgKiBAbmFtZSBqYXNtaW5lLmlzU3B5XG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHV0YXRpdmVTcHkgLSBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBqJC5pc1NweSA9IGZ1bmN0aW9uKHB1dGF0aXZlU3B5KSB7XG4gICAgaWYgKCFwdXRhdGl2ZVNweSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgcHV0YXRpdmVTcHkuYW5kIGluc3RhbmNlb2YgaiQuU3B5U3RyYXRlZ3kgJiZcbiAgICAgIHB1dGF0aXZlU3B5LmNhbGxzIGluc3RhbmNlb2YgaiQuQ2FsbFRyYWNrZXJcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb2dzIGEgbWVzc2FnZSBmb3IgdXNlIGluIGRlYnVnZ2luZy4gSWYgdGhlIHNwZWMgZmFpbHMsIHRyYWNlIG1lc3NhZ2VzXG4gICAqIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHtAbGluayBTcGVjUmVzdWx0fHJlc3VsdH0gcGFzc2VkIHRvIHRoZVxuICAgKiByZXBvcnRlcidzIHNwZWNEb25lIG1ldGhvZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IHdoZW4gYSBzcGVjIChpbmNsdWRpbmcgYW55IGFzc29jaWF0ZWRcbiAgICogYmVmb3JlRWFjaCBvciBhZnRlckVhY2ggZnVuY3Rpb25zKSBpcyBydW5uaW5nLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgamFzbWluZS5kZWJ1Z0xvZ1xuICAgKiBAc2luY2UgNC4wLjBcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIFRoZSBtZXNzYWdlIHRvIGxvZ1xuICAgKi9cbiAgaiQuZGVidWdMb2cgPSBmdW5jdGlvbihtc2cpIHtcbiAgICBqJC5nZXRFbnYoKS5kZWJ1Z0xvZyhtc2cpO1xuICB9O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS51dGlsID0gZnVuY3Rpb24oaiQpIHtcbiAgdmFyIHV0aWwgPSB7fTtcblxuICB1dGlsLmluaGVyaXQgPSBmdW5jdGlvbihjaGlsZENsYXNzLCBwYXJlbnRDbGFzcykge1xuICAgIHZhciBTdWJjbGFzcyA9IGZ1bmN0aW9uKCkge307XG4gICAgU3ViY2xhc3MucHJvdG90eXBlID0gcGFyZW50Q2xhc3MucHJvdG90eXBlO1xuICAgIGNoaWxkQ2xhc3MucHJvdG90eXBlID0gbmV3IFN1YmNsYXNzKCk7XG4gIH07XG5cbiAgdXRpbC5hcmdzVG9BcnJheSA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICB2YXIgYXJyYXlPZkFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycmF5T2ZBcmdzLnB1c2goYXJnc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheU9mQXJncztcbiAgfTtcblxuICB1dGlsLmlzVW5kZWZpbmVkID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwO1xuICB9O1xuXG4gIHV0aWwuYXJyYXlDb250YWlucyA9IGZ1bmN0aW9uKGFycmF5LCBzZWFyY2gpIHtcbiAgICB2YXIgaSA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAoYXJyYXlbaV0gPT09IHNlYXJjaCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHV0aWwuY2xvbmUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseShvYmopID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICByZXR1cm4gb2JqLnNsaWNlKCk7XG4gICAgfVxuXG4gICAgdmFyIGNsb25lZCA9IHt9O1xuICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIGNsb25lZFtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmVkO1xuICB9O1xuXG4gIHV0aWwuY2xvbmVBcmdzID0gZnVuY3Rpb24oYXJncykge1xuICAgIHZhciBjbG9uZWRBcmdzID0gW107XG4gICAgdmFyIGFyZ3NBc0FycmF5ID0gaiQudXRpbC5hcmdzVG9BcnJheShhcmdzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3NBc0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseShhcmdzQXNBcnJheVtpXSksXG4gICAgICAgIHByaW1pdGl2ZXMgPSAvXlxcW29iamVjdCAoQm9vbGVhbnxTdHJpbmd8UmVnRXhwfE51bWJlcikvO1xuXG4gICAgICAvLyBBbGwgZmFsc2V5IHZhbHVlcyBhcmUgZWl0aGVyIHByaW1pdGl2ZXMsIGBudWxsYCwgb3IgYHVuZGVmaW5lZC5cbiAgICAgIGlmICghYXJnc0FzQXJyYXlbaV0gfHwgc3RyLm1hdGNoKHByaW1pdGl2ZXMpKSB7XG4gICAgICAgIGNsb25lZEFyZ3MucHVzaChhcmdzQXNBcnJheVtpXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbG9uZWRBcmdzLnB1c2goaiQudXRpbC5jbG9uZShhcmdzQXNBcnJheVtpXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xvbmVkQXJncztcbiAgfTtcblxuICB1dGlsLmdldFByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgIHZhciBkZXNjcmlwdG9yLFxuICAgICAgcHJvdG8gPSBvYmo7XG5cbiAgICBkbyB7XG4gICAgICBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgbWV0aG9kTmFtZSk7XG4gICAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gICAgfSB3aGlsZSAoIWRlc2NyaXB0b3IgJiYgcHJvdG8pO1xuXG4gICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gIH07XG5cbiAgdXRpbC5vYmplY3REaWZmZXJlbmNlID0gZnVuY3Rpb24ob2JqLCB0b1JlbW92ZSkge1xuICAgIHZhciBkaWZmID0ge307XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAodXRpbC5oYXMob2JqLCBrZXkpICYmICF1dGlsLmhhcyh0b1JlbW92ZSwga2V5KSkge1xuICAgICAgICBkaWZmW2tleV0gPSBvYmpba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGlmZjtcbiAgfTtcblxuICB1dGlsLmhhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gIH07XG5cbiAgdXRpbC5lcnJvcldpdGhTdGFjayA9IGZ1bmN0aW9uIGVycm9yV2l0aFN0YWNrKCkge1xuICAgIC8vIERvbid0IHRocm93IGFuZCBjYXRjaC4gVGhhdCBtYWtlcyBpdCBoYXJkZXIgZm9yIHVzZXJzIHRvIGRlYnVnIHRoZWlyXG4gICAgLy8gY29kZSB3aXRoIGV4Y2VwdGlvbiBicmVha3BvaW50cywgYW5kIGl0J3MgdW5uZWNlc3Nhcnkgc2luY2UgYWxsXG4gICAgLy8gc3VwcG9ydGVkIGVudmlyb25tZW50cyBwb3B1bGF0ZSBuZXcgRXJyb3IoKS5zdGFja1xuICAgIHJldHVybiBuZXcgRXJyb3IoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBjYWxsZXJGaWxlKCkge1xuICAgIHZhciB0cmFjZSA9IG5ldyBqJC5TdGFja1RyYWNlKHV0aWwuZXJyb3JXaXRoU3RhY2soKSk7XG4gICAgcmV0dXJuIHRyYWNlLmZyYW1lc1syXS5maWxlO1xuICB9XG5cbiAgdXRpbC5qYXNtaW5lRmlsZSA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0ID0gY2FsbGVyRmlsZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH0pKCk7XG5cbiAgZnVuY3Rpb24gU3RvcEl0ZXJhdGlvbigpIHt9XG4gIFN0b3BJdGVyYXRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICBTdG9wSXRlcmF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN0b3BJdGVyYXRpb247XG5cbiAgdXRpbC52YWxpZGF0ZVRpbWVvdXQgPSBmdW5jdGlvbih0aW1lb3V0LCBtc2dQcmVmaXgpIHtcbiAgICAvLyBUaW1lb3V0cyBhcmUgaW1wbGVtZW50ZWQgd2l0aCBzZXRUaW1lb3V0LCB3aGljaCBvbmx5IHN1cHBvcnRzIGEgbGltaXRlZFxuICAgIC8vIHJhbmdlIG9mIHZhbHVlcy4gVGhlIGxpbWl0IGlzIHVuc3BlY2lmaWVkLCBhcyBpcyB0aGUgYmVoYXZpb3Igd2hlbiBpdCdzXG4gICAgLy8gZXhjZWVkZWQuIEJ1dCBvbiBhbGwgY3VycmVudGx5IHN1cHBvcnRlZCBKUyBydW50aW1lcywgc2V0VGltZW91dCBjYWxsc1xuICAgIC8vIHRoZSBjYWxsYmFjayBpbW1lZGlhdGVseSB3aGVuIHRoZSB0aW1lb3V0IGlzIGdyZWF0ZXIgdGhhbiAyMTQ3NDgzNjQ3XG4gICAgLy8gKHRoZSBtYXhpbXVtIHZhbHVlIG9mIGEgc2lnbmVkIDMyIGJpdCBpbnRlZ2VyKS5cbiAgICB2YXIgbWF4ID0gMjE0NzQ4MzY0NztcblxuICAgIGlmICh0aW1lb3V0ID4gbWF4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIChtc2dQcmVmaXggfHwgJ1RpbWVvdXQgdmFsdWUnKSArICcgY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiAnICsgbWF4XG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdXRpbDtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuU3BlYyA9IGZ1bmN0aW9uKGokKSB7XG4gIC8qKlxuICAgKiBAaW50ZXJmYWNlIFNwZWNcbiAgICogQHNlZSBDb25maWd1cmF0aW9uI3NwZWNGaWx0ZXJcbiAgICogQHNpbmNlIDIuMC4wXG4gICAqL1xuICBmdW5jdGlvbiBTcGVjKGF0dHJzKSB7XG4gICAgdGhpcy5leHBlY3RhdGlvbkZhY3RvcnkgPSBhdHRycy5leHBlY3RhdGlvbkZhY3Rvcnk7XG4gICAgdGhpcy5hc3luY0V4cGVjdGF0aW9uRmFjdG9yeSA9IGF0dHJzLmFzeW5jRXhwZWN0YXRpb25GYWN0b3J5O1xuICAgIHRoaXMucmVzdWx0Q2FsbGJhY2sgPSBhdHRycy5yZXN1bHRDYWxsYmFjayB8fCBmdW5jdGlvbigpIHt9O1xuICAgIC8qKlxuICAgICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhpcyBzcGVjLlxuICAgICAqIEBuYW1lIFNwZWMjaWRcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBhdHRycy5pZDtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVzY3JpcHRpb24gcGFzc2VkIHRvIHRoZSB7QGxpbmsgaXR9IHRoYXQgY3JlYXRlZCB0aGlzIHNwZWMuXG4gICAgICogQG5hbWUgU3BlYyNkZXNjcmlwdGlvblxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICovXG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IGF0dHJzLmRlc2NyaXB0aW9uIHx8ICcnO1xuICAgIHRoaXMucXVldWVhYmxlRm4gPSBhdHRycy5xdWV1ZWFibGVGbjtcbiAgICB0aGlzLmJlZm9yZUFuZEFmdGVyRm5zID1cbiAgICAgIGF0dHJzLmJlZm9yZUFuZEFmdGVyRm5zIHx8XG4gICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHsgYmVmb3JlczogW10sIGFmdGVyczogW10gfTtcbiAgICAgIH07XG4gICAgdGhpcy51c2VyQ29udGV4dCA9XG4gICAgICBhdHRycy51c2VyQ29udGV4dCB8fFxuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH07XG4gICAgdGhpcy5vblN0YXJ0ID0gYXR0cnMub25TdGFydCB8fCBmdW5jdGlvbigpIHt9O1xuICAgIHRoaXMuYXV0b0NsZWFuQ2xvc3VyZXMgPVxuICAgICAgYXR0cnMuYXV0b0NsZWFuQ2xvc3VyZXMgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIWF0dHJzLmF1dG9DbGVhbkNsb3N1cmVzO1xuICAgIHRoaXMuZ2V0U3BlY05hbWUgPVxuICAgICAgYXR0cnMuZ2V0U3BlY05hbWUgfHxcbiAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9O1xuICAgIHRoaXMuZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5ID1cbiAgICAgIGF0dHJzLmV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeSB8fCBmdW5jdGlvbigpIHt9O1xuICAgIHRoaXMub25MYXRlRXJyb3IgPSBhdHRycy5vbkxhdGVFcnJvciB8fCBmdW5jdGlvbigpIHt9O1xuICAgIHRoaXMucXVldWVSdW5uZXJGYWN0b3J5ID0gYXR0cnMucXVldWVSdW5uZXJGYWN0b3J5IHx8IGZ1bmN0aW9uKCkge307XG4gICAgdGhpcy5jYXRjaGluZ0V4Y2VwdGlvbnMgPVxuICAgICAgYXR0cnMuY2F0Y2hpbmdFeGNlcHRpb25zIHx8XG4gICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIHRoaXMudGhyb3dPbkV4cGVjdGF0aW9uRmFpbHVyZSA9ICEhYXR0cnMudGhyb3dPbkV4cGVjdGF0aW9uRmFpbHVyZTtcbiAgICB0aGlzLnRpbWVyID0gYXR0cnMudGltZXIgfHwgbmV3IGokLlRpbWVyKCk7XG5cbiAgICBpZiAoIXRoaXMucXVldWVhYmxlRm4uZm4pIHtcbiAgICAgIHRoaXMuZXhjbHVkZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIFNwZWNSZXN1bHRcbiAgICAgKiBAcHJvcGVydHkge0ludH0gaWQgLSBUaGUgdW5pcXVlIGlkIG9mIHRoaXMgc3BlYy5cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gZGVzY3JpcHRpb24gLSBUaGUgZGVzY3JpcHRpb24gcGFzc2VkIHRvIHRoZSB7QGxpbmsgaXR9IHRoYXQgY3JlYXRlZCB0aGlzIHNwZWMuXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IGZ1bGxOYW1lIC0gVGhlIGZ1bGwgZGVzY3JpcHRpb24gaW5jbHVkaW5nIGFsbCBhbmNlc3RvcnMgb2YgdGhpcyBzcGVjLlxuICAgICAqIEBwcm9wZXJ0eSB7RXhwZWN0YXRpb25bXX0gZmFpbGVkRXhwZWN0YXRpb25zIC0gVGhlIGxpc3Qgb2YgZXhwZWN0YXRpb25zIHRoYXQgZmFpbGVkIGR1cmluZyBleGVjdXRpb24gb2YgdGhpcyBzcGVjLlxuICAgICAqIEBwcm9wZXJ0eSB7RXhwZWN0YXRpb25bXX0gcGFzc2VkRXhwZWN0YXRpb25zIC0gVGhlIGxpc3Qgb2YgZXhwZWN0YXRpb25zIHRoYXQgcGFzc2VkIGR1cmluZyBleGVjdXRpb24gb2YgdGhpcyBzcGVjLlxuICAgICAqIEBwcm9wZXJ0eSB7RXhwZWN0YXRpb25bXX0gZGVwcmVjYXRpb25XYXJuaW5ncyAtIFRoZSBsaXN0IG9mIGRlcHJlY2F0aW9uIHdhcm5pbmdzIHRoYXQgb2NjdXJyZWQgZHVyaW5nIGV4ZWN1dGlvbiB0aGlzIHNwZWMuXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IHBlbmRpbmdSZWFzb24gLSBJZiB0aGUgc3BlYyBpcyB7QGxpbmsgcGVuZGluZ30sIHRoaXMgd2lsbCBiZSB0aGUgcmVhc29uLlxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzdGF0dXMgLSBPbmNlIHRoZSBzcGVjIGhhcyBjb21wbGV0ZWQsIHRoaXMgc3RyaW5nIHJlcHJlc2VudHMgdGhlIHBhc3MvZmFpbCBzdGF0dXMgb2YgdGhpcyBzcGVjLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSB0aW1lIGluIG1zIHVzZWQgYnkgdGhlIHNwZWMgZXhlY3V0aW9uLCBpbmNsdWRpbmcgYW55IGJlZm9yZS9hZnRlckVhY2guXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IHByb3BlcnRpZXMgLSBVc2VyLXN1cHBsaWVkIHByb3BlcnRpZXMsIGlmIGFueSwgdGhhdCB3ZXJlIHNldCB1c2luZyB7QGxpbmsgRW52I3NldFNwZWNQcm9wZXJ0eX1cbiAgICAgKiBAcHJvcGVydHkge0RlYnVnTG9nRW50cnlbXXxudWxsfSBkZWJ1Z0xvZ3MgLSBNZXNzYWdlcywgaWYgYW55LCB0aGF0IHdlcmUgbG9nZ2VkIHVzaW5nIHtAbGluayBqYXNtaW5lLmRlYnVnTG9nfSBkdXJpbmcgYSBmYWlsaW5nIHNwZWMuXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICovXG4gICAgdGhpcy5yZXN1bHQgPSB7XG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgZnVsbE5hbWU6IHRoaXMuZ2V0RnVsbE5hbWUoKSxcbiAgICAgIGZhaWxlZEV4cGVjdGF0aW9uczogW10sXG4gICAgICBwYXNzZWRFeHBlY3RhdGlvbnM6IFtdLFxuICAgICAgZGVwcmVjYXRpb25XYXJuaW5nczogW10sXG4gICAgICBwZW5kaW5nUmVhc29uOiAnJyxcbiAgICAgIGR1cmF0aW9uOiBudWxsLFxuICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgIGRlYnVnTG9nczogbnVsbFxuICAgIH07XG4gIH1cblxuICBTcGVjLnByb3RvdHlwZS5hZGRFeHBlY3RhdGlvblJlc3VsdCA9IGZ1bmN0aW9uKHBhc3NlZCwgZGF0YSwgaXNFcnJvcikge1xuICAgIHZhciBleHBlY3RhdGlvblJlc3VsdCA9IHRoaXMuZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5KGRhdGEpO1xuICAgIGlmIChwYXNzZWQpIHtcbiAgICAgIHRoaXMucmVzdWx0LnBhc3NlZEV4cGVjdGF0aW9ucy5wdXNoKGV4cGVjdGF0aW9uUmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zLnB1c2goZXhwZWN0YXRpb25SZXN1bHQpO1xuXG4gICAgICBpZiAodGhpcy50aHJvd09uRXhwZWN0YXRpb25GYWlsdXJlICYmICFpc0Vycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBqJC5lcnJvcnMuRXhwZWN0YXRpb25GYWlsZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU3BlYy5wcm90b3R5cGUuc2V0U3BlY1Byb3BlcnR5ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMucmVzdWx0LnByb3BlcnRpZXMgPSB0aGlzLnJlc3VsdC5wcm9wZXJ0aWVzIHx8IHt9O1xuICAgIHRoaXMucmVzdWx0LnByb3BlcnRpZXNba2V5XSA9IHZhbHVlO1xuICB9O1xuXG4gIFNwZWMucHJvdG90eXBlLmV4cGVjdCA9IGZ1bmN0aW9uKGFjdHVhbCkge1xuICAgIHJldHVybiB0aGlzLmV4cGVjdGF0aW9uRmFjdG9yeShhY3R1YWwsIHRoaXMpO1xuICB9O1xuXG4gIFNwZWMucHJvdG90eXBlLmV4cGVjdEFzeW5jID0gZnVuY3Rpb24oYWN0dWFsKSB7XG4gICAgcmV0dXJuIHRoaXMuYXN5bmNFeHBlY3RhdGlvbkZhY3RvcnkoYWN0dWFsLCB0aGlzKTtcbiAgfTtcblxuICBTcGVjLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24ob25Db21wbGV0ZSwgZXhjbHVkZWQsIGZhaWxTcGVjV2l0aE5vRXhwKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIG9uU3RhcnQgPSB7XG4gICAgICBmbjogZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICBzZWxmLnRpbWVyLnN0YXJ0KCk7XG4gICAgICAgIHNlbGYub25TdGFydChzZWxmLCBkb25lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNvbXBsZXRlID0ge1xuICAgICAgZm46IGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgaWYgKHNlbGYuYXV0b0NsZWFuQ2xvc3VyZXMpIHtcbiAgICAgICAgICBzZWxmLnF1ZXVlYWJsZUZuLmZuID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLnJlc3VsdC5zdGF0dXMgPSBzZWxmLnN0YXR1cyhleGNsdWRlZCwgZmFpbFNwZWNXaXRoTm9FeHApO1xuICAgICAgICBzZWxmLnJlc3VsdC5kdXJhdGlvbiA9IHNlbGYudGltZXIuZWxhcHNlZCgpO1xuXG4gICAgICAgIGlmIChzZWxmLnJlc3VsdC5zdGF0dXMgIT09ICdmYWlsZWQnKSB7XG4gICAgICAgICAgc2VsZi5yZXN1bHQuZGVidWdMb2dzID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYucmVzdWx0Q2FsbGJhY2soc2VsZi5yZXN1bHQsIGRvbmUpO1xuICAgICAgfSxcbiAgICAgIHR5cGU6ICdzcGVjQ2xlYW51cCdcbiAgICB9O1xuXG4gICAgdmFyIGZucyA9IHRoaXMuYmVmb3JlQW5kQWZ0ZXJGbnMoKTtcblxuICAgIHZhciBydW5uZXJDb25maWcgPSB7XG4gICAgICBpc0xlYWY6IHRydWUsXG4gICAgICBxdWV1ZWFibGVGbnM6IFsuLi5mbnMuYmVmb3JlcywgdGhpcy5xdWV1ZWFibGVGbiwgLi4uZm5zLmFmdGVyc10sXG4gICAgICBvbkV4Y2VwdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYub25FeGNlcHRpb24uYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICAgIH0sXG4gICAgICBvbk11bHRpcGxlRG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIElzc3VlIGEgZGVwcmVjYXRpb24uIEluY2x1ZGUgdGhlIGNvbnRleHQgb3Vyc2VsdmVzIGFuZCBwYXNzXG4gICAgICAgIC8vIGlnbm9yZVJ1bm5hYmxlOiB0cnVlLCBzaW5jZSBnZXR0aW5nIGhlcmUgYWx3YXlzIG1lYW5zIHRoYXQgd2UndmUgYWxyZWFkeVxuICAgICAgICAvLyBtb3ZlZCBvbiBhbmQgdGhlIGN1cnJlbnQgcnVubmFibGUgaXNuJ3QgdGhlIG9uZSB0aGF0IGNhdXNlZCB0aGUgcHJvYmxlbS5cbiAgICAgICAgc2VsZi5vbkxhdGVFcnJvcihcbiAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQW4gYXN5bmNocm9ub3VzIHNwZWMsIGJlZm9yZUVhY2gsIG9yIGFmdGVyRWFjaCBmdW5jdGlvbiBjYWxsZWQgaXRzICcgK1xuICAgICAgICAgICAgICBcIidkb25lJyBjYWxsYmFjayBtb3JlIHRoYW4gb25jZS5cXG4oaW4gc3BlYzogXCIgK1xuICAgICAgICAgICAgICBzZWxmLmdldEZ1bGxOYW1lKCkgK1xuICAgICAgICAgICAgICAnKSdcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChzZWxmLnJlc3VsdC5zdGF0dXMgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgICAgb25Db21wbGV0ZShuZXcgaiQuU3RvcEV4ZWN1dGlvbkVycm9yKCdzcGVjIGZhaWxlZCcpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VyQ29udGV4dDogdGhpcy51c2VyQ29udGV4dCgpLFxuICAgICAgcnVubmFibGVOYW1lOiB0aGlzLmdldEZ1bGxOYW1lLmJpbmQodGhpcylcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMubWFya2VkUGVuZGluZyB8fCBleGNsdWRlZCA9PT0gdHJ1ZSkge1xuICAgICAgcnVubmVyQ29uZmlnLnF1ZXVlYWJsZUZucyA9IFtdO1xuICAgIH1cblxuICAgIHJ1bm5lckNvbmZpZy5xdWV1ZWFibGVGbnMudW5zaGlmdChvblN0YXJ0KTtcbiAgICBydW5uZXJDb25maWcucXVldWVhYmxlRm5zLnB1c2goY29tcGxldGUpO1xuXG4gICAgdGhpcy5xdWV1ZVJ1bm5lckZhY3RvcnkocnVubmVyQ29uZmlnKTtcbiAgfTtcblxuICBTcGVjLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVzdWx0ID0ge1xuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgIGZ1bGxOYW1lOiB0aGlzLmdldEZ1bGxOYW1lKCksXG4gICAgICBmYWlsZWRFeHBlY3RhdGlvbnM6IFtdLFxuICAgICAgcGFzc2VkRXhwZWN0YXRpb25zOiBbXSxcbiAgICAgIGRlcHJlY2F0aW9uV2FybmluZ3M6IFtdLFxuICAgICAgcGVuZGluZ1JlYXNvbjogdGhpcy5leGNsdWRlTWVzc2FnZSxcbiAgICAgIGR1cmF0aW9uOiBudWxsLFxuICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgIGRlYnVnTG9nczogbnVsbFxuICAgIH07XG4gICAgdGhpcy5tYXJrZWRQZW5kaW5nID0gdGhpcy5tYXJrZWRFeGNsdWRpbmc7XG4gIH07XG5cbiAgU3BlYy5wcm90b3R5cGUub25FeGNlcHRpb24gPSBmdW5jdGlvbiBvbkV4Y2VwdGlvbihlKSB7XG4gICAgaWYgKFNwZWMuaXNQZW5kaW5nU3BlY0V4Y2VwdGlvbihlKSkge1xuICAgICAgdGhpcy5wZW5kKGV4dHJhY3RDdXN0b21QZW5kaW5nTWVzc2FnZShlKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGUgaW5zdGFuY2VvZiBqJC5lcnJvcnMuRXhwZWN0YXRpb25GYWlsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmFkZEV4cGVjdGF0aW9uUmVzdWx0KFxuICAgICAgZmFsc2UsXG4gICAgICB7XG4gICAgICAgIG1hdGNoZXJOYW1lOiAnJyxcbiAgICAgICAgcGFzc2VkOiBmYWxzZSxcbiAgICAgICAgZXhwZWN0ZWQ6ICcnLFxuICAgICAgICBhY3R1YWw6ICcnLFxuICAgICAgICBlcnJvcjogZVxuICAgICAgfSxcbiAgICAgIHRydWVcbiAgICApO1xuICB9O1xuXG4gIC8qXG4gICAqIE1hcmtzIHN0YXRlIGFzIHBlbmRpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFttZXNzYWdlXSBBbiBvcHRpb25hbCByZWFzb24gbWVzc2FnZVxuICAgKi9cbiAgU3BlYy5wcm90b3R5cGUucGVuZCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1hcmtlZFBlbmRpbmcgPSB0cnVlO1xuICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICB0aGlzLnJlc3VsdC5wZW5kaW5nUmVhc29uID0gbWVzc2FnZTtcbiAgICB9XG4gIH07XG5cbiAgLypcbiAgICogTGlrZSB7QGxpbmsgU3BlYyNwZW5kfSwgYnV0IHBlbmRpbmcgc3RhdGUgd2lsbCBzdXJ2aXZlIHtAbGluayBTcGVjI3Jlc2V0fVxuICAgKiBVc2VmdWwgZm9yIGZpdCwgeGl0LCB3aGVyZSBwZW5kaW5nIHN0YXRlIHJlbWFpbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbWVzc2FnZV0gQW4gb3B0aW9uYWwgcmVhc29uIG1lc3NhZ2VcbiAgICovXG4gIFNwZWMucHJvdG90eXBlLmV4Y2x1ZGUgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgdGhpcy5tYXJrZWRFeGNsdWRpbmcgPSB0cnVlO1xuICAgIGlmICh0aGlzLm1lc3NhZ2UpIHtcbiAgICAgIHRoaXMuZXhjbHVkZU1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH1cbiAgICB0aGlzLnBlbmQobWVzc2FnZSk7XG4gIH07XG5cbiAgU3BlYy5wcm90b3R5cGUuZ2V0UmVzdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZXN1bHQuc3RhdHVzID0gdGhpcy5zdGF0dXMoKTtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQ7XG4gIH07XG5cbiAgU3BlYy5wcm90b3R5cGUuc3RhdHVzID0gZnVuY3Rpb24oZXhjbHVkZWQsIGZhaWxTcGVjV2l0aE5vRXhwZWN0YXRpb25zKSB7XG4gICAgaWYgKGV4Y2x1ZGVkID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gJ2V4Y2x1ZGVkJztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tYXJrZWRQZW5kaW5nKSB7XG4gICAgICByZXR1cm4gJ3BlbmRpbmcnO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHRoaXMucmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9ucy5sZW5ndGggPiAwIHx8XG4gICAgICAoZmFpbFNwZWNXaXRoTm9FeHBlY3RhdGlvbnMgJiZcbiAgICAgICAgdGhpcy5yZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zLmxlbmd0aCArXG4gICAgICAgICAgdGhpcy5yZXN1bHQucGFzc2VkRXhwZWN0YXRpb25zLmxlbmd0aCA9PT1cbiAgICAgICAgICAwKVxuICAgICkge1xuICAgICAgcmV0dXJuICdmYWlsZWQnO1xuICAgIH1cblxuICAgIHJldHVybiAncGFzc2VkJztcbiAgfTtcblxuICAvKipcbiAgICogVGhlIGZ1bGwgZGVzY3JpcHRpb24gaW5jbHVkaW5nIGFsbCBhbmNlc3RvcnMgb2YgdGhpcyBzcGVjLlxuICAgKiBAbmFtZSBTcGVjI2dldEZ1bGxOYW1lXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAc2luY2UgMi4wLjBcbiAgICovXG4gIFNwZWMucHJvdG90eXBlLmdldEZ1bGxOYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3BlY05hbWUodGhpcyk7XG4gIH07XG5cbiAgU3BlYy5wcm90b3R5cGUuYWRkRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24oZGVwcmVjYXRpb24pIHtcbiAgICBpZiAodHlwZW9mIGRlcHJlY2F0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgZGVwcmVjYXRpb24gPSB7IG1lc3NhZ2U6IGRlcHJlY2F0aW9uIH07XG4gICAgfVxuICAgIHRoaXMucmVzdWx0LmRlcHJlY2F0aW9uV2FybmluZ3MucHVzaChcbiAgICAgIHRoaXMuZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5KGRlcHJlY2F0aW9uKVxuICAgICk7XG4gIH07XG5cbiAgU3BlYy5wcm90b3R5cGUuZGVidWdMb2cgPSBmdW5jdGlvbihtc2cpIHtcbiAgICBpZiAoIXRoaXMucmVzdWx0LmRlYnVnTG9ncykge1xuICAgICAgdGhpcy5yZXN1bHQuZGVidWdMb2dzID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYgRGVidWdMb2dFbnRyeVxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBtZXNzYWdlIC0gVGhlIG1lc3NhZ2UgdGhhdCB3YXMgcGFzc2VkIHRvIHtAbGluayBqYXNtaW5lLmRlYnVnTG9nfS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdGltZXN0YW1wIC0gVGhlIHRpbWUgd2hlbiB0aGUgZW50cnkgd2FzIGFkZGVkLCBpblxuICAgICAqIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBzcGVjJ3Mgc3RhcnQgdGltZVxuICAgICAqL1xuICAgIHRoaXMucmVzdWx0LmRlYnVnTG9ncy5wdXNoKHtcbiAgICAgIG1lc3NhZ2U6IG1zZyxcbiAgICAgIHRpbWVzdGFtcDogdGhpcy50aW1lci5lbGFwc2VkKClcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZXh0cmFjdEN1c3RvbVBlbmRpbmdNZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgIHZhciBmdWxsTWVzc2FnZSA9IGUudG9TdHJpbmcoKSxcbiAgICAgIGJvaWxlcnBsYXRlU3RhcnQgPSBmdWxsTWVzc2FnZS5pbmRleE9mKFNwZWMucGVuZGluZ1NwZWNFeGNlcHRpb25NZXNzYWdlKSxcbiAgICAgIGJvaWxlcnBsYXRlRW5kID1cbiAgICAgICAgYm9pbGVycGxhdGVTdGFydCArIFNwZWMucGVuZGluZ1NwZWNFeGNlcHRpb25NZXNzYWdlLmxlbmd0aDtcblxuICAgIHJldHVybiBmdWxsTWVzc2FnZS5zdWJzdHIoYm9pbGVycGxhdGVFbmQpO1xuICB9O1xuXG4gIFNwZWMucGVuZGluZ1NwZWNFeGNlcHRpb25NZXNzYWdlID0gJz0+IG1hcmtlZCBQZW5kaW5nJztcblxuICBTcGVjLmlzUGVuZGluZ1NwZWNFeGNlcHRpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuICEhKFxuICAgICAgZSAmJlxuICAgICAgZS50b1N0cmluZyAmJlxuICAgICAgZS50b1N0cmluZygpLmluZGV4T2YoU3BlYy5wZW5kaW5nU3BlY0V4Y2VwdGlvbk1lc3NhZ2UpICE9PSAtMVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbnRlcmZhY2UgU3BlY1xuICAgKiBAc2VlIENvbmZpZ3VyYXRpb24jc3BlY0ZpbHRlclxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNwZWMucHJvdG90eXBlLCAnbWV0YWRhdGEnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5tZXRhZGF0YV8pIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YV8gPSB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGlzIHNwZWMuXG4gICAgICAgICAgICogQG5hbWUgU3BlYyNpZFxuICAgICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAgICovXG4gICAgICAgICAgaWQ6IHRoaXMuaWQsXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgZGVzY3JpcHRpb24gcGFzc2VkIHRvIHRoZSB7QGxpbmsgaXR9IHRoYXQgY3JlYXRlZCB0aGlzIHNwZWMuXG4gICAgICAgICAgICogQG5hbWUgU3BlYyNkZXNjcmlwdGlvblxuICAgICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAgICovXG4gICAgICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgZnVsbCBkZXNjcmlwdGlvbiBpbmNsdWRpbmcgYWxsIGFuY2VzdG9ycyBvZiB0aGlzIHNwZWMuXG4gICAgICAgICAgICogQG5hbWUgU3BlYyNnZXRGdWxsTmFtZVxuICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgICAgICovXG4gICAgICAgICAgZ2V0RnVsbE5hbWU6IHRoaXMuZ2V0RnVsbE5hbWUuYmluZCh0aGlzKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5tZXRhZGF0YV87XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gU3BlYztcbn07XG5cbi8qanNoaW50IGJpdHdpc2U6IGZhbHNlKi9cblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5PcmRlciA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBPcmRlcihvcHRpb25zKSB7XG4gICAgdGhpcy5yYW5kb20gPSAncmFuZG9tJyBpbiBvcHRpb25zID8gb3B0aW9ucy5yYW5kb20gOiB0cnVlO1xuICAgIHZhciBzZWVkID0gKHRoaXMuc2VlZCA9IG9wdGlvbnMuc2VlZCB8fCBnZW5lcmF0ZVNlZWQoKSk7XG4gICAgdGhpcy5zb3J0ID0gdGhpcy5yYW5kb20gPyByYW5kb21PcmRlciA6IG5hdHVyYWxPcmRlcjtcblxuICAgIGZ1bmN0aW9uIG5hdHVyYWxPcmRlcihpdGVtcykge1xuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJhbmRvbU9yZGVyKGl0ZW1zKSB7XG4gICAgICB2YXIgY29weSA9IGl0ZW1zLnNsaWNlKCk7XG4gICAgICBjb3B5LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gamVua2luc0hhc2goc2VlZCArIGEuaWQpIC0gamVua2luc0hhc2goc2VlZCArIGIuaWQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29weTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZVNlZWQoKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKE1hdGgucmFuZG9tKCkpLnNsaWNlKC01KTtcbiAgICB9XG5cbiAgICAvLyBCb2IgSmVua2lucyBPbmUtYXQtYS1UaW1lIEhhc2ggYWxnb3JpdGhtIGlzIGEgbm9uLWNyeXB0b2dyYXBoaWMgaGFzaCBmdW5jdGlvblxuICAgIC8vIHVzZWQgdG8gZ2V0IGEgZGlmZmVyZW50IG91dHB1dCB3aGVuIHRoZSBrZXkgY2hhbmdlcyBzbGlnaHRseS5cbiAgICAvLyBXZSB1c2UgeW91ciByZXR1cm4gdG8gc29ydCB0aGUgY2hpbGRyZW4gcmFuZG9tbHkgaW4gYSBjb25zaXN0ZW50IHdheSB3aGVuXG4gICAgLy8gdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGEgc2VlZFxuXG4gICAgZnVuY3Rpb24gamVua2luc0hhc2goa2V5KSB7XG4gICAgICB2YXIgaGFzaCwgaTtcbiAgICAgIGZvciAoaGFzaCA9IGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGhhc2ggKz0ga2V5LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGhhc2ggKz0gaGFzaCA8PCAxMDtcbiAgICAgICAgaGFzaCBePSBoYXNoID4+IDY7XG4gICAgICB9XG4gICAgICBoYXNoICs9IGhhc2ggPDwgMztcbiAgICAgIGhhc2ggXj0gaGFzaCA+PiAxMTtcbiAgICAgIGhhc2ggKz0gaGFzaCA8PCAxNTtcbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBPcmRlcjtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuRW52ID0gZnVuY3Rpb24oaiQpIHtcbiAgLyoqXG4gICAqIEBjbGFzcyBFbnZcbiAgICogQHNpbmNlIDIuMC4wXG4gICAqIEBjbGFzc2Rlc2MgVGhlIEphc21pbmUgZW52aXJvbm1lbnQuPGJyPlxuICAgKiBfTm90ZTpfIERvIG5vdCBjb25zdHJ1Y3QgdGhpcyBkaXJlY3RseS4gWW91IGNhbiBvYnRhaW4gdGhlIEVudiBpbnN0YW5jZSBieVxuICAgKiBjYWxsaW5nIHtAbGluayBqYXNtaW5lLmdldEVudn0uXG4gICAqIEBoaWRlY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIEVudihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGdsb2JhbCA9IG9wdGlvbnMuZ2xvYmFsIHx8IGokLmdldEdsb2JhbCgpO1xuXG4gICAgdmFyIHRvdGFsU3BlY3NEZWZpbmVkID0gMDtcblxuICAgIHZhciByZWFsU2V0VGltZW91dCA9IGdsb2JhbC5zZXRUaW1lb3V0O1xuICAgIHZhciByZWFsQ2xlYXJUaW1lb3V0ID0gZ2xvYmFsLmNsZWFyVGltZW91dDtcbiAgICB2YXIgY2xlYXJTdGFjayA9IGokLmdldENsZWFyU3RhY2soZ2xvYmFsKTtcbiAgICB0aGlzLmNsb2NrID0gbmV3IGokLkNsb2NrKFxuICAgICAgZ2xvYmFsLFxuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgaiQuRGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyKCk7XG4gICAgICB9LFxuICAgICAgbmV3IGokLk1vY2tEYXRlKGdsb2JhbClcbiAgICApO1xuXG4gICAgdmFyIHJ1bm5hYmxlUmVzb3VyY2VzID0ge307XG5cbiAgICB2YXIgY3VycmVudFNwZWMgPSBudWxsO1xuICAgIHZhciBjdXJyZW50bHlFeGVjdXRpbmdTdWl0ZXMgPSBbXTtcbiAgICB2YXIgY3VycmVudERlY2xhcmF0aW9uU3VpdGUgPSBudWxsO1xuICAgIHZhciBoYXNGYWlsdXJlcyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyByZXByZXNlbnRzIHRoZSBhdmFpbGFibGUgb3B0aW9ucyB0byBjb25maWd1cmUgSmFzbWluZS5cbiAgICAgKiBPcHRpb25zIHRoYXQgYXJlIG5vdCBwcm92aWRlZCB3aWxsIHVzZSB0aGVpciBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKiBAc2VlIEVudiNjb25maWd1cmVcbiAgICAgKiBAaW50ZXJmYWNlIENvbmZpZ3VyYXRpb25cbiAgICAgKiBAc2luY2UgMy4zLjBcbiAgICAgKi9cbiAgICB2YXIgY29uZmlnID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIHRvIHJhbmRvbWl6ZSBzcGVjIGV4ZWN1dGlvbiBvcmRlclxuICAgICAgICogQG5hbWUgQ29uZmlndXJhdGlvbiNyYW5kb21cbiAgICAgICAqIEBzaW5jZSAzLjMuMFxuICAgICAgICogQHR5cGUgQm9vbGVhblxuICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICovXG4gICAgICByYW5kb206IHRydWUsXG4gICAgICAvKipcbiAgICAgICAqIFNlZWQgdG8gdXNlIGFzIHRoZSBiYXNpcyBvZiByYW5kb21pemF0aW9uLlxuICAgICAgICogTnVsbCBjYXVzZXMgdGhlIHNlZWQgdG8gYmUgZGV0ZXJtaW5lZCByYW5kb21seSBhdCB0aGUgc3RhcnQgb2YgZXhlY3V0aW9uLlxuICAgICAgICogQG5hbWUgQ29uZmlndXJhdGlvbiNzZWVkXG4gICAgICAgKiBAc2luY2UgMy4zLjBcbiAgICAgICAqIEB0eXBlIChudW1iZXJ8c3RyaW5nKVxuICAgICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAgICovXG4gICAgICBzZWVkOiBudWxsLFxuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIHRvIHN0b3AgZXhlY3V0aW9uIG9mIHRoZSBzdWl0ZSBhZnRlciB0aGUgZmlyc3Qgc3BlYyBmYWlsdXJlXG4gICAgICAgKiBAbmFtZSBDb25maWd1cmF0aW9uI3N0b3BPblNwZWNGYWlsdXJlXG4gICAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgKi9cbiAgICAgIHN0b3BPblNwZWNGYWlsdXJlOiBmYWxzZSxcbiAgICAgIC8qKlxuICAgICAgICogV2hldGhlciB0byBmYWlsIHRoZSBzcGVjIGlmIGl0IHJhbiBubyBleHBlY3RhdGlvbnMuIEJ5IGRlZmF1bHRcbiAgICAgICAqIGEgc3BlYyB0aGF0IHJhbiBubyBleHBlY3RhdGlvbnMgaXMgcmVwb3J0ZWQgYXMgcGFzc2VkLiBTZXR0aW5nIHRoaXNcbiAgICAgICAqIHRvIHRydWUgd2lsbCByZXBvcnQgc3VjaCBzcGVjIGFzIGEgZmFpbHVyZS5cbiAgICAgICAqIEBuYW1lIENvbmZpZ3VyYXRpb24jZmFpbFNwZWNXaXRoTm9FeHBlY3RhdGlvbnNcbiAgICAgICAqIEBzaW5jZSAzLjUuMFxuICAgICAgICogQHR5cGUgQm9vbGVhblxuICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAqL1xuICAgICAgZmFpbFNwZWNXaXRoTm9FeHBlY3RhdGlvbnM6IGZhbHNlLFxuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIHRvIGNhdXNlIHNwZWNzIHRvIG9ubHkgaGF2ZSBvbmUgZXhwZWN0YXRpb24gZmFpbHVyZS5cbiAgICAgICAqIEBuYW1lIENvbmZpZ3VyYXRpb24jc3RvcFNwZWNPbkV4cGVjdGF0aW9uRmFpbHVyZVxuICAgICAgICogQHNpbmNlIDMuMy4wXG4gICAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICovXG4gICAgICBzdG9wU3BlY09uRXhwZWN0YXRpb25GYWlsdXJlOiBmYWxzZSxcbiAgICAgIC8qKlxuICAgICAgICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgc3BlYyBhbmQgcmV0dXJucyB0cnVlIGlmIGl0IHNob3VsZCBiZSBleGVjdXRlZFxuICAgICAgICogb3IgZmFsc2UgaWYgaXQgc2hvdWxkIGJlIHNraXBwZWQuXG4gICAgICAgKiBAY2FsbGJhY2sgU3BlY0ZpbHRlclxuICAgICAgICogQHBhcmFtIHtTcGVjfSBzcGVjIC0gVGhlIHNwZWMgdGhhdCB0aGUgZmlsdGVyIGlzIGJlaW5nIGFwcGxpZWQgdG8uXG4gICAgICAgKiBAcmV0dXJuIGJvb2xlYW5cbiAgICAgICAqL1xuICAgICAgLyoqXG4gICAgICAgKiBGdW5jdGlvbiB0byB1c2UgdG8gZmlsdGVyIHNwZWNzXG4gICAgICAgKiBAbmFtZSBDb25maWd1cmF0aW9uI3NwZWNGaWx0ZXJcbiAgICAgICAqIEBzaW5jZSAzLjMuMFxuICAgICAgICogQHR5cGUgU3BlY0ZpbHRlclxuICAgICAgICogQGRlZmF1bHQgQSBmdW5jdGlvbiB0aGF0IGFsd2F5cyByZXR1cm5zIHRydWUuXG4gICAgICAgKi9cbiAgICAgIHNwZWNGaWx0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIFdoZXRoZXIgb3Igbm90IHJlcG9ydGVycyBzaG91bGQgaGlkZSBkaXNhYmxlZCBzcGVjcyBmcm9tIHRoZWlyIG91dHB1dC5cbiAgICAgICAqIEN1cnJlbnRseSBvbmx5IHN1cHBvcnRlZCBieSBKYXNtaW5lJ3MgSFRNTFJlcG9ydGVyXG4gICAgICAgKiBAbmFtZSBDb25maWd1cmF0aW9uI2hpZGVEaXNhYmxlZFxuICAgICAgICogQHNpbmNlIDMuMy4wXG4gICAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICovXG4gICAgICBoaWRlRGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgLyoqXG4gICAgICAgKiBDbGVhbiBjbG9zdXJlcyB3aGVuIGEgc3VpdGUgaXMgZG9uZSBydW5uaW5nIChkb25lIGJ5IGNsZWFyaW5nIHRoZSBzdG9yZWQgZnVuY3Rpb24gcmVmZXJlbmNlKS5cbiAgICAgICAqIFRoaXMgcHJldmVudHMgbWVtb3J5IGxlYWtzLCBidXQgeW91IHdvbid0IGJlIGFibGUgdG8gcnVuIGphc21pbmUgbXVsdGlwbGUgdGltZXMuXG4gICAgICAgKiBAbmFtZSBDb25maWd1cmF0aW9uI2F1dG9DbGVhbkNsb3N1cmVzXG4gICAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgKi9cbiAgICAgIGF1dG9DbGVhbkNsb3N1cmVzOiB0cnVlLFxuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0byBpc3N1ZSB3YXJuaW5ncyBmb3IgY2VydGFpbiBkZXByZWNhdGVkIGZ1bmN0aW9uYWxpdHlcbiAgICAgICAqIGV2ZXJ5IHRpbWUgaXQncyB1c2VkLiBJZiBub3Qgc2V0IG9yIHNldCB0byBmYWxzZSwgZGVwcmVjYXRpb24gd2FybmluZ3NcbiAgICAgICAqIGZvciBtZXRob2RzIHRoYXQgdGVuZCB0byBiZSBjYWxsZWQgZnJlcXVlbnRseSB3aWxsIGJlIGlzc3VlZCBvbmx5IG9uY2VcbiAgICAgICAqIG9yIG90aGVyd2lzZSB0aHJvdHRsZWQgdG8gdG8gcHJldmVudCB0aGUgc3VpdGUgb3V0cHV0IGZyb20gYmVpbmcgZmxvb2RlZFxuICAgICAgICogd2l0aCB3YXJuaW5ncy5cbiAgICAgICAqIEBuYW1lIENvbmZpZ3VyYXRpb24jdmVyYm9zZURlcHJlY2F0aW9uc1xuICAgICAgICogQHNpbmNlIDMuNi4wXG4gICAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICovXG4gICAgICB2ZXJib3NlRGVwcmVjYXRpb25zOiBmYWxzZVxuICAgIH07XG5cbiAgICB2YXIgY3VycmVudFN1aXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY3VycmVudGx5RXhlY3V0aW5nU3VpdGVzW2N1cnJlbnRseUV4ZWN1dGluZ1N1aXRlcy5sZW5ndGggLSAxXTtcbiAgICB9O1xuXG4gICAgdmFyIGN1cnJlbnRSdW5uYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRTcGVjIHx8IGN1cnJlbnRTdWl0ZSgpO1xuICAgIH07XG5cbiAgICB2YXIgZ2xvYmFsRXJyb3JzID0gbnVsbDtcblxuICAgIHZhciBpbnN0YWxsR2xvYmFsRXJyb3JzID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoZ2xvYmFsRXJyb3JzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZ2xvYmFsRXJyb3JzID0gbmV3IGokLkdsb2JhbEVycm9ycygpO1xuICAgICAgZ2xvYmFsRXJyb3JzLmluc3RhbGwoKTtcbiAgICB9O1xuXG4gICAgaWYgKCFvcHRpb25zLnN1cHByZXNzTG9hZEVycm9ycykge1xuICAgICAgaW5zdGFsbEdsb2JhbEVycm9ycygpO1xuICAgICAgZ2xvYmFsRXJyb3JzLnB1c2hMaXN0ZW5lcihmdW5jdGlvbihcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgIGxpbmVubyxcbiAgICAgICAgY29sTm8sXG4gICAgICAgIGVyclxuICAgICAgKSB7XG4gICAgICAgIHRvcFN1aXRlLnJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMucHVzaCh7XG4gICAgICAgICAgcGFzc2VkOiBmYWxzZSxcbiAgICAgICAgICBnbG9iYWxFcnJvclR5cGU6ICdsb2FkJyxcbiAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgIHN0YWNrOiBlcnIgJiYgZXJyLnN0YWNrLFxuICAgICAgICAgIGZpbGVuYW1lOiBmaWxlbmFtZSxcbiAgICAgICAgICBsaW5lbm86IGxpbmVub1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZSB5b3VyIGphc21pbmUgZW52aXJvbm1lbnRcbiAgICAgKiBAbmFtZSBFbnYjY29uZmlndXJlXG4gICAgICogQHNpbmNlIDMuMy4wXG4gICAgICogQGFyZ3VtZW50IHtDb25maWd1cmF0aW9ufSBjb25maWd1cmF0aW9uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgdGhpcy5jb25maWd1cmUgPSBmdW5jdGlvbihjb25maWd1cmF0aW9uKSB7XG4gICAgICB2YXIgYm9vbGVhblByb3BzID0gW1xuICAgICAgICAncmFuZG9tJyxcbiAgICAgICAgJ2ZhaWxTcGVjV2l0aE5vRXhwZWN0YXRpb25zJyxcbiAgICAgICAgJ2hpZGVEaXNhYmxlZCcsXG4gICAgICAgICdzdG9wT25TcGVjRmFpbHVyZScsXG4gICAgICAgICdzdG9wU3BlY09uRXhwZWN0YXRpb25GYWlsdXJlJyxcbiAgICAgICAgJ2F1dG9DbGVhbkNsb3N1cmVzJ1xuICAgICAgXTtcblxuICAgICAgYm9vbGVhblByb3BzLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZ3VyYXRpb25bcHJvcF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY29uZmlnW3Byb3BdID0gISFjb25maWd1cmF0aW9uW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGNvbmZpZ3VyYXRpb24uc3BlY0ZpbHRlcikge1xuICAgICAgICBjb25maWcuc3BlY0ZpbHRlciA9IGNvbmZpZ3VyYXRpb24uc3BlY0ZpbHRlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjb25maWd1cmF0aW9uLnNlZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbmZpZy5zZWVkID0gY29uZmlndXJhdGlvbi5zZWVkO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29uZmlndXJhdGlvbi5oYXNPd25Qcm9wZXJ0eSgndmVyYm9zZURlcHJlY2F0aW9ucycpKSB7XG4gICAgICAgIGNvbmZpZy52ZXJib3NlRGVwcmVjYXRpb25zID0gY29uZmlndXJhdGlvbi52ZXJib3NlRGVwcmVjYXRpb25zO1xuICAgICAgICBkZXByZWNhdG9yLnZlcmJvc2VEZXByZWNhdGlvbnMoY29uZmlnLnZlcmJvc2VEZXByZWNhdGlvbnMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgY29uZmlndXJhdGlvbiBmb3IgeW91ciBqYXNtaW5lIGVudmlyb25tZW50XG4gICAgICogQG5hbWUgRW52I2NvbmZpZ3VyYXRpb25cbiAgICAgKiBAc2luY2UgMy4zLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7Q29uZmlndXJhdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIGNvbmZpZykge1xuICAgICAgICByZXN1bHRbcHJvcGVydHldID0gY29uZmlnW3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0RGVmYXVsdFNweVN0cmF0ZWd5ID0gZnVuY3Rpb24oZGVmYXVsdFN0cmF0ZWd5Rm4pIHtcbiAgICAgIGlmICghY3VycmVudFJ1bm5hYmxlKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdEZWZhdWx0IHNweSBzdHJhdGVneSBtdXN0IGJlIHNldCBpbiBhIGJlZm9yZSBmdW5jdGlvbiBvciBhIHNwZWMnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBydW5uYWJsZVJlc291cmNlc1tcbiAgICAgICAgY3VycmVudFJ1bm5hYmxlKCkuaWRcbiAgICAgIF0uZGVmYXVsdFN0cmF0ZWd5Rm4gPSBkZWZhdWx0U3RyYXRlZ3lGbjtcbiAgICB9O1xuXG4gICAgdGhpcy5hZGRTcHlTdHJhdGVneSA9IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XG4gICAgICBpZiAoIWN1cnJlbnRSdW5uYWJsZSgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnQ3VzdG9tIHNweSBzdHJhdGVnaWVzIG11c3QgYmUgYWRkZWQgaW4gYSBiZWZvcmUgZnVuY3Rpb24gb3IgYSBzcGVjJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcnVubmFibGVSZXNvdXJjZXNbY3VycmVudFJ1bm5hYmxlKCkuaWRdLmN1c3RvbVNweVN0cmF0ZWdpZXNbbmFtZV0gPSBmbjtcbiAgICB9O1xuXG4gICAgdGhpcy5hZGRDdXN0b21FcXVhbGl0eVRlc3RlciA9IGZ1bmN0aW9uKHRlc3Rlcikge1xuICAgICAgaWYgKCFjdXJyZW50UnVubmFibGUoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0N1c3RvbSBFcXVhbGl0aWVzIG11c3QgYmUgYWRkZWQgaW4gYSBiZWZvcmUgZnVuY3Rpb24gb3IgYSBzcGVjJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcnVubmFibGVSZXNvdXJjZXNbY3VycmVudFJ1bm5hYmxlKCkuaWRdLmN1c3RvbUVxdWFsaXR5VGVzdGVycy5wdXNoKFxuICAgICAgICB0ZXN0ZXJcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHRoaXMuYWRkTWF0Y2hlcnMgPSBmdW5jdGlvbihtYXRjaGVyc1RvQWRkKSB7XG4gICAgICBpZiAoIWN1cnJlbnRSdW5uYWJsZSgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnTWF0Y2hlcnMgbXVzdCBiZSBhZGRlZCBpbiBhIGJlZm9yZSBmdW5jdGlvbiBvciBhIHNwZWMnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2YXIgY3VzdG9tTWF0Y2hlcnMgPVxuICAgICAgICBydW5uYWJsZVJlc291cmNlc1tjdXJyZW50UnVubmFibGUoKS5pZF0uY3VzdG9tTWF0Y2hlcnM7XG5cbiAgICAgIGZvciAodmFyIG1hdGNoZXJOYW1lIGluIG1hdGNoZXJzVG9BZGQpIHtcbiAgICAgICAgY3VzdG9tTWF0Y2hlcnNbbWF0Y2hlck5hbWVdID0gbWF0Y2hlcnNUb0FkZFttYXRjaGVyTmFtZV07XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuYWRkQXN5bmNNYXRjaGVycyA9IGZ1bmN0aW9uKG1hdGNoZXJzVG9BZGQpIHtcbiAgICAgIGlmICghY3VycmVudFJ1bm5hYmxlKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdBc3luYyBNYXRjaGVycyBtdXN0IGJlIGFkZGVkIGluIGEgYmVmb3JlIGZ1bmN0aW9uIG9yIGEgc3BlYydcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZhciBjdXN0b21Bc3luY01hdGNoZXJzID1cbiAgICAgICAgcnVubmFibGVSZXNvdXJjZXNbY3VycmVudFJ1bm5hYmxlKCkuaWRdLmN1c3RvbUFzeW5jTWF0Y2hlcnM7XG5cbiAgICAgIGZvciAodmFyIG1hdGNoZXJOYW1lIGluIG1hdGNoZXJzVG9BZGQpIHtcbiAgICAgICAgY3VzdG9tQXN5bmNNYXRjaGVyc1ttYXRjaGVyTmFtZV0gPSBtYXRjaGVyc1RvQWRkW21hdGNoZXJOYW1lXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5hZGRDdXN0b21PYmplY3RGb3JtYXR0ZXIgPSBmdW5jdGlvbihmb3JtYXR0ZXIpIHtcbiAgICAgIGlmICghY3VycmVudFJ1bm5hYmxlKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdDdXN0b20gb2JqZWN0IGZvcm1hdHRlcnMgbXVzdCBiZSBhZGRlZCBpbiBhIGJlZm9yZSBmdW5jdGlvbiBvciBhIHNwZWMnXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJ1bm5hYmxlUmVzb3VyY2VzW2N1cnJlbnRSdW5uYWJsZSgpLmlkXS5jdXN0b21PYmplY3RGb3JtYXR0ZXJzLnB1c2goXG4gICAgICAgIGZvcm1hdHRlclxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgaiQuRXhwZWN0YXRpb24uYWRkQ29yZU1hdGNoZXJzKGokLm1hdGNoZXJzKTtcbiAgICBqJC5FeHBlY3RhdGlvbi5hZGRBc3luY0NvcmVNYXRjaGVycyhqJC5hc3luY01hdGNoZXJzKTtcblxuICAgIHZhciBuZXh0U3BlY0lkID0gMDtcbiAgICB2YXIgZ2V0TmV4dFNwZWNJZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICdzcGVjJyArIG5leHRTcGVjSWQrKztcbiAgICB9O1xuXG4gICAgdmFyIG5leHRTdWl0ZUlkID0gMDtcbiAgICB2YXIgZ2V0TmV4dFN1aXRlSWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnc3VpdGUnICsgbmV4dFN1aXRlSWQrKztcbiAgICB9O1xuXG4gICAgdmFyIG1ha2VQcmV0dHlQcmludGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3VzdG9tT2JqZWN0Rm9ybWF0dGVycyA9XG4gICAgICAgIHJ1bm5hYmxlUmVzb3VyY2VzW2N1cnJlbnRSdW5uYWJsZSgpLmlkXS5jdXN0b21PYmplY3RGb3JtYXR0ZXJzO1xuICAgICAgcmV0dXJuIGokLm1ha2VQcmV0dHlQcmludGVyKGN1c3RvbU9iamVjdEZvcm1hdHRlcnMpO1xuICAgIH07XG5cbiAgICB2YXIgbWFrZU1hdGNoZXJzVXRpbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgY3IgPSBjdXJyZW50UnVubmFibGUoKTtcblxuICAgICAgaWYgKGNyKSB7XG4gICAgICAgIGNvbnN0IGN1c3RvbUVxdWFsaXR5VGVzdGVycyA9XG4gICAgICAgICAgcnVubmFibGVSZXNvdXJjZXNbY3IuaWRdLmN1c3RvbUVxdWFsaXR5VGVzdGVycztcbiAgICAgICAgcmV0dXJuIG5ldyBqJC5NYXRjaGVyc1V0aWwoe1xuICAgICAgICAgIGN1c3RvbVRlc3RlcnM6IGN1c3RvbUVxdWFsaXR5VGVzdGVycyxcbiAgICAgICAgICBwcDogbWFrZVByZXR0eVByaW50ZXIoKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgaiQuTWF0Y2hlcnNVdGlsKHsgcHA6IGokLmJhc2ljUHJldHR5UHJpbnRlcl8gfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBleHBlY3RhdGlvbkZhY3RvcnkgPSBmdW5jdGlvbihhY3R1YWwsIHNwZWMpIHtcbiAgICAgIHJldHVybiBqJC5FeHBlY3RhdGlvbi5mYWN0b3J5KHtcbiAgICAgICAgbWF0Y2hlcnNVdGlsOiBtYWtlTWF0Y2hlcnNVdGlsKCksXG4gICAgICAgIGN1c3RvbU1hdGNoZXJzOiBydW5uYWJsZVJlc291cmNlc1tzcGVjLmlkXS5jdXN0b21NYXRjaGVycyxcbiAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICAgIGFkZEV4cGVjdGF0aW9uUmVzdWx0OiBhZGRFeHBlY3RhdGlvblJlc3VsdFxuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIGFkZEV4cGVjdGF0aW9uUmVzdWx0KHBhc3NlZCwgcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBzcGVjLmFkZEV4cGVjdGF0aW9uUmVzdWx0KHBhc3NlZCwgcmVzdWx0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVjb3JkTGF0ZUVycm9yKGVycm9yKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBleHBlY3RhdGlvblJlc3VsdEZhY3Rvcnkoe1xuICAgICAgICBlcnJvcixcbiAgICAgICAgcGFzc2VkOiBmYWxzZSxcbiAgICAgICAgbWF0Y2hlck5hbWU6ICcnLFxuICAgICAgICBleHBlY3RlZDogJycsXG4gICAgICAgIGFjdHVhbDogJydcbiAgICAgIH0pO1xuICAgICAgcmVzdWx0Lmdsb2JhbEVycm9yVHlwZSA9ICdsYXRlRXJyb3InO1xuICAgICAgdG9wU3VpdGUucmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9ucy5wdXNoKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVjb3JkTGF0ZUV4cGVjdGF0aW9uKHJ1bmFibGUsIHJ1bmFibGVUeXBlLCByZXN1bHQpIHtcbiAgICAgIHZhciBkZWxheWVkRXhwZWN0YXRpb25SZXN1bHQgPSB7fTtcbiAgICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICAgIGRlbGF5ZWRFeHBlY3RhdGlvblJlc3VsdFtrXSA9IHJlc3VsdFtrXTtcbiAgICAgIH0pO1xuICAgICAgZGVsYXllZEV4cGVjdGF0aW9uUmVzdWx0LnBhc3NlZCA9IGZhbHNlO1xuICAgICAgZGVsYXllZEV4cGVjdGF0aW9uUmVzdWx0Lmdsb2JhbEVycm9yVHlwZSA9ICdsYXRlRXhwZWN0YXRpb24nO1xuICAgICAgZGVsYXllZEV4cGVjdGF0aW9uUmVzdWx0Lm1lc3NhZ2UgPVxuICAgICAgICBydW5hYmxlVHlwZSArXG4gICAgICAgICcgXCInICtcbiAgICAgICAgcnVuYWJsZS5nZXRGdWxsTmFtZSgpICtcbiAgICAgICAgJ1wiIHJhbiBhIFwiJyArXG4gICAgICAgIHJlc3VsdC5tYXRjaGVyTmFtZSArXG4gICAgICAgICdcIiBleHBlY3RhdGlvbiBhZnRlciBpdCBmaW5pc2hlZC5cXG4nO1xuXG4gICAgICBpZiAocmVzdWx0Lm1lc3NhZ2UpIHtcbiAgICAgICAgZGVsYXllZEV4cGVjdGF0aW9uUmVzdWx0Lm1lc3NhZ2UgKz1cbiAgICAgICAgICAnTWVzc2FnZTogXCInICsgcmVzdWx0Lm1lc3NhZ2UgKyAnXCJcXG4nO1xuICAgICAgfVxuXG4gICAgICBkZWxheWVkRXhwZWN0YXRpb25SZXN1bHQubWVzc2FnZSArPVxuICAgICAgICAnMS4gRGlkIHlvdSBmb3JnZXQgdG8gcmV0dXJuIG9yIGF3YWl0IHRoZSByZXN1bHQgb2YgZXhwZWN0QXN5bmM/XFxuJyArXG4gICAgICAgICcyLiBXYXMgZG9uZSgpIGludm9rZWQgYmVmb3JlIGFuIGFzeW5jIG9wZXJhdGlvbiBjb21wbGV0ZWQ/XFxuJyArXG4gICAgICAgICczLiBEaWQgYW4gZXhwZWN0YXRpb24gZm9sbG93IGEgY2FsbCB0byBkb25lKCk/JztcblxuICAgICAgdG9wU3VpdGUucmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9ucy5wdXNoKGRlbGF5ZWRFeHBlY3RhdGlvblJlc3VsdCk7XG4gICAgfVxuXG4gICAgdmFyIGFzeW5jRXhwZWN0YXRpb25GYWN0b3J5ID0gZnVuY3Rpb24oYWN0dWFsLCBzcGVjLCBydW5hYmxlVHlwZSkge1xuICAgICAgcmV0dXJuIGokLkV4cGVjdGF0aW9uLmFzeW5jRmFjdG9yeSh7XG4gICAgICAgIG1hdGNoZXJzVXRpbDogbWFrZU1hdGNoZXJzVXRpbCgpLFxuICAgICAgICBjdXN0b21Bc3luY01hdGNoZXJzOiBydW5uYWJsZVJlc291cmNlc1tzcGVjLmlkXS5jdXN0b21Bc3luY01hdGNoZXJzLFxuICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgICAgYWRkRXhwZWN0YXRpb25SZXN1bHQ6IGFkZEV4cGVjdGF0aW9uUmVzdWx0XG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gYWRkRXhwZWN0YXRpb25SZXN1bHQocGFzc2VkLCByZXN1bHQpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRSdW5uYWJsZSgpICE9PSBzcGVjKSB7XG4gICAgICAgICAgcmVjb3JkTGF0ZUV4cGVjdGF0aW9uKHNwZWMsIHJ1bmFibGVUeXBlLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGVjLmFkZEV4cGVjdGF0aW9uUmVzdWx0KHBhc3NlZCwgcmVzdWx0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzdWl0ZUFzeW5jRXhwZWN0YXRpb25GYWN0b3J5ID0gZnVuY3Rpb24oYWN0dWFsLCBzdWl0ZSkge1xuICAgICAgcmV0dXJuIGFzeW5jRXhwZWN0YXRpb25GYWN0b3J5KGFjdHVhbCwgc3VpdGUsICdTdWl0ZScpO1xuICAgIH07XG5cbiAgICB2YXIgc3BlY0FzeW5jRXhwZWN0YXRpb25GYWN0b3J5ID0gZnVuY3Rpb24oYWN0dWFsLCBzdWl0ZSkge1xuICAgICAgcmV0dXJuIGFzeW5jRXhwZWN0YXRpb25GYWN0b3J5KGFjdHVhbCwgc3VpdGUsICdTcGVjJyk7XG4gICAgfTtcblxuICAgIHZhciBkZWZhdWx0UmVzb3VyY2VzRm9yUnVubmFibGUgPSBmdW5jdGlvbihpZCwgcGFyZW50UnVubmFibGVJZCkge1xuICAgICAgdmFyIHJlc291cmNlcyA9IHtcbiAgICAgICAgc3BpZXM6IFtdLFxuICAgICAgICBjdXN0b21FcXVhbGl0eVRlc3RlcnM6IFtdLFxuICAgICAgICBjdXN0b21NYXRjaGVyczoge30sXG4gICAgICAgIGN1c3RvbUFzeW5jTWF0Y2hlcnM6IHt9LFxuICAgICAgICBjdXN0b21TcHlTdHJhdGVnaWVzOiB7fSxcbiAgICAgICAgZGVmYXVsdFN0cmF0ZWd5Rm46IHVuZGVmaW5lZCxcbiAgICAgICAgY3VzdG9tT2JqZWN0Rm9ybWF0dGVyczogW11cbiAgICAgIH07XG5cbiAgICAgIGlmIChydW5uYWJsZVJlc291cmNlc1twYXJlbnRSdW5uYWJsZUlkXSkge1xuICAgICAgICByZXNvdXJjZXMuY3VzdG9tRXF1YWxpdHlUZXN0ZXJzID0gaiQudXRpbC5jbG9uZShcbiAgICAgICAgICBydW5uYWJsZVJlc291cmNlc1twYXJlbnRSdW5uYWJsZUlkXS5jdXN0b21FcXVhbGl0eVRlc3RlcnNcbiAgICAgICAgKTtcbiAgICAgICAgcmVzb3VyY2VzLmN1c3RvbU1hdGNoZXJzID0gaiQudXRpbC5jbG9uZShcbiAgICAgICAgICBydW5uYWJsZVJlc291cmNlc1twYXJlbnRSdW5uYWJsZUlkXS5jdXN0b21NYXRjaGVyc1xuICAgICAgICApO1xuICAgICAgICByZXNvdXJjZXMuY3VzdG9tQXN5bmNNYXRjaGVycyA9IGokLnV0aWwuY2xvbmUoXG4gICAgICAgICAgcnVubmFibGVSZXNvdXJjZXNbcGFyZW50UnVubmFibGVJZF0uY3VzdG9tQXN5bmNNYXRjaGVyc1xuICAgICAgICApO1xuICAgICAgICByZXNvdXJjZXMuY3VzdG9tT2JqZWN0Rm9ybWF0dGVycyA9IGokLnV0aWwuY2xvbmUoXG4gICAgICAgICAgcnVubmFibGVSZXNvdXJjZXNbcGFyZW50UnVubmFibGVJZF0uY3VzdG9tT2JqZWN0Rm9ybWF0dGVyc1xuICAgICAgICApO1xuICAgICAgICByZXNvdXJjZXMuY3VzdG9tU3B5U3RyYXRlZ2llcyA9IGokLnV0aWwuY2xvbmUoXG4gICAgICAgICAgcnVubmFibGVSZXNvdXJjZXNbcGFyZW50UnVubmFibGVJZF0uY3VzdG9tU3B5U3RyYXRlZ2llc1xuICAgICAgICApO1xuICAgICAgICByZXNvdXJjZXMuZGVmYXVsdFN0cmF0ZWd5Rm4gPVxuICAgICAgICAgIHJ1bm5hYmxlUmVzb3VyY2VzW3BhcmVudFJ1bm5hYmxlSWRdLmRlZmF1bHRTdHJhdGVneUZuO1xuICAgICAgfVxuXG4gICAgICBydW5uYWJsZVJlc291cmNlc1tpZF0gPSByZXNvdXJjZXM7XG4gICAgfTtcblxuICAgIHZhciBjbGVhclJlc291cmNlc0ZvclJ1bm5hYmxlID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgIHNweVJlZ2lzdHJ5LmNsZWFyU3BpZXMoKTtcbiAgICAgIGRlbGV0ZSBydW5uYWJsZVJlc291cmNlc1tpZF07XG4gICAgfTtcblxuICAgIHZhciBiZWZvcmVBbmRBZnRlckZucyA9IGZ1bmN0aW9uKHRhcmdldFN1aXRlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBiZWZvcmVzID0gW10sXG4gICAgICAgICAgYWZ0ZXJzID0gW10sXG4gICAgICAgICAgc3VpdGUgPSB0YXJnZXRTdWl0ZTtcblxuICAgICAgICB3aGlsZSAoc3VpdGUpIHtcbiAgICAgICAgICBiZWZvcmVzID0gYmVmb3Jlcy5jb25jYXQoc3VpdGUuYmVmb3JlRm5zKTtcbiAgICAgICAgICBhZnRlcnMgPSBhZnRlcnMuY29uY2F0KHN1aXRlLmFmdGVyRm5zKTtcblxuICAgICAgICAgIHN1aXRlID0gc3VpdGUucGFyZW50U3VpdGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJlZm9yZXM6IGJlZm9yZXMucmV2ZXJzZSgpLFxuICAgICAgICAgIGFmdGVyczogYWZ0ZXJzXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgZ2V0U3BlY05hbWUgPSBmdW5jdGlvbihzcGVjLCBzdWl0ZSkge1xuICAgICAgdmFyIGZ1bGxOYW1lID0gW3NwZWMuZGVzY3JpcHRpb25dLFxuICAgICAgICBzdWl0ZUZ1bGxOYW1lID0gc3VpdGUuZ2V0RnVsbE5hbWUoKTtcblxuICAgICAgaWYgKHN1aXRlRnVsbE5hbWUgIT09ICcnKSB7XG4gICAgICAgIGZ1bGxOYW1lLnVuc2hpZnQoc3VpdGVGdWxsTmFtZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVsbE5hbWUuam9pbignICcpO1xuICAgIH07XG5cbiAgICAvLyBUT0RPOiB3ZSBtYXkganVzdCBiZSBhYmxlIHRvIHBhc3MgaW4gdGhlIGZuIGluc3RlYWQgb2Ygd3JhcHBpbmcgaGVyZVxuICAgIHZhciBidWlsZEV4cGVjdGF0aW9uUmVzdWx0ID0gaiQuYnVpbGRFeHBlY3RhdGlvblJlc3VsdCxcbiAgICAgIGV4Y2VwdGlvbkZvcm1hdHRlciA9IG5ldyBqJC5FeGNlcHRpb25Gb3JtYXR0ZXIoKSxcbiAgICAgIGV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeSA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgICAgIGF0dHJzLm1lc3NhZ2VGb3JtYXR0ZXIgPSBleGNlcHRpb25Gb3JtYXR0ZXIubWVzc2FnZTtcbiAgICAgICAgYXR0cnMuc3RhY2tGb3JtYXR0ZXIgPSBleGNlcHRpb25Gb3JtYXR0ZXIuc3RhY2s7XG5cbiAgICAgICAgcmV0dXJuIGJ1aWxkRXhwZWN0YXRpb25SZXN1bHQoYXR0cnMpO1xuICAgICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhdXNlcyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgdG8gYmUgbG9nZ2VkIHRvIHRoZSBjb25zb2xlIGFuZCByZXBvcnRlZCB0b1xuICAgICAqIHJlcG9ydGVycy5cbiAgICAgKlxuICAgICAqIFRoZSBvcHRpb25hbCBzZWNvbmQgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBoYXZlIGVpdGhlciBvZiB0aGVcbiAgICAgKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgKlxuICAgICAqIG9taXRTdGFja1RyYWNlOiBXaGV0aGVyIHRvIG9taXQgdGhlIHN0YWNrIHRyYWNlLiBPcHRpb25hbC4gRGVmYXVsdHMgdG9cbiAgICAgKiBmYWxzZS4gVGhpcyBvcHRpb24gaXMgaWdub3JlZCBpZiB0aGUgZGVwcmVjYXRpb24gaXMgYW4gRXJyb3IuIFNldCB0aGlzXG4gICAgICogd2hlbiB0aGUgc3RhY2sgdHJhY2Ugd2lsbCBub3QgY29udGFpbiBhbnl0aGluZyB0aGF0IGhlbHBzIHRoZSB1c2VyIGZpbmRcbiAgICAgKiB0aGUgc291cmNlIG9mIHRoZSBkZXByZWNhdGlvbi5cbiAgICAgKlxuICAgICAqIGlnbm9yZVJ1bm5hYmxlOiBXaGV0aGVyIHRvIGxvZyB0aGUgZGVwcmVjYXRpb24gb24gdGhlIHJvb3Qgc3VpdGUsIGlnbm9yaW5nXG4gICAgICogdGhlIHNwZWMgb3Igc3VpdGUgdGhhdCdzIHJ1bm5pbmcgd2hlbiBpdCBoYXBwZW5zLiBPcHRpb25hbC4gRGVmYXVsdHMgdG9cbiAgICAgKiBmYWxzZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIEVudiNkZXByZWNhdGVkXG4gICAgICogQHNpbmNlIDIuOTlcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xFcnJvcn0gZGVwcmVjYXRpb24gVGhlIGRlcHJlY2F0aW9uIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbmFsIGV4dHJhIG9wdGlvbnMsIGFzIGRlc2NyaWJlZCBhYm92ZVxuICAgICAqL1xuICAgIHRoaXMuZGVwcmVjYXRlZCA9IGZ1bmN0aW9uKGRlcHJlY2F0aW9uLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcnVubmFibGUgPSBjdXJyZW50UnVubmFibGUoKSB8fCB0b3BTdWl0ZTtcbiAgICAgIGRlcHJlY2F0b3IuYWRkRGVwcmVjYXRpb25XYXJuaW5nKHJ1bm5hYmxlLCBkZXByZWNhdGlvbiwgb3B0aW9ucyk7XG4gICAgfTtcblxuICAgIHZhciBxdWV1ZVJ1bm5lckZhY3RvcnkgPSBmdW5jdGlvbihvcHRpb25zLCBhcmdzKSB7XG4gICAgICBpZiAob3B0aW9ucy5pc0xlYWYpIHtcbiAgICAgICAgLy8gQSBzcGVjXG4gICAgICAgIG9wdGlvbnMuU2tpcFBvbGljeSA9IGokLkNvbXBsZXRlT25GaXJzdEVycm9yU2tpcFBvbGljeTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5pc1JlcG9ydGVyKSB7XG4gICAgICAgIC8vIEEgcmVwb3J0ZXIgcXVldWVcbiAgICAgICAgb3B0aW9ucy5Ta2lwUG9saWN5ID0gaiQuTmV2ZXJTa2lwUG9saWN5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQSBzdWl0ZVxuICAgICAgICBpZiAoY29uZmlnLnN0b3BPblNwZWNGYWlsdXJlKSB7XG4gICAgICAgICAgb3B0aW9ucy5Ta2lwUG9saWN5ID0gaiQuQ29tcGxldGVPbkZpcnN0RXJyb3JTa2lwUG9saWN5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMuU2tpcFBvbGljeSA9IGokLlNraXBBZnRlckJlZm9yZUFsbEVycm9yUG9saWN5O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMuY2xlYXJTdGFjayA9IG9wdGlvbnMuY2xlYXJTdGFjayB8fCBjbGVhclN0YWNrO1xuICAgICAgb3B0aW9ucy50aW1lb3V0ID0ge1xuICAgICAgICBzZXRUaW1lb3V0OiByZWFsU2V0VGltZW91dCxcbiAgICAgICAgY2xlYXJUaW1lb3V0OiByZWFsQ2xlYXJUaW1lb3V0XG4gICAgICB9O1xuICAgICAgb3B0aW9ucy5mYWlsID0gc2VsZi5mYWlsO1xuICAgICAgb3B0aW9ucy5nbG9iYWxFcnJvcnMgPSBnbG9iYWxFcnJvcnM7XG4gICAgICBvcHRpb25zLm9uRXhjZXB0aW9uID1cbiAgICAgICAgb3B0aW9ucy5vbkV4Y2VwdGlvbiB8fFxuICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgKGN1cnJlbnRSdW5uYWJsZSgpIHx8IHRvcFN1aXRlKS5vbkV4Y2VwdGlvbihlKTtcbiAgICAgICAgfTtcbiAgICAgIG9wdGlvbnMuZGVwcmVjYXRlZCA9IHNlbGYuZGVwcmVjYXRlZDtcblxuICAgICAgbmV3IGokLlF1ZXVlUnVubmVyKG9wdGlvbnMpLmV4ZWN1dGUoYXJncyk7XG4gICAgfTtcblxuICAgIHZhciB0b3BTdWl0ZSA9IG5ldyBqJC5TdWl0ZSh7XG4gICAgICBpZDogZ2V0TmV4dFN1aXRlSWQoKSxcbiAgICAgIGRlc2NyaXB0aW9uOiAnSmFzbWluZV9fVG9wTGV2ZWxfX1N1aXRlJyxcbiAgICAgIGV4cGVjdGF0aW9uRmFjdG9yeTogZXhwZWN0YXRpb25GYWN0b3J5LFxuICAgICAgYXN5bmNFeHBlY3RhdGlvbkZhY3Rvcnk6IHN1aXRlQXN5bmNFeHBlY3RhdGlvbkZhY3RvcnksXG4gICAgICBleHBlY3RhdGlvblJlc3VsdEZhY3Rvcnk6IGV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeSxcbiAgICAgIGF1dG9DbGVhbkNsb3N1cmVzOiBjb25maWcuYXV0b0NsZWFuQ2xvc3VyZXMsXG4gICAgICBvbkxhdGVFcnJvcjogcmVjb3JkTGF0ZUVycm9yXG4gICAgfSk7XG4gICAgdmFyIGRlcHJlY2F0b3IgPSBuZXcgaiQuRGVwcmVjYXRvcih0b3BTdWl0ZSk7XG4gICAgY3VycmVudERlY2xhcmF0aW9uU3VpdGUgPSB0b3BTdWl0ZTtcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIHRoZSByb290IHN1aXRlLCB0aHJvdWdoIHdoaWNoIGFsbCBzdWl0ZXMgYW5kIHNwZWNzIGNhbiBiZVxuICAgICAqIGFjY2Vzc2VkLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBuYW1lIEVudiN0b3BTdWl0ZVxuICAgICAqIEByZXR1cm4ge1N1aXRlfSB0aGUgcm9vdCBzdWl0ZVxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqL1xuICAgIHRoaXMudG9wU3VpdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0b3BTdWl0ZS5tZXRhZGF0YTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyByZXByZXNlbnRzIHRoZSBhdmFpbGFibGUgcmVwb3J0ZXIgY2FsbGJhY2sgZm9yIGFuIG9iamVjdCBwYXNzZWQgdG8ge0BsaW5rIEVudiNhZGRSZXBvcnRlcn0uXG4gICAgICogQGludGVyZmFjZSBSZXBvcnRlclxuICAgICAqIEBzZWUgY3VzdG9tX3JlcG9ydGVyXG4gICAgICovXG4gICAgdmFyIHJlcG9ydGVyID0gbmV3IGokLlJlcG9ydERpc3BhdGNoZXIoXG4gICAgICBbXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgamFzbWluZVN0YXJ0ZWRgIGlzIGNhbGxlZCBhZnRlciBhbGwgb2YgdGhlIHNwZWNzIGhhdmUgYmVlbiBsb2FkZWQsIGJ1dCBqdXN0IGJlZm9yZSBleGVjdXRpb24gc3RhcnRzLlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQG5hbWUgUmVwb3J0ZXIjamFzbWluZVN0YXJ0ZWRcbiAgICAgICAgICogQHBhcmFtIHtKYXNtaW5lU3RhcnRlZEluZm99IHN1aXRlSW5mbyBJbmZvcm1hdGlvbiBhYm91dCB0aGUgZnVsbCBKYXNtaW5lIHN1aXRlIHRoYXQgaXMgYmVpbmcgcnVuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtkb25lXSBVc2VkIHRvIHNwZWNpZnkgdG8gSmFzbWluZSB0aGF0IHRoaXMgY2FsbGJhY2sgaXMgYXN5bmNocm9ub3VzIGFuZCBKYXNtaW5lIHNob3VsZCB3YWl0IHVudGlsIGl0IGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUgbW92aW5nIG9uLlxuICAgICAgICAgKiBAcmV0dXJucyB7fSBPcHRpb25hbGx5IHJldHVybiBhIFByb21pc2UgaW5zdGVhZCBvZiB1c2luZyBgZG9uZWAgdG8gY2F1c2UgSmFzbWluZSB0byB3YWl0IGZvciBjb21wbGV0aW9uLlxuICAgICAgICAgKiBAc2VlIGFzeW5jXG4gICAgICAgICAqL1xuICAgICAgICAnamFzbWluZVN0YXJ0ZWQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiB0aGUgZW50aXJlIHN1aXRlIGhhcyBmaW5pc2hlZCBleGVjdXRpb24gYGphc21pbmVEb25lYCBpcyBjYWxsZWRcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBuYW1lIFJlcG9ydGVyI2phc21pbmVEb25lXG4gICAgICAgICAqIEBwYXJhbSB7SmFzbWluZURvbmVJbmZvfSBzdWl0ZUluZm8gSW5mb3JtYXRpb24gYWJvdXQgdGhlIGZ1bGwgSmFzbWluZSBzdWl0ZSB0aGF0IGp1c3QgZmluaXNoZWQgcnVubmluZy5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2RvbmVdIFVzZWQgdG8gc3BlY2lmeSB0byBKYXNtaW5lIHRoYXQgdGhpcyBjYWxsYmFjayBpcyBhc3luY2hyb25vdXMgYW5kIEphc21pbmUgc2hvdWxkIHdhaXQgdW50aWwgaXQgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSBtb3Zpbmcgb24uXG4gICAgICAgICAqIEByZXR1cm5zIHt9IE9wdGlvbmFsbHkgcmV0dXJuIGEgUHJvbWlzZSBpbnN0ZWFkIG9mIHVzaW5nIGBkb25lYCB0byBjYXVzZSBKYXNtaW5lIHRvIHdhaXQgZm9yIGNvbXBsZXRpb24uXG4gICAgICAgICAqIEBzZWUgYXN5bmNcbiAgICAgICAgICovXG4gICAgICAgICdqYXNtaW5lRG9uZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgc3VpdGVTdGFydGVkYCBpcyBpbnZva2VkIHdoZW4gYSBgZGVzY3JpYmVgIHN0YXJ0cyB0byBydW5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBuYW1lIFJlcG9ydGVyI3N1aXRlU3RhcnRlZFxuICAgICAgICAgKiBAcGFyYW0ge1N1aXRlUmVzdWx0fSByZXN1bHQgSW5mb3JtYXRpb24gYWJvdXQgdGhlIGluZGl2aWR1YWwge0BsaW5rIGRlc2NyaWJlfSBiZWluZyBydW5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2RvbmVdIFVzZWQgdG8gc3BlY2lmeSB0byBKYXNtaW5lIHRoYXQgdGhpcyBjYWxsYmFjayBpcyBhc3luY2hyb25vdXMgYW5kIEphc21pbmUgc2hvdWxkIHdhaXQgdW50aWwgaXQgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSBtb3Zpbmcgb24uXG4gICAgICAgICAqIEByZXR1cm5zIHt9IE9wdGlvbmFsbHkgcmV0dXJuIGEgUHJvbWlzZSBpbnN0ZWFkIG9mIHVzaW5nIGBkb25lYCB0byBjYXVzZSBKYXNtaW5lIHRvIHdhaXQgZm9yIGNvbXBsZXRpb24uXG4gICAgICAgICAqIEBzZWUgYXN5bmNcbiAgICAgICAgICovXG4gICAgICAgICdzdWl0ZVN0YXJ0ZWQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogYHN1aXRlRG9uZWAgaXMgaW52b2tlZCB3aGVuIGFsbCBvZiB0aGUgY2hpbGQgc3BlY3MgYW5kIHN1aXRlcyBmb3IgYSBnaXZlbiBzdWl0ZSBoYXZlIGJlZW4gcnVuXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoaWxlIGphc21pbmUgZG9lc24ndCByZXF1aXJlIGFueSBzcGVjaWZpYyBmdW5jdGlvbnMsIG5vdCBkZWZpbmluZyBhIGBzdWl0ZURvbmVgIHdpbGwgbWFrZSBpdCBpbXBvc3NpYmxlIGZvciBhIHJlcG9ydGVyIHRvIGtub3cgd2hlbiBhIHN1aXRlIGhhcyBmYWlsdXJlcyBpbiBhbiBgYWZ0ZXJBbGxgLlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQG5hbWUgUmVwb3J0ZXIjc3VpdGVEb25lXG4gICAgICAgICAqIEBwYXJhbSB7U3VpdGVSZXN1bHR9IHJlc3VsdFxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZG9uZV0gVXNlZCB0byBzcGVjaWZ5IHRvIEphc21pbmUgdGhhdCB0aGlzIGNhbGxiYWNrIGlzIGFzeW5jaHJvbm91cyBhbmQgSmFzbWluZSBzaG91bGQgd2FpdCB1bnRpbCBpdCBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlIG1vdmluZyBvbi5cbiAgICAgICAgICogQHJldHVybnMge30gT3B0aW9uYWxseSByZXR1cm4gYSBQcm9taXNlIGluc3RlYWQgb2YgdXNpbmcgYGRvbmVgIHRvIGNhdXNlIEphc21pbmUgdG8gd2FpdCBmb3IgY29tcGxldGlvbi5cbiAgICAgICAgICogQHNlZSBhc3luY1xuICAgICAgICAgKi9cbiAgICAgICAgJ3N1aXRlRG9uZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgc3BlY1N0YXJ0ZWRgIGlzIGludm9rZWQgd2hlbiBhbiBgaXRgIHN0YXJ0cyB0byBydW4gKGluY2x1ZGluZyBhc3NvY2lhdGVkIGBiZWZvcmVFYWNoYCBmdW5jdGlvbnMpXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAbmFtZSBSZXBvcnRlciNzcGVjU3RhcnRlZFxuICAgICAgICAgKiBAcGFyYW0ge1NwZWNSZXN1bHR9IHJlc3VsdCBJbmZvcm1hdGlvbiBhYm91dCB0aGUgaW5kaXZpZHVhbCB7QGxpbmsgaXR9IGJlaW5nIHJ1blxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZG9uZV0gVXNlZCB0byBzcGVjaWZ5IHRvIEphc21pbmUgdGhhdCB0aGlzIGNhbGxiYWNrIGlzIGFzeW5jaHJvbm91cyBhbmQgSmFzbWluZSBzaG91bGQgd2FpdCB1bnRpbCBpdCBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlIG1vdmluZyBvbi5cbiAgICAgICAgICogQHJldHVybnMge30gT3B0aW9uYWxseSByZXR1cm4gYSBQcm9taXNlIGluc3RlYWQgb2YgdXNpbmcgYGRvbmVgIHRvIGNhdXNlIEphc21pbmUgdG8gd2FpdCBmb3IgY29tcGxldGlvbi5cbiAgICAgICAgICogQHNlZSBhc3luY1xuICAgICAgICAgKi9cbiAgICAgICAgJ3NwZWNTdGFydGVkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGBzcGVjRG9uZWAgaXMgaW52b2tlZCB3aGVuIGFuIGBpdGAgYW5kIGl0cyBhc3NvY2lhdGVkIGBiZWZvcmVFYWNoYCBhbmQgYGFmdGVyRWFjaGAgZnVuY3Rpb25zIGhhdmUgYmVlbiBydW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoaWxlIGphc21pbmUgZG9lc24ndCByZXF1aXJlIGFueSBzcGVjaWZpYyBmdW5jdGlvbnMsIG5vdCBkZWZpbmluZyBhIGBzcGVjRG9uZWAgd2lsbCBtYWtlIGl0IGltcG9zc2libGUgZm9yIGEgcmVwb3J0ZXIgdG8ga25vdyB3aGVuIGEgc3BlYyBoYXMgZmFpbGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQG5hbWUgUmVwb3J0ZXIjc3BlY0RvbmVcbiAgICAgICAgICogQHBhcmFtIHtTcGVjUmVzdWx0fSByZXN1bHRcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2RvbmVdIFVzZWQgdG8gc3BlY2lmeSB0byBKYXNtaW5lIHRoYXQgdGhpcyBjYWxsYmFjayBpcyBhc3luY2hyb25vdXMgYW5kIEphc21pbmUgc2hvdWxkIHdhaXQgdW50aWwgaXQgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSBtb3Zpbmcgb24uXG4gICAgICAgICAqIEByZXR1cm5zIHt9IE9wdGlvbmFsbHkgcmV0dXJuIGEgUHJvbWlzZSBpbnN0ZWFkIG9mIHVzaW5nIGBkb25lYCB0byBjYXVzZSBKYXNtaW5lIHRvIHdhaXQgZm9yIGNvbXBsZXRpb24uXG4gICAgICAgICAqIEBzZWUgYXN5bmNcbiAgICAgICAgICovXG4gICAgICAgICdzcGVjRG9uZSdcbiAgICAgIF0sXG4gICAgICBxdWV1ZVJ1bm5lckZhY3RvcnksXG4gICAgICByZWNvcmRMYXRlRXJyb3JcbiAgICApO1xuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIHNwZWNzLlxuICAgICAqXG4gICAgICogSWYgY2FsbGVkIHdpdGggbm8gcGFyYW1ldGVycyBvciB3aXRoIGEgZmFsc3kgdmFsdWUgYXMgdGhlIGZpcnN0IHBhcmFtZXRlcixcbiAgICAgKiBhbGwgc3BlY3Mgd2lsbCBiZSBleGVjdXRlZCBleGNlcHQgdGhvc2UgdGhhdCBhcmUgZXhjbHVkZWQgYnkgYVxuICAgICAqIFtzcGVjIGZpbHRlcl17QGxpbmsgQ29uZmlndXJhdGlvbiNzcGVjRmlsdGVyfSBvciBvdGhlciBtZWNoYW5pc20uIElmIHRoZVxuICAgICAqIGZpcnN0IHBhcmFtZXRlciBpcyBhIGxpc3Qgb2Ygc3BlYy9zdWl0ZSBJRHMsIG9ubHkgdGhvc2Ugc3BlY3Mvc3VpdGVzIHdpbGxcbiAgICAgKiBiZSBydW4uXG4gICAgICpcbiAgICAgKiBCb3RoIHBhcmFtZXRlcnMgYXJlIG9wdGlvbmFsLCBidXQgYSBjb21wbGV0aW9uIGNhbGxiYWNrIGlzIG9ubHkgdmFsaWQgYXNcbiAgICAgKiB0aGUgc2Vjb25kIHBhcmFtZXRlci4gVG8gc3BlY2lmeSBhIGNvbXBsZXRpb24gY2FsbGJhY2sgYnV0IG5vdCBhIGxpc3Qgb2ZcbiAgICAgKiBzcGVjcy9zdWl0ZXMgdG8gcnVuLCBwYXNzIG51bGwgb3IgdW5kZWZpbmVkIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIuIFRoZVxuICAgICAqIGNvbXBsZXRpb24gY2FsbGJhY2sgaXMgc3VwcG9ydGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiBJbiBtb3N0XG4gICAgICogY2FzZXMgaXQgd2lsbCBiZSBtb3JlIGNvbnZlbmllbnQgdG8gdXNlIHRoZSByZXR1cm5lZCBwcm9taXNlIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBleGVjdXRlIHNob3VsZCBub3QgYmUgY2FsbGVkIG1vcmUgdGhhbiBvbmNlIHVubGVzcyB0aGUgZW52IGhhcyBiZWVuXG4gICAgICogY29uZmlndXJlZCB3aXRoIGB7YXV0b0NsZWFuQ2xvc3VyZXM6IGZhbHNlfWAuXG4gICAgICpcbiAgICAgKiBleGVjdXRlIHJldHVybnMgYSBwcm9taXNlLiBUaGUgcHJvbWlzZSB3aWxsIGJlIHJlc29sdmVkIHRvIHRoZSBzYW1lXG4gICAgICoge0BsaW5rIEphc21pbmVEb25lSW5mb3xvdmVyYWxsIHJlc3VsdH0gdGhhdCdzIHBhc3NlZCB0byBhIHJlcG9ydGVyJ3NcbiAgICAgKiBgamFzbWluZURvbmVgIG1ldGhvZCwgZXZlbiBpZiB0aGUgc3VpdGUgZGlkIG5vdCBwYXNzLiBUbyBkZXRlcm1pbmVcbiAgICAgKiB3aGV0aGVyIHRoZSBzdWl0ZSBwYXNzZWQsIGNoZWNrIHRoZSB2YWx1ZSB0aGF0IHRoZSBwcm9taXNlIHJlc29sdmVzIHRvXG4gICAgICogb3IgdXNlIGEge0BsaW5rIFJlcG9ydGVyfS5cbiAgICAgKlxuICAgICAqIEBuYW1lIEVudiNleGVjdXRlXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsoc3RyaW5nW10pPX0gcnVubmFibGVzVG9SdW4gSURzIG9mIHN1aXRlcyBhbmQvb3Igc3BlY3MgdG8gcnVuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uQ29tcGxldGUgRnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBhZnRlciBhbGwgc3BlY3MgaGF2ZSBydW5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPEphc21pbmVEb25lSW5mbz59XG4gICAgICovXG4gICAgdGhpcy5leGVjdXRlID0gZnVuY3Rpb24ocnVubmFibGVzVG9SdW4sIG9uQ29tcGxldGUpIHtcbiAgICAgIGlmICh0aGlzLl9leGVjdXRlZEJlZm9yZSkge1xuICAgICAgICB0b3BTdWl0ZS5yZXNldCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZXhlY3V0ZWRCZWZvcmUgPSB0cnVlO1xuICAgICAgZGVmYXVsdFJlc291cmNlc0ZvclJ1bm5hYmxlKHRvcFN1aXRlLmlkKTtcbiAgICAgIGluc3RhbGxHbG9iYWxFcnJvcnMoKTtcblxuICAgICAgaWYgKCFydW5uYWJsZXNUb1J1bikge1xuICAgICAgICBpZiAoZm9jdXNlZFJ1bm5hYmxlcy5sZW5ndGgpIHtcbiAgICAgICAgICBydW5uYWJsZXNUb1J1biA9IGZvY3VzZWRSdW5uYWJsZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcnVubmFibGVzVG9SdW4gPSBbdG9wU3VpdGUuaWRdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBvcmRlciA9IG5ldyBqJC5PcmRlcih7XG4gICAgICAgIHJhbmRvbTogY29uZmlnLnJhbmRvbSxcbiAgICAgICAgc2VlZDogY29uZmlnLnNlZWRcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgcHJvY2Vzc29yID0gbmV3IGokLlRyZWVQcm9jZXNzb3Ioe1xuICAgICAgICB0cmVlOiB0b3BTdWl0ZSxcbiAgICAgICAgcnVubmFibGVJZHM6IHJ1bm5hYmxlc1RvUnVuLFxuICAgICAgICBxdWV1ZVJ1bm5lckZhY3Rvcnk6IHF1ZXVlUnVubmVyRmFjdG9yeSxcbiAgICAgICAgZmFpbFNwZWNXaXRoTm9FeHBlY3RhdGlvbnM6IGNvbmZpZy5mYWlsU3BlY1dpdGhOb0V4cGVjdGF0aW9ucyxcbiAgICAgICAgbm9kZVN0YXJ0OiBmdW5jdGlvbihzdWl0ZSwgbmV4dCkge1xuICAgICAgICAgIGN1cnJlbnRseUV4ZWN1dGluZ1N1aXRlcy5wdXNoKHN1aXRlKTtcbiAgICAgICAgICBkZWZhdWx0UmVzb3VyY2VzRm9yUnVubmFibGUoc3VpdGUuaWQsIHN1aXRlLnBhcmVudFN1aXRlLmlkKTtcbiAgICAgICAgICByZXBvcnRlci5zdWl0ZVN0YXJ0ZWQoc3VpdGUucmVzdWx0LCBuZXh0KTtcbiAgICAgICAgICBzdWl0ZS5zdGFydFRpbWVyKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG5vZGVDb21wbGV0ZTogZnVuY3Rpb24oc3VpdGUsIHJlc3VsdCwgbmV4dCkge1xuICAgICAgICAgIGlmIChzdWl0ZSAhPT0gY3VycmVudFN1aXRlKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJpZWQgdG8gY29tcGxldGUgdGhlIHdyb25nIHN1aXRlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2xlYXJSZXNvdXJjZXNGb3JSdW5uYWJsZShzdWl0ZS5pZCk7XG4gICAgICAgICAgY3VycmVudGx5RXhlY3V0aW5nU3VpdGVzLnBvcCgpO1xuXG4gICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgICAgICBoYXNGYWlsdXJlcyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN1aXRlLmVuZFRpbWVyKCk7XG5cbiAgICAgICAgICBpZiAoc3VpdGUuaGFkQmVmb3JlQWxsRmFpbHVyZSkge1xuICAgICAgICAgICAgcmVwb3J0Q2hpbGRyZW5PZkJlZm9yZUFsbEZhaWx1cmUoc3VpdGUpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJlcG9ydGVyLnN1aXRlRG9uZShyZXN1bHQsIG5leHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcG9ydGVyLnN1aXRlRG9uZShyZXN1bHQsIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb3JkZXJDaGlsZHJlbjogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIHJldHVybiBvcmRlci5zb3J0KG5vZGUuY2hpbGRyZW4pO1xuICAgICAgICB9LFxuICAgICAgICBleGNsdWRlTm9kZTogZnVuY3Rpb24oc3BlYykge1xuICAgICAgICAgIHJldHVybiAhY29uZmlnLnNwZWNGaWx0ZXIoc3BlYyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXByb2Nlc3Nvci5wcm9jZXNzVHJlZSgpLnZhbGlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBvcmRlcjogd291bGQgY2F1c2UgYSBiZWZvcmVBbGwgb3IgYWZ0ZXJBbGwgdG8gYmUgcnVuIG11bHRpcGxlIHRpbWVzJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB2YXIgamFzbWluZVRpbWVyID0gbmV3IGokLlRpbWVyKCk7XG4gICAgICBqYXNtaW5lVGltZXIuc3RhcnQoKTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgcnVuQWxsKGZ1bmN0aW9uKGphc21pbmVEb25lSW5mbykge1xuICAgICAgICAgIGlmIChvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzb2x2ZShqYXNtaW5lRG9uZUluZm8pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBydW5BbGwoZG9uZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5mb3JtYXRpb24gcGFzc2VkIHRvIHRoZSB7QGxpbmsgUmVwb3J0ZXIjamFzbWluZVN0YXJ0ZWR9IGV2ZW50LlxuICAgICAgICAgKiBAdHlwZWRlZiBKYXNtaW5lU3RhcnRlZEluZm9cbiAgICAgICAgICogQHByb3BlcnR5IHtJbnR9IHRvdGFsU3BlY3NEZWZpbmVkIC0gVGhlIHRvdGFsIG51bWJlciBvZiBzcGVjcyBkZWZpbmVkIGluIHRoaXMgc3VpdGUuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3JkZXJ9IG9yZGVyIC0gSW5mb3JtYXRpb24gYWJvdXQgdGhlIG9yZGVyaW5nIChyYW5kb20gb3Igbm90KSBvZiB0aGlzIGV4ZWN1dGlvbiBvZiB0aGUgc3VpdGUuXG4gICAgICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAgICAgKi9cbiAgICAgICAgcmVwb3J0ZXIuamFzbWluZVN0YXJ0ZWQoXG4gICAgICAgICAge1xuICAgICAgICAgICAgdG90YWxTcGVjc0RlZmluZWQ6IHRvdGFsU3BlY3NEZWZpbmVkLFxuICAgICAgICAgICAgb3JkZXI6IG9yZGVyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGN1cnJlbnRseUV4ZWN1dGluZ1N1aXRlcy5wdXNoKHRvcFN1aXRlKTtcblxuICAgICAgICAgICAgcHJvY2Vzc29yLmV4ZWN1dGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIChhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9wU3VpdGUuaGFkQmVmb3JlQWxsRmFpbHVyZSkge1xuICAgICAgICAgICAgICAgICAgYXdhaXQgcmVwb3J0Q2hpbGRyZW5PZkJlZm9yZUFsbEZhaWx1cmUodG9wU3VpdGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNsZWFyUmVzb3VyY2VzRm9yUnVubmFibGUodG9wU3VpdGUuaWQpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseUV4ZWN1dGluZ1N1aXRlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB2YXIgb3ZlcmFsbFN0YXR1cywgaW5jb21wbGV0ZVJlYXNvbjtcblxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIGhhc0ZhaWx1cmVzIHx8XG4gICAgICAgICAgICAgICAgICB0b3BTdWl0ZS5yZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIG92ZXJhbGxTdGF0dXMgPSAnZmFpbGVkJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZvY3VzZWRSdW5uYWJsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgb3ZlcmFsbFN0YXR1cyA9ICdpbmNvbXBsZXRlJztcbiAgICAgICAgICAgICAgICAgIGluY29tcGxldGVSZWFzb24gPSAnZml0KCkgb3IgZmRlc2NyaWJlKCkgd2FzIGZvdW5kJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRvdGFsU3BlY3NEZWZpbmVkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBvdmVyYWxsU3RhdHVzID0gJ2luY29tcGxldGUnO1xuICAgICAgICAgICAgICAgICAgaW5jb21wbGV0ZVJlYXNvbiA9ICdObyBzcGVjcyBmb3VuZCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG92ZXJhbGxTdGF0dXMgPSAncGFzc2VkJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJbmZvcm1hdGlvbiBwYXNzZWQgdG8gdGhlIHtAbGluayBSZXBvcnRlciNqYXNtaW5lRG9uZX0gZXZlbnQuXG4gICAgICAgICAgICAgICAgICogQHR5cGVkZWYgSmFzbWluZURvbmVJbmZvXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtPdmVyYWxsU3RhdHVzfSBvdmVyYWxsU3RhdHVzIC0gVGhlIG92ZXJhbGwgcmVzdWx0IG9mIHRoZSBzdWl0ZTogJ3Bhc3NlZCcsICdmYWlsZWQnLCBvciAnaW5jb21wbGV0ZScuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtJbnR9IHRvdGFsVGltZSAtIFRoZSB0b3RhbCB0aW1lIChpbiBtcykgdGhhdCBpdCB0b29rIHRvIGV4ZWN1dGUgdGhlIHN1aXRlXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtJbmNvbXBsZXRlUmVhc29ufSBpbmNvbXBsZXRlUmVhc29uIC0gRXhwbGFuYXRpb24gb2Ygd2h5IHRoZSBzdWl0ZSB3YXMgaW5jb21wbGV0ZS5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge09yZGVyfSBvcmRlciAtIEluZm9ybWF0aW9uIGFib3V0IHRoZSBvcmRlcmluZyAocmFuZG9tIG9yIG5vdCkgb2YgdGhpcyBleGVjdXRpb24gb2YgdGhlIHN1aXRlLlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7RXhwZWN0YXRpb25bXX0gZmFpbGVkRXhwZWN0YXRpb25zIC0gTGlzdCBvZiBleHBlY3RhdGlvbnMgdGhhdCBmYWlsZWQgaW4gYW4ge0BsaW5rIGFmdGVyQWxsfSBhdCB0aGUgZ2xvYmFsIGxldmVsLlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7RXhwZWN0YXRpb25bXX0gZGVwcmVjYXRpb25XYXJuaW5ncyAtIExpc3Qgb2YgZGVwcmVjYXRpb24gd2FybmluZ3MgdGhhdCBvY2N1cnJlZCBhdCB0aGUgZ2xvYmFsIGxldmVsLlxuICAgICAgICAgICAgICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IGphc21pbmVEb25lSW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgIG92ZXJhbGxTdGF0dXM6IG92ZXJhbGxTdGF0dXMsXG4gICAgICAgICAgICAgICAgICB0b3RhbFRpbWU6IGphc21pbmVUaW1lci5lbGFwc2VkKCksXG4gICAgICAgICAgICAgICAgICBpbmNvbXBsZXRlUmVhc29uOiBpbmNvbXBsZXRlUmVhc29uLFxuICAgICAgICAgICAgICAgICAgb3JkZXI6IG9yZGVyLFxuICAgICAgICAgICAgICAgICAgZmFpbGVkRXhwZWN0YXRpb25zOiB0b3BTdWl0ZS5yZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zLFxuICAgICAgICAgICAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5nczogdG9wU3VpdGUucmVzdWx0LmRlcHJlY2F0aW9uV2FybmluZ3NcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlcG9ydGVyLmphc21pbmVEb25lKGphc21pbmVEb25lSW5mbywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBkb25lKGphc21pbmVEb25lSW5mbyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGFzeW5jIGZ1bmN0aW9uIHJlcG9ydENoaWxkcmVuT2ZCZWZvcmVBbGxGYWlsdXJlKHN1aXRlKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygc3VpdGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBqJC5TdWl0ZSkge1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgICByZXBvcnRlci5zdWl0ZVN0YXJ0ZWQoY2hpbGQucmVzdWx0LCByZXNvbHZlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmVwb3J0Q2hpbGRyZW5PZkJlZm9yZUFsbEZhaWx1cmUoY2hpbGQpO1xuXG4gICAgICAgICAgICAvLyBNYXJraW5nIHRoZSBzdWl0ZSBwYXNzZWQgaXMgY29uc2lzdGVudCB3aXRoIGhvdyBzdWl0ZXMgdGhhdFxuICAgICAgICAgICAgLy8gY29udGFpbiBmYWlsZWQgc3BlY3MgYnV0IG5vIHN1aXRlLWxldmVsIGZhaWx1cmVzIGFyZSByZXBvcnRlZC5cbiAgICAgICAgICAgIGNoaWxkLnJlc3VsdC5zdGF0dXMgPSAncGFzc2VkJztcblxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgICByZXBvcnRlci5zdWl0ZURvbmUoY2hpbGQucmVzdWx0LCByZXNvbHZlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKiBhIHNwZWMgKi9cbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgcmVwb3J0ZXIuc3BlY1N0YXJ0ZWQoY2hpbGQucmVzdWx0LCByZXNvbHZlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjaGlsZC5hZGRFeHBlY3RhdGlvblJlc3VsdChcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwYXNzZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAgICAgICAnTm90IHJ1biBiZWNhdXNlIGEgYmVmb3JlQWxsIGZ1bmN0aW9uIGZhaWxlZC4gVGhlICcgK1xuICAgICAgICAgICAgICAgICAgJ2JlZm9yZUFsbCBmYWlsdXJlIHdpbGwgYmUgcmVwb3J0ZWQgb24gdGhlIHN1aXRlIHRoYXQgJyArXG4gICAgICAgICAgICAgICAgICAnY2F1c2VkIGl0LidcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNoaWxkLnJlc3VsdC5zdGF0dXMgPSAnZmFpbGVkJztcblxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgICByZXBvcnRlci5zcGVjRG9uZShjaGlsZC5yZXN1bHQsIHJlc29sdmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGN1c3RvbSByZXBvcnRlciB0byB0aGUgSmFzbWluZSBlbnZpcm9ubWVudC5cbiAgICAgKiBAbmFtZSBFbnYjYWRkUmVwb3J0ZXJcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1JlcG9ydGVyfSByZXBvcnRlclRvQWRkIFRoZSByZXBvcnRlciB0byBiZSBhZGRlZC5cbiAgICAgKiBAc2VlIGN1c3RvbV9yZXBvcnRlclxuICAgICAqL1xuICAgIHRoaXMuYWRkUmVwb3J0ZXIgPSBmdW5jdGlvbihyZXBvcnRlclRvQWRkKSB7XG4gICAgICByZXBvcnRlci5hZGRSZXBvcnRlcihyZXBvcnRlclRvQWRkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZSBhIGZhbGxiYWNrIHJlcG9ydGVyIGlmIG5vIG90aGVyIHJlcG9ydGVycyBoYXZlIGJlZW4gc3BlY2lmaWVkLlxuICAgICAqIEBuYW1lIEVudiNwcm92aWRlRmFsbGJhY2tSZXBvcnRlclxuICAgICAqIEBzaW5jZSAyLjUuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7UmVwb3J0ZXJ9IHJlcG9ydGVyVG9BZGQgVGhlIHJlcG9ydGVyXG4gICAgICogQHNlZSBjdXN0b21fcmVwb3J0ZXJcbiAgICAgKi9cbiAgICB0aGlzLnByb3ZpZGVGYWxsYmFja1JlcG9ydGVyID0gZnVuY3Rpb24ocmVwb3J0ZXJUb0FkZCkge1xuICAgICAgcmVwb3J0ZXIucHJvdmlkZUZhbGxiYWNrUmVwb3J0ZXIocmVwb3J0ZXJUb0FkZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCByZWdpc3RlcmVkIHJlcG9ydGVyc1xuICAgICAqIEBuYW1lIEVudiNjbGVhclJlcG9ydGVyc1xuICAgICAqIEBzaW5jZSAyLjUuMlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIHRoaXMuY2xlYXJSZXBvcnRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJlcG9ydGVyLmNsZWFyUmVwb3J0ZXJzKCk7XG4gICAgfTtcblxuICAgIHZhciBzcHlGYWN0b3J5ID0gbmV3IGokLlNweUZhY3RvcnkoXG4gICAgICBmdW5jdGlvbiBnZXRDdXN0b21TdHJhdGVnaWVzKCkge1xuICAgICAgICB2YXIgcnVubmFibGUgPSBjdXJyZW50UnVubmFibGUoKTtcblxuICAgICAgICBpZiAocnVubmFibGUpIHtcbiAgICAgICAgICByZXR1cm4gcnVubmFibGVSZXNvdXJjZXNbcnVubmFibGUuaWRdLmN1c3RvbVNweVN0cmF0ZWdpZXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge307XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gZ2V0RGVmYXVsdFN0cmF0ZWd5Rm4oKSB7XG4gICAgICAgIHZhciBydW5uYWJsZSA9IGN1cnJlbnRSdW5uYWJsZSgpO1xuXG4gICAgICAgIGlmIChydW5uYWJsZSkge1xuICAgICAgICAgIHJldHVybiBydW5uYWJsZVJlc291cmNlc1tydW5uYWJsZS5pZF0uZGVmYXVsdFN0cmF0ZWd5Rm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSxcbiAgICAgIG1ha2VNYXRjaGVyc1V0aWxcbiAgICApO1xuXG4gICAgdmFyIHNweVJlZ2lzdHJ5ID0gbmV3IGokLlNweVJlZ2lzdHJ5KHtcbiAgICAgIGN1cnJlbnRTcGllczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghY3VycmVudFJ1bm5hYmxlKCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnU3BpZXMgbXVzdCBiZSBjcmVhdGVkIGluIGEgYmVmb3JlIGZ1bmN0aW9uIG9yIGEgc3BlYydcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW5uYWJsZVJlc291cmNlc1tjdXJyZW50UnVubmFibGUoKS5pZF0uc3BpZXM7XG4gICAgICB9LFxuICAgICAgY3JlYXRlU3B5OiBmdW5jdGlvbihuYW1lLCBvcmlnaW5hbEZuKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmNyZWF0ZVNweShuYW1lLCBvcmlnaW5hbEZuKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgd2hldGhlciBKYXNtaW5lIHNob3VsZCBhbGxvdyB0aGUgc2FtZSBmdW5jdGlvbiB0byBiZSBzcGllZCBvblxuICAgICAqIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgZXhlY3V0aW9uIG9mIGEgc3BlYy4gQnkgZGVmYXVsdCwgc3B5aW5nIG9uXG4gICAgICogYSBmdW5jdGlvbiB0aGF0IGlzIGFscmVhZHkgYSBzcHkgd2lsbCBjYXVzZSBhbiBlcnJvci5cbiAgICAgKiBAbmFtZSBFbnYjYWxsb3dSZXNweVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBzaW5jZSAyLjUuMFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYWxsb3cgV2hldGhlciB0byBhbGxvdyByZXNweWluZ1xuICAgICAqL1xuICAgIHRoaXMuYWxsb3dSZXNweSA9IGZ1bmN0aW9uKGFsbG93KSB7XG4gICAgICBzcHlSZWdpc3RyeS5hbGxvd1Jlc3B5KGFsbG93KTtcbiAgICB9O1xuXG4gICAgdGhpcy5zcHlPbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNweVJlZ2lzdHJ5LnNweU9uLmFwcGx5KHNweVJlZ2lzdHJ5LCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICB0aGlzLnNweU9uUHJvcGVydHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzcHlSZWdpc3RyeS5zcHlPblByb3BlcnR5LmFwcGx5KHNweVJlZ2lzdHJ5LCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICB0aGlzLnNweU9uQWxsRnVuY3Rpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3B5UmVnaXN0cnkuc3B5T25BbGxGdW5jdGlvbnMuYXBwbHkoc3B5UmVnaXN0cnksIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIHRoaXMuY3JlYXRlU3B5ID0gZnVuY3Rpb24obmFtZSwgb3JpZ2luYWxGbikge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgaiQuaXNGdW5jdGlvbl8obmFtZSkpIHtcbiAgICAgICAgb3JpZ2luYWxGbiA9IG5hbWU7XG4gICAgICAgIG5hbWUgPSBvcmlnaW5hbEZuLm5hbWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzcHlGYWN0b3J5LmNyZWF0ZVNweShuYW1lLCBvcmlnaW5hbEZuKTtcbiAgICB9O1xuXG4gICAgdGhpcy5jcmVhdGVTcHlPYmogPSBmdW5jdGlvbihiYXNlTmFtZSwgbWV0aG9kTmFtZXMsIHByb3BlcnR5TmFtZXMpIHtcbiAgICAgIHJldHVybiBzcHlGYWN0b3J5LmNyZWF0ZVNweU9iaihiYXNlTmFtZSwgbWV0aG9kTmFtZXMsIHByb3BlcnR5TmFtZXMpO1xuICAgIH07XG5cbiAgICB2YXIgZW5zdXJlSXNGdW5jdGlvbiA9IGZ1bmN0aW9uKGZuLCBjYWxsZXIpIHtcbiAgICAgIGlmICghaiQuaXNGdW5jdGlvbl8oZm4pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBjYWxsZXIgKyAnIGV4cGVjdHMgYSBmdW5jdGlvbiBhcmd1bWVudDsgcmVjZWl2ZWQgJyArIGokLmdldFR5cGVfKGZuKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZW5zdXJlSXNGdW5jdGlvbk9yQXN5bmMgPSBmdW5jdGlvbihmbiwgY2FsbGVyKSB7XG4gICAgICBpZiAoIWokLmlzRnVuY3Rpb25fKGZuKSAmJiAhaiQuaXNBc3luY0Z1bmN0aW9uXyhmbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGNhbGxlciArICcgZXhwZWN0cyBhIGZ1bmN0aW9uIGFyZ3VtZW50OyByZWNlaXZlZCAnICsgaiQuZ2V0VHlwZV8oZm4pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGVuc3VyZUlzTm90TmVzdGVkKG1ldGhvZCkge1xuICAgICAgdmFyIHJ1bm5hYmxlID0gY3VycmVudFJ1bm5hYmxlKCk7XG4gICAgICBpZiAocnVubmFibGUgIT09IG51bGwgJiYgcnVubmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCInXCIgKyBtZXRob2QgKyBcIicgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbiAnZGVzY3JpYmUnIGZ1bmN0aW9uXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3VpdGVGYWN0b3J5ID0gZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcbiAgICAgIHZhciBzdWl0ZSA9IG5ldyBqJC5TdWl0ZSh7XG4gICAgICAgIGlkOiBnZXROZXh0U3VpdGVJZCgpLFxuICAgICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gICAgICAgIHBhcmVudFN1aXRlOiBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZSxcbiAgICAgICAgdGltZXI6IG5ldyBqJC5UaW1lcigpLFxuICAgICAgICBleHBlY3RhdGlvbkZhY3Rvcnk6IGV4cGVjdGF0aW9uRmFjdG9yeSxcbiAgICAgICAgYXN5bmNFeHBlY3RhdGlvbkZhY3Rvcnk6IHN1aXRlQXN5bmNFeHBlY3RhdGlvbkZhY3RvcnksXG4gICAgICAgIGV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeTogZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5LFxuICAgICAgICB0aHJvd09uRXhwZWN0YXRpb25GYWlsdXJlOiBjb25maWcuc3RvcFNwZWNPbkV4cGVjdGF0aW9uRmFpbHVyZSxcbiAgICAgICAgYXV0b0NsZWFuQ2xvc3VyZXM6IGNvbmZpZy5hdXRvQ2xlYW5DbG9zdXJlcyxcbiAgICAgICAgb25MYXRlRXJyb3I6IHJlY29yZExhdGVFcnJvclxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBzdWl0ZTtcbiAgICB9O1xuXG4gICAgdGhpcy5kZXNjcmliZSA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uLCBzcGVjRGVmaW5pdGlvbnMpIHtcbiAgICAgIGVuc3VyZUlzTm90TmVzdGVkKCdkZXNjcmliZScpO1xuICAgICAgZW5zdXJlSXNGdW5jdGlvbihzcGVjRGVmaW5pdGlvbnMsICdkZXNjcmliZScpO1xuICAgICAgdmFyIHN1aXRlID0gc3VpdGVGYWN0b3J5KGRlc2NyaXB0aW9uKTtcbiAgICAgIGlmIChzcGVjRGVmaW5pdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rlc2NyaWJlIGRvZXMgbm90IGV4cGVjdCBhbnkgYXJndW1lbnRzJyk7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudERlY2xhcmF0aW9uU3VpdGUubWFya2VkRXhjbHVkaW5nKSB7XG4gICAgICAgIHN1aXRlLmV4Y2x1ZGUoKTtcbiAgICAgIH1cbiAgICAgIGFkZFNwZWNzVG9TdWl0ZShzdWl0ZSwgc3BlY0RlZmluaXRpb25zKTtcbiAgICAgIGlmIChzdWl0ZS5wYXJlbnRTdWl0ZSAmJiAhc3VpdGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGVzY3JpYmUgd2l0aCBubyBjaGlsZHJlbiAoZGVzY3JpYmUoKSBvciBpdCgpKScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1aXRlLm1ldGFkYXRhO1xuICAgIH07XG5cbiAgICB0aGlzLnhkZXNjcmliZSA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uLCBzcGVjRGVmaW5pdGlvbnMpIHtcbiAgICAgIGVuc3VyZUlzTm90TmVzdGVkKCd4ZGVzY3JpYmUnKTtcbiAgICAgIGVuc3VyZUlzRnVuY3Rpb24oc3BlY0RlZmluaXRpb25zLCAneGRlc2NyaWJlJyk7XG4gICAgICB2YXIgc3VpdGUgPSBzdWl0ZUZhY3RvcnkoZGVzY3JpcHRpb24pO1xuICAgICAgc3VpdGUuZXhjbHVkZSgpO1xuICAgICAgYWRkU3BlY3NUb1N1aXRlKHN1aXRlLCBzcGVjRGVmaW5pdGlvbnMpO1xuICAgICAgcmV0dXJuIHN1aXRlLm1ldGFkYXRhO1xuICAgIH07XG5cbiAgICB2YXIgZm9jdXNlZFJ1bm5hYmxlcyA9IFtdO1xuXG4gICAgdGhpcy5mZGVzY3JpYmUgPSBmdW5jdGlvbihkZXNjcmlwdGlvbiwgc3BlY0RlZmluaXRpb25zKSB7XG4gICAgICBlbnN1cmVJc05vdE5lc3RlZCgnZmRlc2NyaWJlJyk7XG4gICAgICBlbnN1cmVJc0Z1bmN0aW9uKHNwZWNEZWZpbml0aW9ucywgJ2ZkZXNjcmliZScpO1xuICAgICAgdmFyIHN1aXRlID0gc3VpdGVGYWN0b3J5KGRlc2NyaXB0aW9uKTtcbiAgICAgIHN1aXRlLmlzRm9jdXNlZCA9IHRydWU7XG5cbiAgICAgIGZvY3VzZWRSdW5uYWJsZXMucHVzaChzdWl0ZS5pZCk7XG4gICAgICB1bmZvY3VzQW5jZXN0b3IoKTtcbiAgICAgIGFkZFNwZWNzVG9TdWl0ZShzdWl0ZSwgc3BlY0RlZmluaXRpb25zKTtcblxuICAgICAgcmV0dXJuIHN1aXRlLm1ldGFkYXRhO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBhZGRTcGVjc1RvU3VpdGUoc3VpdGUsIHNwZWNEZWZpbml0aW9ucykge1xuICAgICAgdmFyIHBhcmVudFN1aXRlID0gY3VycmVudERlY2xhcmF0aW9uU3VpdGU7XG4gICAgICBwYXJlbnRTdWl0ZS5hZGRDaGlsZChzdWl0ZSk7XG4gICAgICBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZSA9IHN1aXRlO1xuXG4gICAgICB2YXIgZGVjbGFyYXRpb25FcnJvciA9IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICBzcGVjRGVmaW5pdGlvbnMoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZGVjbGFyYXRpb25FcnJvciA9IGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWNsYXJhdGlvbkVycm9yKSB7XG4gICAgICAgIHN1aXRlLm9uRXhjZXB0aW9uKGRlY2xhcmF0aW9uRXJyb3IpO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZSA9IHBhcmVudFN1aXRlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmRGb2N1c2VkQW5jZXN0b3Ioc3VpdGUpIHtcbiAgICAgIHdoaWxlIChzdWl0ZSkge1xuICAgICAgICBpZiAoc3VpdGUuaXNGb2N1c2VkKSB7XG4gICAgICAgICAgcmV0dXJuIHN1aXRlLmlkO1xuICAgICAgICB9XG4gICAgICAgIHN1aXRlID0gc3VpdGUucGFyZW50U3VpdGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuZm9jdXNBbmNlc3RvcigpIHtcbiAgICAgIHZhciBmb2N1c2VkQW5jZXN0b3IgPSBmaW5kRm9jdXNlZEFuY2VzdG9yKGN1cnJlbnREZWNsYXJhdGlvblN1aXRlKTtcbiAgICAgIGlmIChmb2N1c2VkQW5jZXN0b3IpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb2N1c2VkUnVubmFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGZvY3VzZWRSdW5uYWJsZXNbaV0gPT09IGZvY3VzZWRBbmNlc3Rvcikge1xuICAgICAgICAgICAgZm9jdXNlZFJ1bm5hYmxlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3BlY0ZhY3RvcnkgPSBmdW5jdGlvbihkZXNjcmlwdGlvbiwgZm4sIHN1aXRlLCB0aW1lb3V0KSB7XG4gICAgICB0b3RhbFNwZWNzRGVmaW5lZCsrO1xuICAgICAgdmFyIHNwZWMgPSBuZXcgaiQuU3BlYyh7XG4gICAgICAgIGlkOiBnZXROZXh0U3BlY0lkKCksXG4gICAgICAgIGJlZm9yZUFuZEFmdGVyRm5zOiBiZWZvcmVBbmRBZnRlckZucyhzdWl0ZSksXG4gICAgICAgIGV4cGVjdGF0aW9uRmFjdG9yeTogZXhwZWN0YXRpb25GYWN0b3J5LFxuICAgICAgICBhc3luY0V4cGVjdGF0aW9uRmFjdG9yeTogc3BlY0FzeW5jRXhwZWN0YXRpb25GYWN0b3J5LFxuICAgICAgICBvbkxhdGVFcnJvcjogcmVjb3JkTGF0ZUVycm9yLFxuICAgICAgICByZXN1bHRDYWxsYmFjazogc3BlY1Jlc3VsdENhbGxiYWNrLFxuICAgICAgICBnZXRTcGVjTmFtZTogZnVuY3Rpb24oc3BlYykge1xuICAgICAgICAgIHJldHVybiBnZXRTcGVjTmFtZShzcGVjLCBzdWl0ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU3RhcnQ6IHNwZWNTdGFydGVkLFxuICAgICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gICAgICAgIGV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeTogZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5LFxuICAgICAgICBxdWV1ZVJ1bm5lckZhY3Rvcnk6IHF1ZXVlUnVubmVyRmFjdG9yeSxcbiAgICAgICAgdXNlckNvbnRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzdWl0ZS5jbG9uZWRTaGFyZWRVc2VyQ29udGV4dCgpO1xuICAgICAgICB9LFxuICAgICAgICBxdWV1ZWFibGVGbjoge1xuICAgICAgICAgIGZuOiBmbixcbiAgICAgICAgICB0aW1lb3V0OiB0aW1lb3V0IHx8IDBcbiAgICAgICAgfSxcbiAgICAgICAgdGhyb3dPbkV4cGVjdGF0aW9uRmFpbHVyZTogY29uZmlnLnN0b3BTcGVjT25FeHBlY3RhdGlvbkZhaWx1cmUsXG4gICAgICAgIGF1dG9DbGVhbkNsb3N1cmVzOiBjb25maWcuYXV0b0NsZWFuQ2xvc3VyZXMsXG4gICAgICAgIHRpbWVyOiBuZXcgaiQuVGltZXIoKVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc3BlYztcblxuICAgICAgZnVuY3Rpb24gc3BlY1Jlc3VsdENhbGxiYWNrKHJlc3VsdCwgbmV4dCkge1xuICAgICAgICBjbGVhclJlc291cmNlc0ZvclJ1bm5hYmxlKHNwZWMuaWQpO1xuICAgICAgICBjdXJyZW50U3BlYyA9IG51bGw7XG5cbiAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgICAgaGFzRmFpbHVyZXMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVwb3J0ZXIuc3BlY0RvbmUocmVzdWx0LCBuZXh0KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc3BlY1N0YXJ0ZWQoc3BlYywgbmV4dCkge1xuICAgICAgICBjdXJyZW50U3BlYyA9IHNwZWM7XG4gICAgICAgIGRlZmF1bHRSZXNvdXJjZXNGb3JSdW5uYWJsZShzcGVjLmlkLCBzdWl0ZS5pZCk7XG4gICAgICAgIHJlcG9ydGVyLnNwZWNTdGFydGVkKHNwZWMucmVzdWx0LCBuZXh0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5pdF8gPSBmdW5jdGlvbihkZXNjcmlwdGlvbiwgZm4sIHRpbWVvdXQpIHtcbiAgICAgIGVuc3VyZUlzTm90TmVzdGVkKCdpdCcpO1xuICAgICAgLy8gaXQoKSBzb21ldGltZXMgZG9lc24ndCBoYXZlIGEgZm4gYXJndW1lbnQsIHNvIG9ubHkgY2hlY2sgdGhlIHR5cGUgaWZcbiAgICAgIC8vIGl0J3MgZ2l2ZW4uXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIGZuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBlbnN1cmVJc0Z1bmN0aW9uT3JBc3luYyhmbiwgJ2l0Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgIGokLnV0aWwudmFsaWRhdGVUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3BlYyA9IHNwZWNGYWN0b3J5KGRlc2NyaXB0aW9uLCBmbiwgY3VycmVudERlY2xhcmF0aW9uU3VpdGUsIHRpbWVvdXQpO1xuICAgICAgaWYgKGN1cnJlbnREZWNsYXJhdGlvblN1aXRlLm1hcmtlZEV4Y2x1ZGluZykge1xuICAgICAgICBzcGVjLmV4Y2x1ZGUoKTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnREZWNsYXJhdGlvblN1aXRlLmFkZENoaWxkKHNwZWMpO1xuXG4gICAgICByZXR1cm4gc3BlYztcbiAgICB9O1xuXG4gICAgdGhpcy5pdCA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uLCBmbiwgdGltZW91dCkge1xuICAgICAgY29uc3Qgc3BlYyA9IHRoaXMuaXRfKGRlc2NyaXB0aW9uLCBmbiwgdGltZW91dCk7XG4gICAgICByZXR1cm4gc3BlYy5tZXRhZGF0YTtcbiAgICB9O1xuXG4gICAgdGhpcy54aXQgPSBmdW5jdGlvbihkZXNjcmlwdGlvbiwgZm4sIHRpbWVvdXQpIHtcbiAgICAgIGVuc3VyZUlzTm90TmVzdGVkKCd4aXQnKTtcbiAgICAgIC8vIHhpdCgpLCBsaWtlIGl0KCksIGRvZXNuJ3QgYWx3YXlzIGhhdmUgYSBmbiBhcmd1bWVudCwgc28gb25seSBjaGVjayB0aGVcbiAgICAgIC8vIHR5cGUgd2hlbiBuZWVkZWQuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIGZuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBlbnN1cmVJc0Z1bmN0aW9uT3JBc3luYyhmbiwgJ3hpdCcpO1xuICAgICAgfVxuICAgICAgdmFyIHNwZWMgPSB0aGlzLml0Xy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgc3BlYy5leGNsdWRlKCdUZW1wb3JhcmlseSBkaXNhYmxlZCB3aXRoIHhpdCcpO1xuICAgICAgcmV0dXJuIHNwZWMubWV0YWRhdGE7XG4gICAgfTtcblxuICAgIHRoaXMuZml0ID0gZnVuY3Rpb24oZGVzY3JpcHRpb24sIGZuLCB0aW1lb3V0KSB7XG4gICAgICBlbnN1cmVJc05vdE5lc3RlZCgnZml0Jyk7XG4gICAgICBlbnN1cmVJc0Z1bmN0aW9uT3JBc3luYyhmbiwgJ2ZpdCcpO1xuXG4gICAgICBpZiAodGltZW91dCkge1xuICAgICAgICBqJC51dGlsLnZhbGlkYXRlVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIHZhciBzcGVjID0gc3BlY0ZhY3RvcnkoZGVzY3JpcHRpb24sIGZuLCBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZSwgdGltZW91dCk7XG4gICAgICBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZS5hZGRDaGlsZChzcGVjKTtcbiAgICAgIGZvY3VzZWRSdW5uYWJsZXMucHVzaChzcGVjLmlkKTtcbiAgICAgIHVuZm9jdXNBbmNlc3RvcigpO1xuICAgICAgcmV0dXJuIHNwZWMubWV0YWRhdGE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgYSB1c2VyLWRlZmluZWQgcHJvcGVydHkgdGhhdCB3aWxsIGJlIHByb3ZpZGVkIHRvIHJlcG9ydGVycyBhcyBwYXJ0IG9mIHRoZSBwcm9wZXJ0aWVzIGZpZWxkIG9mIHtAbGluayBTcGVjUmVzdWx0fVxuICAgICAqIEBuYW1lIEVudiNzZXRTcGVjUHJvcGVydHlcbiAgICAgKiBAc2luY2UgMy42LjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAqL1xuICAgIHRoaXMuc2V0U3BlY1Byb3BlcnR5ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKCFjdXJyZW50UnVubmFibGUoKSB8fCBjdXJyZW50UnVubmFibGUoKSA9PSBjdXJyZW50U3VpdGUoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCInc2V0U3BlY1Byb3BlcnR5JyB3YXMgdXNlZCB3aGVuIHRoZXJlIHdhcyBubyBjdXJyZW50IHNwZWNcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY3VycmVudFJ1bm5hYmxlKCkuc2V0U3BlY1Byb3BlcnR5KGtleSwgdmFsdWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgdXNlci1kZWZpbmVkIHByb3BlcnR5IHRoYXQgd2lsbCBiZSBwcm92aWRlZCB0byByZXBvcnRlcnMgYXMgcGFydCBvZiB0aGUgcHJvcGVydGllcyBmaWVsZCBvZiB7QGxpbmsgU3VpdGVSZXN1bHR9XG4gICAgICogQG5hbWUgRW52I3NldFN1aXRlUHJvcGVydHlcbiAgICAgKiBAc2luY2UgMy42LjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAqL1xuICAgIHRoaXMuc2V0U3VpdGVQcm9wZXJ0eSA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICghY3VycmVudFN1aXRlKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiJ3NldFN1aXRlUHJvcGVydHknIHdhcyB1c2VkIHdoZW4gdGhlcmUgd2FzIG5vIGN1cnJlbnQgc3VpdGVcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY3VycmVudFN1aXRlKCkuc2V0U3VpdGVQcm9wZXJ0eShrZXksIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgdGhpcy5kZWJ1Z0xvZyA9IGZ1bmN0aW9uKG1zZykge1xuICAgICAgdmFyIG1heWJlU3BlYyA9IGN1cnJlbnRSdW5uYWJsZSgpO1xuXG4gICAgICBpZiAoIW1heWJlU3BlYyB8fCAhbWF5YmVTcGVjLmRlYnVnTG9nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIidkZWJ1Z0xvZycgd2FzIGNhbGxlZCB3aGVuIHRoZXJlIHdhcyBubyBjdXJyZW50IHNwZWNcIik7XG4gICAgICB9XG5cbiAgICAgIG1heWJlU3BlYy5kZWJ1Z0xvZyhtc2cpO1xuICAgIH07XG5cbiAgICB0aGlzLmV4cGVjdCA9IGZ1bmN0aW9uKGFjdHVhbCkge1xuICAgICAgaWYgKCFjdXJyZW50UnVubmFibGUoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCInZXhwZWN0JyB3YXMgdXNlZCB3aGVuIHRoZXJlIHdhcyBubyBjdXJyZW50IHNwZWMsIHRoaXMgY291bGQgYmUgYmVjYXVzZSBhbiBhc3luY2hyb25vdXMgdGVzdCB0aW1lZCBvdXRcIlxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3VycmVudFJ1bm5hYmxlKCkuZXhwZWN0KGFjdHVhbCk7XG4gICAgfTtcblxuICAgIHRoaXMuZXhwZWN0QXN5bmMgPSBmdW5jdGlvbihhY3R1YWwpIHtcbiAgICAgIGlmICghY3VycmVudFJ1bm5hYmxlKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiJ2V4cGVjdEFzeW5jJyB3YXMgdXNlZCB3aGVuIHRoZXJlIHdhcyBubyBjdXJyZW50IHNwZWMsIHRoaXMgY291bGQgYmUgYmVjYXVzZSBhbiBhc3luY2hyb25vdXMgdGVzdCB0aW1lZCBvdXRcIlxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3VycmVudFJ1bm5hYmxlKCkuZXhwZWN0QXN5bmMoYWN0dWFsKTtcbiAgICB9O1xuXG4gICAgdGhpcy5iZWZvcmVFYWNoID0gZnVuY3Rpb24oYmVmb3JlRWFjaEZ1bmN0aW9uLCB0aW1lb3V0KSB7XG4gICAgICBlbnN1cmVJc05vdE5lc3RlZCgnYmVmb3JlRWFjaCcpO1xuICAgICAgZW5zdXJlSXNGdW5jdGlvbk9yQXN5bmMoYmVmb3JlRWFjaEZ1bmN0aW9uLCAnYmVmb3JlRWFjaCcpO1xuXG4gICAgICBpZiAodGltZW91dCkge1xuICAgICAgICBqJC51dGlsLnZhbGlkYXRlVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudERlY2xhcmF0aW9uU3VpdGUuYmVmb3JlRWFjaCh7XG4gICAgICAgIGZuOiBiZWZvcmVFYWNoRnVuY3Rpb24sXG4gICAgICAgIHRpbWVvdXQ6IHRpbWVvdXQgfHwgMFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMuYmVmb3JlQWxsID0gZnVuY3Rpb24oYmVmb3JlQWxsRnVuY3Rpb24sIHRpbWVvdXQpIHtcbiAgICAgIGVuc3VyZUlzTm90TmVzdGVkKCdiZWZvcmVBbGwnKTtcbiAgICAgIGVuc3VyZUlzRnVuY3Rpb25PckFzeW5jKGJlZm9yZUFsbEZ1bmN0aW9uLCAnYmVmb3JlQWxsJyk7XG5cbiAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgIGokLnV0aWwudmFsaWRhdGVUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZS5iZWZvcmVBbGwoe1xuICAgICAgICBmbjogYmVmb3JlQWxsRnVuY3Rpb24sXG4gICAgICAgIHRpbWVvdXQ6IHRpbWVvdXQgfHwgMFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMuYWZ0ZXJFYWNoID0gZnVuY3Rpb24oYWZ0ZXJFYWNoRnVuY3Rpb24sIHRpbWVvdXQpIHtcbiAgICAgIGVuc3VyZUlzTm90TmVzdGVkKCdhZnRlckVhY2gnKTtcbiAgICAgIGVuc3VyZUlzRnVuY3Rpb25PckFzeW5jKGFmdGVyRWFjaEZ1bmN0aW9uLCAnYWZ0ZXJFYWNoJyk7XG5cbiAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgIGokLnV0aWwudmFsaWRhdGVUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgfVxuXG4gICAgICBhZnRlckVhY2hGdW5jdGlvbi5pc0NsZWFudXAgPSB0cnVlO1xuICAgICAgY3VycmVudERlY2xhcmF0aW9uU3VpdGUuYWZ0ZXJFYWNoKHtcbiAgICAgICAgZm46IGFmdGVyRWFjaEZ1bmN0aW9uLFxuICAgICAgICB0aW1lb3V0OiB0aW1lb3V0IHx8IDBcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLmFmdGVyQWxsID0gZnVuY3Rpb24oYWZ0ZXJBbGxGdW5jdGlvbiwgdGltZW91dCkge1xuICAgICAgZW5zdXJlSXNOb3ROZXN0ZWQoJ2FmdGVyQWxsJyk7XG4gICAgICBlbnN1cmVJc0Z1bmN0aW9uT3JBc3luYyhhZnRlckFsbEZ1bmN0aW9uLCAnYWZ0ZXJBbGwnKTtcblxuICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgaiQudXRpbC52YWxpZGF0ZVRpbWVvdXQodGltZW91dCk7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnREZWNsYXJhdGlvblN1aXRlLmFmdGVyQWxsKHtcbiAgICAgICAgZm46IGFmdGVyQWxsRnVuY3Rpb24sXG4gICAgICAgIHRpbWVvdXQ6IHRpbWVvdXQgfHwgMFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMucGVuZGluZyA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgIHZhciBmdWxsTWVzc2FnZSA9IGokLlNwZWMucGVuZGluZ1NwZWNFeGNlcHRpb25NZXNzYWdlO1xuICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgZnVsbE1lc3NhZ2UgKz0gbWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIHRocm93IGZ1bGxNZXNzYWdlO1xuICAgIH07XG5cbiAgICB0aGlzLmZhaWwgPSBmdW5jdGlvbihlcnJvcikge1xuICAgICAgaWYgKCFjdXJyZW50UnVubmFibGUoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCInZmFpbCcgd2FzIHVzZWQgd2hlbiB0aGVyZSB3YXMgbm8gY3VycmVudCBzcGVjLCB0aGlzIGNvdWxkIGJlIGJlY2F1c2UgYW4gYXN5bmNocm9ub3VzIHRlc3QgdGltZWQgb3V0XCJcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1lc3NhZ2UgPSAnRmFpbGVkJztcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBtZXNzYWdlICs9ICc6ICc7XG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlKSB7XG4gICAgICAgICAgbWVzc2FnZSArPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICB9IGVsc2UgaWYgKGokLmlzU3RyaW5nXyhlcnJvcikpIHtcbiAgICAgICAgICBtZXNzYWdlICs9IGVycm9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHByZXR0eSBwcmludCBhbGwga2luZCBvZiBvYmplY3RzLiBUaGlzIGluY2x1ZGVzIGFycmF5cy5cbiAgICAgICAgICBtZXNzYWdlICs9IG1ha2VQcmV0dHlQcmludGVyKCkoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRSdW5uYWJsZSgpLmFkZEV4cGVjdGF0aW9uUmVzdWx0KGZhbHNlLCB7XG4gICAgICAgIG1hdGNoZXJOYW1lOiAnJyxcbiAgICAgICAgcGFzc2VkOiBmYWxzZSxcbiAgICAgICAgZXhwZWN0ZWQ6ICcnLFxuICAgICAgICBhY3R1YWw6ICcnLFxuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICBlcnJvcjogZXJyb3IgJiYgZXJyb3IubWVzc2FnZSA/IGVycm9yIDogbnVsbFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChjb25maWcuc3RvcFNwZWNPbkV4cGVjdGF0aW9uRmFpbHVyZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuY2xlYW51cF8gPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChnbG9iYWxFcnJvcnMpIHtcbiAgICAgICAgZ2xvYmFsRXJyb3JzLnVuaW5zdGFsbCgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gRW52O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5Kc0FwaVJlcG9ydGVyID0gZnVuY3Rpb24oaiQpIHtcbiAgLyoqXG4gICAqIEBuYW1lIGpzQXBpUmVwb3J0ZXJcbiAgICogQGNsYXNzZGVzYyB7QGxpbmsgUmVwb3J0ZXJ9IGFkZGVkIGJ5IGRlZmF1bHQgaW4gYGJvb3QuanNgIHRvIHJlY29yZCByZXN1bHRzIGZvciByZXRyaWV2YWwgaW4gamF2YXNjcmlwdCBjb2RlLiBBbiBpbnN0YW5jZSBpcyBtYWRlIGF2YWlsYWJsZSBhcyBganNBcGlSZXBvcnRlcmAgb24gdGhlIGdsb2JhbCBvYmplY3QuXG4gICAqIEBjbGFzc1xuICAgKiBAaGlkZWNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBKc0FwaVJlcG9ydGVyKG9wdGlvbnMpIHtcbiAgICB2YXIgdGltZXIgPSBvcHRpb25zLnRpbWVyIHx8IG5ldyBqJC5UaW1lcigpLFxuICAgICAgc3RhdHVzID0gJ2xvYWRlZCc7XG5cbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5ydW5EZXRhaWxzID0ge307XG5cbiAgICB0aGlzLmphc21pbmVTdGFydGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgc3RhdHVzID0gJ3N0YXJ0ZWQnO1xuICAgICAgdGltZXIuc3RhcnQoKTtcbiAgICB9O1xuXG4gICAgdmFyIGV4ZWN1dGlvblRpbWU7XG5cbiAgICB0aGlzLmphc21pbmVEb25lID0gZnVuY3Rpb24ocnVuRGV0YWlscykge1xuICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICB0aGlzLnJ1bkRldGFpbHMgPSBydW5EZXRhaWxzO1xuICAgICAgZXhlY3V0aW9uVGltZSA9IHRpbWVyLmVsYXBzZWQoKTtcbiAgICAgIHN0YXR1cyA9ICdkb25lJztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHN0YXR1cyBmb3IgdGhlIEphc21pbmUgZW52aXJvbm1lbnQuXG4gICAgICogQG5hbWUganNBcGlSZXBvcnRlciNzdGF0dXNcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IC0gT25lIG9mIGBsb2FkZWRgLCBgc3RhcnRlZGAsIG9yIGBkb25lYFxuICAgICAqL1xuICAgIHRoaXMuc3RhdHVzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH07XG5cbiAgICB2YXIgc3VpdGVzID0gW10sXG4gICAgICBzdWl0ZXNfaGFzaCA9IHt9O1xuXG4gICAgdGhpcy5zdWl0ZVN0YXJ0ZWQgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIHN1aXRlc19oYXNoW3Jlc3VsdC5pZF0gPSByZXN1bHQ7XG4gICAgfTtcblxuICAgIHRoaXMuc3VpdGVEb25lID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICBzdG9yZVN1aXRlKHJlc3VsdCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcmVzdWx0cyBmb3IgYSBzZXQgb2Ygc3VpdGVzLlxuICAgICAqXG4gICAgICogUmV0cmlldmFibGUgaW4gc2xpY2VzIGZvciBlYXNpZXIgc2VyaWFsaXphdGlvbi5cbiAgICAgKiBAbmFtZSBqc0FwaVJlcG9ydGVyI3N1aXRlUmVzdWx0c1xuICAgICAqIEBzaW5jZSAyLjEuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSBwb3NpdGlvbiBpbiB0aGUgc3VpdGVzIGxpc3QgdG8gc3RhcnQgZnJvbS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIC0gTWF4aW11bSBudW1iZXIgb2Ygc3VpdGUgcmVzdWx0cyB0byByZXR1cm4uXG4gICAgICogQHJldHVybiB7U3VpdGVSZXN1bHRbXX1cbiAgICAgKi9cbiAgICB0aGlzLnN1aXRlUmVzdWx0cyA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIHJldHVybiBzdWl0ZXMuc2xpY2UoaW5kZXgsIGluZGV4ICsgbGVuZ3RoKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gc3RvcmVTdWl0ZShyZXN1bHQpIHtcbiAgICAgIHN1aXRlcy5wdXNoKHJlc3VsdCk7XG4gICAgICBzdWl0ZXNfaGFzaFtyZXN1bHQuaWRdID0gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgb2YgdGhlIHN1aXRlcyBpbiBhIHNpbmdsZSBvYmplY3QsIHdpdGggdGhlaXIgYGlkYCBhcyB0aGUga2V5LlxuICAgICAqIEBuYW1lIGpzQXBpUmVwb3J0ZXIjc3VpdGVzXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAtIE1hcCBvZiBzdWl0ZSBpZCB0byB7QGxpbmsgU3VpdGVSZXN1bHR9XG4gICAgICovXG4gICAgdGhpcy5zdWl0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdWl0ZXNfaGFzaDtcbiAgICB9O1xuXG4gICAgdmFyIHNwZWNzID0gW107XG5cbiAgICB0aGlzLnNwZWNEb25lID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICBzcGVjcy5wdXNoKHJlc3VsdCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcmVzdWx0cyBmb3IgYSBzZXQgb2Ygc3BlY3MuXG4gICAgICpcbiAgICAgKiBSZXRyaWV2YWJsZSBpbiBzbGljZXMgZm9yIGVhc2llciBzZXJpYWxpemF0aW9uLlxuICAgICAqIEBuYW1lIGpzQXBpUmVwb3J0ZXIjc3BlY1Jlc3VsdHNcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBUaGUgcG9zaXRpb24gaW4gdGhlIHNwZWNzIGxpc3QgdG8gc3RhcnQgZnJvbS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIC0gTWF4aW11bSBudW1iZXIgb2Ygc3BlY3MgcmVzdWx0cyB0byByZXR1cm4uXG4gICAgICogQHJldHVybiB7U3BlY1Jlc3VsdFtdfVxuICAgICAqL1xuICAgIHRoaXMuc3BlY1Jlc3VsdHMgPSBmdW5jdGlvbihpbmRleCwgbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gc3BlY3Muc2xpY2UoaW5kZXgsIGluZGV4ICsgbGVuZ3RoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBzcGVjIHJlc3VsdHMuXG4gICAgICogQG5hbWUganNBcGlSZXBvcnRlciNzcGVjc1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge1NwZWNSZXN1bHRbXX1cbiAgICAgKi9cbiAgICB0aGlzLnNwZWNzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3BlY3M7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZnVsbCBKYXNtaW5lIHN1aXRlIHRvIHJ1bi5cbiAgICAgKiBAbmFtZSBqc0FwaVJlcG9ydGVyI2V4ZWN1dGlvblRpbWVcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5leGVjdXRpb25UaW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhlY3V0aW9uVGltZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIEpzQXBpUmVwb3J0ZXI7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkFueSA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIEFueShleHBlY3RlZE9iamVjdCkge1xuICAgIGlmICh0eXBlb2YgZXhwZWN0ZWRPYmplY3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnamFzbWluZS5hbnkoKSBleHBlY3RzIHRvIGJlIHBhc3NlZCBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLiAnICtcbiAgICAgICAgICAnUGxlYXNlIHBhc3Mgb25lIG9yIHVzZSBqYXNtaW5lLmFueXRoaW5nKCkgdG8gbWF0Y2ggYW55IG9iamVjdC4nXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmV4cGVjdGVkT2JqZWN0ID0gZXhwZWN0ZWRPYmplY3Q7XG4gIH1cblxuICBBbnkucHJvdG90eXBlLmFzeW1tZXRyaWNNYXRjaCA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgaWYgKHRoaXMuZXhwZWN0ZWRPYmplY3QgPT0gU3RyaW5nKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG90aGVyID09ICdzdHJpbmcnIHx8IG90aGVyIGluc3RhbmNlb2YgU3RyaW5nO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmV4cGVjdGVkT2JqZWN0ID09IE51bWJlcikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvdGhlciA9PSAnbnVtYmVyJyB8fCBvdGhlciBpbnN0YW5jZW9mIE51bWJlcjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5leHBlY3RlZE9iamVjdCA9PSBGdW5jdGlvbikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvdGhlciA9PSAnZnVuY3Rpb24nIHx8IG90aGVyIGluc3RhbmNlb2YgRnVuY3Rpb247XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZXhwZWN0ZWRPYmplY3QgPT0gT2JqZWN0KSB7XG4gICAgICByZXR1cm4gb3RoZXIgIT09IG51bGwgJiYgdHlwZW9mIG90aGVyID09ICdvYmplY3QnO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmV4cGVjdGVkT2JqZWN0ID09IEJvb2xlYW4pIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb3RoZXIgPT0gJ2Jvb2xlYW4nO1xuICAgIH1cblxuICAgIC8qIGpzaGludCAtVzEyMiAqL1xuICAgIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgICBpZiAodHlwZW9mIFN5bWJvbCAhPSAndW5kZWZpbmVkJyAmJiB0aGlzLmV4cGVjdGVkT2JqZWN0ID09IFN5bWJvbCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvdGhlciA9PSAnc3ltYm9sJztcbiAgICB9XG4gICAgLyoganNoaW50ICtXMTIyICovXG5cbiAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiB0aGlzLmV4cGVjdGVkT2JqZWN0O1xuICB9O1xuXG4gIEFueS5wcm90b3R5cGUuamFzbWluZVRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICc8amFzbWluZS5hbnkoJyArIGokLmZuTmFtZUZvcih0aGlzLmV4cGVjdGVkT2JqZWN0KSArICcpPic7XG4gIH07XG5cbiAgcmV0dXJuIEFueTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuQW55dGhpbmcgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBBbnl0aGluZygpIHt9XG5cbiAgQW55dGhpbmcucHJvdG90eXBlLmFzeW1tZXRyaWNNYXRjaCA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgcmV0dXJuICFqJC51dGlsLmlzVW5kZWZpbmVkKG90aGVyKSAmJiBvdGhlciAhPT0gbnVsbDtcbiAgfTtcblxuICBBbnl0aGluZy5wcm90b3R5cGUuamFzbWluZVRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICc8amFzbWluZS5hbnl0aGluZz4nO1xuICB9O1xuXG4gIHJldHVybiBBbnl0aGluZztcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuQXJyYXlDb250YWluaW5nID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gQXJyYXlDb250YWluaW5nKHNhbXBsZSkge1xuICAgIHRoaXMuc2FtcGxlID0gc2FtcGxlO1xuICB9XG5cbiAgQXJyYXlDb250YWluaW5nLnByb3RvdHlwZS5hc3ltbWV0cmljTWF0Y2ggPSBmdW5jdGlvbihvdGhlciwgbWF0Y2hlcnNVdGlsKSB7XG4gICAgaWYgKCFqJC5pc0FycmF5Xyh0aGlzLnNhbXBsZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1lvdSBtdXN0IHByb3ZpZGUgYW4gYXJyYXkgdG8gYXJyYXlDb250YWluaW5nLCBub3QgJyArXG4gICAgICAgICAgaiQuYmFzaWNQcmV0dHlQcmludGVyXyh0aGlzLnNhbXBsZSkgK1xuICAgICAgICAgICcuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgYWN0dWFsIHBhcmFtZXRlciBpcyBub3QgYW4gYXJyYXksIHdlIGNhbiBmYWlsIGltbWVkaWF0ZWx5LCBzaW5jZSBpdCBjb3VsZG4ndFxuICAgIC8vIHBvc3NpYmx5IGJlIGFuIFwiYXJyYXkgY29udGFpbmluZ1wiIGFueXRoaW5nLiBIb3dldmVyLCB3ZSBhbHNvIHdhbnQgYW4gZW1wdHkgc2FtcGxlXG4gICAgLy8gYXJyYXkgdG8gbWF0Y2ggYW55dGhpbmcsIHNvIHdlIG5lZWQgdG8gZG91YmxlLWNoZWNrIHdlIGFyZW4ndCBpbiB0aGF0IGNhc2VcbiAgICBpZiAoIWokLmlzQXJyYXlfKG90aGVyKSAmJiB0aGlzLnNhbXBsZS5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNhbXBsZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSB0aGlzLnNhbXBsZVtpXTtcbiAgICAgIGlmICghbWF0Y2hlcnNVdGlsLmNvbnRhaW5zKG90aGVyLCBpdGVtKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgQXJyYXlDb250YWluaW5nLnByb3RvdHlwZS5qYXNtaW5lVG9TdHJpbmcgPSBmdW5jdGlvbihwcCkge1xuICAgIHJldHVybiAnPGphc21pbmUuYXJyYXlDb250YWluaW5nKCcgKyBwcCh0aGlzLnNhbXBsZSkgKyAnKT4nO1xuICB9O1xuXG4gIHJldHVybiBBcnJheUNvbnRhaW5pbmc7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkFycmF5V2l0aEV4YWN0Q29udGVudHMgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBBcnJheVdpdGhFeGFjdENvbnRlbnRzKHNhbXBsZSkge1xuICAgIHRoaXMuc2FtcGxlID0gc2FtcGxlO1xuICB9XG5cbiAgQXJyYXlXaXRoRXhhY3RDb250ZW50cy5wcm90b3R5cGUuYXN5bW1ldHJpY01hdGNoID0gZnVuY3Rpb24oXG4gICAgb3RoZXIsXG4gICAgbWF0Y2hlcnNVdGlsXG4gICkge1xuICAgIGlmICghaiQuaXNBcnJheV8odGhpcy5zYW1wbGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdZb3UgbXVzdCBwcm92aWRlIGFuIGFycmF5IHRvIGFycmF5V2l0aEV4YWN0Q29udGVudHMsIG5vdCAnICtcbiAgICAgICAgICBqJC5iYXNpY1ByZXR0eVByaW50ZXJfKHRoaXMuc2FtcGxlKSArXG4gICAgICAgICAgJy4nXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNhbXBsZS5sZW5ndGggIT09IG90aGVyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zYW1wbGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gdGhpcy5zYW1wbGVbaV07XG4gICAgICBpZiAoIW1hdGNoZXJzVXRpbC5jb250YWlucyhvdGhlciwgaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIEFycmF5V2l0aEV4YWN0Q29udGVudHMucHJvdG90eXBlLmphc21pbmVUb1N0cmluZyA9IGZ1bmN0aW9uKHBwKSB7XG4gICAgcmV0dXJuICc8amFzbWluZS5hcnJheVdpdGhFeGFjdENvbnRlbnRzKCcgKyBwcCh0aGlzLnNhbXBsZSkgKyAnKT4nO1xuICB9O1xuXG4gIHJldHVybiBBcnJheVdpdGhFeGFjdENvbnRlbnRzO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5FbXB0eSA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIEVtcHR5KCkge31cblxuICBFbXB0eS5wcm90b3R5cGUuYXN5bW1ldHJpY01hdGNoID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICBpZiAoaiQuaXNTdHJpbmdfKG90aGVyKSB8fCBqJC5pc0FycmF5XyhvdGhlcikgfHwgaiQuaXNUeXBlZEFycmF5XyhvdGhlcikpIHtcbiAgICAgIHJldHVybiBvdGhlci5sZW5ndGggPT09IDA7XG4gICAgfVxuXG4gICAgaWYgKGokLmlzTWFwKG90aGVyKSB8fCBqJC5pc1NldChvdGhlcikpIHtcbiAgICAgIHJldHVybiBvdGhlci5zaXplID09PSAwO1xuICAgIH1cblxuICAgIGlmIChqJC5pc09iamVjdF8ob3RoZXIpKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMob3RoZXIpLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIEVtcHR5LnByb3RvdHlwZS5qYXNtaW5lVG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJzxqYXNtaW5lLmVtcHR5Pic7XG4gIH07XG5cbiAgcmV0dXJuIEVtcHR5O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5GYWxzeSA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIEZhbHN5KCkge31cblxuICBGYWxzeS5wcm90b3R5cGUuYXN5bW1ldHJpY01hdGNoID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICByZXR1cm4gIW90aGVyO1xuICB9O1xuXG4gIEZhbHN5LnByb3RvdHlwZS5qYXNtaW5lVG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJzxqYXNtaW5lLmZhbHN5Pic7XG4gIH07XG5cbiAgcmV0dXJuIEZhbHN5O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5NYXBDb250YWluaW5nID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gTWFwQ29udGFpbmluZyhzYW1wbGUpIHtcbiAgICBpZiAoIWokLmlzTWFwKHNhbXBsZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1lvdSBtdXN0IHByb3ZpZGUgYSBtYXAgdG8gYG1hcENvbnRhaW5pbmdgLCBub3QgJyArXG4gICAgICAgICAgaiQuYmFzaWNQcmV0dHlQcmludGVyXyhzYW1wbGUpXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuc2FtcGxlID0gc2FtcGxlO1xuICB9XG5cbiAgTWFwQ29udGFpbmluZy5wcm90b3R5cGUuYXN5bW1ldHJpY01hdGNoID0gZnVuY3Rpb24ob3RoZXIsIG1hdGNoZXJzVXRpbCkge1xuICAgIGlmICghaiQuaXNNYXAob3RoZXIpKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLnNhbXBsZSkge1xuICAgICAgLy8gZm9yIGVhY2gga2V5L3ZhbHVlIHBhaXIgaW4gYHNhbXBsZWBcbiAgICAgIC8vIHRoZXJlIHNob3VsZCBiZSBhdCBsZWFzdCBvbmUgcGFpciBpbiBgb3RoZXJgIHdob3NlIGtleSBhbmQgdmFsdWUgYm90aCBtYXRjaFxuICAgICAgdmFyIGhhc01hdGNoID0gZmFsc2U7XG4gICAgICBmb3IgKGNvbnN0IFtvS2V5LCBvVmFsdWVdIG9mIG90aGVyKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBtYXRjaGVyc1V0aWwuZXF1YWxzKG9LZXksIGtleSkgJiZcbiAgICAgICAgICBtYXRjaGVyc1V0aWwuZXF1YWxzKG9WYWx1ZSwgdmFsdWUpXG4gICAgICAgICkge1xuICAgICAgICAgIGhhc01hdGNoID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWhhc01hdGNoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBNYXBDb250YWluaW5nLnByb3RvdHlwZS5qYXNtaW5lVG9TdHJpbmcgPSBmdW5jdGlvbihwcCkge1xuICAgIHJldHVybiAnPGphc21pbmUubWFwQ29udGFpbmluZygnICsgcHAodGhpcy5zYW1wbGUpICsgJyk+JztcbiAgfTtcblxuICByZXR1cm4gTWFwQ29udGFpbmluZztcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuTm90RW1wdHkgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBOb3RFbXB0eSgpIHt9XG5cbiAgTm90RW1wdHkucHJvdG90eXBlLmFzeW1tZXRyaWNNYXRjaCA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgaWYgKGokLmlzU3RyaW5nXyhvdGhlcikgfHwgaiQuaXNBcnJheV8ob3RoZXIpIHx8IGokLmlzVHlwZWRBcnJheV8ob3RoZXIpKSB7XG4gICAgICByZXR1cm4gb3RoZXIubGVuZ3RoICE9PSAwO1xuICAgIH1cblxuICAgIGlmIChqJC5pc01hcChvdGhlcikgfHwgaiQuaXNTZXQob3RoZXIpKSB7XG4gICAgICByZXR1cm4gb3RoZXIuc2l6ZSAhPT0gMDtcbiAgICB9XG5cbiAgICBpZiAoaiQuaXNPYmplY3RfKG90aGVyKSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG90aGVyKS5sZW5ndGggIT09IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIE5vdEVtcHR5LnByb3RvdHlwZS5qYXNtaW5lVG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJzxqYXNtaW5lLm5vdEVtcHR5Pic7XG4gIH07XG5cbiAgcmV0dXJuIE5vdEVtcHR5O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5PYmplY3RDb250YWluaW5nID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gT2JqZWN0Q29udGFpbmluZyhzYW1wbGUpIHtcbiAgICB0aGlzLnNhbXBsZSA9IHNhbXBsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc1Byb3BlcnR5KG9iaiwgcHJvcGVydHkpIHtcbiAgICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wZXJ0eSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBoYXNQcm9wZXJ0eShPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSwgcHJvcGVydHkpO1xuICB9XG5cbiAgT2JqZWN0Q29udGFpbmluZy5wcm90b3R5cGUuYXN5bW1ldHJpY01hdGNoID0gZnVuY3Rpb24ob3RoZXIsIG1hdGNoZXJzVXRpbCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5zYW1wbGUgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiWW91IG11c3QgcHJvdmlkZSBhbiBvYmplY3QgdG8gb2JqZWN0Q29udGFpbmluZywgbm90ICdcIiArXG4gICAgICAgICAgdGhpcy5zYW1wbGUgK1xuICAgICAgICAgIFwiJy5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvdGhlciAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzLnNhbXBsZSkge1xuICAgICAgaWYgKFxuICAgICAgICAhaGFzUHJvcGVydHkob3RoZXIsIHByb3BlcnR5KSB8fFxuICAgICAgICAhbWF0Y2hlcnNVdGlsLmVxdWFscyh0aGlzLnNhbXBsZVtwcm9wZXJ0eV0sIG90aGVyW3Byb3BlcnR5XSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgT2JqZWN0Q29udGFpbmluZy5wcm90b3R5cGUudmFsdWVzRm9yRGlmZl8gPSBmdW5jdGlvbihvdGhlciwgcHApIHtcbiAgICBpZiAoIWokLmlzT2JqZWN0XyhvdGhlcikpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlbGY6IHRoaXMuamFzbWluZVRvU3RyaW5nKHBwKSxcbiAgICAgICAgb3RoZXI6IG90aGVyXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBmaWx0ZXJlZE90aGVyID0ge307XG4gICAgT2JqZWN0LmtleXModGhpcy5zYW1wbGUpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgLy8gZXEgc2hvcnQtY2lyY3VpdHMgY29tcGFyaXNvbiBvZiBvYmplY3RzIHRoYXQgaGF2ZSBkaWZmZXJlbnQga2V5IHNldHMsXG4gICAgICAvLyBzbyBpbmNsdWRlIGFsbCBrZXlzIGV2ZW4gaWYgdW5kZWZpbmVkLlxuICAgICAgZmlsdGVyZWRPdGhlcltrXSA9IG90aGVyW2tdO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbGY6IHRoaXMuc2FtcGxlLFxuICAgICAgb3RoZXI6IGZpbHRlcmVkT3RoZXJcbiAgICB9O1xuICB9O1xuXG4gIE9iamVjdENvbnRhaW5pbmcucHJvdG90eXBlLmphc21pbmVUb1N0cmluZyA9IGZ1bmN0aW9uKHBwKSB7XG4gICAgcmV0dXJuICc8amFzbWluZS5vYmplY3RDb250YWluaW5nKCcgKyBwcCh0aGlzLnNhbXBsZSkgKyAnKT4nO1xuICB9O1xuXG4gIHJldHVybiBPYmplY3RDb250YWluaW5nO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5TZXRDb250YWluaW5nID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gU2V0Q29udGFpbmluZyhzYW1wbGUpIHtcbiAgICBpZiAoIWokLmlzU2V0KHNhbXBsZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1lvdSBtdXN0IHByb3ZpZGUgYSBzZXQgdG8gYHNldENvbnRhaW5pbmdgLCBub3QgJyArXG4gICAgICAgICAgaiQuYmFzaWNQcmV0dHlQcmludGVyXyhzYW1wbGUpXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuc2FtcGxlID0gc2FtcGxlO1xuICB9XG5cbiAgU2V0Q29udGFpbmluZy5wcm90b3R5cGUuYXN5bW1ldHJpY01hdGNoID0gZnVuY3Rpb24ob3RoZXIsIG1hdGNoZXJzVXRpbCkge1xuICAgIGlmICghaiQuaXNTZXQob3RoZXIpKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5zYW1wbGUpIHtcbiAgICAgIC8vIGZvciBlYWNoIGl0ZW0gaW4gYHNhbXBsZWAgdGhlcmUgc2hvdWxkIGJlIGF0IGxlYXN0IG9uZSBtYXRjaGluZyBpdGVtIGluIGBvdGhlcmBcbiAgICAgIC8vIChub3QgdXNpbmcgYG1hdGNoZXJzVXRpbC5jb250YWluc2AgYmVjYXVzZSBpdCBjb21wYXJlcyBzZXQgbWVtYmVycyBieSByZWZlcmVuY2UsXG4gICAgICAvLyBub3QgYnkgZGVlcCB2YWx1ZSBlcXVhbGl0eSlcbiAgICAgIHZhciBoYXNNYXRjaCA9IGZhbHNlO1xuICAgICAgZm9yIChjb25zdCBvSXRlbSBvZiBvdGhlcikge1xuICAgICAgICBpZiAobWF0Y2hlcnNVdGlsLmVxdWFscyhvSXRlbSwgaXRlbSkpIHtcbiAgICAgICAgICBoYXNNYXRjaCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFoYXNNYXRjaCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgU2V0Q29udGFpbmluZy5wcm90b3R5cGUuamFzbWluZVRvU3RyaW5nID0gZnVuY3Rpb24ocHApIHtcbiAgICByZXR1cm4gJzxqYXNtaW5lLnNldENvbnRhaW5pbmcoJyArIHBwKHRoaXMuc2FtcGxlKSArICcpPic7XG4gIH07XG5cbiAgcmV0dXJuIFNldENvbnRhaW5pbmc7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlN0cmluZ0NvbnRhaW5pbmcgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBTdHJpbmdDb250YWluaW5nKGV4cGVjdGVkKSB7XG4gICAgaWYgKCFqJC5pc1N0cmluZ18oZXhwZWN0ZWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGlzIG5vdCBhIFN0cmluZycpO1xuICAgIH1cblxuICAgIHRoaXMuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgfVxuXG4gIFN0cmluZ0NvbnRhaW5pbmcucHJvdG90eXBlLmFzeW1tZXRyaWNNYXRjaCA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgaWYgKCFqJC5pc1N0cmluZ18ob3RoZXIpKSB7XG4gICAgICAvLyBBcnJheXMsIGV0Yy4gZG9uJ3QgbWF0Y2ggbm8gbWF0dGVyIHdoYXQgdGhlaXIgaW5kZXhPZiByZXR1cm5zLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBvdGhlci5pbmRleE9mKHRoaXMuZXhwZWN0ZWQpICE9PSAtMTtcbiAgfTtcblxuICBTdHJpbmdDb250YWluaW5nLnByb3RvdHlwZS5qYXNtaW5lVG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJzxqYXNtaW5lLnN0cmluZ0NvbnRhaW5pbmcoXCInICsgdGhpcy5leHBlY3RlZCArICdcIik+JztcbiAgfTtcblxuICByZXR1cm4gU3RyaW5nQ29udGFpbmluZztcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuU3RyaW5nTWF0Y2hpbmcgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBTdHJpbmdNYXRjaGluZyhleHBlY3RlZCkge1xuICAgIGlmICghaiQuaXNTdHJpbmdfKGV4cGVjdGVkKSAmJiAhaiQuaXNBXygnUmVnRXhwJywgZXhwZWN0ZWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGlzIG5vdCBhIFN0cmluZyBvciBhIFJlZ0V4cCcpO1xuICAgIH1cblxuICAgIHRoaXMucmVnZXhwID0gbmV3IFJlZ0V4cChleHBlY3RlZCk7XG4gIH1cblxuICBTdHJpbmdNYXRjaGluZy5wcm90b3R5cGUuYXN5bW1ldHJpY01hdGNoID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5yZWdleHAudGVzdChvdGhlcik7XG4gIH07XG5cbiAgU3RyaW5nTWF0Y2hpbmcucHJvdG90eXBlLmphc21pbmVUb1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnPGphc21pbmUuc3RyaW5nTWF0Y2hpbmcoJyArIHRoaXMucmVnZXhwICsgJyk+JztcbiAgfTtcblxuICByZXR1cm4gU3RyaW5nTWF0Y2hpbmc7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlRydXRoeSA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIFRydXRoeSgpIHt9XG5cbiAgVHJ1dGh5LnByb3RvdHlwZS5hc3ltbWV0cmljTWF0Y2ggPSBmdW5jdGlvbihvdGhlcikge1xuICAgIHJldHVybiAhIW90aGVyO1xuICB9O1xuXG4gIFRydXRoeS5wcm90b3R5cGUuamFzbWluZVRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICc8amFzbWluZS50cnV0aHk+JztcbiAgfTtcblxuICByZXR1cm4gVHJ1dGh5O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5DYWxsVHJhY2tlciA9IGZ1bmN0aW9uKGokKSB7XG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlIFNweSNjYWxsc1xuICAgKiBAc2luY2UgMi4wLjBcbiAgICovXG4gIGZ1bmN0aW9uIENhbGxUcmFja2VyKCkge1xuICAgIHZhciBjYWxscyA9IFtdO1xuICAgIHZhciBvcHRzID0ge307XG5cbiAgICB0aGlzLnRyYWNrID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgaWYgKG9wdHMuY2xvbmVBcmdzKSB7XG4gICAgICAgIGNvbnRleHQuYXJncyA9IGokLnV0aWwuY2xvbmVBcmdzKGNvbnRleHQuYXJncyk7XG4gICAgICB9XG4gICAgICBjYWxscy5wdXNoKGNvbnRleHQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoaXMgc3B5IGhhcyBiZWVuIGludm9rZWQuXG4gICAgICogQG5hbWUgU3B5I2NhbGxzI2FueVxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5hbnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhIWNhbGxzLmxlbmd0aDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBudW1iZXIgb2YgaW52b2NhdGlvbnMgb2YgdGhpcyBzcHkuXG4gICAgICogQG5hbWUgU3B5I2NhbGxzI2NvdW50XG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7SW50ZWdlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY2FsbHMubGVuZ3RoO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGFyZ3VtZW50cyB0aGF0IHdlcmUgcGFzc2VkIHRvIGEgc3BlY2lmaWMgaW52b2NhdGlvbiBvZiB0aGlzIHNweS5cbiAgICAgKiBAbmFtZSBTcHkjY2FsbHMjYXJnc0ZvclxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gaW5kZXggVGhlIDAtYmFzZWQgaW52b2NhdGlvbiBpbmRleC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmFyZ3NGb3IgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgdmFyIGNhbGwgPSBjYWxsc1tpbmRleF07XG4gICAgICByZXR1cm4gY2FsbCA/IGNhbGwuYXJncyA6IFtdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIFwidGhpc1wiIG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgdG8gYSBzcGVjaWZpYyBpbnZvY2F0aW9uIG9mIHRoaXMgc3B5LlxuICAgICAqIEBuYW1lIFNweSNjYWxscyN0aGlzRm9yXG4gICAgICogQHNpbmNlIDMuOC4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBpbmRleCBUaGUgMC1iYXNlZCBpbnZvY2F0aW9uIGluZGV4LlxuICAgICAqIEByZXR1cm4ge09iamVjdD99XG4gICAgICovXG4gICAgdGhpcy50aGlzRm9yID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIHZhciBjYWxsID0gY2FsbHNbaW5kZXhdO1xuICAgICAgcmV0dXJuIGNhbGwgPyBjYWxsLm9iamVjdCA6IHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSByYXcgY2FsbHMgYXJyYXkgZm9yIHRoaXMgc3B5LlxuICAgICAqIEBuYW1lIFNweSNjYWxscyNhbGxcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtTcHkuY2FsbERhdGFbXX1cbiAgICAgKi9cbiAgICB0aGlzLmFsbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNhbGxzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIG9mIHRoZSBhcmd1bWVudHMgZm9yIGVhY2ggaW52b2NhdGlvbiBvZiB0aGlzIHNweSBpbiB0aGUgb3JkZXIgdGhleSB3ZXJlIHJlY2VpdmVkLlxuICAgICAqIEBuYW1lIFNweSNjYWxscyNhbGxBcmdzXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5hbGxBcmdzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2FsbEFyZ3MgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEFyZ3MucHVzaChjYWxsc1tpXS5hcmdzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhbGxBcmdzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGZpcnN0IGludm9jYXRpb24gb2YgdGhpcyBzcHkuXG4gICAgICogQG5hbWUgU3B5I2NhbGxzI2ZpcnN0XG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7T2JqZWNTcHkuY2FsbERhdGF9XG4gICAgICovXG4gICAgdGhpcy5maXJzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNhbGxzWzBdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG1vc3QgcmVjZW50IGludm9jYXRpb24gb2YgdGhpcyBzcHkuXG4gICAgICogQG5hbWUgU3B5I2NhbGxzI21vc3RSZWNlbnRcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtPYmplY1NweS5jYWxsRGF0YX1cbiAgICAgKi9cbiAgICB0aGlzLm1vc3RSZWNlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjYWxsc1tjYWxscy5sZW5ndGggLSAxXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhpcyBzcHkgYXMgaWYgaXQgaGFzIG5ldmVyIGJlZW4gY2FsbGVkLlxuICAgICAqIEBuYW1lIFNweSNjYWxscyNyZXNldFxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIHRoaXMucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNhbGxzID0gW107XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGlzIHNweSB0byBkbyBhIHNoYWxsb3cgY2xvbmUgb2YgYXJndW1lbnRzIHBhc3NlZCB0byBlYWNoIGludm9jYXRpb24uXG4gICAgICogQG5hbWUgU3B5I2NhbGxzI3NhdmVBcmd1bWVudHNCeVZhbHVlXG4gICAgICogQHNpbmNlIDIuNS4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgdGhpcy5zYXZlQXJndW1lbnRzQnlWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgb3B0cy5jbG9uZUFyZ3MgPSB0cnVlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gQ2FsbFRyYWNrZXI7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLmNsZWFyU3RhY2sgPSBmdW5jdGlvbihqJCkge1xuICB2YXIgbWF4SW5saW5lQ2FsbENvdW50ID0gMTA7XG5cbiAgZnVuY3Rpb24gbWVzc2FnZUNoYW5uZWxJbXBsKGdsb2JhbCwgc2V0VGltZW91dCkge1xuICAgIHZhciBjaGFubmVsID0gbmV3IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCgpLFxuICAgICAgaGVhZCA9IHt9LFxuICAgICAgdGFpbCA9IGhlYWQ7XG5cbiAgICB2YXIgdGFza1J1bm5pbmcgPSBmYWxzZTtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIHZhciB0YXNrID0gaGVhZC50YXNrO1xuICAgICAgZGVsZXRlIGhlYWQudGFzaztcblxuICAgICAgaWYgKHRhc2tSdW5uaW5nKSB7XG4gICAgICAgIGdsb2JhbC5zZXRUaW1lb3V0KHRhc2ssIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0YXNrUnVubmluZyA9IHRydWU7XG4gICAgICAgICAgdGFzaygpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRhc2tSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGN1cnJlbnRDYWxsQ291bnQgPSAwO1xuICAgIHJldHVybiBmdW5jdGlvbiBjbGVhclN0YWNrKGZuKSB7XG4gICAgICBjdXJyZW50Q2FsbENvdW50Kys7XG5cbiAgICAgIGlmIChjdXJyZW50Q2FsbENvdW50IDwgbWF4SW5saW5lQ2FsbENvdW50KSB7XG4gICAgICAgIHRhaWwgPSB0YWlsLm5leHQgPSB7IHRhc2s6IGZuIH07XG4gICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50Q2FsbENvdW50ID0gMDtcbiAgICAgICAgc2V0VGltZW91dChmbik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENsZWFyU3RhY2soZ2xvYmFsKSB7XG4gICAgdmFyIGN1cnJlbnRDYWxsQ291bnQgPSAwO1xuICAgIHZhciByZWFsU2V0VGltZW91dCA9IGdsb2JhbC5zZXRUaW1lb3V0O1xuICAgIHZhciBzZXRUaW1lb3V0SW1wbCA9IGZ1bmN0aW9uIGNsZWFyU3RhY2soZm4pIHtcbiAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShyZWFsU2V0VGltZW91dCwgW2dsb2JhbCwgW2ZuLCAwXV0pO1xuICAgIH07XG5cbiAgICBpZiAoaiQuaXNGdW5jdGlvbl8oZ2xvYmFsLnNldEltbWVkaWF0ZSkpIHtcbiAgICAgIHZhciByZWFsU2V0SW1tZWRpYXRlID0gZ2xvYmFsLnNldEltbWVkaWF0ZTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihmbikge1xuICAgICAgICBjdXJyZW50Q2FsbENvdW50Kys7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRDYWxsQ291bnQgPCBtYXhJbmxpbmVDYWxsQ291bnQpIHtcbiAgICAgICAgICByZWFsU2V0SW1tZWRpYXRlKGZuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50Q2FsbENvdW50ID0gMDtcblxuICAgICAgICAgIHNldFRpbWVvdXRJbXBsKGZuKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCFqJC51dGlsLmlzVW5kZWZpbmVkKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkpIHtcbiAgICAgIHJldHVybiBtZXNzYWdlQ2hhbm5lbEltcGwoZ2xvYmFsLCBzZXRUaW1lb3V0SW1wbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0SW1wbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZ2V0Q2xlYXJTdGFjaztcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuQ2xvY2sgPSBmdW5jdGlvbigpIHtcbiAgLyogZ2xvYmFsIHByb2Nlc3MgKi9cbiAgdmFyIE5PREVfSlMgPVxuICAgIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHByb2Nlc3MudmVyc2lvbnMgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlID09PSAnc3RyaW5nJztcblxuICAvKipcbiAgICogQGNsYXNzIENsb2NrXG4gICAqIEBzaW5jZSAxLjMuMFxuICAgKiBAY2xhc3NkZXNjIEphc21pbmUncyBtb2NrIGNsb2NrIGlzIHVzZWQgd2hlbiB0ZXN0aW5nIHRpbWUgZGVwZW5kZW50IGNvZGUuPGJyPlxuICAgKiBfTm90ZTpfIERvIG5vdCBjb25zdHJ1Y3QgdGhpcyBkaXJlY3RseS4gWW91IGNhbiBnZXQgdGhlIGN1cnJlbnQgY2xvY2sgd2l0aFxuICAgKiB7QGxpbmsgamFzbWluZS5jbG9ja30uXG4gICAqIEBoaWRlY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIENsb2NrKGdsb2JhbCwgZGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyRmFjdG9yeSwgbW9ja0RhdGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICByZWFsVGltaW5nRnVuY3Rpb25zID0ge1xuICAgICAgICBzZXRUaW1lb3V0OiBnbG9iYWwuc2V0VGltZW91dCxcbiAgICAgICAgY2xlYXJUaW1lb3V0OiBnbG9iYWwuY2xlYXJUaW1lb3V0LFxuICAgICAgICBzZXRJbnRlcnZhbDogZ2xvYmFsLnNldEludGVydmFsLFxuICAgICAgICBjbGVhckludGVydmFsOiBnbG9iYWwuY2xlYXJJbnRlcnZhbFxuICAgICAgfSxcbiAgICAgIGZha2VUaW1pbmdGdW5jdGlvbnMgPSB7XG4gICAgICAgIHNldFRpbWVvdXQ6IHNldFRpbWVvdXQsXG4gICAgICAgIGNsZWFyVGltZW91dDogY2xlYXJUaW1lb3V0LFxuICAgICAgICBzZXRJbnRlcnZhbDogc2V0SW50ZXJ2YWwsXG4gICAgICAgIGNsZWFySW50ZXJ2YWw6IGNsZWFySW50ZXJ2YWxcbiAgICAgIH0sXG4gICAgICBpbnN0YWxsZWQgPSBmYWxzZSxcbiAgICAgIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlcixcbiAgICAgIHRpbWVyO1xuXG4gICAgc2VsZi5GYWtlVGltZW91dCA9IEZha2VUaW1lb3V0O1xuXG4gICAgLyoqXG4gICAgICogSW5zdGFsbCB0aGUgbW9jayBjbG9jayBvdmVyIHRoZSBidWlsdC1pbiBtZXRob2RzLlxuICAgICAqIEBuYW1lIENsb2NrI2luc3RhbGxcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtDbG9ja31cbiAgICAgKi9cbiAgICBzZWxmLmluc3RhbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghb3JpZ2luYWxUaW1pbmdGdW5jdGlvbnNJbnRhY3QoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0phc21pbmUgQ2xvY2sgd2FzIHVuYWJsZSB0byBpbnN0YWxsIG92ZXIgY3VzdG9tIGdsb2JhbCB0aW1lciBmdW5jdGlvbnMuIElzIHRoZSBjbG9jayBhbHJlYWR5IGluc3RhbGxlZD8nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXBsYWNlKGdsb2JhbCwgZmFrZVRpbWluZ0Z1bmN0aW9ucyk7XG4gICAgICB0aW1lciA9IGZha2VUaW1pbmdGdW5jdGlvbnM7XG4gICAgICBkZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIgPSBkZWxheWVkRnVuY3Rpb25TY2hlZHVsZXJGYWN0b3J5KCk7XG4gICAgICBpbnN0YWxsZWQgPSB0cnVlO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVW5pbnN0YWxsIHRoZSBtb2NrIGNsb2NrLCByZXR1cm5pbmcgdGhlIGJ1aWx0LWluIG1ldGhvZHMgdG8gdGhlaXIgcGxhY2VzLlxuICAgICAqIEBuYW1lIENsb2NrI3VuaW5zdGFsbFxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIHNlbGYudW5pbnN0YWxsID0gZnVuY3Rpb24oKSB7XG4gICAgICBkZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIgPSBudWxsO1xuICAgICAgbW9ja0RhdGUudW5pbnN0YWxsKCk7XG4gICAgICByZXBsYWNlKGdsb2JhbCwgcmVhbFRpbWluZ0Z1bmN0aW9ucyk7XG5cbiAgICAgIHRpbWVyID0gcmVhbFRpbWluZ0Z1bmN0aW9ucztcbiAgICAgIGluc3RhbGxlZCA9IGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIGEgZnVuY3Rpb24gd2l0aCBhIG1vY2tlZCBDbG9ja1xuICAgICAqXG4gICAgICogVGhlIGNsb2NrIHdpbGwgYmUge0BsaW5rIENsb2NrI2luc3RhbGx8aW5zdGFsbH1lZCBiZWZvcmUgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBhbmQge0BsaW5rIENsb2NrI3VuaW5zdGFsbHx1bmluc3RhbGx9ZWQgaW4gYSBgZmluYWxseWAgYWZ0ZXIgdGhlIGZ1bmN0aW9uIGNvbXBsZXRlcy5cbiAgICAgKiBAbmFtZSBDbG9jayN3aXRoTW9ja1xuICAgICAqIEBzaW5jZSAyLjMuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNsb3N1cmUgVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZC5cbiAgICAgKi9cbiAgICBzZWxmLndpdGhNb2NrID0gZnVuY3Rpb24oY2xvc3VyZSkge1xuICAgICAgdGhpcy5pbnN0YWxsKCk7XG4gICAgICB0cnkge1xuICAgICAgICBjbG9zdXJlKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLnVuaW5zdGFsbCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnN0cnVjdCB0aGUgaW5zdGFsbGVkIENsb2NrIHRvIGFsc28gbW9jayB0aGUgZGF0ZSByZXR1cm5lZCBieSBgbmV3IERhdGUoKWBcbiAgICAgKiBAbmFtZSBDbG9jayNtb2NrRGF0ZVxuICAgICAqIEBzaW5jZSAyLjEuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RGF0ZX0gW2luaXRpYWxEYXRlPW5vd10gVGhlIGBEYXRlYCB0byBwcm92aWRlLlxuICAgICAqL1xuICAgIHNlbGYubW9ja0RhdGUgPSBmdW5jdGlvbihpbml0aWFsRGF0ZSkge1xuICAgICAgbW9ja0RhdGUuaW5zdGFsbChpbml0aWFsRGF0ZSk7XG4gICAgfTtcblxuICAgIHNlbGYuc2V0VGltZW91dCA9IGZ1bmN0aW9uKGZuLCBkZWxheSwgcGFyYW1zKSB7XG4gICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KHRpbWVyLnNldFRpbWVvdXQsIFtcbiAgICAgICAgZ2xvYmFsLFxuICAgICAgICBhcmd1bWVudHNcbiAgICAgIF0pO1xuICAgIH07XG5cbiAgICBzZWxmLnNldEludGVydmFsID0gZnVuY3Rpb24oZm4sIGRlbGF5LCBwYXJhbXMpIHtcbiAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkodGltZXIuc2V0SW50ZXJ2YWwsIFtcbiAgICAgICAgZ2xvYmFsLFxuICAgICAgICBhcmd1bWVudHNcbiAgICAgIF0pO1xuICAgIH07XG5cbiAgICBzZWxmLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYXBwbHkodGltZXIuY2xlYXJUaW1lb3V0LCBbZ2xvYmFsLCBpZF0pO1xuICAgIH07XG5cbiAgICBzZWxmLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbihpZCkge1xuICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLmFwcGx5KHRpbWVyLmNsZWFySW50ZXJ2YWwsIFtnbG9iYWwsIGlkXSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRpY2sgdGhlIENsb2NrIGZvcndhcmQsIHJ1bm5pbmcgYW55IGVucXVldWVkIHRpbWVvdXRzIGFsb25nIHRoZSB3YXlcbiAgICAgKiBAbmFtZSBDbG9jayN0aWNrXG4gICAgICogQHNpbmNlIDEuMy4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtpbnR9IG1pbGxpcyBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aWNrLlxuICAgICAqL1xuICAgIHNlbGYudGljayA9IGZ1bmN0aW9uKG1pbGxpcykge1xuICAgICAgaWYgKGluc3RhbGxlZCkge1xuICAgICAgICBkZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIudGljayhtaWxsaXMsIGZ1bmN0aW9uKG1pbGxpcykge1xuICAgICAgICAgIG1vY2tEYXRlLnRpY2sobWlsbGlzKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ01vY2sgY2xvY2sgaXMgbm90IGluc3RhbGxlZCwgdXNlIGphc21pbmUuY2xvY2soKS5pbnN0YWxsKCknXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xuXG4gICAgZnVuY3Rpb24gb3JpZ2luYWxUaW1pbmdGdW5jdGlvbnNJbnRhY3QoKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBnbG9iYWwuc2V0VGltZW91dCA9PT0gcmVhbFRpbWluZ0Z1bmN0aW9ucy5zZXRUaW1lb3V0ICYmXG4gICAgICAgIGdsb2JhbC5jbGVhclRpbWVvdXQgPT09IHJlYWxUaW1pbmdGdW5jdGlvbnMuY2xlYXJUaW1lb3V0ICYmXG4gICAgICAgIGdsb2JhbC5zZXRJbnRlcnZhbCA9PT0gcmVhbFRpbWluZ0Z1bmN0aW9ucy5zZXRJbnRlcnZhbCAmJlxuICAgICAgICBnbG9iYWwuY2xlYXJJbnRlcnZhbCA9PT0gcmVhbFRpbWluZ0Z1bmN0aW9ucy5jbGVhckludGVydmFsXG4gICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcGxhY2UoZGVzdCwgc291cmNlKSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICBkZXN0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFRpbWVvdXQoZm4sIGRlbGF5KSB7XG4gICAgICBpZiAoIU5PREVfSlMpIHtcbiAgICAgICAgcmV0dXJuIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlci5zY2hlZHVsZUZ1bmN0aW9uKFxuICAgICAgICAgIGZuLFxuICAgICAgICAgIGRlbGF5LFxuICAgICAgICAgIGFyZ1NsaWNlKGFyZ3VtZW50cywgMilcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRpbWVvdXQgPSBuZXcgRmFrZVRpbWVvdXQoKTtcblxuICAgICAgZGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyLnNjaGVkdWxlRnVuY3Rpb24oXG4gICAgICAgIGZuLFxuICAgICAgICBkZWxheSxcbiAgICAgICAgYXJnU2xpY2UoYXJndW1lbnRzLCAyKSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRpbWVvdXRcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB0aW1lb3V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFyVGltZW91dChpZCkge1xuICAgICAgcmV0dXJuIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlci5yZW1vdmVGdW5jdGlvbldpdGhJZChpZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0SW50ZXJ2YWwoZm4sIGludGVydmFsKSB7XG4gICAgICBpZiAoIU5PREVfSlMpIHtcbiAgICAgICAgcmV0dXJuIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlci5zY2hlZHVsZUZ1bmN0aW9uKFxuICAgICAgICAgIGZuLFxuICAgICAgICAgIGludGVydmFsLFxuICAgICAgICAgIGFyZ1NsaWNlKGFyZ3VtZW50cywgMiksXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGltZW91dCA9IG5ldyBGYWtlVGltZW91dCgpO1xuXG4gICAgICBkZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIuc2NoZWR1bGVGdW5jdGlvbihcbiAgICAgICAgZm4sXG4gICAgICAgIGludGVydmFsLFxuICAgICAgICBhcmdTbGljZShhcmd1bWVudHMsIDIpLFxuICAgICAgICB0cnVlLFxuICAgICAgICB0aW1lb3V0XG4gICAgICApO1xuXG4gICAgICByZXR1cm4gdGltZW91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckludGVydmFsKGlkKSB7XG4gICAgICByZXR1cm4gZGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyLnJlbW92ZUZ1bmN0aW9uV2l0aElkKGlkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcmdTbGljZShhcmdzT2JqLCBuKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJnc09iaiwgbik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1vY2tzIE5vZGUuanMgVGltZW91dCBjbGFzc1xuICAgKi9cbiAgZnVuY3Rpb24gRmFrZVRpbWVvdXQoKSB7fVxuXG4gIEZha2VUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBGYWtlVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gQ2xvY2s7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkNvbXBsZXRlT25GaXJzdEVycm9yU2tpcFBvbGljeSA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIENvbXBsZXRlT25GaXJzdEVycm9yU2tpcFBvbGljeShxdWV1ZWFibGVGbnMpIHtcbiAgICB0aGlzLnF1ZXVlYWJsZUZuc18gPSBxdWV1ZWFibGVGbnM7XG4gICAgdGhpcy5lcnJvcmVkRm5JeF8gPSBudWxsO1xuICB9XG5cbiAgQ29tcGxldGVPbkZpcnN0RXJyb3JTa2lwUG9saWN5LnByb3RvdHlwZS5za2lwVG8gPSBmdW5jdGlvbihsYXN0UmFuRm5JeCkge1xuICAgIGxldCBpO1xuXG4gICAgZm9yIChcbiAgICAgIGkgPSBsYXN0UmFuRm5JeCArIDE7XG4gICAgICBpIDwgdGhpcy5xdWV1ZWFibGVGbnNfLmxlbmd0aCAmJiB0aGlzLnNob3VsZFNraXBfKGkpO1xuICAgICAgaSsrXG4gICAgKSB7fVxuICAgIHJldHVybiBpO1xuICB9O1xuXG4gIENvbXBsZXRlT25GaXJzdEVycm9yU2tpcFBvbGljeS5wcm90b3R5cGUuZm5FcnJvcmVkID0gZnVuY3Rpb24oZm5JeCkge1xuICAgIHRoaXMuZXJyb3JlZEZuSXhfID0gZm5JeDtcbiAgfTtcblxuICBDb21wbGV0ZU9uRmlyc3RFcnJvclNraXBQb2xpY3kucHJvdG90eXBlLnNob3VsZFNraXBfID0gZnVuY3Rpb24oZm5JeCkge1xuICAgIGlmICh0aGlzLmVycm9yZWRGbkl4XyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGZuID0gdGhpcy5xdWV1ZWFibGVGbnNfW2ZuSXhdO1xuICAgIGNvbnN0IGNhbmRpZGF0ZVN1aXRlID0gZm4uc3VpdGU7XG4gICAgY29uc3QgZXJyb3JTdWl0ZSA9IHRoaXMucXVldWVhYmxlRm5zX1t0aGlzLmVycm9yZWRGbkl4X10uc3VpdGU7XG4gICAgY29uc3Qgd2FzQ2xlYW51cEZuID1cbiAgICAgIGZuLnR5cGUgPT09ICdhZnRlckVhY2gnIHx8XG4gICAgICBmbi50eXBlID09PSAnYWZ0ZXJBbGwnIHx8XG4gICAgICBmbi50eXBlID09PSAnc3BlY0NsZWFudXAnO1xuICAgIHJldHVybiAoXG4gICAgICAhd2FzQ2xlYW51cEZuIHx8XG4gICAgICAoY2FuZGlkYXRlU3VpdGUgJiYgaXNEZXNjZW5kZW50KGNhbmRpZGF0ZVN1aXRlLCBlcnJvclN1aXRlKSlcbiAgICApO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGlzRGVzY2VuZGVudChjYW5kaWRhdGUsIGFuY2VzdG9yKSB7XG4gICAgaWYgKCFjYW5kaWRhdGUucGFyZW50U3VpdGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGNhbmRpZGF0ZS5wYXJlbnRTdWl0ZSA9PT0gYW5jZXN0b3IpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaXNEZXNjZW5kZW50KGNhbmRpZGF0ZS5wYXJlbnRTdWl0ZSwgYW5jZXN0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBDb21wbGV0ZU9uRmlyc3RFcnJvclNraXBQb2xpY3k7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlciA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIERlbGF5ZWRGdW5jdGlvblNjaGVkdWxlcigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHNjaGVkdWxlZExvb2t1cCA9IFtdO1xuICAgIHZhciBzY2hlZHVsZWRGdW5jdGlvbnMgPSB7fTtcbiAgICB2YXIgY3VycmVudFRpbWUgPSAwO1xuICAgIHZhciBkZWxheWVkRm5Db3VudCA9IDA7XG4gICAgdmFyIGRlbGV0ZWRLZXlzID0gW107XG5cbiAgICBzZWxmLnRpY2sgPSBmdW5jdGlvbihtaWxsaXMsIHRpY2tEYXRlKSB7XG4gICAgICBtaWxsaXMgPSBtaWxsaXMgfHwgMDtcbiAgICAgIHZhciBlbmRUaW1lID0gY3VycmVudFRpbWUgKyBtaWxsaXM7XG5cbiAgICAgIHJ1blNjaGVkdWxlZEZ1bmN0aW9ucyhlbmRUaW1lLCB0aWNrRGF0ZSk7XG4gICAgfTtcblxuICAgIHNlbGYuc2NoZWR1bGVGdW5jdGlvbiA9IGZ1bmN0aW9uKFxuICAgICAgZnVuY1RvQ2FsbCxcbiAgICAgIG1pbGxpcyxcbiAgICAgIHBhcmFtcyxcbiAgICAgIHJlY3VycmluZyxcbiAgICAgIHRpbWVvdXRLZXksXG4gICAgICBydW5BdE1pbGxpc1xuICAgICkge1xuICAgICAgdmFyIGY7XG4gICAgICBpZiAodHlwZW9mIGZ1bmNUb0NhbGwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8qIGpzaGludCBldmlsOiB0cnVlICovXG4gICAgICAgIGYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gZXZhbChmdW5jVG9DYWxsKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoganNoaW50IGV2aWw6IGZhbHNlICovXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmID0gZnVuY1RvQ2FsbDtcbiAgICAgIH1cblxuICAgICAgbWlsbGlzID0gbWlsbGlzIHx8IDA7XG4gICAgICB0aW1lb3V0S2V5ID0gdGltZW91dEtleSB8fCArK2RlbGF5ZWRGbkNvdW50O1xuICAgICAgcnVuQXRNaWxsaXMgPSBydW5BdE1pbGxpcyB8fCBjdXJyZW50VGltZSArIG1pbGxpcztcblxuICAgICAgdmFyIGZ1bmNUb1NjaGVkdWxlID0ge1xuICAgICAgICBydW5BdE1pbGxpczogcnVuQXRNaWxsaXMsXG4gICAgICAgIGZ1bmNUb0NhbGw6IGYsXG4gICAgICAgIHJlY3VycmluZzogcmVjdXJyaW5nLFxuICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgdGltZW91dEtleTogdGltZW91dEtleSxcbiAgICAgICAgbWlsbGlzOiBtaWxsaXNcbiAgICAgIH07XG5cbiAgICAgIGlmIChydW5BdE1pbGxpcyBpbiBzY2hlZHVsZWRGdW5jdGlvbnMpIHtcbiAgICAgICAgc2NoZWR1bGVkRnVuY3Rpb25zW3J1bkF0TWlsbGlzXS5wdXNoKGZ1bmNUb1NjaGVkdWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjaGVkdWxlZEZ1bmN0aW9uc1tydW5BdE1pbGxpc10gPSBbZnVuY1RvU2NoZWR1bGVdO1xuICAgICAgICBzY2hlZHVsZWRMb29rdXAucHVzaChydW5BdE1pbGxpcyk7XG4gICAgICAgIHNjaGVkdWxlZExvb2t1cC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGltZW91dEtleTtcbiAgICB9O1xuXG4gICAgc2VsZi5yZW1vdmVGdW5jdGlvbldpdGhJZCA9IGZ1bmN0aW9uKHRpbWVvdXRLZXkpIHtcbiAgICAgIGRlbGV0ZWRLZXlzLnB1c2godGltZW91dEtleSk7XG5cbiAgICAgIGZvciAodmFyIHJ1bkF0TWlsbGlzIGluIHNjaGVkdWxlZEZ1bmN0aW9ucykge1xuICAgICAgICB2YXIgZnVuY3MgPSBzY2hlZHVsZWRGdW5jdGlvbnNbcnVuQXRNaWxsaXNdO1xuICAgICAgICB2YXIgaSA9IGluZGV4T2ZGaXJzdFRvUGFzcyhmdW5jcywgZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgIHJldHVybiBmdW5jLnRpbWVvdXRLZXkgPT09IHRpbWVvdXRLZXk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgICBpZiAoZnVuY3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBkZWxldGUgc2NoZWR1bGVkRnVuY3Rpb25zW3J1bkF0TWlsbGlzXTtcbiAgICAgICAgICAgIGRlbGV0ZUZyb21Mb29rdXAocnVuQXRNaWxsaXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmdW5jcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaW50ZXJ2YWxzIGdldCByZXNjaGVkdWxlZCB3aGVuIGV4ZWN1dGVkLCBzbyB0aGVyZSdzIG5ldmVyIG1vcmVcbiAgICAgICAgICAvLyB0aGFuIGEgc2luZ2xlIHNjaGVkdWxlZCBmdW5jdGlvbiB3aXRoIGEgZ2l2ZW4gdGltZW91dEtleVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xuXG4gICAgZnVuY3Rpb24gaW5kZXhPZkZpcnN0VG9QYXNzKGFycmF5LCB0ZXN0Rm4pIHtcbiAgICAgIHZhciBpbmRleCA9IC0xO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICh0ZXN0Rm4oYXJyYXlbaV0pKSB7XG4gICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWxldGVGcm9tTG9va3VwKGtleSkge1xuICAgICAgdmFyIHZhbHVlID0gTnVtYmVyKGtleSk7XG4gICAgICB2YXIgaSA9IGluZGV4T2ZGaXJzdFRvUGFzcyhzY2hlZHVsZWRMb29rdXAsIGZ1bmN0aW9uKG1pbGxpcykge1xuICAgICAgICByZXR1cm4gbWlsbGlzID09PSB2YWx1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgIHNjaGVkdWxlZExvb2t1cC5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzY2hlZHVsZShzY2hlZHVsZWRGbikge1xuICAgICAgc2VsZi5zY2hlZHVsZUZ1bmN0aW9uKFxuICAgICAgICBzY2hlZHVsZWRGbi5mdW5jVG9DYWxsLFxuICAgICAgICBzY2hlZHVsZWRGbi5taWxsaXMsXG4gICAgICAgIHNjaGVkdWxlZEZuLnBhcmFtcyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgc2NoZWR1bGVkRm4udGltZW91dEtleSxcbiAgICAgICAgc2NoZWR1bGVkRm4ucnVuQXRNaWxsaXMgKyBzY2hlZHVsZWRGbi5taWxsaXNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9yRWFjaEZ1bmN0aW9uKGZ1bmNzVG9SdW4sIGNhbGxiYWNrKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmNzVG9SdW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2FsbGJhY2soZnVuY3NUb1J1bltpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuU2NoZWR1bGVkRnVuY3Rpb25zKGVuZFRpbWUsIHRpY2tEYXRlKSB7XG4gICAgICB0aWNrRGF0ZSA9IHRpY2tEYXRlIHx8IGZ1bmN0aW9uKCkge307XG4gICAgICBpZiAoc2NoZWR1bGVkTG9va3VwLmxlbmd0aCA9PT0gMCB8fCBzY2hlZHVsZWRMb29rdXBbMF0gPiBlbmRUaW1lKSB7XG4gICAgICAgIGlmIChlbmRUaW1lID49IGN1cnJlbnRUaW1lKSB7XG4gICAgICAgICAgdGlja0RhdGUoZW5kVGltZSAtIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICBjdXJyZW50VGltZSA9IGVuZFRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBkbyB7XG4gICAgICAgIGRlbGV0ZWRLZXlzID0gW107XG4gICAgICAgIHZhciBuZXdDdXJyZW50VGltZSA9IHNjaGVkdWxlZExvb2t1cC5zaGlmdCgpO1xuICAgICAgICBpZiAobmV3Q3VycmVudFRpbWUgPj0gY3VycmVudFRpbWUpIHtcbiAgICAgICAgICB0aWNrRGF0ZShuZXdDdXJyZW50VGltZSAtIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICBjdXJyZW50VGltZSA9IG5ld0N1cnJlbnRUaW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZ1bmNzVG9SdW4gPSBzY2hlZHVsZWRGdW5jdGlvbnNbY3VycmVudFRpbWVdO1xuXG4gICAgICAgIGRlbGV0ZSBzY2hlZHVsZWRGdW5jdGlvbnNbY3VycmVudFRpbWVdO1xuXG4gICAgICAgIGZvckVhY2hGdW5jdGlvbihmdW5jc1RvUnVuLCBmdW5jdGlvbihmdW5jVG9SdW4pIHtcbiAgICAgICAgICBpZiAoZnVuY1RvUnVuLnJlY3VycmluZykge1xuICAgICAgICAgICAgcmVzY2hlZHVsZShmdW5jVG9SdW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yRWFjaEZ1bmN0aW9uKGZ1bmNzVG9SdW4sIGZ1bmN0aW9uKGZ1bmNUb1J1bikge1xuICAgICAgICAgIGlmIChqJC51dGlsLmFycmF5Q29udGFpbnMoZGVsZXRlZEtleXMsIGZ1bmNUb1J1bi50aW1lb3V0S2V5KSkge1xuICAgICAgICAgICAgLy8gc2tpcCBhIHRpbWVvdXRLZXkgZGVsZXRlZCB3aGlsc3Qgd2Ugd2VyZSBydW5uaW5nXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmNUb1J1bi5mdW5jVG9DYWxsLmFwcGx5KG51bGwsIGZ1bmNUb1J1bi5wYXJhbXMgfHwgW10pO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlZEtleXMgPSBbXTtcbiAgICAgIH0gd2hpbGUgKFxuICAgICAgICBzY2hlZHVsZWRMb29rdXAubGVuZ3RoID4gMCAmJlxuICAgICAgICAvLyBjaGVja2luZyBmaXJzdCBpZiB3ZSdyZSBvdXQgb2YgdGltZSBwcmV2ZW50cyBzZXRUaW1lb3V0KDApXG4gICAgICAgIC8vIHNjaGVkdWxlZCBpbiBhIGZ1bmNUb1J1biBmcm9tIGZvcmNpbmcgYW4gZXh0cmEgaXRlcmF0aW9uXG4gICAgICAgIGN1cnJlbnRUaW1lICE9PSBlbmRUaW1lICYmXG4gICAgICAgIHNjaGVkdWxlZExvb2t1cFswXSA8PSBlbmRUaW1lXG4gICAgICApO1xuXG4gICAgICAvLyByYW4gb3V0IG9mIGZ1bmN0aW9ucyB0byBjYWxsLCBidXQgc3RpbGwgdGltZSBsZWZ0IG9uIHRoZSBjbG9ja1xuICAgICAgaWYgKGVuZFRpbWUgPj0gY3VycmVudFRpbWUpIHtcbiAgICAgICAgdGlja0RhdGUoZW5kVGltZSAtIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgY3VycmVudFRpbWUgPSBlbmRUaW1lO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBEZWxheWVkRnVuY3Rpb25TY2hlZHVsZXI7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkRlcHJlY2F0b3IgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBEZXByZWNhdG9yKHRvcFN1aXRlKSB7XG4gICAgdGhpcy50b3BTdWl0ZV8gPSB0b3BTdWl0ZTtcbiAgICB0aGlzLnZlcmJvc2VfID0gZmFsc2U7XG4gICAgdGhpcy50b1N1cHByZXNzXyA9IFtdO1xuICB9XG5cbiAgdmFyIHZlcmJvc2VOb3RlID1cbiAgICAnTm90ZTogVGhpcyBtZXNzYWdlIHdpbGwgYmUgc2hvd24gb25seSBvbmNlLiBTZXQgdGhlIHZlcmJvc2VEZXByZWNhdGlvbnMgJyArXG4gICAgJ2NvbmZpZyBwcm9wZXJ0eSB0byB0cnVlIHRvIHNlZSBldmVyeSBvY2N1cnJlbmNlLic7XG5cbiAgRGVwcmVjYXRvci5wcm90b3R5cGUudmVyYm9zZURlcHJlY2F0aW9ucyA9IGZ1bmN0aW9uKGVuYWJsZWQpIHtcbiAgICB0aGlzLnZlcmJvc2VfID0gZW5hYmxlZDtcbiAgfTtcblxuICAvLyBydW5uYWJsZSBpcyBhIHNwZWMgb3IgYSBzdWl0ZS5cbiAgLy8gZGVwcmVjYXRpb24gaXMgYSBzdHJpbmcgb3IgYW4gRXJyb3IuXG4gIC8vIFNlZSBFbnYjZGVwcmVjYXRlZCBmb3IgYSBkZXNjcmlwdGlvbiBvZiB0aGUgb3B0aW9ucyBhcmd1bWVudC5cbiAgRGVwcmVjYXRvci5wcm90b3R5cGUuYWRkRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24oXG4gICAgcnVubmFibGUsXG4gICAgZGVwcmVjYXRpb24sXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmICghdGhpcy52ZXJib3NlXyAmJiAhaiQuaXNFcnJvcl8oZGVwcmVjYXRpb24pKSB7XG4gICAgICBpZiAodGhpcy50b1N1cHByZXNzXy5pbmRleE9mKGRlcHJlY2F0aW9uKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy50b1N1cHByZXNzXy5wdXNoKGRlcHJlY2F0aW9uKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvZ18ocnVubmFibGUsIGRlcHJlY2F0aW9uLCBvcHRpb25zKTtcbiAgICB0aGlzLnJlcG9ydF8ocnVubmFibGUsIGRlcHJlY2F0aW9uLCBvcHRpb25zKTtcbiAgfTtcblxuICBEZXByZWNhdG9yLnByb3RvdHlwZS5sb2dfID0gZnVuY3Rpb24ocnVubmFibGUsIGRlcHJlY2F0aW9uLCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRleHQ7XG5cbiAgICBpZiAoaiQuaXNFcnJvcl8oZGVwcmVjYXRpb24pKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGRlcHJlY2F0aW9uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocnVubmFibGUgPT09IHRoaXMudG9wU3VpdGVfIHx8IG9wdGlvbnMuaWdub3JlUnVubmFibGUpIHtcbiAgICAgIGNvbnRleHQgPSAnJztcbiAgICB9IGVsc2UgaWYgKHJ1bm5hYmxlLmNoaWxkcmVuKSB7XG4gICAgICBjb250ZXh0ID0gJyAoaW4gc3VpdGU6ICcgKyBydW5uYWJsZS5nZXRGdWxsTmFtZSgpICsgJyknO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0ID0gJyAoaW4gc3BlYzogJyArIHJ1bm5hYmxlLmdldEZ1bGxOYW1lKCkgKyAnKSc7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLm9taXRTdGFja1RyYWNlKSB7XG4gICAgICBjb250ZXh0ICs9ICdcXG4nICsgdGhpcy5zdGFja1RyYWNlXygpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy52ZXJib3NlXykge1xuICAgICAgY29udGV4dCArPSAnXFxuJyArIHZlcmJvc2VOb3RlO1xuICAgIH1cblxuICAgIGNvbnNvbGUuZXJyb3IoJ0RFUFJFQ0FUSU9OOiAnICsgZGVwcmVjYXRpb24gKyBjb250ZXh0KTtcbiAgfTtcblxuICBEZXByZWNhdG9yLnByb3RvdHlwZS5zdGFja1RyYWNlXyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmb3JtYXR0ZXIgPSBuZXcgaiQuRXhjZXB0aW9uRm9ybWF0dGVyKCk7XG4gICAgcmV0dXJuIGZvcm1hdHRlci5zdGFjayhqJC51dGlsLmVycm9yV2l0aFN0YWNrKCkpLnJlcGxhY2UoL15FcnJvclxcbi9tLCAnJyk7XG4gIH07XG5cbiAgRGVwcmVjYXRvci5wcm90b3R5cGUucmVwb3J0XyA9IGZ1bmN0aW9uKHJ1bm5hYmxlLCBkZXByZWNhdGlvbiwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmlnbm9yZVJ1bm5hYmxlKSB7XG4gICAgICBydW5uYWJsZSA9IHRoaXMudG9wU3VpdGVfO1xuICAgIH1cblxuICAgIGlmIChqJC5pc0Vycm9yXyhkZXByZWNhdGlvbikpIHtcbiAgICAgIHJ1bm5hYmxlLmFkZERlcHJlY2F0aW9uV2FybmluZyhkZXByZWNhdGlvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnZlcmJvc2VfKSB7XG4gICAgICBkZXByZWNhdGlvbiArPSAnXFxuJyArIHZlcmJvc2VOb3RlO1xuICAgIH1cblxuICAgIHJ1bm5hYmxlLmFkZERlcHJlY2F0aW9uV2FybmluZyh7XG4gICAgICBtZXNzYWdlOiBkZXByZWNhdGlvbixcbiAgICAgIG9taXRTdGFja1RyYWNlOiBvcHRpb25zLm9taXRTdGFja1RyYWNlIHx8IGZhbHNlXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIERlcHJlY2F0b3I7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLmVycm9ycyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBFeHBlY3RhdGlvbkZhaWxlZCgpIHt9XG5cbiAgRXhwZWN0YXRpb25GYWlsZWQucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gIEV4cGVjdGF0aW9uRmFpbGVkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV4cGVjdGF0aW9uRmFpbGVkO1xuXG4gIHJldHVybiB7XG4gICAgRXhwZWN0YXRpb25GYWlsZWQ6IEV4cGVjdGF0aW9uRmFpbGVkXG4gIH07XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkV4Y2VwdGlvbkZvcm1hdHRlciA9IGZ1bmN0aW9uKGokKSB7XG4gIHZhciBpZ25vcmVkUHJvcGVydGllcyA9IFtcbiAgICAnbmFtZScsXG4gICAgJ21lc3NhZ2UnLFxuICAgICdzdGFjaycsXG4gICAgJ2ZpbGVOYW1lJyxcbiAgICAnc291cmNlVVJMJyxcbiAgICAnbGluZScsXG4gICAgJ2xpbmVOdW1iZXInLFxuICAgICdjb2x1bW4nLFxuICAgICdkZXNjcmlwdGlvbicsXG4gICAgJ2phc21pbmVNZXNzYWdlJ1xuICBdO1xuXG4gIGZ1bmN0aW9uIEV4Y2VwdGlvbkZvcm1hdHRlcihvcHRpb25zKSB7XG4gICAgdmFyIGphc21pbmVGaWxlID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5qYXNtaW5lRmlsZSkgfHwgaiQudXRpbC5qYXNtaW5lRmlsZSgpO1xuICAgIHRoaXMubWVzc2FnZSA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICB2YXIgbWVzc2FnZSA9ICcnO1xuXG4gICAgICBpZiAoZXJyb3IuamFzbWluZU1lc3NhZ2UpIHtcbiAgICAgICAgbWVzc2FnZSArPSBlcnJvci5qYXNtaW5lTWVzc2FnZTtcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3IubmFtZSAmJiBlcnJvci5tZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gZXJyb3IubmFtZSArICc6ICcgKyBlcnJvci5tZXNzYWdlO1xuICAgICAgfSBlbHNlIGlmIChlcnJvci5tZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gZXJyb3IubWVzc2FnZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gZXJyb3IudG9TdHJpbmcoKSArICcgdGhyb3duJztcbiAgICAgIH1cblxuICAgICAgaWYgKGVycm9yLmZpbGVOYW1lIHx8IGVycm9yLnNvdXJjZVVSTCkge1xuICAgICAgICBtZXNzYWdlICs9ICcgaW4gJyArIChlcnJvci5maWxlTmFtZSB8fCBlcnJvci5zb3VyY2VVUkwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXJyb3IubGluZSB8fCBlcnJvci5saW5lTnVtYmVyKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gJyAobGluZSAnICsgKGVycm9yLmxpbmUgfHwgZXJyb3IubGluZU51bWJlcikgKyAnKSc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH07XG5cbiAgICB0aGlzLnN0YWNrID0gZnVuY3Rpb24oZXJyb3IsIHsgb21pdE1lc3NhZ2UgfSA9IHt9KSB7XG4gICAgICBpZiAoIWVycm9yIHx8ICFlcnJvci5zdGFjaykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YWNrVHJhY2UgPSBuZXcgaiQuU3RhY2tUcmFjZShlcnJvcik7XG4gICAgICB2YXIgbGluZXMgPSBmaWx0ZXJKYXNtaW5lKHN0YWNrVHJhY2UpO1xuICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gICAgICBpZiAoc3RhY2tUcmFjZS5tZXNzYWdlICYmICFvbWl0TWVzc2FnZSkge1xuICAgICAgICBsaW5lcy51bnNoaWZ0KHN0YWNrVHJhY2UubWVzc2FnZSk7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCArPSBmb3JtYXRQcm9wZXJ0aWVzKGVycm9yKTtcbiAgICAgIHJlc3VsdCArPSBsaW5lcy5qb2luKCdcXG4nKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZmlsdGVySmFzbWluZShzdGFja1RyYWNlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgIGphc21pbmVNYXJrZXIgPVxuICAgICAgICAgIHN0YWNrVHJhY2Uuc3R5bGUgPT09ICd3ZWJraXQnID8gJzxKYXNtaW5lPicgOiAnICAgIGF0IDxKYXNtaW5lPic7XG5cbiAgICAgIHN0YWNrVHJhY2UuZnJhbWVzLmZvckVhY2goZnVuY3Rpb24oZnJhbWUpIHtcbiAgICAgICAgaWYgKGZyYW1lLmZpbGUgIT09IGphc21pbmVGaWxlKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goZnJhbWUucmF3KTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdICE9PSBqYXNtaW5lTWFya2VyKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goamFzbWluZU1hcmtlcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFByb3BlcnRpZXMoZXJyb3IpIHtcbiAgICAgIGlmICghKGVycm9yIGluc3RhbmNlb2YgT2JqZWN0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIHZhciBlbXB0eSA9IHRydWU7XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gZXJyb3IpIHtcbiAgICAgICAgaWYgKGokLnV0aWwuYXJyYXlDb250YWlucyhpZ25vcmVkUHJvcGVydGllcywgcHJvcCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbcHJvcF0gPSBlcnJvcltwcm9wXTtcbiAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFlbXB0eSkge1xuICAgICAgICByZXR1cm4gJ2Vycm9yIHByb3BlcnRpZXM6ICcgKyBqJC5iYXNpY1ByZXR0eVByaW50ZXJfKHJlc3VsdCkgKyAnXFxuJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBFeGNlcHRpb25Gb3JtYXR0ZXI7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkV4cGVjdGF0aW9uID0gZnVuY3Rpb24oaiQpIHtcbiAgLyoqXG4gICAqIE1hdGNoZXJzIHRoYXQgY29tZSB3aXRoIEphc21pbmUgb3V0IG9mIHRoZSBib3guXG4gICAqIEBuYW1lc3BhY2UgbWF0Y2hlcnNcbiAgICovXG4gIGZ1bmN0aW9uIEV4cGVjdGF0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLmV4cGVjdG9yID0gbmV3IGokLkV4cGVjdG9yKG9wdGlvbnMpO1xuXG4gICAgdmFyIGN1c3RvbU1hdGNoZXJzID0gb3B0aW9ucy5jdXN0b21NYXRjaGVycyB8fCB7fTtcbiAgICBmb3IgKHZhciBtYXRjaGVyTmFtZSBpbiBjdXN0b21NYXRjaGVycykge1xuICAgICAgdGhpc1ttYXRjaGVyTmFtZV0gPSB3cmFwU3luY0NvbXBhcmUoXG4gICAgICAgIG1hdGNoZXJOYW1lLFxuICAgICAgICBjdXN0b21NYXRjaGVyc1ttYXRjaGVyTmFtZV1cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBzb21lIGNvbnRleHQgZm9yIGFuIHtAbGluayBleHBlY3R9XG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN3aXRoQ29udGV4dFxuICAgKiBAc2luY2UgMy4zLjBcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgLSBBZGRpdGlvbmFsIGNvbnRleHQgdG8gc2hvdyB3aGVuIHRoZSBtYXRjaGVyIGZhaWxzXG4gICAqIEByZXR1cm4ge21hdGNoZXJzfVxuICAgKi9cbiAgRXhwZWN0YXRpb24ucHJvdG90eXBlLndpdGhDb250ZXh0ID0gZnVuY3Rpb24gd2l0aENvbnRleHQobWVzc2FnZSkge1xuICAgIHJldHVybiBhZGRGaWx0ZXIodGhpcywgbmV3IENvbnRleHRBZGRpbmdGaWx0ZXIobWVzc2FnZSkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnZlcnQgdGhlIG1hdGNoZXIgZm9sbG93aW5nIHRoaXMge0BsaW5rIGV4cGVjdH1cbiAgICogQG1lbWJlclxuICAgKiBAbmFtZSBtYXRjaGVycyNub3RcbiAgICogQHNpbmNlIDEuMy4wXG4gICAqIEB0eXBlIHttYXRjaGVyc31cbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KHNvbWV0aGluZykubm90LnRvQmUodHJ1ZSk7XG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXhwZWN0YXRpb24ucHJvdG90eXBlLCAnbm90Jywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYWRkRmlsdGVyKHRoaXMsIHN5bmNOZWdhdGluZ0ZpbHRlcik7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQXN5bmNocm9ub3VzIG1hdGNoZXJzIHRoYXQgb3BlcmF0ZSBvbiBhbiBhY3R1YWwgdmFsdWUgd2hpY2ggaXMgYSBwcm9taXNlLFxuICAgKiBhbmQgcmV0dXJuIGEgcHJvbWlzZS5cbiAgICpcbiAgICogTW9zdCBhc3luYyBtYXRjaGVycyB3aWxsIHdhaXQgaW5kZWZpbml0ZWx5IGZvciB0aGUgcHJvbWlzZSB0byBiZSByZXNvbHZlZFxuICAgKiBvciByZWplY3RlZCwgcmVzdWx0aW5nIGluIGEgc3BlYyB0aW1lb3V0IGlmIHRoYXQgbmV2ZXIgaGFwcGVucy4gSWYgeW91XG4gICAqIGV4cGVjdCB0aGF0IHRoZSBwcm9taXNlIHdpbGwgYWxyZWFkeSBiZSByZXNvbHZlZCBvciByZWplY3RlZCBhdCB0aGUgdGltZVxuICAgKiB0aGUgbWF0Y2hlciBpcyBjYWxsZWQsIHlvdSBjYW4gdXNlIHRoZSB7QGxpbmsgYXN5bmMtbWF0Y2hlcnMjYWxyZWFkeX1cbiAgICogbW9kaWZpZXIgdG8gZ2V0IGEgZmFzdGVyIGZhaWx1cmUgd2l0aCBhIG1vcmUgaGVscGZ1bCBtZXNzYWdlLlxuICAgKlxuICAgKiBOb3RlOiBTcGVjcyBtdXN0IGF3YWl0IHRoZSByZXN1bHQgb2YgZWFjaCBhc3luYyBtYXRjaGVyLCByZXR1cm4gdGhlXG4gICAqIHByb21pc2UgcmV0dXJuZWQgYnkgdGhlIG1hdGNoZXIsIG9yIHJldHVybiBhIHByb21pc2UgdGhhdCdzIGRlcml2ZWQgZnJvbVxuICAgKiB0aGUgb25lIHJldHVybmVkIGJ5IHRoZSBtYXRjaGVyLiBPdGhlcndpc2UgdGhlIG1hdGNoZXIgd2lsbCBub3QgYmVcbiAgICogZXZhbHVhdGVkIGJlZm9yZSB0aGUgc3BlYyBjb21wbGV0ZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEdvb2RcbiAgICogYXdhaXQgZXhwZWN0QXN5bmMoYVByb21pc2UpLnRvQmVSZXNvbHZlZCgpO1xuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBHb29kXG4gICAqIHJldHVybiBleHBlY3RBc3luYyhhUHJvbWlzZSkudG9CZVJlc29sdmVkKCk7XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEdvb2RcbiAgICogcmV0dXJuIGV4cGVjdEFzeW5jKGFQcm9taXNlKS50b0JlUmVzb2x2ZWQoKVxuICAgKiAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAqICAgIC8vIG1vcmUgc3BlYyBjb2RlXG4gICAqICB9KTtcbiAgICogQGV4YW1wbGVcbiAgICogLy8gQmFkXG4gICAqIGV4cGVjdEFzeW5jKGFQcm9taXNlKS50b0JlUmVzb2x2ZWQoKTtcbiAgICogQG5hbWVzcGFjZSBhc3luYy1tYXRjaGVyc1xuICAgKi9cbiAgZnVuY3Rpb24gQXN5bmNFeHBlY3RhdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5leHBlY3RvciA9IG5ldyBqJC5FeHBlY3RvcihvcHRpb25zKTtcblxuICAgIHZhciBjdXN0b21Bc3luY01hdGNoZXJzID0gb3B0aW9ucy5jdXN0b21Bc3luY01hdGNoZXJzIHx8IHt9O1xuICAgIGZvciAodmFyIG1hdGNoZXJOYW1lIGluIGN1c3RvbUFzeW5jTWF0Y2hlcnMpIHtcbiAgICAgIHRoaXNbbWF0Y2hlck5hbWVdID0gd3JhcEFzeW5jQ29tcGFyZShcbiAgICAgICAgbWF0Y2hlck5hbWUsXG4gICAgICAgIGN1c3RvbUFzeW5jTWF0Y2hlcnNbbWF0Y2hlck5hbWVdXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgc29tZSBjb250ZXh0IGZvciBhbiB7QGxpbmsgZXhwZWN0QXN5bmN9XG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBhc3luYy1tYXRjaGVycyN3aXRoQ29udGV4dFxuICAgKiBAc2luY2UgMy4zLjBcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgLSBBZGRpdGlvbmFsIGNvbnRleHQgdG8gc2hvdyB3aGVuIHRoZSBhc3luYyBtYXRjaGVyIGZhaWxzXG4gICAqIEByZXR1cm4ge2FzeW5jLW1hdGNoZXJzfVxuICAgKi9cbiAgQXN5bmNFeHBlY3RhdGlvbi5wcm90b3R5cGUud2l0aENvbnRleHQgPSBmdW5jdGlvbiB3aXRoQ29udGV4dChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIGFkZEZpbHRlcih0aGlzLCBuZXcgQ29udGV4dEFkZGluZ0ZpbHRlcihtZXNzYWdlKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEludmVydCB0aGUgbWF0Y2hlciBmb2xsb3dpbmcgdGhpcyB7QGxpbmsgZXhwZWN0QXN5bmN9XG4gICAqIEBtZW1iZXJcbiAgICogQG5hbWUgYXN5bmMtbWF0Y2hlcnMjbm90XG4gICAqIEB0eXBlIHthc3luYy1tYXRjaGVyc31cbiAgICogQGV4YW1wbGVcbiAgICogYXdhaXQgZXhwZWN0QXN5bmMobXlQcm9taXNlKS5ub3QudG9CZVJlc29sdmVkKCk7XG4gICAqIEBleGFtcGxlXG4gICAqIHJldHVybiBleHBlY3RBc3luYyhteVByb21pc2UpLm5vdC50b0JlUmVzb2x2ZWQoKTtcbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBc3luY0V4cGVjdGF0aW9uLnByb3RvdHlwZSwgJ25vdCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFkZEZpbHRlcih0aGlzLCBhc3luY05lZ2F0aW5nRmlsdGVyKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBGYWlsIGFzIHNvb24gYXMgcG9zc2libGUgaWYgdGhlIGFjdHVhbCBpcyBwZW5kaW5nLlxuICAgKiBPdGhlcndpc2UgZXZhbHVhdGUgdGhlIG1hdGNoZXIuXG4gICAqIEBtZW1iZXJcbiAgICogQG5hbWUgYXN5bmMtbWF0Y2hlcnMjYWxyZWFkeVxuICAgKiBAc2luY2UgMy44LjBcbiAgICogQHR5cGUge2FzeW5jLW1hdGNoZXJzfVxuICAgKiBAZXhhbXBsZVxuICAgKiBhd2FpdCBleHBlY3RBc3luYyhteVByb21pc2UpLmFscmVhZHkudG9CZVJlc29sdmVkKCk7XG4gICAqIEBleGFtcGxlXG4gICAqIHJldHVybiBleHBlY3RBc3luYyhteVByb21pc2UpLmFscmVhZHkudG9CZVJlc29sdmVkKCk7XG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXN5bmNFeHBlY3RhdGlvbi5wcm90b3R5cGUsICdhbHJlYWR5Jywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYWRkRmlsdGVyKHRoaXMsIGV4cGVjdFNldHRsZWRQcm9taXNlRmlsdGVyKTtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHdyYXBTeW5jQ29tcGFyZShuYW1lLCBtYXRjaGVyRmFjdG9yeSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmV4cGVjdG9yLmNvbXBhcmUobmFtZSwgbWF0Y2hlckZhY3RvcnksIGFyZ3VtZW50cyk7XG4gICAgICB0aGlzLmV4cGVjdG9yLnByb2Nlc3NSZXN1bHQocmVzdWx0KTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcEFzeW5jQ29tcGFyZShuYW1lLCBtYXRjaGVyRmFjdG9yeSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgLy8gQ2FwdHVyZSB0aGUgY2FsbCBzdGFjayBoZXJlLCBiZWZvcmUgd2UgZ28gYXN5bmMsIHNvIHRoYXQgaXQgd2lsbCBjb250YWluXG4gICAgICAvLyBmcmFtZXMgdGhhdCBhcmUgcmVsZXZhbnQgdG8gdGhlIHVzZXIgaW5zdGVhZCBvZiBqdXN0IHBhcnRzIG9mIEphc21pbmUuXG4gICAgICB2YXIgZXJyb3JGb3JTdGFjayA9IGokLnV0aWwuZXJyb3JXaXRoU3RhY2soKTtcblxuICAgICAgcmV0dXJuIHRoaXMuZXhwZWN0b3JcbiAgICAgICAgLmNvbXBhcmUobmFtZSwgbWF0Y2hlckZhY3RvcnksIGFyZ3VtZW50cylcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgc2VsZi5leHBlY3Rvci5wcm9jZXNzUmVzdWx0KHJlc3VsdCwgZXJyb3JGb3JTdGFjayk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBhZGRDb3JlTWF0Y2hlcnMocHJvdG90eXBlLCBtYXRjaGVycywgd3JhcHBlcikge1xuICAgIGZvciAodmFyIG1hdGNoZXJOYW1lIGluIG1hdGNoZXJzKSB7XG4gICAgICB2YXIgbWF0Y2hlciA9IG1hdGNoZXJzW21hdGNoZXJOYW1lXTtcbiAgICAgIHByb3RvdHlwZVttYXRjaGVyTmFtZV0gPSB3cmFwcGVyKG1hdGNoZXJOYW1lLCBtYXRjaGVyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRGaWx0ZXIoc291cmNlLCBmaWx0ZXIpIHtcbiAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShzb3VyY2UpO1xuICAgIHJlc3VsdC5leHBlY3RvciA9IHNvdXJjZS5leHBlY3Rvci5hZGRGaWx0ZXIoZmlsdGVyKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gbmVnYXRlZEZhaWx1cmVNZXNzYWdlKHJlc3VsdCwgbWF0Y2hlck5hbWUsIGFyZ3MsIG1hdGNoZXJzVXRpbCkge1xuICAgIGlmIChyZXN1bHQubWVzc2FnZSkge1xuICAgICAgaWYgKGokLmlzRnVuY3Rpb25fKHJlc3VsdC5tZXNzYWdlKSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0Lm1lc3NhZ2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHQubWVzc2FnZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhcmdzID0gYXJncy5zbGljZSgpO1xuICAgIGFyZ3MudW5zaGlmdCh0cnVlKTtcbiAgICBhcmdzLnVuc2hpZnQobWF0Y2hlck5hbWUpO1xuICAgIHJldHVybiBtYXRjaGVyc1V0aWwuYnVpbGRGYWlsdXJlTWVzc2FnZS5hcHBseShtYXRjaGVyc1V0aWwsIGFyZ3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gbmVnYXRlKHJlc3VsdCkge1xuICAgIHJlc3VsdC5wYXNzID0gIXJlc3VsdC5wYXNzO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgc3luY05lZ2F0aW5nRmlsdGVyID0ge1xuICAgIHNlbGVjdENvbXBhcmlzb25GdW5jOiBmdW5jdGlvbihtYXRjaGVyKSB7XG4gICAgICBmdW5jdGlvbiBkZWZhdWx0TmVnYXRpdmVDb21wYXJlKCkge1xuICAgICAgICByZXR1cm4gbmVnYXRlKG1hdGNoZXIuY29tcGFyZS5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hdGNoZXIubmVnYXRpdmVDb21wYXJlIHx8IGRlZmF1bHROZWdhdGl2ZUNvbXBhcmU7XG4gICAgfSxcbiAgICBidWlsZEZhaWx1cmVNZXNzYWdlOiBuZWdhdGVkRmFpbHVyZU1lc3NhZ2VcbiAgfTtcblxuICB2YXIgYXN5bmNOZWdhdGluZ0ZpbHRlciA9IHtcbiAgICBzZWxlY3RDb21wYXJpc29uRnVuYzogZnVuY3Rpb24obWF0Y2hlcikge1xuICAgICAgZnVuY3Rpb24gZGVmYXVsdE5lZ2F0aXZlQ29tcGFyZSgpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXIuY29tcGFyZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLnRoZW4obmVnYXRlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hdGNoZXIubmVnYXRpdmVDb21wYXJlIHx8IGRlZmF1bHROZWdhdGl2ZUNvbXBhcmU7XG4gICAgfSxcbiAgICBidWlsZEZhaWx1cmVNZXNzYWdlOiBuZWdhdGVkRmFpbHVyZU1lc3NhZ2VcbiAgfTtcblxuICB2YXIgZXhwZWN0U2V0dGxlZFByb21pc2VGaWx0ZXIgPSB7XG4gICAgc2VsZWN0Q29tcGFyaXNvbkZ1bmM6IGZ1bmN0aW9uKG1hdGNoZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihhY3R1YWwpIHtcbiAgICAgICAgdmFyIG1hdGNoZXJBcmdzID0gYXJndW1lbnRzO1xuXG4gICAgICAgIHJldHVybiBqJC5pc1BlbmRpbmdfKGFjdHVhbCkudGhlbihmdW5jdGlvbihpc1BlbmRpbmcpIHtcbiAgICAgICAgICBpZiAoaXNQZW5kaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBwYXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgICAnRXhwZWN0ZWQgYSBwcm9taXNlIHRvIGJlIHNldHRsZWQgKHZpYSAnICtcbiAgICAgICAgICAgICAgICAnZXhwZWN0QXN5bmMoLi4uKS5hbHJlYWR5KSBidXQgaXQgd2FzIHBlbmRpbmcuJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXIuY29tcGFyZS5hcHBseShudWxsLCBtYXRjaGVyQXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIENvbnRleHRBZGRpbmdGaWx0ZXIobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cblxuICBDb250ZXh0QWRkaW5nRmlsdGVyLnByb3RvdHlwZS5tb2RpZnlGYWlsdXJlTWVzc2FnZSA9IGZ1bmN0aW9uKG1zZykge1xuICAgIHZhciBubCA9IG1zZy5pbmRleE9mKCdcXG4nKTtcblxuICAgIGlmIChubCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2UgKyAnOiAnICsgbXNnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXNzYWdlICsgJzpcXG4nICsgaW5kZW50KG1zZyk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGluZGVudChzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZSgvXi9nbSwgJyAgICAnKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZmFjdG9yeTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyBFeHBlY3RhdGlvbihvcHRpb25zIHx8IHt9KTtcbiAgICB9LFxuICAgIGFkZENvcmVNYXRjaGVyczogZnVuY3Rpb24obWF0Y2hlcnMpIHtcbiAgICAgIGFkZENvcmVNYXRjaGVycyhFeHBlY3RhdGlvbi5wcm90b3R5cGUsIG1hdGNoZXJzLCB3cmFwU3luY0NvbXBhcmUpO1xuICAgIH0sXG4gICAgYXN5bmNGYWN0b3J5OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IEFzeW5jRXhwZWN0YXRpb24ob3B0aW9ucyB8fCB7fSk7XG4gICAgfSxcbiAgICBhZGRBc3luY0NvcmVNYXRjaGVyczogZnVuY3Rpb24obWF0Y2hlcnMpIHtcbiAgICAgIGFkZENvcmVNYXRjaGVycyhBc3luY0V4cGVjdGF0aW9uLnByb3RvdHlwZSwgbWF0Y2hlcnMsIHdyYXBBc3luY0NvbXBhcmUpO1xuICAgIH1cbiAgfTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuRXhwZWN0YXRpb25GaWx0ZXJDaGFpbiA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBFeHBlY3RhdGlvbkZpbHRlckNoYWluKG1heWJlRmlsdGVyLCBwcmV2KSB7XG4gICAgdGhpcy5maWx0ZXJfID0gbWF5YmVGaWx0ZXI7XG4gICAgdGhpcy5wcmV2XyA9IHByZXY7XG4gIH1cblxuICBFeHBlY3RhdGlvbkZpbHRlckNoYWluLnByb3RvdHlwZS5hZGRGaWx0ZXIgPSBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICByZXR1cm4gbmV3IEV4cGVjdGF0aW9uRmlsdGVyQ2hhaW4oZmlsdGVyLCB0aGlzKTtcbiAgfTtcblxuICBFeHBlY3RhdGlvbkZpbHRlckNoYWluLnByb3RvdHlwZS5zZWxlY3RDb21wYXJpc29uRnVuYyA9IGZ1bmN0aW9uKG1hdGNoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jYWxsRmlyc3RfKCdzZWxlY3RDb21wYXJpc29uRnVuYycsIGFyZ3VtZW50cykucmVzdWx0O1xuICB9O1xuXG4gIEV4cGVjdGF0aW9uRmlsdGVyQ2hhaW4ucHJvdG90eXBlLmJ1aWxkRmFpbHVyZU1lc3NhZ2UgPSBmdW5jdGlvbihcbiAgICByZXN1bHQsXG4gICAgbWF0Y2hlck5hbWUsXG4gICAgYXJncyxcbiAgICBtYXRjaGVyc1V0aWxcbiAgKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FsbEZpcnN0XygnYnVpbGRGYWlsdXJlTWVzc2FnZScsIGFyZ3VtZW50cykucmVzdWx0O1xuICB9O1xuXG4gIEV4cGVjdGF0aW9uRmlsdGVyQ2hhaW4ucHJvdG90eXBlLm1vZGlmeUZhaWx1cmVNZXNzYWdlID0gZnVuY3Rpb24obXNnKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuY2FsbEZpcnN0XygnbW9kaWZ5RmFpbHVyZU1lc3NhZ2UnLCBhcmd1bWVudHMpLnJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0IHx8IG1zZztcbiAgfTtcblxuICBFeHBlY3RhdGlvbkZpbHRlckNoYWluLnByb3RvdHlwZS5jYWxsRmlyc3RfID0gZnVuY3Rpb24oZm5hbWUsIGFyZ3MpIHtcbiAgICB2YXIgcHJldlJlc3VsdDtcblxuICAgIGlmICh0aGlzLnByZXZfKSB7XG4gICAgICBwcmV2UmVzdWx0ID0gdGhpcy5wcmV2Xy5jYWxsRmlyc3RfKGZuYW1lLCBhcmdzKTtcblxuICAgICAgaWYgKHByZXZSZXN1bHQuZm91bmQpIHtcbiAgICAgICAgcmV0dXJuIHByZXZSZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmlsdGVyXyAmJiB0aGlzLmZpbHRlcl9bZm5hbWVdKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmb3VuZDogdHJ1ZSxcbiAgICAgICAgcmVzdWx0OiB0aGlzLmZpbHRlcl9bZm5hbWVdLmFwcGx5KHRoaXMuZmlsdGVyXywgYXJncylcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgZm91bmQ6IGZhbHNlIH07XG4gIH07XG5cbiAgcmV0dXJuIEV4cGVjdGF0aW9uRmlsdGVyQ2hhaW47XG59O1xuXG4vL1RPRE86IGV4cGVjdGF0aW9uIHJlc3VsdCBtYXkgbWFrZSBtb3JlIHNlbnNlIGFzIGEgcHJlc2VudGF0aW9uIG9mIGFuIGV4cGVjdGF0aW9uLlxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5idWlsZEV4cGVjdGF0aW9uUmVzdWx0ID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gYnVpbGRFeHBlY3RhdGlvblJlc3VsdChvcHRpb25zKSB7XG4gICAgdmFyIG1lc3NhZ2VGb3JtYXR0ZXIgPSBvcHRpb25zLm1lc3NhZ2VGb3JtYXR0ZXIgfHwgZnVuY3Rpb24oKSB7fSxcbiAgICAgIHN0YWNrRm9ybWF0dGVyID0gb3B0aW9ucy5zdGFja0Zvcm1hdHRlciB8fCBmdW5jdGlvbigpIHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYgRXhwZWN0YXRpb25cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gbWF0Y2hlck5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgbWF0Y2hlciB0aGF0IHdhcyBleGVjdXRlZCBmb3IgdGhpcyBleHBlY3RhdGlvbi5cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gbWVzc2FnZSAtIFRoZSBmYWlsdXJlIG1lc3NhZ2UgZm9yIHRoZSBleHBlY3RhdGlvbi5cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gc3RhY2sgLSBUaGUgc3RhY2sgdHJhY2UgZm9yIHRoZSBmYWlsdXJlIGlmIGF2YWlsYWJsZS5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHBhc3NlZCAtIFdoZXRoZXIgdGhlIGV4cGVjdGF0aW9uIHBhc3NlZCBvciBmYWlsZWQuXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IGV4cGVjdGVkIC0gSWYgdGhlIGV4cGVjdGF0aW9uIGZhaWxlZCwgd2hhdCB3YXMgdGhlIGV4cGVjdGVkIHZhbHVlLlxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBhY3R1YWwgLSBJZiB0aGUgZXhwZWN0YXRpb24gZmFpbGVkLCB3aGF0IGFjdHVhbCB2YWx1ZSB3YXMgcHJvZHVjZWQuXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd8dW5kZWZpbmVkfSBnbG9iYWxFcnJvclR5cGUgLSBUaGUgdHlwZSBvZiBhbiBlcnJvciB0aGF0XG4gICAgICogaXMgcmVwb3J0ZWQgb24gdGhlIHRvcCBzdWl0ZS4gVmFsaWQgdmFsdWVzIGFyZSB1bmRlZmluZWQsIFwiYWZ0ZXJBbGxcIixcbiAgICAgKiBcImxvYWRcIiwgXCJsYXRlRXhwZWN0YXRpb25cIiwgYW5kIFwibGF0ZUVycm9yXCIuXG4gICAgICovXG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIG1hdGNoZXJOYW1lOiBvcHRpb25zLm1hdGNoZXJOYW1lLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSgpLFxuICAgICAgc3RhY2s6IG9wdGlvbnMub21pdFN0YWNrVHJhY2UgPyAnJyA6IHN0YWNrKCksXG4gICAgICBwYXNzZWQ6IG9wdGlvbnMucGFzc2VkXG4gICAgfTtcblxuICAgIGlmICghcmVzdWx0LnBhc3NlZCkge1xuICAgICAgcmVzdWx0LmV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgICAgIHJlc3VsdC5hY3R1YWwgPSBvcHRpb25zLmFjdHVhbDtcblxuICAgICAgaWYgKG9wdGlvbnMuZXJyb3IgJiYgIWokLmlzU3RyaW5nXyhvcHRpb25zLmVycm9yKSkge1xuICAgICAgICBpZiAoJ2NvZGUnIGluIG9wdGlvbnMuZXJyb3IpIHtcbiAgICAgICAgICByZXN1bHQuY29kZSA9IG9wdGlvbnMuZXJyb3IuY29kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBvcHRpb25zLmVycm9yLmNvZGUgPT09ICdFUlJfQVNTRVJUSU9OJyAmJlxuICAgICAgICAgIG9wdGlvbnMuZXhwZWN0ZWQgPT09ICcnICYmXG4gICAgICAgICAgb3B0aW9ucy5hY3R1YWwgPT09ICcnXG4gICAgICAgICkge1xuICAgICAgICAgIHJlc3VsdC5leHBlY3RlZCA9IG9wdGlvbnMuZXJyb3IuZXhwZWN0ZWQ7XG4gICAgICAgICAgcmVzdWx0LmFjdHVhbCA9IG9wdGlvbnMuZXJyb3IuYWN0dWFsO1xuICAgICAgICAgIHJlc3VsdC5tYXRjaGVyTmFtZSA9ICdhc3NlcnQgJyArIG9wdGlvbnMuZXJyb3Iub3BlcmF0b3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgZnVuY3Rpb24gbWVzc2FnZSgpIHtcbiAgICAgIGlmIChvcHRpb25zLnBhc3NlZCkge1xuICAgICAgICByZXR1cm4gJ1Bhc3NlZC4nO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMubWVzc2FnZTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5lcnJvcikge1xuICAgICAgICByZXR1cm4gbWVzc2FnZUZvcm1hdHRlcihvcHRpb25zLmVycm9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFjaygpIHtcbiAgICAgIGlmIChvcHRpb25zLnBhc3NlZCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIHZhciBlcnJvciA9IG9wdGlvbnMuZXJyb3I7XG4gICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmVycm9yRm9yU3RhY2spIHtcbiAgICAgICAgICBlcnJvciA9IG9wdGlvbnMuZXJyb3JGb3JTdGFjaztcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnN0YWNrKSB7XG4gICAgICAgICAgZXJyb3IgPSBvcHRpb25zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSgpKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBPbWl0IHRoZSBtZXNzYWdlIGZyb20gdGhlIHN0YWNrIHRyYWNlIGJlY2F1c2UgaXQgd2lsbCBiZVxuICAgICAgLy8gaW5jbHVkZWQgZWxzZXdoZXJlLlxuICAgICAgcmV0dXJuIHN0YWNrRm9ybWF0dGVyKGVycm9yLCB7IG9taXRNZXNzYWdlOiB0cnVlIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWlsZEV4cGVjdGF0aW9uUmVzdWx0O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5FeHBlY3RvciA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIEV4cGVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm1hdGNoZXJzVXRpbCA9IG9wdGlvbnMubWF0Y2hlcnNVdGlsIHx8IHtcbiAgICAgIGJ1aWxkRmFpbHVyZU1lc3NhZ2U6IGZ1bmN0aW9uKCkge31cbiAgICB9O1xuICAgIHRoaXMuYWN0dWFsID0gb3B0aW9ucy5hY3R1YWw7XG4gICAgdGhpcy5hZGRFeHBlY3RhdGlvblJlc3VsdCA9IG9wdGlvbnMuYWRkRXhwZWN0YXRpb25SZXN1bHQgfHwgZnVuY3Rpb24oKSB7fTtcbiAgICB0aGlzLmZpbHRlcnMgPSBuZXcgaiQuRXhwZWN0YXRpb25GaWx0ZXJDaGFpbigpO1xuICB9XG5cbiAgRXhwZWN0b3IucHJvdG90eXBlLmluc3RhbnRpYXRlTWF0Y2hlciA9IGZ1bmN0aW9uKFxuICAgIG1hdGNoZXJOYW1lLFxuICAgIG1hdGNoZXJGYWN0b3J5LFxuICAgIGFyZ3NcbiAgKSB7XG4gICAgdGhpcy5tYXRjaGVyTmFtZSA9IG1hdGNoZXJOYW1lO1xuICAgIHRoaXMuYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDApO1xuICAgIHRoaXMuZXhwZWN0ZWQgPSB0aGlzLmFyZ3Muc2xpY2UoMCk7XG5cbiAgICB0aGlzLmFyZ3MudW5zaGlmdCh0aGlzLmFjdHVhbCk7XG5cbiAgICB2YXIgbWF0Y2hlciA9IG1hdGNoZXJGYWN0b3J5KHRoaXMubWF0Y2hlcnNVdGlsKTtcblxuICAgIHZhciBjb21wYXJpc29uRnVuYyA9IHRoaXMuZmlsdGVycy5zZWxlY3RDb21wYXJpc29uRnVuYyhtYXRjaGVyKTtcbiAgICByZXR1cm4gY29tcGFyaXNvbkZ1bmMgfHwgbWF0Y2hlci5jb21wYXJlO1xuICB9O1xuXG4gIEV4cGVjdG9yLnByb3RvdHlwZS5idWlsZE1lc3NhZ2UgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAocmVzdWx0LnBhc3MpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICB2YXIgbXNnID0gdGhpcy5maWx0ZXJzLmJ1aWxkRmFpbHVyZU1lc3NhZ2UoXG4gICAgICByZXN1bHQsXG4gICAgICB0aGlzLm1hdGNoZXJOYW1lLFxuICAgICAgdGhpcy5hcmdzLFxuICAgICAgdGhpcy5tYXRjaGVyc1V0aWwsXG4gICAgICBkZWZhdWx0TWVzc2FnZVxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVycy5tb2RpZnlGYWlsdXJlTWVzc2FnZShtc2cgfHwgZGVmYXVsdE1lc3NhZ2UoKSk7XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0TWVzc2FnZSgpIHtcbiAgICAgIGlmICghcmVzdWx0Lm1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBzZWxmLmFyZ3Muc2xpY2UoKTtcbiAgICAgICAgYXJncy51bnNoaWZ0KGZhbHNlKTtcbiAgICAgICAgYXJncy51bnNoaWZ0KHNlbGYubWF0Y2hlck5hbWUpO1xuICAgICAgICByZXR1cm4gc2VsZi5tYXRjaGVyc1V0aWwuYnVpbGRGYWlsdXJlTWVzc2FnZS5hcHBseShcbiAgICAgICAgICBzZWxmLm1hdGNoZXJzVXRpbCxcbiAgICAgICAgICBhcmdzXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGokLmlzRnVuY3Rpb25fKHJlc3VsdC5tZXNzYWdlKSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0Lm1lc3NhZ2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHQubWVzc2FnZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgRXhwZWN0b3IucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbihtYXRjaGVyTmFtZSwgbWF0Y2hlckZhY3RvcnksIGFyZ3MpIHtcbiAgICB2YXIgbWF0Y2hlckNvbXBhcmUgPSB0aGlzLmluc3RhbnRpYXRlTWF0Y2hlcihcbiAgICAgIG1hdGNoZXJOYW1lLFxuICAgICAgbWF0Y2hlckZhY3RvcnksXG4gICAgICBhcmdzXG4gICAgKTtcbiAgICByZXR1cm4gbWF0Y2hlckNvbXBhcmUuYXBwbHkobnVsbCwgdGhpcy5hcmdzKTtcbiAgfTtcblxuICBFeHBlY3Rvci5wcm90b3R5cGUuYWRkRmlsdGVyID0gZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgcmVzdWx0LmZpbHRlcnMgPSB0aGlzLmZpbHRlcnMuYWRkRmlsdGVyKGZpbHRlcik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBFeHBlY3Rvci5wcm90b3R5cGUucHJvY2Vzc1Jlc3VsdCA9IGZ1bmN0aW9uKHJlc3VsdCwgZXJyb3JGb3JTdGFjaykge1xuICAgIHZhciBtZXNzYWdlID0gdGhpcy5idWlsZE1lc3NhZ2UocmVzdWx0KTtcblxuICAgIGlmICh0aGlzLmV4cGVjdGVkLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGhpcy5leHBlY3RlZCA9IHRoaXMuZXhwZWN0ZWRbMF07XG4gICAgfVxuXG4gICAgdGhpcy5hZGRFeHBlY3RhdGlvblJlc3VsdChyZXN1bHQucGFzcywge1xuICAgICAgbWF0Y2hlck5hbWU6IHRoaXMubWF0Y2hlck5hbWUsXG4gICAgICBwYXNzZWQ6IHJlc3VsdC5wYXNzLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIGVycm9yOiBlcnJvckZvclN0YWNrID8gdW5kZWZpbmVkIDogcmVzdWx0LmVycm9yLFxuICAgICAgZXJyb3JGb3JTdGFjazogZXJyb3JGb3JTdGFjayB8fCB1bmRlZmluZWQsXG4gICAgICBhY3R1YWw6IHRoaXMuYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IHRoaXMuZXhwZWN0ZWQgLy8gVE9ETzogdGhpcyBtYXkgbmVlZCB0byBiZSBhcnJheWlmaWVkL3NsaWNlZFxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBFeHBlY3Rvcjtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuZm9ybWF0RXJyb3JNc2cgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gZ2VuZXJhdGVFcnJvck1zZyhkb21haW4sIHVzYWdlKSB7XG4gICAgdmFyIHVzYWdlRGVmaW5pdGlvbiA9IHVzYWdlID8gJ1xcblVzYWdlOiAnICsgdXNhZ2UgOiAnJztcblxuICAgIHJldHVybiBmdW5jdGlvbiBlcnJvck1zZyhtc2cpIHtcbiAgICAgIHJldHVybiBkb21haW4gKyAnIDogJyArIG1zZyArIHVzYWdlRGVmaW5pdGlvbjtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGdlbmVyYXRlRXJyb3JNc2c7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkdsb2JhbEVycm9ycyA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIEdsb2JhbEVycm9ycyhnbG9iYWwpIHtcbiAgICB2YXIgaGFuZGxlcnMgPSBbXTtcbiAgICBnbG9iYWwgPSBnbG9iYWwgfHwgaiQuZ2V0R2xvYmFsKCk7XG5cbiAgICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uIG9uZXJyb3IoKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IGhhbmRsZXJzW2hhbmRsZXJzLmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICBoYW5kbGVyLmFwcGx5KG51bGwsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgYXJndW1lbnRzWzBdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm9yaWdpbmFsSGFuZGxlcnMgPSB7fTtcbiAgICB0aGlzLmphc21pbmVIYW5kbGVycyA9IHt9O1xuICAgIHRoaXMuaW5zdGFsbE9uZV8gPSBmdW5jdGlvbiBpbnN0YWxsT25lXyhlcnJvclR5cGUsIGphc21pbmVNZXNzYWdlKSB7XG4gICAgICBmdW5jdGlvbiB0YWdnZWRPbkVycm9yKGVycm9yKSB7XG4gICAgICAgIHZhciBzdWJzdGl0dXRlTXNnO1xuXG4gICAgICAgIGlmIChqJC5pc0Vycm9yXyhlcnJvcikpIHtcbiAgICAgICAgICBlcnJvci5qYXNtaW5lTWVzc2FnZSA9IGphc21pbmVNZXNzYWdlICsgJzogJyArIGVycm9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgc3Vic3RpdHV0ZU1zZyA9IGphc21pbmVNZXNzYWdlICsgJzogJyArIGVycm9yO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJzdGl0dXRlTXNnID0gamFzbWluZU1lc3NhZ2UgKyAnIHdpdGggbm8gZXJyb3Igb3IgbWVzc2FnZSc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGVycm9yVHlwZSA9PT0gJ3VuaGFuZGxlZFJlamVjdGlvbicpIHtcbiAgICAgICAgICAgIHN1YnN0aXR1dGVNc2cgKz1cbiAgICAgICAgICAgICAgJ1xcbicgK1xuICAgICAgICAgICAgICAnKFRpcDogdG8gZ2V0IGEgdXNlZnVsIHN0YWNrIHRyYWNlLCB1c2UgJyArXG4gICAgICAgICAgICAgICdQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoLi4uKSkgaW5zdGVhZCBvZiBQcm9taXNlLnJlamVjdCgnICtcbiAgICAgICAgICAgICAgKGVycm9yID8gJy4uLicgOiAnJykgK1xuICAgICAgICAgICAgICAnKS4pJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihzdWJzdGl0dXRlTXNnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYW5kbGVyID0gaGFuZGxlcnNbaGFuZGxlcnMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICBoYW5kbGVyKGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLm9yaWdpbmFsSGFuZGxlcnNbZXJyb3JUeXBlXSA9IGdsb2JhbC5wcm9jZXNzLmxpc3RlbmVycyhlcnJvclR5cGUpO1xuICAgICAgdGhpcy5qYXNtaW5lSGFuZGxlcnNbZXJyb3JUeXBlXSA9IHRhZ2dlZE9uRXJyb3I7XG5cbiAgICAgIGdsb2JhbC5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyhlcnJvclR5cGUpO1xuICAgICAgZ2xvYmFsLnByb2Nlc3Mub24oZXJyb3JUeXBlLCB0YWdnZWRPbkVycm9yKTtcblxuICAgICAgdGhpcy51bmluc3RhbGwgPSBmdW5jdGlvbiB1bmluc3RhbGwoKSB7XG4gICAgICAgIHZhciBlcnJvclR5cGVzID0gT2JqZWN0LmtleXModGhpcy5vcmlnaW5hbEhhbmRsZXJzKTtcbiAgICAgICAgZm9yICh2YXIgaVR5cGUgPSAwOyBpVHlwZSA8IGVycm9yVHlwZXMubGVuZ3RoOyBpVHlwZSsrKSB7XG4gICAgICAgICAgdmFyIGVycm9yVHlwZSA9IGVycm9yVHlwZXNbaVR5cGVdO1xuICAgICAgICAgIGdsb2JhbC5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyKFxuICAgICAgICAgICAgZXJyb3JUeXBlLFxuICAgICAgICAgICAgdGhpcy5qYXNtaW5lSGFuZGxlcnNbZXJyb3JUeXBlXVxuICAgICAgICAgICk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9yaWdpbmFsSGFuZGxlcnNbZXJyb3JUeXBlXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZ2xvYmFsLnByb2Nlc3Mub24oZXJyb3JUeXBlLCB0aGlzLm9yaWdpbmFsSGFuZGxlcnNbZXJyb3JUeXBlXVtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSB0aGlzLm9yaWdpbmFsSGFuZGxlcnNbZXJyb3JUeXBlXTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5qYXNtaW5lSGFuZGxlcnNbZXJyb3JUeXBlXTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdGhpcy5pbnN0YWxsID0gZnVuY3Rpb24gaW5zdGFsbCgpIHtcbiAgICAgIGlmIChcbiAgICAgICAgZ2xvYmFsLnByb2Nlc3MgJiZcbiAgICAgICAgZ2xvYmFsLnByb2Nlc3MubGlzdGVuZXJzICYmXG4gICAgICAgIGokLmlzRnVuY3Rpb25fKGdsb2JhbC5wcm9jZXNzLm9uKVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuaW5zdGFsbE9uZV8oJ3VuY2F1Z2h0RXhjZXB0aW9uJywgJ1VuY2F1Z2h0IGV4Y2VwdGlvbicpO1xuICAgICAgICB0aGlzLmluc3RhbGxPbmVfKCd1bmhhbmRsZWRSZWplY3Rpb24nLCAnVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3JpZ2luYWxIYW5kbGVyID0gZ2xvYmFsLm9uZXJyb3I7XG4gICAgICAgIGdsb2JhbC5vbmVycm9yID0gb25lcnJvcjtcblxuICAgICAgICB2YXIgYnJvd3NlclJlamVjdGlvbkhhbmRsZXIgPSBmdW5jdGlvbiBicm93c2VyUmVqZWN0aW9uSGFuZGxlcihldmVudCkge1xuICAgICAgICAgIGlmIChqJC5pc0Vycm9yXyhldmVudC5yZWFzb24pKSB7XG4gICAgICAgICAgICBldmVudC5yZWFzb24uamFzbWluZU1lc3NhZ2UgPVxuICAgICAgICAgICAgICAnVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uOiAnICsgZXZlbnQucmVhc29uO1xuICAgICAgICAgICAgZ2xvYmFsLm9uZXJyb3IoZXZlbnQucmVhc29uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLm9uZXJyb3IoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbjogJyArIGV2ZW50LnJlYXNvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgJ3VuaGFuZGxlZHJlamVjdGlvbicsXG4gICAgICAgICAgICBicm93c2VyUmVqZWN0aW9uSGFuZGxlclxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVuaW5zdGFsbCA9IGZ1bmN0aW9uIHVuaW5zdGFsbCgpIHtcbiAgICAgICAgICBnbG9iYWwub25lcnJvciA9IG9yaWdpbmFsSGFuZGxlcjtcbiAgICAgICAgICBpZiAoZ2xvYmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgICAndW5oYW5kbGVkcmVqZWN0aW9uJyxcbiAgICAgICAgICAgICAgYnJvd3NlclJlamVjdGlvbkhhbmRsZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnB1c2hMaXN0ZW5lciA9IGZ1bmN0aW9uIHB1c2hMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgaGFuZGxlcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfTtcblxuICAgIHRoaXMucG9wTGlzdGVuZXIgPSBmdW5jdGlvbiBwb3BMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgaWYgKCFsaXN0ZW5lcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvcExpc3RlbmVyIGV4cGVjdHMgYSBsaXN0ZW5lcicpO1xuICAgICAgfVxuXG4gICAgICBoYW5kbGVycy5wb3AoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIEdsb2JhbEVycm9ycztcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZVBlbmRpbmcgPSBmdW5jdGlvbihqJCkge1xuICAvKipcbiAgICogRXhwZWN0IGEgcHJvbWlzZSB0byBiZSBwZW5kaW5nLCBpLmUuIHRoZSBwcm9taXNlIGlzIG5laXRoZXIgcmVzb2x2ZWQgbm9yIHJlamVjdGVkLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQGFzeW5jXG4gICAqIEBuYW1lIGFzeW5jLW1hdGNoZXJzI3RvQmVQZW5kaW5nXG4gICAqIEBzaW5jZSAzLjZcbiAgICogQGV4YW1wbGVcbiAgICogYXdhaXQgZXhwZWN0QXN5bmMoYVByb21pc2UpLnRvQmVQZW5kaW5nKCk7XG4gICAqL1xuICByZXR1cm4gZnVuY3Rpb24gdG9CZVBlbmRpbmcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCkge1xuICAgICAgICBpZiAoIWokLmlzUHJvbWlzZUxpa2UoYWN0dWFsKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG9CZVBlbmRpbmcgdG8gYmUgY2FsbGVkIG9uIGEgcHJvbWlzZS4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2FudCA9IHt9O1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFthY3R1YWwsIFByb21pc2UucmVzb2x2ZSh3YW50KV0pLnRoZW4oXG4gICAgICAgICAgZnVuY3Rpb24oZ290KSB7XG4gICAgICAgICAgICByZXR1cm4geyBwYXNzOiB3YW50ID09PSBnb3QgfTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcGFzczogZmFsc2UgfTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZVJlamVjdGVkID0gZnVuY3Rpb24oaiQpIHtcbiAgLyoqXG4gICAqIEV4cGVjdCBhIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAYXN5bmNcbiAgICogQG5hbWUgYXN5bmMtbWF0Y2hlcnMjdG9CZVJlamVjdGVkXG4gICAqIEBzaW5jZSAzLjEuMFxuICAgKiBAZXhhbXBsZVxuICAgKiBhd2FpdCBleHBlY3RBc3luYyhhUHJvbWlzZSkudG9CZVJlamVjdGVkKCk7XG4gICAqIEBleGFtcGxlXG4gICAqIHJldHVybiBleHBlY3RBc3luYyhhUHJvbWlzZSkudG9CZVJlamVjdGVkKCk7XG4gICAqL1xuICByZXR1cm4gZnVuY3Rpb24gdG9CZVJlamVjdGVkKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwpIHtcbiAgICAgICAgaWYgKCFqJC5pc1Byb21pc2VMaWtlKGFjdHVhbCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvQmVSZWplY3RlZCB0byBiZSBjYWxsZWQgb24gYSBwcm9taXNlLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY3R1YWwudGhlbihcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHBhc3M6IGZhbHNlIH07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHBhc3M6IHRydWUgfTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZVJlamVjdGVkV2l0aCA9IGZ1bmN0aW9uKGokKSB7XG4gIC8qKlxuICAgKiBFeHBlY3QgYSBwcm9taXNlIHRvIGJlIHJlamVjdGVkIHdpdGggYSB2YWx1ZSBlcXVhbCB0byB0aGUgZXhwZWN0ZWQsIHVzaW5nIGRlZXAgZXF1YWxpdHkgY29tcGFyaXNvbi5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBhc3luY1xuICAgKiBAbmFtZSBhc3luYy1tYXRjaGVycyN0b0JlUmVqZWN0ZWRXaXRoXG4gICAqIEBzaW5jZSAzLjMuMFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXhwZWN0ZWQgLSBWYWx1ZSB0aGF0IHRoZSBwcm9taXNlIGlzIGV4cGVjdGVkIHRvIGJlIHJlamVjdGVkIHdpdGhcbiAgICogQGV4YW1wbGVcbiAgICogYXdhaXQgZXhwZWN0QXN5bmMoYVByb21pc2UpLnRvQmVSZWplY3RlZFdpdGgoe3Byb3A6ICd2YWx1ZSd9KTtcbiAgICogQGV4YW1wbGVcbiAgICogcmV0dXJuIGV4cGVjdEFzeW5jKGFQcm9taXNlKS50b0JlUmVqZWN0ZWRXaXRoKHtwcm9wOiAndmFsdWUnfSk7XG4gICAqL1xuICByZXR1cm4gZnVuY3Rpb24gdG9CZVJlamVjdGVkV2l0aChtYXRjaGVyc1V0aWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsUHJvbWlzZSwgZXhwZWN0ZWRWYWx1ZSkge1xuICAgICAgICBpZiAoIWokLmlzUHJvbWlzZUxpa2UoYWN0dWFsUHJvbWlzZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnRXhwZWN0ZWQgdG9CZVJlamVjdGVkV2l0aCB0byBiZSBjYWxsZWQgb24gYSBwcm9taXNlLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcHJlZml4KHBhc3NlZCkge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAnRXhwZWN0ZWQgYSBwcm9taXNlICcgK1xuICAgICAgICAgICAgKHBhc3NlZCA/ICdub3QgJyA6ICcnKSArXG4gICAgICAgICAgICAndG8gYmUgcmVqZWN0ZWQgd2l0aCAnICtcbiAgICAgICAgICAgIG1hdGNoZXJzVXRpbC5wcChleHBlY3RlZFZhbHVlKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWN0dWFsUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcGFzczogZmFsc2UsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IHByZWZpeChmYWxzZSkgKyAnIGJ1dCBpdCB3YXMgcmVzb2x2ZWQuJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGFjdHVhbFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2hlcnNVdGlsLmVxdWFscyhhY3R1YWxWYWx1ZSwgZXhwZWN0ZWRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwYXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHByZWZpeCh0cnVlKSArICcuJ1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwYXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgICAgICAgcHJlZml4KGZhbHNlKSArXG4gICAgICAgICAgICAgICAgICAnIGJ1dCBpdCB3YXMgcmVqZWN0ZWQgd2l0aCAnICtcbiAgICAgICAgICAgICAgICAgIG1hdGNoZXJzVXRpbC5wcChhY3R1YWxWYWx1ZSkgK1xuICAgICAgICAgICAgICAgICAgJy4nXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVSZWplY3RlZFdpdGhFcnJvciA9IGZ1bmN0aW9uKGokKSB7XG4gIC8qKlxuICAgKiBFeHBlY3QgYSBwcm9taXNlIHRvIGJlIHJlamVjdGVkIHdpdGggYSB2YWx1ZSBtYXRjaGVkIHRvIHRoZSBleHBlY3RlZFxuICAgKiBAZnVuY3Rpb25cbiAgICogQGFzeW5jXG4gICAqIEBuYW1lIGFzeW5jLW1hdGNoZXJzI3RvQmVSZWplY3RlZFdpdGhFcnJvclxuICAgKiBAc2luY2UgMy41LjBcbiAgICogQHBhcmFtIHtFcnJvcn0gW2V4cGVjdGVkXSAtIGBFcnJvcmAgY29uc3RydWN0b3IgdGhlIG9iamVjdCB0aGF0IHdhcyB0aHJvd24gbmVlZHMgdG8gYmUgYW4gaW5zdGFuY2Ugb2YuIElmIG5vdCBwcm92aWRlZCwgYEVycm9yYCB3aWxsIGJlIHVzZWQuXG4gICAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gW21lc3NhZ2VdIC0gVGhlIG1lc3NhZ2UgdGhhdCBzaG91bGQgYmUgc2V0IG9uIHRoZSB0aHJvd24gYEVycm9yYFxuICAgKiBAZXhhbXBsZVxuICAgKiBhd2FpdCBleHBlY3RBc3luYyhhUHJvbWlzZSkudG9CZVJlamVjdGVkV2l0aEVycm9yKE15Q3VzdG9tRXJyb3IsICdFcnJvciBtZXNzYWdlJyk7XG4gICAqIGF3YWl0IGV4cGVjdEFzeW5jKGFQcm9taXNlKS50b0JlUmVqZWN0ZWRXaXRoRXJyb3IoTXlDdXN0b21FcnJvciwgL0Vycm9yIG1lc3NhZ2UvKTtcbiAgICogYXdhaXQgZXhwZWN0QXN5bmMoYVByb21pc2UpLnRvQmVSZWplY3RlZFdpdGhFcnJvcihNeUN1c3RvbUVycm9yKTtcbiAgICogYXdhaXQgZXhwZWN0QXN5bmMoYVByb21pc2UpLnRvQmVSZWplY3RlZFdpdGhFcnJvcignRXJyb3IgbWVzc2FnZScpO1xuICAgKiByZXR1cm4gZXhwZWN0QXN5bmMoYVByb21pc2UpLnRvQmVSZWplY3RlZFdpdGhFcnJvcigvRXJyb3IgbWVzc2FnZS8pO1xuICAgKi9cbiAgcmV0dXJuIGZ1bmN0aW9uIHRvQmVSZWplY3RlZFdpdGhFcnJvcihtYXRjaGVyc1V0aWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsUHJvbWlzZSwgYXJnMSwgYXJnMikge1xuICAgICAgICBpZiAoIWokLmlzUHJvbWlzZUxpa2UoYWN0dWFsUHJvbWlzZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnRXhwZWN0ZWQgdG9CZVJlamVjdGVkV2l0aEVycm9yIHRvIGJlIGNhbGxlZCBvbiBhIHByb21pc2UuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXhwZWN0ZWQgPSBnZXRFeHBlY3RlZEZyb21BcmdzKGFyZzEsIGFyZzIsIG1hdGNoZXJzVXRpbCk7XG5cbiAgICAgICAgcmV0dXJuIGFjdHVhbFByb21pc2UudGhlbihcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHBhc3M6IGZhbHNlLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnRXhwZWN0ZWQgYSBwcm9taXNlIHRvIGJlIHJlamVjdGVkIGJ1dCBpdCB3YXMgcmVzb2x2ZWQuJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGFjdHVhbFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hFcnJvcihhY3R1YWxWYWx1ZSwgZXhwZWN0ZWQsIG1hdGNoZXJzVXRpbCk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gbWF0Y2hFcnJvcihhY3R1YWwsIGV4cGVjdGVkLCBtYXRjaGVyc1V0aWwpIHtcbiAgICBpZiAoIWokLmlzRXJyb3JfKGFjdHVhbCkpIHtcbiAgICAgIHJldHVybiBmYWlsKGV4cGVjdGVkLCAncmVqZWN0ZWQgd2l0aCAnICsgbWF0Y2hlcnNVdGlsLnBwKGFjdHVhbCkpO1xuICAgIH1cblxuICAgIGlmICghKGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkLmVycm9yKSkge1xuICAgICAgcmV0dXJuIGZhaWwoXG4gICAgICAgIGV4cGVjdGVkLFxuICAgICAgICAncmVqZWN0ZWQgd2l0aCB0eXBlICcgKyBqJC5mbk5hbWVGb3IoYWN0dWFsLmNvbnN0cnVjdG9yKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgYWN0dWFsTWVzc2FnZSA9IGFjdHVhbC5tZXNzYWdlO1xuXG4gICAgaWYgKFxuICAgICAgYWN0dWFsTWVzc2FnZSA9PT0gZXhwZWN0ZWQubWVzc2FnZSB8fFxuICAgICAgdHlwZW9mIGV4cGVjdGVkLm1lc3NhZ2UgPT09ICd1bmRlZmluZWQnXG4gICAgKSB7XG4gICAgICByZXR1cm4gcGFzcyhleHBlY3RlZCk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgZXhwZWN0ZWQubWVzc2FnZSBpbnN0YW5jZW9mIFJlZ0V4cCAmJlxuICAgICAgZXhwZWN0ZWQubWVzc2FnZS50ZXN0KGFjdHVhbE1lc3NhZ2UpXG4gICAgKSB7XG4gICAgICByZXR1cm4gcGFzcyhleHBlY3RlZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhaWwoZXhwZWN0ZWQsICdyZWplY3RlZCB3aXRoICcgKyBtYXRjaGVyc1V0aWwucHAoYWN0dWFsKSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXNzKGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhc3M6IHRydWUsXG4gICAgICBtZXNzYWdlOlxuICAgICAgICAnRXhwZWN0ZWQgYSBwcm9taXNlIG5vdCB0byBiZSByZWplY3RlZCB3aXRoICcgK1xuICAgICAgICBleHBlY3RlZC5wcmludFZhbHVlICtcbiAgICAgICAgJywgYnV0IGl0IHdhcy4nXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZhaWwoZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGFzczogZmFsc2UsXG4gICAgICBtZXNzYWdlOlxuICAgICAgICAnRXhwZWN0ZWQgYSBwcm9taXNlIHRvIGJlIHJlamVjdGVkIHdpdGggJyArXG4gICAgICAgIGV4cGVjdGVkLnByaW50VmFsdWUgK1xuICAgICAgICAnIGJ1dCBpdCB3YXMgJyArXG4gICAgICAgIG1lc3NhZ2UgK1xuICAgICAgICAnLidcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RXhwZWN0ZWRGcm9tQXJncyhhcmcxLCBhcmcyLCBtYXRjaGVyc1V0aWwpIHtcbiAgICB2YXIgZXJyb3IsIG1lc3NhZ2U7XG5cbiAgICBpZiAoaXNFcnJvckNvbnN0cnVjdG9yKGFyZzEpKSB7XG4gICAgICBlcnJvciA9IGFyZzE7XG4gICAgICBtZXNzYWdlID0gYXJnMjtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3IgPSBFcnJvcjtcbiAgICAgIG1lc3NhZ2UgPSBhcmcxO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogZXJyb3IsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgcHJpbnRWYWx1ZTpcbiAgICAgICAgaiQuZm5OYW1lRm9yKGVycm9yKSArXG4gICAgICAgICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6ICc6ICcgKyBtYXRjaGVyc1V0aWwucHAobWVzc2FnZSkpXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRXJyb3JDb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHJldHVybiAoXG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICh2YWx1ZSA9PT0gRXJyb3IgfHwgaiQuaXNFcnJvcl8odmFsdWUucHJvdG90eXBlKSlcbiAgICApO1xuICB9XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVSZXNvbHZlZCA9IGZ1bmN0aW9uKGokKSB7XG4gIC8qKlxuICAgKiBFeHBlY3QgYSBwcm9taXNlIHRvIGJlIHJlc29sdmVkLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQGFzeW5jXG4gICAqIEBuYW1lIGFzeW5jLW1hdGNoZXJzI3RvQmVSZXNvbHZlZFxuICAgKiBAc2luY2UgMy4xLjBcbiAgICogQGV4YW1wbGVcbiAgICogYXdhaXQgZXhwZWN0QXN5bmMoYVByb21pc2UpLnRvQmVSZXNvbHZlZCgpO1xuICAgKiBAZXhhbXBsZVxuICAgKiByZXR1cm4gZXhwZWN0QXN5bmMoYVByb21pc2UpLnRvQmVSZXNvbHZlZCgpO1xuICAgKi9cbiAgcmV0dXJuIGZ1bmN0aW9uIHRvQmVSZXNvbHZlZChtYXRjaGVyc1V0aWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsKSB7XG4gICAgICAgIGlmICghaiQuaXNQcm9taXNlTGlrZShhY3R1YWwpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0b0JlUmVzb2x2ZWQgdG8gYmUgY2FsbGVkIG9uIGEgcHJvbWlzZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhY3R1YWwudGhlbihcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHBhc3M6IHRydWUgfTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHBhc3M6IGZhbHNlLFxuICAgICAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgICAgICdFeHBlY3RlZCBhIHByb21pc2UgdG8gYmUgcmVzb2x2ZWQgYnV0IGl0IHdhcyAnICtcbiAgICAgICAgICAgICAgICAncmVqZWN0ZWQgd2l0aCAnICtcbiAgICAgICAgICAgICAgICBtYXRjaGVyc1V0aWwucHAoZSkgK1xuICAgICAgICAgICAgICAgICcuJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZVJlc29sdmVkVG8gPSBmdW5jdGlvbihqJCkge1xuICAvKipcbiAgICogRXhwZWN0IGEgcHJvbWlzZSB0byBiZSByZXNvbHZlZCB0byBhIHZhbHVlIGVxdWFsIHRvIHRoZSBleHBlY3RlZCwgdXNpbmcgZGVlcCBlcXVhbGl0eSBjb21wYXJpc29uLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQGFzeW5jXG4gICAqIEBuYW1lIGFzeW5jLW1hdGNoZXJzI3RvQmVSZXNvbHZlZFRvXG4gICAqIEBzaW5jZSAzLjEuMFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXhwZWN0ZWQgLSBWYWx1ZSB0aGF0IHRoZSBwcm9taXNlIGlzIGV4cGVjdGVkIHRvIHJlc29sdmUgdG9cbiAgICogQGV4YW1wbGVcbiAgICogYXdhaXQgZXhwZWN0QXN5bmMoYVByb21pc2UpLnRvQmVSZXNvbHZlZFRvKHtwcm9wOiAndmFsdWUnfSk7XG4gICAqIEBleGFtcGxlXG4gICAqIHJldHVybiBleHBlY3RBc3luYyhhUHJvbWlzZSkudG9CZVJlc29sdmVkVG8oe3Byb3A6ICd2YWx1ZSd9KTtcbiAgICovXG4gIHJldHVybiBmdW5jdGlvbiB0b0JlUmVzb2x2ZWRUbyhtYXRjaGVyc1V0aWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsUHJvbWlzZSwgZXhwZWN0ZWRWYWx1ZSkge1xuICAgICAgICBpZiAoIWokLmlzUHJvbWlzZUxpa2UoYWN0dWFsUHJvbWlzZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvQmVSZXNvbHZlZFRvIHRvIGJlIGNhbGxlZCBvbiBhIHByb21pc2UuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwcmVmaXgocGFzc2VkKSB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICdFeHBlY3RlZCBhIHByb21pc2UgJyArXG4gICAgICAgICAgICAocGFzc2VkID8gJ25vdCAnIDogJycpICtcbiAgICAgICAgICAgICd0byBiZSByZXNvbHZlZCB0byAnICtcbiAgICAgICAgICAgIG1hdGNoZXJzVXRpbC5wcChleHBlY3RlZFZhbHVlKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWN0dWFsUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGZ1bmN0aW9uKGFjdHVhbFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2hlcnNVdGlsLmVxdWFscyhhY3R1YWxWYWx1ZSwgZXhwZWN0ZWRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwYXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHByZWZpeCh0cnVlKSArICcuJ1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwYXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgICAgICAgcHJlZml4KGZhbHNlKSArXG4gICAgICAgICAgICAgICAgICAnIGJ1dCBpdCB3YXMgcmVzb2x2ZWQgdG8gJyArXG4gICAgICAgICAgICAgICAgICBtYXRjaGVyc1V0aWwucHAoYWN0dWFsVmFsdWUpICtcbiAgICAgICAgICAgICAgICAgICcuJ1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcGFzczogZmFsc2UsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAgICAgcHJlZml4KGZhbHNlKSArXG4gICAgICAgICAgICAgICAgJyBidXQgaXQgd2FzIHJlamVjdGVkIHdpdGggJyArXG4gICAgICAgICAgICAgICAgbWF0Y2hlcnNVdGlsLnBwKGUpICtcbiAgICAgICAgICAgICAgICAnLidcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkRpZmZCdWlsZGVyID0gZnVuY3Rpb24oaiQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIERpZmZCdWlsZGVyKGNvbmZpZykge1xuICAgIHZhciBwcmV0dHlQcmludGVyID0gKGNvbmZpZyB8fCB7fSkucHJldHR5UHJpbnRlciB8fCBqJC5tYWtlUHJldHR5UHJpbnRlcigpLFxuICAgICAgbWlzbWF0Y2hlcyA9IG5ldyBqJC5NaXNtYXRjaFRyZWUoKSxcbiAgICAgIHBhdGggPSBuZXcgaiQuT2JqZWN0UGF0aCgpLFxuICAgICAgYWN0dWFsUm9vdCA9IHVuZGVmaW5lZCxcbiAgICAgIGV4cGVjdGVkUm9vdCA9IHVuZGVmaW5lZDtcblxuICAgIHJldHVybiB7XG4gICAgICBzZXRSb290czogZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICAgICAgICBhY3R1YWxSb290ID0gYWN0dWFsO1xuICAgICAgICBleHBlY3RlZFJvb3QgPSBleHBlY3RlZDtcbiAgICAgIH0sXG5cbiAgICAgIHJlY29yZE1pc21hdGNoOiBmdW5jdGlvbihmb3JtYXR0ZXIpIHtcbiAgICAgICAgbWlzbWF0Y2hlcy5hZGQocGF0aCwgZm9ybWF0dGVyKTtcbiAgICAgIH0sXG5cbiAgICAgIGdldE1lc3NhZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWVzc2FnZXMgPSBbXTtcblxuICAgICAgICBtaXNtYXRjaGVzLnRyYXZlcnNlKGZ1bmN0aW9uKHBhdGgsIGlzTGVhZiwgZm9ybWF0dGVyKSB7XG4gICAgICAgICAgdmFyIGFjdHVhbEN1c3RvbSxcbiAgICAgICAgICAgIGV4cGVjdGVkQ3VzdG9tLFxuICAgICAgICAgICAgdXNlQ3VzdG9tLFxuICAgICAgICAgICAgZGVyZWZSZXN1bHQgPSBkZXJlZmVyZW5jZVBhdGgoXG4gICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgIGFjdHVhbFJvb3QsXG4gICAgICAgICAgICAgIGV4cGVjdGVkUm9vdCxcbiAgICAgICAgICAgICAgcHJldHR5UHJpbnRlclxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGFjdHVhbCA9IGRlcmVmUmVzdWx0LmFjdHVhbCxcbiAgICAgICAgICAgIGV4cGVjdGVkID0gZGVyZWZSZXN1bHQuZXhwZWN0ZWQ7XG5cbiAgICAgICAgICBpZiAoZm9ybWF0dGVyKSB7XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKGZvcm1hdHRlcihhY3R1YWwsIGV4cGVjdGVkLCBwYXRoLCBwcmV0dHlQcmludGVyKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhY3R1YWxDdXN0b20gPSBwcmV0dHlQcmludGVyLmN1c3RvbUZvcm1hdF8oYWN0dWFsKTtcbiAgICAgICAgICBleHBlY3RlZEN1c3RvbSA9IHByZXR0eVByaW50ZXIuY3VzdG9tRm9ybWF0XyhleHBlY3RlZCk7XG4gICAgICAgICAgdXNlQ3VzdG9tID0gIShcbiAgICAgICAgICAgIGokLnV0aWwuaXNVbmRlZmluZWQoYWN0dWFsQ3VzdG9tKSAmJlxuICAgICAgICAgICAgaiQudXRpbC5pc1VuZGVmaW5lZChleHBlY3RlZEN1c3RvbSlcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKHVzZUN1c3RvbSkge1xuICAgICAgICAgICAgbWVzc2FnZXMucHVzaChcbiAgICAgICAgICAgICAgd3JhcFByZXR0eVByaW50ZWQoYWN0dWFsQ3VzdG9tLCBleHBlY3RlZEN1c3RvbSwgcGF0aClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGRvbid0IHJlY3Vyc2UgZnVydGhlclxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc0xlYWYpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goXG4gICAgICAgICAgICAgIGRlZmF1bHRGb3JtYXR0ZXIoYWN0dWFsLCBleHBlY3RlZCwgcGF0aCwgcHJldHR5UHJpbnRlcilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBtZXNzYWdlcy5qb2luKCdcXG4nKTtcbiAgICAgIH0sXG5cbiAgICAgIHdpdGhQYXRoOiBmdW5jdGlvbihwYXRoQ29tcG9uZW50LCBibG9jaykge1xuICAgICAgICB2YXIgb2xkUGF0aCA9IHBhdGg7XG4gICAgICAgIHBhdGggPSBwYXRoLmFkZChwYXRoQ29tcG9uZW50KTtcbiAgICAgICAgYmxvY2soKTtcbiAgICAgICAgcGF0aCA9IG9sZFBhdGg7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRGb3JtYXR0ZXIoYWN0dWFsLCBleHBlY3RlZCwgcGF0aCwgcHJldHR5UHJpbnRlcikge1xuICAgICAgcmV0dXJuIHdyYXBQcmV0dHlQcmludGVkKFxuICAgICAgICBwcmV0dHlQcmludGVyKGFjdHVhbCksXG4gICAgICAgIHByZXR0eVByaW50ZXIoZXhwZWN0ZWQpLFxuICAgICAgICBwYXRoXG4gICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdyYXBQcmV0dHlQcmludGVkKGFjdHVhbCwgZXhwZWN0ZWQsIHBhdGgpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgICdFeHBlY3RlZCAnICtcbiAgICAgICAgcGF0aCArXG4gICAgICAgIChwYXRoLmRlcHRoKCkgPyAnID0gJyA6ICcnKSArXG4gICAgICAgIGFjdHVhbCArXG4gICAgICAgICcgdG8gZXF1YWwgJyArXG4gICAgICAgIGV4cGVjdGVkICtcbiAgICAgICAgJy4nXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBkZXJlZmVyZW5jZVBhdGgob2JqZWN0UGF0aCwgYWN0dWFsLCBleHBlY3RlZCwgcHApIHtcbiAgICBmdW5jdGlvbiBoYW5kbGVBc3ltbWV0cmljRXhwZWN0ZWQoKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGokLmlzQXN5bW1ldHJpY0VxdWFsaXR5VGVzdGVyXyhleHBlY3RlZCkgJiZcbiAgICAgICAgaiQuaXNGdW5jdGlvbl8oZXhwZWN0ZWQudmFsdWVzRm9yRGlmZl8pXG4gICAgICApIHtcbiAgICAgICAgdmFyIGFzeW1tZXRyaWNSZXN1bHQgPSBleHBlY3RlZC52YWx1ZXNGb3JEaWZmXyhhY3R1YWwsIHBwKTtcbiAgICAgICAgZXhwZWN0ZWQgPSBhc3ltbWV0cmljUmVzdWx0LnNlbGY7XG4gICAgICAgIGFjdHVhbCA9IGFzeW1tZXRyaWNSZXN1bHQub3RoZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgaGFuZGxlQXN5bW1ldHJpY0V4cGVjdGVkKCk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgb2JqZWN0UGF0aC5jb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3R1YWwgPSBhY3R1YWxbb2JqZWN0UGF0aC5jb21wb25lbnRzW2ldXTtcbiAgICAgIGV4cGVjdGVkID0gZXhwZWN0ZWRbb2JqZWN0UGF0aC5jb21wb25lbnRzW2ldXTtcbiAgICAgIGhhbmRsZUFzeW1tZXRyaWNFeHBlY3RlZCgpO1xuICAgIH1cblxuICAgIHJldHVybiB7IGFjdHVhbDogYWN0dWFsLCBleHBlY3RlZDogZXhwZWN0ZWQgfTtcbiAgfVxufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5NYXRjaGVyc1V0aWwgPSBmdW5jdGlvbihqJCkge1xuICAvKipcbiAgICogQGNsYXNzIE1hdGNoZXJzVXRpbFxuICAgKiBAY2xhc3NkZXNjIFV0aWxpdGllcyBmb3IgdXNlIGluIGltcGxlbWVudGluZyBtYXRjaGVycy48YnI+XG4gICAqIF9Ob3RlOl8gRG8gbm90IGNvbnN0cnVjdCB0aGlzIGRpcmVjdGx5LiBKYXNtaW5lIHdpbGwgY29uc3RydWN0IG9uZSBhbmRcbiAgICogcGFzcyBpdCB0byBtYXRjaGVycyBhbmQgYXN5bW1ldHJpYyBlcXVhbGl0eSB0ZXN0ZXJzLlxuICAgKiBAaGlkZWNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBNYXRjaGVyc1V0aWwob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuY3VzdG9tVGVzdGVyc18gPSBvcHRpb25zLmN1c3RvbVRlc3RlcnMgfHwgW107XG4gICAgLyoqXG4gICAgICogRm9ybWF0cyBhIHZhbHVlIGZvciB1c2UgaW4gbWF0Y2hlciBmYWlsdXJlIG1lc3NhZ2VzIGFuZCBzaW1pbGFyIGNvbnRleHRzLFxuICAgICAqIHRha2luZyBpbnRvIGFjY291bnQgdGhlIGN1cnJlbnQgc2V0IG9mIGN1c3RvbSB2YWx1ZSBmb3JtYXR0ZXJzLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBuYW1lIE1hdGNoZXJzVXRpbCNwcFxuICAgICAqIEBzaW5jZSAzLjYuMFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByZXR0eS1wcmludFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHByZXR0eS1wcmludGVkIHZhbHVlXG4gICAgICovXG4gICAgdGhpcy5wcCA9IG9wdGlvbnMucHAgfHwgZnVuY3Rpb24oKSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYGhheXN0YWNrYCBjb250YWlucyBgbmVlZGxlYCwgdXNpbmcgdGhlIHNhbWUgY29tcGFyaXNvblxuICAgKiBsb2dpYyBhcyB7QGxpbmsgTWF0Y2hlcnNVdGlsI2VxdWFsc30uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBNYXRjaGVyc1V0aWwjY29udGFpbnNcbiAgICogQHNpbmNlIDIuMC4wXG4gICAqIEBwYXJhbSB7Kn0gaGF5c3RhY2sgVGhlIGNvbGxlY3Rpb24gdG8gc2VhcmNoXG4gICAqIEBwYXJhbSB7Kn0gbmVlZGxlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGBuZWVkbGVgIHdhcyBmb3VuZCBpbiBgaGF5c3RhY2tgXG4gICAqL1xuICBNYXRjaGVyc1V0aWwucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24oaGF5c3RhY2ssIG5lZWRsZSkge1xuICAgIGlmICghaGF5c3RhY2spIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaiQuaXNTZXQoaGF5c3RhY2spKSB7XG4gICAgICAvLyBUcnkgLmhhcygpIGZpcnN0LiBJdCBzaG91bGQgYmUgZmFzdGVyIGluIGNhc2VzIHdoZXJlXG4gICAgICAvLyBuZWVkbGUgPT09IHNvbWV0aGluZyBpbiBoYXlzdGFjay4gRmFsbCBiYWNrIHRvIC5lcXVhbHMoKSBjb21wYXJpc29uXG4gICAgICAvLyBpZiB0aGF0IGZhaWxzLlxuICAgICAgaWYgKGhheXN0YWNrLmhhcyhuZWVkbGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChqJC5pc0l0ZXJhYmxlXyhoYXlzdGFjaykgJiYgIWokLmlzU3RyaW5nXyhoYXlzdGFjaykpIHtcbiAgICAgIC8vIEFycmF5cywgU2V0cywgZXRjLlxuICAgICAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgaGF5c3RhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuZXF1YWxzKGNhbmRpZGF0ZSwgbmVlZGxlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaGF5c3RhY2suaW5kZXhPZikge1xuICAgICAgLy8gTWFpbmx5IHN0cmluZ3NcbiAgICAgIHJldHVybiBoYXlzdGFjay5pbmRleE9mKG5lZWRsZSkgPj0gMDtcbiAgICB9XG5cbiAgICBpZiAoaiQuaXNOdW1iZXJfKGhheXN0YWNrLmxlbmd0aCkpIHtcbiAgICAgIC8vIE9iamVjdHMgdGhhdCBhcmUgc2hhcGVkIGxpa2UgYXJyYXlzIGJ1dCBhcmVuJ3QgaXRlcmFibGVcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGF5c3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuZXF1YWxzKGhheXN0YWNrW2ldLCBuZWVkbGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgTWF0Y2hlcnNVdGlsLnByb3RvdHlwZS5idWlsZEZhaWx1cmVNZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSxcbiAgICAgIG1hdGNoZXJOYW1lID0gYXJnc1swXSxcbiAgICAgIGlzTm90ID0gYXJnc1sxXSxcbiAgICAgIGFjdHVhbCA9IGFyZ3NbMl0sXG4gICAgICBleHBlY3RlZCA9IGFyZ3Muc2xpY2UoMyksXG4gICAgICBlbmdsaXNoeVByZWRpY2F0ZSA9IG1hdGNoZXJOYW1lLnJlcGxhY2UoL1tBLVpdL2csIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuICcgJyArIHMudG9Mb3dlckNhc2UoKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIG1lc3NhZ2UgPVxuICAgICAgJ0V4cGVjdGVkICcgK1xuICAgICAgc2VsZi5wcChhY3R1YWwpICtcbiAgICAgIChpc05vdCA/ICcgbm90ICcgOiAnICcpICtcbiAgICAgIGVuZ2xpc2h5UHJlZGljYXRlO1xuXG4gICAgaWYgKGV4cGVjdGVkLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgbWVzc2FnZSArPSAnLCc7XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZSArPSAnICcgKyBzZWxmLnBwKGV4cGVjdGVkW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWVzc2FnZSArICcuJztcbiAgfTtcblxuICBNYXRjaGVyc1V0aWwucHJvdG90eXBlLmFzeW1tZXRyaWNEaWZmXyA9IGZ1bmN0aW9uKFxuICAgIGEsXG4gICAgYixcbiAgICBhU3RhY2ssXG4gICAgYlN0YWNrLFxuICAgIGRpZmZCdWlsZGVyXG4gICkge1xuICAgIGlmIChqJC5pc0Z1bmN0aW9uXyhiLnZhbHVlc0ZvckRpZmZfKSkge1xuICAgICAgdmFyIHZhbHVlcyA9IGIudmFsdWVzRm9yRGlmZl8oYSwgdGhpcy5wcCk7XG4gICAgICB0aGlzLmVxXyh2YWx1ZXMub3RoZXIsIHZhbHVlcy5zZWxmLCBhU3RhY2ssIGJTdGFjaywgZGlmZkJ1aWxkZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaWZmQnVpbGRlci5yZWNvcmRNaXNtYXRjaCgpO1xuICAgIH1cbiAgfTtcblxuICBNYXRjaGVyc1V0aWwucHJvdG90eXBlLmFzeW1tZXRyaWNNYXRjaF8gPSBmdW5jdGlvbihcbiAgICBhLFxuICAgIGIsXG4gICAgYVN0YWNrLFxuICAgIGJTdGFjayxcbiAgICBkaWZmQnVpbGRlclxuICApIHtcbiAgICB2YXIgYXN5bW1ldHJpY0EgPSBqJC5pc0FzeW1tZXRyaWNFcXVhbGl0eVRlc3Rlcl8oYSksXG4gICAgICBhc3ltbWV0cmljQiA9IGokLmlzQXN5bW1ldHJpY0VxdWFsaXR5VGVzdGVyXyhiKSxcbiAgICAgIHJlc3VsdDtcblxuICAgIGlmIChhc3ltbWV0cmljQSA9PT0gYXN5bW1ldHJpY0IpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGFzeW1tZXRyaWNBKSB7XG4gICAgICByZXN1bHQgPSBhLmFzeW1tZXRyaWNNYXRjaChiLCB0aGlzKTtcbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIGRpZmZCdWlsZGVyLnJlY29yZE1pc21hdGNoKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGlmIChhc3ltbWV0cmljQikge1xuICAgICAgcmVzdWx0ID0gYi5hc3ltbWV0cmljTWF0Y2goYSwgdGhpcyk7XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICB0aGlzLmFzeW1tZXRyaWNEaWZmXyhhLCBiLCBhU3RhY2ssIGJTdGFjaywgZGlmZkJ1aWxkZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciB0d28gdmFsdWVzIGFyZSBkZWVwbHkgZXF1YWwgdG8gZWFjaCBvdGhlci5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIE1hdGNoZXJzVXRpbCNlcXVhbHNcbiAgICogQHNpbmNlIDIuMC4wXG4gICAqIEBwYXJhbSB7Kn0gYSBUaGUgZmlyc3QgdmFsdWUgdG8gY29tcGFyZVxuICAgKiBAcGFyYW0geyp9IGIgVGhlIHNlY29uZCB2YWx1ZSB0byBjb21wYXJlXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWFsXG4gICAqL1xuICBNYXRjaGVyc1V0aWwucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKGEsIGIsIGRpZmZCdWlsZGVyKSB7XG4gICAgZGlmZkJ1aWxkZXIgPSBkaWZmQnVpbGRlciB8fCBqJC5OdWxsRGlmZkJ1aWxkZXIoKTtcbiAgICBkaWZmQnVpbGRlci5zZXRSb290cyhhLCBiKTtcblxuICAgIHJldHVybiB0aGlzLmVxXyhhLCBiLCBbXSwgW10sIGRpZmZCdWlsZGVyKTtcbiAgfTtcblxuICAvLyBFcXVhbGl0eSBmdW5jdGlvbiBsb3ZpbmdseSBhZGFwdGVkIGZyb20gaXNFcXVhbCBpblxuICAvLyAgIFtVbmRlcnNjb3JlXShodHRwOi8vdW5kZXJzY29yZWpzLm9yZylcbiAgTWF0Y2hlcnNVdGlsLnByb3RvdHlwZS5lcV8gPSBmdW5jdGlvbihhLCBiLCBhU3RhY2ssIGJTdGFjaywgZGlmZkJ1aWxkZXIpIHtcbiAgICB2YXIgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgaTtcblxuICAgIHZhciBhc3ltbWV0cmljUmVzdWx0ID0gdGhpcy5hc3ltbWV0cmljTWF0Y2hfKFxuICAgICAgYSxcbiAgICAgIGIsXG4gICAgICBhU3RhY2ssXG4gICAgICBiU3RhY2ssXG4gICAgICBkaWZmQnVpbGRlclxuICAgICk7XG4gICAgaWYgKCFqJC51dGlsLmlzVW5kZWZpbmVkKGFzeW1tZXRyaWNSZXN1bHQpKSB7XG4gICAgICByZXR1cm4gYXN5bW1ldHJpY1Jlc3VsdDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5jdXN0b21UZXN0ZXJzXy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGN1c3RvbVRlc3RlclJlc3VsdCA9IHRoaXMuY3VzdG9tVGVzdGVyc19baV0oYSwgYik7XG4gICAgICBpZiAoIWokLnV0aWwuaXNVbmRlZmluZWQoY3VzdG9tVGVzdGVyUmVzdWx0KSkge1xuICAgICAgICBpZiAoIWN1c3RvbVRlc3RlclJlc3VsdCkge1xuICAgICAgICAgIGRpZmZCdWlsZGVyLnJlY29yZE1pc21hdGNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1c3RvbVRlc3RlclJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIEVycm9yICYmIGIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgcmVzdWx0ID0gYS5tZXNzYWdlID09IGIubWVzc2FnZTtcbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIGRpZmZCdWlsZGVyLnJlY29yZE1pc21hdGNoKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIElkZW50aWNhbCBvYmplY3RzIGFyZSBlcXVhbC4gYDAgPT09IC0wYCwgYnV0IHRoZXkgYXJlbid0IGlkZW50aWNhbC5cbiAgICAvLyBTZWUgdGhlIFtIYXJtb255IGBlZ2FsYCBwcm9wb3NhbF0oaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTplZ2FsKS5cbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgcmVzdWx0ID0gYSAhPT0gMCB8fCAxIC8gYSA9PSAxIC8gYjtcbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIGRpZmZCdWlsZGVyLnJlY29yZE1pc21hdGNoKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBBIHN0cmljdCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGBudWxsID09IHVuZGVmaW5lZGAuXG4gICAgaWYgKGEgPT09IG51bGwgfHwgYiA9PT0gbnVsbCkge1xuICAgICAgcmVzdWx0ID0gYSA9PT0gYjtcbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIGRpZmZCdWlsZGVyLnJlY29yZE1pc21hdGNoKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB2YXIgY2xhc3NOYW1lID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpO1xuICAgIGlmIChjbGFzc05hbWUgIT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGIpKSB7XG4gICAgICBkaWZmQnVpbGRlci5yZWNvcmRNaXNtYXRjaCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgIHJlc3VsdCA9IGEgPT0gU3RyaW5nKGIpO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgIGRpZmZCdWlsZGVyLnJlY29yZE1pc21hdGNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3JcbiAgICAgICAgLy8gb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgYSAhPSArYSA/IGIgIT0gK2IgOiBhID09PSAwICYmIGIgPT09IDAgPyAxIC8gYSA9PSAxIC8gYiA6IGEgPT0gK2I7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkTWlzbWF0Y2goKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcbiAgICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1lcmljIHByaW1pdGl2ZSB2YWx1ZXMuIERhdGVzIGFyZSBjb21wYXJlZCBieSB0aGVpclxuICAgICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXG4gICAgICAgIC8vIG9mIGBOYU5gIGFyZSBub3QgZXF1aXZhbGVudC5cbiAgICAgICAgcmVzdWx0ID0gK2EgPT0gK2I7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkTWlzbWF0Y2goKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgY2FzZSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nOlxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGFuIGluc3RhbmNlIG9mIEFycmF5QnVmZmVyIHRoZSBVaW50OEFycmF5IGN0b3JcbiAgICAgICAgLy8gd2lsbCBiZSBkZWZpbmVkIGFzIHdlbGxcbiAgICAgICAgcmV0dXJuIHNlbGYuZXFfKFxuICAgICAgICAgIG5ldyBVaW50OEFycmF5KGEpLFxuICAgICAgICAgIG5ldyBVaW50OEFycmF5KGIpLFxuICAgICAgICAgIGFTdGFjayxcbiAgICAgICAgICBiU3RhY2ssXG4gICAgICAgICAgZGlmZkJ1aWxkZXJcbiAgICAgICAgKTtcbiAgICAgIC8vIFJlZ0V4cHMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyIHNvdXJjZSBwYXR0ZXJucyBhbmQgZmxhZ3MuXG4gICAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOlxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGEuc291cmNlID09IGIuc291cmNlICYmXG4gICAgICAgICAgYS5nbG9iYWwgPT0gYi5nbG9iYWwgJiZcbiAgICAgICAgICBhLm11bHRpbGluZSA9PSBiLm11bHRpbGluZSAmJlxuICAgICAgICAgIGEuaWdub3JlQ2FzZSA9PSBiLmlnbm9yZUNhc2VcbiAgICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhICE9ICdvYmplY3QnIHx8IHR5cGVvZiBiICE9ICdvYmplY3QnKSB7XG4gICAgICBkaWZmQnVpbGRlci5yZWNvcmRNaXNtYXRjaCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBhSXNEb21Ob2RlID0gaiQuaXNEb21Ob2RlKGEpO1xuICAgIHZhciBiSXNEb21Ob2RlID0gaiQuaXNEb21Ob2RlKGIpO1xuICAgIGlmIChhSXNEb21Ob2RlICYmIGJJc0RvbU5vZGUpIHtcbiAgICAgIC8vIEF0IGZpcnN0IHRyeSB0byB1c2UgRE9NMyBtZXRob2QgaXNFcXVhbE5vZGVcbiAgICAgIHJlc3VsdCA9IGEuaXNFcXVhbE5vZGUoYik7XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICBkaWZmQnVpbGRlci5yZWNvcmRNaXNtYXRjaCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKGFJc0RvbU5vZGUgfHwgYklzRG9tTm9kZSkge1xuICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkTWlzbWF0Y2goKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgYUlzUHJvbWlzZSA9IGokLmlzUHJvbWlzZShhKTtcbiAgICB2YXIgYklzUHJvbWlzZSA9IGokLmlzUHJvbWlzZShiKTtcbiAgICBpZiAoYUlzUHJvbWlzZSAmJiBiSXNQcm9taXNlKSB7XG4gICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICB9XG5cbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PSBhKSB7XG4gICAgICAgIHJldHVybiBiU3RhY2tbbGVuZ3RoXSA9PSBiO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBBZGQgdGhlIGZpcnN0IG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnB1c2goYSk7XG4gICAgYlN0YWNrLnB1c2goYik7XG4gICAgdmFyIHNpemUgPSAwO1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgIGlmIChjbGFzc05hbWUgPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgdmFyIGFMZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIHZhciBiTGVuZ3RoID0gYi5sZW5ndGg7XG5cbiAgICAgIGRpZmZCdWlsZGVyLndpdGhQYXRoKCdsZW5ndGgnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGFMZW5ndGggIT09IGJMZW5ndGgpIHtcbiAgICAgICAgICBkaWZmQnVpbGRlci5yZWNvcmRNaXNtYXRjaCgpO1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGFMZW5ndGggfHwgaSA8IGJMZW5ndGg7IGkrKykge1xuICAgICAgICBkaWZmQnVpbGRlci53aXRoUGF0aChpLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoaSA+PSBiTGVuZ3RoKSB7XG4gICAgICAgICAgICBkaWZmQnVpbGRlci5yZWNvcmRNaXNtYXRjaChcbiAgICAgICAgICAgICAgYWN0dWFsQXJyYXlJc0xvbmdlckZvcm1hdHRlci5iaW5kKG51bGwsIHNlbGYucHApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgIHNlbGYuZXFfKFxuICAgICAgICAgICAgICAgIGkgPCBhTGVuZ3RoID8gYVtpXSA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBpIDwgYkxlbmd0aCA/IGJbaV0gOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgYVN0YWNrLFxuICAgICAgICAgICAgICAgIGJTdGFjayxcbiAgICAgICAgICAgICAgICBkaWZmQnVpbGRlclxuICAgICAgICAgICAgICApICYmIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaiQuaXNNYXAoYSkgJiYgaiQuaXNNYXAoYikpIHtcbiAgICAgIGlmIChhLnNpemUgIT0gYi5zaXplKSB7XG4gICAgICAgIGRpZmZCdWlsZGVyLnJlY29yZE1pc21hdGNoKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGtleXNBID0gW107XG4gICAgICB2YXIga2V5c0IgPSBbXTtcbiAgICAgIGEuZm9yRWFjaChmdW5jdGlvbih2YWx1ZUEsIGtleUEpIHtcbiAgICAgICAga2V5c0EucHVzaChrZXlBKTtcbiAgICAgIH0pO1xuICAgICAgYi5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlQiwga2V5Qikge1xuICAgICAgICBrZXlzQi5wdXNoKGtleUIpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEZvciBib3RoIHNldHMgb2Yga2V5cywgY2hlY2sgdGhleSBtYXAgdG8gZXF1YWwgdmFsdWVzIGluIGJvdGggbWFwcy5cbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgY29ycmVzcG9uZGluZyBrZXlzIChpbiBpbnNlcnRpb24gb3JkZXIpIGluIG9yZGVyIHRvIGhhbmRsZSBhc3ltbWV0cmljIG9iaiBrZXlzLlxuICAgICAgdmFyIG1hcEtleXMgPSBba2V5c0EsIGtleXNCXTtcbiAgICAgIHZhciBjbXBLZXlzID0gW2tleXNCLCBrZXlzQV07XG4gICAgICB2YXIgbWFwSXRlciwgbWFwS2V5LCBtYXBWYWx1ZUEsIG1hcFZhbHVlQjtcbiAgICAgIHZhciBjbXBJdGVyLCBjbXBLZXk7XG4gICAgICBmb3IgKGkgPSAwOyByZXN1bHQgJiYgaSA8IG1hcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWFwSXRlciA9IG1hcEtleXNbaV07XG4gICAgICAgIGNtcEl0ZXIgPSBjbXBLZXlzW2ldO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyByZXN1bHQgJiYgaiA8IG1hcEl0ZXIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBtYXBLZXkgPSBtYXBJdGVyW2pdO1xuICAgICAgICAgIGNtcEtleSA9IGNtcEl0ZXJbal07XG4gICAgICAgICAgbWFwVmFsdWVBID0gYS5nZXQobWFwS2V5KTtcblxuICAgICAgICAgIC8vIE9ubHkgdXNlIHRoZSBjbXBLZXkgd2hlbiBvbmUgb2YgdGhlIGtleXMgaXMgYXN5bW1ldHJpYyBhbmQgdGhlIGNvcnJlc3BvbmRpbmcga2V5IG1hdGNoZXMsXG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIGV4cGxpY2l0bHkgbG9vayB1cCB0aGUgbWFwS2V5IGluIHRoZSBvdGhlciBNYXAgc2luY2Ugd2Ugd2FudCBrZXlzIHdpdGggdW5pcXVlXG4gICAgICAgICAgLy8gb2JqIGlkZW50aXR5ICh0aGF0IGFyZSBvdGhlcndpc2UgZXF1YWwpIHRvIG5vdCBtYXRjaC5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBqJC5pc0FzeW1tZXRyaWNFcXVhbGl0eVRlc3Rlcl8obWFwS2V5KSB8fFxuICAgICAgICAgICAgKGokLmlzQXN5bW1ldHJpY0VxdWFsaXR5VGVzdGVyXyhjbXBLZXkpICYmXG4gICAgICAgICAgICAgIHRoaXMuZXFfKG1hcEtleSwgY21wS2V5LCBhU3RhY2ssIGJTdGFjaywgaiQuTnVsbERpZmZCdWlsZGVyKCkpKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgbWFwVmFsdWVCID0gYi5nZXQoY21wS2V5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFwVmFsdWVCID0gYi5nZXQobWFwS2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gdGhpcy5lcV8oXG4gICAgICAgICAgICBtYXBWYWx1ZUEsXG4gICAgICAgICAgICBtYXBWYWx1ZUIsXG4gICAgICAgICAgICBhU3RhY2ssXG4gICAgICAgICAgICBiU3RhY2ssXG4gICAgICAgICAgICBqJC5OdWxsRGlmZkJ1aWxkZXIoKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkTWlzbWF0Y2goKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaiQuaXNTZXQoYSkgJiYgaiQuaXNTZXQoYikpIHtcbiAgICAgIGlmIChhLnNpemUgIT0gYi5zaXplKSB7XG4gICAgICAgIGRpZmZCdWlsZGVyLnJlY29yZE1pc21hdGNoKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlc0EgPSBbXTtcbiAgICAgIGEuZm9yRWFjaChmdW5jdGlvbih2YWx1ZUEpIHtcbiAgICAgICAgdmFsdWVzQS5wdXNoKHZhbHVlQSk7XG4gICAgICB9KTtcbiAgICAgIHZhciB2YWx1ZXNCID0gW107XG4gICAgICBiLmZvckVhY2goZnVuY3Rpb24odmFsdWVCKSB7XG4gICAgICAgIHZhbHVlc0IucHVzaCh2YWx1ZUIpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEZvciBib3RoIHNldHMsIGNoZWNrIHRoZXkgYXJlIGFsbCBjb250YWluZWQgaW4gdGhlIG90aGVyIHNldFxuICAgICAgdmFyIHNldFBhaXJzID0gW1t2YWx1ZXNBLCB2YWx1ZXNCXSwgW3ZhbHVlc0IsIHZhbHVlc0FdXTtcbiAgICAgIHZhciBzdGFja1BhaXJzID0gW1thU3RhY2ssIGJTdGFja10sIFtiU3RhY2ssIGFTdGFja11dO1xuICAgICAgdmFyIGJhc2VWYWx1ZXMsIGJhc2VWYWx1ZSwgYmFzZVN0YWNrO1xuICAgICAgdmFyIG90aGVyVmFsdWVzLCBvdGhlclZhbHVlLCBvdGhlclN0YWNrO1xuICAgICAgdmFyIGZvdW5kO1xuICAgICAgdmFyIHByZXZTdGFja1NpemU7XG4gICAgICBmb3IgKGkgPSAwOyByZXN1bHQgJiYgaSA8IHNldFBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJhc2VWYWx1ZXMgPSBzZXRQYWlyc1tpXVswXTtcbiAgICAgICAgb3RoZXJWYWx1ZXMgPSBzZXRQYWlyc1tpXVsxXTtcbiAgICAgICAgYmFzZVN0YWNrID0gc3RhY2tQYWlyc1tpXVswXTtcbiAgICAgICAgb3RoZXJTdGFjayA9IHN0YWNrUGFpcnNbaV1bMV07XG4gICAgICAgIC8vIEZvciBlYWNoIHZhbHVlIGluIHRoZSBiYXNlIHNldC4uLlxuICAgICAgICBmb3IgKHZhciBrID0gMDsgcmVzdWx0ICYmIGsgPCBiYXNlVmFsdWVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgYmFzZVZhbHVlID0gYmFzZVZhbHVlc1trXTtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgIC8vIC4uLiB0ZXN0IHRoYXQgaXQgaXMgcHJlc2VudCBpbiB0aGUgb3RoZXIgc2V0XG4gICAgICAgICAgZm9yICh2YXIgbCA9IDA7ICFmb3VuZCAmJiBsIDwgb3RoZXJWYWx1ZXMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICAgIG90aGVyVmFsdWUgPSBvdGhlclZhbHVlc1tsXTtcbiAgICAgICAgICAgIHByZXZTdGFja1NpemUgPSBiYXNlU3RhY2subGVuZ3RoO1xuICAgICAgICAgICAgLy8gY29tcGFyZSBieSB2YWx1ZSBlcXVhbGl0eVxuICAgICAgICAgICAgZm91bmQgPSB0aGlzLmVxXyhcbiAgICAgICAgICAgICAgYmFzZVZhbHVlLFxuICAgICAgICAgICAgICBvdGhlclZhbHVlLFxuICAgICAgICAgICAgICBiYXNlU3RhY2ssXG4gICAgICAgICAgICAgIG90aGVyU3RhY2ssXG4gICAgICAgICAgICAgIGokLk51bGxEaWZmQnVpbGRlcigpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCFmb3VuZCAmJiBwcmV2U3RhY2tTaXplICE9PSBiYXNlU3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGJhc2VTdGFjay5zcGxpY2UocHJldlN0YWNrU2l6ZSk7XG4gICAgICAgICAgICAgIG90aGVyU3RhY2suc3BsaWNlKHByZXZTdGFja1NpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQgJiYgZm91bmQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkTWlzbWF0Y2goKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaiQuaXNVUkwoYSkgJiYgaiQuaXNVUkwoYikpIHtcbiAgICAgIC8vIFVSTHMgaGF2ZSBubyBlbnVtcmFibGUgcHJvcGVydGllcywgc28gdGhlIGRlZmF1bHQgb2JqZWN0IGNvbXBhcmlzb25cbiAgICAgIC8vIHdvdWxkIGNvbnNpZGVyIGFueSB0d28gVVJMcyB0byBiZSBlcXVhbC5cbiAgICAgIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzXG4gICAgICAvLyBvciBgQXJyYXlgcyBmcm9tIGRpZmZlcmVudCBmcmFtZXMgYXJlLlxuICAgICAgdmFyIGFDdG9yID0gYS5jb25zdHJ1Y3RvcixcbiAgICAgICAgYkN0b3IgPSBiLmNvbnN0cnVjdG9yO1xuICAgICAgaWYgKFxuICAgICAgICBhQ3RvciAhPT0gYkN0b3IgJiZcbiAgICAgICAgaXNGdW5jdGlvbihhQ3RvcikgJiZcbiAgICAgICAgaXNGdW5jdGlvbihiQ3RvcikgJiZcbiAgICAgICAgYSBpbnN0YW5jZW9mIGFDdG9yICYmXG4gICAgICAgIGIgaW5zdGFuY2VvZiBiQ3RvciAmJlxuICAgICAgICAhKGFDdG9yIGluc3RhbmNlb2YgYUN0b3IgJiYgYkN0b3IgaW5zdGFuY2VvZiBiQ3RvcilcbiAgICAgICkge1xuICAgICAgICBkaWZmQnVpbGRlci5yZWNvcmRNaXNtYXRjaChcbiAgICAgICAgICBjb25zdHJ1Y3RvcnNBcmVEaWZmZXJlbnRGb3JtYXR0ZXIuYmluZChudWxsLCB0aGlzLnBwKVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgdmFyIGFLZXlzID0ga2V5cyhhLCBjbGFzc05hbWUgPT0gJ1tvYmplY3QgQXJyYXldJyksXG4gICAgICBrZXk7XG4gICAgc2l6ZSA9IGFLZXlzLmxlbmd0aDtcblxuICAgIC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzIGJlZm9yZSBjb21wYXJpbmcgZGVlcCBlcXVhbGl0eS5cbiAgICBpZiAoa2V5cyhiLCBjbGFzc05hbWUgPT0gJ1tvYmplY3QgQXJyYXldJykubGVuZ3RoICE9PSBzaXplKSB7XG4gICAgICBkaWZmQnVpbGRlci5yZWNvcmRNaXNtYXRjaChcbiAgICAgICAgb2JqZWN0S2V5c0FyZURpZmZlcmVudEZvcm1hdHRlci5iaW5kKG51bGwsIHRoaXMucHApXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgIGtleSA9IGFLZXlzW2ldO1xuICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG4gICAgICBpZiAoIWokLnV0aWwuaGFzKGIsIGtleSkpIHtcbiAgICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkTWlzbWF0Y2goXG4gICAgICAgICAgb2JqZWN0S2V5c0FyZURpZmZlcmVudEZvcm1hdHRlci5iaW5kKG51bGwsIHRoaXMucHApXG4gICAgICAgICk7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZGlmZkJ1aWxkZXIud2l0aFBhdGgoa2V5LCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFzZWxmLmVxXyhhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2ssIGRpZmZCdWlsZGVyKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSB0aGUgZmlyc3Qgb2JqZWN0IGZyb20gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wb3AoKTtcbiAgICBiU3RhY2sucG9wKCk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIGZ1bmN0aW9uIGtleXMob2JqLCBpc0FycmF5KSB7XG4gICAgdmFyIGFsbEtleXMgPSBPYmplY3Qua2V5c1xuICAgICAgPyBPYmplY3Qua2V5cyhvYmopXG4gICAgICA6IChmdW5jdGlvbihvKSB7XG4gICAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gbykge1xuICAgICAgICAgICAgaWYgKGokLnV0aWwuaGFzKG8sIGtleSkpIHtcbiAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgICB9KShvYmopO1xuXG4gICAgaWYgKCFpc0FycmF5KSB7XG4gICAgICByZXR1cm4gYWxsS2V5cztcbiAgICB9XG5cbiAgICBpZiAoYWxsS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBhbGxLZXlzO1xuICAgIH1cblxuICAgIHZhciBleHRyYUtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghL15bMC05XSskLy50ZXN0KGFsbEtleXNbaV0pKSB7XG4gICAgICAgIGV4dHJhS2V5cy5wdXNoKGFsbEtleXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBleHRyYUtleXM7XG4gIH1cblxuICBmdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgZnVuY3Rpb24gb2JqZWN0S2V5c0FyZURpZmZlcmVudEZvcm1hdHRlcihwcCwgYWN0dWFsLCBleHBlY3RlZCwgcGF0aCkge1xuICAgIHZhciBtaXNzaW5nUHJvcGVydGllcyA9IGokLnV0aWwub2JqZWN0RGlmZmVyZW5jZShleHBlY3RlZCwgYWN0dWFsKSxcbiAgICAgIGV4dHJhUHJvcGVydGllcyA9IGokLnV0aWwub2JqZWN0RGlmZmVyZW5jZShhY3R1YWwsIGV4cGVjdGVkKSxcbiAgICAgIG1pc3NpbmdQcm9wZXJ0aWVzTWVzc2FnZSA9IGZvcm1hdEtleVZhbHVlUGFpcnMocHAsIG1pc3NpbmdQcm9wZXJ0aWVzKSxcbiAgICAgIGV4dHJhUHJvcGVydGllc01lc3NhZ2UgPSBmb3JtYXRLZXlWYWx1ZVBhaXJzKHBwLCBleHRyYVByb3BlcnRpZXMpLFxuICAgICAgbWVzc2FnZXMgPSBbXTtcblxuICAgIGlmICghcGF0aC5kZXB0aCgpKSB7XG4gICAgICBwYXRoID0gJ29iamVjdCc7XG4gICAgfVxuXG4gICAgaWYgKG1pc3NpbmdQcm9wZXJ0aWVzTWVzc2FnZS5sZW5ndGgpIHtcbiAgICAgIG1lc3NhZ2VzLnB1c2goXG4gICAgICAgICdFeHBlY3RlZCAnICsgcGF0aCArICcgdG8gaGF2ZSBwcm9wZXJ0aWVzJyArIG1pc3NpbmdQcm9wZXJ0aWVzTWVzc2FnZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZXh0cmFQcm9wZXJ0aWVzTWVzc2FnZS5sZW5ndGgpIHtcbiAgICAgIG1lc3NhZ2VzLnB1c2goXG4gICAgICAgICdFeHBlY3RlZCAnICsgcGF0aCArICcgbm90IHRvIGhhdmUgcHJvcGVydGllcycgKyBleHRyYVByb3BlcnRpZXNNZXNzYWdlXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBtZXNzYWdlcy5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN0cnVjdG9yc0FyZURpZmZlcmVudEZvcm1hdHRlcihwcCwgYWN0dWFsLCBleHBlY3RlZCwgcGF0aCkge1xuICAgIGlmICghcGF0aC5kZXB0aCgpKSB7XG4gICAgICBwYXRoID0gJ29iamVjdCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgICdFeHBlY3RlZCAnICtcbiAgICAgIHBhdGggK1xuICAgICAgJyB0byBiZSBhIGtpbmQgb2YgJyArXG4gICAgICBqJC5mbk5hbWVGb3IoZXhwZWN0ZWQuY29uc3RydWN0b3IpICtcbiAgICAgICcsIGJ1dCB3YXMgJyArXG4gICAgICBwcChhY3R1YWwpICtcbiAgICAgICcuJ1xuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBhY3R1YWxBcnJheUlzTG9uZ2VyRm9ybWF0dGVyKHBwLCBhY3R1YWwsIGV4cGVjdGVkLCBwYXRoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICdVbmV4cGVjdGVkICcgK1xuICAgICAgcGF0aCArXG4gICAgICAocGF0aC5kZXB0aCgpID8gJyA9ICcgOiAnJykgK1xuICAgICAgcHAoYWN0dWFsKSArXG4gICAgICAnIGluIGFycmF5LidcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0S2V5VmFsdWVQYWlycyhwcCwgb2JqKSB7XG4gICAgdmFyIGZvcm1hdHRlZCA9ICcnO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGZvcm1hdHRlZCArPSAnXFxuICAgICcgKyBrZXkgKyAnOiAnICsgcHAob2JqW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0dGVkO1xuICB9XG5cbiAgcmV0dXJuIE1hdGNoZXJzVXRpbDtcbn07XG5cbi8qKlxuICogQGludGVyZmFjZSBBc3ltbWV0cmljRXF1YWxpdHlUZXN0ZXJcbiAqIEBjbGFzc2Rlc2MgQW4gYXN5bW1ldHJpYyBlcXVhbGl0eSB0ZXN0ZXIgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIG1hdGNoIG11bHRpcGxlXG4gKiBvYmplY3RzLiBFeGFtcGxlcyBpbmNsdWRlIGphc21pbmUuYW55KCkgYW5kIGphc21pbmUuc3RyaW5nTWF0Y2hpbmcoKS4gSmFzbWluZVxuICogaW5jbHVkZXMgYSBudW1iZXIgb2YgYnVpbHQtaW4gYXN5bW1ldHJpYyBlcXVhbGl0eSB0ZXN0ZXJzLCBzdWNoIGFzXG4gKiB7QGxpbmsgamFzbWluZS5vYmplY3RDb250YWluaW5nfS4gVXNlci1kZWZpbmVkIGFzeW1tZXRyaWMgZXF1YWxpdHkgdGVzdGVycyBhcmVcbiAqIGFsc28gc3VwcG9ydGVkLlxuICpcbiAqIEFzeW1tZXRyaWMgZXF1YWxpdHkgdGVzdGVycyB3b3JrIHdpdGggYW55IG1hdGNoZXIsIGluY2x1ZGluZyB1c2VyLWRlZmluZWRcbiAqIGN1c3RvbSBtYXRjaGVycywgdGhhdCB1c2VzIHtAbGluayBNYXRjaGVyc1V0aWwjZXF1YWxzfSBvclxuICoge0BsaW5rIE1hdGNoZXJzVXRpbCNjb250YWluc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGZ1bmN0aW9uIG51bWJlckRpdmlzaWJsZUJ5KGRpdmlzb3IpIHtcbiAqICAgcmV0dXJuIHtcbiAqICAgICBhc3ltbWV0cmljTWF0Y2g6IGZ1bmN0aW9uKG4pIHtcbiAqICAgICAgIHJldHVybiB0eXBlb2YgbiA9PT0gJ251bWJlcicgJiYgbiAlIGRpdmlzb3IgPT09IDA7XG4gKiAgICAgfSxcbiAqICAgICBqYXNtaW5lVG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuIGA8YSBudW1iZXIgZGl2aXNpYmxlIGJ5ICR7ZGl2aXNvcn0+YDtcbiAqICAgICB9XG4gKiAgIH07XG4gKiB9XG4gKlxuICogdmFyIGFjdHVhbCA9IHtcbiAqICAgbjogMixcbiAqICAgb3RoZXJGaWVsZHM6IFwiZG9uJ3QgY2FyZVwiXG4gKiB9O1xuICpcbiAqIGV4cGVjdChhY3R1YWwpLnRvRXF1YWwoamFzbWluZS5vYmplY3RDb250YWluaW5nKHtuOiBudW1iZXJEaXZpc2libGVCeSgyKX0pKTtcbiAqIEBzZWUgY3VzdG9tX2FzeW1tZXRyaWNfZXF1YWxpdHlfdGVzdGVyc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgdmFsdWUgbWF0Y2hlcyB0aGlzIHRlc3RlclxuICogQGZ1bmN0aW9uXG4gKiBAbmFtZSBBc3ltbWV0cmljRXF1YWxpdHlUZXN0ZXIjYXN5bW1ldHJpY01hdGNoXG4gKiBAcGFyYW0gdmFsdWUge2FueX0gVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEBwYXJhbSBtYXRjaGVyc1V0aWwge01hdGNoZXJzVXRpbH0gdXRpbGl0aWVzIGZvciB0ZXN0aW5nIGVxdWFsaXR5LCBldGNcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHRlc3RlciB0byB1c2UgaW4gbWF0Y2hlciBmYWlsdXJlIG1lc3NhZ2VzXG4gKiBAZnVuY3Rpb25cbiAqIEBuYW1lIEFzeW1tZXRyaWNFcXVhbGl0eVRlc3RlciNqYXNtaW5lVG9TdHJpbmdcbiAqIEBwYXJhbSBwcCB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB2YWx1ZSBhbmQgcmV0dXJucyBhIHByZXR0eS1wcmludGVkIHJlcHJlc2VudGF0aW9uXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5NaXNtYXRjaFRyZWUgPSBmdW5jdGlvbihqJCkge1xuICAvKlxuICAgIFRvIGJlIGFibGUgdG8gYXBwbHkgY3VzdG9tIG9iamVjdCBmb3JtYXR0ZXJzIGF0IGFsbCBwb3NzaWJsZSBsZXZlbHMgb2YgYW5cbiAgICBvYmplY3QgZ3JhcGgsIERpZmZCdWlsZGVyIG5lZWRzIHRvIGJlIGFibGUgdG8ga25vdyBub3QganVzdCB3aGVyZSB0aGVcbiAgICBtaXNtYXRjaCBvY2N1cnJlZCBidXQgYWxzbyBhbGwgYW5jZXN0b3JzIG9mIHRoZSBtaXNtYXRjaGVkIHZhbHVlIGluIGJvdGhcbiAgICB0aGUgZXhwZWN0ZWQgYW5kIGFjdHVhbCBvYmplY3QgZ3JhcGhzLiBNaXNtYXRjaFRyZWUgbWFpbnRhaW5zIHRoYXQgY29udGV4dFxuICAgIGFuZCBwcm92aWRlcyBpdCB2aWEgdGhlIHRyYXZlcnNlIG1ldGhvZC5cbiAgICovXG4gIGZ1bmN0aW9uIE1pc21hdGNoVHJlZShwYXRoKSB7XG4gICAgdGhpcy5wYXRoID0gcGF0aCB8fCBuZXcgaiQuT2JqZWN0UGF0aChbXSk7XG4gICAgdGhpcy5mb3JtYXR0ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMuaXNNaXNtYXRjaCA9IGZhbHNlO1xuICB9XG5cbiAgTWlzbWF0Y2hUcmVlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihwYXRoLCBmb3JtYXR0ZXIpIHtcbiAgICB2YXIga2V5LCBjaGlsZDtcblxuICAgIGlmIChwYXRoLmRlcHRoKCkgPT09IDApIHtcbiAgICAgIHRoaXMuZm9ybWF0dGVyID0gZm9ybWF0dGVyO1xuICAgICAgdGhpcy5pc01pc21hdGNoID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5ID0gcGF0aC5jb21wb25lbnRzWzBdO1xuICAgICAgcGF0aCA9IHBhdGguc2hpZnQoKTtcbiAgICAgIGNoaWxkID0gdGhpcy5jaGlsZChrZXkpO1xuXG4gICAgICBpZiAoIWNoaWxkKSB7XG4gICAgICAgIGNoaWxkID0gbmV3IE1pc21hdGNoVHJlZSh0aGlzLnBhdGguYWRkKGtleSkpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZC5hZGQocGF0aCwgZm9ybWF0dGVyKTtcbiAgICB9XG4gIH07XG5cbiAgTWlzbWF0Y2hUcmVlLnByb3RvdHlwZS50cmF2ZXJzZSA9IGZ1bmN0aW9uKHZpc2l0KSB7XG4gICAgdmFyIGksXG4gICAgICBoYXNDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMDtcblxuICAgIGlmICh0aGlzLmlzTWlzbWF0Y2ggfHwgaGFzQ2hpbGRyZW4pIHtcbiAgICAgIGlmICh2aXNpdCh0aGlzLnBhdGgsICFoYXNDaGlsZHJlbiwgdGhpcy5mb3JtYXR0ZXIpKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS50cmF2ZXJzZSh2aXNpdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgTWlzbWF0Y2hUcmVlLnByb3RvdHlwZS5jaGlsZCA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBpLCBwYXRoRWxzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhdGhFbHMgPSB0aGlzLmNoaWxkcmVuW2ldLnBhdGguY29tcG9uZW50cztcbiAgICAgIGlmIChwYXRoRWxzW3BhdGhFbHMubGVuZ3RoIC0gMV0gPT09IGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIE1pc21hdGNoVHJlZTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkubm90aGluZyA9IGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gbm90aGluZyBleHBsaWNpdGx5LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjbm90aGluZ1xuICAgKiBAc2luY2UgMi44LjBcbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KCkubm90aGluZygpO1xuICAgKi9cbiAgZnVuY3Rpb24gbm90aGluZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFzczogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gbm90aGluZztcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuTnVsbERpZmZCdWlsZGVyID0gZnVuY3Rpb24oaiQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3aXRoUGF0aDogZnVuY3Rpb24oXywgYmxvY2spIHtcbiAgICAgICAgYmxvY2soKTtcbiAgICAgIH0sXG4gICAgICBzZXRSb290czogZnVuY3Rpb24oKSB7fSxcbiAgICAgIHJlY29yZE1pc21hdGNoOiBmdW5jdGlvbigpIHt9XG4gICAgfTtcbiAgfTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuT2JqZWN0UGF0aCA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIE9iamVjdFBhdGgoY29tcG9uZW50cykge1xuICAgIHRoaXMuY29tcG9uZW50cyA9IGNvbXBvbmVudHMgfHwgW107XG4gIH1cblxuICBPYmplY3RQYXRoLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gJyQnICsgbWFwKHRoaXMuY29tcG9uZW50cywgZm9ybWF0UHJvcGVydHlBY2Nlc3MpLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9O1xuXG4gIE9iamVjdFBhdGgucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgIHJldHVybiBuZXcgT2JqZWN0UGF0aCh0aGlzLmNvbXBvbmVudHMuY29uY2F0KFtjb21wb25lbnRdKSk7XG4gIH07XG5cbiAgT2JqZWN0UGF0aC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IE9iamVjdFBhdGgodGhpcy5jb21wb25lbnRzLnNsaWNlKDEpKTtcbiAgfTtcblxuICBPYmplY3RQYXRoLnByb3RvdHlwZS5kZXB0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNvbXBvbmVudHMubGVuZ3RoO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5QWNjZXNzKHByb3ApIHtcbiAgICBpZiAodHlwZW9mIHByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gJ1snICsgcHJvcCArICddJztcbiAgICB9XG5cbiAgICBpZiAoaXNWYWxpZElkZW50aWZpZXIocHJvcCkpIHtcbiAgICAgIHJldHVybiAnLicgKyBwcm9wO1xuICAgIH1cblxuICAgIHJldHVybiBcIlsnXCIgKyBwcm9wICsgXCInXVwiO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0cy5wdXNoKGZuKGFycmF5W2ldKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNWYWxpZElkZW50aWZpZXIoc3RyaW5nKSB7XG4gICAgcmV0dXJuIC9eW0EtWmEtelxcJF9dW0EtWmEtejAtOVxcJF9dKiQvLnRlc3Qoc3RyaW5nKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3RQYXRoO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5yZXF1aXJlQXN5bmNNYXRjaGVycyA9IGZ1bmN0aW9uKGpSZXF1aXJlLCBqJCkge1xuICB2YXIgYXZhaWxhYmxlTWF0Y2hlcnMgPSBbXG4gICAgICAndG9CZVBlbmRpbmcnLFxuICAgICAgJ3RvQmVSZXNvbHZlZCcsXG4gICAgICAndG9CZVJlamVjdGVkJyxcbiAgICAgICd0b0JlUmVzb2x2ZWRUbycsXG4gICAgICAndG9CZVJlamVjdGVkV2l0aCcsXG4gICAgICAndG9CZVJlamVjdGVkV2l0aEVycm9yJ1xuICAgIF0sXG4gICAgbWF0Y2hlcnMgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGF2YWlsYWJsZU1hdGNoZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSBhdmFpbGFibGVNYXRjaGVyc1tpXTtcbiAgICBtYXRjaGVyc1tuYW1lXSA9IGpSZXF1aXJlW25hbWVdKGokKTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVycztcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZSA9IGZ1bmN0aW9uKGokKSB7XG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIHZhbHVlIHRvIGJlIGA9PT1gIHRvIHRoZSBleHBlY3RlZCB2YWx1ZS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvQmVcbiAgICogQHNpbmNlIDEuMy4wXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHBlY3RlZCAtIFRoZSBleHBlY3RlZCB2YWx1ZSB0byBjb21wYXJlIGFnYWluc3QuXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdCh0aGluZykudG9CZShyZWFsVGhpbmcpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9CZShtYXRjaGVyc1V0aWwpIHtcbiAgICB2YXIgdGlwID1cbiAgICAgICcgVGlwOiBUbyBjaGVjayBmb3IgZGVlcCBlcXVhbGl0eSwgdXNlIC50b0VxdWFsKCkgaW5zdGVhZCBvZiAudG9CZSgpLic7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgIHBhc3M6IGFjdHVhbCA9PT0gZXhwZWN0ZWRcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID1cbiAgICAgICAgICAgIG1hdGNoZXJzVXRpbC5idWlsZEZhaWx1cmVNZXNzYWdlKFxuICAgICAgICAgICAgICAndG9CZScsXG4gICAgICAgICAgICAgIHJlc3VsdC5wYXNzLFxuICAgICAgICAgICAgICBhY3R1YWwsXG4gICAgICAgICAgICAgIGV4cGVjdGVkXG4gICAgICAgICAgICApICsgdGlwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvQmU7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVDbG9zZVRvID0gZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIHZhbHVlIHRvIGJlIHdpdGhpbiBhIHNwZWNpZmllZCBwcmVjaXNpb24gb2YgdGhlIGV4cGVjdGVkIHZhbHVlLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9CZUNsb3NlVG9cbiAgICogQHNpbmNlIDEuMy4wXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHBlY3RlZCAtIFRoZSBleHBlY3RlZCB2YWx1ZSB0byBjb21wYXJlIGFnYWluc3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcHJlY2lzaW9uPTJdIC0gVGhlIG51bWJlciBvZiBkZWNpbWFsIHBvaW50cyB0byBjaGVjay5cbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KG51bWJlcikudG9CZUNsb3NlVG8oNDIuMiwgMyk7XG4gICAqL1xuICBmdW5jdGlvbiB0b0JlQ2xvc2VUbygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCwgcHJlY2lzaW9uKSB7XG4gICAgICAgIGlmIChwcmVjaXNpb24gIT09IDApIHtcbiAgICAgICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gfHwgMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHBlY3RlZCA9PT0gbnVsbCB8fCBhY3R1YWwgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQ2Fubm90IHVzZSB0b0JlQ2xvc2VUbyB3aXRoIG51bGwuIEFyZ3VtZW50cyBldmFsdWF0ZWQgdG86ICcgK1xuICAgICAgICAgICAgICAnZXhwZWN0KCcgK1xuICAgICAgICAgICAgICBhY3R1YWwgK1xuICAgICAgICAgICAgICAnKS50b0JlQ2xvc2VUbygnICtcbiAgICAgICAgICAgICAgZXhwZWN0ZWQgK1xuICAgICAgICAgICAgICAnKS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3cgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uICsgMSk7XG4gICAgICAgIHZhciBkZWx0YSA9IE1hdGguYWJzKGV4cGVjdGVkIC0gYWN0dWFsKTtcbiAgICAgICAgdmFyIG1heERlbHRhID0gTWF0aC5wb3coMTAsIC1wcmVjaXNpb24pIC8gMjtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhc3M6IE1hdGgucm91bmQoZGVsdGEgKiBwb3cpIDw9IG1heERlbHRhICogcG93XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0JlQ2xvc2VUbztcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZURlZmluZWQgPSBmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgdmFsdWUgdG8gYmUgZGVmaW5lZC4gKE5vdCBgdW5kZWZpbmVkYClcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvQmVEZWZpbmVkXG4gICAqIEBzaW5jZSAxLjMuMFxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QocmVzdWx0KS50b0JlRGVmaW5lZCgpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9CZURlZmluZWQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhc3M6IHZvaWQgMCAhPT0gYWN0dWFsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0JlRGVmaW5lZDtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZUZhbHNlID0gZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIHZhbHVlIHRvIGJlIGBmYWxzZWAuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0JlRmFsc2VcbiAgICogQHNpbmNlIDMuNS4wXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdChyZXN1bHQpLnRvQmVGYWxzZSgpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9CZUZhbHNlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXNzOiBhY3R1YWwgPT09IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0JlRmFsc2U7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVGYWxzeSA9IGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCB2YWx1ZSB0byBiZSBmYWxzeVxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9CZUZhbHN5XG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QocmVzdWx0KS50b0JlRmFsc3koKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvQmVGYWxzeSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFzczogIWFjdHVhbFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9CZUZhbHN5O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlR3JlYXRlclRoYW4gPSBmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgdmFsdWUgdG8gYmUgZ3JlYXRlciB0aGFuIHRoZSBleHBlY3RlZCB2YWx1ZS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvQmVHcmVhdGVyVGhhblxuICAgKiBAc2luY2UgMi4wLjBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV4cGVjdGVkIC0gVGhlIHZhbHVlIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KHJlc3VsdCkudG9CZUdyZWF0ZXJUaGFuKDMpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9CZUdyZWF0ZXJUaGFuKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFzczogYWN0dWFsID4gZXhwZWN0ZWRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvQmVHcmVhdGVyVGhhbjtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCB2YWx1ZSB0byBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGV4cGVjdGVkIHZhbHVlLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9CZUdyZWF0ZXJUaGFuT3JFcXVhbFxuICAgKiBAc2luY2UgMi4wLjBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV4cGVjdGVkIC0gVGhlIGV4cGVjdGVkIHZhbHVlIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KHJlc3VsdCkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgyNSk7XG4gICAqL1xuICBmdW5jdGlvbiB0b0JlR3JlYXRlclRoYW5PckVxdWFsKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFzczogYWN0dWFsID49IGV4cGVjdGVkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0JlR3JlYXRlclRoYW5PckVxdWFsO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlSW5zdGFuY2VPZiA9IGZ1bmN0aW9uKGokKSB7XG4gIHZhciB1c2FnZUVycm9yID0gaiQuZm9ybWF0RXJyb3JNc2coXG4gICAgJzx0b0JlSW5zdGFuY2VPZj4nLFxuICAgICdleHBlY3QodmFsdWUpLnRvQmVJbnN0YW5jZU9mKDxDb25zdHJ1Y3RvckZ1bmN0aW9uPiknXG4gICk7XG5cbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgdGhlIGV4cGVjdGVkIGNsYXNzXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0JlSW5zdGFuY2VPZlxuICAgKiBAc2luY2UgMy41LjBcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4cGVjdGVkIC0gVGhlIGNsYXNzIG9yIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGNoZWNrIGZvclxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QoJ2ZvbycpLnRvQmVJbnN0YW5jZU9mKFN0cmluZyk7XG4gICAqIGV4cGVjdCgzKS50b0JlSW5zdGFuY2VPZihOdW1iZXIpO1xuICAgKiBleHBlY3QobmV3IEVycm9yKCkpLnRvQmVJbnN0YW5jZU9mKEVycm9yKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvQmVJbnN0YW5jZU9mKG1hdGNoZXJzVXRpbCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gICAgICAgIHZhciBhY3R1YWxUeXBlID1cbiAgICAgICAgICAgIGFjdHVhbCAmJiBhY3R1YWwuY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgPyBqJC5mbk5hbWVGb3IoYWN0dWFsLmNvbnN0cnVjdG9yKVxuICAgICAgICAgICAgICA6IG1hdGNoZXJzVXRpbC5wcChhY3R1YWwpLFxuICAgICAgICAgIGV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkXG4gICAgICAgICAgICA/IGokLmZuTmFtZUZvcihleHBlY3RlZClcbiAgICAgICAgICAgIDogbWF0Y2hlcnNVdGlsLnBwKGV4cGVjdGVkKSxcbiAgICAgICAgICBleHBlY3RlZE1hdGNoZXIsXG4gICAgICAgICAgcGFzcztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGV4cGVjdGVkTWF0Y2hlciA9IG5ldyBqJC5BbnkoZXhwZWN0ZWQpO1xuICAgICAgICAgIHBhc3MgPSBleHBlY3RlZE1hdGNoZXIuYXN5bW1ldHJpY01hdGNoKGFjdHVhbCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgdXNhZ2VFcnJvcignRXhwZWN0ZWQgdmFsdWUgaXMgbm90IGEgY29uc3RydWN0b3IgZnVuY3Rpb24nKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFzcykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXNzOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgJ0V4cGVjdGVkIGluc3RhbmNlIG9mICcgK1xuICAgICAgICAgICAgICBhY3R1YWxUeXBlICtcbiAgICAgICAgICAgICAgJyBub3QgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgJyArXG4gICAgICAgICAgICAgIGV4cGVjdGVkVHlwZVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhc3M6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgJ0V4cGVjdGVkIGluc3RhbmNlIG9mICcgK1xuICAgICAgICAgICAgICBhY3R1YWxUeXBlICtcbiAgICAgICAgICAgICAgJyB0byBiZSBhbiBpbnN0YW5jZSBvZiAnICtcbiAgICAgICAgICAgICAgZXhwZWN0ZWRUeXBlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9CZUluc3RhbmNlT2Y7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVMZXNzVGhhbiA9IGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCB2YWx1ZSB0byBiZSBsZXNzIHRoYW4gdGhlIGV4cGVjdGVkIHZhbHVlLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9CZUxlc3NUaGFuXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKiBAcGFyYW0ge051bWJlcn0gZXhwZWN0ZWQgLSBUaGUgZXhwZWN0ZWQgdmFsdWUgdG8gY29tcGFyZSBhZ2FpbnN0LlxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QocmVzdWx0KS50b0JlTGVzc1RoYW4oMCk7XG4gICAqL1xuICBmdW5jdGlvbiB0b0JlTGVzc1RoYW4oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXNzOiBhY3R1YWwgPCBleHBlY3RlZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9CZUxlc3NUaGFuO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlTGVzc1RoYW5PckVxdWFsID0gZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIHZhbHVlIHRvIGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgZXhwZWN0ZWQgdmFsdWUuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0JlTGVzc1RoYW5PckVxdWFsXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKiBAcGFyYW0ge051bWJlcn0gZXhwZWN0ZWQgLSBUaGUgZXhwZWN0ZWQgdmFsdWUgdG8gY29tcGFyZSBhZ2FpbnN0LlxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QocmVzdWx0KS50b0JlTGVzc1RoYW5PckVxdWFsKDEyMyk7XG4gICAqL1xuICBmdW5jdGlvbiB0b0JlTGVzc1RoYW5PckVxdWFsKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFzczogYWN0dWFsIDw9IGV4cGVjdGVkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0JlTGVzc1RoYW5PckVxdWFsO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlTmFOID0gZnVuY3Rpb24oaiQpIHtcbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgdmFsdWUgdG8gYmUgYE5hTmAgKE5vdCBhIE51bWJlcikuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0JlTmFOXG4gICAqIEBzaW5jZSAxLjMuMFxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QodGhpbmcpLnRvQmVOYU4oKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvQmVOYU4obWF0Y2hlcnNVdGlsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgIHBhc3M6IGFjdHVhbCAhPT0gYWN0dWFsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHJlc3VsdC5wYXNzKSB7XG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSAnRXhwZWN0ZWQgYWN0dWFsIG5vdCB0byBiZSBOYU4uJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICdFeHBlY3RlZCAnICsgbWF0Y2hlcnNVdGlsLnBwKGFjdHVhbCkgKyAnIHRvIGJlIE5hTi4nO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9CZU5hTjtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZU5lZ2F0aXZlSW5maW5pdHkgPSBmdW5jdGlvbihqJCkge1xuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCB2YWx1ZSB0byBiZSBgLUluZmluaXR5YCAoLWluZmluaXR5KS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvQmVOZWdhdGl2ZUluZmluaXR5XG4gICAqIEBzaW5jZSAyLjYuMFxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QodGhpbmcpLnRvQmVOZWdhdGl2ZUluZmluaXR5KCk7XG4gICAqL1xuICBmdW5jdGlvbiB0b0JlTmVnYXRpdmVJbmZpbml0eShtYXRjaGVyc1V0aWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgcGFzczogYWN0dWFsID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAocmVzdWx0LnBhc3MpIHtcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9ICdFeHBlY3RlZCBhY3R1YWwgbm90IHRvIGJlIC1JbmZpbml0eS4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0V4cGVjdGVkICcgKyBtYXRjaGVyc1V0aWwucHAoYWN0dWFsKSArICcgdG8gYmUgLUluZmluaXR5Lic7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0JlTmVnYXRpdmVJbmZpbml0eTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZU51bGwgPSBmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgdmFsdWUgdG8gYmUgYG51bGxgLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9CZU51bGxcbiAgICogQHNpbmNlIDEuMy4wXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAqL1xuICBmdW5jdGlvbiB0b0JlTnVsbCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFzczogYWN0dWFsID09PSBudWxsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0JlTnVsbDtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZVBvc2l0aXZlSW5maW5pdHkgPSBmdW5jdGlvbihqJCkge1xuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCB2YWx1ZSB0byBiZSBgSW5maW5pdHlgIChpbmZpbml0eSkuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0JlUG9zaXRpdmVJbmZpbml0eVxuICAgKiBAc2luY2UgMi42LjBcbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KHRoaW5nKS50b0JlUG9zaXRpdmVJbmZpbml0eSgpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9CZVBvc2l0aXZlSW5maW5pdHkobWF0Y2hlcnNVdGlsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgIHBhc3M6IGFjdHVhbCA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHJlc3VsdC5wYXNzKSB7XG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSAnRXhwZWN0ZWQgYWN0dWFsIG5vdCB0byBiZSBJbmZpbml0eS4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0V4cGVjdGVkICcgKyBtYXRjaGVyc1V0aWwucHAoYWN0dWFsKSArICcgdG8gYmUgSW5maW5pdHkuJztcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvQmVQb3NpdGl2ZUluZmluaXR5O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlVHJ1ZSA9IGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCB2YWx1ZSB0byBiZSBgdHJ1ZWAuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0JlVHJ1ZVxuICAgKiBAc2luY2UgMy41LjBcbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KHJlc3VsdCkudG9CZVRydWUoKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvQmVUcnVlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXNzOiBhY3R1YWwgPT09IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvQmVUcnVlO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlVHJ1dGh5ID0gZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIHZhbHVlIHRvIGJlIHRydXRoeS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvQmVUcnV0aHlcbiAgICogQHNpbmNlIDIuMC4wXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdCh0aGluZykudG9CZVRydXRoeSgpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9CZVRydXRoeSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFzczogISFhY3R1YWxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvQmVUcnV0aHk7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVVbmRlZmluZWQgPSBmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgdmFsdWUgdG8gYmUgYHVuZGVmaW5lZGAuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0JlVW5kZWZpbmVkXG4gICAqIEBzaW5jZSAxLjMuMFxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QocmVzdWx0KS50b0JlVW5kZWZpbmVkKCk6XG4gICAqL1xuICBmdW5jdGlvbiB0b0JlVW5kZWZpbmVkKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXNzOiB2b2lkIDAgPT09IGFjdHVhbFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9CZVVuZGVmaW5lZDtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9Db250YWluID0gZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIHZhbHVlIHRvIGNvbnRhaW4gYSBzcGVjaWZpYyB2YWx1ZS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvQ29udGFpblxuICAgKiBAc2luY2UgMi4wLjBcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4cGVjdGVkIC0gVGhlIHZhbHVlIHRvIGxvb2sgZm9yLlxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QoYXJyYXkpLnRvQ29udGFpbihhbkVsZW1lbnQpO1xuICAgKiBleHBlY3Qoc3RyaW5nKS50b0NvbnRhaW4oc3Vic3RyaW5nKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvQ29udGFpbihtYXRjaGVyc1V0aWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhc3M6IG1hdGNoZXJzVXRpbC5jb250YWlucyhhY3R1YWwsIGV4cGVjdGVkKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9Db250YWluO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0VxdWFsID0gZnVuY3Rpb24oaiQpIHtcbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgdmFsdWUgdG8gYmUgZXF1YWwgdG8gdGhlIGV4cGVjdGVkLCB1c2luZyBkZWVwIGVxdWFsaXR5IGNvbXBhcmlzb24uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0VxdWFsXG4gICAqIEBzaW5jZSAxLjMuMFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXhwZWN0ZWQgLSBFeHBlY3RlZCB2YWx1ZVxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QoYmlnT2JqZWN0KS50b0VxdWFsKHtcImZvb1wiOiBbJ2JhcicsICdiYXonXX0pO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9FcXVhbChtYXRjaGVyc1V0aWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgcGFzczogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRpZmZCdWlsZGVyID0gaiQuRGlmZkJ1aWxkZXIoeyBwcmV0dHlQcmludGVyOiBtYXRjaGVyc1V0aWwucHAgfSk7XG5cbiAgICAgICAgcmVzdWx0LnBhc3MgPSBtYXRjaGVyc1V0aWwuZXF1YWxzKGFjdHVhbCwgZXhwZWN0ZWQsIGRpZmZCdWlsZGVyKTtcblxuICAgICAgICAvLyBUT0RPOiBvbmx5IHNldCBlcnJvciBtZXNzYWdlIGlmIHRlc3QgZmFpbHNcbiAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSBkaWZmQnVpbGRlci5nZXRNZXNzYWdlKCk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvRXF1YWw7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvSGF2ZUJlZW5DYWxsZWQgPSBmdW5jdGlvbihqJCkge1xuICB2YXIgZ2V0RXJyb3JNc2cgPSBqJC5mb3JtYXRFcnJvck1zZyhcbiAgICAnPHRvSGF2ZUJlZW5DYWxsZWQ+JyxcbiAgICAnZXhwZWN0KDxzcHlPYmo+KS50b0hhdmVCZWVuQ2FsbGVkKCknXG4gICk7XG5cbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgKGEge0BsaW5rIFNweX0pIHRvIGhhdmUgYmVlbiBjYWxsZWQuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0hhdmVCZWVuQ2FsbGVkXG4gICAqIEBzaW5jZSAxLjMuMFxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QobXlTcHkpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICogZXhwZWN0KG15U3B5KS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9IYXZlQmVlbkNhbGxlZChtYXRjaGVyc1V0aWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgICAgICBpZiAoIWokLmlzU3B5KGFjdHVhbCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBnZXRFcnJvck1zZyhcbiAgICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3B5LCBidXQgZ290ICcgKyBtYXRjaGVyc1V0aWwucHAoYWN0dWFsKSArICcuJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBnZXRFcnJvck1zZygnRG9lcyBub3QgdGFrZSBhcmd1bWVudHMsIHVzZSB0b0hhdmVCZWVuQ2FsbGVkV2l0aCcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wYXNzID0gYWN0dWFsLmNhbGxzLmFueSgpO1xuXG4gICAgICAgIHJlc3VsdC5tZXNzYWdlID0gcmVzdWx0LnBhc3NcbiAgICAgICAgICA/ICdFeHBlY3RlZCBzcHkgJyArIGFjdHVhbC5hbmQuaWRlbnRpdHkgKyAnIG5vdCB0byBoYXZlIGJlZW4gY2FsbGVkLidcbiAgICAgICAgICA6ICdFeHBlY3RlZCBzcHkgJyArIGFjdHVhbC5hbmQuaWRlbnRpdHkgKyAnIHRvIGhhdmUgYmVlbiBjYWxsZWQuJztcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9IYXZlQmVlbkNhbGxlZDtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9IYXZlQmVlbkNhbGxlZEJlZm9yZSA9IGZ1bmN0aW9uKGokKSB7XG4gIHZhciBnZXRFcnJvck1zZyA9IGokLmZvcm1hdEVycm9yTXNnKFxuICAgICc8dG9IYXZlQmVlbkNhbGxlZEJlZm9yZT4nLFxuICAgICdleHBlY3QoPHNweU9iaj4pLnRvSGF2ZUJlZW5DYWxsZWRCZWZvcmUoPHNweU9iaj4pJ1xuICApO1xuXG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIHZhbHVlIChhIHtAbGluayBTcHl9KSB0byBoYXZlIGJlZW4gY2FsbGVkIGJlZm9yZSBhbm90aGVyIHtAbGluayBTcHl9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9IYXZlQmVlbkNhbGxlZEJlZm9yZVxuICAgKiBAc2luY2UgMi42LjBcbiAgICogQHBhcmFtIHtTcHl9IGV4cGVjdGVkIC0ge0BsaW5rIFNweX0gdGhhdCBzaG91bGQgaGF2ZSBiZWVuIGNhbGxlZCBhZnRlciB0aGUgYGFjdHVhbGAge0BsaW5rIFNweX0uXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdChteVNweSkudG9IYXZlQmVlbkNhbGxlZEJlZm9yZShvdGhlclNweSk7XG4gICAqL1xuICBmdW5jdGlvbiB0b0hhdmVCZWVuQ2FsbGVkQmVmb3JlKG1hdGNoZXJzVXRpbCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihmaXJzdFNweSwgbGF0dGVyU3B5KSB7XG4gICAgICAgIGlmICghaiQuaXNTcHkoZmlyc3RTcHkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgZ2V0RXJyb3JNc2coXG4gICAgICAgICAgICAgICdFeHBlY3RlZCBhIHNweSwgYnV0IGdvdCAnICsgbWF0Y2hlcnNVdGlsLnBwKGZpcnN0U3B5KSArICcuJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFqJC5pc1NweShsYXR0ZXJTcHkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgZ2V0RXJyb3JNc2coXG4gICAgICAgICAgICAgICdFeHBlY3RlZCBhIHNweSwgYnV0IGdvdCAnICsgbWF0Y2hlcnNVdGlsLnBwKGxhdHRlclNweSkgKyAnLidcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgcGFzczogZmFsc2UgfTtcblxuICAgICAgICBpZiAoIWZpcnN0U3B5LmNhbGxzLmNvdW50KCkpIHtcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9XG4gICAgICAgICAgICAnRXhwZWN0ZWQgc3B5ICcgKyBmaXJzdFNweS5hbmQuaWRlbnRpdHkgKyAnIHRvIGhhdmUgYmVlbiBjYWxsZWQuJztcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghbGF0dGVyU3B5LmNhbGxzLmNvdW50KCkpIHtcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9XG4gICAgICAgICAgICAnRXhwZWN0ZWQgc3B5ICcgKyBsYXR0ZXJTcHkuYW5kLmlkZW50aXR5ICsgJyB0byBoYXZlIGJlZW4gY2FsbGVkLic7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXRlc3Qxc3RTcHlDYWxsID0gZmlyc3RTcHkuY2FsbHMubW9zdFJlY2VudCgpLmludm9jYXRpb25PcmRlcjtcbiAgICAgICAgdmFyIGZpcnN0Mm5kU3B5Q2FsbCA9IGxhdHRlclNweS5jYWxscy5maXJzdCgpLmludm9jYXRpb25PcmRlcjtcblxuICAgICAgICByZXN1bHQucGFzcyA9IGxhdGVzdDFzdFNweUNhbGwgPCBmaXJzdDJuZFNweUNhbGw7XG5cbiAgICAgICAgaWYgKHJlc3VsdC5wYXNzKSB7XG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPVxuICAgICAgICAgICAgJ0V4cGVjdGVkIHNweSAnICtcbiAgICAgICAgICAgIGZpcnN0U3B5LmFuZC5pZGVudGl0eSArXG4gICAgICAgICAgICAnIHRvIG5vdCBoYXZlIGJlZW4gY2FsbGVkIGJlZm9yZSBzcHkgJyArXG4gICAgICAgICAgICBsYXR0ZXJTcHkuYW5kLmlkZW50aXR5ICtcbiAgICAgICAgICAgICcsIGJ1dCBpdCB3YXMnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBmaXJzdDFzdFNweUNhbGwgPSBmaXJzdFNweS5jYWxscy5maXJzdCgpLmludm9jYXRpb25PcmRlcjtcbiAgICAgICAgICB2YXIgbGF0ZXN0Mm5kU3B5Q2FsbCA9IGxhdHRlclNweS5jYWxscy5tb3N0UmVjZW50KCkuaW52b2NhdGlvbk9yZGVyO1xuXG4gICAgICAgICAgaWYgKGZpcnN0MXN0U3B5Q2FsbCA8IGZpcnN0Mm5kU3B5Q2FsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPVxuICAgICAgICAgICAgICAnRXhwZWN0ZWQgbGF0ZXN0IGNhbGwgdG8gc3B5ICcgK1xuICAgICAgICAgICAgICBmaXJzdFNweS5hbmQuaWRlbnRpdHkgK1xuICAgICAgICAgICAgICAnIHRvIGhhdmUgYmVlbiBjYWxsZWQgYmVmb3JlIGZpcnN0IGNhbGwgdG8gc3B5ICcgK1xuICAgICAgICAgICAgICBsYXR0ZXJTcHkuYW5kLmlkZW50aXR5ICtcbiAgICAgICAgICAgICAgJyAobm8gaW50ZXJsZWF2ZWQgY2FsbHMpJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGxhdGVzdDJuZFNweUNhbGwgPiBsYXRlc3Qxc3RTcHlDYWxsKSB7XG4gICAgICAgICAgICByZXN1bHQubWVzc2FnZSA9XG4gICAgICAgICAgICAgICdFeHBlY3RlZCBmaXJzdCBjYWxsIHRvIHNweSAnICtcbiAgICAgICAgICAgICAgbGF0dGVyU3B5LmFuZC5pZGVudGl0eSArXG4gICAgICAgICAgICAgICcgdG8gaGF2ZSBiZWVuIGNhbGxlZCBhZnRlciBsYXRlc3QgY2FsbCB0byBzcHkgJyArXG4gICAgICAgICAgICAgIGZpcnN0U3B5LmFuZC5pZGVudGl0eSArXG4gICAgICAgICAgICAgICcgKG5vIGludGVybGVhdmVkIGNhbGxzKSc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID1cbiAgICAgICAgICAgICAgJ0V4cGVjdGVkIHNweSAnICtcbiAgICAgICAgICAgICAgZmlyc3RTcHkuYW5kLmlkZW50aXR5ICtcbiAgICAgICAgICAgICAgJyB0byBoYXZlIGJlZW4gY2FsbGVkIGJlZm9yZSBzcHkgJyArXG4gICAgICAgICAgICAgIGxhdHRlclNweS5hbmQuaWRlbnRpdHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvSGF2ZUJlZW5DYWxsZWRCZWZvcmU7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvSGF2ZUJlZW5DYWxsZWRPbmNlV2l0aCA9IGZ1bmN0aW9uKGokKSB7XG4gIHZhciBnZXRFcnJvck1zZyA9IGokLmZvcm1hdEVycm9yTXNnKFxuICAgICc8dG9IYXZlQmVlbkNhbGxlZE9uY2VXaXRoPicsXG4gICAgJ2V4cGVjdCg8c3B5T2JqPikudG9IYXZlQmVlbkNhbGxlZE9uY2VXaXRoKC4uLmFyZ3VtZW50cyknXG4gICk7XG5cbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgKGEge0BsaW5rIFNweX0pIHRvIGhhdmUgYmVlbiBjYWxsZWQgZXhhY3RseSBvbmNlLCBhbmQgZXhhY3RseSB3aXRoIHRoZSBwYXJ0aWN1bGFyIGFyZ3VtZW50cy5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvSGF2ZUJlZW5DYWxsZWRPbmNlV2l0aFxuICAgKiBAc2luY2UgMy42LjBcbiAgICogQHBhcmFtIHsuLi5PYmplY3R9IC0gVGhlIGFyZ3VtZW50cyB0byBsb29rIGZvclxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QobXlTcHkpLnRvSGF2ZUJlZW5DYWxsZWRPbmNlV2l0aCgnZm9vJywgJ2JhcicsIDIpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9IYXZlQmVlbkNhbGxlZE9uY2VXaXRoKHV0aWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSxcbiAgICAgICAgICBhY3R1YWwgPSBhcmdzWzBdLFxuICAgICAgICAgIGV4cGVjdGVkQXJncyA9IGFyZ3Muc2xpY2UoMSk7XG5cbiAgICAgICAgaWYgKCFqJC5pc1NweShhY3R1YWwpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgZ2V0RXJyb3JNc2coJ0V4cGVjdGVkIGEgc3B5LCBidXQgZ290ICcgKyB1dGlsLnBwKGFjdHVhbCkgKyAnLicpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmV0dHlQcmludGVkQ2FsbHMgPSBhY3R1YWwuY2FsbHNcbiAgICAgICAgICAuYWxsQXJncygpXG4gICAgICAgICAgLm1hcChmdW5jdGlvbihhcmdzRm9yQ2FsbCkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyB1dGlsLnBwKGFyZ3NGb3JDYWxsKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgYWN0dWFsLmNhbGxzLmNvdW50KCkgPT09IDEgJiZcbiAgICAgICAgICB1dGlsLmNvbnRhaW5zKGFjdHVhbC5jYWxscy5hbGxBcmdzKCksIGV4cGVjdGVkQXJncylcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhc3M6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgICAnRXhwZWN0ZWQgc3B5ICcgK1xuICAgICAgICAgICAgICBhY3R1YWwuYW5kLmlkZW50aXR5ICtcbiAgICAgICAgICAgICAgJyB0byBoYXZlIGJlZW4gY2FsbGVkIDAgdGltZXMsIG11bHRpcGxlIHRpbWVzLCBvciBvbmNlLCBidXQgd2l0aCBhcmd1bWVudHMgZGlmZmVyZW50IGZyb206XFxuJyArXG4gICAgICAgICAgICAgICcgICcgK1xuICAgICAgICAgICAgICB1dGlsLnBwKGV4cGVjdGVkQXJncykgK1xuICAgICAgICAgICAgICAnXFxuJyArXG4gICAgICAgICAgICAgICdCdXQgdGhlIGFjdHVhbCBjYWxsIHdhczpcXG4nICtcbiAgICAgICAgICAgICAgcHJldHR5UHJpbnRlZENhbGxzLmpvaW4oJyxcXG4nKSArXG4gICAgICAgICAgICAgICcuXFxuXFxuJ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXREaWZmcygpIHtcbiAgICAgICAgICByZXR1cm4gYWN0dWFsLmNhbGxzLmFsbEFyZ3MoKS5tYXAoZnVuY3Rpb24oYXJnc0ZvckNhbGwsIGNhbGxJeCkge1xuICAgICAgICAgICAgdmFyIGRpZmZCdWlsZGVyID0gbmV3IGokLkRpZmZCdWlsZGVyKCk7XG4gICAgICAgICAgICB1dGlsLmVxdWFscyhhcmdzRm9yQ2FsbCwgZXhwZWN0ZWRBcmdzLCBkaWZmQnVpbGRlcik7XG4gICAgICAgICAgICByZXR1cm4gZGlmZkJ1aWxkZXIuZ2V0TWVzc2FnZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYnV0U3RyaW5nKCkge1xuICAgICAgICAgIHN3aXRjaCAoYWN0dWFsLmNhbGxzLmNvdW50KCkpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgcmV0dXJuICdCdXQgaXQgd2FzIG5ldmVyIGNhbGxlZC5cXG5cXG4nO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICdCdXQgdGhlIGFjdHVhbCBjYWxsIHdhczpcXG4nICtcbiAgICAgICAgICAgICAgICBwcmV0dHlQcmludGVkQ2FsbHMuam9pbignLFxcbicpICtcbiAgICAgICAgICAgICAgICAnLlxcbicgK1xuICAgICAgICAgICAgICAgIGdldERpZmZzKCkuam9pbignXFxuJykgK1xuICAgICAgICAgICAgICAgICdcXG5cXG4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICdCdXQgdGhlIGFjdHVhbCBjYWxscyB3ZXJlOlxcbicgK1xuICAgICAgICAgICAgICAgIHByZXR0eVByaW50ZWRDYWxscy5qb2luKCcsXFxuJykgK1xuICAgICAgICAgICAgICAgICcuXFxuXFxuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFzczogZmFsc2UsXG4gICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICdFeHBlY3RlZCBzcHkgJyArXG4gICAgICAgICAgICBhY3R1YWwuYW5kLmlkZW50aXR5ICtcbiAgICAgICAgICAgICcgdG8gaGF2ZSBiZWVuIGNhbGxlZCBvbmx5IG9uY2UsIGFuZCB3aXRoIGdpdmVuIGFyZ3M6XFxuJyArXG4gICAgICAgICAgICAnICAnICtcbiAgICAgICAgICAgIHV0aWwucHAoZXhwZWN0ZWRBcmdzKSArXG4gICAgICAgICAgICAnXFxuJyArXG4gICAgICAgICAgICBidXRTdHJpbmcoKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9IYXZlQmVlbkNhbGxlZE9uY2VXaXRoO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMgPSBmdW5jdGlvbihqJCkge1xuICB2YXIgZ2V0RXJyb3JNc2cgPSBqJC5mb3JtYXRFcnJvck1zZyhcbiAgICAnPHRvSGF2ZUJlZW5DYWxsZWRUaW1lcz4nLFxuICAgICdleHBlY3QoPHNweU9iaj4pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcyg8TnVtYmVyPiknXG4gICk7XG5cbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgKGEge0BsaW5rIFNweX0pIHRvIGhhdmUgYmVlbiBjYWxsZWQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgdGltZXMuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0hhdmVCZWVuQ2FsbGVkVGltZXNcbiAgICogQHNpbmNlIDIuNC4wXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBleHBlY3RlZCAtIFRoZSBudW1iZXIgb2YgaW52b2NhdGlvbnMgdG8gbG9vayBmb3IuXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdChteVNweSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDMpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9IYXZlQmVlbkNhbGxlZFRpbWVzKG1hdGNoZXJzVXRpbCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gICAgICAgIGlmICghaiQuaXNTcHkoYWN0dWFsKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGdldEVycm9yTXNnKFxuICAgICAgICAgICAgICAnRXhwZWN0ZWQgYSBzcHksIGJ1dCBnb3QgJyArIG1hdGNoZXJzVXRpbC5wcChhY3R1YWwpICsgJy4nXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSB7IHBhc3M6IGZhbHNlIH07XG5cbiAgICAgICAgaWYgKCFqJC5pc051bWJlcl8oZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgZ2V0RXJyb3JNc2coXG4gICAgICAgICAgICAgICdUaGUgZXhwZWN0ZWQgdGltZXMgZmFpbGVkIGlzIGEgcmVxdWlyZWQgYXJndW1lbnQgYW5kIG11c3QgYmUgYSBudW1iZXIuJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBhY3R1YWwgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgY2FsbHMgPSBhY3R1YWwuY2FsbHMuY291bnQoKTtcbiAgICAgICAgdmFyIHRpbWVzTWVzc2FnZSA9IGV4cGVjdGVkID09PSAxID8gJ29uY2UnIDogZXhwZWN0ZWQgKyAnIHRpbWVzJztcbiAgICAgICAgcmVzdWx0LnBhc3MgPSBjYWxscyA9PT0gZXhwZWN0ZWQ7XG4gICAgICAgIHJlc3VsdC5tZXNzYWdlID0gcmVzdWx0LnBhc3NcbiAgICAgICAgICA/ICdFeHBlY3RlZCBzcHkgJyArXG4gICAgICAgICAgICBhY3R1YWwuYW5kLmlkZW50aXR5ICtcbiAgICAgICAgICAgICcgbm90IHRvIGhhdmUgYmVlbiBjYWxsZWQgJyArXG4gICAgICAgICAgICB0aW1lc01lc3NhZ2UgK1xuICAgICAgICAgICAgJy4gSXQgd2FzIGNhbGxlZCAnICtcbiAgICAgICAgICAgIGNhbGxzICtcbiAgICAgICAgICAgICcgdGltZXMuJ1xuICAgICAgICAgIDogJ0V4cGVjdGVkIHNweSAnICtcbiAgICAgICAgICAgIGFjdHVhbC5hbmQuaWRlbnRpdHkgK1xuICAgICAgICAgICAgJyB0byBoYXZlIGJlZW4gY2FsbGVkICcgK1xuICAgICAgICAgICAgdGltZXNNZXNzYWdlICtcbiAgICAgICAgICAgICcuIEl0IHdhcyBjYWxsZWQgJyArXG4gICAgICAgICAgICBjYWxscyArXG4gICAgICAgICAgICAnIHRpbWVzLic7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0hhdmVCZWVuQ2FsbGVkVGltZXM7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoID0gZnVuY3Rpb24oaiQpIHtcbiAgdmFyIGdldEVycm9yTXNnID0gaiQuZm9ybWF0RXJyb3JNc2coXG4gICAgJzx0b0hhdmVCZWVuQ2FsbGVkV2l0aD4nLFxuICAgICdleHBlY3QoPHNweU9iaj4pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKC4uLmFyZ3VtZW50cyknXG4gICk7XG5cbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgKGEge0BsaW5rIFNweX0pIHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aCBwYXJ0aWN1bGFyIGFyZ3VtZW50cyBhdCBsZWFzdCBvbmNlLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9IYXZlQmVlbkNhbGxlZFdpdGhcbiAgICogQHNpbmNlIDEuMy4wXG4gICAqIEBwYXJhbSB7Li4uT2JqZWN0fSAtIFRoZSBhcmd1bWVudHMgdG8gbG9vayBmb3JcbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KG15U3B5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnZm9vJywgJ2JhcicsIDIpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9IYXZlQmVlbkNhbGxlZFdpdGgobWF0Y2hlcnNVdGlsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCksXG4gICAgICAgICAgYWN0dWFsID0gYXJnc1swXSxcbiAgICAgICAgICBleHBlY3RlZEFyZ3MgPSBhcmdzLnNsaWNlKDEpLFxuICAgICAgICAgIHJlc3VsdCA9IHsgcGFzczogZmFsc2UgfTtcblxuICAgICAgICBpZiAoIWokLmlzU3B5KGFjdHVhbCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBnZXRFcnJvck1zZyhcbiAgICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3B5LCBidXQgZ290ICcgKyBtYXRjaGVyc1V0aWwucHAoYWN0dWFsKSArICcuJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFjdHVhbC5jYWxscy5hbnkoKSkge1xuICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAnRXhwZWN0ZWQgc3B5ICcgK1xuICAgICAgICAgICAgICBhY3R1YWwuYW5kLmlkZW50aXR5ICtcbiAgICAgICAgICAgICAgJyB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGg6XFxuJyArXG4gICAgICAgICAgICAgICcgICcgK1xuICAgICAgICAgICAgICBtYXRjaGVyc1V0aWwucHAoZXhwZWN0ZWRBcmdzKSArXG4gICAgICAgICAgICAgICdcXG5idXQgaXQgd2FzIG5ldmVyIGNhbGxlZC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaGVyc1V0aWwuY29udGFpbnMoYWN0dWFsLmNhbGxzLmFsbEFyZ3MoKSwgZXhwZWN0ZWRBcmdzKSkge1xuICAgICAgICAgIHJlc3VsdC5wYXNzID0gdHJ1ZTtcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgJ0V4cGVjdGVkIHNweSAnICtcbiAgICAgICAgICAgICAgYWN0dWFsLmFuZC5pZGVudGl0eSArXG4gICAgICAgICAgICAgICcgbm90IHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aDpcXG4nICtcbiAgICAgICAgICAgICAgJyAgJyArXG4gICAgICAgICAgICAgIG1hdGNoZXJzVXRpbC5wcChleHBlY3RlZEFyZ3MpICtcbiAgICAgICAgICAgICAgJ1xcbmJ1dCBpdCB3YXMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcHJldHR5UHJpbnRlZENhbGxzID0gYWN0dWFsLmNhbGxzXG4gICAgICAgICAgICAgIC5hbGxBcmdzKClcbiAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihhcmdzRm9yQ2FsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnICAnICsgbWF0Y2hlcnNVdGlsLnBwKGFyZ3NGb3JDYWxsKTtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBkaWZmcyA9IGFjdHVhbC5jYWxsc1xuICAgICAgICAgICAgICAuYWxsQXJncygpXG4gICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oYXJnc0ZvckNhbGwsIGNhbGxJeCkge1xuICAgICAgICAgICAgICAgIHZhciBkaWZmQnVpbGRlciA9IG5ldyBqJC5EaWZmQnVpbGRlcigpO1xuICAgICAgICAgICAgICAgIG1hdGNoZXJzVXRpbC5lcXVhbHMoYXJnc0ZvckNhbGwsIGV4cGVjdGVkQXJncywgZGlmZkJ1aWxkZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAnQ2FsbCAnICtcbiAgICAgICAgICAgICAgICAgIGNhbGxJeCArXG4gICAgICAgICAgICAgICAgICAnOlxcbicgK1xuICAgICAgICAgICAgICAgICAgZGlmZkJ1aWxkZXIuZ2V0TWVzc2FnZSgpLnJlcGxhY2UoL14vZ20sICcgICcpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICdFeHBlY3RlZCBzcHkgJyArXG4gICAgICAgICAgICAgIGFjdHVhbC5hbmQuaWRlbnRpdHkgK1xuICAgICAgICAgICAgICAnIHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aDpcXG4nICtcbiAgICAgICAgICAgICAgJyAgJyArXG4gICAgICAgICAgICAgIG1hdGNoZXJzVXRpbC5wcChleHBlY3RlZEFyZ3MpICtcbiAgICAgICAgICAgICAgJ1xcbicgK1xuICAgICAgICAgICAgICAnJyArXG4gICAgICAgICAgICAgICdidXQgYWN0dWFsIGNhbGxzIHdlcmU6XFxuJyArXG4gICAgICAgICAgICAgIHByZXR0eVByaW50ZWRDYWxscy5qb2luKCcsXFxuJykgK1xuICAgICAgICAgICAgICAnLlxcblxcbicgK1xuICAgICAgICAgICAgICBkaWZmcy5qb2luKCdcXG4nKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvSGF2ZUJlZW5DYWxsZWRXaXRoO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0hhdmVDbGFzcyA9IGZ1bmN0aW9uKGokKSB7XG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIHZhbHVlIHRvIGJlIGEgRE9NIGVsZW1lbnQgdGhhdCBoYXMgdGhlIGV4cGVjdGVkIGNsYXNzXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0hhdmVDbGFzc1xuICAgKiBAc2luY2UgMy4wLjBcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4cGVjdGVkIC0gVGhlIGNsYXNzIG5hbWUgdG8gdGVzdCBmb3JcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAqIGVsLmNsYXNzTmFtZSA9ICdmb28gYmFyIGJheic7XG4gICAqIGV4cGVjdChlbCkudG9IYXZlQ2xhc3MoJ2JhcicpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9IYXZlQ2xhc3MobWF0Y2hlcnNVdGlsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgICAgICAgaWYgKCFpc0VsZW1lbnQoYWN0dWFsKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtYXRjaGVyc1V0aWwucHAoYWN0dWFsKSArICcgaXMgbm90IGEgRE9NIGVsZW1lbnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFzczogYWN0dWFsLmNsYXNzTGlzdC5jb250YWlucyhleHBlY3RlZClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNFbGVtZW50KG1heWJlRWwpIHtcbiAgICByZXR1cm4gKFxuICAgICAgbWF5YmVFbCAmJiBtYXliZUVsLmNsYXNzTGlzdCAmJiBqJC5pc0Z1bmN0aW9uXyhtYXliZUVsLmNsYXNzTGlzdC5jb250YWlucylcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHRvSGF2ZUNsYXNzO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0hhdmVTaXplID0gZnVuY3Rpb24oaiQpIHtcbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgc2l6ZSB0byBiZSBlcXVhbCB0byB0aGUgZXhwZWN0ZWQsIHVzaW5nIGFycmF5LWxpa2UgbGVuZ3RoIG9yIG9iamVjdCBrZXlzIHNpemUuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0hhdmVTaXplXG4gICAqIEBzaW5jZSAzLjYuMFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXhwZWN0ZWQgLSBFeHBlY3RlZCBzaXplXG4gICAqIEBleGFtcGxlXG4gICAqIGFycmF5ID0gWzEsMl07XG4gICAqIGV4cGVjdChhcnJheSkudG9IYXZlU2l6ZSgyKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvSGF2ZVNpemUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICBwYXNzOiBmYWxzZVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBqJC5pc0FfKCdXZWFrU2V0JywgYWN0dWFsKSB8fFxuICAgICAgICAgIGokLmlzV2Vha01hcChhY3R1YWwpIHx8XG4gICAgICAgICAgaiQuaXNEYXRhVmlldyhhY3R1YWwpXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGdldCBzaXplIG9mICcgKyBhY3R1YWwgKyAnLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGokLmlzU2V0KGFjdHVhbCkgfHwgaiQuaXNNYXAoYWN0dWFsKSkge1xuICAgICAgICAgIHJlc3VsdC5wYXNzID0gYWN0dWFsLnNpemUgPT09IGV4cGVjdGVkO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTGVuZ3RoKGFjdHVhbC5sZW5ndGgpKSB7XG4gICAgICAgICAgcmVzdWx0LnBhc3MgPSBhY3R1YWwubGVuZ3RoID09PSBleHBlY3RlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucGFzcyA9IE9iamVjdC5rZXlzKGFjdHVhbCkubGVuZ3RoID09PSBleHBlY3RlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHZhciBNQVhfU0FGRV9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgOTAwNzE5OTI1NDc0MDk5MTtcbiAgZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgICB2YWx1ZSA+IC0xICYmXG4gICAgICB2YWx1ZSAlIDEgPT09IDAgJiZcbiAgICAgIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVJcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHRvSGF2ZVNpemU7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvTWF0Y2ggPSBmdW5jdGlvbihqJCkge1xuICB2YXIgZ2V0RXJyb3JNc2cgPSBqJC5mb3JtYXRFcnJvck1zZyhcbiAgICAnPHRvTWF0Y2g+JyxcbiAgICAnZXhwZWN0KDxleHBlY3RhdGlvbj4pLnRvTWF0Y2goPHN0cmluZz4gfHwgPHJlZ2V4cD4pJ1xuICApO1xuXG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIHZhbHVlIHRvIG1hdGNoIGEgcmVndWxhciBleHByZXNzaW9uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b01hdGNoXG4gICAqIEBzaW5jZSAxLjMuMFxuICAgKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IGV4cGVjdGVkIC0gVmFsdWUgdG8gbG9vayBmb3IgaW4gdGhlIHN0cmluZy5cbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KFwibXkgc3RyaW5nXCIpLnRvTWF0Y2goL3N0cmluZyQvKTtcbiAgICogZXhwZWN0KFwib3RoZXIgc3RyaW5nXCIpLnRvTWF0Y2goXCJoZXJcIik7XG4gICAqL1xuICBmdW5jdGlvbiB0b01hdGNoKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gICAgICAgIGlmICghaiQuaXNTdHJpbmdfKGV4cGVjdGVkKSAmJiAhaiQuaXNBXygnUmVnRXhwJywgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGdldEVycm9yTXNnKCdFeHBlY3RlZCBpcyBub3QgYSBTdHJpbmcgb3IgYSBSZWdFeHAnKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cChleHBlY3RlZCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXNzOiByZWdleHAudGVzdChhY3R1YWwpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b01hdGNoO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b1Rocm93ID0gZnVuY3Rpb24oaiQpIHtcbiAgdmFyIGdldEVycm9yTXNnID0gaiQuZm9ybWF0RXJyb3JNc2coXG4gICAgJzx0b1Rocm93PicsXG4gICAgJ2V4cGVjdChmdW5jdGlvbigpIHs8ZXhwZWN0YXRpb24+fSkudG9UaHJvdygpJ1xuICApO1xuXG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSBhIGZ1bmN0aW9uIHRvIGB0aHJvd2Agc29tZXRoaW5nLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9UaHJvd1xuICAgKiBAc2luY2UgMi4wLjBcbiAgICogQHBhcmFtIHtPYmplY3R9IFtleHBlY3RlZF0gLSBWYWx1ZSB0aGF0IHNob3VsZCBiZSB0aHJvd24uIElmIG5vdCBwcm92aWRlZCwgc2ltcGx5IHRoZSBmYWN0IHRoYXQgc29tZXRoaW5nIHdhcyB0aHJvd24gd2lsbCBiZSBjaGVja2VkLlxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QoZnVuY3Rpb24oKSB7IHJldHVybiAndGhpbmdzJzsgfSkudG9UaHJvdygnZm9vJyk7XG4gICAqIGV4cGVjdChmdW5jdGlvbigpIHsgcmV0dXJuICdzdHVmZic7IH0pLnRvVGhyb3coKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvVGhyb3cobWF0Y2hlcnNVdGlsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgcGFzczogZmFsc2UgfSxcbiAgICAgICAgICB0aHJldyA9IGZhbHNlLFxuICAgICAgICAgIHRocm93bjtcblxuICAgICAgICBpZiAodHlwZW9mIGFjdHVhbCAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGdldEVycm9yTXNnKCdBY3R1YWwgaXMgbm90IGEgRnVuY3Rpb24nKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGFjdHVhbCgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyZXcgPSB0cnVlO1xuICAgICAgICAgIHRocm93biA9IGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRocmV3KSB7XG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSAnRXhwZWN0ZWQgZnVuY3Rpb24gdG8gdGhyb3cgYW4gZXhjZXB0aW9uLic7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICByZXN1bHQucGFzcyA9IHRydWU7XG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICdFeHBlY3RlZCBmdW5jdGlvbiBub3QgdG8gdGhyb3csIGJ1dCBpdCB0aHJldyAnICtcbiAgICAgICAgICAgICAgbWF0Y2hlcnNVdGlsLnBwKHRocm93bikgK1xuICAgICAgICAgICAgICAnLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2hlcnNVdGlsLmVxdWFscyh0aHJvd24sIGV4cGVjdGVkKSkge1xuICAgICAgICAgIHJlc3VsdC5wYXNzID0gdHJ1ZTtcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgJ0V4cGVjdGVkIGZ1bmN0aW9uIG5vdCB0byB0aHJvdyAnICtcbiAgICAgICAgICAgICAgbWF0Y2hlcnNVdGlsLnBwKGV4cGVjdGVkKSArXG4gICAgICAgICAgICAgICcuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAnRXhwZWN0ZWQgZnVuY3Rpb24gdG8gdGhyb3cgJyArXG4gICAgICAgICAgICAgIG1hdGNoZXJzVXRpbC5wcChleHBlY3RlZCkgK1xuICAgICAgICAgICAgICAnLCBidXQgaXQgdGhyZXcgJyArXG4gICAgICAgICAgICAgIG1hdGNoZXJzVXRpbC5wcCh0aHJvd24pICtcbiAgICAgICAgICAgICAgJy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9UaHJvdztcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9UaHJvd0Vycm9yID0gZnVuY3Rpb24oaiQpIHtcbiAgdmFyIGdldEVycm9yTXNnID0gaiQuZm9ybWF0RXJyb3JNc2coXG4gICAgJzx0b1Rocm93RXJyb3I+JyxcbiAgICAnZXhwZWN0KGZ1bmN0aW9uKCkgezxleHBlY3RhdGlvbj59KS50b1Rocm93RXJyb3IoPEVycm9yQ29uc3RydWN0b3I+LCA8bWVzc2FnZT4pJ1xuICApO1xuXG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSBhIGZ1bmN0aW9uIHRvIGB0aHJvd2AgYW4gYEVycm9yYC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvVGhyb3dFcnJvclxuICAgKiBAc2luY2UgMi4wLjBcbiAgICogQHBhcmFtIHtFcnJvcn0gW2V4cGVjdGVkXSAtIGBFcnJvcmAgY29uc3RydWN0b3IgdGhlIG9iamVjdCB0aGF0IHdhcyB0aHJvd24gbmVlZHMgdG8gYmUgYW4gaW5zdGFuY2Ugb2YuIElmIG5vdCBwcm92aWRlZCwgYEVycm9yYCB3aWxsIGJlIHVzZWQuXG4gICAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gW21lc3NhZ2VdIC0gVGhlIG1lc3NhZ2UgdGhhdCBzaG91bGQgYmUgc2V0IG9uIHRoZSB0aHJvd24gYEVycm9yYFxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QoZnVuY3Rpb24oKSB7IHJldHVybiAndGhpbmdzJzsgfSkudG9UaHJvd0Vycm9yKE15Q3VzdG9tRXJyb3IsICdtZXNzYWdlJyk7XG4gICAqIGV4cGVjdChmdW5jdGlvbigpIHsgcmV0dXJuICd0aGluZ3MnOyB9KS50b1Rocm93RXJyb3IoTXlDdXN0b21FcnJvciwgL2Jhci8pO1xuICAgKiBleHBlY3QoZnVuY3Rpb24oKSB7IHJldHVybiAnc3R1ZmYnOyB9KS50b1Rocm93RXJyb3IoTXlDdXN0b21FcnJvcik7XG4gICAqIGV4cGVjdChmdW5jdGlvbigpIHsgcmV0dXJuICdvdGhlcic7IH0pLnRvVGhyb3dFcnJvcigvZm9vLyk7XG4gICAqIGV4cGVjdChmdW5jdGlvbigpIHsgcmV0dXJuICdvdGhlcic7IH0pLnRvVGhyb3dFcnJvcigpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9UaHJvd0Vycm9yKG1hdGNoZXJzVXRpbCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwpIHtcbiAgICAgICAgdmFyIGVycm9yTWF0Y2hlciA9IGdldE1hdGNoZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKSxcbiAgICAgICAgICB0aHJvd247XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhY3R1YWwgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihnZXRFcnJvck1zZygnQWN0dWFsIGlzIG5vdCBhIEZ1bmN0aW9uJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhY3R1YWwoKTtcbiAgICAgICAgICByZXR1cm4gZmFpbCgnRXhwZWN0ZWQgZnVuY3Rpb24gdG8gdGhyb3cgYW4gRXJyb3IuJyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvd24gPSBlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFqJC5pc0Vycm9yXyh0aHJvd24pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhaWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAnRXhwZWN0ZWQgZnVuY3Rpb24gdG8gdGhyb3cgYW4gRXJyb3IsIGJ1dCBpdCB0aHJldyAnICtcbiAgICAgICAgICAgICAgbWF0Y2hlcnNVdGlsLnBwKHRocm93bikgK1xuICAgICAgICAgICAgICAnLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXJyb3JNYXRjaGVyLm1hdGNoKHRocm93bik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldE1hdGNoZXIoKSB7XG4gICAgICB2YXIgZXhwZWN0ZWQsIGVycm9yVHlwZTtcblxuICAgICAgaWYgKGFyZ3VtZW50c1syXSkge1xuICAgICAgICBlcnJvclR5cGUgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIGV4cGVjdGVkID0gYXJndW1lbnRzWzJdO1xuICAgICAgICBpZiAoIWlzQW5FcnJvclR5cGUoZXJyb3JUeXBlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihnZXRFcnJvck1zZygnRXhwZWN0ZWQgZXJyb3IgdHlwZSBpcyBub3QgYW4gRXJyb3IuJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4YWN0TWF0Y2hlcihleHBlY3RlZCwgZXJyb3JUeXBlKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzFdKSB7XG4gICAgICAgIGV4cGVjdGVkID0gYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIGlmIChpc0FuRXJyb3JUeXBlKGFyZ3VtZW50c1sxXSkpIHtcbiAgICAgICAgICByZXR1cm4gZXhhY3RNYXRjaGVyKG51bGwsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGV4YWN0TWF0Y2hlcihhcmd1bWVudHNbMV0sIG51bGwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYW55TWF0Y2hlcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFueU1hdGNoZXIoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXRjaDogZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gcGFzcyhcbiAgICAgICAgICAgICdFeHBlY3RlZCBmdW5jdGlvbiBub3QgdG8gdGhyb3cgYW4gRXJyb3IsIGJ1dCBpdCB0aHJldyAnICtcbiAgICAgICAgICAgICAgaiQuZm5OYW1lRm9yKGVycm9yKSArXG4gICAgICAgICAgICAgICcuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhhY3RNYXRjaGVyKGV4cGVjdGVkLCBlcnJvclR5cGUpIHtcbiAgICAgIGlmIChleHBlY3RlZCAmJiAhaXNTdHJpbmdPclJlZ0V4cChleHBlY3RlZCkpIHtcbiAgICAgICAgaWYgKGVycm9yVHlwZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGdldEVycm9yTXNnKCdFeHBlY3RlZCBlcnJvciBtZXNzYWdlIGlzIG5vdCBhIHN0cmluZyBvciBSZWdFeHAuJylcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGdldEVycm9yTXNnKCdFeHBlY3RlZCBpcyBub3QgYW4gRXJyb3IsIHN0cmluZywgb3IgUmVnRXhwLicpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtZXNzYWdlTWF0Y2gobWVzc2FnZSkge1xuICAgICAgICBpZiAodHlwZW9mIGV4cGVjdGVkID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIGV4cGVjdGVkID09IG1lc3NhZ2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGVycm9yVHlwZURlc2NyaXB0aW9uID0gZXJyb3JUeXBlXG4gICAgICAgID8gaiQuZm5OYW1lRm9yKGVycm9yVHlwZSlcbiAgICAgICAgOiAnYW4gZXhjZXB0aW9uJztcblxuICAgICAgZnVuY3Rpb24gdGhyb3duRGVzY3JpcHRpb24odGhyb3duKSB7XG4gICAgICAgIHZhciB0aHJvd25OYW1lID0gZXJyb3JUeXBlXG4gICAgICAgICAgICA/IGokLmZuTmFtZUZvcih0aHJvd24uY29uc3RydWN0b3IpXG4gICAgICAgICAgICA6ICdhbiBleGNlcHRpb24nLFxuICAgICAgICAgIHRocm93bk1lc3NhZ2UgPSAnJztcblxuICAgICAgICBpZiAoZXhwZWN0ZWQpIHtcbiAgICAgICAgICB0aHJvd25NZXNzYWdlID0gJyB3aXRoIG1lc3NhZ2UgJyArIG1hdGNoZXJzVXRpbC5wcCh0aHJvd24ubWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhyb3duTmFtZSArIHRocm93bk1lc3NhZ2U7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1lc3NhZ2VEZXNjcmlwdGlvbigpIHtcbiAgICAgICAgaWYgKGV4cGVjdGVkID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9IGVsc2UgaWYgKGV4cGVjdGVkIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgcmV0dXJuICcgd2l0aCBhIG1lc3NhZ2UgbWF0Y2hpbmcgJyArIG1hdGNoZXJzVXRpbC5wcChleHBlY3RlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICcgd2l0aCBtZXNzYWdlICcgKyBtYXRjaGVyc1V0aWwucHAoZXhwZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1hdGNoZXMoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAoZXJyb3JUeXBlID09PSBudWxsIHx8IGVycm9yIGluc3RhbmNlb2YgZXJyb3JUeXBlKSAmJlxuICAgICAgICAgIChleHBlY3RlZCA9PT0gbnVsbCB8fCBtZXNzYWdlTWF0Y2goZXJyb3IubWVzc2FnZSkpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hdGNoOiBmdW5jdGlvbih0aHJvd24pIHtcbiAgICAgICAgICBpZiAobWF0Y2hlcyh0aHJvd24pKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFzcyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAnRXhwZWN0ZWQgZnVuY3Rpb24gbm90IHRvIHRocm93ICcgK1xuICAgICAgICAgICAgICAgIGVycm9yVHlwZURlc2NyaXB0aW9uICtcbiAgICAgICAgICAgICAgICBtZXNzYWdlRGVzY3JpcHRpb24oKSArXG4gICAgICAgICAgICAgICAgJy4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhaWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgJ0V4cGVjdGVkIGZ1bmN0aW9uIHRvIHRocm93ICcgK1xuICAgICAgICAgICAgICAgIGVycm9yVHlwZURlc2NyaXB0aW9uICtcbiAgICAgICAgICAgICAgICBtZXNzYWdlRGVzY3JpcHRpb24oKSArXG4gICAgICAgICAgICAgICAgJywgYnV0IGl0IHRocmV3ICcgK1xuICAgICAgICAgICAgICAgIHRocm93bkRlc2NyaXB0aW9uKHRocm93bikgK1xuICAgICAgICAgICAgICAgICcuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU3RyaW5nT3JSZWdFeHAocG90ZW50aWFsKSB7XG4gICAgICByZXR1cm4gcG90ZW50aWFsIGluc3RhbmNlb2YgUmVnRXhwIHx8IHR5cGVvZiBwb3RlbnRpYWwgPT0gJ3N0cmluZyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBbkVycm9yVHlwZSh0eXBlKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgU3Vycm9nYXRlID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgIFN1cnJvZ2F0ZS5wcm90b3R5cGUgPSB0eXBlLnByb3RvdHlwZTtcbiAgICAgIHJldHVybiBqJC5pc0Vycm9yXyhuZXcgU3Vycm9nYXRlKCkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhc3MobWVzc2FnZSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXNzOiB0cnVlLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBmYWlsKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGFzczogZmFsc2UsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b1Rocm93RXJyb3I7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvVGhyb3dNYXRjaGluZyA9IGZ1bmN0aW9uKGokKSB7XG4gIHZhciB1c2FnZUVycm9yID0gaiQuZm9ybWF0RXJyb3JNc2coXG4gICAgJzx0b1Rocm93TWF0Y2hpbmc+JyxcbiAgICAnZXhwZWN0KGZ1bmN0aW9uKCkgezxleHBlY3RhdGlvbj59KS50b1Rocm93TWF0Y2hpbmcoPFByZWRpY2F0ZT4pJ1xuICApO1xuXG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSBhIGZ1bmN0aW9uIHRvIGB0aHJvd2Agc29tZXRoaW5nIG1hdGNoaW5nIGEgcHJlZGljYXRlLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9UaHJvd01hdGNoaW5nXG4gICAqIEBzaW5jZSAzLjAuMFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgLSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIHRocm93biBleGNlcHRpb24gYXMgaXRzIHBhcmFtZXRlciBhbmQgcmV0dXJucyB0cnVlIGlmIGl0IG1hdGNoZXMuXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdChmdW5jdGlvbigpIHsgdGhyb3cgbmV3IEVycm9yKCdub3BlJyk7IH0pLnRvVGhyb3dNYXRjaGluZyhmdW5jdGlvbih0aHJvd24pIHsgcmV0dXJuIHRocm93bi5tZXNzYWdlID09PSAnbm9wZSc7IH0pO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9UaHJvd01hdGNoaW5nKG1hdGNoZXJzVXRpbCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwsIHByZWRpY2F0ZSkge1xuICAgICAgICB2YXIgdGhyb3duO1xuXG4gICAgICAgIGlmICh0eXBlb2YgYWN0dWFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHVzYWdlRXJyb3IoJ0FjdHVhbCBpcyBub3QgYSBGdW5jdGlvbicpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHVzYWdlRXJyb3IoJ1ByZWRpY2F0ZSBpcyBub3QgYSBGdW5jdGlvbicpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYWN0dWFsKCk7XG4gICAgICAgICAgcmV0dXJuIGZhaWwoJ0V4cGVjdGVkIGZ1bmN0aW9uIHRvIHRocm93IGFuIGV4Y2VwdGlvbi4nKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93biA9IGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJlZGljYXRlKHRocm93bikpIHtcbiAgICAgICAgICByZXR1cm4gcGFzcyhcbiAgICAgICAgICAgICdFeHBlY3RlZCBmdW5jdGlvbiBub3QgdG8gdGhyb3cgYW4gZXhjZXB0aW9uIG1hdGNoaW5nIGEgcHJlZGljYXRlLidcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWlsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgJ0V4cGVjdGVkIGZ1bmN0aW9uIHRvIHRocm93IGFuIGV4Y2VwdGlvbiBtYXRjaGluZyBhIHByZWRpY2F0ZSwgJyArXG4gICAgICAgICAgICAgICdidXQgaXQgdGhyZXcgJyArXG4gICAgICAgICAgICAgIHRocm93bkRlc2NyaXB0aW9uKHRocm93bikgK1xuICAgICAgICAgICAgICAnLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdGhyb3duRGVzY3JpcHRpb24odGhyb3duKSB7XG4gICAgICBpZiAodGhyb3duICYmIHRocm93bi5jb25zdHJ1Y3Rvcikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGokLmZuTmFtZUZvcih0aHJvd24uY29uc3RydWN0b3IpICtcbiAgICAgICAgICAnIHdpdGggbWVzc2FnZSAnICtcbiAgICAgICAgICBtYXRjaGVyc1V0aWwucHAodGhyb3duLm1lc3NhZ2UpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWF0Y2hlcnNVdGlsLnBwKHRocm93bik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFzcyhtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhc3M6IHRydWUsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZhaWwobWVzc2FnZSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXNzOiBmYWxzZSxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvVGhyb3dNYXRjaGluZztcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuTW9ja0RhdGUgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBNb2NrRGF0ZShnbG9iYWwpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gMDtcblxuICAgIGlmICghZ2xvYmFsIHx8ICFnbG9iYWwuRGF0ZSkge1xuICAgICAgc2VsZi5pbnN0YWxsID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgIHNlbGYudGljayA9IGZ1bmN0aW9uKCkge307XG4gICAgICBzZWxmLnVuaW5zdGFsbCA9IGZ1bmN0aW9uKCkge307XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICB2YXIgR2xvYmFsRGF0ZSA9IGdsb2JhbC5EYXRlO1xuXG4gICAgc2VsZi5pbnN0YWxsID0gZnVuY3Rpb24obW9ja0RhdGUpIHtcbiAgICAgIGlmIChtb2NrRGF0ZSBpbnN0YW5jZW9mIEdsb2JhbERhdGUpIHtcbiAgICAgICAgY3VycmVudFRpbWUgPSBtb2NrRGF0ZS5nZXRUaW1lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWokLnV0aWwuaXNVbmRlZmluZWQobW9ja0RhdGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1RoZSBhcmd1bWVudCB0byBqYXNtaW5lLmNsb2NrKCkubW9ja0RhdGUoKSwgaWYgc3BlY2lmaWVkLCAnICtcbiAgICAgICAgICAgICAgJ3Nob3VsZCBiZSBhIERhdGUgaW5zdGFuY2UuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50VGltZSA9IG5ldyBHbG9iYWxEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgfVxuXG4gICAgICBnbG9iYWwuRGF0ZSA9IEZha2VEYXRlO1xuICAgIH07XG5cbiAgICBzZWxmLnRpY2sgPSBmdW5jdGlvbihtaWxsaXMpIHtcbiAgICAgIG1pbGxpcyA9IG1pbGxpcyB8fCAwO1xuICAgICAgY3VycmVudFRpbWUgPSBjdXJyZW50VGltZSArIG1pbGxpcztcbiAgICB9O1xuXG4gICAgc2VsZi51bmluc3RhbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgIGN1cnJlbnRUaW1lID0gMDtcbiAgICAgIGdsb2JhbC5EYXRlID0gR2xvYmFsRGF0ZTtcbiAgICB9O1xuXG4gICAgY3JlYXRlRGF0ZVByb3BlcnRpZXMoKTtcblxuICAgIHJldHVybiBzZWxmO1xuXG4gICAgZnVuY3Rpb24gRmFrZURhdGUoKSB7XG4gICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBuZXcgR2xvYmFsRGF0ZShjdXJyZW50VGltZSk7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gbmV3IEdsb2JhbERhdGUoYXJndW1lbnRzWzBdKTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJldHVybiBuZXcgR2xvYmFsRGF0ZShhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXR1cm4gbmV3IEdsb2JhbERhdGUoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gbmV3IEdsb2JhbERhdGUoXG4gICAgICAgICAgICBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgICBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICBhcmd1bWVudHNbMl0sXG4gICAgICAgICAgICBhcmd1bWVudHNbM11cbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmV0dXJuIG5ldyBHbG9iYWxEYXRlKFxuICAgICAgICAgICAgYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgYXJndW1lbnRzWzJdLFxuICAgICAgICAgICAgYXJndW1lbnRzWzNdLFxuICAgICAgICAgICAgYXJndW1lbnRzWzRdXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIHJldHVybiBuZXcgR2xvYmFsRGF0ZShcbiAgICAgICAgICAgIGFyZ3VtZW50c1swXSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1syXSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1szXSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1s0XSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1s1XVxuICAgICAgICAgICk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG5ldyBHbG9iYWxEYXRlKFxuICAgICAgICAgICAgYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgYXJndW1lbnRzWzJdLFxuICAgICAgICAgICAgYXJndW1lbnRzWzNdLFxuICAgICAgICAgICAgYXJndW1lbnRzWzRdLFxuICAgICAgICAgICAgYXJndW1lbnRzWzVdLFxuICAgICAgICAgICAgYXJndW1lbnRzWzZdXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEYXRlUHJvcGVydGllcygpIHtcbiAgICAgIEZha2VEYXRlLnByb3RvdHlwZSA9IEdsb2JhbERhdGUucHJvdG90eXBlO1xuXG4gICAgICBGYWtlRGF0ZS5ub3cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRUaW1lO1xuICAgICAgfTtcblxuICAgICAgRmFrZURhdGUudG9Tb3VyY2UgPSBHbG9iYWxEYXRlLnRvU291cmNlO1xuICAgICAgRmFrZURhdGUudG9TdHJpbmcgPSBHbG9iYWxEYXRlLnRvU3RyaW5nO1xuICAgICAgRmFrZURhdGUucGFyc2UgPSBHbG9iYWxEYXRlLnBhcnNlO1xuICAgICAgRmFrZURhdGUuVVRDID0gR2xvYmFsRGF0ZS5VVEM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIE1vY2tEYXRlO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5OZXZlclNraXBQb2xpY3kgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBOZXZlclNraXBQb2xpY3kocXVldWVhYmxlRm5zKSB7fVxuXG4gIE5ldmVyU2tpcFBvbGljeS5wcm90b3R5cGUuc2tpcFRvID0gZnVuY3Rpb24obGFzdFJhbkZuSXgpIHtcbiAgICByZXR1cm4gbGFzdFJhbkZuSXggKyAxO1xuICB9O1xuXG4gIE5ldmVyU2tpcFBvbGljeS5wcm90b3R5cGUuZm5FcnJvcmVkID0gZnVuY3Rpb24oZm5JeCkge307XG5cbiAgcmV0dXJuIE5ldmVyU2tpcFBvbGljeTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkubWFrZVByZXR0eVByaW50ZXIgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBTaW5nbGVQcmV0dHlQcmludFJ1bihjdXN0b21PYmplY3RGb3JtYXR0ZXJzLCBwcCkge1xuICAgIHRoaXMuY3VzdG9tT2JqZWN0Rm9ybWF0dGVyc18gPSBjdXN0b21PYmplY3RGb3JtYXR0ZXJzO1xuICAgIHRoaXMucHBOZXN0TGV2ZWxfID0gMDtcbiAgICB0aGlzLnNlZW4gPSBbXTtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5zdHJpbmdQYXJ0cyA9IFtdO1xuICAgIHRoaXMucHBfID0gcHA7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNDdXN0b21Ub1N0cmluZyh2YWx1ZSkge1xuICAgIC8vIHZhbHVlLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nIGlmIHZhbHVlIGhhcyBubyBjdXN0b20gdG9TdHJpbmcgYnV0IGlzIGZyb20gYW5vdGhlciBjb250ZXh0IChlLmcuXG4gICAgLy8gaWZyYW1lLCB3ZWIgd29ya2VyKVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBqJC5pc0Z1bmN0aW9uXyh2YWx1ZS50b1N0cmluZykgJiZcbiAgICAgICAgdmFsdWUudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgJiZcbiAgICAgICAgdmFsdWUudG9TdHJpbmcoKSAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBUaGUgY3VzdG9tIHRvU3RyaW5nKCkgdGhyZXcuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBTaW5nbGVQcmV0dHlQcmludFJ1bi5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB0aGlzLnBwTmVzdExldmVsXysrO1xuICAgIHRyeSB7XG4gICAgICB2YXIgY3VzdG9tRm9ybWF0UmVzdWx0ID0gdGhpcy5hcHBseUN1c3RvbUZvcm1hdHRlcnNfKHZhbHVlKTtcblxuICAgICAgaWYgKGN1c3RvbUZvcm1hdFJlc3VsdCkge1xuICAgICAgICB0aGlzLmVtaXRTY2FsYXIoY3VzdG9tRm9ybWF0UmVzdWx0KTtcbiAgICAgIH0gZWxzZSBpZiAoaiQudXRpbC5pc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5lbWl0U2NhbGFyKCd1bmRlZmluZWQnKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5lbWl0U2NhbGFyKCdudWxsJyk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgIHRoaXMuZW1pdFNjYWxhcignLTAnKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IGokLmdldEdsb2JhbCgpKSB7XG4gICAgICAgIHRoaXMuZW1pdFNjYWxhcignPGdsb2JhbD4nKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUuamFzbWluZVRvU3RyaW5nKSB7XG4gICAgICAgIHRoaXMuZW1pdFNjYWxhcih2YWx1ZS5qYXNtaW5lVG9TdHJpbmcodGhpcy5wcF8pKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLmVtaXRTdHJpbmcodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChqJC5pc1NweSh2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5lbWl0U2NhbGFyKCdzcHkgb24gJyArIHZhbHVlLmFuZC5pZGVudGl0eSk7XG4gICAgICB9IGVsc2UgaWYgKGokLmlzU3B5KHZhbHVlLnRvU3RyaW5nKSkge1xuICAgICAgICB0aGlzLmVtaXRTY2FsYXIoJ3NweSBvbiAnICsgdmFsdWUudG9TdHJpbmcuYW5kLmlkZW50aXR5KTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgdGhpcy5lbWl0U2NhbGFyKHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5lbWl0U2NhbGFyKCdGdW5jdGlvbicpO1xuICAgICAgfSBlbHNlIGlmIChqJC5pc0RvbU5vZGUodmFsdWUpKSB7XG4gICAgICAgIGlmICh2YWx1ZS50YWdOYW1lKSB7XG4gICAgICAgICAgdGhpcy5lbWl0RG9tRWxlbWVudCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lbWl0U2NhbGFyKCdIVE1MTm9kZScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICB0aGlzLmVtaXRTY2FsYXIoJ0RhdGUoJyArIHZhbHVlICsgJyknKTtcbiAgICAgIH0gZWxzZSBpZiAoaiQuaXNTZXQodmFsdWUpKSB7XG4gICAgICAgIHRoaXMuZW1pdFNldCh2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGokLmlzTWFwKHZhbHVlKSkge1xuICAgICAgICB0aGlzLmVtaXRNYXAodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChqJC5pc1R5cGVkQXJyYXlfKHZhbHVlKSkge1xuICAgICAgICB0aGlzLmVtaXRUeXBlZEFycmF5KHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHZhbHVlLnRvU3RyaW5nICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgIWokLmlzQXJyYXlfKHZhbHVlKSAmJlxuICAgICAgICBoYXNDdXN0b21Ub1N0cmluZyh2YWx1ZSlcbiAgICAgICkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuZW1pdFNjYWxhcih2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXMuZW1pdFNjYWxhcignaGFzLWludmFsaWQtdG9TdHJpbmctbWV0aG9kJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaiQudXRpbC5hcnJheUNvbnRhaW5zKHRoaXMuc2VlbiwgdmFsdWUpKSB7XG4gICAgICAgIHRoaXMuZW1pdFNjYWxhcihcbiAgICAgICAgICAnPGNpcmN1bGFyIHJlZmVyZW5jZTogJyArXG4gICAgICAgICAgICAoaiQuaXNBcnJheV8odmFsdWUpID8gJ0FycmF5JyA6ICdPYmplY3QnKSArXG4gICAgICAgICAgICAnPidcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoaiQuaXNBcnJheV8odmFsdWUpIHx8IGokLmlzQV8oJ09iamVjdCcsIHZhbHVlKSkge1xuICAgICAgICB0aGlzLnNlZW4ucHVzaCh2YWx1ZSk7XG4gICAgICAgIGlmIChqJC5pc0FycmF5Xyh2YWx1ZSkpIHtcbiAgICAgICAgICB0aGlzLmVtaXRBcnJheSh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lbWl0T2JqZWN0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlZW4ucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVtaXRTY2FsYXIodmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKHRoaXMucHBOZXN0TGV2ZWxfID4gMSB8fCAhKGUgaW5zdGFuY2VvZiBNYXhDaGFyc1JlYWNoZWRFcnJvcikpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5wcE5lc3RMZXZlbF8tLTtcbiAgICB9XG4gIH07XG5cbiAgU2luZ2xlUHJldHR5UHJpbnRSdW4ucHJvdG90eXBlLmFwcGx5Q3VzdG9tRm9ybWF0dGVyc18gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBjdXN0b21Gb3JtYXQodmFsdWUsIHRoaXMuY3VzdG9tT2JqZWN0Rm9ybWF0dGVyc18pO1xuICB9O1xuXG4gIFNpbmdsZVByZXR0eVByaW50UnVuLnByb3RvdHlwZS5pdGVyYXRlT2JqZWN0ID0gZnVuY3Rpb24ob2JqLCBmbikge1xuICAgIHZhciBvYmpLZXlzID0ga2V5cyhvYmosIGokLmlzQXJyYXlfKG9iaikpO1xuICAgIHZhciBpc0dldHRlciA9IGZ1bmN0aW9uIGlzR2V0dGVyKHByb3ApIHt9O1xuXG4gICAgaWYgKG9iai5fX2xvb2t1cEdldHRlcl9fKSB7XG4gICAgICBpc0dldHRlciA9IGZ1bmN0aW9uIGlzR2V0dGVyKHByb3ApIHtcbiAgICAgICAgdmFyIGdldHRlciA9IG9iai5fX2xvb2t1cEdldHRlcl9fKHByb3ApO1xuICAgICAgICByZXR1cm4gIWokLnV0aWwuaXNVbmRlZmluZWQoZ2V0dGVyKSAmJiBnZXR0ZXIgIT09IG51bGw7XG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5taW4ob2JqS2V5cy5sZW5ndGgsIGokLk1BWF9QUkVUVFlfUFJJTlRfQVJSQVlfTEVOR1RIKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcGVydHkgPSBvYmpLZXlzW2ldO1xuICAgICAgZm4ocHJvcGVydHksIGlzR2V0dGVyKHByb3BlcnR5KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iaktleXMubGVuZ3RoID4gbGVuZ3RoO1xuICB9O1xuXG4gIFNpbmdsZVByZXR0eVByaW50UnVuLnByb3RvdHlwZS5lbWl0U2NhbGFyID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB0aGlzLmFwcGVuZCh2YWx1ZSk7XG4gIH07XG5cbiAgU2luZ2xlUHJldHR5UHJpbnRSdW4ucHJvdG90eXBlLmVtaXRTdHJpbmcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuYXBwZW5kKFwiJ1wiICsgdmFsdWUgKyBcIidcIik7XG4gIH07XG5cbiAgU2luZ2xlUHJldHR5UHJpbnRSdW4ucHJvdG90eXBlLmVtaXRBcnJheSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgaWYgKHRoaXMucHBOZXN0TGV2ZWxfID4gaiQuTUFYX1BSRVRUWV9QUklOVF9ERVBUSCkge1xuICAgICAgdGhpcy5hcHBlbmQoJ0FycmF5Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBNYXRoLm1pbihhcnJheS5sZW5ndGgsIGokLk1BWF9QUkVUVFlfUFJJTlRfQVJSQVlfTEVOR1RIKTtcbiAgICB0aGlzLmFwcGVuZCgnWyAnKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgdGhpcy5hcHBlbmQoJywgJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmZvcm1hdChhcnJheVtpXSk7XG4gICAgfVxuICAgIGlmIChhcnJheS5sZW5ndGggPiBsZW5ndGgpIHtcbiAgICAgIHRoaXMuYXBwZW5kKCcsIC4uLicpO1xuICAgIH1cblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZmlyc3QgPSBhcnJheS5sZW5ndGggPT09IDA7XG4gICAgdmFyIHRydW5jYXRlZCA9IHRoaXMuaXRlcmF0ZU9iamVjdChhcnJheSwgZnVuY3Rpb24ocHJvcGVydHksIGlzR2V0dGVyKSB7XG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuYXBwZW5kKCcsICcpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLmZvcm1hdFByb3BlcnR5KGFycmF5LCBwcm9wZXJ0eSwgaXNHZXR0ZXIpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRydW5jYXRlZCkge1xuICAgICAgdGhpcy5hcHBlbmQoJywgLi4uJyk7XG4gICAgfVxuXG4gICAgdGhpcy5hcHBlbmQoJyBdJyk7XG4gIH07XG5cbiAgU2luZ2xlUHJldHR5UHJpbnRSdW4ucHJvdG90eXBlLmVtaXRTZXQgPSBmdW5jdGlvbihzZXQpIHtcbiAgICBpZiAodGhpcy5wcE5lc3RMZXZlbF8gPiBqJC5NQVhfUFJFVFRZX1BSSU5UX0RFUFRIKSB7XG4gICAgICB0aGlzLmFwcGVuZCgnU2V0Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYXBwZW5kKCdTZXQoICcpO1xuICAgIHZhciBzaXplID0gTWF0aC5taW4oc2V0LnNpemUsIGokLk1BWF9QUkVUVFlfUFJJTlRfQVJSQVlfTEVOR1RIKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgaWYgKGkgPj0gc2l6ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgdGhpcy5hcHBlbmQoJywgJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmZvcm1hdCh2YWx1ZSk7XG5cbiAgICAgIGkrKztcbiAgICB9LCB0aGlzKTtcbiAgICBpZiAoc2V0LnNpemUgPiBzaXplKSB7XG4gICAgICB0aGlzLmFwcGVuZCgnLCAuLi4nKTtcbiAgICB9XG4gICAgdGhpcy5hcHBlbmQoJyApJyk7XG4gIH07XG5cbiAgU2luZ2xlUHJldHR5UHJpbnRSdW4ucHJvdG90eXBlLmVtaXRNYXAgPSBmdW5jdGlvbihtYXApIHtcbiAgICBpZiAodGhpcy5wcE5lc3RMZXZlbF8gPiBqJC5NQVhfUFJFVFRZX1BSSU5UX0RFUFRIKSB7XG4gICAgICB0aGlzLmFwcGVuZCgnTWFwJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYXBwZW5kKCdNYXAoICcpO1xuICAgIHZhciBzaXplID0gTWF0aC5taW4obWFwLnNpemUsIGokLk1BWF9QUkVUVFlfUFJJTlRfQVJSQVlfTEVOR1RIKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgaWYgKGkgPj0gc2l6ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgdGhpcy5hcHBlbmQoJywgJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmZvcm1hdChba2V5LCB2YWx1ZV0pO1xuXG4gICAgICBpKys7XG4gICAgfSwgdGhpcyk7XG4gICAgaWYgKG1hcC5zaXplID4gc2l6ZSkge1xuICAgICAgdGhpcy5hcHBlbmQoJywgLi4uJyk7XG4gICAgfVxuICAgIHRoaXMuYXBwZW5kKCcgKScpO1xuICB9O1xuXG4gIFNpbmdsZVByZXR0eVByaW50UnVuLnByb3RvdHlwZS5lbWl0T2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGN0b3IgPSBvYmouY29uc3RydWN0b3IsXG4gICAgICBjb25zdHJ1Y3Rvck5hbWU7XG5cbiAgICBjb25zdHJ1Y3Rvck5hbWUgPVxuICAgICAgdHlwZW9mIGN0b3IgPT09ICdmdW5jdGlvbicgJiYgb2JqIGluc3RhbmNlb2YgY3RvclxuICAgICAgICA/IGokLmZuTmFtZUZvcihvYmouY29uc3RydWN0b3IpXG4gICAgICAgIDogJ251bGwnO1xuXG4gICAgdGhpcy5hcHBlbmQoY29uc3RydWN0b3JOYW1lKTtcblxuICAgIGlmICh0aGlzLnBwTmVzdExldmVsXyA+IGokLk1BWF9QUkVUVFlfUFJJTlRfREVQVEgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5hcHBlbmQoJyh7ICcpO1xuICAgIHZhciBmaXJzdCA9IHRydWU7XG5cbiAgICB2YXIgdHJ1bmNhdGVkID0gdGhpcy5pdGVyYXRlT2JqZWN0KG9iaiwgZnVuY3Rpb24ocHJvcGVydHksIGlzR2V0dGVyKSB7XG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuYXBwZW5kKCcsICcpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLmZvcm1hdFByb3BlcnR5KG9iaiwgcHJvcGVydHksIGlzR2V0dGVyKTtcbiAgICB9KTtcblxuICAgIGlmICh0cnVuY2F0ZWQpIHtcbiAgICAgIHRoaXMuYXBwZW5kKCcsIC4uLicpO1xuICAgIH1cblxuICAgIHRoaXMuYXBwZW5kKCcgfSknKTtcbiAgfTtcblxuICBTaW5nbGVQcmV0dHlQcmludFJ1bi5wcm90b3R5cGUuZW1pdFR5cGVkQXJyYXkgPSBmdW5jdGlvbihhcnIpIHtcbiAgICB2YXIgY29uc3RydWN0b3JOYW1lID0gaiQuZm5OYW1lRm9yKGFyci5jb25zdHJ1Y3RvciksXG4gICAgICBsaW1pdGVkQXJyYXkgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChcbiAgICAgICAgYXJyLFxuICAgICAgICAwLFxuICAgICAgICBqJC5NQVhfUFJFVFRZX1BSSU5UX0FSUkFZX0xFTkdUSFxuICAgICAgKSxcbiAgICAgIGl0ZW1zU3RyaW5nID0gQXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbChsaW1pdGVkQXJyYXksICcsICcpO1xuXG4gICAgaWYgKGxpbWl0ZWRBcnJheS5sZW5ndGggIT09IGFyci5sZW5ndGgpIHtcbiAgICAgIGl0ZW1zU3RyaW5nICs9ICcsIC4uLic7XG4gICAgfVxuXG4gICAgdGhpcy5hcHBlbmQoY29uc3RydWN0b3JOYW1lICsgJyBbICcgKyBpdGVtc1N0cmluZyArICcgXScpO1xuICB9O1xuXG4gIFNpbmdsZVByZXR0eVByaW50UnVuLnByb3RvdHlwZS5lbWl0RG9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgdmFyIHRhZ05hbWUgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICBhdHRycyA9IGVsLmF0dHJpYnV0ZXMsXG4gICAgICBpLFxuICAgICAgbGVuID0gYXR0cnMubGVuZ3RoLFxuICAgICAgb3V0ID0gJzwnICsgdGFnTmFtZSxcbiAgICAgIGF0dHI7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGF0dHIgPSBhdHRyc1tpXTtcbiAgICAgIG91dCArPSAnICcgKyBhdHRyLm5hbWU7XG5cbiAgICAgIGlmIChhdHRyLnZhbHVlICE9PSAnJykge1xuICAgICAgICBvdXQgKz0gJz1cIicgKyBhdHRyLnZhbHVlICsgJ1wiJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvdXQgKz0gJz4nO1xuXG4gICAgaWYgKGVsLmNoaWxkRWxlbWVudENvdW50ICE9PSAwIHx8IGVsLnRleHRDb250ZW50ICE9PSAnJykge1xuICAgICAgb3V0ICs9ICcuLi48LycgKyB0YWdOYW1lICsgJz4nO1xuICAgIH1cblxuICAgIHRoaXMuYXBwZW5kKG91dCk7XG4gIH07XG5cbiAgU2luZ2xlUHJldHR5UHJpbnRSdW4ucHJvdG90eXBlLmZvcm1hdFByb3BlcnR5ID0gZnVuY3Rpb24oXG4gICAgb2JqLFxuICAgIHByb3BlcnR5LFxuICAgIGlzR2V0dGVyXG4gICkge1xuICAgIHRoaXMuYXBwZW5kKHByb3BlcnR5KTtcbiAgICB0aGlzLmFwcGVuZCgnOiAnKTtcbiAgICBpZiAoaXNHZXR0ZXIpIHtcbiAgICAgIHRoaXMuYXBwZW5kKCc8Z2V0dGVyPicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZvcm1hdChvYmpbcHJvcGVydHldKTtcbiAgICB9XG4gIH07XG5cbiAgU2luZ2xlUHJldHR5UHJpbnRSdW4ucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgLy8gVGhpcyBjaGVjayBwcm90ZWN0cyB1cyBmcm9tIHRoZSByYXJlIGNhc2Ugd2hlcmUgYW4gb2JqZWN0IGhhcyBvdmVycmlkZW5cbiAgICAvLyBgdG9TdHJpbmcoKWAgd2l0aCBhbiBpbnZhbGlkIGltcGxlbWVudGF0aW9uIChyZXR1cm5pbmcgYSBub24tc3RyaW5nKS5cbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB0cnVuY2F0ZSh2YWx1ZSwgaiQuTUFYX1BSRVRUWV9QUklOVF9DSEFSUyAtIHRoaXMubGVuZ3RoKTtcbiAgICB0aGlzLmxlbmd0aCArPSByZXN1bHQudmFsdWUubGVuZ3RoO1xuICAgIHRoaXMuc3RyaW5nUGFydHMucHVzaChyZXN1bHQudmFsdWUpO1xuXG4gICAgaWYgKHJlc3VsdC50cnVuY2F0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBNYXhDaGFyc1JlYWNoZWRFcnJvcigpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiB0cnVuY2F0ZShzLCBtYXhsZW4pIHtcbiAgICBpZiAocy5sZW5ndGggPD0gbWF4bGVuKSB7XG4gICAgICByZXR1cm4geyB2YWx1ZTogcywgdHJ1bmNhdGVkOiBmYWxzZSB9O1xuICAgIH1cblxuICAgIHMgPSBzLnN1YnN0cmluZygwLCBtYXhsZW4gLSA0KSArICcgLi4uJztcbiAgICByZXR1cm4geyB2YWx1ZTogcywgdHJ1bmNhdGVkOiB0cnVlIH07XG4gIH1cblxuICBmdW5jdGlvbiBNYXhDaGFyc1JlYWNoZWRFcnJvcigpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPVxuICAgICAgJ0V4Y2VlZGVkICcgK1xuICAgICAgaiQuTUFYX1BSRVRUWV9QUklOVF9DSEFSUyArXG4gICAgICAnIGNoYXJhY3RlcnMgd2hpbGUgcHJldHR5LXByaW50aW5nIGEgdmFsdWUnO1xuICB9XG5cbiAgTWF4Q2hhcnNSZWFjaGVkRXJyb3IucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG5cbiAgZnVuY3Rpb24ga2V5cyhvYmosIGlzQXJyYXkpIHtcbiAgICB2YXIgYWxsS2V5cyA9IE9iamVjdC5rZXlzXG4gICAgICA/IE9iamVjdC5rZXlzKG9iailcbiAgICAgIDogKGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvKSB7XG4gICAgICAgICAgICBpZiAoaiQudXRpbC5oYXMobywga2V5KSkge1xuICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICAgIH0pKG9iaik7XG5cbiAgICBpZiAoIWlzQXJyYXkpIHtcbiAgICAgIHJldHVybiBhbGxLZXlzO1xuICAgIH1cblxuICAgIGlmIChhbGxLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGFsbEtleXM7XG4gICAgfVxuXG4gICAgdmFyIGV4dHJhS2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCEvXlswLTldKyQvLnRlc3QoYWxsS2V5c1tpXSkpIHtcbiAgICAgICAgZXh0cmFLZXlzLnB1c2goYWxsS2V5c1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4dHJhS2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIGN1c3RvbUZvcm1hdCh2YWx1ZSwgY3VzdG9tT2JqZWN0Rm9ybWF0dGVycykge1xuICAgIHZhciBpLCByZXN1bHQ7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY3VzdG9tT2JqZWN0Rm9ybWF0dGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0ID0gY3VzdG9tT2JqZWN0Rm9ybWF0dGVyc1tpXSh2YWx1ZSk7XG5cbiAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihjdXN0b21PYmplY3RGb3JtYXR0ZXJzKSB7XG4gICAgY3VzdG9tT2JqZWN0Rm9ybWF0dGVycyA9IGN1c3RvbU9iamVjdEZvcm1hdHRlcnMgfHwgW107XG5cbiAgICB2YXIgcHAgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIHByZXR0eVByaW50ZXIgPSBuZXcgU2luZ2xlUHJldHR5UHJpbnRSdW4oY3VzdG9tT2JqZWN0Rm9ybWF0dGVycywgcHApO1xuICAgICAgcHJldHR5UHJpbnRlci5mb3JtYXQodmFsdWUpO1xuICAgICAgcmV0dXJuIHByZXR0eVByaW50ZXIuc3RyaW5nUGFydHMuam9pbignJyk7XG4gICAgfTtcblxuICAgIHBwLmN1c3RvbUZvcm1hdF8gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGN1c3RvbUZvcm1hdCh2YWx1ZSwgY3VzdG9tT2JqZWN0Rm9ybWF0dGVycyk7XG4gICAgfTtcblxuICAgIHJldHVybiBwcDtcbiAgfTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuUXVldWVSdW5uZXIgPSBmdW5jdGlvbihqJCkge1xuICB2YXIgbmV4dGlkID0gMTtcblxuICBmdW5jdGlvbiBTdG9wRXhlY3V0aW9uRXJyb3IoKSB7fVxuICBTdG9wRXhlY3V0aW9uRXJyb3IucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gIGokLlN0b3BFeGVjdXRpb25FcnJvciA9IFN0b3BFeGVjdXRpb25FcnJvcjtcblxuICBmdW5jdGlvbiBvbmNlKGZuLCBvblR3aWNlKSB7XG4gICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIGlmIChjYWxsZWQpIHtcbiAgICAgICAgaWYgKG9uVHdpY2UpIHtcbiAgICAgICAgICBvblR3aWNlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIC8vIERpcmVjdCBjYWxsIHVzaW5nIHNpbmdsZSBwYXJhbWV0ZXIsIGJlY2F1c2UgY2xlYW51cC9uZXh0IGRvZXMgbm90IG5lZWQgbW9yZVxuICAgICAgICBmbihhcmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZhbGxiYWNrT25NdWx0aXBsZURvbmUoKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgXCJBbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gY2FsbGVkIGl0cyAnZG9uZScgXCIgK1xuICAgICAgICAgICdjYWxsYmFjayBtb3JlIHRoYW4gb25jZSwgaW4gYSBRdWV1ZVJ1bm5lciB3aXRob3V0IGEgb25NdWx0aXBsZURvbmUgJyArXG4gICAgICAgICAgJ2hhbmRsZXIuJ1xuICAgICAgKVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBlbXB0eUZuKCkge31cblxuICBmdW5jdGlvbiBRdWV1ZVJ1bm5lcihhdHRycykge1xuICAgIHRoaXMuaWRfID0gbmV4dGlkKys7XG4gICAgdGhpcy5xdWV1ZWFibGVGbnMgPSBhdHRycy5xdWV1ZWFibGVGbnMgfHwgW107XG4gICAgdGhpcy5vbkNvbXBsZXRlID0gYXR0cnMub25Db21wbGV0ZSB8fCBlbXB0eUZuO1xuICAgIHRoaXMuY2xlYXJTdGFjayA9XG4gICAgICBhdHRycy5jbGVhclN0YWNrIHx8XG4gICAgICBmdW5jdGlvbihmbikge1xuICAgICAgICBmbigpO1xuICAgICAgfTtcbiAgICB0aGlzLm9uRXhjZXB0aW9uID0gYXR0cnMub25FeGNlcHRpb24gfHwgZW1wdHlGbjtcbiAgICB0aGlzLm9uTXVsdGlwbGVEb25lID0gYXR0cnMub25NdWx0aXBsZURvbmUgfHwgZmFsbGJhY2tPbk11bHRpcGxlRG9uZTtcbiAgICB0aGlzLnVzZXJDb250ZXh0ID0gYXR0cnMudXNlckNvbnRleHQgfHwgbmV3IGokLlVzZXJDb250ZXh0KCk7XG4gICAgdGhpcy50aW1lb3V0ID0gYXR0cnMudGltZW91dCB8fCB7XG4gICAgICBzZXRUaW1lb3V0OiBzZXRUaW1lb3V0LFxuICAgICAgY2xlYXJUaW1lb3V0OiBjbGVhclRpbWVvdXRcbiAgICB9O1xuICAgIHRoaXMuZmFpbCA9IGF0dHJzLmZhaWwgfHwgZW1wdHlGbjtcbiAgICB0aGlzLmdsb2JhbEVycm9ycyA9IGF0dHJzLmdsb2JhbEVycm9ycyB8fCB7XG4gICAgICBwdXNoTGlzdGVuZXI6IGVtcHR5Rm4sXG4gICAgICBwb3BMaXN0ZW5lcjogZW1wdHlGblxuICAgIH07XG5cbiAgICBjb25zdCBTa2lwUG9saWN5ID0gYXR0cnMuU2tpcFBvbGljeSB8fCBqJC5OZXZlclNraXBQb2xpY3k7XG4gICAgdGhpcy5za2lwUG9saWN5XyA9IG5ldyBTa2lwUG9saWN5KHRoaXMucXVldWVhYmxlRm5zKTtcbiAgICB0aGlzLmVycm9yZWRfID0gZmFsc2U7XG5cbiAgICBpZiAodHlwZW9mIHRoaXMub25Db21wbGV0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG9uQ29tcGxldGUgJyArIEpTT04uc3RyaW5naWZ5KHRoaXMub25Db21wbGV0ZSkpO1xuICAgIH1cbiAgICB0aGlzLmRlcHJlY2F0ZWQgPSBhdHRycy5kZXByZWNhdGVkO1xuICB9XG5cbiAgUXVldWVSdW5uZXIucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5oYW5kbGVGaW5hbEVycm9yID0gZnVuY3Rpb24obWVzc2FnZSwgc291cmNlLCBsaW5lbm8sIGNvbG5vLCBlcnJvcikge1xuICAgICAgLy8gT2xkZXIgYnJvd3NlcnMgd291bGQgc2VuZCB0aGUgZXJyb3IgYXMgdGhlIGZpcnN0IHBhcmFtZXRlci4gSFRNTDVcbiAgICAgIC8vIHNwZWNpZmllcyB0aGUgdGhlIGZpdmUgcGFyYW1ldGVycyBhYm92ZS4gVGhlIGVycm9yIGluc3RhbmNlIHNob3VsZFxuICAgICAgLy8gYmUgcHJlZmZlcmVkLCBvdGhlcndpc2UgdGhlIGNhbGwgc3RhY2sgd291bGQgZ2V0IGxvc3QuXG4gICAgICBzZWxmLm9uRXhjZXB0aW9uKGVycm9yIHx8IG1lc3NhZ2UpO1xuICAgIH07XG4gICAgdGhpcy5nbG9iYWxFcnJvcnMucHVzaExpc3RlbmVyKHRoaXMuaGFuZGxlRmluYWxFcnJvcik7XG4gICAgdGhpcy5ydW4oMCk7XG4gIH07XG5cbiAgUXVldWVSdW5uZXIucHJvdG90eXBlLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uKHRpbWVvdXRJZCkge1xuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseSh0aGlzLnRpbWVvdXQuY2xlYXJUaW1lb3V0LCBbXG4gICAgICBqJC5nZXRHbG9iYWwoKSxcbiAgICAgIFt0aW1lb3V0SWRdXG4gICAgXSk7XG4gIH07XG5cbiAgUXVldWVSdW5uZXIucHJvdG90eXBlLnNldFRpbWVvdXQgPSBmdW5jdGlvbihmbiwgdGltZW91dCkge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkodGhpcy50aW1lb3V0LnNldFRpbWVvdXQsIFtcbiAgICAgIGokLmdldEdsb2JhbCgpLFxuICAgICAgW2ZuLCB0aW1lb3V0XVxuICAgIF0pO1xuICB9O1xuXG4gIFF1ZXVlUnVubmVyLnByb3RvdHlwZS5hdHRlbXB0ID0gZnVuY3Rpb24gYXR0ZW1wdChpdGVyYXRpdmVJbmRleCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIGNvbXBsZXRlZFN5bmNocm9ub3VzbHkgPSB0cnVlLFxuICAgICAgaGFuZGxlRXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnJvcikge1xuICAgICAgICAvLyBUT0RPIHByb2JhYmx5IHNob3VsZG4ndCBuZXh0KCkgcmlnaHQgYXdheSBoZXJlLlxuICAgICAgICAvLyBUaGF0IG1ha2VzIGRlYnVnZ2luZyBhc3luYyBmYWlsdXJlcyBtdWNoIG1vcmUgY29uZnVzaW5nLlxuICAgICAgICBvbkV4Y2VwdGlvbihlcnJvcik7XG4gICAgICB9LFxuICAgICAgY2xlYW51cCA9IG9uY2UoZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgICAgaWYgKHRpbWVvdXRJZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmdsb2JhbEVycm9ycy5wb3BMaXN0ZW5lcihoYW5kbGVFcnJvcik7XG4gICAgICB9KSxcbiAgICAgIG5leHQgPSBvbmNlKFxuICAgICAgICBmdW5jdGlvbiBuZXh0KGVycikge1xuICAgICAgICAgIGNsZWFudXAoKTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZXJyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgU3RvcEV4ZWN1dGlvbkVycm9yKSAmJiAhZXJyLmphc21pbmVNZXNzYWdlKSB7XG4gICAgICAgICAgICAgIHNlbGYuZmFpbChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5yZWNvcmRFcnJvcl8oaXRlcmF0aXZlSW5kZXgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHJ1bk5leHQoKSB7XG4gICAgICAgICAgICBzZWxmLnJ1bihzZWxmLm5leHRGbkl4XyhpdGVyYXRpdmVJbmRleCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb21wbGV0ZWRTeW5jaHJvbm91c2x5KSB7XG4gICAgICAgICAgICBzZWxmLnNldFRpbWVvdXQocnVuTmV4dCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJ1bk5leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXRpbWVkT3V0KSB7XG4gICAgICAgICAgICAgIHNlbGYub25NdWx0aXBsZURvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gQW55IGVycm9yIHdlIGNhdGNoIGhlcmUgaXMgcHJvYmFibHkgZHVlIHRvIGEgYnVnIGluIEphc21pbmUsXG4gICAgICAgICAgICAvLyBhbmQgaXQncyBub3QgbGlrZWx5IHRvIGVuZCB1cCBhbnl3aGVyZSB1c2VmdWwgaWYgd2UgbGV0IGl0XG4gICAgICAgICAgICAvLyBwcm9wYWdhdGUuIExvZyBpdCBzbyBpdCBjYW4gYXQgbGVhc3Qgc2hvdyB1cCB3aGVuIGRlYnVnZ2luZy5cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHRpbWVkT3V0ID0gZmFsc2UsXG4gICAgICBxdWV1ZWFibGVGbiA9IHNlbGYucXVldWVhYmxlRm5zW2l0ZXJhdGl2ZUluZGV4XSxcbiAgICAgIHRpbWVvdXRJZCxcbiAgICAgIG1heWJlVGhlbmFibGU7XG5cbiAgICBuZXh0LmZhaWwgPSBmdW5jdGlvbiBuZXh0RmFpbCgpIHtcbiAgICAgIHNlbGYuZmFpbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgc2VsZi5yZWNvcmRFcnJvcl8oaXRlcmF0aXZlSW5kZXgpO1xuICAgICAgbmV4dCgpO1xuICAgIH07XG5cbiAgICBzZWxmLmdsb2JhbEVycm9ycy5wdXNoTGlzdGVuZXIoaGFuZGxlRXJyb3IpO1xuXG4gICAgaWYgKHF1ZXVlYWJsZUZuLnRpbWVvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHRpbWVvdXRJbnRlcnZhbCA9IHF1ZXVlYWJsZUZuLnRpbWVvdXQgfHwgaiQuREVGQVVMVF9USU1FT1VUX0lOVEVSVkFMO1xuICAgICAgdGltZW91dElkID0gc2VsZi5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB0aW1lZE91dCA9IHRydWU7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAnVGltZW91dCAtIEFzeW5jIGZ1bmN0aW9uIGRpZCBub3QgY29tcGxldGUgd2l0aGluICcgK1xuICAgICAgICAgICAgdGltZW91dEludGVydmFsICtcbiAgICAgICAgICAgICdtcyAnICtcbiAgICAgICAgICAgIChxdWV1ZWFibGVGbi50aW1lb3V0XG4gICAgICAgICAgICAgID8gJyhjdXN0b20gdGltZW91dCknXG4gICAgICAgICAgICAgIDogJyhzZXQgYnkgamFzbWluZS5ERUZBVUxUX1RJTUVPVVRfSU5URVJWQUwpJylcbiAgICAgICAgKTtcbiAgICAgICAgLy8gVE9ETyBOZWVkIHRvIGRlY2lkZSB3aGF0IHRvIGRvIGFib3V0IGEgc3VjY2Vzc2Z1bCBjb21wbGV0aW9uIGFmdGVyIGFcbiAgICAgICAgLy8gICB0aW1lb3V0LiBUaGF0IHNob3VsZCBwcm9iYWJseSBub3QgYmUgYSBkZXByZWNhdGlvbiwgYW5kIG1heWJlIG5vdFxuICAgICAgICAvLyAgIGFuIGVycm9yIGluIDQuMC4gKEJ1dCBhIGRpYWdub3N0aWMgb2Ygc29tZSBzb3J0IG1pZ2h0IGJlIGhlbHBmdWwuKVxuICAgICAgICBvbkV4Y2VwdGlvbihlcnJvcik7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH0sIHRpbWVvdXRJbnRlcnZhbCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChxdWV1ZWFibGVGbi5mbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbWF5YmVUaGVuYWJsZSA9IHF1ZXVlYWJsZUZuLmZuLmNhbGwoc2VsZi51c2VyQ29udGV4dCk7XG5cbiAgICAgICAgaWYgKG1heWJlVGhlbmFibGUgJiYgaiQuaXNGdW5jdGlvbl8obWF5YmVUaGVuYWJsZS50aGVuKSkge1xuICAgICAgICAgIG1heWJlVGhlbmFibGUudGhlbihcbiAgICAgICAgICAgIHdyYXBJblByb21pc2VSZXNvbHV0aW9uSGFuZGxlcihuZXh0KSxcbiAgICAgICAgICAgIG9uUHJvbWlzZVJlamVjdGlvblxuICAgICAgICAgICk7XG4gICAgICAgICAgY29tcGxldGVkU3luY2hyb25vdXNseSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiB7IGNvbXBsZXRlZFN5bmNocm9ub3VzbHk6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heWJlVGhlbmFibGUgPSBxdWV1ZWFibGVGbi5mbi5jYWxsKHNlbGYudXNlckNvbnRleHQsIG5leHQpO1xuICAgICAgICB0aGlzLmRpYWdub3NlQ29uZmxpY3RpbmdBc3luY18ocXVldWVhYmxlRm4uZm4sIG1heWJlVGhlbmFibGUpO1xuICAgICAgICBjb21wbGV0ZWRTeW5jaHJvbm91c2x5ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB7IGNvbXBsZXRlZFN5bmNocm9ub3VzbHk6IGZhbHNlIH07XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgb25FeGNlcHRpb24oZSk7XG4gICAgICBzZWxmLnJlY29yZEVycm9yXyhpdGVyYXRpdmVJbmRleCk7XG4gICAgfVxuXG4gICAgY2xlYW51cCgpO1xuICAgIHJldHVybiB7IGNvbXBsZXRlZFN5bmNocm9ub3VzbHk6IHRydWUgfTtcblxuICAgIGZ1bmN0aW9uIG9uRXhjZXB0aW9uKGUpIHtcbiAgICAgIHNlbGYub25FeGNlcHRpb24oZSk7XG4gICAgICBzZWxmLnJlY29yZEVycm9yXyhpdGVyYXRpdmVJbmRleCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Qcm9taXNlUmVqZWN0aW9uKGUpIHtcbiAgICAgIG9uRXhjZXB0aW9uKGUpO1xuICAgICAgbmV4dCgpO1xuICAgIH1cbiAgfTtcblxuICBRdWV1ZVJ1bm5lci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24ocmVjdXJzaXZlSW5kZXgpIHtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5xdWV1ZWFibGVGbnMubGVuZ3RoLFxuICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICBpdGVyYXRpdmVJbmRleDtcblxuICAgIGZvciAoXG4gICAgICBpdGVyYXRpdmVJbmRleCA9IHJlY3Vyc2l2ZUluZGV4O1xuICAgICAgaXRlcmF0aXZlSW5kZXggPCBsZW5ndGg7XG4gICAgICBpdGVyYXRpdmVJbmRleCA9IHRoaXMubmV4dEZuSXhfKGl0ZXJhdGl2ZUluZGV4KVxuICAgICkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuYXR0ZW1wdChpdGVyYXRpdmVJbmRleCk7XG5cbiAgICAgIGlmICghcmVzdWx0LmNvbXBsZXRlZFN5bmNocm9ub3VzbHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY2xlYXJTdGFjayhmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuZ2xvYmFsRXJyb3JzLnBvcExpc3RlbmVyKHNlbGYuaGFuZGxlRmluYWxFcnJvcik7XG5cbiAgICAgIGlmIChzZWxmLmVycm9yZWRfKSB7XG4gICAgICAgIHNlbGYub25Db21wbGV0ZShuZXcgU3RvcEV4ZWN1dGlvbkVycm9yKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5vbkNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgUXVldWVSdW5uZXIucHJvdG90eXBlLm5leHRGbkl4XyA9IGZ1bmN0aW9uKGN1cnJlbnRGbkl4KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5za2lwUG9saWN5Xy5za2lwVG8oY3VycmVudEZuSXgpO1xuXG4gICAgaWYgKHJlc3VsdCA9PT0gY3VycmVudEZuSXgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHNraXAgdG8gdGhlIHNhbWUgcXVldWVhYmxlIGZuIHRoYXQganVzdCBmaW5pc2hlZFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIFF1ZXVlUnVubmVyLnByb3RvdHlwZS5yZWNvcmRFcnJvcl8gPSBmdW5jdGlvbihjdXJyZW50Rm5JeCkge1xuICAgIHRoaXMuZXJyb3JlZF8gPSB0cnVlO1xuICAgIHRoaXMuc2tpcFBvbGljeV8uZm5FcnJvcmVkKGN1cnJlbnRGbkl4KTtcbiAgfTtcblxuICBRdWV1ZVJ1bm5lci5wcm90b3R5cGUuZGlhZ25vc2VDb25mbGljdGluZ0FzeW5jXyA9IGZ1bmN0aW9uKGZuLCByZXR2YWwpIHtcbiAgICB2YXIgbXNnO1xuXG4gICAgaWYgKHJldHZhbCAmJiBqJC5pc0Z1bmN0aW9uXyhyZXR2YWwudGhlbikpIHtcbiAgICAgIC8vIElzc3VlIGEgd2FybmluZyB0aGF0IG1hdGNoZXMgdGhlIHVzZXIncyBjb2RlLlxuICAgICAgLy8gT21pdCB0aGUgc3RhY2sgdHJhY2UgYmVjYXVzZSB0aGVyZSdzIGFsbW9zdCBjZXJ0YWlubHkgbm8gdXNlciBjb2RlXG4gICAgICAvLyBvbiB0aGUgc3RhY2sgYXQgdGhpcyBwb2ludC5cbiAgICAgIGlmIChqJC5pc0FzeW5jRnVuY3Rpb25fKGZuKSkge1xuICAgICAgICB0aGlzLm9uRXhjZXB0aW9uKFxuICAgICAgICAgICdBbiBhc3luY2hyb25vdXMgYmVmb3JlL2l0L2FmdGVyICcgK1xuICAgICAgICAgICAgJ2Z1bmN0aW9uIHdhcyBkZWZpbmVkIHdpdGggdGhlIGFzeW5jIGtleXdvcmQgYnV0IGFsc28gdG9vayBhICcgK1xuICAgICAgICAgICAgJ2RvbmUgY2FsbGJhY2suIEVpdGhlciByZW1vdmUgdGhlIGRvbmUgY2FsbGJhY2sgKHJlY29tbWVuZGVkKSBvciAnICtcbiAgICAgICAgICAgICdyZW1vdmUgdGhlIGFzeW5jIGtleXdvcmQuJ1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbkV4Y2VwdGlvbihcbiAgICAgICAgICAnQW4gYXN5bmNocm9ub3VzIGJlZm9yZS9pdC9hZnRlciAnICtcbiAgICAgICAgICAgICdmdW5jdGlvbiB0b29rIGEgZG9uZSBjYWxsYmFjayBidXQgYWxzbyByZXR1cm5lZCBhIHByb21pc2UuICcgK1xuICAgICAgICAgICAgJ0VpdGhlciByZW1vdmUgdGhlIGRvbmUgY2FsbGJhY2sgKHJlY29tbWVuZGVkKSBvciBjaGFuZ2UgdGhlICcgK1xuICAgICAgICAgICAgJ2Z1bmN0aW9uIHRvIG5vdCByZXR1cm4gYSBwcm9taXNlLidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kZXByZWNhdGVkKG1zZywgeyBvbWl0U3RhY2tUcmFjZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gd3JhcEluUHJvbWlzZVJlc29sdXRpb25IYW5kbGVyKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG1heWJlQXJnKSB7XG4gICAgICBpZiAoaiQuaXNFcnJvcl8obWF5YmVBcmcpKSB7XG4gICAgICAgIGZuKG1heWJlQXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBRdWV1ZVJ1bm5lcjtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuUmVwb3J0RGlzcGF0Y2hlciA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIFJlcG9ydERpc3BhdGNoZXIobWV0aG9kcywgcXVldWVSdW5uZXJGYWN0b3J5LCBvbkxhdGVFcnJvcikge1xuICAgIHZhciBkaXNwYXRjaGVkTWV0aG9kcyA9IG1ldGhvZHMgfHwgW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoZWRNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbWV0aG9kID0gZGlzcGF0Y2hlZE1ldGhvZHNbaV07XG4gICAgICB0aGlzW21ldGhvZF0gPSAoZnVuY3Rpb24obSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZGlzcGF0Y2gobSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKG1ldGhvZCk7XG4gICAgfVxuXG4gICAgdmFyIHJlcG9ydGVycyA9IFtdO1xuICAgIHZhciBmYWxsYmFja1JlcG9ydGVyID0gbnVsbDtcblxuICAgIHRoaXMuYWRkUmVwb3J0ZXIgPSBmdW5jdGlvbihyZXBvcnRlcikge1xuICAgICAgcmVwb3J0ZXJzLnB1c2gocmVwb3J0ZXIpO1xuICAgIH07XG5cbiAgICB0aGlzLnByb3ZpZGVGYWxsYmFja1JlcG9ydGVyID0gZnVuY3Rpb24ocmVwb3J0ZXIpIHtcbiAgICAgIGZhbGxiYWNrUmVwb3J0ZXIgPSByZXBvcnRlcjtcbiAgICB9O1xuXG4gICAgdGhpcy5jbGVhclJlcG9ydGVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVwb3J0ZXJzID0gW107XG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gICAgZnVuY3Rpb24gZGlzcGF0Y2gobWV0aG9kLCBhcmdzKSB7XG4gICAgICBpZiAocmVwb3J0ZXJzLmxlbmd0aCA9PT0gMCAmJiBmYWxsYmFja1JlcG9ydGVyICE9PSBudWxsKSB7XG4gICAgICAgIHJlcG9ydGVycy5wdXNoKGZhbGxiYWNrUmVwb3J0ZXIpO1xuICAgICAgfVxuICAgICAgdmFyIG9uQ29tcGxldGUgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICBhcmdzID0gaiQudXRpbC5hcmdzVG9BcnJheShhcmdzKS5zcGxpY2UoMCwgYXJncy5sZW5ndGggLSAxKTtcbiAgICAgIHZhciBmbnMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVwb3J0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByZXBvcnRlciA9IHJlcG9ydGVyc1tpXTtcbiAgICAgICAgYWRkRm4oZm5zLCByZXBvcnRlciwgbWV0aG9kLCBhcmdzKTtcbiAgICAgIH1cblxuICAgICAgcXVldWVSdW5uZXJGYWN0b3J5KHtcbiAgICAgICAgcXVldWVhYmxlRm5zOiBmbnMsXG4gICAgICAgIG9uQ29tcGxldGU6IG9uQ29tcGxldGUsXG4gICAgICAgIGlzUmVwb3J0ZXI6IHRydWUsXG4gICAgICAgIG9uTXVsdGlwbGVEb25lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBvbkxhdGVFcnJvcihcbiAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgXCJBbiBhc3luY2hyb25vdXMgcmVwb3J0ZXIgY2FsbGJhY2sgY2FsbGVkIGl0cyAnZG9uZScgY2FsbGJhY2sgXCIgK1xuICAgICAgICAgICAgICAgICdtb3JlIHRoYW4gb25jZS4nXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkRm4oZm5zLCByZXBvcnRlciwgbWV0aG9kLCBhcmdzKSB7XG4gICAgICB2YXIgZm4gPSByZXBvcnRlclttZXRob2RdO1xuICAgICAgaWYgKCFmbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0aGlzQXJncyA9IGokLnV0aWwuY2xvbmVBcmdzKGFyZ3MpO1xuICAgICAgaWYgKGZuLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIGZucy5wdXNoKHtcbiAgICAgICAgICBmbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkocmVwb3J0ZXIsIHRoaXNBcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm5zLnB1c2goe1xuICAgICAgICAgIGZuOiBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkocmVwb3J0ZXIsIHRoaXNBcmdzLmNvbmNhdChbZG9uZV0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBSZXBvcnREaXNwYXRjaGVyO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5pbnRlcmZhY2UgPSBmdW5jdGlvbihqYXNtaW5lLCBlbnYpIHtcbiAgdmFyIGphc21pbmVJbnRlcmZhY2UgPSB7XG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgcGFzc2VkIHRvIHBhcnRzIG9mIHRoZSBKYXNtaW5lIGJhc2UgaW50ZXJmYWNlLlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCBKYXNtaW5lIGFzc3VtZXMgdGhpcyBmdW5jdGlvbiBjb21wbGV0ZXMgc3luY2hyb25vdXNseS5cbiAgICAgKiBJZiB5b3UgaGF2ZSBjb2RlIHRoYXQgeW91IG5lZWQgdG8gdGVzdCBhc3luY2hyb25vdXNseSwgeW91IGNhbiBkZWNsYXJlIHRoYXQgeW91IHJlY2VpdmUgYSBgZG9uZWAgY2FsbGJhY2ssIHJldHVybiBhIFByb21pc2UsIG9yIHVzZSB0aGUgYGFzeW5jYCBrZXl3b3JkIGlmIGl0IGlzIHN1cHBvcnRlZCBpbiB5b3VyIGVudmlyb25tZW50LlxuICAgICAqIEBjYWxsYmFjayBpbXBsZW1lbnRhdGlvbkNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2RvbmVdIFVzZWQgdG8gc3BlY2lmeSB0byBKYXNtaW5lIHRoYXQgdGhpcyBjYWxsYmFjayBpcyBhc3luY2hyb25vdXMgYW5kIEphc21pbmUgc2hvdWxkIHdhaXQgdW50aWwgaXQgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSBtb3Zpbmcgb24uXG4gICAgICogQHJldHVybnMge30gT3B0aW9uYWxseSByZXR1cm4gYSBQcm9taXNlIGluc3RlYWQgb2YgdXNpbmcgYGRvbmVgIHRvIGNhdXNlIEphc21pbmUgdG8gd2FpdCBmb3IgY29tcGxldGlvbi5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGdyb3VwIG9mIHNwZWNzIChvZnRlbiBjYWxsZWQgYSBzdWl0ZSkuXG4gICAgICpcbiAgICAgKiBDYWxscyB0byBgZGVzY3JpYmVgIGNhbiBiZSBuZXN0ZWQgd2l0aGluIG90aGVyIGNhbGxzIHRvIGNvbXBvc2UgeW91ciBzdWl0ZSBhcyBhIHRyZWUuXG4gICAgICogQG5hbWUgZGVzY3JpYmVcbiAgICAgKiBAc2luY2UgMS4zLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZ2xvYmFsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlc2NyaXB0aW9uIFRleHR1YWwgZGVzY3JpcHRpb24gb2YgdGhlIGdyb3VwXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3BlY0RlZmluaXRpb25zIEZ1bmN0aW9uIGZvciBKYXNtaW5lIHRvIGludm9rZSB0aGF0IHdpbGwgZGVmaW5lIGlubmVyIHN1aXRlcyBhbmQgc3BlY3NcbiAgICAgKi9cbiAgICBkZXNjcmliZTogZnVuY3Rpb24oZGVzY3JpcHRpb24sIHNwZWNEZWZpbml0aW9ucykge1xuICAgICAgcmV0dXJuIGVudi5kZXNjcmliZShkZXNjcmlwdGlvbiwgc3BlY0RlZmluaXRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0ZW1wb3JhcmlseSBkaXNhYmxlZCBbYGRlc2NyaWJlYF17QGxpbmsgZGVzY3JpYmV9XG4gICAgICpcbiAgICAgKiBTcGVjcyB3aXRoaW4gYW4gYHhkZXNjcmliZWAgd2lsbCBiZSBtYXJrZWQgcGVuZGluZyBhbmQgbm90IGV4ZWN1dGVkXG4gICAgICogQG5hbWUgeGRlc2NyaWJlXG4gICAgICogQHNpbmNlIDEuMy4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGdsb2JhbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkZXNjcmlwdGlvbiBUZXh0dWFsIGRlc2NyaXB0aW9uIG9mIHRoZSBncm91cFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNwZWNEZWZpbml0aW9ucyBGdW5jdGlvbiBmb3IgSmFzbWluZSB0byBpbnZva2UgdGhhdCB3aWxsIGRlZmluZSBpbm5lciBzdWl0ZXMgYW5kIHNwZWNzXG4gICAgICovXG4gICAgeGRlc2NyaWJlOiBmdW5jdGlvbihkZXNjcmlwdGlvbiwgc3BlY0RlZmluaXRpb25zKSB7XG4gICAgICByZXR1cm4gZW52LnhkZXNjcmliZShkZXNjcmlwdGlvbiwgc3BlY0RlZmluaXRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSBmb2N1c2VkIFtgZGVzY3JpYmVgXXtAbGluayBkZXNjcmliZX1cbiAgICAgKlxuICAgICAqIElmIHN1aXRlcyBvciBzcGVjcyBhcmUgZm9jdXNlZCwgb25seSB0aG9zZSB0aGF0IGFyZSBmb2N1c2VkIHdpbGwgYmUgZXhlY3V0ZWRcbiAgICAgKiBAc2VlIGZpdFxuICAgICAqIEBuYW1lIGZkZXNjcmliZVxuICAgICAqIEBzaW5jZSAyLjEuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBnbG9iYWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVzY3JpcHRpb24gVGV4dHVhbCBkZXNjcmlwdGlvbiBvZiB0aGUgZ3JvdXBcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzcGVjRGVmaW5pdGlvbnMgRnVuY3Rpb24gZm9yIEphc21pbmUgdG8gaW52b2tlIHRoYXQgd2lsbCBkZWZpbmUgaW5uZXIgc3VpdGVzIGFuZCBzcGVjc1xuICAgICAqL1xuICAgIGZkZXNjcmliZTogZnVuY3Rpb24oZGVzY3JpcHRpb24sIHNwZWNEZWZpbml0aW9ucykge1xuICAgICAgcmV0dXJuIGVudi5mZGVzY3JpYmUoZGVzY3JpcHRpb24sIHNwZWNEZWZpbml0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlZmluZSBhIHNpbmdsZSBzcGVjLiBBIHNwZWMgc2hvdWxkIGNvbnRhaW4gb25lIG9yIG1vcmUge0BsaW5rIGV4cGVjdHxleHBlY3RhdGlvbnN9IHRoYXQgdGVzdCB0aGUgc3RhdGUgb2YgdGhlIGNvZGUuXG4gICAgICpcbiAgICAgKiBBIHNwZWMgd2hvc2UgZXhwZWN0YXRpb25zIGFsbCBzdWNjZWVkIHdpbGwgYmUgcGFzc2luZyBhbmQgYSBzcGVjIHdpdGggYW55IGZhaWx1cmVzIHdpbGwgZmFpbC5cbiAgICAgKiBUaGUgbmFtZSBgaXRgIGlzIGEgcHJvbm91biBmb3IgdGhlIHRlc3QgdGFyZ2V0LCBub3QgYW4gYWJicmV2aWF0aW9uIG9mIGFueXRoaW5nLiBJdCBtYWtlcyB0aGVcbiAgICAgKiBzcGVjIG1vcmUgcmVhZGFibGUgYnkgY29ubmVjdGluZyB0aGUgZnVuY3Rpb24gbmFtZSBgaXRgIGFuZCB0aGUgYXJndW1lbnQgYGRlc2NyaXB0aW9uYCBhcyBhXG4gICAgICogY29tcGxldGUgc2VudGVuY2UuXG4gICAgICogQG5hbWUgaXRcbiAgICAgKiBAc2luY2UgMS4zLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZ2xvYmFsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlc2NyaXB0aW9uIFRleHR1YWwgZGVzY3JpcHRpb24gb2Ygd2hhdCB0aGlzIHNwZWMgaXMgY2hlY2tpbmdcbiAgICAgKiBAcGFyYW0ge2ltcGxlbWVudGF0aW9uQ2FsbGJhY2t9IFt0ZXN0RnVuY3Rpb25dIEZ1bmN0aW9uIHRoYXQgY29udGFpbnMgdGhlIGNvZGUgb2YgeW91ciB0ZXN0LiBJZiBub3QgcHJvdmlkZWQgdGhlIHRlc3Qgd2lsbCBiZSBgcGVuZGluZ2AuXG4gICAgICogQHBhcmFtIHtJbnR9IFt0aW1lb3V0PXtAbGluayBqYXNtaW5lLkRFRkFVTFRfVElNRU9VVF9JTlRFUlZBTH1dIEN1c3RvbSB0aW1lb3V0IGZvciBhbiBhc3luYyBzcGVjLlxuICAgICAqIEBzZWUgYXN5bmNcbiAgICAgKi9cbiAgICBpdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZW52Lml0LmFwcGx5KGVudiwgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0ZW1wb3JhcmlseSBkaXNhYmxlZCBbYGl0YF17QGxpbmsgaXR9XG4gICAgICpcbiAgICAgKiBUaGUgc3BlYyB3aWxsIHJlcG9ydCBhcyBgcGVuZGluZ2AgYW5kIHdpbGwgbm90IGJlIGV4ZWN1dGVkLlxuICAgICAqIEBuYW1lIHhpdFxuICAgICAqIEBzaW5jZSAxLjMuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBnbG9iYWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVzY3JpcHRpb24gVGV4dHVhbCBkZXNjcmlwdGlvbiBvZiB3aGF0IHRoaXMgc3BlYyBpcyBjaGVja2luZy5cbiAgICAgKiBAcGFyYW0ge2ltcGxlbWVudGF0aW9uQ2FsbGJhY2t9IFt0ZXN0RnVuY3Rpb25dIEZ1bmN0aW9uIHRoYXQgY29udGFpbnMgdGhlIGNvZGUgb2YgeW91ciB0ZXN0LiBXaWxsIG5vdCBiZSBleGVjdXRlZC5cbiAgICAgKi9cbiAgICB4aXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGVudi54aXQuYXBwbHkoZW52LCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIGZvY3VzZWQgW2BpdGBde0BsaW5rIGl0fVxuICAgICAqXG4gICAgICogSWYgc3VpdGVzIG9yIHNwZWNzIGFyZSBmb2N1c2VkLCBvbmx5IHRob3NlIHRoYXQgYXJlIGZvY3VzZWQgd2lsbCBiZSBleGVjdXRlZC5cbiAgICAgKiBAbmFtZSBmaXRcbiAgICAgKiBAc2luY2UgMi4xLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZ2xvYmFsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlc2NyaXB0aW9uIFRleHR1YWwgZGVzY3JpcHRpb24gb2Ygd2hhdCB0aGlzIHNwZWMgaXMgY2hlY2tpbmcuXG4gICAgICogQHBhcmFtIHtpbXBsZW1lbnRhdGlvbkNhbGxiYWNrfSB0ZXN0RnVuY3Rpb24gRnVuY3Rpb24gdGhhdCBjb250YWlucyB0aGUgY29kZSBvZiB5b3VyIHRlc3QuXG4gICAgICogQHBhcmFtIHtJbnR9IFt0aW1lb3V0PXtAbGluayBqYXNtaW5lLkRFRkFVTFRfVElNRU9VVF9JTlRFUlZBTH1dIEN1c3RvbSB0aW1lb3V0IGZvciBhbiBhc3luYyBzcGVjLlxuICAgICAqIEBzZWUgYXN5bmNcbiAgICAgKi9cbiAgICBmaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGVudi5maXQuYXBwbHkoZW52LCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSdW4gc29tZSBzaGFyZWQgc2V0dXAgYmVmb3JlIGVhY2ggb2YgdGhlIHNwZWNzIGluIHRoZSB7QGxpbmsgZGVzY3JpYmV9IGluIHdoaWNoIGl0IGlzIGNhbGxlZC5cbiAgICAgKiBAbmFtZSBiZWZvcmVFYWNoXG4gICAgICogQHNpbmNlIDEuMy4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGdsb2JhbFxuICAgICAqIEBwYXJhbSB7aW1wbGVtZW50YXRpb25DYWxsYmFja30gW2Z1bmN0aW9uXSBGdW5jdGlvbiB0aGF0IGNvbnRhaW5zIHRoZSBjb2RlIHRvIHNldHVwIHlvdXIgc3BlY3MuXG4gICAgICogQHBhcmFtIHtJbnR9IFt0aW1lb3V0PXtAbGluayBqYXNtaW5lLkRFRkFVTFRfVElNRU9VVF9JTlRFUlZBTH1dIEN1c3RvbSB0aW1lb3V0IGZvciBhbiBhc3luYyBiZWZvcmVFYWNoLlxuICAgICAqIEBzZWUgYXN5bmNcbiAgICAgKi9cbiAgICBiZWZvcmVFYWNoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBlbnYuYmVmb3JlRWFjaC5hcHBseShlbnYsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJ1biBzb21lIHNoYXJlZCB0ZWFyZG93biBhZnRlciBlYWNoIG9mIHRoZSBzcGVjcyBpbiB0aGUge0BsaW5rIGRlc2NyaWJlfSBpbiB3aGljaCBpdCBpcyBjYWxsZWQuXG4gICAgICogQG5hbWUgYWZ0ZXJFYWNoXG4gICAgICogQHNpbmNlIDEuMy4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGdsb2JhbFxuICAgICAqIEBwYXJhbSB7aW1wbGVtZW50YXRpb25DYWxsYmFja30gW2Z1bmN0aW9uXSBGdW5jdGlvbiB0aGF0IGNvbnRhaW5zIHRoZSBjb2RlIHRvIHRlYXJkb3duIHlvdXIgc3BlY3MuXG4gICAgICogQHBhcmFtIHtJbnR9IFt0aW1lb3V0PXtAbGluayBqYXNtaW5lLkRFRkFVTFRfVElNRU9VVF9JTlRFUlZBTH1dIEN1c3RvbSB0aW1lb3V0IGZvciBhbiBhc3luYyBhZnRlckVhY2guXG4gICAgICogQHNlZSBhc3luY1xuICAgICAqL1xuICAgIGFmdGVyRWFjaDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZW52LmFmdGVyRWFjaC5hcHBseShlbnYsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJ1biBzb21lIHNoYXJlZCBzZXR1cCBvbmNlIGJlZm9yZSBhbGwgb2YgdGhlIHNwZWNzIGluIHRoZSB7QGxpbmsgZGVzY3JpYmV9IGFyZSBydW4uXG4gICAgICpcbiAgICAgKiBfTm90ZTpfIEJlIGNhcmVmdWwsIHNoYXJpbmcgdGhlIHNldHVwIGZyb20gYSBiZWZvcmVBbGwgbWFrZXMgaXQgZWFzeSB0byBhY2NpZGVudGFsbHkgbGVhayBzdGF0ZSBiZXR3ZWVuIHlvdXIgc3BlY3Mgc28gdGhhdCB0aGV5IGVycm9uZW91c2x5IHBhc3Mgb3IgZmFpbC5cbiAgICAgKiBAbmFtZSBiZWZvcmVBbGxcbiAgICAgKiBAc2luY2UgMi4xLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZ2xvYmFsXG4gICAgICogQHBhcmFtIHtpbXBsZW1lbnRhdGlvbkNhbGxiYWNrfSBbZnVuY3Rpb25dIEZ1bmN0aW9uIHRoYXQgY29udGFpbnMgdGhlIGNvZGUgdG8gc2V0dXAgeW91ciBzcGVjcy5cbiAgICAgKiBAcGFyYW0ge0ludH0gW3RpbWVvdXQ9e0BsaW5rIGphc21pbmUuREVGQVVMVF9USU1FT1VUX0lOVEVSVkFMfV0gQ3VzdG9tIHRpbWVvdXQgZm9yIGFuIGFzeW5jIGJlZm9yZUFsbC5cbiAgICAgKiBAc2VlIGFzeW5jXG4gICAgICovXG4gICAgYmVmb3JlQWxsOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBlbnYuYmVmb3JlQWxsLmFwcGx5KGVudiwgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUnVuIHNvbWUgc2hhcmVkIHRlYXJkb3duIG9uY2UgYWZ0ZXIgYWxsIG9mIHRoZSBzcGVjcyBpbiB0aGUge0BsaW5rIGRlc2NyaWJlfSBhcmUgcnVuLlxuICAgICAqXG4gICAgICogX05vdGU6XyBCZSBjYXJlZnVsLCBzaGFyaW5nIHRoZSB0ZWFyZG93biBmcm9tIGEgYWZ0ZXJBbGwgbWFrZXMgaXQgZWFzeSB0byBhY2NpZGVudGFsbHkgbGVhayBzdGF0ZSBiZXR3ZWVuIHlvdXIgc3BlY3Mgc28gdGhhdCB0aGV5IGVycm9uZW91c2x5IHBhc3Mgb3IgZmFpbC5cbiAgICAgKiBAbmFtZSBhZnRlckFsbFxuICAgICAqIEBzaW5jZSAyLjEuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBnbG9iYWxcbiAgICAgKiBAcGFyYW0ge2ltcGxlbWVudGF0aW9uQ2FsbGJhY2t9IFtmdW5jdGlvbl0gRnVuY3Rpb24gdGhhdCBjb250YWlucyB0aGUgY29kZSB0byB0ZWFyZG93biB5b3VyIHNwZWNzLlxuICAgICAqIEBwYXJhbSB7SW50fSBbdGltZW91dD17QGxpbmsgamFzbWluZS5ERUZBVUxUX1RJTUVPVVRfSU5URVJWQUx9XSBDdXN0b20gdGltZW91dCBmb3IgYW4gYXN5bmMgYWZ0ZXJBbGwuXG4gICAgICogQHNlZSBhc3luY1xuICAgICAqL1xuICAgIGFmdGVyQWxsOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBlbnYuYWZ0ZXJBbGwuYXBwbHkoZW52LCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgdXNlci1kZWZpbmVkIHByb3BlcnR5IHRoYXQgd2lsbCBiZSBwcm92aWRlZCB0byByZXBvcnRlcnMgYXMgcGFydCBvZiB0aGUgcHJvcGVydGllcyBmaWVsZCBvZiB7QGxpbmsgU3BlY1Jlc3VsdH1cbiAgICAgKiBAbmFtZSBzZXRTcGVjUHJvcGVydHlcbiAgICAgKiBAc2luY2UgMy42LjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAqL1xuICAgIHNldFNwZWNQcm9wZXJ0eTogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGVudi5zZXRTcGVjUHJvcGVydHkoa2V5LCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgYSB1c2VyLWRlZmluZWQgcHJvcGVydHkgdGhhdCB3aWxsIGJlIHByb3ZpZGVkIHRvIHJlcG9ydGVycyBhcyBwYXJ0IG9mIHRoZSBwcm9wZXJ0aWVzIGZpZWxkIG9mIHtAbGluayBTdWl0ZVJlc3VsdH1cbiAgICAgKiBAbmFtZSBzZXRTdWl0ZVByb3BlcnR5XG4gICAgICogQHNpbmNlIDMuNi4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKi9cbiAgICBzZXRTdWl0ZVByb3BlcnR5OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gZW52LnNldFN1aXRlUHJvcGVydHkoa2V5LCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBleHBlY3RhdGlvbiBmb3IgYSBzcGVjLlxuICAgICAqIEBuYW1lIGV4cGVjdFxuICAgICAqIEBzaW5jZSAxLjMuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBnbG9iYWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWN0dWFsIC0gQWN0dWFsIGNvbXB1dGVkIHZhbHVlIHRvIHRlc3QgZXhwZWN0YXRpb25zIGFnYWluc3QuXG4gICAgICogQHJldHVybiB7bWF0Y2hlcnN9XG4gICAgICovXG4gICAgZXhwZWN0OiBmdW5jdGlvbihhY3R1YWwpIHtcbiAgICAgIHJldHVybiBlbnYuZXhwZWN0KGFjdHVhbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBhc3luY2hyb25vdXMgZXhwZWN0YXRpb24gZm9yIGEgc3BlYy4gTm90ZSB0aGF0IHRoZSBtYXRjaGVyc1xuICAgICAqIHRoYXQgYXJlIHByb3ZpZGVkIGJ5IGFuIGFzeW5jaHJvbm91cyBleHBlY3RhdGlvbiBhbGwgcmV0dXJuIHByb21pc2VzXG4gICAgICogd2hpY2ggbXVzdCBiZSBlaXRoZXIgcmV0dXJuZWQgZnJvbSB0aGUgc3BlYyBvciB3YWl0ZWQgZm9yIHVzaW5nIGBhd2FpdGBcbiAgICAgKiBpbiBvcmRlciBmb3IgSmFzbWluZSB0byBhc3NvY2lhdGUgdGhlbSB3aXRoIHRoZSBjb3JyZWN0IHNwZWMuXG4gICAgICogQG5hbWUgZXhwZWN0QXN5bmNcbiAgICAgKiBAc2luY2UgMy4zLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZ2xvYmFsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFjdHVhbCAtIEFjdHVhbCBjb21wdXRlZCB2YWx1ZSB0byB0ZXN0IGV4cGVjdGF0aW9ucyBhZ2FpbnN0LlxuICAgICAqIEByZXR1cm4ge2FzeW5jLW1hdGNoZXJzfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogYXdhaXQgZXhwZWN0QXN5bmMoc29tZVByb21pc2UpLnRvQmVSZXNvbHZlZCgpO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogcmV0dXJuIGV4cGVjdEFzeW5jKHNvbWVQcm9taXNlKS50b0JlUmVzb2x2ZWQoKTtcbiAgICAgKi9cbiAgICBleHBlY3RBc3luYzogZnVuY3Rpb24oYWN0dWFsKSB7XG4gICAgICByZXR1cm4gZW52LmV4cGVjdEFzeW5jKGFjdHVhbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1hcmsgYSBzcGVjIGFzIHBlbmRpbmcsIGV4cGVjdGF0aW9uIHJlc3VsdHMgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqIEBuYW1lIHBlbmRpbmdcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZ2xvYmFsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFttZXNzYWdlXSAtIFJlYXNvbiB0aGUgc3BlYyBpcyBwZW5kaW5nLlxuICAgICAqL1xuICAgIHBlbmRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGVudi5wZW5kaW5nLmFwcGx5KGVudiwgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXhwbGljaXRseSBtYXJrIGEgc3BlYyBhcyBmYWlsZWQuXG4gICAgICogQG5hbWUgZmFpbFxuICAgICAqIEBzaW5jZSAyLjEuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBnbG9iYWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xFcnJvcn0gW2Vycm9yXSAtIFJlYXNvbiBmb3IgdGhlIGZhaWx1cmUuXG4gICAgICovXG4gICAgZmFpbDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZW52LmZhaWwuYXBwbHkoZW52LCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnN0YWxsIGEgc3B5IG9udG8gYW4gZXhpc3Rpbmcgb2JqZWN0LlxuICAgICAqIEBuYW1lIHNweU9uXG4gICAgICogQHNpbmNlIDEuMy4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGdsb2JhbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBUaGUgb2JqZWN0IHVwb24gd2hpY2ggdG8gaW5zdGFsbCB0aGUge0BsaW5rIFNweX0uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIHJlcGxhY2Ugd2l0aCBhIHtAbGluayBTcHl9LlxuICAgICAqIEByZXR1cm5zIHtTcHl9XG4gICAgICovXG4gICAgc3B5T246IGZ1bmN0aW9uKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgICAgcmV0dXJuIGVudi5zcHlPbihvYmosIG1ldGhvZE5hbWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnN0YWxsIGEgc3B5IG9uIGEgcHJvcGVydHkgaW5zdGFsbGVkIHdpdGggYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgb250byBhbiBleGlzdGluZyBvYmplY3QuXG4gICAgICogQG5hbWUgc3B5T25Qcm9wZXJ0eVxuICAgICAqIEBzaW5jZSAyLjYuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBnbG9iYWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gVGhlIG9iamVjdCB1cG9uIHdoaWNoIHRvIGluc3RhbGwgdGhlIHtAbGluayBTcHl9XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byByZXBsYWNlIHdpdGggYSB7QGxpbmsgU3B5fS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2FjY2Vzc1R5cGU9Z2V0XSAtIFRoZSBhY2Nlc3MgdHlwZSAoZ2V0fHNldCkgb2YgdGhlIHByb3BlcnR5IHRvIHtAbGluayBTcHl9IG9uLlxuICAgICAqIEByZXR1cm5zIHtTcHl9XG4gICAgICovXG4gICAgc3B5T25Qcm9wZXJ0eTogZnVuY3Rpb24ob2JqLCBtZXRob2ROYW1lLCBhY2Nlc3NUeXBlKSB7XG4gICAgICByZXR1cm4gZW52LnNweU9uUHJvcGVydHkob2JqLCBtZXRob2ROYW1lLCBhY2Nlc3NUeXBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5zdGFsbHMgc3BpZXMgb24gYWxsIHdyaXRhYmxlIGFuZCBjb25maWd1cmFibGUgcHJvcGVydGllcyBvZiBhbiBvYmplY3QuXG4gICAgICogQG5hbWUgc3B5T25BbGxGdW5jdGlvbnNcbiAgICAgKiBAc2luY2UgMy4yLjFcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZ2xvYmFsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIFRoZSBvYmplY3QgdXBvbiB3aGljaCB0byBpbnN0YWxsIHRoZSB7QGxpbmsgU3B5fXNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluY2x1ZGVOb25FbnVtZXJhYmxlIC0gV2hldGhlciBvciBub3QgdG8gYWRkIHNwaWVzIHRvIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgc3BpZWQgb2JqZWN0XG4gICAgICovXG4gICAgc3B5T25BbGxGdW5jdGlvbnM6IGZ1bmN0aW9uKG9iaiwgaW5jbHVkZU5vbkVudW1lcmFibGUpIHtcbiAgICAgIHJldHVybiBlbnYuc3B5T25BbGxGdW5jdGlvbnMob2JqLCBpbmNsdWRlTm9uRW51bWVyYWJsZSk7XG4gICAgfSxcblxuICAgIGpzQXBpUmVwb3J0ZXI6IG5ldyBqYXNtaW5lLkpzQXBpUmVwb3J0ZXIoe1xuICAgICAgdGltZXI6IG5ldyBqYXNtaW5lLlRpbWVyKClcbiAgICB9KSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2UgamFzbWluZVxuICAgICAqL1xuICAgIGphc21pbmU6IGphc21pbmVcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgY3VzdG9tIGVxdWFsaXR5IHRlc3RlciBmb3IgdGhlIGN1cnJlbnQgc2NvcGUgb2Ygc3BlY3MuXG4gICAqXG4gICAqIF9Ob3RlOl8gVGhpcyBpcyBvbmx5IGNhbGxhYmxlIGZyb20gd2l0aGluIGEge0BsaW5rIGJlZm9yZUVhY2h9LCB7QGxpbmsgaXR9LCBvciB7QGxpbmsgYmVmb3JlQWxsfS5cbiAgICogQG5hbWUgamFzbWluZS5hZGRDdXN0b21FcXVhbGl0eVRlc3RlclxuICAgKiBAc2luY2UgMi4wLjBcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHRlc3RlciAtIEEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgdHdvIGFyZ3VtZW50cyB0byBjb21wYXJlIGFuZCByZXR1cm5zIGEgYHRydWVgIG9yIGBmYWxzZWAgY29tcGFyaXNvbiByZXN1bHQgaWYgaXQga25vd3MgaG93IHRvIGNvbXBhcmUgdGhlbSwgYW5kIGB1bmRlZmluZWRgIG90aGVyd2lzZS5cbiAgICogQHNlZSBjdXN0b21fZXF1YWxpdHlcbiAgICovXG4gIGphc21pbmUuYWRkQ3VzdG9tRXF1YWxpdHlUZXN0ZXIgPSBmdW5jdGlvbih0ZXN0ZXIpIHtcbiAgICBlbnYuYWRkQ3VzdG9tRXF1YWxpdHlUZXN0ZXIodGVzdGVyKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGN1c3RvbSBtYXRjaGVycyBmb3IgdGhlIGN1cnJlbnQgc2NvcGUgb2Ygc3BlY3MuXG4gICAqXG4gICAqIF9Ob3RlOl8gVGhpcyBpcyBvbmx5IGNhbGxhYmxlIGZyb20gd2l0aGluIGEge0BsaW5rIGJlZm9yZUVhY2h9LCB7QGxpbmsgaXR9LCBvciB7QGxpbmsgYmVmb3JlQWxsfS5cbiAgICogQG5hbWUgamFzbWluZS5hZGRNYXRjaGVyc1xuICAgKiBAc2luY2UgMi4wLjBcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXRjaGVycyAtIEtleXMgZnJvbSB0aGlzIG9iamVjdCB3aWxsIGJlIHRoZSBuZXcgbWF0Y2hlciBuYW1lcy5cbiAgICogQHNlZSBjdXN0b21fbWF0Y2hlclxuICAgKi9cbiAgamFzbWluZS5hZGRNYXRjaGVycyA9IGZ1bmN0aW9uKG1hdGNoZXJzKSB7XG4gICAgcmV0dXJuIGVudi5hZGRNYXRjaGVycyhtYXRjaGVycyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBjdXN0b20gYXN5bmMgbWF0Y2hlcnMgZm9yIHRoZSBjdXJyZW50IHNjb3BlIG9mIHNwZWNzLlxuICAgKlxuICAgKiBfTm90ZTpfIFRoaXMgaXMgb25seSBjYWxsYWJsZSBmcm9tIHdpdGhpbiBhIHtAbGluayBiZWZvcmVFYWNofSwge0BsaW5rIGl0fSwgb3Ige0BsaW5rIGJlZm9yZUFsbH0uXG4gICAqIEBuYW1lIGphc21pbmUuYWRkQXN5bmNNYXRjaGVyc1xuICAgKiBAc2luY2UgMy41LjBcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXRjaGVycyAtIEtleXMgZnJvbSB0aGlzIG9iamVjdCB3aWxsIGJlIHRoZSBuZXcgYXN5bmMgbWF0Y2hlciBuYW1lcy5cbiAgICogQHNlZSBjdXN0b21fbWF0Y2hlclxuICAgKi9cbiAgamFzbWluZS5hZGRBc3luY01hdGNoZXJzID0gZnVuY3Rpb24obWF0Y2hlcnMpIHtcbiAgICByZXR1cm4gZW52LmFkZEFzeW5jTWF0Y2hlcnMobWF0Y2hlcnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBjdXN0b20gb2JqZWN0IGZvcm1hdHRlciBmb3IgdGhlIGN1cnJlbnQgc2NvcGUgb2Ygc3BlY3MuXG4gICAqXG4gICAqIF9Ob3RlOl8gVGhpcyBpcyBvbmx5IGNhbGxhYmxlIGZyb20gd2l0aGluIGEge0BsaW5rIGJlZm9yZUVhY2h9LCB7QGxpbmsgaXR9LCBvciB7QGxpbmsgYmVmb3JlQWxsfS5cbiAgICogQG5hbWUgamFzbWluZS5hZGRDdXN0b21PYmplY3RGb3JtYXR0ZXJcbiAgICogQHNpbmNlIDMuNi4wXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmb3JtYXR0ZXIgLSBBIGZ1bmN0aW9uIHdoaWNoIHRha2VzIGEgdmFsdWUgdG8gZm9ybWF0IGFuZCByZXR1cm5zIGEgc3RyaW5nIGlmIGl0IGtub3dzIGhvdyB0byBmb3JtYXQgaXQsIGFuZCBgdW5kZWZpbmVkYCBvdGhlcndpc2UuXG4gICAqIEBzZWUgY3VzdG9tX29iamVjdF9mb3JtYXR0ZXJzXG4gICAqL1xuICBqYXNtaW5lLmFkZEN1c3RvbU9iamVjdEZvcm1hdHRlciA9IGZ1bmN0aW9uKGZvcm1hdHRlcikge1xuICAgIHJldHVybiBlbnYuYWRkQ3VzdG9tT2JqZWN0Rm9ybWF0dGVyKGZvcm1hdHRlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudGx5IGJvb3RlZCBtb2NrIHtDbG9ja30gZm9yIHRoaXMgSmFzbWluZSBlbnZpcm9ubWVudC5cbiAgICogQG5hbWUgamFzbWluZS5jbG9ja1xuICAgKiBAc2luY2UgMi4wLjBcbiAgICogQGZ1bmN0aW9uXG4gICAqIEByZXR1cm5zIHtDbG9ja31cbiAgICovXG4gIGphc21pbmUuY2xvY2sgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZW52LmNsb2NrO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBiYXJlIHtAbGluayBTcHl9IG9iamVjdC4gVGhpcyB3b24ndCBiZSBpbnN0YWxsZWQgYW55d2hlcmUgYW5kIHdpbGwgbm90IGhhdmUgYW55IGltcGxlbWVudGF0aW9uIGJlaGluZCBpdC5cbiAgICogQG5hbWUgamFzbWluZS5jcmVhdGVTcHlcbiAgICogQHNpbmNlIDEuMy4wXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gW25hbWVdIC0gTmFtZSB0byBnaXZlIHRoZSBzcHkuIFRoaXMgd2lsbCBiZSBkaXNwbGF5ZWQgaW4gZmFpbHVyZSBtZXNzYWdlcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29yaWdpbmFsRm5dIC0gRnVuY3Rpb24gdG8gYWN0IGFzIHRoZSByZWFsIGltcGxlbWVudGF0aW9uLlxuICAgKiBAcmV0dXJuIHtTcHl9XG4gICAqL1xuICBqYXNtaW5lLmNyZWF0ZVNweSA9IGZ1bmN0aW9uKG5hbWUsIG9yaWdpbmFsRm4pIHtcbiAgICByZXR1cm4gZW52LmNyZWF0ZVNweShuYW1lLCBvcmlnaW5hbEZuKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIG9iamVjdCB3aXRoIG11bHRpcGxlIHtAbGluayBTcHl9cyBhcyBpdHMgbWVtYmVycy5cbiAgICogQG5hbWUgamFzbWluZS5jcmVhdGVTcHlPYmpcbiAgICogQHNpbmNlIDEuMy4wXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2Jhc2VOYW1lXSAtIEJhc2UgbmFtZSBmb3IgdGhlIHNwaWVzIGluIHRoZSBvYmplY3QuXG4gICAqIEBwYXJhbSB7U3RyaW5nW118T2JqZWN0fSBtZXRob2ROYW1lcyAtIEFycmF5IG9mIG1ldGhvZCBuYW1lcyB0byBjcmVhdGUgc3BpZXMgZm9yLCBvciBPYmplY3Qgd2hvc2Uga2V5cyB3aWxsIGJlIG1ldGhvZCBuYW1lcyBhbmQgdmFsdWVzIHRoZSB7QGxpbmsgU3B5I2FuZCNyZXR1cm5WYWx1ZXxyZXR1cm5WYWx1ZX0uXG4gICAqIEBwYXJhbSB7U3RyaW5nW118T2JqZWN0fSBbcHJvcGVydHlOYW1lc10gLSBBcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyB0byBjcmVhdGUgc3BpZXMgZm9yLCBvciBPYmplY3Qgd2hvc2Uga2V5cyB3aWxsIGJlIHByb3BlcnR5bmFtZXMgYW5kIHZhbHVlcyB0aGUge0BsaW5rIFNweSNhbmQjcmV0dXJuVmFsdWV8cmV0dXJuVmFsdWV9LlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBqYXNtaW5lLmNyZWF0ZVNweU9iaiA9IGZ1bmN0aW9uKGJhc2VOYW1lLCBtZXRob2ROYW1lcywgcHJvcGVydHlOYW1lcykge1xuICAgIHJldHVybiBlbnYuY3JlYXRlU3B5T2JqKGJhc2VOYW1lLCBtZXRob2ROYW1lcywgcHJvcGVydHlOYW1lcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIGN1c3RvbSBzcHkgc3RyYXRlZ3kgZm9yIHRoZSBjdXJyZW50IHNjb3BlIG9mIHNwZWNzLlxuICAgKlxuICAgKiBfTm90ZTpfIFRoaXMgaXMgb25seSBjYWxsYWJsZSBmcm9tIHdpdGhpbiBhIHtAbGluayBiZWZvcmVFYWNofSwge0BsaW5rIGl0fSwgb3Ige0BsaW5rIGJlZm9yZUFsbH0uXG4gICAqIEBuYW1lIGphc21pbmUuYWRkU3B5U3RyYXRlZ3lcbiAgICogQHNpbmNlIDMuNS4wXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzdHJhdGVneSAoaS5lLiB3aGF0IHlvdSBjYWxsIGZyb20gYGFuZGApXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZhY3RvcnkgLSBGYWN0b3J5IGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgcGxhbiB0byBiZSBleGVjdXRlZC5cbiAgICovXG4gIGphc21pbmUuYWRkU3B5U3RyYXRlZ3kgPSBmdW5jdGlvbihuYW1lLCBmYWN0b3J5KSB7XG4gICAgcmV0dXJuIGVudi5hZGRTcHlTdHJhdGVneShuYW1lLCBmYWN0b3J5KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBkZWZhdWx0IHNweSBzdHJhdGVneSBmb3IgdGhlIGN1cnJlbnQgc2NvcGUgb2Ygc3BlY3MuXG4gICAqXG4gICAqIF9Ob3RlOl8gVGhpcyBpcyBvbmx5IGNhbGxhYmxlIGZyb20gd2l0aGluIGEge0BsaW5rIGJlZm9yZUVhY2h9LCB7QGxpbmsgaXR9LCBvciB7QGxpbmsgYmVmb3JlQWxsfS5cbiAgICogQG5hbWUgamFzbWluZS5zZXREZWZhdWx0U3B5U3RyYXRlZ3lcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRlZmF1bHRTdHJhdGVneUZuIC0gYSBmdW5jdGlvbiB0aGF0IGFzc2lnbnMgYSBzdHJhdGVneVxuICAgKiBAZXhhbXBsZVxuICAgKiBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuICAgKiAgIGphc21pbmUuc2V0RGVmYXVsdFNweVN0cmF0ZWd5KGFuZCA9PiBhbmQucmV0dXJuVmFsdWUodHJ1ZSkpO1xuICAgKiB9KTtcbiAgICovXG4gIGphc21pbmUuc2V0RGVmYXVsdFNweVN0cmF0ZWd5ID0gZnVuY3Rpb24oZGVmYXVsdFN0cmF0ZWd5Rm4pIHtcbiAgICByZXR1cm4gZW52LnNldERlZmF1bHRTcHlTdHJhdGVneShkZWZhdWx0U3RyYXRlZ3lGbik7XG4gIH07XG5cbiAgcmV0dXJuIGphc21pbmVJbnRlcmZhY2U7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlNraXBBZnRlckJlZm9yZUFsbEVycm9yUG9saWN5ID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gU2tpcEFmdGVyQmVmb3JlQWxsRXJyb3JQb2xpY3kocXVldWVhYmxlRm5zKSB7XG4gICAgdGhpcy5xdWV1ZWFibGVGbnNfID0gcXVldWVhYmxlRm5zO1xuICAgIHRoaXMuc2tpcHBpbmdfID0gZmFsc2U7XG4gIH1cblxuICBTa2lwQWZ0ZXJCZWZvcmVBbGxFcnJvclBvbGljeS5wcm90b3R5cGUuc2tpcFRvID0gZnVuY3Rpb24obGFzdFJhbkZuSXgpIHtcbiAgICBpZiAodGhpcy5za2lwcGluZ18pIHtcbiAgICAgIHJldHVybiB0aGlzLm5leHRBZnRlckFsbEFmdGVyXyhsYXN0UmFuRm5JeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsYXN0UmFuRm5JeCArIDE7XG4gICAgfVxuICB9O1xuXG4gIFNraXBBZnRlckJlZm9yZUFsbEVycm9yUG9saWN5LnByb3RvdHlwZS5uZXh0QWZ0ZXJBbGxBZnRlcl8gPSBmdW5jdGlvbihpKSB7XG4gICAgZm9yIChcbiAgICAgIGkrKztcbiAgICAgIGkgPCB0aGlzLnF1ZXVlYWJsZUZuc18ubGVuZ3RoICYmXG4gICAgICB0aGlzLnF1ZXVlYWJsZUZuc19baV0udHlwZSAhPT0gJ2FmdGVyQWxsJztcbiAgICAgIGkrK1xuICAgICkge31cbiAgICByZXR1cm4gaTtcbiAgfTtcblxuICBTa2lwQWZ0ZXJCZWZvcmVBbGxFcnJvclBvbGljeS5wcm90b3R5cGUuZm5FcnJvcmVkID0gZnVuY3Rpb24oZm5JeCkge1xuICAgIGlmICh0aGlzLnF1ZXVlYWJsZUZuc19bZm5JeF0udHlwZSA9PT0gJ2JlZm9yZUFsbCcpIHtcbiAgICAgIHRoaXMuc2tpcHBpbmdfID0gdHJ1ZTtcbiAgICAgIC8vIEZhaWx1cmVzIG5lZWQgdG8gYmUgcmVwb3J0ZWQgZm9yIGVhY2ggY29udGFpbmVkIHNwZWMuIEJ1dCB3ZSBjYW4ndCBkb1xuICAgICAgLy8gdGhhdCBmcm9tIGhlcmUgYmVjYXVzZSByZXBvcnRpbmcgaXMgYXN5bmMuIFRoaXMgZnVuY3Rpb24gaXNuJ3QgYXN5bmNcbiAgICAgIC8vIChhbmQgY2FuJ3QgYmUgd2l0aG91dCBncmVhdGx5IGNvbXBsaWNhdGluZyBRdWV1ZVJ1bm5lcikuIE1hcmsgdGhlXG4gICAgICAvLyBmYWlsdXJlIHNvIHRoYXQgdGhlIGNvZGUgdGhhdCByZXBvcnRzIHRoZSBzdWl0ZSByZXN1bHQgKHdoaWNoIGlzXG4gICAgICAvLyBhbHJlYWR5IGFzeW5jKSBjYW4gZGV0ZWN0IHRoZSBmYWlsdXJlIGFuZCByZXBvcnQgdGhlIHNwZWNzLlxuICAgICAgdGhpcy5xdWV1ZWFibGVGbnNfW2ZuSXhdLnN1aXRlLmhhZEJlZm9yZUFsbEZhaWx1cmUgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU2tpcEFmdGVyQmVmb3JlQWxsRXJyb3JQb2xpY3k7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlNweSA9IGZ1bmN0aW9uKGokKSB7XG4gIHZhciBuZXh0T3JkZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9yZGVyID0gMDtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBvcmRlcisrO1xuICAgIH07XG4gIH0pKCk7XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2MgX05vdGU6XyBEbyBub3QgY29uc3RydWN0IHRoaXMgZGlyZWN0bHkuIFVzZSB7QGxpbmsgc3B5T259LFxuICAgKiB7QGxpbmsgc3B5T25Qcm9wZXJ0eX0sIHtAbGluayBqYXNtaW5lLmNyZWF0ZVNweX0sIG9yXG4gICAqIHtAbGluayBqYXNtaW5lLmNyZWF0ZVNweU9ian0gaW5zdGVhZC5cbiAgICogQGNsYXNzIFNweVxuICAgKiBAaGlkZWNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBTcHkobmFtZSwgbWF0Y2hlcnNVdGlsLCBvcHRpb25hbHMpIHtcbiAgICBjb25zdCB7IG9yaWdpbmFsRm4sIGN1c3RvbVN0cmF0ZWdpZXMsIGRlZmF1bHRTdHJhdGVneUZuIH0gPSBvcHRpb25hbHMgfHwge307XG5cbiAgICB2YXIgbnVtQXJncyA9IHR5cGVvZiBvcmlnaW5hbEZuID09PSAnZnVuY3Rpb24nID8gb3JpZ2luYWxGbi5sZW5ndGggOiAwLFxuICAgICAgd3JhcHBlciA9IG1ha2VGdW5jKG51bUFyZ3MsIGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MsIGludm9rZU5ldykge1xuICAgICAgICByZXR1cm4gc3B5KGNvbnRleHQsIGFyZ3MsIGludm9rZU5ldyk7XG4gICAgICB9KSxcbiAgICAgIHN0cmF0ZWd5RGlzcGF0Y2hlciA9IG5ldyBTcHlTdHJhdGVneURpc3BhdGNoZXIoXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIGZuOiBvcmlnaW5hbEZuLFxuICAgICAgICAgIGdldFNweTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGN1c3RvbVN0cmF0ZWdpZXM6IGN1c3RvbVN0cmF0ZWdpZXNcbiAgICAgICAgfSxcbiAgICAgICAgbWF0Y2hlcnNVdGlsXG4gICAgICApLFxuICAgICAgY2FsbFRyYWNrZXIgPSBuZXcgaiQuQ2FsbFRyYWNrZXIoKSxcbiAgICAgIHNweSA9IGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MsIGludm9rZU5ldykge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgU3B5LmNhbGxEYXRhXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBvYmplY3QgLSBgdGhpc2AgY29udGV4dCBmb3IgdGhlIGludm9jYXRpb24uXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnZvY2F0aW9uT3JkZXIgLSBPcmRlciBvZiB0aGUgaW52b2NhdGlvbi5cbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheX0gYXJncyAtIFRoZSBhcmd1bWVudHMgcGFzc2VkIGZvciB0aGlzIGludm9jYXRpb24uXG4gICAgICAgICAqIEBwcm9wZXJ0eSByZXR1cm5WYWx1ZSAtIFRoZSB2YWx1ZSB0aGF0IHdhcyByZXR1cm5lZCBmcm9tIHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBjYWxsRGF0YSA9IHtcbiAgICAgICAgICBvYmplY3Q6IGNvbnRleHQsXG4gICAgICAgICAgaW52b2NhdGlvbk9yZGVyOiBuZXh0T3JkZXIoKSxcbiAgICAgICAgICBhcmdzOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJncylcbiAgICAgICAgfTtcblxuICAgICAgICBjYWxsVHJhY2tlci50cmFjayhjYWxsRGF0YSk7XG4gICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IHN0cmF0ZWd5RGlzcGF0Y2hlci5leGVjKGNvbnRleHQsIGFyZ3MsIGludm9rZU5ldyk7XG4gICAgICAgIGNhbGxEYXRhLnJldHVyblZhbHVlID0gcmV0dXJuVmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgfTtcblxuICAgIGZ1bmN0aW9uIG1ha2VGdW5jKGxlbmd0aCwgZm4pIHtcbiAgICAgIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gd3JhcDEoYSkge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHRoaXMsIGFyZ3VtZW50cywgdGhpcyBpbnN0YW5jZW9mIHdyYXAxKTtcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAyKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBmbih0aGlzLCBhcmd1bWVudHMsIHRoaXMgaW5zdGFuY2VvZiB3cmFwMik7XG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiB3cmFwMyhhLCBiLCBjKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4odGhpcywgYXJndW1lbnRzLCB0aGlzIGluc3RhbmNlb2Ygd3JhcDMpO1xuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gd3JhcDQoYSwgYiwgYywgZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHRoaXMsIGFyZ3VtZW50cywgdGhpcyBpbnN0YW5jZW9mIHdyYXA0KTtcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHdyYXA1KGEsIGIsIGMsIGQsIGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmbih0aGlzLCBhcmd1bWVudHMsIHRoaXMgaW5zdGFuY2VvZiB3cmFwNSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiB3cmFwNihhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4odGhpcywgYXJndW1lbnRzLCB0aGlzIGluc3RhbmNlb2Ygd3JhcDYpO1xuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gd3JhcDcoYSwgYiwgYywgZCwgZSwgZiwgZykge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHRoaXMsIGFyZ3VtZW50cywgdGhpcyBpbnN0YW5jZW9mIHdyYXA3KTtcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHdyYXA4KGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmbih0aGlzLCBhcmd1bWVudHMsIHRoaXMgaW5zdGFuY2VvZiB3cmFwOCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiB3cmFwOShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4odGhpcywgYXJndW1lbnRzLCB0aGlzIGluc3RhbmNlb2Ygd3JhcDkpO1xuICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4odGhpcywgYXJndW1lbnRzLCB0aGlzIGluc3RhbmNlb2Ygd3JhcCk7XG4gICAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIG9yaWdpbmFsRm4pIHtcbiAgICAgIGlmIChwcm9wID09PSAnYW5kJyB8fCBwcm9wID09PSAnY2FsbHMnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkphc21pbmUgc3BpZXMgd291bGQgb3ZlcndyaXRlIHRoZSAnYW5kJyBhbmQgJ2NhbGxzJyBwcm9wZXJ0aWVzIG9uIHRoZSBvYmplY3QgYmVpbmcgc3BpZWQgdXBvblwiXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHdyYXBwZXJbcHJvcF0gPSBvcmlnaW5hbEZuW3Byb3BdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1NweVN0cmF0ZWd5fSAtIEFjY2Vzc2VzIHRoZSBkZWZhdWx0IHN0cmF0ZWd5IGZvciB0aGUgc3B5LiBUaGlzIHN0cmF0ZWd5IHdpbGwgYmUgdXNlZFxuICAgICAqIHdoZW5ldmVyIHRoZSBzcHkgaXMgY2FsbGVkIHdpdGggYXJndW1lbnRzIHRoYXQgZG9uJ3QgbWF0Y2ggYW55IHN0cmF0ZWd5XG4gICAgICogY3JlYXRlZCB3aXRoIHtAbGluayBTcHkjd2l0aEFyZ3N9LlxuICAgICAqIEBuYW1lIFNweSNhbmRcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHNweU9uKHNvbWVPYmosICdmdW5jJykuYW5kLnJldHVyblZhbHVlKDQyKTtcbiAgICAgKi9cbiAgICB3cmFwcGVyLmFuZCA9IHN0cmF0ZWd5RGlzcGF0Y2hlci5hbmQ7XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIGEgc3RyYXRlZ3kgdG8gYmUgdXNlZCBmb3IgY2FsbHMgdG8gdGhlIHNweSB0aGF0IGhhdmUgdGhlXG4gICAgICogc3BlY2lmaWVkIGFyZ3VtZW50cy5cbiAgICAgKiBAbmFtZSBTcHkjd2l0aEFyZ3NcbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgLSBUaGUgYXJndW1lbnRzIHRvIG1hdGNoXG4gICAgICogQHR5cGUge1NweVN0cmF0ZWd5fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogc3B5T24oc29tZU9iaiwgJ2Z1bmMnKS53aXRoQXJncygxLCAyLCAzKS5hbmQucmV0dXJuVmFsdWUoNDIpO1xuICAgICAqIHNvbWVPYmouZnVuYygxLCAyLCAzKTsgLy8gcmV0dXJucyA0MlxuICAgICAqL1xuICAgIHdyYXBwZXIud2l0aEFyZ3MgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdHJhdGVneURpc3BhdGNoZXIud2l0aEFyZ3MuYXBwbHkoc3RyYXRlZ3lEaXNwYXRjaGVyLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgd3JhcHBlci5jYWxscyA9IGNhbGxUcmFja2VyO1xuXG4gICAgaWYgKGRlZmF1bHRTdHJhdGVneUZuKSB7XG4gICAgICBkZWZhdWx0U3RyYXRlZ3lGbih3cmFwcGVyLmFuZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdyYXBwZXI7XG4gIH1cblxuICBmdW5jdGlvbiBTcHlTdHJhdGVneURpc3BhdGNoZXIoc3RyYXRlZ3lBcmdzLCBtYXRjaGVyc1V0aWwpIHtcbiAgICB2YXIgYmFzZVN0cmF0ZWd5ID0gbmV3IGokLlNweVN0cmF0ZWd5KHN0cmF0ZWd5QXJncyk7XG4gICAgdmFyIGFyZ3NTdHJhdGVnaWVzID0gbmV3IFN0cmF0ZWd5RGljdChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgaiQuU3B5U3RyYXRlZ3koc3RyYXRlZ3lBcmdzKTtcbiAgICB9LCBtYXRjaGVyc1V0aWwpO1xuXG4gICAgdGhpcy5hbmQgPSBiYXNlU3RyYXRlZ3k7XG5cbiAgICB0aGlzLmV4ZWMgPSBmdW5jdGlvbihzcHksIGFyZ3MsIGludm9rZU5ldykge1xuICAgICAgdmFyIHN0cmF0ZWd5ID0gYXJnc1N0cmF0ZWdpZXMuZ2V0KGFyZ3MpO1xuXG4gICAgICBpZiAoIXN0cmF0ZWd5KSB7XG4gICAgICAgIGlmIChhcmdzU3RyYXRlZ2llcy5hbnkoKSAmJiAhYmFzZVN0cmF0ZWd5LmlzQ29uZmlndXJlZCgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJTcHkgJ1wiICtcbiAgICAgICAgICAgICAgc3RyYXRlZ3lBcmdzLm5hbWUgK1xuICAgICAgICAgICAgICBcIicgcmVjZWl2ZWQgYSBjYWxsIHdpdGggYXJndW1lbnRzIFwiICtcbiAgICAgICAgICAgICAgaiQuYmFzaWNQcmV0dHlQcmludGVyXyhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKSkgK1xuICAgICAgICAgICAgICAnIGJ1dCBhbGwgY29uZmlndXJlZCBzdHJhdGVnaWVzIHNwZWNpZnkgb3RoZXIgYXJndW1lbnRzLidcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmF0ZWd5ID0gYmFzZVN0cmF0ZWd5O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHJhdGVneS5leGVjKHNweSwgYXJncywgaW52b2tlTmV3KTtcbiAgICB9O1xuXG4gICAgdGhpcy53aXRoQXJncyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHsgYW5kOiBhcmdzU3RyYXRlZ2llcy5nZXRPckNyZWF0ZShhcmd1bWVudHMpIH07XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFN0cmF0ZWd5RGljdChzdHJhdGVneUZhY3RvcnksIG1hdGNoZXJzVXRpbCkge1xuICAgIHRoaXMuc3RyYXRlZ2llcyA9IFtdO1xuICAgIHRoaXMuc3RyYXRlZ3lGYWN0b3J5ID0gc3RyYXRlZ3lGYWN0b3J5O1xuICAgIHRoaXMubWF0Y2hlcnNVdGlsID0gbWF0Y2hlcnNVdGlsO1xuICB9XG5cbiAgU3RyYXRlZ3lEaWN0LnByb3RvdHlwZS5hbnkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJhdGVnaWVzLmxlbmd0aCA+IDA7XG4gIH07XG5cbiAgU3RyYXRlZ3lEaWN0LnByb3RvdHlwZS5nZXRPckNyZWF0ZSA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICB2YXIgc3RyYXRlZ3kgPSB0aGlzLmdldChhcmdzKTtcblxuICAgIGlmICghc3RyYXRlZ3kpIHtcbiAgICAgIHN0cmF0ZWd5ID0gdGhpcy5zdHJhdGVneUZhY3RvcnkoKTtcbiAgICAgIHRoaXMuc3RyYXRlZ2llcy5wdXNoKHtcbiAgICAgICAgYXJnczogYXJncyxcbiAgICAgICAgc3RyYXRlZ3k6IHN0cmF0ZWd5XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyYXRlZ3k7XG4gIH07XG5cbiAgU3RyYXRlZ3lEaWN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zdHJhdGVnaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaGVyc1V0aWwuZXF1YWxzKGFyZ3MsIHRoaXMuc3RyYXRlZ2llc1tpXS5hcmdzKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJhdGVnaWVzW2ldLnN0cmF0ZWd5O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU3B5O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5TcHlGYWN0b3J5ID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gU3B5RmFjdG9yeShcbiAgICBnZXRDdXN0b21TdHJhdGVnaWVzLFxuICAgIGdldERlZmF1bHRTdHJhdGVneUZuLFxuICAgIGdldE1hdGNoZXJzVXRpbFxuICApIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLmNyZWF0ZVNweSA9IGZ1bmN0aW9uKG5hbWUsIG9yaWdpbmFsRm4pIHtcbiAgICAgIHJldHVybiBqJC5TcHkobmFtZSwgZ2V0TWF0Y2hlcnNVdGlsKCksIHtcbiAgICAgICAgb3JpZ2luYWxGbixcbiAgICAgICAgY3VzdG9tU3RyYXRlZ2llczogZ2V0Q3VzdG9tU3RyYXRlZ2llcygpLFxuICAgICAgICBkZWZhdWx0U3RyYXRlZ3lGbjogZ2V0RGVmYXVsdFN0cmF0ZWd5Rm4oKVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMuY3JlYXRlU3B5T2JqID0gZnVuY3Rpb24oYmFzZU5hbWUsIG1ldGhvZE5hbWVzLCBwcm9wZXJ0eU5hbWVzKSB7XG4gICAgICB2YXIgYmFzZU5hbWVJc0NvbGxlY3Rpb24gPVxuICAgICAgICBqJC5pc09iamVjdF8oYmFzZU5hbWUpIHx8IGokLmlzQXJyYXlfKGJhc2VOYW1lKTtcblxuICAgICAgaWYgKGJhc2VOYW1lSXNDb2xsZWN0aW9uKSB7XG4gICAgICAgIHByb3BlcnR5TmFtZXMgPSBtZXRob2ROYW1lcztcbiAgICAgICAgbWV0aG9kTmFtZXMgPSBiYXNlTmFtZTtcbiAgICAgICAgYmFzZU5hbWUgPSAndW5rbm93bic7XG4gICAgICB9XG5cbiAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgIHZhciBzcHksIGRlc2NyaXB0b3I7XG5cbiAgICAgIHZhciBtZXRob2RzID0gbm9ybWFsaXplS2V5VmFsdWVzKG1ldGhvZE5hbWVzKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzcHkgPSBvYmpbbWV0aG9kc1tpXVswXV0gPSBzZWxmLmNyZWF0ZVNweShcbiAgICAgICAgICBiYXNlTmFtZSArICcuJyArIG1ldGhvZHNbaV1bMF1cbiAgICAgICAgKTtcbiAgICAgICAgaWYgKG1ldGhvZHNbaV0ubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHNweS5hbmQucmV0dXJuVmFsdWUobWV0aG9kc1tpXVsxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHByb3BlcnRpZXMgPSBub3JtYWxpemVLZXlWYWx1ZXMocHJvcGVydHlOYW1lcyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogc2VsZi5jcmVhdGVTcHkoYmFzZU5hbWUgKyAnLicgKyBwcm9wZXJ0aWVzW2ldWzBdICsgJy5nZXQnKSxcbiAgICAgICAgICBzZXQ6IHNlbGYuY3JlYXRlU3B5KGJhc2VOYW1lICsgJy4nICsgcHJvcGVydGllc1tpXVswXSArICcuc2V0JylcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHByb3BlcnRpZXNbaV0ubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGRlc2NyaXB0b3IuZ2V0LmFuZC5yZXR1cm5WYWx1ZShwcm9wZXJ0aWVzW2ldWzFdKTtcbiAgICAgICAgICBkZXNjcmlwdG9yLnNldC5hbmQucmV0dXJuVmFsdWUocHJvcGVydGllc1tpXVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcGVydGllc1tpXVswXSwgZGVzY3JpcHRvcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZXRob2RzLmxlbmd0aCA9PT0gMCAmJiBwcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyAnY3JlYXRlU3B5T2JqIHJlcXVpcmVzIGEgbm9uLWVtcHR5IGFycmF5IG9yIG9iamVjdCBvZiBtZXRob2QgbmFtZXMgdG8gY3JlYXRlIHNwaWVzIGZvcic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUtleVZhbHVlcyhvYmplY3QpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgaWYgKGokLmlzQXJyYXlfKG9iamVjdCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFtvYmplY3RbaV1dKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGokLmlzT2JqZWN0XyhvYmplY3QpKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKFtrZXksIG9iamVjdFtrZXldXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJldHVybiBTcHlGYWN0b3J5O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5TcHlSZWdpc3RyeSA9IGZ1bmN0aW9uKGokKSB7XG4gIHZhciBzcHlPbk1zZyA9IGokLmZvcm1hdEVycm9yTXNnKCc8c3B5T24+JywgJ3NweU9uKDxvYmplY3Q+LCA8bWV0aG9kTmFtZT4pJyk7XG4gIHZhciBzcHlPblByb3BlcnR5TXNnID0gaiQuZm9ybWF0RXJyb3JNc2coXG4gICAgJzxzcHlPblByb3BlcnR5PicsXG4gICAgJ3NweU9uUHJvcGVydHkoPG9iamVjdD4sIDxwcm9wTmFtZT4sIFthY2Nlc3NUeXBlXSknXG4gICk7XG5cbiAgZnVuY3Rpb24gU3B5UmVnaXN0cnkob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBnbG9iYWwgPSBvcHRpb25zLmdsb2JhbCB8fCBqJC5nZXRHbG9iYWwoKTtcbiAgICB2YXIgY3JlYXRlU3B5ID0gb3B0aW9ucy5jcmVhdGVTcHk7XG4gICAgdmFyIGN1cnJlbnRTcGllcyA9XG4gICAgICBvcHRpb25zLmN1cnJlbnRTcGllcyB8fFxuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH07XG5cbiAgICB0aGlzLmFsbG93UmVzcHkgPSBmdW5jdGlvbihhbGxvdykge1xuICAgICAgdGhpcy5yZXNweSA9IGFsbG93O1xuICAgIH07XG5cbiAgICB0aGlzLnNweU9uID0gZnVuY3Rpb24ob2JqLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZ2V0RXJyb3JNc2cgPSBzcHlPbk1zZztcblxuICAgICAgaWYgKGokLnV0aWwuaXNVbmRlZmluZWQob2JqKSB8fCBvYmogPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGdldEVycm9yTXNnKFxuICAgICAgICAgICAgJ2NvdWxkIG5vdCBmaW5kIGFuIG9iamVjdCB0byBzcHkgdXBvbiBmb3IgJyArIG1ldGhvZE5hbWUgKyAnKCknXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoaiQudXRpbC5pc1VuZGVmaW5lZChtZXRob2ROYW1lKSB8fCBtZXRob2ROYW1lID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihnZXRFcnJvck1zZygnTm8gbWV0aG9kIG5hbWUgc3VwcGxpZWQnKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChqJC51dGlsLmlzVW5kZWZpbmVkKG9ialttZXRob2ROYW1lXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGdldEVycm9yTXNnKG1ldGhvZE5hbWUgKyAnKCkgbWV0aG9kIGRvZXMgbm90IGV4aXN0JykpO1xuICAgICAgfVxuXG4gICAgICBpZiAob2JqW21ldGhvZE5hbWVdICYmIGokLmlzU3B5KG9ialttZXRob2ROYW1lXSkpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzcHkpIHtcbiAgICAgICAgICByZXR1cm4gb2JqW21ldGhvZE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGdldEVycm9yTXNnKG1ldGhvZE5hbWUgKyAnIGhhcyBhbHJlYWR5IGJlZW4gc3BpZWQgdXBvbicpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBtZXRob2ROYW1lKTtcblxuICAgICAgaWYgKGRlc2NyaXB0b3IgJiYgIShkZXNjcmlwdG9yLndyaXRhYmxlIHx8IGRlc2NyaXB0b3Iuc2V0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgZ2V0RXJyb3JNc2cobWV0aG9kTmFtZSArICcgaXMgbm90IGRlY2xhcmVkIHdyaXRhYmxlIG9yIGhhcyBubyBzZXR0ZXInKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3JpZ2luYWxNZXRob2QgPSBvYmpbbWV0aG9kTmFtZV0sXG4gICAgICAgIHNwaWVkTWV0aG9kID0gY3JlYXRlU3B5KG1ldGhvZE5hbWUsIG9yaWdpbmFsTWV0aG9kKSxcbiAgICAgICAgcmVzdG9yZVN0cmF0ZWd5O1xuXG4gICAgICBpZiAoXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIG1ldGhvZE5hbWUpIHx8XG4gICAgICAgIChvYmogPT09IGdsb2JhbCAmJiBtZXRob2ROYW1lID09PSAnb25lcnJvcicpXG4gICAgICApIHtcbiAgICAgICAgcmVzdG9yZVN0cmF0ZWd5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgb2JqW21ldGhvZE5hbWVdID0gb3JpZ2luYWxNZXRob2Q7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN0b3JlU3RyYXRlZ3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoIWRlbGV0ZSBvYmpbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgICAgIG9ialttZXRob2ROYW1lXSA9IG9yaWdpbmFsTWV0aG9kO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudFNwaWVzKCkucHVzaCh7XG4gICAgICAgIHJlc3RvcmVPYmplY3RUb09yaWdpbmFsU3RhdGU6IHJlc3RvcmVTdHJhdGVneVxuICAgICAgfSk7XG5cbiAgICAgIG9ialttZXRob2ROYW1lXSA9IHNwaWVkTWV0aG9kO1xuXG4gICAgICByZXR1cm4gc3BpZWRNZXRob2Q7XG4gICAgfTtcblxuICAgIHRoaXMuc3B5T25Qcm9wZXJ0eSA9IGZ1bmN0aW9uKG9iaiwgcHJvcGVydHlOYW1lLCBhY2Nlc3NUeXBlKSB7XG4gICAgICB2YXIgZ2V0RXJyb3JNc2cgPSBzcHlPblByb3BlcnR5TXNnO1xuXG4gICAgICBhY2Nlc3NUeXBlID0gYWNjZXNzVHlwZSB8fCAnZ2V0JztcblxuICAgICAgaWYgKGokLnV0aWwuaXNVbmRlZmluZWQob2JqKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgZ2V0RXJyb3JNc2coXG4gICAgICAgICAgICAnc3B5T24gY291bGQgbm90IGZpbmQgYW4gb2JqZWN0IHRvIHNweSB1cG9uIGZvciAnICtcbiAgICAgICAgICAgICAgcHJvcGVydHlOYW1lICtcbiAgICAgICAgICAgICAgJydcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChqJC51dGlsLmlzVW5kZWZpbmVkKHByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGdldEVycm9yTXNnKCdObyBwcm9wZXJ0eSBuYW1lIHN1cHBsaWVkJykpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVzY3JpcHRvciA9IGokLnV0aWwuZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcGVydHlOYW1lKTtcblxuICAgICAgaWYgKCFkZXNjcmlwdG9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihnZXRFcnJvck1zZyhwcm9wZXJ0eU5hbWUgKyAnIHByb3BlcnR5IGRvZXMgbm90IGV4aXN0JykpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBnZXRFcnJvck1zZyhwcm9wZXJ0eU5hbWUgKyAnIGlzIG5vdCBkZWNsYXJlZCBjb25maWd1cmFibGUnKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRlc2NyaXB0b3JbYWNjZXNzVHlwZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGdldEVycm9yTXNnKFxuICAgICAgICAgICAgJ1Byb3BlcnR5ICcgK1xuICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWUgK1xuICAgICAgICAgICAgICAnIGRvZXMgbm90IGhhdmUgYWNjZXNzIHR5cGUgJyArXG4gICAgICAgICAgICAgIGFjY2Vzc1R5cGVcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChqJC5pc1NweShkZXNjcmlwdG9yW2FjY2Vzc1R5cGVdKSkge1xuICAgICAgICBpZiAodGhpcy5yZXNweSkge1xuICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yW2FjY2Vzc1R5cGVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGdldEVycm9yTXNnKFxuICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWUgKyAnIycgKyBhY2Nlc3NUeXBlICsgJyBoYXMgYWxyZWFkeSBiZWVuIHNwaWVkIHVwb24nXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgb3JpZ2luYWxEZXNjcmlwdG9yID0gaiQudXRpbC5jbG9uZShkZXNjcmlwdG9yKSxcbiAgICAgICAgc3B5ID0gY3JlYXRlU3B5KHByb3BlcnR5TmFtZSwgZGVzY3JpcHRvclthY2Nlc3NUeXBlXSksXG4gICAgICAgIHJlc3RvcmVTdHJhdGVneTtcblxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgcmVzdG9yZVN0cmF0ZWd5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcGVydHlOYW1lLCBvcmlnaW5hbERlc2NyaXB0b3IpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdG9yZVN0cmF0ZWd5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZGVsZXRlIG9ialtwcm9wZXJ0eU5hbWVdO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50U3BpZXMoKS5wdXNoKHtcbiAgICAgICAgcmVzdG9yZU9iamVjdFRvT3JpZ2luYWxTdGF0ZTogcmVzdG9yZVN0cmF0ZWd5XG4gICAgICB9KTtcblxuICAgICAgZGVzY3JpcHRvclthY2Nlc3NUeXBlXSA9IHNweTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcGVydHlOYW1lLCBkZXNjcmlwdG9yKTtcblxuICAgICAgcmV0dXJuIHNweTtcbiAgICB9O1xuXG4gICAgdGhpcy5zcHlPbkFsbEZ1bmN0aW9ucyA9IGZ1bmN0aW9uKG9iaiwgaW5jbHVkZU5vbkVudW1lcmFibGUpIHtcbiAgICAgIGlmIChqJC51dGlsLmlzVW5kZWZpbmVkKG9iaikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdzcHlPbkFsbEZ1bmN0aW9ucyBjb3VsZCBub3QgZmluZCBhbiBvYmplY3QgdG8gc3B5IHVwb24nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludGVyID0gb2JqLFxuICAgICAgICBwcm9wc1RvU3B5T24gPSBbXSxcbiAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgcHJvcGVydGllc1RvU2tpcCA9IFtdO1xuXG4gICAgICB3aGlsZSAoXG4gICAgICAgIHBvaW50ZXIgJiZcbiAgICAgICAgKCFpbmNsdWRlTm9uRW51bWVyYWJsZSB8fCBwb2ludGVyICE9PSBPYmplY3QucHJvdG90eXBlKVxuICAgICAgKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSBnZXRQcm9wcyhwb2ludGVyLCBpbmNsdWRlTm9uRW51bWVyYWJsZSk7XG4gICAgICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmZpbHRlcihmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BlcnRpZXNUb1NraXAuaW5kZXhPZihwcm9wKSA9PT0gLTE7XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9wZXJ0aWVzVG9Ta2lwID0gcHJvcGVydGllc1RvU2tpcC5jb25jYXQocHJvcGVydGllcyk7XG4gICAgICAgIHByb3BzVG9TcHlPbiA9IHByb3BzVG9TcHlPbi5jb25jYXQoXG4gICAgICAgICAgZ2V0U3B5YWJsZUZ1bmN0aW9uUHJvcHMocG9pbnRlciwgcHJvcGVydGllcylcbiAgICAgICAgKTtcbiAgICAgICAgcG9pbnRlciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwb2ludGVyKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wc1RvU3B5T24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5zcHlPbihvYmosIHByb3BzVG9TcHlPbltpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcblxuICAgIHRoaXMuY2xlYXJTcGllcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNwaWVzID0gY3VycmVudFNwaWVzKCk7XG4gICAgICBmb3IgKHZhciBpID0gc3BpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIHNweUVudHJ5ID0gc3BpZXNbaV07XG4gICAgICAgIHNweUVudHJ5LnJlc3RvcmVPYmplY3RUb09yaWdpbmFsU3RhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UHJvcHMob2JqLCBpbmNsdWRlTm9uRW51bWVyYWJsZSkge1xuICAgIHZhciBlbnVtZXJhYmxlUHJvcGVydGllcyA9IE9iamVjdC5rZXlzKG9iaik7XG5cbiAgICBpZiAoIWluY2x1ZGVOb25FbnVtZXJhYmxlKSB7XG4gICAgICByZXR1cm4gZW51bWVyYWJsZVByb3BlcnRpZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikuZmlsdGVyKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHByb3AgIT09ICdjb25zdHJ1Y3RvcicgfHxcbiAgICAgICAgZW51bWVyYWJsZVByb3BlcnRpZXMuaW5kZXhPZignY29uc3RydWN0b3InKSA+IC0xXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U3B5YWJsZUZ1bmN0aW9uUHJvcHMob2JqLCBwcm9wZXJ0aWVzVG9DaGVjaykge1xuICAgIHZhciBwcm9wcyA9IFtdLFxuICAgICAgcHJvcDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnRpZXNUb0NoZWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwcm9wID0gcHJvcGVydGllc1RvQ2hlY2tbaV07XG4gICAgICBpZiAoXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApICYmXG4gICAgICAgIGlzU3B5YWJsZVByb3Aob2JqLCBwcm9wKVxuICAgICAgKSB7XG4gICAgICAgIHByb3BzLnB1c2gocHJvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3B5YWJsZVByb3Aob2JqLCBwcm9wKSB7XG4gICAgdmFyIHZhbHVlLCBkZXNjcmlwdG9yO1xuICAgIHRyeSB7XG4gICAgICB2YWx1ZSA9IG9ialtwcm9wXTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHByb3ApO1xuICAgICAgcmV0dXJuIChkZXNjcmlwdG9yLndyaXRhYmxlIHx8IGRlc2NyaXB0b3Iuc2V0KSAmJiBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIFNweVJlZ2lzdHJ5O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5TcHlTdHJhdGVneSA9IGZ1bmN0aW9uKGokKSB7XG4gIC8qKlxuICAgKiBAaW50ZXJmYWNlIFNweVN0cmF0ZWd5XG4gICAqL1xuICBmdW5jdGlvbiBTcHlTdHJhdGVneShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGlkZW50aWZ5aW5nIGluZm9ybWF0aW9uIGZvciB0aGUgc3B5LlxuICAgICAqIEBuYW1lIFNweVN0cmF0ZWd5I2lkZW50aXR5XG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQG1lbWJlclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5pZGVudGl0eSA9IG9wdGlvbnMubmFtZSB8fCAndW5rbm93bic7XG4gICAgdGhpcy5vcmlnaW5hbEZuID0gb3B0aW9ucy5mbiB8fCBmdW5jdGlvbigpIHt9O1xuICAgIHRoaXMuZ2V0U3B5ID0gb3B0aW9ucy5nZXRTcHkgfHwgZnVuY3Rpb24oKSB7fTtcbiAgICB0aGlzLnBsYW4gPSB0aGlzLl9kZWZhdWx0UGxhbiA9IGZ1bmN0aW9uKCkge307XG5cbiAgICB2YXIgayxcbiAgICAgIGNzID0gb3B0aW9ucy5jdXN0b21TdHJhdGVnaWVzIHx8IHt9O1xuICAgIGZvciAoayBpbiBjcykge1xuICAgICAgaWYgKGokLnV0aWwuaGFzKGNzLCBrKSAmJiAhdGhpc1trXSkge1xuICAgICAgICB0aGlzW2tdID0gY3JlYXRlQ3VzdG9tUGxhbihjc1trXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVsbCB0aGUgc3B5IHRvIHJldHVybiBhIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBzcGVjaWZpZWQgdmFsdWUgd2hlbiBpbnZva2VkLlxuICAgICAqIEBuYW1lIFNweVN0cmF0ZWd5I3Jlc29sdmVUb1xuICAgICAqIEBzaW5jZSAzLjUuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybi5cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdmVUbyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBzZWxmLnBsYW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHNlbGYuZ2V0U3B5KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlbGwgdGhlIHNweSB0byByZXR1cm4gYSBwcm9taXNlIHJlamVjdGluZyB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWUgd2hlbiBpbnZva2VkLlxuICAgICAqIEBuYW1lIFNweVN0cmF0ZWd5I3JlamVjdFdpdGhcbiAgICAgKiBAc2luY2UgMy41LjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4uXG4gICAgICovXG4gICAgdGhpcy5yZWplY3RXaXRoID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHNlbGYucGxhbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodmFsdWUpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBzZWxmLmdldFNweSgpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDdXN0b21QbGFuKGZhY3RvcnkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGxhbiA9IGZhY3RvcnkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcblxuICAgICAgaWYgKCFqJC5pc0Z1bmN0aW9uXyhwbGFuKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NweSBzdHJhdGVneSBtdXN0IHJldHVybiBhIGZ1bmN0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGxhbiA9IHBsYW47XG4gICAgICByZXR1cm4gdGhpcy5nZXRTcHkoKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgdGhlIGN1cnJlbnQgc3B5IHN0cmF0ZWd5LlxuICAgKiBAbmFtZSBTcHlTdHJhdGVneSNleGVjXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIFNweVN0cmF0ZWd5LnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY29udGV4dCwgYXJncywgaW52b2tlTmV3KSB7XG4gICAgdmFyIGNvbnRleHRBcmdzID0gW2NvbnRleHRdLmNvbmNhdChcbiAgICAgIGFyZ3MgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKSA6IFtdXG4gICAgKTtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5wbGFuLmJpbmQuYXBwbHkodGhpcy5wbGFuLCBjb250ZXh0QXJncyk7XG5cbiAgICByZXR1cm4gaW52b2tlTmV3ID8gbmV3IHRhcmdldCgpIDogdGFyZ2V0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRlbGwgdGhlIHNweSB0byBjYWxsIHRocm91Z2ggdG8gdGhlIHJlYWwgaW1wbGVtZW50YXRpb24gd2hlbiBpbnZva2VkLlxuICAgKiBAbmFtZSBTcHlTdHJhdGVneSNjYWxsVGhyb3VnaFxuICAgKiBAc2luY2UgMi4wLjBcbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBTcHlTdHJhdGVneS5wcm90b3R5cGUuY2FsbFRocm91Z2ggPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnBsYW4gPSB0aGlzLm9yaWdpbmFsRm47XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3B5KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRlbGwgdGhlIHNweSB0byByZXR1cm4gdGhlIHZhbHVlIHdoZW4gaW52b2tlZC5cbiAgICogQG5hbWUgU3B5U3RyYXRlZ3kjcmV0dXJuVmFsdWVcbiAgICogQHNpbmNlIDIuMC4wXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4uXG4gICAqL1xuICBTcHlTdHJhdGVneS5wcm90b3R5cGUucmV0dXJuVmFsdWUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHRoaXMucGxhbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3B5KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRlbGwgdGhlIHNweSB0byByZXR1cm4gb25lIG9mIHRoZSBzcGVjaWZpZWQgdmFsdWVzIChzZXF1ZW50aWFsbHkpIGVhY2ggdGltZSB0aGUgc3B5IGlzIGludm9rZWQuXG4gICAqIEBuYW1lIFNweVN0cmF0ZWd5I3JldHVyblZhbHVlc1xuICAgKiBAc2luY2UgMi4xLjBcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Li4uKn0gdmFsdWVzIC0gVmFsdWVzIHRvIGJlIHJldHVybmVkIG9uIHN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHNweS5cbiAgICovXG4gIFNweVN0cmF0ZWd5LnByb3RvdHlwZS5yZXR1cm5WYWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB0aGlzLnBsYW4gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB2YWx1ZXMuc2hpZnQoKTtcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmdldFNweSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZWxsIHRoZSBzcHkgdG8gdGhyb3cgYW4gZXJyb3Igd2hlbiBpbnZva2VkLlxuICAgKiBAbmFtZSBTcHlTdHJhdGVneSN0aHJvd0Vycm9yXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtFcnJvcnxPYmplY3R8U3RyaW5nfSBzb21ldGhpbmcgVGhpbmcgdG8gdGhyb3dcbiAgICovXG4gIFNweVN0cmF0ZWd5LnByb3RvdHlwZS50aHJvd0Vycm9yID0gZnVuY3Rpb24oc29tZXRoaW5nKSB7XG4gICAgdmFyIGVycm9yID0gaiQuaXNTdHJpbmdfKHNvbWV0aGluZykgPyBuZXcgRXJyb3Ioc29tZXRoaW5nKSA6IHNvbWV0aGluZztcbiAgICB0aGlzLnBsYW4gPSBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3B5KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRlbGwgdGhlIHNweSB0byBjYWxsIGEgZmFrZSBpbXBsZW1lbnRhdGlvbiB3aGVuIGludm9rZWQuXG4gICAqIEBuYW1lIFNweVN0cmF0ZWd5I2NhbGxGYWtlXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGludm9rZSB3aXRoIHRoZSBwYXNzZWQgcGFyYW1ldGVycy5cbiAgICovXG4gIFNweVN0cmF0ZWd5LnByb3RvdHlwZS5jYWxsRmFrZSA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgaWYgKFxuICAgICAgIShcbiAgICAgICAgaiQuaXNGdW5jdGlvbl8oZm4pIHx8XG4gICAgICAgIGokLmlzQXN5bmNGdW5jdGlvbl8oZm4pIHx8XG4gICAgICAgIGokLmlzR2VuZXJhdG9yRnVuY3Rpb25fKGZuKVxuICAgICAgKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQXJndW1lbnQgcGFzc2VkIHRvIGNhbGxGYWtlIHNob3VsZCBiZSBhIGZ1bmN0aW9uLCBnb3QgJyArIGZuXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnBsYW4gPSBmbjtcbiAgICByZXR1cm4gdGhpcy5nZXRTcHkoKTtcbiAgfTtcblxuICAvKipcbiAgICogVGVsbCB0aGUgc3B5IHRvIGRvIG5vdGhpbmcgd2hlbiBpbnZva2VkLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlxuICAgKiBAbmFtZSBTcHlTdHJhdGVneSNzdHViXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIFNweVN0cmF0ZWd5LnByb3RvdHlwZS5zdHViID0gZnVuY3Rpb24oZm4pIHtcbiAgICB0aGlzLnBsYW4gPSBmdW5jdGlvbigpIHt9O1xuICAgIHJldHVybiB0aGlzLmdldFNweSgpO1xuICB9O1xuXG4gIFNweVN0cmF0ZWd5LnByb3RvdHlwZS5pc0NvbmZpZ3VyZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wbGFuICE9PSB0aGlzLl9kZWZhdWx0UGxhbjtcbiAgfTtcblxuICByZXR1cm4gU3B5U3RyYXRlZ3k7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlN0YWNrVHJhY2UgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBTdGFja1RyYWNlKGVycm9yKSB7XG4gICAgdmFyIGxpbmVzID0gZXJyb3Iuc3RhY2suc3BsaXQoJ1xcbicpLmZpbHRlcihmdW5jdGlvbihsaW5lKSB7XG4gICAgICByZXR1cm4gbGluZSAhPT0gJyc7XG4gICAgfSk7XG5cbiAgICB2YXIgZXh0cmFjdFJlc3VsdCA9IGV4dHJhY3RNZXNzYWdlKGVycm9yLm1lc3NhZ2UsIGxpbmVzKTtcblxuICAgIGlmIChleHRyYWN0UmVzdWx0KSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBleHRyYWN0UmVzdWx0Lm1lc3NhZ2U7XG4gICAgICBsaW5lcyA9IGV4dHJhY3RSZXN1bHQucmVtYWluZGVyO1xuICAgIH1cblxuICAgIHZhciBwYXJzZVJlc3VsdCA9IHRyeVBhcnNlRnJhbWVzKGxpbmVzKTtcbiAgICB0aGlzLmZyYW1lcyA9IHBhcnNlUmVzdWx0LmZyYW1lcztcbiAgICB0aGlzLnN0eWxlID0gcGFyc2VSZXN1bHQuc3R5bGU7XG4gIH1cblxuICB2YXIgZnJhbWVQYXR0ZXJucyA9IFtcbiAgICAvLyBOb2RlLCBDaHJvbWUsIEVkZ2VcbiAgICAvLyBlLmcuIFwiICAgYXQgUXVldWVSdW5uZXIucnVuIChodHRwOi8vbG9jYWxob3N0Ojg4ODgvX19qYXNtaW5lX18vamFzbWluZS5qczo0MzIwOjIwKVwiXG4gICAgLy8gTm90ZSB0aGF0IHRoZSBcImZ1bmN0aW9uIG5hbWVcIiBjYW4gaW5jbHVkZSBhIHN1cnByaXNpbmdseSBsYXJnZSBzZXQgb2ZcbiAgICAvLyBjaGFyYWN0ZXJzLCBpbmNsdWRpbmcgYW5nbGUgYnJhY2tldHMgYW5kIHNxdWFyZSBicmFja2V0cy5cbiAgICB7XG4gICAgICByZTogL15cXHMqYXQgKFteXFwpXSspIFxcKChbXlxcKV0rKVxcKSQvLFxuICAgICAgZm5JeDogMSxcbiAgICAgIGZpbGVMaW5lQ29sSXg6IDIsXG4gICAgICBzdHlsZTogJ3Y4J1xuICAgIH0sXG5cbiAgICAvLyBOb2RlSlMgYWx0ZXJuYXRlIGZvcm0sIG9mdGVuIG1peGVkIGluIHdpdGggdGhlIENocm9tZSBzdHlsZVxuICAgIC8vIGUuZy4gXCIgIGF0IC9zb21lL3BhdGg6NDMyMDoyMFxuICAgIHsgcmU6IC9cXHMqYXQgKC4rKSQvLCBmaWxlTGluZUNvbEl4OiAxLCBzdHlsZTogJ3Y4JyB9LFxuXG4gICAgLy8gUGhhbnRvbUpTIG9uIE9TIFgsIFNhZmFyaSwgRmlyZWZveFxuICAgIC8vIGUuZy4gXCJydW5AaHR0cDovL2xvY2FsaG9zdDo4ODg4L19famFzbWluZV9fL2phc21pbmUuanM6NDMyMDoyN1wiXG4gICAgLy8gb3IgXCJodHRwOi8vbG9jYWxob3N0Ojg4ODgvX19qYXNtaW5lX18vamFzbWluZS5qczo0MzIwOjI3XCJcbiAgICB7XG4gICAgICByZTogL14oPzooKFteQFxcc10rKUApfEApPyhbXlxcc10rKSQvLFxuICAgICAgZm5JeDogMixcbiAgICAgIGZpbGVMaW5lQ29sSXg6IDMsXG4gICAgICBzdHlsZTogJ3dlYmtpdCdcbiAgICB9XG4gIF07XG5cbiAgLy8gcmVnZXhlcyBzaG91bGQgY2FwdHVyZSB0aGUgZnVuY3Rpb24gbmFtZSAoaWYgYW55KSBhcyBncm91cCAxXG4gIC8vIGFuZCB0aGUgZmlsZSwgbGluZSwgYW5kIGNvbHVtbiBhcyBncm91cCAyLlxuICBmdW5jdGlvbiB0cnlQYXJzZUZyYW1lcyhsaW5lcykge1xuICAgIHZhciBzdHlsZSA9IG51bGw7XG4gICAgdmFyIGZyYW1lcyA9IGxpbmVzLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgY29udmVydGVkTGluZSA9IGZpcnN0KGZyYW1lUGF0dGVybnMsIGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgICAgICAgdmFyIG92ZXJhbGxNYXRjaCA9IGxpbmUubWF0Y2gocGF0dGVybi5yZSksXG4gICAgICAgICAgZmlsZUxpbmVDb2xNYXRjaDtcbiAgICAgICAgaWYgKCFvdmVyYWxsTWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbGVMaW5lQ29sTWF0Y2ggPSBvdmVyYWxsTWF0Y2hbcGF0dGVybi5maWxlTGluZUNvbEl4XS5tYXRjaChcbiAgICAgICAgICAvXiguKik6KFxcZCspOlxcZCskL1xuICAgICAgICApO1xuICAgICAgICBpZiAoIWZpbGVMaW5lQ29sTWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0eWxlID0gc3R5bGUgfHwgcGF0dGVybi5zdHlsZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByYXc6IGxpbmUsXG4gICAgICAgICAgZmlsZTogZmlsZUxpbmVDb2xNYXRjaFsxXSxcbiAgICAgICAgICBsaW5lOiBwYXJzZUludChmaWxlTGluZUNvbE1hdGNoWzJdLCAxMCksXG4gICAgICAgICAgZnVuYzogb3ZlcmFsbE1hdGNoW3BhdHRlcm4uZm5JeF1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gY29udmVydGVkTGluZSB8fCB7IHJhdzogbGluZSB9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgIGZyYW1lczogZnJhbWVzXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcnN0KGl0ZW1zLCBmbikge1xuICAgIHZhciBpLCByZXN1bHQ7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdCA9IGZuKGl0ZW1zW2ldKTtcblxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3RNZXNzYWdlKG1lc3NhZ2UsIHN0YWNrTGluZXMpIHtcbiAgICB2YXIgbGVuID0gbWVzc2FnZVByZWZpeExlbmd0aChtZXNzYWdlLCBzdGFja0xpbmVzKTtcblxuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZXNzYWdlOiBzdGFja0xpbmVzLnNsaWNlKDAsIGxlbikuam9pbignXFxuJyksXG4gICAgICAgIHJlbWFpbmRlcjogc3RhY2tMaW5lcy5zbGljZShsZW4pXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1lc3NhZ2VQcmVmaXhMZW5ndGgobWVzc2FnZSwgc3RhY2tMaW5lcykge1xuICAgIGlmICghc3RhY2tMaW5lc1swXS5tYXRjaCgvXlxcdypFcnJvci8pKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIgbWVzc2FnZUxpbmVzID0gbWVzc2FnZS5zcGxpdCgnXFxuJyk7XG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAxOyBpIDwgbWVzc2FnZUxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobWVzc2FnZUxpbmVzW2ldICE9PSBzdGFja0xpbmVzW2ldKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtZXNzYWdlTGluZXMubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIFN0YWNrVHJhY2U7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlN1aXRlID0gZnVuY3Rpb24oaiQpIHtcbiAgLyoqXG4gICAqIEBpbnRlcmZhY2UgU3VpdGVcbiAgICogQHNlZSBFbnYjdG9wU3VpdGVcbiAgICogQHNpbmNlIDIuMC4wXG4gICAqL1xuICBmdW5jdGlvbiBTdWl0ZShhdHRycykge1xuICAgIHRoaXMuZW52ID0gYXR0cnMuZW52O1xuICAgIC8qKlxuICAgICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhpcyBzdWl0ZS5cbiAgICAgKiBAbmFtZSBTdWl0ZSNpZFxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICovXG4gICAgdGhpcy5pZCA9IGF0dHJzLmlkO1xuICAgIHRoaXMucGFyZW50U3VpdGUgPSBhdHRycy5wYXJlbnRTdWl0ZTtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVzY3JpcHRpb24gcGFzc2VkIHRvIHRoZSB7QGxpbmsgZGVzY3JpYmV9IHRoYXQgY3JlYXRlZCB0aGlzIHN1aXRlLlxuICAgICAqIEBuYW1lIFN1aXRlI2Rlc2NyaXB0aW9uXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKi9cbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gYXR0cnMuZGVzY3JpcHRpb247XG4gICAgdGhpcy5leHBlY3RhdGlvbkZhY3RvcnkgPSBhdHRycy5leHBlY3RhdGlvbkZhY3Rvcnk7XG4gICAgdGhpcy5hc3luY0V4cGVjdGF0aW9uRmFjdG9yeSA9IGF0dHJzLmFzeW5jRXhwZWN0YXRpb25GYWN0b3J5O1xuICAgIHRoaXMuZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5ID0gYXR0cnMuZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5O1xuICAgIHRoaXMudGhyb3dPbkV4cGVjdGF0aW9uRmFpbHVyZSA9ICEhYXR0cnMudGhyb3dPbkV4cGVjdGF0aW9uRmFpbHVyZTtcbiAgICB0aGlzLmF1dG9DbGVhbkNsb3N1cmVzID1cbiAgICAgIGF0dHJzLmF1dG9DbGVhbkNsb3N1cmVzID09PSB1bmRlZmluZWQgPyB0cnVlIDogISFhdHRycy5hdXRvQ2xlYW5DbG9zdXJlcztcbiAgICB0aGlzLm9uTGF0ZUVycm9yID0gYXR0cnMub25MYXRlRXJyb3I7XG5cbiAgICB0aGlzLmJlZm9yZUZucyA9IFtdO1xuICAgIHRoaXMuYWZ0ZXJGbnMgPSBbXTtcbiAgICB0aGlzLmJlZm9yZUFsbEZucyA9IFtdO1xuICAgIHRoaXMuYWZ0ZXJBbGxGbnMgPSBbXTtcbiAgICB0aGlzLnRpbWVyID0gYXR0cnMudGltZXIgfHwgbmV3IGokLlRpbWVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3VpdGUncyBjaGlsZHJlbi5cbiAgICAgKiBAbmFtZSBTdWl0ZSNjaGlsZHJlblxuICAgICAqIEB0eXBlIHtBcnJheS48KFNwZWN8U3VpdGUpPn1cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKi9cbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG5cbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxuICBTdWl0ZS5wcm90b3R5cGUuc2V0U3VpdGVQcm9wZXJ0eSA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLnJlc3VsdC5wcm9wZXJ0aWVzID0gdGhpcy5yZXN1bHQucHJvcGVydGllcyB8fCB7fTtcbiAgICB0aGlzLnJlc3VsdC5wcm9wZXJ0aWVzW2tleV0gPSB2YWx1ZTtcbiAgfTtcblxuICBTdWl0ZS5wcm90b3R5cGUuZXhwZWN0ID0gZnVuY3Rpb24oYWN0dWFsKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhwZWN0YXRpb25GYWN0b3J5KGFjdHVhbCwgdGhpcyk7XG4gIH07XG5cbiAgU3VpdGUucHJvdG90eXBlLmV4cGVjdEFzeW5jID0gZnVuY3Rpb24oYWN0dWFsKSB7XG4gICAgcmV0dXJuIHRoaXMuYXN5bmNFeHBlY3RhdGlvbkZhY3RvcnkoYWN0dWFsLCB0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIGZ1bGwgZGVzY3JpcHRpb24gaW5jbHVkaW5nIGFsbCBhbmNlc3RvcnMgb2YgdGhpcyBzdWl0ZS5cbiAgICogQG5hbWUgU3VpdGUjZ2V0RnVsbE5hbWVcbiAgICogQGZ1bmN0aW9uXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKi9cbiAgU3VpdGUucHJvdG90eXBlLmdldEZ1bGxOYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZ1bGxOYW1lID0gW107XG4gICAgZm9yIChcbiAgICAgIHZhciBwYXJlbnRTdWl0ZSA9IHRoaXM7XG4gICAgICBwYXJlbnRTdWl0ZTtcbiAgICAgIHBhcmVudFN1aXRlID0gcGFyZW50U3VpdGUucGFyZW50U3VpdGVcbiAgICApIHtcbiAgICAgIGlmIChwYXJlbnRTdWl0ZS5wYXJlbnRTdWl0ZSkge1xuICAgICAgICBmdWxsTmFtZS51bnNoaWZ0KHBhcmVudFN1aXRlLmRlc2NyaXB0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZ1bGxOYW1lLmpvaW4oJyAnKTtcbiAgfTtcblxuICAvKlxuICAgKiBNYXJrIHRoZSBzdWl0ZSB3aXRoIFwicGVuZGluZ1wiIHN0YXR1c1xuICAgKi9cbiAgU3VpdGUucHJvdG90eXBlLnBlbmQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1hcmtlZFBlbmRpbmcgPSB0cnVlO1xuICB9O1xuXG4gIC8qXG4gICAqIExpa2Uge0BsaW5rIFN1aXRlI3BlbmR9LCBidXQgcGVuZGluZyBzdGF0ZSB3aWxsIHN1cnZpdmUge0BsaW5rIFNwZWMjcmVzZXR9XG4gICAqIFVzZWZ1bCBmb3IgZmRlc2NyaWJlLCB4ZGVzY3JpYmUsIHdoZXJlIHBlbmRpbmcgc3RhdGUgc2hvdWxkIHJlbWFpbi5cbiAgICovXG4gIFN1aXRlLnByb3RvdHlwZS5leGNsdWRlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5wZW5kKCk7XG4gICAgdGhpcy5tYXJrZWRFeGNsdWRpbmcgPSB0cnVlO1xuICB9O1xuXG4gIFN1aXRlLnByb3RvdHlwZS5iZWZvcmVFYWNoID0gZnVuY3Rpb24oZm4pIHtcbiAgICB0aGlzLmJlZm9yZUZucy51bnNoaWZ0KHsgLi4uZm4sIHN1aXRlOiB0aGlzIH0pO1xuICB9O1xuXG4gIFN1aXRlLnByb3RvdHlwZS5iZWZvcmVBbGwgPSBmdW5jdGlvbihmbikge1xuICAgIHRoaXMuYmVmb3JlQWxsRm5zLnB1c2goeyAuLi5mbiwgdHlwZTogJ2JlZm9yZUFsbCcsIHN1aXRlOiB0aGlzIH0pO1xuICB9O1xuXG4gIFN1aXRlLnByb3RvdHlwZS5hZnRlckVhY2ggPSBmdW5jdGlvbihmbikge1xuICAgIHRoaXMuYWZ0ZXJGbnMudW5zaGlmdCh7IC4uLmZuLCBzdWl0ZTogdGhpcywgdHlwZTogJ2FmdGVyRWFjaCcgfSk7XG4gIH07XG5cbiAgU3VpdGUucHJvdG90eXBlLmFmdGVyQWxsID0gZnVuY3Rpb24oZm4pIHtcbiAgICB0aGlzLmFmdGVyQWxsRm5zLnVuc2hpZnQoeyAuLi5mbiwgdHlwZTogJ2FmdGVyQWxsJyB9KTtcbiAgfTtcblxuICBTdWl0ZS5wcm90b3R5cGUuc3RhcnRUaW1lciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudGltZXIuc3RhcnQoKTtcbiAgfTtcblxuICBTdWl0ZS5wcm90b3R5cGUuZW5kVGltZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlc3VsdC5kdXJhdGlvbiA9IHRoaXMudGltZXIuZWxhcHNlZCgpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlbW92ZUZucyhxdWV1ZWFibGVGbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlYWJsZUZucy5sZW5ndGg7IGkrKykge1xuICAgICAgcXVldWVhYmxlRm5zW2ldLmZuID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBTdWl0ZS5wcm90b3R5cGUuY2xlYW51cEJlZm9yZUFmdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuYXV0b0NsZWFuQ2xvc3VyZXMpIHtcbiAgICAgIHJlbW92ZUZucyh0aGlzLmJlZm9yZUFsbEZucyk7XG4gICAgICByZW1vdmVGbnModGhpcy5hZnRlckFsbEZucyk7XG4gICAgICByZW1vdmVGbnModGhpcy5iZWZvcmVGbnMpO1xuICAgICAgcmVtb3ZlRm5zKHRoaXMuYWZ0ZXJGbnMpO1xuICAgIH1cbiAgfTtcblxuICBTdWl0ZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiBTdWl0ZVJlc3VsdFxuICAgICAqIEBwcm9wZXJ0eSB7SW50fSBpZCAtIFRoZSB1bmlxdWUgaWQgb2YgdGhpcyBzdWl0ZS5cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gZGVzY3JpcHRpb24gLSBUaGUgZGVzY3JpcHRpb24gdGV4dCBwYXNzZWQgdG8gdGhlIHtAbGluayBkZXNjcmliZX0gdGhhdCBtYWRlIHRoaXMgc3VpdGUuXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IGZ1bGxOYW1lIC0gVGhlIGZ1bGwgZGVzY3JpcHRpb24gaW5jbHVkaW5nIGFsbCBhbmNlc3RvcnMgb2YgdGhpcyBzdWl0ZS5cbiAgICAgKiBAcHJvcGVydHkge0V4cGVjdGF0aW9uW119IGZhaWxlZEV4cGVjdGF0aW9ucyAtIFRoZSBsaXN0IG9mIGV4cGVjdGF0aW9ucyB0aGF0IGZhaWxlZCBpbiBhbiB7QGxpbmsgYWZ0ZXJBbGx9IGZvciB0aGlzIHN1aXRlLlxuICAgICAqIEBwcm9wZXJ0eSB7RXhwZWN0YXRpb25bXX0gZGVwcmVjYXRpb25XYXJuaW5ncyAtIFRoZSBsaXN0IG9mIGRlcHJlY2F0aW9uIHdhcm5pbmdzIHRoYXQgb2NjdXJyZWQgb24gdGhpcyBzdWl0ZS5cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gc3RhdHVzIC0gT25jZSB0aGUgc3VpdGUgaGFzIGNvbXBsZXRlZCwgdGhpcyBzdHJpbmcgcmVwcmVzZW50cyB0aGUgcGFzcy9mYWlsIHN0YXR1cyBvZiB0aGlzIHN1aXRlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSB0aW1lIGluIG1zIGZvciBTdWl0ZSBleGVjdXRpb24sIGluY2x1ZGluZyBhbnkgYmVmb3JlL2FmdGVyQWxsLCBiZWZvcmUvYWZ0ZXJFYWNoLlxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gVXNlci1zdXBwbGllZCBwcm9wZXJ0aWVzLCBpZiBhbnksIHRoYXQgd2VyZSBzZXQgdXNpbmcge0BsaW5rIEVudiNzZXRTdWl0ZVByb3BlcnR5fVxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqL1xuICAgIHRoaXMucmVzdWx0ID0ge1xuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgIGZ1bGxOYW1lOiB0aGlzLmdldEZ1bGxOYW1lKCksXG4gICAgICBmYWlsZWRFeHBlY3RhdGlvbnM6IFtdLFxuICAgICAgZGVwcmVjYXRpb25XYXJuaW5nczogW10sXG4gICAgICBkdXJhdGlvbjogbnVsbCxcbiAgICAgIHByb3BlcnRpZXM6IG51bGxcbiAgICB9O1xuICAgIHRoaXMubWFya2VkUGVuZGluZyA9IHRoaXMubWFya2VkRXhjbHVkaW5nO1xuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgY2hpbGQucmVzZXQoKTtcbiAgICB9KTtcbiAgfTtcblxuICBTdWl0ZS5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbihjaGlsZCkge1xuICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gIH07XG5cbiAgU3VpdGUucHJvdG90eXBlLnN0YXR1cyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm1hcmtlZFBlbmRpbmcpIHtcbiAgICAgIHJldHVybiAncGVuZGluZyc7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gJ2ZhaWxlZCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAncGFzc2VkJztcbiAgICB9XG4gIH07XG5cbiAgU3VpdGUucHJvdG90eXBlLmNhbkJlUmVlbnRlcmVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYmVmb3JlQWxsRm5zLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmFmdGVyQWxsRm5zLmxlbmd0aCA9PT0gMDtcbiAgfTtcblxuICBTdWl0ZS5wcm90b3R5cGUuZ2V0UmVzdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZXN1bHQuc3RhdHVzID0gdGhpcy5zdGF0dXMoKTtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQ7XG4gIH07XG5cbiAgU3VpdGUucHJvdG90eXBlLnNoYXJlZFVzZXJDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLnNoYXJlZENvbnRleHQpIHtcbiAgICAgIHRoaXMuc2hhcmVkQ29udGV4dCA9IHRoaXMucGFyZW50U3VpdGVcbiAgICAgICAgPyB0aGlzLnBhcmVudFN1aXRlLmNsb25lZFNoYXJlZFVzZXJDb250ZXh0KClcbiAgICAgICAgOiBuZXcgaiQuVXNlckNvbnRleHQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zaGFyZWRDb250ZXh0O1xuICB9O1xuXG4gIFN1aXRlLnByb3RvdHlwZS5jbG9uZWRTaGFyZWRVc2VyQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBqJC5Vc2VyQ29udGV4dC5mcm9tRXhpc3RpbmcodGhpcy5zaGFyZWRVc2VyQ29udGV4dCgpKTtcbiAgfTtcblxuICBTdWl0ZS5wcm90b3R5cGUub25FeGNlcHRpb24gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgaiQuZXJyb3JzLkV4cGVjdGF0aW9uRmFpbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBtYXRjaGVyTmFtZTogJycsXG4gICAgICBwYXNzZWQ6IGZhbHNlLFxuICAgICAgZXhwZWN0ZWQ6ICcnLFxuICAgICAgYWN0dWFsOiAnJyxcbiAgICAgIGVycm9yOiBhcmd1bWVudHNbMF1cbiAgICB9O1xuICAgIHZhciBmYWlsZWRFeHBlY3RhdGlvbiA9IHRoaXMuZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5KGRhdGEpO1xuXG4gICAgaWYgKCF0aGlzLnBhcmVudFN1aXRlKSB7XG4gICAgICBmYWlsZWRFeHBlY3RhdGlvbi5nbG9iYWxFcnJvclR5cGUgPSAnYWZ0ZXJBbGwnO1xuICAgIH1cblxuICAgIHRoaXMucmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9ucy5wdXNoKGZhaWxlZEV4cGVjdGF0aW9uKTtcbiAgfTtcblxuICBTdWl0ZS5wcm90b3R5cGUub25NdWx0aXBsZURvbmUgPSBmdW5jdGlvbigpIHtcbiAgICBsZXQgbXNnO1xuXG4gICAgLy8gSXNzdWUgYSBkZXByZWNhdGlvbi4gSW5jbHVkZSB0aGUgY29udGV4dCBvdXJzZWx2ZXMgYW5kIHBhc3NcbiAgICAvLyBpZ25vcmVSdW5uYWJsZTogdHJ1ZSwgc2luY2UgZ2V0dGluZyBoZXJlIGFsd2F5cyBtZWFucyB0aGF0IHdlJ3ZlIGFscmVhZHlcbiAgICAvLyBtb3ZlZCBvbiBhbmQgdGhlIGN1cnJlbnQgcnVubmFibGUgaXNuJ3QgdGhlIG9uZSB0aGF0IGNhdXNlZCB0aGUgcHJvYmxlbS5cbiAgICBpZiAodGhpcy5wYXJlbnRTdWl0ZSkge1xuICAgICAgbXNnID1cbiAgICAgICAgXCJBbiBhc3luY2hyb25vdXMgYmVmb3JlQWxsIG9yIGFmdGVyQWxsIGZ1bmN0aW9uIGNhbGxlZCBpdHMgJ2RvbmUnIFwiICtcbiAgICAgICAgJ2NhbGxiYWNrIG1vcmUgdGhhbiBvbmNlLlxcbicgK1xuICAgICAgICAnKGluIHN1aXRlOiAnICtcbiAgICAgICAgdGhpcy5nZXRGdWxsTmFtZSgpICtcbiAgICAgICAgJyknO1xuICAgIH0gZWxzZSB7XG4gICAgICBtc2cgPVxuICAgICAgICAnQSB0b3AtbGV2ZWwgYmVmb3JlQWxsIG9yIGFmdGVyQWxsIGZ1bmN0aW9uIGNhbGxlZCBpdHMgJyArXG4gICAgICAgIFwiJ2RvbmUnIGNhbGxiYWNrIG1vcmUgdGhhbiBvbmNlLlwiO1xuICAgIH1cblxuICAgIHRoaXMub25MYXRlRXJyb3IobmV3IEVycm9yKG1zZykpO1xuICB9O1xuXG4gIFN1aXRlLnByb3RvdHlwZS5hZGRFeHBlY3RhdGlvblJlc3VsdCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChpc0ZhaWx1cmUoYXJndW1lbnRzKSkge1xuICAgICAgdmFyIGRhdGEgPSBhcmd1bWVudHNbMV07XG4gICAgICB0aGlzLnJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMucHVzaCh0aGlzLmV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeShkYXRhKSk7XG4gICAgICBpZiAodGhpcy50aHJvd09uRXhwZWN0YXRpb25GYWlsdXJlKSB7XG4gICAgICAgIHRocm93IG5ldyBqJC5lcnJvcnMuRXhwZWN0YXRpb25GYWlsZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU3VpdGUucHJvdG90eXBlLmFkZERlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uKGRlcHJlY2F0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBkZXByZWNhdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGRlcHJlY2F0aW9uID0geyBtZXNzYWdlOiBkZXByZWNhdGlvbiB9O1xuICAgIH1cbiAgICB0aGlzLnJlc3VsdC5kZXByZWNhdGlvbldhcm5pbmdzLnB1c2goXG4gICAgICB0aGlzLmV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeShkZXByZWNhdGlvbilcbiAgICApO1xuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdWl0ZS5wcm90b3R5cGUsICdtZXRhZGF0YScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLm1ldGFkYXRhXykge1xuICAgICAgICB0aGlzLm1ldGFkYXRhXyA9IG5ldyBTdWl0ZU1ldGFkYXRhKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5tZXRhZGF0YV87XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQGludGVyZmFjZSBTdWl0ZVxuICAgKiBAc2VlIEVudiN0b3BTdWl0ZVxuICAgKi9cbiAgZnVuY3Rpb24gU3VpdGVNZXRhZGF0YShzdWl0ZSkge1xuICAgIHRoaXMuc3VpdGVfID0gc3VpdGU7XG4gICAgLyoqXG4gICAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGlzIHN1aXRlLlxuICAgICAqIEBuYW1lIFN1aXRlI2lkXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmlkID0gc3VpdGUuaWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcGFyZW50IG9mIHRoaXMgc3VpdGUsIG9yIG51bGwgaWYgdGhpcyBpcyB0aGUgdG9wIHN1aXRlLlxuICAgICAqIEBuYW1lIFN1aXRlI3BhcmVudFN1aXRlXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge1N1aXRlfVxuICAgICAqL1xuICAgIHRoaXMucGFyZW50U3VpdGUgPSBzdWl0ZS5wYXJlbnRTdWl0ZSA/IHN1aXRlLnBhcmVudFN1aXRlLm1ldGFkYXRhIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZXNjcmlwdGlvbiBwYXNzZWQgdG8gdGhlIHtAbGluayBkZXNjcmliZX0gdGhhdCBjcmVhdGVkIHRoaXMgc3VpdGUuXG4gICAgICogQG5hbWUgU3VpdGUjZGVzY3JpcHRpb25cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBzdWl0ZS5kZXNjcmlwdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZnVsbCBkZXNjcmlwdGlvbiBpbmNsdWRpbmcgYWxsIGFuY2VzdG9ycyBvZiB0aGlzIHN1aXRlLlxuICAgKiBAbmFtZSBTdWl0ZSNnZXRGdWxsTmFtZVxuICAgKiBAZnVuY3Rpb25cbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIFN1aXRlTWV0YWRhdGEucHJvdG90eXBlLmdldEZ1bGxOYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3VpdGVfLmdldEZ1bGxOYW1lKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBzdWl0ZSdzIGNoaWxkcmVuLlxuICAgKiBAbmFtZSBTdWl0ZSNjaGlsZHJlblxuICAgKiBAdHlwZSB7QXJyYXkuPChTcGVjfFN1aXRlKT59XG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3VpdGVNZXRhZGF0YS5wcm90b3R5cGUsICdjaGlsZHJlbicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3VpdGVfLmNoaWxkcmVuLm1hcChjaGlsZCA9PiBjaGlsZC5tZXRhZGF0YSk7XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiBpc0ZhaWx1cmUoYXJncykge1xuICAgIHJldHVybiAhYXJnc1swXTtcbiAgfVxuXG4gIHJldHVybiBTdWl0ZTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuVGltZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGRlZmF1bHROb3cgPSAoZnVuY3Rpb24oRGF0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9O1xuICB9KShEYXRlKTtcblxuICBmdW5jdGlvbiBUaW1lcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgbm93ID0gb3B0aW9ucy5ub3cgfHwgZGVmYXVsdE5vdyxcbiAgICAgIHN0YXJ0VGltZTtcblxuICAgIHRoaXMuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHN0YXJ0VGltZSA9IG5vdygpO1xuICAgIH07XG5cbiAgICB0aGlzLmVsYXBzZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBub3coKSAtIHN0YXJ0VGltZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIFRpbWVyO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5UcmVlUHJvY2Vzc29yID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFRyZWVQcm9jZXNzb3IoYXR0cnMpIHtcbiAgICB2YXIgdHJlZSA9IGF0dHJzLnRyZWUsXG4gICAgICBydW5uYWJsZUlkcyA9IGF0dHJzLnJ1bm5hYmxlSWRzLFxuICAgICAgcXVldWVSdW5uZXJGYWN0b3J5ID0gYXR0cnMucXVldWVSdW5uZXJGYWN0b3J5LFxuICAgICAgbm9kZVN0YXJ0ID0gYXR0cnMubm9kZVN0YXJ0IHx8IGZ1bmN0aW9uKCkge30sXG4gICAgICBub2RlQ29tcGxldGUgPSBhdHRycy5ub2RlQ29tcGxldGUgfHwgZnVuY3Rpb24oKSB7fSxcbiAgICAgIGZhaWxTcGVjV2l0aE5vRXhwZWN0YXRpb25zID0gISFhdHRycy5mYWlsU3BlY1dpdGhOb0V4cGVjdGF0aW9ucyxcbiAgICAgIG9yZGVyQ2hpbGRyZW4gPVxuICAgICAgICBhdHRycy5vcmRlckNoaWxkcmVuIHx8XG4gICAgICAgIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgfSxcbiAgICAgIGV4Y2x1ZGVOb2RlID1cbiAgICAgICAgYXR0cnMuZXhjbHVkZU5vZGUgfHxcbiAgICAgICAgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgIHN0YXRzID0geyB2YWxpZDogdHJ1ZSB9LFxuICAgICAgcHJvY2Vzc2VkID0gZmFsc2UsXG4gICAgICBkZWZhdWx0TWluID0gSW5maW5pdHksXG4gICAgICBkZWZhdWx0TWF4ID0gMSAtIEluZmluaXR5O1xuXG4gICAgdGhpcy5wcm9jZXNzVHJlZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcHJvY2Vzc05vZGUodHJlZSwgdHJ1ZSk7XG4gICAgICBwcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHN0YXRzO1xuICAgIH07XG5cbiAgICB0aGlzLmV4ZWN1dGUgPSBmdW5jdGlvbihkb25lKSB7XG4gICAgICBpZiAoIXByb2Nlc3NlZCkge1xuICAgICAgICB0aGlzLnByb2Nlc3NUcmVlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghc3RhdHMudmFsaWQpIHtcbiAgICAgICAgdGhyb3cgJ2ludmFsaWQgb3JkZXInO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hpbGRGbnMgPSB3cmFwQ2hpbGRyZW4odHJlZSwgMCk7XG5cbiAgICAgIHF1ZXVlUnVubmVyRmFjdG9yeSh7XG4gICAgICAgIHF1ZXVlYWJsZUZuczogY2hpbGRGbnMsXG4gICAgICAgIHVzZXJDb250ZXh0OiB0cmVlLnNoYXJlZFVzZXJDb250ZXh0KCksXG4gICAgICAgIG9uRXhjZXB0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0cmVlLm9uRXhjZXB0aW9uLmFwcGx5KHRyZWUsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ29tcGxldGU6IGRvbmUsXG4gICAgICAgIG9uTXVsdGlwbGVEb25lOiB0cmVlLm9uTXVsdGlwbGVEb25lXG4gICAgICAgICAgPyB0cmVlLm9uTXVsdGlwbGVEb25lLmJpbmQodHJlZSlcbiAgICAgICAgICA6IG51bGxcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBydW5uYWJsZUluZGV4KGlkKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bm5hYmxlSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChydW5uYWJsZUlkc1tpXSA9PT0gaWQpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NOb2RlKG5vZGUsIHBhcmVudEV4Y2x1ZGVkKSB7XG4gICAgICB2YXIgZXhlY3V0YWJsZUluZGV4ID0gcnVubmFibGVJbmRleChub2RlLmlkKTtcblxuICAgICAgaWYgKGV4ZWN1dGFibGVJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcmVudEV4Y2x1ZGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghbm9kZS5jaGlsZHJlbikge1xuICAgICAgICB2YXIgZXhjbHVkZWQgPSBwYXJlbnRFeGNsdWRlZCB8fCBleGNsdWRlTm9kZShub2RlKTtcbiAgICAgICAgc3RhdHNbbm9kZS5pZF0gPSB7XG4gICAgICAgICAgZXhjbHVkZWQ6IGV4Y2x1ZGVkLFxuICAgICAgICAgIHdpbGxFeGVjdXRlOiAhZXhjbHVkZWQgJiYgIW5vZGUubWFya2VkUGVuZGluZyxcbiAgICAgICAgICBzZWdtZW50czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpbmRleDogMCxcbiAgICAgICAgICAgICAgb3duZXI6IG5vZGUsXG4gICAgICAgICAgICAgIG5vZGVzOiBbbm9kZV0sXG4gICAgICAgICAgICAgIG1pbjogc3RhcnRpbmdNaW4oZXhlY3V0YWJsZUluZGV4KSxcbiAgICAgICAgICAgICAgbWF4OiBzdGFydGluZ01heChleGVjdXRhYmxlSW5kZXgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGhhc0V4ZWN1dGFibGVDaGlsZCA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBvcmRlcmVkQ2hpbGRyZW4gPSBvcmRlckNoaWxkcmVuKG5vZGUpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXJlZENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gb3JkZXJlZENoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgcHJvY2Vzc05vZGUoY2hpbGQsIHBhcmVudEV4Y2x1ZGVkKTtcblxuICAgICAgICAgIGlmICghc3RhdHMudmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY2hpbGRTdGF0cyA9IHN0YXRzW2NoaWxkLmlkXTtcblxuICAgICAgICAgIGhhc0V4ZWN1dGFibGVDaGlsZCA9IGhhc0V4ZWN1dGFibGVDaGlsZCB8fCBjaGlsZFN0YXRzLndpbGxFeGVjdXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdHNbbm9kZS5pZF0gPSB7XG4gICAgICAgICAgZXhjbHVkZWQ6IHBhcmVudEV4Y2x1ZGVkLFxuICAgICAgICAgIHdpbGxFeGVjdXRlOiBoYXNFeGVjdXRhYmxlQ2hpbGRcbiAgICAgICAgfTtcblxuICAgICAgICBzZWdtZW50Q2hpbGRyZW4obm9kZSwgb3JkZXJlZENoaWxkcmVuLCBzdGF0c1tub2RlLmlkXSwgZXhlY3V0YWJsZUluZGV4KTtcblxuICAgICAgICBpZiAoIW5vZGUuY2FuQmVSZWVudGVyZWQoKSAmJiBzdGF0c1tub2RlLmlkXS5zZWdtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgc3RhdHMgPSB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRpbmdNaW4oZXhlY3V0YWJsZUluZGV4KSB7XG4gICAgICByZXR1cm4gZXhlY3V0YWJsZUluZGV4ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0TWluIDogZXhlY3V0YWJsZUluZGV4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0aW5nTWF4KGV4ZWN1dGFibGVJbmRleCkge1xuICAgICAgcmV0dXJuIGV4ZWN1dGFibGVJbmRleCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdE1heCA6IGV4ZWN1dGFibGVJbmRleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZWdtZW50Q2hpbGRyZW4oXG4gICAgICBub2RlLFxuICAgICAgb3JkZXJlZENoaWxkcmVuLFxuICAgICAgbm9kZVN0YXRzLFxuICAgICAgZXhlY3V0YWJsZUluZGV4XG4gICAgKSB7XG4gICAgICB2YXIgY3VycmVudFNlZ21lbnQgPSB7XG4gICAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgICAgb3duZXI6IG5vZGUsXG4gICAgICAgICAgbm9kZXM6IFtdLFxuICAgICAgICAgIG1pbjogc3RhcnRpbmdNaW4oZXhlY3V0YWJsZUluZGV4KSxcbiAgICAgICAgICBtYXg6IHN0YXJ0aW5nTWF4KGV4ZWN1dGFibGVJbmRleClcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdWx0ID0gW2N1cnJlbnRTZWdtZW50XSxcbiAgICAgICAgbGFzdE1heCA9IGRlZmF1bHRNYXgsXG4gICAgICAgIG9yZGVyZWRDaGlsZFNlZ21lbnRzID0gb3JkZXJDaGlsZFNlZ21lbnRzKG9yZGVyZWRDaGlsZHJlbik7XG5cbiAgICAgIGZ1bmN0aW9uIGlzU2VnbWVudEJvdW5kYXJ5KG1pbkluZGV4KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgbGFzdE1heCAhPT0gZGVmYXVsdE1heCAmJlxuICAgICAgICAgIG1pbkluZGV4ICE9PSBkZWZhdWx0TWluICYmXG4gICAgICAgICAgbGFzdE1heCA8IG1pbkluZGV4IC0gMVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyZWRDaGlsZFNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZFNlZ21lbnQgPSBvcmRlcmVkQ2hpbGRTZWdtZW50c1tpXSxcbiAgICAgICAgICBtYXhJbmRleCA9IGNoaWxkU2VnbWVudC5tYXgsXG4gICAgICAgICAgbWluSW5kZXggPSBjaGlsZFNlZ21lbnQubWluO1xuXG4gICAgICAgIGlmIChpc1NlZ21lbnRCb3VuZGFyeShtaW5JbmRleCkpIHtcbiAgICAgICAgICBjdXJyZW50U2VnbWVudCA9IHtcbiAgICAgICAgICAgIGluZGV4OiByZXN1bHQubGVuZ3RoLFxuICAgICAgICAgICAgb3duZXI6IG5vZGUsXG4gICAgICAgICAgICBub2RlczogW10sXG4gICAgICAgICAgICBtaW46IGRlZmF1bHRNaW4sXG4gICAgICAgICAgICBtYXg6IGRlZmF1bHRNYXhcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnRTZWdtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRTZWdtZW50Lm5vZGVzLnB1c2goY2hpbGRTZWdtZW50KTtcbiAgICAgICAgY3VycmVudFNlZ21lbnQubWluID0gTWF0aC5taW4oY3VycmVudFNlZ21lbnQubWluLCBtaW5JbmRleCk7XG4gICAgICAgIGN1cnJlbnRTZWdtZW50Lm1heCA9IE1hdGgubWF4KGN1cnJlbnRTZWdtZW50Lm1heCwgbWF4SW5kZXgpO1xuICAgICAgICBsYXN0TWF4ID0gbWF4SW5kZXg7XG4gICAgICB9XG5cbiAgICAgIG5vZGVTdGF0cy5zZWdtZW50cyA9IHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvcmRlckNoaWxkU2VnbWVudHMoY2hpbGRyZW4pIHtcbiAgICAgIHZhciBzcGVjaWZpZWRPcmRlciA9IFtdLFxuICAgICAgICB1bnNwZWNpZmllZE9yZGVyID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV0sXG4gICAgICAgICAgc2VnbWVudHMgPSBzdGF0c1tjaGlsZC5pZF0uc2VnbWVudHM7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWdtZW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBzZWcgPSBzZWdtZW50c1tqXTtcblxuICAgICAgICAgIGlmIChzZWcubWluID09PSBkZWZhdWx0TWluKSB7XG4gICAgICAgICAgICB1bnNwZWNpZmllZE9yZGVyLnB1c2goc2VnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3BlY2lmaWVkT3JkZXIucHVzaChzZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzcGVjaWZpZWRPcmRlci5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEubWluIC0gYi5taW47XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHNwZWNpZmllZE9yZGVyLmNvbmNhdCh1bnNwZWNpZmllZE9yZGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleGVjdXRlTm9kZShub2RlLCBzZWdtZW50TnVtYmVyKSB7XG4gICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGZuOiBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICB2YXIgb25TdGFydCA9IHtcbiAgICAgICAgICAgICAgZm46IGZ1bmN0aW9uKG5leHQpIHtcbiAgICAgICAgICAgICAgICBub2RlU3RhcnQobm9kZSwgbmV4dCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHF1ZXVlUnVubmVyRmFjdG9yeSh7XG4gICAgICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCBbMF0pO1xuICAgICAgICAgICAgICAgIG5vZGUuY2xlYW51cEJlZm9yZUFmdGVyKCk7XG4gICAgICAgICAgICAgICAgbm9kZUNvbXBsZXRlKG5vZGUsIG5vZGUuZ2V0UmVzdWx0KCksIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgZG9uZS5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBxdWV1ZWFibGVGbnM6IFtvblN0YXJ0XS5jb25jYXQod3JhcENoaWxkcmVuKG5vZGUsIHNlZ21lbnROdW1iZXIpKSxcbiAgICAgICAgICAgICAgdXNlckNvbnRleHQ6IG5vZGUuc2hhcmVkVXNlckNvbnRleHQoKSxcbiAgICAgICAgICAgICAgb25FeGNlcHRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG5vZGUub25FeGNlcHRpb24uYXBwbHkobm9kZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgb25NdWx0aXBsZURvbmU6IG5vZGUub25NdWx0aXBsZURvbmVcbiAgICAgICAgICAgICAgICA/IG5vZGUub25NdWx0aXBsZURvbmUuYmluZChub2RlKVxuICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmbjogZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgbm9kZS5leGVjdXRlKFxuICAgICAgICAgICAgICBkb25lLFxuICAgICAgICAgICAgICBzdGF0c1tub2RlLmlkXS5leGNsdWRlZCxcbiAgICAgICAgICAgICAgZmFpbFNwZWNXaXRoTm9FeHBlY3RhdGlvbnNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdyYXBDaGlsZHJlbihub2RlLCBzZWdtZW50TnVtYmVyKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgIHNlZ21lbnRDaGlsZHJlbiA9IHN0YXRzW25vZGUuaWRdLnNlZ21lbnRzW3NlZ21lbnROdW1iZXJdLm5vZGVzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICBleGVjdXRlTm9kZShzZWdtZW50Q2hpbGRyZW5baV0ub3duZXIsIHNlZ21lbnRDaGlsZHJlbltpXS5pbmRleClcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzdGF0c1tub2RlLmlkXS53aWxsRXhlY3V0ZSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZS5iZWZvcmVBbGxGbnMuY29uY2F0KHJlc3VsdCkuY29uY2F0KG5vZGUuYWZ0ZXJBbGxGbnMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBUcmVlUHJvY2Vzc29yO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5Vc2VyQ29udGV4dCA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIFVzZXJDb250ZXh0KCkge31cblxuICBVc2VyQ29udGV4dC5mcm9tRXhpc3RpbmcgPSBmdW5jdGlvbihvbGRDb250ZXh0KSB7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgVXNlckNvbnRleHQoKTtcblxuICAgIGZvciAodmFyIHByb3AgaW4gb2xkQ29udGV4dCkge1xuICAgICAgaWYgKG9sZENvbnRleHQuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgY29udGV4dFtwcm9wXSA9IG9sZENvbnRleHRbcHJvcF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIFVzZXJDb250ZXh0O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS52ZXJzaW9uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnNC4wLjEnO1xufTtcbiIsImV4cG9ydCBkZWZhdWx0IFwic3RydWN0IFBlcm11dGF0aW9ucyB7XFxuICBQZXJtIDogYXJyYXk8aTMyLCA1MTI+LFxcbn07XFxuXFxuQGJpbmRpbmcoMCkgQGdyb3VwKDApXFxudmFyPHN0b3JhZ2UsIHJlYWQ+IHBlcm0gOiBQZXJtdXRhdGlvbnM7XFxuXFxuc3RydWN0IENvcm5lck1hdGVyaWFscyB7XFxuICBjb3JuZXJNYXRlcmlhbHMgOiBhcnJheTx1MzI+LFxcbn07XFxuXFxuQGJpbmRpbmcoMSkgQGdyb3VwKDApXFxudmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IGNvcm5lck1hdGVyaWFsczogQ29ybmVyTWF0ZXJpYWxzO1xcblxcbnN0cnVjdCBWb3hlbE1hdGVyaWFscyB7XFxuICB2b3hlbE1hdGVyaWFscyA6IGFycmF5PHUzMj4sXFxufTtcXG5cXG5AYmluZGluZygyKSBAZ3JvdXAoMClcXG52YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gdm94ZWxNYXRlcmlhbHM6IFZveGVsTWF0ZXJpYWxzO1xcblxcbnN0cnVjdCBDb3JuZXJJbmRleCB7XFxuICBjb3JuZXJDb3VudCA6IHUzMixcXG4gIGNvcm5lckluZGV4ZXMgOiBhcnJheTx1MzI+XFxufTtcXG5cXG5AYmluZGluZygzKSBAZ3JvdXAoMClcXG52YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gY29ybmVySW5kZXg6IENvcm5lckluZGV4O1xcblxcbnN0cnVjdCBHUFVWT1hcXG57XFxuXFx0dm94TWluOiB2ZWMzPGYzMj4sXFxuXFx0Y29ybmVyczogZjMyLFxcblxcdHZlcnRQb2ludDogdmVjMzxmMzI+LFxcblxcdGF2Z05vcm1hbDogdmVjMzxmMzI+LFxcblxcdG51bVBvaW50czogZjMyXFxufTtcXG5zdHJ1Y3QgR1BVVk9YUyB7XFxuICB2b3hlbHMgOiBhcnJheTxHUFVWT1g+LFxcbn07XFxuXFxuQGJpbmRpbmcoNCkgQGdyb3VwKDApXFxudmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IHZveGVsczogR1BVVk9YUztcXG5cXG5zdHJ1Y3QgVW5pZm9ybUJ1ZmZlck9iamVjdCB7XFxuICBjaHVua1Bvc2l0aW9uIDogdmVjMzxmMzI+LFxcbiAgc3RyaWRlIDogZjMyLFxcblxcdHdpZHRoOiB1MzJcXG59O1xcblxcbkBiaW5kaW5nKDUpIEBncm91cCgwKVxcbnZhcjx1bmlmb3JtPiB1bmlmb3JtcyA6IFVuaWZvcm1CdWZmZXJPYmplY3Q7XFxuXFxubGV0IENISUxEX01JTl9PRkZTRVRTOiBhcnJheTx2ZWMzPHUzMj4sIDg+ID0gYXJyYXk8dmVjMzx1MzI+LCA4PlxcbihcXG4gIHZlYzM8dTMyPigwdSwgMHUsIDB1KSxcXG4gIHZlYzM8dTMyPigwdSwgMHUsIDF1KSxcXG4gIHZlYzM8dTMyPigwdSwgMXUsIDB1KSxcXG4gIHZlYzM8dTMyPigwdSwgMXUsIDF1KSxcXG4gIHZlYzM8dTMyPigxdSwgMHUsIDB1KSxcXG4gIHZlYzM8dTMyPigxdSwgMHUsIDF1KSxcXG4gIHZlYzM8dTMyPigxdSwgMXUsIDB1KSxcXG4gIHZlYzM8dTMyPigxdSwgMXUsIDF1KVxcbik7XFxuXFxubGV0IGVkZ2V2bWFwOiBhcnJheTx2ZWMyPGkzMj4sIDEyPiA9IGFycmF5PHZlYzI8aTMyPiwgMTI+XFxuKFxcblxcdHZlYzI8aTMyPigwLDQpLCB2ZWMyPGkzMj4oMSw1KSwgdmVjMjxpMzI+KDIsNiksIHZlYzI8aTMyPigzLDcpLFxcblxcdHZlYzI8aTMyPigwLDIpLCB2ZWMyPGkzMj4oMSwzKSwgdmVjMjxpMzI+KDQsNiksIHZlYzI8aTMyPig1LDcpLFxcblxcdHZlYzI8aTMyPigwLDEpLCB2ZWMyPGkzMj4oMiwzKSwgdmVjMjxpMzI+KDQsNSksIHZlYzI8aTMyPig2LDcpXFxuKTtcXG5cXG5mbiByYW5kb20oaTogdmVjMjxmMzI+KSAtPiBmMzIge1xcbiAgcmV0dXJuIGZyYWN0KHNpbihkb3QoaSx2ZWMyKDEyLjk4OTgsNzguMjMzKSkpKjQzNzU4LjU0NTMxMjMpO1xcbn1cXG5cXG5mbiBWZWMzRG90KGE6IHZlYzM8ZjMyPiwgYjogdmVjMzxmMzI+KSAtPiBmMzJcXG57XFxuXFx0cmV0dXJuIChhLnggKiBiLngpICsgKGEueSAqIGIueSkgKyAoYS56ICogYi56KTtcXG59XFxuXFxubGV0IEdyYWQzOiBhcnJheTx2ZWMzPGYzMj4sIDEyPiA9IGFycmF5PHZlYzM8ZjMyPiwgMTI+KFxcblxcdHZlYzM8ZjMyPigxLjAsMS4wLDAuMCksIHZlYzM8ZjMyPigtMS4wLDEuMCwwLjApLCB2ZWMzPGYzMj4oMS4wLC0xLjAsMC4wKSwgdmVjMzxmMzI+KC0xLjAsLTEuMCwwLjApLFxcblxcdHZlYzM8ZjMyPigxLjAsMC4wLDEuMCksIHZlYzM8ZjMyPigtMS4wLDAuMCwxLjApLCB2ZWMzPGYzMj4oMS4wLDAuMCwtMS4wKSwgdmVjMzxmMzI+KC0xLjAsMC4wLC0xLjApLFxcblxcdHZlYzM8ZjMyPigwLjAsMS4wLDEuMCksIHZlYzM8ZjMyPigwLjAsLTEuMCwxLjApLCB2ZWMzPGYzMj4oMC4wLDEuMCwtMS4wKSwgdmVjMzxmMzI+KDAuMCwtMS4wLC0xLjApXFxuKTtcXG5cXG5mbiBQZXJsaW4oeDE6IGYzMiwgeTE6IGYzMiwgejE6IGYzMikgLT4gZjMyXFxue1xcblxcdHZhciBYOiBpMzIgPSAwO1xcblxcdGlmICh4MSA+IDAuMCkge1xcblxcdFxcdFggPSBpMzIoeDEpO1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0WCA9IGkzMih4MSkgLSAxO1xcblxcdH1cXG5cXG5cXHR2YXIgWTogaTMyID0gMDtcXG5cXHRpZiAoeTEgPiAwLjApIHtcXG5cXHRcXHRZID0gaTMyKHkxKTtcXG5cXHR9IGVsc2Uge1xcblxcdFxcdFkgPSBpMzIoeTEpIC0gMTtcXG5cXHR9XFxuXFxuXFx0dmFyIFo6IGkzMiA9IDA7XFxuXFx0aWYgKHoxID4gMC4wKSB7XFxuXFx0XFx0WiA9IGkzMih6MSk7XFxuXFx0fSBlbHNlIHtcXG5cXHRcXHRaID0gaTMyKHoxKSAtIDE7XFxuXFx0fVxcblxcdFxcblxcdGxldCB4OiBmMzIgPSB4MSAtIGYzMihYKTtcXG5cXHRsZXQgeTogZjMyID0geTEgLSBmMzIoWSk7XFxuXFx0bGV0IHo6IGYzMiA9IHoxIC0gZjMyKFopO1xcblxcdFxcblxcdFggPSBYICYgMjU1O1xcblxcdFkgPSBZICYgMjU1O1xcblxcdFogPSBaICYgMjU1O1xcblxcdFxcblxcdGxldCBnaTAwMDogaTMyID0gKHBlcm0uUGVybVtYICsgcGVybS5QZXJtW1kgKyBwZXJtLlBlcm1bWl0gXSBdICUgMTIpO1xcblxcdGxldCBnaTAwMTogaTMyID0gKHBlcm0uUGVybVtYICsgcGVybS5QZXJtW1kgKyBwZXJtLlBlcm1bWiArIDFdIF0gXSAlIDEyKTtcXG5cXHRsZXQgZ2kwMTA6IGkzMiA9IChwZXJtLlBlcm1bWCArIHBlcm0uUGVybVtZICsgMSArIHBlcm0uUGVybVtaXSBdIF0gJSAxMik7XFxuXFx0bGV0IGdpMDExOiBpMzIgPSAocGVybS5QZXJtW1ggKyBwZXJtLlBlcm1bWSArIDEgKyBwZXJtLlBlcm1bWiArIDFdIF0gXSAlIDEyKTtcXG5cXHRsZXQgZ2kxMDA6IGkzMiA9IChwZXJtLlBlcm1bWCArIDEgKyBwZXJtLlBlcm1bWSArIHBlcm0uUGVybVtaXSBdIF0gJSAxMik7XFxuXFx0bGV0IGdpMTAxOiBpMzIgPSAocGVybS5QZXJtW1ggKyAxICsgcGVybS5QZXJtW1kgKyBwZXJtLlBlcm1bWiArIDFdIF0gXSAlIDEyKTtcXG5cXHRsZXQgZ2kxMTA6IGkzMiA9IChwZXJtLlBlcm1bWCArIDEgKyBwZXJtLlBlcm1bWSArIDEgKyBwZXJtLlBlcm1bWl0gXSBdICUgMTIpO1xcblxcdGxldCBnaTExMTogaTMyID0gKHBlcm0uUGVybVtYICsgMSArIHBlcm0uUGVybVtZICsgMSArIHBlcm0uUGVybVtaICsgMV0gXSBdICUgMTIpO1xcblxcblxcdGxldCBuMDAwOiBmMzIgPSBkb3QoR3JhZDNbZ2kwMDBdLCB2ZWMzPGYzMj4oeCwgeSwgeikpO1xcblxcdGxldCBuMTAwOiBmMzIgPSBkb3QoR3JhZDNbZ2kxMDBdLCB2ZWMzPGYzMj4oeCAtIDEuMCwgeSwgeikpO1xcblxcdGxldCBuMDEwOiBmMzIgPSBkb3QoR3JhZDNbZ2kwMTBdLCB2ZWMzPGYzMj4oeCwgeSAtIDEuMCwgeikpO1xcblxcdGxldCBuMTEwOiBmMzIgPSBkb3QoR3JhZDNbZ2kxMTBdLCB2ZWMzPGYzMj4oeCAtIDEuMCwgeSAtIDEuMCwgeikpO1xcblxcdGxldCBuMDAxOiBmMzIgPSBkb3QoR3JhZDNbZ2kwMDFdLCB2ZWMzPGYzMj4oeCwgeSwgeiAtIDEuMCkpO1xcblxcdGxldCBuMTAxOiBmMzIgPSBkb3QoR3JhZDNbZ2kxMDFdLCB2ZWMzPGYzMj4oeCAtIDEuMCwgeSwgeiAtIDEuMCkpO1xcblxcdGxldCBuMDExOiBmMzIgPSBkb3QoR3JhZDNbZ2kwMTFdLCB2ZWMzPGYzMj4oeCwgeSAtIDEuMCwgeiAtIDEuMCkpO1xcblxcdGxldCBuMTExOiBmMzIgPSBkb3QoR3JhZDNbZ2kxMTFdLCB2ZWMzPGYzMj4oeCAtIDEuMCwgeSAtIDEuMCwgeiAtIDEuMCkpO1xcblxcdFxcblxcdGxldCB1OiBmMzIgPSBmMzIoeCAqIHggKiB4ICogKHggKiAoeCAqIDYuMCAtIDE1LjApICsgMTAuMCkpO1xcblxcdGxldCB2OiBmMzIgPSBmMzIoeSAqIHkgKiB5ICogKHkgKiAoeSAqIDYuMCAtIDE1LjApICsgMTAuMCkpO1xcblxcdGxldCB3OiBmMzIgPSBmMzIoeiAqIHogKiB6ICogKHogKiAoeiAqIDYuMCAtIDE1LjApICsgMTAuMCkpO1xcblxcdGxldCBueDAwOiBmMzIgPSBtaXgobjAwMCwgbjEwMCwgdSk7XFxuXFx0bGV0IG54MDE6IGYzMiA9IG1peChuMDAxLCBuMTAxLCB1KTtcXG5cXHRsZXQgbngxMDogZjMyID0gbWl4KG4wMTAsIG4xMTAsIHUpO1xcblxcdGxldCBueDExOiBmMzIgPSBtaXgobjAxMSwgbjExMSwgdSk7XFxuXFx0bGV0IG54eTA6IGYzMiA9IG1peChueDAwLCBueDEwLCB2KTtcXG5cXHRsZXQgbnh5MTogZjMyID0gbWl4KG54MDEsIG54MTEsIHYpO1xcblxcdGxldCBueHl6OiBmMzIgPSBtaXgobnh5MCwgbnh5MSwgdyk7XFxuXFx0XFxuXFx0cmV0dXJuIG54eXo7XFxufVxcblxcbmZuIEZyYWN0YWxOb2lzZShvY3RhdmVzOiBpMzIsIGZyZXF1ZW5jeTogZjMyLCBsYWN1bmFyaXR5OiBmMzIsIHBlcnNpc3RlbmNlOiBmMzIsIHBvc2l0aW9uOiB2ZWMzPGYzMj4pIC0+IGYzMlxcbntcXG5cXHRsZXQgU0NBTEU6IGYzMiA9IDEuMCAvIDEyOC4wO1xcblxcdHZhciBwOiB2ZWMzPGYzMj4gPSBwb3NpdGlvbiAqIFNDQUxFO1xcblxcdHZhciBub2lzOiBmMzIgPSAwLjA7XFxuXFxuXFx0dmFyIGFtcGxpdHVkZTogZjMyID0gMS4wO1xcblxcdHAgPSBwICogZnJlcXVlbmN5O1xcblxcblxcdHZhciBpOiBpMzIgPSAwO1xcblxcdGxvb3Age1xcblxcdFxcdGlmIChpID49IG9jdGF2ZXMpIHsgYnJlYWs7IH1cXG5cXG5cXHRcXHRub2lzID0gbm9pcyArIFBlcmxpbihwLngsIHAueSwgcC56KSAqIGFtcGxpdHVkZTtcXG5cXHRcXHRwID0gcCAqIGxhY3VuYXJpdHk7XFxuXFx0XFx0YW1wbGl0dWRlID0gYW1wbGl0dWRlICogcGVyc2lzdGVuY2U7XFxuXFxuXFx0XFx0Y29udGludWluZyB7XFxuXFx0XFx0XFx0aSA9IGkgKyAxO1xcblxcdFxcdH1cXG5cXHR9XFxuXFx0XFxuXFx0cmV0dXJuIG5vaXM7XFxufVxcblxcbmZuIEZyYWN0YWxOb2lzZTEoZnJlcXVlbmN5OiBmMzIsIGxhY3VuYXJpdHk6IGYzMiwgcGVyc2lzdGVuY2U6IGYzMiwgcG9zaXRpb246IHZlYzM8ZjMyPikgLT4gZjMyXFxue1xcblxcdGxldCBTQ0FMRTogZjMyID0gMS4wIC8gMTI4LjA7XFxuXFx0dmFyIHA6IHZlYzM8ZjMyPiA9IHBvc2l0aW9uICogU0NBTEU7XFxuXFx0dmFyIG5vaXM6IGYzMiA9IDAuMDtcXG5cXG5cXHR2YXIgYW1wbGl0dWRlOiBmMzIgPSAxLjA7XFxuXFx0cCA9IHAgKiBmcmVxdWVuY3k7XFxuXFx0XFxuXFx0bm9pcyA9IG5vaXMgKyBQZXJsaW4ocC54LCBwLnksIHAueikgKiBhbXBsaXR1ZGU7XFxuXFx0cCA9IHAgKiBsYWN1bmFyaXR5O1xcblxcdGFtcGxpdHVkZSA9IGFtcGxpdHVkZSAqIHBlcnNpc3RlbmNlO1xcblxcdFxcblxcdHJldHVybiBub2lzO1xcbn1cXG5cXG5mbiBDYWxjdWxhdGVOb2lzZVZhbHVlKHBvczogdmVjMzxmMzI+LCBzY2FsZTogZjMyKSAtPiBmMzJcXG57XFxuXFx0cmV0dXJuIEZyYWN0YWxOb2lzZSg0LCAwLjUzNDMsIDIuMjMyNCwgMC42ODMyNCwgcG9zICogc2NhbGUpO1xcbn1cXG5cXG5mbiBDTGVycChhOiBmMzIsIGI6IGYzMiwgdDogZjMyKSAtPiBmMzJcXG57XFxuXFx0cmV0dXJuICgxLjAgLSB0KSAqIGEgKyB0ICogYjtcXG59XFxuXFxuLy8gU1ZEXFxuXFxubGV0IFNWRF9OVU1fU1dFRVBTOiBpMzIgPSA0O1xcbmxldCBQU1VFRE9fSU5WRVJTRV9USFJFU0hPTEQ6IGYzMiA9IDAuMDAwMDAwMDE7XFxuXFxuZm4gc3ZkX211bF9tYXRyaXhfdmVjKG06IG1hdDN4MzxmMzI+LCBiOiB2ZWM0PGYzMj4pIC0+IHZlYzQ8ZjMyPlxcbntcXG5cXHR2YXIgYTogbWF0M3gzPGYzMj4gPSBtO1xcblxcdFxcblxcdHJldHVybiB2ZWM0PGYzMj4oXFxuXFx0XFx0ZG90KHZlYzQ8ZjMyPihhWzBdWzBdLCBhWzBdWzFdLCBhWzBdWzJdLCAwLjApLCBiKSxcXG5cXHRcXHRkb3QodmVjNDxmMzI+KGFbMV1bMF0sIGFbMV1bMV0sIGFbMV1bMl0sIDAuMCksIGIpLFxcblxcdFxcdGRvdCh2ZWM0PGYzMj4oYVsyXVswXSwgYVsyXVsxXSwgYVsyXVsyXSwgMC4wKSwgYiksXFxuXFx0XFx0MC4wXFxuXFx0KTtcXG59XFxuXFxuZm4gZ2l2ZW5zX2NvZWZmc19zeW0oYV9wcDogZjMyLCBhX3BxOiBmMzIsIGFfcXE6IGYzMikgLT4gdmVjMjxmMzI+XFxue1xcblxcdGlmIChhX3BxID09IDAuMCkge1xcblxcdFxcdHJldHVybiB2ZWMyPGYzMj4oMS4wLCAwLjApO1xcblxcdH1cXG5cXHRcXG5cXHRsZXQgdGF1OiBmMzIgPSAoYV9xcSAtIGFfcHApIC8gKDIuMCAqIGFfcHEpO1xcblxcdGxldCBzdHQ6IGYzMiA9IHNxcnQoMS4wICsgdGF1ICogdGF1KTtcXG5cXHR2YXIgdGFuOiBmMzI7XFxuXFx0aWYgKCh0YXUgPj0gMC4wKSkge1xcblxcdFxcdHRhbiA9ICh0YXUgKyBzdHQpO1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0dGFuID0gKHRhdSAtIHN0dCk7XFxuXFx0fVxcblxcdHRhbiA9IDEuMCAvIHRhbjtcXG5cXG5cXHRsZXQgYzogZjMyID0gaW52ZXJzZVNxcnQoMS4wICsgdGFuICogdGFuKTtcXG5cXHRsZXQgczogZjMyID0gdGFuICogYztcXG5cXG5cXHRyZXR1cm4gdmVjMjxmMzI+KGMsIHMpO1xcbn1cXG5cXG5mbiBzdmRfcm90YXRlX3h5KHg6IGYzMiwgeTogZjMyLCBjOiBmMzIsIHM6IGYzMikgLT4gdmVjMjxmMzI+XFxue1xcblxcdHJldHVybiB2ZWMyPGYzMj4oYyAqIHggLSBzICogeSwgcyAqIHggKyBjICogeSk7XFxufVxcblxcbmZuIHN2ZF9yb3RhdGVxX3h5KHg6IGYzMiwgeTogZjMyLCB6OiBmMzIsIGM6IGYzMiwgczogZjMyKSAtPiB2ZWMyPGYzMj5cXG57XFxuXFx0bGV0IGNjOiBmMzIgPSBjICogYztcXG5cXHRsZXQgc3M6IGYzMiA9IHMgKiBzO1xcblxcdGxldCBteDogZjMyID0gMi4wICogYyAqIHMgKiB6O1xcblxcblxcdHJldHVybiB2ZWMyPGYzMj4oXFxuXFx0XFx0Y2MgKiB4IC0gbXggKyBzcyAqIHksXFxuXFx0XFx0c3MgKiB4ICsgbXggKyBjYyAqIHpcXG5cXHQpO1xcbn1cXG5cXG52YXI8cHJpdmF0ZT4gdnRhdjogbWF0M3gzPGYzMj47XFxudmFyPHByaXZhdGU+IHY6IG1hdDN4MzxmMzI+O1xcbnZhcjxwcml2YXRlPiBBVEE6IGFycmF5PGYzMiwgNj47XFxudmFyPHByaXZhdGU+IEF0YjogdmVjNDxmMzI+O1xcbnZhcjxwcml2YXRlPiBwb2ludGFjY3VtOiB2ZWM0PGYzMj47XFxudmFyPHByaXZhdGU+IGJ0YjogZjMyO1xcblxcbmZuIHN2ZF9yb3RhdGUoYTogaTMyLCBiOiBpMzIpXFxue1xcblxcdGlmICh2dGF2W2FdW2JdID09IDAuMCkgeyByZXR1cm47IH1cXG5cXG5cXG5cXHRcXG5cXHRsZXQgY29lZmZzOiB2ZWMyPGYzMj4gPSBnaXZlbnNfY29lZmZzX3N5bSh2dGF2W2FdW2FdLCB2dGF2W2FdW2JdLCB2dGF2W2JdW2JdKTtcXG5cXHRsZXQgYzogZjMyID0gY29lZmZzLng7XFxuXFx0bGV0IHM6IGYzMiA9IGNvZWZmcy55O1xcblxcdFxcblxcdGxldCByb3QxOiB2ZWMyPGYzMj4gPSBzdmRfcm90YXRlcV94eSh2dGF2W2FdW2FdLCB2dGF2W2JdW2JdLCB2dGF2W2FdW2JdLCBjLCBzKTtcXG5cXHR2dGF2W2FdW2FdID0gcm90MS54O1xcblxcdHZ0YXZbYl1bYl0gPSByb3QxLnk7XFxuXFx0XFxuXFx0bGV0IHJvdDI6IHZlYzI8ZjMyPiA9IHN2ZF9yb3RhdGVfeHkodnRhdlswXVszLWJdLCB2dGF2WzEtYV1bMl0sIGMsIHMpO1xcblxcdHZ0YXZbMF1bMy1iXSA9IHJvdDIueDsgXFxuXFx0dnRhdlsxLWFdWzJdID0gcm90Mi55O1xcblxcdFxcblxcdHZ0YXZbYV1bYl0gPSAwLjA7XFxuXFx0XFxuXFx0bGV0IHJvdDM6IHZlYzI8ZjMyPiA9IHN2ZF9yb3RhdGVfeHkodlswXVthXSwgdlswXVtiXSwgYywgcyk7XFxuXFx0dlswXVthXSA9IHJvdDMueDsgdlswXVtiXSA9IHJvdDMueTtcXG5cXHRcXG5cXHRsZXQgcm90NDogdmVjMjxmMzI+ID0gc3ZkX3JvdGF0ZV94eSh2WzFdW2FdLCB2WzFdW2JdLCBjLCBzKTtcXG5cXHR2WzFdW2FdID0gcm90NC54OyB2WzFdW2JdID0gcm90NC55O1xcblxcdFxcblxcdGxldCByb3Q1OiB2ZWMyPGYzMj4gPSBzdmRfcm90YXRlX3h5KHZbMl1bYV0sIHZbMl1bYl0sIGMsIHMpO1xcblxcdHZbMl1bYV0gPSByb3Q1Lng7IHZbMl1bYl0gPSByb3Q1Lnk7XFxufVxcblxcbmZuIHN2ZF9zb2x2ZV9zeW0oYjogYXJyYXk8ZjMyLCA2PikgLT4gdmVjNDxmMzI+XFxue1xcblxcdHZhciBhOiBhcnJheTxmMzIsIDY+ID0gYjtcXG5cXHRcXG5cXHR2dGF2ID0gbWF0M3gzPGYzMj4oIFxcblxcdFxcdHZlYzM8ZjMyPihhWzBdLCBhWzFdLCBhWzJdKSwgXFxuXFx0XFx0dmVjMzxmMzI+KDAuMCwgYVszXSwgYVs0XSksIFxcblxcdFxcdHZlYzM8ZjMyPigwLjAsIDAuMCwgYVs1XSlcXG5cXHQpO1xcblxcblxcdHZhciBpOiBpMzI7XFxuXFx0bG9vcCB7XFxuXFx0XFx0aWYgKGkgPj0gU1ZEX05VTV9TV0VFUFMpIHsgYnJlYWs7IH1cXG5cXG5cXHRcXHRzdmRfcm90YXRlKDAsIDEpO1xcblxcdFxcdHN2ZF9yb3RhdGUoMCwgMik7XFxuXFx0XFx0c3ZkX3JvdGF0ZSgxLCAyKTtcXG5cXG5cXHRcXHRjb250aW51aW5nIHtcXG5cXHRcXHRcXHRpID0gaSArIDE7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHR2YXIgY29weTogbWF0M3gzPGYzMj4gPSB2dGF2O1xcblxcdHJldHVybiB2ZWM0PGYzMj4oY29weVswXVswXSwgY29weVsxXVsxXSwgY29weVsyXVsyXSwgMC4wKTtcXG59XFxuXFxuXFxuZm4gc3ZkX2ludmRldCh4OiBmMzIsIHRvbDogZjMyKSAtPiBmMzJcXG57XFxuXFx0aWYgKGFicyh4KSA8IHRvbCB8fCBhYnMoMS4wIC8geCkgPCB0b2wpIHtcXG5cXHRcXHRyZXR1cm4gMC4wO1xcblxcdH1cXG5cXHRyZXR1cm4gKDEuMCAvIHgpO1xcbn1cXG5cXG5mbiBzdmRfcHNldWRvaW52ZXJzZShzaWdtYTogdmVjNDxmMzI+LCBjOiBtYXQzeDM8ZjMyPikgLT4gbWF0M3gzPGYzMj5cXG57XFxuXFx0bGV0IGQwOiBmMzIgPSBzdmRfaW52ZGV0KHNpZ21hLngsIFBTVUVET19JTlZFUlNFX1RIUkVTSE9MRCk7XFxuXFx0bGV0IGQxOiBmMzIgPSBzdmRfaW52ZGV0KHNpZ21hLnksIFBTVUVET19JTlZFUlNFX1RIUkVTSE9MRCk7XFxuXFx0bGV0IGQyOiBmMzIgPSBzdmRfaW52ZGV0KHNpZ21hLnosIFBTVUVET19JTlZFUlNFX1RIUkVTSE9MRCk7XFxuXFxuXFx0dmFyIGNvcHk6IG1hdDN4MzxmMzI+ID0gYztcXG5cXG5cXHRyZXR1cm4gbWF0M3gzPGYzMj4gKFxcblxcdFxcdHZlYzM8ZjMyPihcXG5cXHRcXHRcXHRjb3B5WzBdWzBdICogZDAgKiBjb3B5WzBdWzBdICsgY29weVswXVsxXSAqIGQxICogY29weVswXVsxXSArIGNvcHlbMF1bMl0gKiBkMiAqIGNvcHlbMF1bMl0sXFxuXFx0XFx0XFx0Y29weVswXVswXSAqIGQwICogY29weVsxXVswXSArIGNvcHlbMF1bMV0gKiBkMSAqIGNvcHlbMV1bMV0gKyBjb3B5WzBdWzJdICogZDIgKiBjb3B5WzFdWzJdLFxcblxcdFxcdFxcdGNvcHlbMF1bMF0gKiBkMCAqIGNvcHlbMl1bMF0gKyBjb3B5WzBdWzFdICogZDEgKiBjb3B5WzJdWzFdICsgY29weVswXVsyXSAqIGQyICogY29weVsyXVsyXVxcblxcdFxcdCksXFxuXFx0XFx0dmVjMzxmMzI+KFxcblxcdFxcdFxcdGNvcHlbMV1bMF0gKiBkMCAqIGNvcHlbMF1bMF0gKyBjb3B5WzFdWzFdICogZDEgKiBjb3B5WzBdWzFdICsgY29weVsxXVsyXSAqIGQyICogY29weVswXVsyXSxcXG5cXHRcXHRcXHRjb3B5WzFdWzBdICogZDAgKiBjb3B5WzFdWzBdICsgY29weVsxXVsxXSAqIGQxICogY29weVsxXVsxXSArIGNvcHlbMV1bMl0gKiBkMiAqIGNvcHlbMV1bMl0sXFxuXFx0XFx0XFx0Y29weVsxXVswXSAqIGQwICogY29weVsyXVswXSArIGNvcHlbMV1bMV0gKiBkMSAqIGNvcHlbMl1bMV0gKyBjb3B5WzFdWzJdICogZDIgKiBjb3B5WzJdWzJdXFxuXFx0XFx0KSxcXG5cXHRcXHR2ZWMzPGYzMj4oXFxuXFx0XFx0XFx0Y29weVsyXVswXSAqIGQwICogY29weVswXVswXSArIGNvcHlbMl1bMV0gKiBkMSAqIGNvcHlbMF1bMV0gKyBjb3B5WzJdWzJdICogZDIgKiBjb3B5WzBdWzJdLFxcblxcdFxcdFxcdGNvcHlbMl1bMF0gKiBkMCAqIGNvcHlbMV1bMF0gKyBjb3B5WzJdWzFdICogZDEgKiBjb3B5WzFdWzFdICsgY29weVsyXVsyXSAqIGQyICogY29weVsxXVsyXSxcXG5cXHRcXHRcXHRjb3B5WzJdWzBdICogZDAgKiBjb3B5WzJdWzBdICsgY29weVsyXVsxXSAqIGQxICogY29weVsyXVsxXSArIGNvcHlbMl1bMl0gKiBkMiAqIGNvcHlbMl1bMl1cXG5cXHRcXHQpLFxcblxcdCk7XFxufVxcblxcbmZuIHN2ZF9zb2x2ZV9BVEFfQXRiKGE6IHZlYzQ8ZjMyPikgLT4gdmVjNDxmMzI+XFxue1xcblxcdHYgPSBtYXQzeDM8ZjMyPih2ZWMzPGYzMj4oMS4wLCAwLjAsIDAuMCksIHZlYzM8ZjMyPigwLjAsIDEuMCwgMC4wKSwgdmVjMzxmMzI+KDAuMCwgMC4wLCAxLjApKTtcXG5cXHRcXG5cXHRsZXQgc2lnbWE6IHZlYzQ8ZjMyPiA9IHN2ZF9zb2x2ZV9zeW0oQVRBKTtcXG5cXHRcXG5cXHRsZXQgVmludjogbWF0M3gzPGYzMj4gPSBzdmRfcHNldWRvaW52ZXJzZShzaWdtYSwgdik7XFxuXFx0cmV0dXJuIHN2ZF9tdWxfbWF0cml4X3ZlYyhWaW52LCBhKTtcXG59XFxuXFxuZm4gc3ZkX3ZtdWxfc3ltKHY6IHZlYzQ8ZjMyPikgLT4gdmVjNDxmMzI+XFxue1xcblxcdGxldCBBX3Jvd194OiB2ZWM0PGYzMj4gPSB2ZWM0PGYzMj4oQVRBWzBdLCBBVEFbMV0sIEFUQVsyXSwgMC4wKTtcXG5cXHRyZXR1cm4gdmVjNDxmMzI+IChcXG5cXHRcXHRkb3QoQV9yb3dfeCwgdiksXFxuXFx0XFx0QVRBWzFdICogdi54ICsgQVRBWzNdICogdi55ICsgQVRBWzRdICogdi56LFxcblxcdFxcdEFUQVsyXSAqIHYueCArIEFUQVs0XSAqIHYueSArIEFUQVs1XSAqIHYueixcXG5cXHRcXHQwLjBcXG5cXHQpO1xcbn1cXG5cXG5cXG4vLyAvLyBRRUZcXG5cXG5mbiBxZWZfYWRkKG46IHZlYzQ8ZjMyPiwgcDogdmVjNDxmMzI+KVxcbntcXG5cXHRBVEFbMF0gPSBBVEFbMF0gKyBuLnggKiBuLng7XFxuXFx0QVRBWzFdID0gQVRBWzFdICsgbi54ICogbi55O1xcblxcdEFUQVsyXSA9IEFUQVsyXSArIG4ueCAqIG4uejtcXG5cXHRBVEFbM10gPSBBVEFbM10gKyBuLnkgKiBuLnk7XFxuXFx0QVRBWzRdID0gQVRBWzRdICsgbi55ICogbi56O1xcblxcdEFUQVs1XSA9IEFUQVs1XSArIG4ueiAqIG4uejtcXG5cXHRcXG5cXHRsZXQgYjogZjMyID0gZG90KHAsIG4pO1xcblxcdEF0Yi54ID0gQXRiLnggK24ueCAqIGI7XFxuXFx0QXRiLnkgPSBBdGIueSArbi55ICogYjtcXG5cXHRBdGIueiA9IEF0Yi56ICtuLnogKiBiO1xcblxcdGJ0YiA9IGJ0YiArIGIgKiBiO1xcblxcdFxcblxcdHBvaW50YWNjdW0ueCA9IHBvaW50YWNjdW0ueCArcC54O1xcblxcdHBvaW50YWNjdW0ueSA9IHBvaW50YWNjdW0ueSArcC55O1xcblxcdHBvaW50YWNjdW0ueiA9IHBvaW50YWNjdW0ueiArcC56O1xcblxcdHBvaW50YWNjdW0udyA9IHBvaW50YWNjdW0udyArMS4wO1xcbn1cXG5cXG5mbiBxZWZfY2FsY19lcnJvcih4OiB2ZWM0PGYzMj4pIC0+IGYzMlxcbntcXG5cXHR2YXIgdG1wOiB2ZWM0PGYzMj4gPSBzdmRfdm11bF9zeW0oeCk7XFxuXFx0dG1wID0gQXRiIC0gdG1wO1xcblxcdFxcblxcdHJldHVybiBkb3QodG1wLCB0bXApO1xcbn1cXG5cXG5mbiBxZWZfc29sdmUoKSAtPiB2ZWM0PGYzMj5cXG57XFxuXFx0bGV0IG1hc3Nwb2ludDogdmVjNDxmMzI+ID0gdmVjNDxmMzI+KHBvaW50YWNjdW0ueCAvIHBvaW50YWNjdW0udywgcG9pbnRhY2N1bS55IC8gcG9pbnRhY2N1bS53LCBwb2ludGFjY3VtLnogLyBwb2ludGFjY3VtLncsIHBvaW50YWNjdW0udyAvIHBvaW50YWNjdW0udyk7XFxuXFx0XFxuXFx0dmFyIEFfbXA6IHZlYzQ8ZjMyPiA9IHN2ZF92bXVsX3N5bShtYXNzcG9pbnQpO1xcblxcdEFfbXAgPSBBdGIgLSBBX21wO1xcblxcdFxcblxcdGxldCB4OiB2ZWM0PGYzMj4gPSBzdmRfc29sdmVfQVRBX0F0YihBX21wKTtcXG5cXHRcXG5cXHRsZXQgZXJyb3I6IGYzMiA9IHFlZl9jYWxjX2Vycm9yKHgpO1xcblxcdGxldCByOiB2ZWM0PGYzMj4gPSB4ICsgbWFzc3BvaW50O1xcblxcdFxcblxcdHJldHVybiB2ZWM0PGYzMj4oci54LCByLnksIHIueiwgZXJyb3IpO1xcbn1cXG5cXG4jaW1wb3J0IGRlbnNpdHlcXG5cXG5mbiBBcHByb3hpbWF0ZVplcm9Dcm9zc2luZ1Bvc2l0aW9uKHAwOiB2ZWMzPGYzMj4sIHAxOiB2ZWMzPGYzMj4pIC0+IHZlYzM8ZjMyPlxcbntcXG5cXHR2YXIgbWluVmFsdWU6IGYzMiA9IDEwMDAwMC4wO1xcblxcdHZhciB0OiBmMzIgPSAwLjA7XFxuXFx0dmFyIGN1cnJlbnRUOiBmMzIgPSAwLjA7XFxuXFx0bGV0IHN0ZXBzOiBmMzIgPSA4LjA7XFxuXFx0bGV0IGluY3JlbWVudDogZjMyID0gMS4wIC8gc3RlcHM7XFxuXFx0bG9vcCB7XFxuXFx0XFx0aWYgKGN1cnJlbnRUID4gMS4wKSB7IGJyZWFrOyB9XFxuXFxuXFx0XFx0bGV0IHA6IHZlYzM8ZjMyPiA9IHAwICsgKChwMSAtIHAwKSAqIGN1cnJlbnRUKTtcXG5cXHRcXHRsZXQgZGVuc2l0eTogZjMyID0gYWJzKGdldERlbnNpdHkocCkpO1xcblxcdFxcdGlmIChkZW5zaXR5IDwgbWluVmFsdWUpXFxuXFx0XFx0e1xcblxcdFxcdFxcdG1pblZhbHVlID0gZGVuc2l0eTtcXG5cXHRcXHRcXHR0ID0gY3VycmVudFQ7XFxuXFx0XFx0fVxcblxcblxcdFxcdGNvbnRpbnVpbmcge1xcblxcdFxcdFxcdGN1cnJlbnRUID0gY3VycmVudFQgKyBpbmNyZW1lbnQ7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRyZXR1cm4gcDAgKyAoKHAxIC0gcDApICogdCk7XFxufVxcblxcbmZuIENhbGN1bGF0ZVN1cmZhY2VOb3JtYWwocDogdmVjMzxmMzI+KSAtPiB2ZWMzPGYzMj5cXG57XFxuXFx0bGV0IEg6IGYzMiA9IHVuaWZvcm1zLnN0cmlkZTsgLy8gVGhpcyBuZWVkcyB0byBzY2FsZSBiYXNlZCBvbiBzb21ldGhpbmcuLi5cXG5cXHRsZXQgZHg6IGYzMiA9IGdldERlbnNpdHkocCArIHZlYzM8ZjMyPihILCAwLjAsIDAuMCkpIC0gZ2V0RGVuc2l0eShwIC0gdmVjMzxmMzI+KEgsIDAuMCwgMC4wKSk7XFxuXFx0bGV0IGR5OiBmMzIgPSBnZXREZW5zaXR5KHAgKyB2ZWMzPGYzMj4oMC4wLCBILCAwLjApKSAtIGdldERlbnNpdHkocCAtIHZlYzM8ZjMyPigwLjAsIEgsIDAuMCkpO1xcblxcdGxldCBkejogZjMyID0gZ2V0RGVuc2l0eShwICsgdmVjMzxmMzI+KDAuMCwgMC4wLCBIKSkgLSBnZXREZW5zaXR5KHAgLSB2ZWMzPGYzMj4oMC4wLCAwLjAsIEgpKTtcXG5cXG5cXHRyZXR1cm4gbm9ybWFsaXplKHZlYzM8ZjMyPihkeCwgZHksIGR6KSk7XFxufVxcblxcbkBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgxMjgpXFxuZm4gbWFpbihAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgR2xvYmFsSW52b2NhdGlvbklEIDogdmVjMzx1MzI+KSB7XFxuXFx0bGV0IHRydWVJbmRleDogdTMyID0gR2xvYmFsSW52b2NhdGlvbklELng7XFxuXFxuXFx0aWYgKHRydWVJbmRleCA8IGNvcm5lckluZGV4LmNvcm5lckNvdW50KVxcblxcdHtcXG5cXHRcXHRsZXQgdXJlczogdTMyID0gMzJ1O1xcblxcblxcdFxcdGxldCBub2RlU2l6ZTogdTMyID0gdTMyKHVuaWZvcm1zLnN0cmlkZSk7XFxuXFxuXFx0XFx0bGV0IHZveGVsSW5kZXg6IHUzMiA9IGNvcm5lckluZGV4LmNvcm5lckluZGV4ZXNbdHJ1ZUluZGV4XTtcXG5cXHRcXHRsZXQgejogdTMyID0gdm94ZWxJbmRleCAvICh1cmVzICogdXJlcyk7XFxuXFx0XFx0bGV0IHk6IHUzMiA9ICh2b3hlbEluZGV4IC0gKHogKiB1cmVzICogdXJlcykpIC8gdXJlcztcXG5cXHRcXHRsZXQgeDogdTMyID0gdm94ZWxJbmRleCAtICh6ICogdXJlcyAqIHVyZXMpIC0gKHkgKiB1cmVzKTtcXG5cXG5cXHRcXHRsZXQgY29ybmVyczogdTMyID0gdm94ZWxNYXRlcmlhbHMudm94ZWxNYXRlcmlhbHNbdm94ZWxJbmRleF07XFxuXFxuXFx0XFx0bGV0IG5vZGVQb3M6IHZlYzM8ZjMyPiA9ICh2ZWMzPGYzMj4oZjMyKHgpLCBmMzIoeSksIGYzMiAoeikpICogdW5pZm9ybXMuc3RyaWRlKSArIHVuaWZvcm1zLmNodW5rUG9zaXRpb247XFxuXFx0XFx0dm94ZWxzLnZveGVsc1t0cnVlSW5kZXhdLnZveE1pbiA9IG5vZGVQb3M7XFxuXFx0XFx0bGV0IE1BWF9DUk9TU0lOR1M6IGkzMiA9IDY7XFxuXFx0XFx0dmFyIGVkZ2VDb3VudDogaTMyID0gMDtcXG5cXG5cXHRcXHRwb2ludGFjY3VtID0gdmVjNDxmMzI+KDAuMCwgMC4wLCAwLjAsIDAuMCk7XFxuXFx0XFx0QVRBID0gYXJyYXk8ZjMyLCA2PigwLjAsIDAuMCwgMC4wLCAwLjAsIDAuMCwgMC4wKTtcXG5cXHRcXHRBdGIgPSB2ZWM0PGYzMj4oMC4wLCAwLjAsIDAuMCwgMC4wKTtcXG5cXHRcXHR2YXIgYXZlcmFnZU5vcm1hbDogdmVjMzxmMzI+ID0gdmVjMzxmMzI+KDAuMCwgMC4wLCAwLjApO1xcblxcdFxcdGJ0YiA9IDAuMDtcXG5cXG5cXHRcXHR2YXIgajogaTMyID0gMDtcXG5cXHRcXHRsb29wIHtcXG5cXHRcXHRcXHRpZiAoIShqIDwgMTIgJiYgZWRnZUNvdW50IDw9IE1BWF9DUk9TU0lOR1MpKSB7XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGxldCBjMTogaTMyID0gZWRnZXZtYXBbal0ueDtcXG5cXHRcXHRcXHRsZXQgYzI6IGkzMiA9IGVkZ2V2bWFwW2pdLnk7XFxuXFxuXFx0XFx0XFx0bGV0IG0xOiB1MzIgPSAoY29ybmVycyA+PiB1MzIoYzEpKSAmIDF1O1xcblxcdFxcdFxcdGxldCBtMjogdTMyID0gKGNvcm5lcnMgPj4gdTMyKGMyKSkgJiAxdTtcXG5cXG5cXHRcXHRcXHRpZiAoISgobTEgPT0gMHUgJiYgbTIgPT0gMHUpIHx8IChtMSA9PSAxdSAmJiBtMiA9PSAxdSkpKVxcblxcdFxcdFxcdHtcXG5cXHRcXHRcXHRcXHRsZXQgcDE6IHZlYzM8ZjMyPiA9IG5vZGVQb3MgKyB2ZWMzPGYzMj4oZjMyKENISUxEX01JTl9PRkZTRVRTW2MxXS54ICogbm9kZVNpemUpLCBmMzIoQ0hJTERfTUlOX09GRlNFVFNbYzFdLnkgKiBub2RlU2l6ZSksIGYzMihDSElMRF9NSU5fT0ZGU0VUU1tjMV0ueiAqIG5vZGVTaXplKSk7XFxuXFx0XFx0XFx0XFx0bGV0IHAyOiB2ZWMzPGYzMj4gPSBub2RlUG9zICsgdmVjMzxmMzI+KGYzMihDSElMRF9NSU5fT0ZGU0VUU1tjMl0ueCAqIG5vZGVTaXplKSwgZjMyKENISUxEX01JTl9PRkZTRVRTW2MyXS55ICogbm9kZVNpemUpLCBmMzIoQ0hJTERfTUlOX09GRlNFVFNbYzJdLnogKiBub2RlU2l6ZSkpO1xcblxcdFxcdFxcdFxcdGxldCBwOiB2ZWMzPGYzMj4gPSBBcHByb3hpbWF0ZVplcm9Dcm9zc2luZ1Bvc2l0aW9uKHAxLCBwMik7XFxuXFx0XFx0XFx0XFx0bGV0IG46IHZlYzM8ZjMyPiA9IENhbGN1bGF0ZVN1cmZhY2VOb3JtYWwocCk7XFxuXFxuXFx0XFx0XFx0XFx0cWVmX2FkZCh2ZWM0PGYzMj4obi54LCBuLnksIG4ueiwgMC4wKSwgdmVjNDxmMzI+KHAueCwgcC55LCBwLnosIDAuMCkpO1xcblxcblxcdFxcdFxcdFxcdGF2ZXJhZ2VOb3JtYWwgPSBhdmVyYWdlTm9ybWFsICsgbjtcXG5cXG5cXHRcXHRcXHRcXHRlZGdlQ291bnQgPSBlZGdlQ291bnQgKyAxO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRjb250aW51aW5nIHtcXG5cXHRcXHRcXHRcXHRqID0gaiArIDE7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXG5cXHRcXHRhdmVyYWdlTm9ybWFsID0gbm9ybWFsaXplKGF2ZXJhZ2VOb3JtYWwgLyB2ZWMzPGYzMj4oZjMyKGVkZ2VDb3VudCksIGYzMihlZGdlQ291bnQpLCBmMzIoZWRnZUNvdW50KSkpO1xcblxcblxcdFxcdGxldCBjb206IHZlYzM8ZjMyPiA9IHZlYzM8ZjMyPihwb2ludGFjY3VtLnggLyBwb2ludGFjY3VtLncsIHBvaW50YWNjdW0ueSAvIHBvaW50YWNjdW0udywgcG9pbnRhY2N1bS56IC8gcG9pbnRhY2N1bS53KTtcXG5cXG5cXHRcXHRsZXQgcmVzdWx0OiB2ZWM0PGYzMj4gPSBxZWZfc29sdmUoKTtcXG5cXHRcXHR2YXIgc29sdmVkX3Bvc2l0aW9uOiB2ZWMzPGYzMj4gPSByZXN1bHQueHl6O1xcblxcdFxcdGxldCBlcnJvcjogZjMyID0gcmVzdWx0Lnc7XFxuXFxuXFxuXFx0XFx0bGV0IE1pbjogdmVjMzxmMzI+ID0gbm9kZVBvcztcXG5cXHRcXHRsZXQgTWF4OiB2ZWMzPGYzMj4gPSBub2RlUG9zICsgdmVjMzxmMzI+KDEuMCwgMS4wLCAxLjApO1xcblxcdFxcdGlmIChzb2x2ZWRfcG9zaXRpb24ueCA8IE1pbi54IHx8IHNvbHZlZF9wb3NpdGlvbi54ID4gTWF4LnggfHxcXG5cXHRcXHRcXHRcXHRzb2x2ZWRfcG9zaXRpb24ueSA8IE1pbi55IHx8IHNvbHZlZF9wb3NpdGlvbi55ID4gTWF4LnkgfHxcXG5cXHRcXHRcXHRcXHRzb2x2ZWRfcG9zaXRpb24ueiA8IE1pbi56IHx8IHNvbHZlZF9wb3NpdGlvbi56ID4gTWF4LnopXFxuXFx0XFx0e1xcblxcdFxcdFxcdHNvbHZlZF9wb3NpdGlvbiA9IGNvbTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dm94ZWxzLnZveGVsc1t0cnVlSW5kZXhdLnZlcnRQb2ludCA9IHNvbHZlZF9wb3NpdGlvbjtcXG5cXHRcXHR2b3hlbHMudm94ZWxzW3RydWVJbmRleF0uYXZnTm9ybWFsID0gYXZlcmFnZU5vcm1hbDtcXG5cXHRcXHR2b3hlbHMudm94ZWxzW3RydWVJbmRleF0ubnVtUG9pbnRzID0gZjMyKGVkZ2VDb3VudCk7XFxuXFx0XFx0dm94ZWxzLnZveGVsc1t0cnVlSW5kZXhdLmNvcm5lcnMgPSBmMzIodm94ZWxNYXRlcmlhbHMudm94ZWxNYXRlcmlhbHNbdm94ZWxJbmRleF0pO1xcblxcdH1cXG59XFxuXFxuQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKDEpXFxuZm4gY29tcHV0ZU1hdGVyaWFscyhAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgR2xvYmFsSW52b2NhdGlvbklEIDogdmVjMzx1MzI+KSB7XFxuXFx0XFx0bGV0IHdpZHRoID0gdW5pZm9ybXMud2lkdGg7XFxuICAgIGxldCBpbmRleDogdTMyID0gR2xvYmFsSW52b2NhdGlvbklELnogKiB3aWR0aCAqIHdpZHRoICsgR2xvYmFsSW52b2NhdGlvbklELnkgKiB3aWR0aCArIEdsb2JhbEludm9jYXRpb25JRC54O1xcbiAgICBsZXQgY29ybmVyUG9zOiB2ZWMzPGYzMj4gPSB2ZWMzPGYzMj4oZjMyKEdsb2JhbEludm9jYXRpb25JRC54KSAqIHVuaWZvcm1zLnN0cmlkZSwgZjMyKEdsb2JhbEludm9jYXRpb25JRC55KSAqIHVuaWZvcm1zLnN0cmlkZSwgZjMyKEdsb2JhbEludm9jYXRpb25JRC56KSAqIHVuaWZvcm1zLnN0cmlkZSk7XFxuXFxuICAgIGxldCBkZW5zaXR5OiBmMzIgPSBnZXREZW5zaXR5KGNvcm5lclBvcyArIHVuaWZvcm1zLmNodW5rUG9zaXRpb24pO1xcblxcblxcdFxcdGlmIChkZW5zaXR5IDwgMC4wKSB7XFxuXFx0XFx0XFx0aWYgKGxlbmd0aChjb3JuZXJQb3MgKyB1bmlmb3Jtcy5jaHVua1Bvc2l0aW9uKSA8IDIwMDAuMCkge1xcbiAgICAgICAgLy9jb3JuZXJNYXRlcmlhbHMuY29ybmVyTWF0ZXJpYWxzW2luZGV4XSA9IHUzMihyYW5kb20odmVjMihmMzIoaW5kZXgpKSkgKiAyNTUuMCkgKyAxO1xcblxcdFxcdFxcdCAgY29ybmVyTWF0ZXJpYWxzLmNvcm5lck1hdGVyaWFsc1tpbmRleF0gPSAyNTZ1O1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuICAgICAgICBjb3JuZXJNYXRlcmlhbHMuY29ybmVyTWF0ZXJpYWxzW2luZGV4XSA9IHUzMihsZW5ndGgoY29ybmVyUG9zKSAvIHVuaWZvcm1zLnN0cmlkZSAqIDI1Ni4wKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRjb3JuZXJNYXRlcmlhbHMuY29ybmVyTWF0ZXJpYWxzW2luZGV4XSA9IDB1O1xcblxcdFxcdH1cXG59XCI7IiwiLy8gQSBsaWJyYXJ5IG9mIHNlZWRhYmxlIFJOR3MgaW1wbGVtZW50ZWQgaW4gSmF2YXNjcmlwdC5cbi8vXG4vLyBVc2FnZTpcbi8vXG4vLyB2YXIgc2VlZHJhbmRvbSA9IHJlcXVpcmUoJ3NlZWRyYW5kb20nKTtcbi8vIHZhciByYW5kb20gPSBzZWVkcmFuZG9tKDEpOyAvLyBvciBhbnkgc2VlZC5cbi8vIHZhciB4ID0gcmFuZG9tKCk7ICAgICAgIC8vIDAgPD0geCA8IDEuICBFdmVyeSBiaXQgaXMgcmFuZG9tLlxuLy8gdmFyIHggPSByYW5kb20ucXVpY2soKTsgLy8gMCA8PSB4IDwgMS4gIDMyIGJpdHMgb2YgcmFuZG9tbmVzcy5cblxuLy8gYWxlYSwgYSA1My1iaXQgbXVsdGlwbHktd2l0aC1jYXJyeSBnZW5lcmF0b3IgYnkgSm9oYW5uZXMgQmFhZ8O4ZS5cbi8vIFBlcmlvZDogfjJeMTE2XG4vLyBSZXBvcnRlZCB0byBwYXNzIGFsbCBCaWdDcnVzaCB0ZXN0cy5cbnZhciBhbGVhID0gcmVxdWlyZSgnLi9saWIvYWxlYScpO1xuXG4vLyB4b3IxMjgsIGEgcHVyZSB4b3Itc2hpZnQgZ2VuZXJhdG9yIGJ5IEdlb3JnZSBNYXJzYWdsaWEuXG4vLyBQZXJpb2Q6IDJeMTI4LTEuXG4vLyBSZXBvcnRlZCB0byBmYWlsOiBNYXRyaXhSYW5rIGFuZCBMaW5lYXJDb21wLlxudmFyIHhvcjEyOCA9IHJlcXVpcmUoJy4vbGliL3hvcjEyOCcpO1xuXG4vLyB4b3J3b3csIEdlb3JnZSBNYXJzYWdsaWEncyAxNjAtYml0IHhvci1zaGlmdCBjb21iaW5lZCBwbHVzIHdleWwuXG4vLyBQZXJpb2Q6IDJeMTkyLTJeMzJcbi8vIFJlcG9ydGVkIHRvIGZhaWw6IENvbGxpc2lvbk92ZXIsIFNpbXBQb2tlciwgYW5kIExpbmVhckNvbXAuXG52YXIgeG9yd293ID0gcmVxdWlyZSgnLi9saWIveG9yd293Jyk7XG5cbi8vIHhvcnNoaWZ0NywgYnkgRnJhbsOnb2lzIFBhbm5ldG9uIGFuZCBQaWVycmUgTCdlY3V5ZXIsIHRha2VzXG4vLyBhIGRpZmZlcmVudCBhcHByb2FjaDogaXQgYWRkcyByb2J1c3RuZXNzIGJ5IGFsbG93aW5nIG1vcmUgc2hpZnRzXG4vLyB0aGFuIE1hcnNhZ2xpYSdzIG9yaWdpbmFsIHRocmVlLiAgSXQgaXMgYSA3LXNoaWZ0IGdlbmVyYXRvclxuLy8gd2l0aCAyNTYgYml0cywgdGhhdCBwYXNzZXMgQmlnQ3J1c2ggd2l0aCBubyBzeXN0bWF0aWMgZmFpbHVyZXMuXG4vLyBQZXJpb2QgMl4yNTYtMS5cbi8vIE5vIHN5c3RlbWF0aWMgQmlnQ3J1c2ggZmFpbHVyZXMgcmVwb3J0ZWQuXG52YXIgeG9yc2hpZnQ3ID0gcmVxdWlyZSgnLi9saWIveG9yc2hpZnQ3Jyk7XG5cbi8vIHhvcjQwOTYsIGJ5IFJpY2hhcmQgQnJlbnQsIGlzIGEgNDA5Ni1iaXQgeG9yLXNoaWZ0IHdpdGggYVxuLy8gdmVyeSBsb25nIHBlcmlvZCB0aGF0IGFsc28gYWRkcyBhIFdleWwgZ2VuZXJhdG9yLiBJdCBhbHNvIHBhc3Nlc1xuLy8gQmlnQ3J1c2ggd2l0aCBubyBzeXN0ZW1hdGljIGZhaWx1cmVzLiAgSXRzIGxvbmcgcGVyaW9kIG1heVxuLy8gYmUgdXNlZnVsIGlmIHlvdSBoYXZlIG1hbnkgZ2VuZXJhdG9ycyBhbmQgbmVlZCB0byBhdm9pZFxuLy8gY29sbGlzaW9ucy5cbi8vIFBlcmlvZDogMl40MTI4LTJeMzIuXG4vLyBObyBzeXN0ZW1hdGljIEJpZ0NydXNoIGZhaWx1cmVzIHJlcG9ydGVkLlxudmFyIHhvcjQwOTYgPSByZXF1aXJlKCcuL2xpYi94b3I0MDk2Jyk7XG5cbi8vIFR5Y2hlLWksIGJ5IFNhbXVlbCBOZXZlcyBhbmQgRmlsaXBlIEFyYXVqbywgaXMgYSBiaXQtc2hpZnRpbmcgcmFuZG9tXG4vLyBudW1iZXIgZ2VuZXJhdG9yIGRlcml2ZWQgZnJvbSBDaGFDaGEsIGEgbW9kZXJuIHN0cmVhbSBjaXBoZXIuXG4vLyBodHRwczovL2VkZW4uZGVpLnVjLnB0L35zbmV2ZXMvcHVicy8yMDExLXNuZmEyLnBkZlxuLy8gUGVyaW9kOiB+Ml4xMjdcbi8vIE5vIHN5c3RlbWF0aWMgQmlnQ3J1c2ggZmFpbHVyZXMgcmVwb3J0ZWQuXG52YXIgdHljaGVpID0gcmVxdWlyZSgnLi9saWIvdHljaGVpJyk7XG5cbi8vIFRoZSBvcmlnaW5hbCBBUkM0LWJhc2VkIHBybmcgaW5jbHVkZWQgaW4gdGhpcyBsaWJyYXJ5LlxuLy8gUGVyaW9kOiB+Ml4xNjAwXG52YXIgc3IgPSByZXF1aXJlKCcuL3NlZWRyYW5kb20nKTtcblxuc3IuYWxlYSA9IGFsZWE7XG5zci54b3IxMjggPSB4b3IxMjg7XG5zci54b3J3b3cgPSB4b3J3b3c7XG5zci54b3JzaGlmdDcgPSB4b3JzaGlmdDc7XG5zci54b3I0MDk2ID0geG9yNDA5NjtcbnNyLnR5Y2hlaSA9IHR5Y2hlaTtcblxubW9kdWxlLmV4cG9ydHMgPSBzcjtcbiIsIi8vIEEgcG9ydCBvZiBhbiBhbGdvcml0aG0gYnkgSm9oYW5uZXMgQmFhZ8O4ZSA8YmFhZ29lQGJhYWdvZS5jb20+LCAyMDEwXG4vLyBodHRwOi8vYmFhZ29lLmNvbS9lbi9SYW5kb21NdXNpbmdzL2phdmFzY3JpcHQvXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbnF1aW5sYW4vYmV0dGVyLXJhbmRvbS1udW1iZXJzLWZvci1qYXZhc2NyaXB0LW1pcnJvclxuLy8gT3JpZ2luYWwgd29yayBpcyB1bmRlciBNSVQgbGljZW5zZSAtXG5cbi8vIENvcHlyaWdodCAoQykgMjAxMCBieSBKb2hhbm5lcyBCYWFnw7hlIDxiYWFnb2VAYmFhZ29lLm9yZz5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5cblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gQWxlYShzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXMsIG1hc2ggPSBNYXNoKCk7XG5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gMjA5MTYzOSAqIG1lLnMwICsgbWUuYyAqIDIuMzI4MzA2NDM2NTM4Njk2M2UtMTA7IC8vIDJeLTMyXG4gICAgbWUuczAgPSBtZS5zMTtcbiAgICBtZS5zMSA9IG1lLnMyO1xuICAgIHJldHVybiBtZS5zMiA9IHQgLSAobWUuYyA9IHQgfCAwKTtcbiAgfTtcblxuICAvLyBBcHBseSB0aGUgc2VlZGluZyBhbGdvcml0aG0gZnJvbSBCYWFnb2UuXG4gIG1lLmMgPSAxO1xuICBtZS5zMCA9IG1hc2goJyAnKTtcbiAgbWUuczEgPSBtYXNoKCcgJyk7XG4gIG1lLnMyID0gbWFzaCgnICcpO1xuICBtZS5zMCAtPSBtYXNoKHNlZWQpO1xuICBpZiAobWUuczAgPCAwKSB7IG1lLnMwICs9IDE7IH1cbiAgbWUuczEgLT0gbWFzaChzZWVkKTtcbiAgaWYgKG1lLnMxIDwgMCkgeyBtZS5zMSArPSAxOyB9XG4gIG1lLnMyIC09IG1hc2goc2VlZCk7XG4gIGlmIChtZS5zMiA8IDApIHsgbWUuczIgKz0gMTsgfVxuICBtYXNoID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuYyA9IGYuYztcbiAgdC5zMCA9IGYuczA7XG4gIHQuczEgPSBmLnMxO1xuICB0LnMyID0gZi5zMjtcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICB2YXIgeGcgPSBuZXcgQWxlYShzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IHhnLm5leHQ7XG4gIHBybmcuaW50MzIgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgKiAweDEwMDAwMDAwMCkgfCAwOyB9XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHBybmcoKSArIChwcm5nKCkgKiAweDIwMDAwMCB8IDApICogMS4xMTAyMjMwMjQ2MjUxNTY1ZS0xNjsgLy8gMl4tNTNcbiAgfTtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmICh0eXBlb2Yoc3RhdGUpID09ICdvYmplY3QnKSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmZ1bmN0aW9uIE1hc2goKSB7XG4gIHZhciBuID0gMHhlZmM4MjQ5ZDtcblxuICB2YXIgbWFzaCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBkYXRhID0gU3RyaW5nKGRhdGEpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgbiArPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgICB2YXIgaCA9IDAuMDI1MTk2MDMyODI0MTY5MzggKiBuO1xuICAgICAgbiA9IGggPj4+IDA7XG4gICAgICBoIC09IG47XG4gICAgICBoICo9IG47XG4gICAgICBuID0gaCA+Pj4gMDtcbiAgICAgIGggLT0gbjtcbiAgICAgIG4gKz0gaCAqIDB4MTAwMDAwMDAwOyAvLyAyXjMyXG4gICAgfVxuICAgIHJldHVybiAobiA+Pj4gMCkgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxuICB9O1xuXG4gIHJldHVybiBtYXNoO1xufVxuXG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMuYWxlYSA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cblxuIiwiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgdGhlIFwiVHljaGUtaVwiIHBybmcgYWxnb3JpdGhtIGJ5XG4vLyBTYW11ZWwgTmV2ZXMgYW5kIEZpbGlwZSBBcmF1am8uXG4vLyBTZWUgaHR0cHM6Ly9lZGVuLmRlaS51Yy5wdC9+c25ldmVzL3B1YnMvMjAxMS1zbmZhMi5wZGZcblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gWG9yR2VuKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcywgc3Ryc2VlZCA9ICcnO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYiA9IG1lLmIsIGMgPSBtZS5jLCBkID0gbWUuZCwgYSA9IG1lLmE7XG4gICAgYiA9IChiIDw8IDI1KSBeIChiID4+PiA3KSBeIGM7XG4gICAgYyA9IChjIC0gZCkgfCAwO1xuICAgIGQgPSAoZCA8PCAyNCkgXiAoZCA+Pj4gOCkgXiBhO1xuICAgIGEgPSAoYSAtIGIpIHwgMDtcbiAgICBtZS5iID0gYiA9IChiIDw8IDIwKSBeIChiID4+PiAxMikgXiBjO1xuICAgIG1lLmMgPSBjID0gKGMgLSBkKSB8IDA7XG4gICAgbWUuZCA9IChkIDw8IDE2KSBeIChjID4+PiAxNikgXiBhO1xuICAgIHJldHVybiBtZS5hID0gKGEgLSBiKSB8IDA7XG4gIH07XG5cbiAgLyogVGhlIGZvbGxvd2luZyBpcyBub24taW52ZXJ0ZWQgdHljaGUsIHdoaWNoIGhhcyBiZXR0ZXIgaW50ZXJuYWxcbiAgICogYml0IGRpZmZ1c2lvbiwgYnV0IHdoaWNoIGlzIGFib3V0IDI1JSBzbG93ZXIgdGhhbiB0eWNoZS1pIGluIEpTLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGEgPSBtZS5hLCBiID0gbWUuYiwgYyA9IG1lLmMsIGQgPSBtZS5kO1xuICAgIGEgPSAobWUuYSArIG1lLmIgfCAwKSA+Pj4gMDtcbiAgICBkID0gbWUuZCBeIGE7IGQgPSBkIDw8IDE2IF4gZCA+Pj4gMTY7XG4gICAgYyA9IG1lLmMgKyBkIHwgMDtcbiAgICBiID0gbWUuYiBeIGM7IGIgPSBiIDw8IDEyIF4gZCA+Pj4gMjA7XG4gICAgbWUuYSA9IGEgPSBhICsgYiB8IDA7XG4gICAgZCA9IGQgXiBhOyBtZS5kID0gZCA9IGQgPDwgOCBeIGQgPj4+IDI0O1xuICAgIG1lLmMgPSBjID0gYyArIGQgfCAwO1xuICAgIGIgPSBiIF4gYztcbiAgICByZXR1cm4gbWUuYiA9IChiIDw8IDcgXiBiID4+PiAyNSk7XG4gIH1cbiAgKi9cblxuICBtZS5hID0gMDtcbiAgbWUuYiA9IDA7XG4gIG1lLmMgPSAyNjU0NDM1NzY5IHwgMDtcbiAgbWUuZCA9IDEzNjcxMzA1NTE7XG5cbiAgaWYgKHNlZWQgPT09IE1hdGguZmxvb3Ioc2VlZCkpIHtcbiAgICAvLyBJbnRlZ2VyIHNlZWQuXG4gICAgbWUuYSA9IChzZWVkIC8gMHgxMDAwMDAwMDApIHwgMDtcbiAgICBtZS5iID0gc2VlZCB8IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RyaW5nIHNlZWQuXG4gICAgc3Ryc2VlZCArPSBzZWVkO1xuICB9XG5cbiAgLy8gTWl4IGluIHN0cmluZyBzZWVkLCB0aGVuIGRpc2NhcmQgYW4gaW5pdGlhbCBiYXRjaCBvZiA2NCB2YWx1ZXMuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgc3Ryc2VlZC5sZW5ndGggKyAyMDsgaysrKSB7XG4gICAgbWUuYiBePSBzdHJzZWVkLmNoYXJDb2RlQXQoaykgfCAwO1xuICAgIG1lLm5leHQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC5hID0gZi5hO1xuICB0LmIgPSBmLmI7XG4gIHQuYyA9IGYuYztcbiAgdC5kID0gZi5kO1xuICByZXR1cm4gdDtcbn07XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICB2YXIgeGcgPSBuZXcgWG9yR2VuKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwOyB9O1xuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvIHtcbiAgICAgIHZhciB0b3AgPSB4Zy5uZXh0KCkgPj4+IDExLFxuICAgICAgICAgIGJvdCA9ICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDAsXG4gICAgICAgICAgcmVzdWx0ID0gKHRvcCArIGJvdCkgLyAoMSA8PCAyMSk7XG4gICAgfSB3aGlsZSAocmVzdWx0ID09PSAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm5nLmludDMyID0geGcubmV4dDtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmICh0eXBlb2Yoc3RhdGUpID09ICdvYmplY3QnKSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMudHljaGVpID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcblxuXG4iLCIvLyBBIEphdmFzY3JpcHQgaW1wbGVtZW50YWlvbiBvZiB0aGUgXCJ4b3IxMjhcIiBwcm5nIGFsZ29yaXRobSBieVxuLy8gR2VvcmdlIE1hcnNhZ2xpYS4gIFNlZSBodHRwOi8vd3d3LmpzdGF0c29mdC5vcmcvdjA4L2kxNC9wYXBlclxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBYb3JHZW4oc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzLCBzdHJzZWVkID0gJyc7XG5cbiAgbWUueCA9IDA7XG4gIG1lLnkgPSAwO1xuICBtZS56ID0gMDtcbiAgbWUudyA9IDA7XG5cbiAgLy8gU2V0IHVwIGdlbmVyYXRvciBmdW5jdGlvbi5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gbWUueCBeIChtZS54IDw8IDExKTtcbiAgICBtZS54ID0gbWUueTtcbiAgICBtZS55ID0gbWUuejtcbiAgICBtZS56ID0gbWUudztcbiAgICByZXR1cm4gbWUudyBePSAobWUudyA+Pj4gMTkpIF4gdCBeICh0ID4+PiA4KTtcbiAgfTtcblxuICBpZiAoc2VlZCA9PT0gKHNlZWQgfCAwKSkge1xuICAgIC8vIEludGVnZXIgc2VlZC5cbiAgICBtZS54ID0gc2VlZDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdHJpbmcgc2VlZC5cbiAgICBzdHJzZWVkICs9IHNlZWQ7XG4gIH1cblxuICAvLyBNaXggaW4gc3RyaW5nIHNlZWQsIHRoZW4gZGlzY2FyZCBhbiBpbml0aWFsIGJhdGNoIG9mIDY0IHZhbHVlcy5cbiAgZm9yICh2YXIgayA9IDA7IGsgPCBzdHJzZWVkLmxlbmd0aCArIDY0OyBrKyspIHtcbiAgICBtZS54IF49IHN0cnNlZWQuY2hhckNvZGVBdChrKSB8IDA7XG4gICAgbWUubmV4dCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LnggPSBmLng7XG4gIHQueSA9IGYueTtcbiAgdC56ID0gZi56O1xuICB0LncgPSBmLnc7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnhvcjEyOCA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cblxuIiwiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgUmljaGFyZCBCcmVudCdzIFhvcmdlbnMgeG9yNDA5NiBhbGdvcml0aG0uXG4vL1xuLy8gVGhpcyBmYXN0IG5vbi1jcnlwdG9ncmFwaGljIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIGlzIGRlc2lnbmVkIGZvclxuLy8gdXNlIGluIE1vbnRlLUNhcmxvIGFsZ29yaXRobXMuIEl0IGNvbWJpbmVzIGEgbG9uZy1wZXJpb2QgeG9yc2hpZnRcbi8vIGdlbmVyYXRvciB3aXRoIGEgV2V5bCBnZW5lcmF0b3IsIGFuZCBpdCBwYXNzZXMgYWxsIGNvbW1vbiBiYXR0ZXJpZXNcbi8vIG9mIHN0YXN0aWNpYWwgdGVzdHMgZm9yIHJhbmRvbW5lc3Mgd2hpbGUgY29uc3VtaW5nIG9ubHkgYSBmZXcgbmFub3NlY29uZHNcbi8vIGZvciBlYWNoIHBybmcgZ2VuZXJhdGVkLiAgRm9yIGJhY2tncm91bmQgb24gdGhlIGdlbmVyYXRvciwgc2VlIEJyZW50J3Ncbi8vIHBhcGVyOiBcIlNvbWUgbG9uZy1wZXJpb2QgcmFuZG9tIG51bWJlciBnZW5lcmF0b3JzIHVzaW5nIHNoaWZ0cyBhbmQgeG9ycy5cIlxuLy8gaHR0cDovL2FyeGl2Lm9yZy9wZGYvMTAwNC4zMTE1djEucGRmXG4vL1xuLy8gVXNhZ2U6XG4vL1xuLy8gdmFyIHhvcjQwOTYgPSByZXF1aXJlKCd4b3I0MDk2Jyk7XG4vLyByYW5kb20gPSB4b3I0MDk2KDEpOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZWQgd2l0aCBpbnQzMiBvciBzdHJpbmcuXG4vLyBhc3NlcnQuZXF1YWwocmFuZG9tKCksIDAuMTUyMDQzNjQ1MDUzODU0Nyk7IC8vICgwLCAxKSByYW5nZSwgNTMgYml0cy5cbi8vIGFzc2VydC5lcXVhbChyYW5kb20uaW50MzIoKSwgMTgwNjUzNDg5Nyk7ICAgLy8gc2lnbmVkIGludDMyLCAzMiBiaXRzLlxuLy9cbi8vIEZvciBub256ZXJvIG51bWVyaWMga2V5cywgdGhpcyBpbXBlbGVtZW50YXRpb24gcHJvdmlkZXMgYSBzZXF1ZW5jZVxuLy8gaWRlbnRpY2FsIHRvIHRoYXQgYnkgQnJlbnQncyB4b3JnZW5zIDMgaW1wbGVtZW50YWlvbiBpbiBDLiAgVGhpc1xuLy8gaW1wbGVtZW50YXRpb24gYWxzbyBwcm92aWRlcyBmb3IgaW5pdGFsaXppbmcgdGhlIGdlbmVyYXRvciB3aXRoXG4vLyBzdHJpbmcgc2VlZHMsIG9yIGZvciBzYXZpbmcgYW5kIHJlc3RvcmluZyB0aGUgc3RhdGUgb2YgdGhlIGdlbmVyYXRvci5cbi8vXG4vLyBPbiBDaHJvbWUsIHRoaXMgcHJuZyBiZW5jaG1hcmtzIGFib3V0IDIuMSB0aW1lcyBzbG93ZXIgdGhhblxuLy8gSmF2YXNjcmlwdCdzIGJ1aWx0LWluIE1hdGgucmFuZG9tKCkuXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXM7XG5cbiAgLy8gU2V0IHVwIGdlbmVyYXRvciBmdW5jdGlvbi5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB3ID0gbWUudyxcbiAgICAgICAgWCA9IG1lLlgsIGkgPSBtZS5pLCB0LCB2O1xuICAgIC8vIFVwZGF0ZSBXZXlsIGdlbmVyYXRvci5cbiAgICBtZS53ID0gdyA9ICh3ICsgMHg2MWM4ODY0NykgfCAwO1xuICAgIC8vIFVwZGF0ZSB4b3IgZ2VuZXJhdG9yLlxuICAgIHYgPSBYWyhpICsgMzQpICYgMTI3XTtcbiAgICB0ID0gWFtpID0gKChpICsgMSkgJiAxMjcpXTtcbiAgICB2IF49IHYgPDwgMTM7XG4gICAgdCBePSB0IDw8IDE3O1xuICAgIHYgXj0gdiA+Pj4gMTU7XG4gICAgdCBePSB0ID4+PiAxMjtcbiAgICAvLyBVcGRhdGUgWG9yIGdlbmVyYXRvciBhcnJheSBzdGF0ZS5cbiAgICB2ID0gWFtpXSA9IHYgXiB0O1xuICAgIG1lLmkgPSBpO1xuICAgIC8vIFJlc3VsdCBpcyB0aGUgY29tYmluYXRpb24uXG4gICAgcmV0dXJuICh2ICsgKHcgXiAodyA+Pj4gMTYpKSkgfCAwO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGluaXQobWUsIHNlZWQpIHtcbiAgICB2YXIgdCwgdiwgaSwgaiwgdywgWCA9IFtdLCBsaW1pdCA9IDEyODtcbiAgICBpZiAoc2VlZCA9PT0gKHNlZWQgfCAwKSkge1xuICAgICAgLy8gTnVtZXJpYyBzZWVkcyBpbml0aWFsaXplIHYsIHdoaWNoIGlzIHVzZWQgdG8gZ2VuZXJhdGVzIFguXG4gICAgICB2ID0gc2VlZDtcbiAgICAgIHNlZWQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdHJpbmcgc2VlZHMgYXJlIG1peGVkIGludG8gdiBhbmQgWCBvbmUgY2hhcmFjdGVyIGF0IGEgdGltZS5cbiAgICAgIHNlZWQgPSBzZWVkICsgJ1xcMCc7XG4gICAgICB2ID0gMDtcbiAgICAgIGxpbWl0ID0gTWF0aC5tYXgobGltaXQsIHNlZWQubGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gSW5pdGlhbGl6ZSBjaXJjdWxhciBhcnJheSBhbmQgd2V5bCB2YWx1ZS5cbiAgICBmb3IgKGkgPSAwLCBqID0gLTMyOyBqIDwgbGltaXQ7ICsraikge1xuICAgICAgLy8gUHV0IHRoZSB1bmljb2RlIGNoYXJhY3RlcnMgaW50byB0aGUgYXJyYXksIGFuZCBzaHVmZmxlIHRoZW0uXG4gICAgICBpZiAoc2VlZCkgdiBePSBzZWVkLmNoYXJDb2RlQXQoKGogKyAzMikgJSBzZWVkLmxlbmd0aCk7XG4gICAgICAvLyBBZnRlciAzMiBzaHVmZmxlcywgdGFrZSB2IGFzIHRoZSBzdGFydGluZyB3IHZhbHVlLlxuICAgICAgaWYgKGogPT09IDApIHcgPSB2O1xuICAgICAgdiBePSB2IDw8IDEwO1xuICAgICAgdiBePSB2ID4+PiAxNTtcbiAgICAgIHYgXj0gdiA8PCA0O1xuICAgICAgdiBePSB2ID4+PiAxMztcbiAgICAgIGlmIChqID49IDApIHtcbiAgICAgICAgdyA9ICh3ICsgMHg2MWM4ODY0NykgfCAwOyAgICAgLy8gV2V5bC5cbiAgICAgICAgdCA9IChYW2ogJiAxMjddIF49ICh2ICsgdykpOyAgLy8gQ29tYmluZSB4b3IgYW5kIHdleWwgdG8gaW5pdCBhcnJheS5cbiAgICAgICAgaSA9ICgwID09IHQpID8gaSArIDEgOiAwOyAgICAgLy8gQ291bnQgemVyb2VzLlxuICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSBoYXZlIGRldGVjdGVkIGFsbCB6ZXJvZXM7IG1ha2UgdGhlIGtleSBub256ZXJvLlxuICAgIGlmIChpID49IDEyOCkge1xuICAgICAgWFsoc2VlZCAmJiBzZWVkLmxlbmd0aCB8fCAwKSAmIDEyN10gPSAtMTtcbiAgICB9XG4gICAgLy8gUnVuIHRoZSBnZW5lcmF0b3IgNTEyIHRpbWVzIHRvIGZ1cnRoZXIgbWl4IHRoZSBzdGF0ZSBiZWZvcmUgdXNpbmcgaXQuXG4gICAgLy8gRmFjdG9yaW5nIHRoaXMgYXMgYSBmdW5jdGlvbiBzbG93cyB0aGUgbWFpbiBnZW5lcmF0b3IsIHNvIGl0IGlzIGp1c3RcbiAgICAvLyB1bnJvbGxlZCBoZXJlLiAgVGhlIHdleWwgZ2VuZXJhdG9yIGlzIG5vdCBhZHZhbmNlZCB3aGlsZSB3YXJtaW5nIHVwLlxuICAgIGkgPSAxMjc7XG4gICAgZm9yIChqID0gNCAqIDEyODsgaiA+IDA7IC0taikge1xuICAgICAgdiA9IFhbKGkgKyAzNCkgJiAxMjddO1xuICAgICAgdCA9IFhbaSA9ICgoaSArIDEpICYgMTI3KV07XG4gICAgICB2IF49IHYgPDwgMTM7XG4gICAgICB0IF49IHQgPDwgMTc7XG4gICAgICB2IF49IHYgPj4+IDE1O1xuICAgICAgdCBePSB0ID4+PiAxMjtcbiAgICAgIFhbaV0gPSB2IF4gdDtcbiAgICB9XG4gICAgLy8gU3RvcmluZyBzdGF0ZSBhcyBvYmplY3QgbWVtYmVycyBpcyBmYXN0ZXIgdGhhbiB1c2luZyBjbG9zdXJlIHZhcmlhYmxlcy5cbiAgICBtZS53ID0gdztcbiAgICBtZS5YID0gWDtcbiAgICBtZS5pID0gaTtcbiAgfVxuXG4gIGluaXQobWUsIHNlZWQpO1xufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC5pID0gZi5pO1xuICB0LncgPSBmLnc7XG4gIHQuWCA9IGYuWC5zbGljZSgpO1xuICByZXR1cm4gdDtcbn07XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICBpZiAoc2VlZCA9PSBudWxsKSBzZWVkID0gKyhuZXcgRGF0ZSk7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLlgpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy54b3I0MDk2ID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbmRvdyBvYmplY3Qgb3IgZ2xvYmFsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcbiIsIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIHRoZSBcInhvcnNoaWZ0N1wiIGFsZ29yaXRobSBieVxuLy8gRnJhbsOnb2lzIFBhbm5ldG9uIGFuZCBQaWVycmUgTCdlY3V5ZXI6XG4vLyBcIk9uIHRoZSBYb3Jnc2hpZnQgUmFuZG9tIE51bWJlciBHZW5lcmF0b3JzXCJcbi8vIGh0dHA6Ly9zYWx1Yy5lbmdyLnVjb25uLmVkdS9yZWZzL2NyeXB0by9ybmcvcGFubmV0b24wNW9udGhleG9yc2hpZnQucGRmXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXM7XG5cbiAgLy8gU2V0IHVwIGdlbmVyYXRvciBmdW5jdGlvbi5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFVwZGF0ZSB4b3IgZ2VuZXJhdG9yLlxuICAgIHZhciBYID0gbWUueCwgaSA9IG1lLmksIHQsIHYsIHc7XG4gICAgdCA9IFhbaV07IHQgXj0gKHQgPj4+IDcpOyB2ID0gdCBeICh0IDw8IDI0KTtcbiAgICB0ID0gWFsoaSArIDEpICYgN107IHYgXj0gdCBeICh0ID4+PiAxMCk7XG4gICAgdCA9IFhbKGkgKyAzKSAmIDddOyB2IF49IHQgXiAodCA+Pj4gMyk7XG4gICAgdCA9IFhbKGkgKyA0KSAmIDddOyB2IF49IHQgXiAodCA8PCA3KTtcbiAgICB0ID0gWFsoaSArIDcpICYgN107IHQgPSB0IF4gKHQgPDwgMTMpOyB2IF49IHQgXiAodCA8PCA5KTtcbiAgICBYW2ldID0gdjtcbiAgICBtZS5pID0gKGkgKyAxKSAmIDc7XG4gICAgcmV0dXJuIHY7XG4gIH07XG5cbiAgZnVuY3Rpb24gaW5pdChtZSwgc2VlZCkge1xuICAgIHZhciBqLCB3LCBYID0gW107XG5cbiAgICBpZiAoc2VlZCA9PT0gKHNlZWQgfCAwKSkge1xuICAgICAgLy8gU2VlZCBzdGF0ZSBhcnJheSB1c2luZyBhIDMyLWJpdCBpbnRlZ2VyLlxuICAgICAgdyA9IFhbMF0gPSBzZWVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZWVkIHN0YXRlIHVzaW5nIGEgc3RyaW5nLlxuICAgICAgc2VlZCA9ICcnICsgc2VlZDtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBzZWVkLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIFhbaiAmIDddID0gKFhbaiAmIDddIDw8IDE1KSBeXG4gICAgICAgICAgICAoc2VlZC5jaGFyQ29kZUF0KGopICsgWFsoaiArIDEpICYgN10gPDwgMTMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBFbmZvcmNlIGFuIGFycmF5IGxlbmd0aCBvZiA4LCBub3QgYWxsIHplcm9lcy5cbiAgICB3aGlsZSAoWC5sZW5ndGggPCA4KSBYLnB1c2goMCk7XG4gICAgZm9yIChqID0gMDsgaiA8IDggJiYgWFtqXSA9PT0gMDsgKytqKTtcbiAgICBpZiAoaiA9PSA4KSB3ID0gWFs3XSA9IC0xOyBlbHNlIHcgPSBYW2pdO1xuXG4gICAgbWUueCA9IFg7XG4gICAgbWUuaSA9IDA7XG5cbiAgICAvLyBEaXNjYXJkIGFuIGluaXRpYWwgMjU2IHZhbHVlcy5cbiAgICBmb3IgKGogPSAyNTY7IGogPiAwOyAtLWopIHtcbiAgICAgIG1lLm5leHQoKTtcbiAgICB9XG4gIH1cblxuICBpbml0KG1lLCBzZWVkKTtcbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQueCA9IGYueC5zbGljZSgpO1xuICB0LmkgPSBmLmk7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgaWYgKHNlZWQgPT0gbnVsbCkgc2VlZCA9ICsobmV3IERhdGUpO1xuICB2YXIgeGcgPSBuZXcgWG9yR2VuKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwOyB9O1xuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvIHtcbiAgICAgIHZhciB0b3AgPSB4Zy5uZXh0KCkgPj4+IDExLFxuICAgICAgICAgIGJvdCA9ICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDAsXG4gICAgICAgICAgcmVzdWx0ID0gKHRvcCArIGJvdCkgLyAoMSA8PCAyMSk7XG4gICAgfSB3aGlsZSAocmVzdWx0ID09PSAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm5nLmludDMyID0geGcubmV4dDtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS54KSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMueG9yc2hpZnQ3ID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcblxuIiwiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgdGhlIFwieG9yd293XCIgcHJuZyBhbGdvcml0aG0gYnlcbi8vIEdlb3JnZSBNYXJzYWdsaWEuICBTZWUgaHR0cDovL3d3dy5qc3RhdHNvZnQub3JnL3YwOC9pMTQvcGFwZXJcblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gWG9yR2VuKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcywgc3Ryc2VlZCA9ICcnO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IChtZS54IF4gKG1lLnggPj4+IDIpKTtcbiAgICBtZS54ID0gbWUueTsgbWUueSA9IG1lLno7IG1lLnogPSBtZS53OyBtZS53ID0gbWUudjtcbiAgICByZXR1cm4gKG1lLmQgPSAobWUuZCArIDM2MjQzNyB8IDApKSArXG4gICAgICAgKG1lLnYgPSAobWUudiBeIChtZS52IDw8IDQpKSBeICh0IF4gKHQgPDwgMSkpKSB8IDA7XG4gIH07XG5cbiAgbWUueCA9IDA7XG4gIG1lLnkgPSAwO1xuICBtZS56ID0gMDtcbiAgbWUudyA9IDA7XG4gIG1lLnYgPSAwO1xuXG4gIGlmIChzZWVkID09PSAoc2VlZCB8IDApKSB7XG4gICAgLy8gSW50ZWdlciBzZWVkLlxuICAgIG1lLnggPSBzZWVkO1xuICB9IGVsc2Uge1xuICAgIC8vIFN0cmluZyBzZWVkLlxuICAgIHN0cnNlZWQgKz0gc2VlZDtcbiAgfVxuXG4gIC8vIE1peCBpbiBzdHJpbmcgc2VlZCwgdGhlbiBkaXNjYXJkIGFuIGluaXRpYWwgYmF0Y2ggb2YgNjQgdmFsdWVzLlxuICBmb3IgKHZhciBrID0gMDsgayA8IHN0cnNlZWQubGVuZ3RoICsgNjQ7IGsrKykge1xuICAgIG1lLnggXj0gc3Ryc2VlZC5jaGFyQ29kZUF0KGspIHwgMDtcbiAgICBpZiAoayA9PSBzdHJzZWVkLmxlbmd0aCkge1xuICAgICAgbWUuZCA9IG1lLnggPDwgMTAgXiBtZS54ID4+PiA0O1xuICAgIH1cbiAgICBtZS5uZXh0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQueCA9IGYueDtcbiAgdC55ID0gZi55O1xuICB0LnogPSBmLno7XG4gIHQudyA9IGYudztcbiAgdC52ID0gZi52O1xuICB0LmQgPSBmLmQ7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnhvcndvdyA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cblxuIiwiLypcbkNvcHlyaWdodCAyMDE5IERhdmlkIEJhdS5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG5hIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcblwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xud2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG5wZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbnRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG5NRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuXG5JTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWVxuQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCxcblRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFXG5TT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIHBvb2wsIG1hdGgpIHtcbi8vXG4vLyBUaGUgZm9sbG93aW5nIGNvbnN0YW50cyBhcmUgcmVsYXRlZCB0byBJRUVFIDc1NCBsaW1pdHMuXG4vL1xuXG52YXIgd2lkdGggPSAyNTYsICAgICAgICAvLyBlYWNoIFJDNCBvdXRwdXQgaXMgMCA8PSB4IDwgMjU2XG4gICAgY2h1bmtzID0gNiwgICAgICAgICAvLyBhdCBsZWFzdCBzaXggUkM0IG91dHB1dHMgZm9yIGVhY2ggZG91YmxlXG4gICAgZGlnaXRzID0gNTIsICAgICAgICAvLyB0aGVyZSBhcmUgNTIgc2lnbmlmaWNhbnQgZGlnaXRzIGluIGEgZG91YmxlXG4gICAgcm5nbmFtZSA9ICdyYW5kb20nLCAvLyBybmduYW1lOiBuYW1lIGZvciBNYXRoLnJhbmRvbSBhbmQgTWF0aC5zZWVkcmFuZG9tXG4gICAgc3RhcnRkZW5vbSA9IG1hdGgucG93KHdpZHRoLCBjaHVua3MpLFxuICAgIHNpZ25pZmljYW5jZSA9IG1hdGgucG93KDIsIGRpZ2l0cyksXG4gICAgb3ZlcmZsb3cgPSBzaWduaWZpY2FuY2UgKiAyLFxuICAgIG1hc2sgPSB3aWR0aCAtIDEsXG4gICAgbm9kZWNyeXB0bzsgICAgICAgICAvLyBub2RlLmpzIGNyeXB0byBtb2R1bGUsIGluaXRpYWxpemVkIGF0IHRoZSBib3R0b20uXG5cbi8vXG4vLyBzZWVkcmFuZG9tKClcbi8vIFRoaXMgaXMgdGhlIHNlZWRyYW5kb20gZnVuY3Rpb24gZGVzY3JpYmVkIGFib3ZlLlxuLy9cbmZ1bmN0aW9uIHNlZWRyYW5kb20oc2VlZCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIGtleSA9IFtdO1xuICBvcHRpb25zID0gKG9wdGlvbnMgPT0gdHJ1ZSkgPyB7IGVudHJvcHk6IHRydWUgfSA6IChvcHRpb25zIHx8IHt9KTtcblxuICAvLyBGbGF0dGVuIHRoZSBzZWVkIHN0cmluZyBvciBidWlsZCBvbmUgZnJvbSBsb2NhbCBlbnRyb3B5IGlmIG5lZWRlZC5cbiAgdmFyIHNob3J0c2VlZCA9IG1peGtleShmbGF0dGVuKFxuICAgIG9wdGlvbnMuZW50cm9weSA/IFtzZWVkLCB0b3N0cmluZyhwb29sKV0gOlxuICAgIChzZWVkID09IG51bGwpID8gYXV0b3NlZWQoKSA6IHNlZWQsIDMpLCBrZXkpO1xuXG4gIC8vIFVzZSB0aGUgc2VlZCB0byBpbml0aWFsaXplIGFuIEFSQzQgZ2VuZXJhdG9yLlxuICB2YXIgYXJjNCA9IG5ldyBBUkM0KGtleSk7XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgcmFuZG9tIGRvdWJsZSBpbiBbMCwgMSkgdGhhdCBjb250YWluc1xuICAvLyByYW5kb21uZXNzIGluIGV2ZXJ5IGJpdCBvZiB0aGUgbWFudGlzc2Egb2YgdGhlIElFRUUgNzU0IHZhbHVlLlxuICB2YXIgcHJuZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuID0gYXJjNC5nKGNodW5rcyksICAgICAgICAgICAgIC8vIFN0YXJ0IHdpdGggYSBudW1lcmF0b3IgbiA8IDIgXiA0OFxuICAgICAgICBkID0gc3RhcnRkZW5vbSwgICAgICAgICAgICAgICAgIC8vICAgYW5kIGRlbm9taW5hdG9yIGQgPSAyIF4gNDguXG4gICAgICAgIHggPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBhbmQgbm8gJ2V4dHJhIGxhc3QgYnl0ZScuXG4gICAgd2hpbGUgKG4gPCBzaWduaWZpY2FuY2UpIHsgICAgICAgICAgLy8gRmlsbCB1cCBhbGwgc2lnbmlmaWNhbnQgZGlnaXRzIGJ5XG4gICAgICBuID0gKG4gKyB4KSAqIHdpZHRoOyAgICAgICAgICAgICAgLy8gICBzaGlmdGluZyBudW1lcmF0b3IgYW5kXG4gICAgICBkICo9IHdpZHRoOyAgICAgICAgICAgICAgICAgICAgICAgLy8gICBkZW5vbWluYXRvciBhbmQgZ2VuZXJhdGluZyBhXG4gICAgICB4ID0gYXJjNC5nKDEpOyAgICAgICAgICAgICAgICAgICAgLy8gICBuZXcgbGVhc3Qtc2lnbmlmaWNhbnQtYnl0ZS5cbiAgICB9XG4gICAgd2hpbGUgKG4gPj0gb3ZlcmZsb3cpIHsgICAgICAgICAgICAgLy8gVG8gYXZvaWQgcm91bmRpbmcgdXAsIGJlZm9yZSBhZGRpbmdcbiAgICAgIG4gLz0gMjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGxhc3QgYnl0ZSwgc2hpZnQgZXZlcnl0aGluZ1xuICAgICAgZCAvPSAyOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgcmlnaHQgdXNpbmcgaW50ZWdlciBtYXRoIHVudGlsXG4gICAgICB4ID4+Pj0gMTsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICB3ZSBoYXZlIGV4YWN0bHkgdGhlIGRlc2lyZWQgYml0cy5cbiAgICB9XG4gICAgcmV0dXJuIChuICsgeCkgLyBkOyAgICAgICAgICAgICAgICAgLy8gRm9ybSB0aGUgbnVtYmVyIHdpdGhpbiBbMCwgMSkuXG4gIH07XG5cbiAgcHJuZy5pbnQzMiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJjNC5nKDQpIHwgMDsgfVxuICBwcm5nLnF1aWNrID0gZnVuY3Rpb24oKSB7IHJldHVybiBhcmM0LmcoNCkgLyAweDEwMDAwMDAwMDsgfVxuICBwcm5nLmRvdWJsZSA9IHBybmc7XG5cbiAgLy8gTWl4IHRoZSByYW5kb21uZXNzIGludG8gYWNjdW11bGF0ZWQgZW50cm9weS5cbiAgbWl4a2V5KHRvc3RyaW5nKGFyYzQuUyksIHBvb2wpO1xuXG4gIC8vIENhbGxpbmcgY29udmVudGlvbjogd2hhdCB0byByZXR1cm4gYXMgYSBmdW5jdGlvbiBvZiBwcm5nLCBzZWVkLCBpc19tYXRoLlxuICByZXR1cm4gKG9wdGlvbnMucGFzcyB8fCBjYWxsYmFjayB8fFxuICAgICAgZnVuY3Rpb24ocHJuZywgc2VlZCwgaXNfbWF0aF9jYWxsLCBzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAvLyBMb2FkIHRoZSBhcmM0IHN0YXRlIGZyb20gdGhlIGdpdmVuIHN0YXRlIGlmIGl0IGhhcyBhbiBTIGFycmF5LlxuICAgICAgICAgIGlmIChzdGF0ZS5TKSB7IGNvcHkoc3RhdGUsIGFyYzQpOyB9XG4gICAgICAgICAgLy8gT25seSBwcm92aWRlIHRoZSAuc3RhdGUgbWV0aG9kIGlmIHJlcXVlc3RlZCB2aWEgb3B0aW9ucy5zdGF0ZS5cbiAgICAgICAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KGFyYzQsIHt9KTsgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgY2FsbGVkIGFzIGEgbWV0aG9kIG9mIE1hdGggKE1hdGguc2VlZHJhbmRvbSgpKSwgbXV0YXRlXG4gICAgICAgIC8vIE1hdGgucmFuZG9tIGJlY2F1c2UgdGhhdCBpcyBob3cgc2VlZHJhbmRvbS5qcyBoYXMgd29ya2VkIHNpbmNlIHYxLjAuXG4gICAgICAgIGlmIChpc19tYXRoX2NhbGwpIHsgbWF0aFtybmduYW1lXSA9IHBybmc7IHJldHVybiBzZWVkOyB9XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdCBpcyBhIG5ld2VyIGNhbGxpbmcgY29udmVudGlvbiwgc28gcmV0dXJuIHRoZVxuICAgICAgICAvLyBwcm5nIGRpcmVjdGx5LlxuICAgICAgICBlbHNlIHJldHVybiBwcm5nO1xuICAgICAgfSkoXG4gIHBybmcsXG4gIHNob3J0c2VlZCxcbiAgJ2dsb2JhbCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMuZ2xvYmFsIDogKHRoaXMgPT0gbWF0aCksXG4gIG9wdGlvbnMuc3RhdGUpO1xufVxuXG4vL1xuLy8gQVJDNFxuLy9cbi8vIEFuIEFSQzQgaW1wbGVtZW50YXRpb24uICBUaGUgY29uc3RydWN0b3IgdGFrZXMgYSBrZXkgaW4gdGhlIGZvcm0gb2Zcbi8vIGFuIGFycmF5IG9mIGF0IG1vc3QgKHdpZHRoKSBpbnRlZ2VycyB0aGF0IHNob3VsZCBiZSAwIDw9IHggPCAod2lkdGgpLlxuLy9cbi8vIFRoZSBnKGNvdW50KSBtZXRob2QgcmV0dXJucyBhIHBzZXVkb3JhbmRvbSBpbnRlZ2VyIHRoYXQgY29uY2F0ZW5hdGVzXG4vLyB0aGUgbmV4dCAoY291bnQpIG91dHB1dHMgZnJvbSBBUkM0LiAgSXRzIHJldHVybiB2YWx1ZSBpcyBhIG51bWJlciB4XG4vLyB0aGF0IGlzIGluIHRoZSByYW5nZSAwIDw9IHggPCAod2lkdGggXiBjb3VudCkuXG4vL1xuZnVuY3Rpb24gQVJDNChrZXkpIHtcbiAgdmFyIHQsIGtleWxlbiA9IGtleS5sZW5ndGgsXG4gICAgICBtZSA9IHRoaXMsIGkgPSAwLCBqID0gbWUuaSA9IG1lLmogPSAwLCBzID0gbWUuUyA9IFtdO1xuXG4gIC8vIFRoZSBlbXB0eSBrZXkgW10gaXMgdHJlYXRlZCBhcyBbMF0uXG4gIGlmICgha2V5bGVuKSB7IGtleSA9IFtrZXlsZW4rK107IH1cblxuICAvLyBTZXQgdXAgUyB1c2luZyB0aGUgc3RhbmRhcmQga2V5IHNjaGVkdWxpbmcgYWxnb3JpdGhtLlxuICB3aGlsZSAoaSA8IHdpZHRoKSB7XG4gICAgc1tpXSA9IGkrKztcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgIHNbaV0gPSBzW2ogPSBtYXNrICYgKGogKyBrZXlbaSAlIGtleWxlbl0gKyAodCA9IHNbaV0pKV07XG4gICAgc1tqXSA9IHQ7XG4gIH1cblxuICAvLyBUaGUgXCJnXCIgbWV0aG9kIHJldHVybnMgdGhlIG5leHQgKGNvdW50KSBvdXRwdXRzIGFzIG9uZSBudW1iZXIuXG4gIChtZS5nID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICAvLyBVc2luZyBpbnN0YW5jZSBtZW1iZXJzIGluc3RlYWQgb2YgY2xvc3VyZSBzdGF0ZSBuZWFybHkgZG91YmxlcyBzcGVlZC5cbiAgICB2YXIgdCwgciA9IDAsXG4gICAgICAgIGkgPSBtZS5pLCBqID0gbWUuaiwgcyA9IG1lLlM7XG4gICAgd2hpbGUgKGNvdW50LS0pIHtcbiAgICAgIHQgPSBzW2kgPSBtYXNrICYgKGkgKyAxKV07XG4gICAgICByID0gciAqIHdpZHRoICsgc1ttYXNrICYgKChzW2ldID0gc1tqID0gbWFzayAmIChqICsgdCldKSArIChzW2pdID0gdCkpXTtcbiAgICB9XG4gICAgbWUuaSA9IGk7IG1lLmogPSBqO1xuICAgIHJldHVybiByO1xuICAgIC8vIEZvciByb2J1c3QgdW5wcmVkaWN0YWJpbGl0eSwgdGhlIGZ1bmN0aW9uIGNhbGwgYmVsb3cgYXV0b21hdGljYWxseVxuICAgIC8vIGRpc2NhcmRzIGFuIGluaXRpYWwgYmF0Y2ggb2YgdmFsdWVzLiAgVGhpcyBpcyBjYWxsZWQgUkM0LWRyb3BbMjU2XS5cbiAgICAvLyBTZWUgaHR0cDovL2dvb2dsZS5jb20vc2VhcmNoP3E9cnNhK2ZsdWhyZXIrcmVzcG9uc2UmYnRuSVxuICB9KSh3aWR0aCk7XG59XG5cbi8vXG4vLyBjb3B5KClcbi8vIENvcGllcyBpbnRlcm5hbCBzdGF0ZSBvZiBBUkM0IHRvIG9yIGZyb20gYSBwbGFpbiBvYmplY3QuXG4vL1xuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuaSA9IGYuaTtcbiAgdC5qID0gZi5qO1xuICB0LlMgPSBmLlMuc2xpY2UoKTtcbiAgcmV0dXJuIHQ7XG59O1xuXG4vL1xuLy8gZmxhdHRlbigpXG4vLyBDb252ZXJ0cyBhbiBvYmplY3QgdHJlZSB0byBuZXN0ZWQgYXJyYXlzIG9mIHN0cmluZ3MuXG4vL1xuZnVuY3Rpb24gZmxhdHRlbihvYmosIGRlcHRoKSB7XG4gIHZhciByZXN1bHQgPSBbXSwgdHlwID0gKHR5cGVvZiBvYmopLCBwcm9wO1xuICBpZiAoZGVwdGggJiYgdHlwID09ICdvYmplY3QnKSB7XG4gICAgZm9yIChwcm9wIGluIG9iaikge1xuICAgICAgdHJ5IHsgcmVzdWx0LnB1c2goZmxhdHRlbihvYmpbcHJvcF0sIGRlcHRoIC0gMSkpOyB9IGNhdGNoIChlKSB7fVxuICAgIH1cbiAgfVxuICByZXR1cm4gKHJlc3VsdC5sZW5ndGggPyByZXN1bHQgOiB0eXAgPT0gJ3N0cmluZycgPyBvYmogOiBvYmogKyAnXFwwJyk7XG59XG5cbi8vXG4vLyBtaXhrZXkoKVxuLy8gTWl4ZXMgYSBzdHJpbmcgc2VlZCBpbnRvIGEga2V5IHRoYXQgaXMgYW4gYXJyYXkgb2YgaW50ZWdlcnMsIGFuZFxuLy8gcmV0dXJucyBhIHNob3J0ZW5lZCBzdHJpbmcgc2VlZCB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gdGhlIHJlc3VsdCBrZXkuXG4vL1xuZnVuY3Rpb24gbWl4a2V5KHNlZWQsIGtleSkge1xuICB2YXIgc3RyaW5nc2VlZCA9IHNlZWQgKyAnJywgc21lYXIsIGogPSAwO1xuICB3aGlsZSAoaiA8IHN0cmluZ3NlZWQubGVuZ3RoKSB7XG4gICAga2V5W21hc2sgJiBqXSA9XG4gICAgICBtYXNrICYgKChzbWVhciBePSBrZXlbbWFzayAmIGpdICogMTkpICsgc3RyaW5nc2VlZC5jaGFyQ29kZUF0KGorKykpO1xuICB9XG4gIHJldHVybiB0b3N0cmluZyhrZXkpO1xufVxuXG4vL1xuLy8gYXV0b3NlZWQoKVxuLy8gUmV0dXJucyBhbiBvYmplY3QgZm9yIGF1dG9zZWVkaW5nLCB1c2luZyB3aW5kb3cuY3J5cHRvIGFuZCBOb2RlIGNyeXB0b1xuLy8gbW9kdWxlIGlmIGF2YWlsYWJsZS5cbi8vXG5mdW5jdGlvbiBhdXRvc2VlZCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3V0O1xuICAgIGlmIChub2RlY3J5cHRvICYmIChvdXQgPSBub2RlY3J5cHRvLnJhbmRvbUJ5dGVzKSkge1xuICAgICAgLy8gVGhlIHVzZSBvZiAnb3V0JyB0byByZW1lbWJlciByYW5kb21CeXRlcyBtYWtlcyB0aWdodCBtaW5pZmllZCBjb2RlLlxuICAgICAgb3V0ID0gb3V0KHdpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkod2lkdGgpO1xuICAgICAgKGdsb2JhbC5jcnlwdG8gfHwgZ2xvYmFsLm1zQ3J5cHRvKS5nZXRSYW5kb21WYWx1ZXMob3V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvc3RyaW5nKG91dCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIgYnJvd3NlciA9IGdsb2JhbC5uYXZpZ2F0b3IsXG4gICAgICAgIHBsdWdpbnMgPSBicm93c2VyICYmIGJyb3dzZXIucGx1Z2lucztcbiAgICByZXR1cm4gWytuZXcgRGF0ZSwgZ2xvYmFsLCBwbHVnaW5zLCBnbG9iYWwuc2NyZWVuLCB0b3N0cmluZyhwb29sKV07XG4gIH1cbn1cblxuLy9cbi8vIHRvc3RyaW5nKClcbi8vIENvbnZlcnRzIGFuIGFycmF5IG9mIGNoYXJjb2RlcyB0byBhIHN0cmluZ1xuLy9cbmZ1bmN0aW9uIHRvc3RyaW5nKGEpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoMCwgYSk7XG59XG5cbi8vXG4vLyBXaGVuIHNlZWRyYW5kb20uanMgaXMgbG9hZGVkLCB3ZSBpbW1lZGlhdGVseSBtaXggYSBmZXcgYml0c1xuLy8gZnJvbSB0aGUgYnVpbHQtaW4gUk5HIGludG8gdGhlIGVudHJvcHkgcG9vbC4gIEJlY2F1c2Ugd2UgZG9cbi8vIG5vdCB3YW50IHRvIGludGVyZmVyZSB3aXRoIGRldGVybWluaXN0aWMgUFJORyBzdGF0ZSBsYXRlcixcbi8vIHNlZWRyYW5kb20gd2lsbCBub3QgY2FsbCBtYXRoLnJhbmRvbSBvbiBpdHMgb3duIGFnYWluIGFmdGVyXG4vLyBpbml0aWFsaXphdGlvbi5cbi8vXG5taXhrZXkobWF0aC5yYW5kb20oKSwgcG9vbCk7XG5cbi8vXG4vLyBOb2RlanMgYW5kIEFNRCBzdXBwb3J0OiBleHBvcnQgdGhlIGltcGxlbWVudGF0aW9uIGFzIGEgbW9kdWxlIHVzaW5nXG4vLyBlaXRoZXIgY29udmVudGlvbi5cbi8vXG5pZiAoKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gc2VlZHJhbmRvbTtcbiAgLy8gV2hlbiBpbiBub2RlLmpzLCB0cnkgdXNpbmcgY3J5cHRvIHBhY2thZ2UgZm9yIGF1dG9zZWVkaW5nLlxuICB0cnkge1xuICAgIG5vZGVjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbiAgfSBjYXRjaCAoZXgpIHt9XG59IGVsc2UgaWYgKCh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VlZHJhbmRvbTsgfSk7XG59IGVsc2Uge1xuICAvLyBXaGVuIGluY2x1ZGVkIGFzIGEgcGxhaW4gc2NyaXB0LCBzZXQgdXAgTWF0aC5zZWVkcmFuZG9tIGdsb2JhbC5cbiAgbWF0aFsnc2VlZCcgKyBybmduYW1lXSA9IHNlZWRyYW5kb207XG59XG5cblxuLy8gRW5kIGFub255bW91cyBzY29wZSwgYW5kIHBhc3MgaW5pdGlhbCB2YWx1ZXMuXG59KShcbiAgLy8gZ2xvYmFsOiBgc2VsZmAgaW4gYnJvd3NlcnMgKGluY2x1ZGluZyBzdHJpY3QgbW9kZSBhbmQgd2ViIHdvcmtlcnMpLFxuICAvLyBvdGhlcndpc2UgYHRoaXNgIGluIE5vZGUgYW5kIG90aGVyIGVudmlyb25tZW50c1xuICAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSA/IHNlbGYgOiB0aGlzLFxuICBbXSwgICAgIC8vIHBvb2w6IGVudHJvcHkgcG9vbCBzdGFydHMgZW1wdHlcbiAgTWF0aCAgICAvLyBtYXRoOiBwYWNrYWdlIGNvbnRhaW5pbmcgcmFuZG9tLCBwb3csIGFuZCBzZWVkcmFuZG9tXG4pO1xuIiwiXG4gICAgICBpbXBvcnQgQVBJIGZyb20gXCIhLi4vLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgIGltcG9ydCBkb21BUEkgZnJvbSBcIiEuLi8uLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0Rm4gZnJvbSBcIiEuLi8uLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanNcIjtcbiAgICAgIGltcG9ydCBzZXRBdHRyaWJ1dGVzIGZyb20gXCIhLi4vLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRTdHlsZUVsZW1lbnQgZnJvbSBcIiEuLi8uLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qc1wiO1xuICAgICAgaW1wb3J0IHN0eWxlVGFnVHJhbnNmb3JtRm4gZnJvbSBcIiEuLi8uLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzXCI7XG4gICAgICBpbXBvcnQgY29udGVudCwgKiBhcyBuYW1lZEV4cG9ydCBmcm9tIFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vamFzbWluZS5jc3NcIjtcbiAgICAgIFxuICAgICAgXG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0gPSBzdHlsZVRhZ1RyYW5zZm9ybUZuO1xub3B0aW9ucy5zZXRBdHRyaWJ1dGVzID0gc2V0QXR0cmlidXRlcztcblxuICAgICAgb3B0aW9ucy5pbnNlcnQgPSBpbnNlcnRGbi5iaW5kKG51bGwsIFwiaGVhZFwiKTtcbiAgICBcbm9wdGlvbnMuZG9tQVBJID0gZG9tQVBJO1xub3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7XG5cbnZhciB1cGRhdGUgPSBBUEkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgKiBmcm9tIFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vamFzbWluZS5jc3NcIjtcbiAgICAgICBleHBvcnQgZGVmYXVsdCBjb250ZW50ICYmIGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB1bmRlZmluZWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHN0eWxlc0luRE9NID0gW107XG5cbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5ET00ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5ET01baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleEJ5SWRlbnRpZmllciA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXSxcbiAgICAgIHN1cHBvcnRzOiBpdGVtWzRdLFxuICAgICAgbGF5ZXI6IGl0ZW1bNV1cbiAgICB9O1xuXG4gICAgaWYgKGluZGV4QnlJZGVudGlmaWVyICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB1cGRhdGVyID0gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLmJ5SW5kZXggPSBpO1xuICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKGksIDAsIHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgdXBkYXRlcjogdXBkYXRlcixcbiAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfVxuXG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cblxuZnVuY3Rpb24gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgYXBpID0gb3B0aW9ucy5kb21BUEkob3B0aW9ucyk7XG4gIGFwaS51cGRhdGUob2JqKTtcblxuICB2YXIgdXBkYXRlciA9IGZ1bmN0aW9uIHVwZGF0ZXIobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCAmJiBuZXdPYmouc3VwcG9ydHMgPT09IG9iai5zdXBwb3J0cyAmJiBuZXdPYmoubGF5ZXIgPT09IG9iai5sYXllcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGFwaS51cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbW92ZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdXBkYXRlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cblxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcblxuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcblxuICAgICAgaWYgKHN0eWxlc0luRE9NW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRPTVtfaW5kZXhdLnVwZGF0ZXIoKTtcblxuICAgICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgbWVtbyA9IHt9O1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cbmZ1bmN0aW9uIGdldFRhcmdldCh0YXJnZXQpIHtcbiAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7IC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cbiAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gIH1cblxuICByZXR1cm4gbWVtb1t0YXJnZXRdO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxuZnVuY3Rpb24gaW5zZXJ0QnlTZWxlY3RvcihpbnNlcnQsIHN0eWxlKSB7XG4gIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQoaW5zZXJ0KTtcblxuICBpZiAoIXRhcmdldCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gIH1cblxuICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydEJ5U2VsZWN0b3I7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIG9wdGlvbnMuc2V0QXR0cmlidXRlcyhlbGVtZW50LCBvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICBvcHRpb25zLmluc2VydChlbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xuICByZXR1cm4gZWxlbWVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzKHN0eWxlRWxlbWVudCkge1xuICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG5cbiAgaWYgKG5vbmNlKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlczsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gXCJcIjtcblxuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQob2JqLnN1cHBvcnRzLCBcIikge1wiKTtcbiAgfVxuXG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKTtcbiAgfVxuXG4gIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2Ygb2JqLmxheWVyICE9PSBcInVuZGVmaW5lZFwiO1xuXG4gIGlmIChuZWVkTGF5ZXIpIHtcbiAgICBjc3MgKz0gXCJAbGF5ZXJcIi5jb25jYXQob2JqLmxheWVyLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQob2JqLmxheWVyKSA6IFwiXCIsIFwiIHtcIik7XG4gIH1cblxuICBjc3MgKz0gb2JqLmNzcztcblxuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG5cbiAgaWYgKG9iai5tZWRpYSkge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuXG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cblxuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIG9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZUVsZW1lbnQucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG5mdW5jdGlvbiBkb21BUEkob3B0aW9ucykge1xuICB2YXIgc3R5bGVFbGVtZW50ID0gb3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUob2JqKSB7XG4gICAgICBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaik7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkb21BUEk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQpIHtcbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5bGVUYWdUcmFuc2Zvcm07IiwiaW1wb3J0IENvbXB1dGVWb3hlbHMgZnJvbSAnISFyYXctbG9hZGVyIS4vY29tcHV0ZS12b3hlbHMud2dzbCc7XG5pbXBvcnQgUmFuZG9tIGZyb20gJ3NlZWRyYW5kb20nO1xuXG5kZXNjcmliZSgnY29tcHV0ZS12b3hlbHMnLCAoKSA9PiB7XG4gIGRlc2NyaWJlKCdjb21wdXRlTWF0ZXJpYWxzJywgKCkgPT4ge1xuICAgIGxldCBtYXRlcmlhbHM6IFVpbnQzMkFycmF5O1xuXG4gICAgYmVmb3JlQWxsKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGFkYXB0ZXIgPSBhd2FpdCBuYXZpZ2F0b3IuZ3B1LnJlcXVlc3RBZGFwdGVyKCk7XG4gICAgICBjb25zdCBkZXZpY2UgPSBhd2FpdCBhZGFwdGVyLnJlcXVlc3REZXZpY2UoKTtcblxuICAgICAgY29uc3QgZGVuc2l0eSA9IGBmbiBnZXREZW5zaXR5KHdvcmxkUG9zaXRpb246IHZlYzM8ZjMyPikgLT4gZjMyIHsgXG4gICAgICAgIGlmICh3b3JsZFBvc2l0aW9uLnkgPCAzLjApIHtcbiAgICAgICAgICByZXR1cm4gLTEuMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gMS4wO1xuICAgICAgICB9XG4gICAgICAgfWA7XG5cbiAgICAgIGNvbnN0IGNvbXB1dGVWb3hlbHMgPSBDb21wdXRlVm94ZWxzLnJlcGxhY2UoXCIjaW1wb3J0IGRlbnNpdHlcIiwgZGVuc2l0eSlcbiAgICAgIGNvbnN0IGNvbXB1dGVQaXBlbGluZSA9IGF3YWl0IGRldmljZS5jcmVhdGVDb21wdXRlUGlwZWxpbmVBc3luYyh7XG4gICAgICAgIGxheW91dDogJ2F1dG8nLFxuICAgICAgICBjb21wdXRlOiB7XG4gICAgICAgICAgbW9kdWxlOiBkZXZpY2UuY3JlYXRlU2hhZGVyTW9kdWxlKHtcbiAgICAgICAgICAgIGNvZGU6IGNvbXB1dGVWb3hlbHMsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgZW50cnlQb2ludDogJ2NvbXB1dGVNYXRlcmlhbHMnLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHBlcm11dGF0aW9ucyA9IG5ldyBJbnQzMkFycmF5KDUxMik7XG5cbiAgICAgIGNvbnN0IHJhbmRvbSA9IG5ldyBSYW5kb20oNjQ1Mik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKVxuICAgICAgICBwZXJtdXRhdGlvbnNbaV0gPSAoMjU2ICogKHJhbmRvbSgpKSk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAyNTY7IGkgPCA1MTI7IGkrKylcbiAgICAgICAgcGVybXV0YXRpb25zW2ldID0gcGVybXV0YXRpb25zW2kgLSAyNTZdO1xuXG4gICAgICBjb25zdCBwZXJtdXRhdGlvbnNCdWZmZXIgPSBkZXZpY2UuY3JlYXRlQnVmZmVyKHtcbiAgICAgICAgc2l6ZTogcGVybXV0YXRpb25zLmJ5dGVMZW5ndGgsXG4gICAgICAgIHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5TVE9SQUdFIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QsXG4gICAgICAgIG1hcHBlZEF0Q3JlYXRpb246IHRydWUsXG4gICAgICB9KTtcblxuICAgICAgbmV3IEludDMyQXJyYXkocGVybXV0YXRpb25zQnVmZmVyLmdldE1hcHBlZFJhbmdlKCkpLnNldChcbiAgICAgICAgcGVybXV0YXRpb25zXG4gICAgICApO1xuICAgICAgcGVybXV0YXRpb25zQnVmZmVyLnVubWFwKCk7XG5cbiAgICAgIGNvbnN0IGNvcm5lck1hdGVyaWFscyA9IGRldmljZS5jcmVhdGVCdWZmZXIoe1xuICAgICAgICBzaXplOiBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCAqIDUgKiA1ICogNSxcbiAgICAgICAgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UgfCBHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQyxcbiAgICAgICAgbWFwcGVkQXRDcmVhdGlvbjogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgY29ybmVyTWF0ZXJpYWxzUmVhZCA9IGRldmljZS5jcmVhdGVCdWZmZXIoe1xuICAgICAgICBzaXplOiBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCAqIDUgKiA1ICogNSxcbiAgICAgICAgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUIHwgR1BVQnVmZmVyVXNhZ2UuTUFQX1JFQUQsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdW5pZm9ybUJ1ZmZlclNpemUgPSA0ICogNTtcbiAgICAgIGNvbnN0IHVuaWZvcm1CdWZmZXIgPSBkZXZpY2UuY3JlYXRlQnVmZmVyKHtcbiAgICAgICAgc2l6ZTogdW5pZm9ybUJ1ZmZlclNpemUsXG4gICAgICAgIHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5VTklGT1JNIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgY29tcHV0ZUJpbmRHcm91cCA9IGRldmljZS5jcmVhdGVCaW5kR3JvdXAoe1xuICAgICAgICBsYXlvdXQ6IGNvbXB1dGVQaXBlbGluZS5nZXRCaW5kR3JvdXBMYXlvdXQoMCksXG4gICAgICAgIGVudHJpZXM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBiaW5kaW5nOiAxLFxuICAgICAgICAgICAgcmVzb3VyY2U6IHtcbiAgICAgICAgICAgICAgYnVmZmVyOiBjb3JuZXJNYXRlcmlhbHNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmluZGluZzogNSxcbiAgICAgICAgICAgIHJlc291cmNlOiB7XG4gICAgICAgICAgICAgIGJ1ZmZlcjogdW5pZm9ybUJ1ZmZlclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBjb21wdXRlRW5jb2RlciA9IGRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlcigpO1xuICAgICAgY29uc3QgY29tcHV0ZVBhc3NFbmNvZGVyID0gY29tcHV0ZUVuY29kZXIuYmVnaW5Db21wdXRlUGFzcygpO1xuICAgICAgY29tcHV0ZVBhc3NFbmNvZGVyLnNldFBpcGVsaW5lKGNvbXB1dGVQaXBlbGluZSk7XG4gICAgICBjb21wdXRlUGFzc0VuY29kZXIuc2V0QmluZEdyb3VwKDAsIGNvbXB1dGVCaW5kR3JvdXApO1xuICAgICAgY29tcHV0ZVBhc3NFbmNvZGVyLmRpc3BhdGNoV29ya2dyb3Vwcyg1LCA1LCA1KTtcbiAgICAgIGNvbXB1dGVQYXNzRW5jb2Rlci5lbmQoKTtcblxuICAgICAgY29uc3QgY29weUVuY29kZXIgPSBkZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoKTtcbiAgICAgIGNvcHlFbmNvZGVyLmNvcHlCdWZmZXJUb0J1ZmZlcihcbiAgICAgICAgY29ybmVyTWF0ZXJpYWxzLFxuICAgICAgICAwLFxuICAgICAgICBjb3JuZXJNYXRlcmlhbHNSZWFkLFxuICAgICAgICAwLFxuICAgICAgICBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCAqIDUgKiA1ICogNVxuICAgICAgKTtcblxuICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcig0ICogNSk7XG4gICAgICBjb25zdCB1bmlmb3JtID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIsIDAsIDQpO1xuICAgICAgdW5pZm9ybVszXSA9IDE7XG5cbiAgICAgIG5ldyBVaW50MzJBcnJheShidWZmZXIsIDE2LCAxKVswXSA9IDU7XG5cbiAgICAgIGRldmljZS5xdWV1ZS53cml0ZUJ1ZmZlcihcbiAgICAgICAgICB1bmlmb3JtQnVmZmVyLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgYnVmZmVyLmJ5dGVMZW5ndGhcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHF1ZXVlID0gZGV2aWNlLnF1ZXVlLm9uU3VibWl0dGVkV29ya0RvbmUoKTtcblxuICAgICAgZGV2aWNlLnF1ZXVlLnN1Ym1pdChbY29tcHV0ZUVuY29kZXIuZmluaXNoKCksIGNvcHlFbmNvZGVyLmZpbmlzaCgpXSk7XG5cbiAgICAgIGF3YWl0IHF1ZXVlO1xuXG4gICAgICBhd2FpdCBjb3JuZXJNYXRlcmlhbHNSZWFkLm1hcEFzeW5jKEdQVU1hcE1vZGUuUkVBRClcbiAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gY29ybmVyTWF0ZXJpYWxzUmVhZC5nZXRNYXBwZWRSYW5nZSgpO1xuICAgICAgbWF0ZXJpYWxzID0gbmV3IFVpbnQzMkFycmF5KGFycmF5QnVmZmVyKS5zbGljZSgpO1xuICAgICAgY29ybmVyTWF0ZXJpYWxzUmVhZC51bm1hcCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3RoZW4gbWF0ZXJpYWxzIGlzIG5vdCBudWxsJywgKCkgPT4ge1xuICAgICAgY29uc3QgZXhwZWN0ZWRSZXN1bHQgPSBuZXcgVWludDMyQXJyYXkoNSo1KjUpO1xuXG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDU7IHgrKylcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTsgeSsrKVxuICAgICAgZm9yIChsZXQgeiA9IDA7IHogPCA1OyB6KyspIHtcbiAgICAgICAgZXhwZWN0ZWRSZXN1bHRbeiAqIDUgKiA1ICsgeSAqIDUgKyB4XSA9IHkgPCAzID8gMSA6IDA7XG4gICAgICB9XG5cbiAgICAgIGV4cGVjdChtYXRlcmlhbHMpLnRvRXF1YWwoZXhwZWN0ZWRSZXN1bHQpO1xuICAgIH0pO1xuICB9KTtcbn0pOyIsImltcG9ydCBSZW5kZXJlciBmcm9tIFwiLi9yZW5kZXJlclwiO1xuXG5kZXNjcmliZSgnUmVuZGVyZXInLCAoKSA9PiB7XG4gIGxldCBjYW52YXM7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbnZhcycpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIG5vdCB0aHJvdyB3aGVuIGluaXRpYWxpemVkJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKCk7XG4gICAgYXdhaXQgZXhwZWN0QXN5bmMgKHJlbmRlcmVyLmluaXQoY2FudmFzKSkudG9CZVJlc29sdmVkKCk7XG4gICAgZXhwZWN0KCgpID0+IHJlbmRlcmVyLmNvbmZpZ3VyZShjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpKS5ub3QudG9UaHJvdygpO1xuICAgIGV4cGVjdCgoKSA9PiByZW5kZXJlci5yZW5kZXIoKCkgPT4ge30pKS5ub3QudG9UaHJvdygpO1xuICB9KTtcbn0pOyIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmVyIHtcbiAgcHJpdmF0ZSBjb250ZXh0OiBHUFVDYW52YXNDb250ZXh0O1xuICBkZXZpY2U6IEdQVURldmljZTtcbiAgcHJpdmF0ZSBwcmVzZW50YXRpb25Gb3JtYXQ6IEdQVVRleHR1cmVGb3JtYXRcbiAgcHJpdmF0ZSBkZXB0aFRleHR1cmU6IEdQVVRleHR1cmVcblxuICBhc3luYyBpbml0KGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gYXdhaXQgbmF2aWdhdG9yLmdwdS5yZXF1ZXN0QWRhcHRlcigpO1xuICAgIHRoaXMuZGV2aWNlID0gYXdhaXQgYWRhcHRlci5yZXF1ZXN0RGV2aWNlKCk7XG5cbiAgICB0aGlzLmNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ3B1Jyk7XG4gICAgdGhpcy5wcmVzZW50YXRpb25Gb3JtYXQgPSAgbmF2aWdhdG9yLmdwdS5nZXRQcmVmZXJyZWRDYW52YXNGb3JtYXQoKTtcbiAgfVxuXG4gIGNvbmZpZ3VyZSh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikge1xuICAgIHRoaXMuY29udGV4dC5jb25maWd1cmUoe1xuICAgICAgZGV2aWNlOiB0aGlzLmRldmljZSxcbiAgICAgIGZvcm1hdDogdGhpcy5wcmVzZW50YXRpb25Gb3JtYXQsXG4gICAgICBhbHBoYU1vZGU6ICdvcGFxdWUnXG4gICAgfSk7XG5cbiAgICB0aGlzLmRlcHRoVGV4dHVyZSA9IHRoaXMuZGV2aWNlLmNyZWF0ZVRleHR1cmUoe1xuICAgICAgc2l6ZTogeyB3aWR0aCwgaGVpZ2h0IH0sXG4gICAgICBmb3JtYXQ6ICdkZXB0aDI0cGx1cy1zdGVuY2lsOCcsXG4gICAgICB1c2FnZTogR1BVVGV4dHVyZVVzYWdlLlJFTkRFUl9BVFRBQ0hNRU5ULFxuICAgIH0pO1xuICB9XG5cbiAgcmVuZGVyKGNhbGxiYWNrOiAoR1BVUmVuZGVyUGFzc0Rlc2NyaXB0b3IpID0+IHZvaWQpIHtcbiAgICBjb25zdCBjb21tYW5kRW5jb2RlciA9IHRoaXMuZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCk7XG4gICAgY29uc3QgdGV4dHVyZVZpZXcgPSB0aGlzLmNvbnRleHQuZ2V0Q3VycmVudFRleHR1cmUoKS5jcmVhdGVWaWV3KCk7XG5cbiAgICBjb25zdCByZW5kZXJQYXNzRGVzY3JpcHRvcjogR1BVUmVuZGVyUGFzc0Rlc2NyaXB0b3IgPSB7XG4gICAgICBjb2xvckF0dGFjaG1lbnRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICB2aWV3OiB0ZXh0dXJlVmlldyxcbiAgICAgICAgICBjbGVhclZhbHVlOiB7cjogMC4wLCBnOiAwLjAsIGI6IDAuMCwgYTogMS4wfSxcbiAgICAgICAgICBsb2FkT3A6ICdjbGVhcicgYXMgY29uc3QsXG4gICAgICAgICAgc3RvcmVPcDogJ3N0b3JlJyBhcyBjb25zdFxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgZGVwdGhTdGVuY2lsQXR0YWNobWVudDoge1xuICAgICAgICB2aWV3OiB0aGlzLmRlcHRoVGV4dHVyZS5jcmVhdGVWaWV3KCksXG5cbiAgICAgICAgZGVwdGhDbGVhclZhbHVlOiAxLjAsXG4gICAgICAgIGRlcHRoTG9hZE9wOiAnY2xlYXInLFxuICAgICAgICBkZXB0aFN0b3JlT3A6ICdzdG9yZScsXG5cbiAgICAgICAgc3RlbmNpbENsZWFyVmFsdWU6IDAsXG4gICAgICAgIHN0ZW5jaWxMb2FkT3A6ICdjbGVhcicsXG4gICAgICAgIHN0ZW5jaWxTdG9yZU9wOiAnc3RvcmUnLFxuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBwYXNzRW5jb2RlciA9IGNvbW1hbmRFbmNvZGVyLmJlZ2luUmVuZGVyUGFzcyhyZW5kZXJQYXNzRGVzY3JpcHRvcik7XG4gICAgY2FsbGJhY2socGFzc0VuY29kZXIpO1xuICAgIHBhc3NFbmNvZGVyLmVuZCgpO1xuXG4gICAgdGhpcy5kZXZpY2UucXVldWUuc3VibWl0KFtjb21tYW5kRW5jb2Rlci5maW5pc2goKV0pO1xuICB9XG59XG4iLCJpbXBvcnQgJ2phc21pbmUtY29yZS9saWIvamFzbWluZS1jb3JlL2phc21pbmUuY3NzJ1xuXG5pbXBvcnQgJ2phc21pbmUtY29yZS9saWIvamFzbWluZS1jb3JlL2phc21pbmUtaHRtbC5qcydcbmltcG9ydCAnamFzbWluZS1jb3JlL2xpYi9qYXNtaW5lLWNvcmUvYm9vdDAuanMnXG5pbXBvcnQgJ2phc21pbmUtY29yZS9saWIvamFzbWluZS1jb3JlL2Jvb3QxLmpzJ1xuXG4vLyBAdHMtaWdub3JlXG5jb25zdCB0ZXN0cyA9IHJlcXVpcmUuY29udGV4dChcbiAgICBcIi4vXCIsIC8vIGNvbnRleHQgZm9sZGVyXG4gICAgdHJ1ZSwgLy8gaW5jbHVkZSBzdWJkaXJlY3Rvcmllc1xuICAgIC8udGVzdC4oanx0KXMkLyAvLyBSZWdFeHBcbik7XG5cbmNvbnN0IHRlc3RGaWxlcyA9IHRlc3RzLmtleXMoKTtcbmZvciAobGV0IHRlc3QgaW4gdGVzdEZpbGVzKSB7XG4gICAgdGVzdHModGVzdEZpbGVzW3Rlc3RdKTtcbn1cbiIsImltcG9ydCBXb3JsZEdlbmVyYXRvciwge2dlbmVyYXRlUG9pbnRzfSBmcm9tICcuL3dvcmxkLWdlbmVyYXRvcic7XG5cbmRlc2NyaWJlKCdXb3JsZCBHZW5lcmF0b3InLCAoKSA9PiB7XG4gIGxldCB3b3JsZEdlbmVyYXRvcjogV29ybGRHZW5lcmF0b3I7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgd29ybGRHZW5lcmF0b3IgPSBuZXcgV29ybGRHZW5lcmF0b3IoOCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCd3aGVuIGluaXQgaXMgY2FsbGVkJywgKCkgPT4ge1xuICAgIGxldCBpbmZvO1xuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgaW5mbyA9IHdvcmxkR2VuZXJhdG9yLmluaXQoMywgMjAsIDQzKTtcbiAgICB9KTtcblxuICAgIGl0KCdwb3NpdGlvbiBpcyByb3VuZGVkIHRvIG5lYXJlc3Qgc3RyaWRlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgZXhwZWN0KGluZm8ueCkudG9FcXVhbCgwKTtcbiAgICAgIGV4cGVjdChpbmZvLnkpLnRvRXF1YWwoMjQpO1xuICAgICAgZXhwZWN0KGluZm8ueikudG9FcXVhbCg0MCk7XG4gICAgfSk7XG5cbiAgICBpdCgnY3VycmVudCBzdHJpZGUgZGVmYXVsdHMgdG8gbWluaW11bSBzdHJpZGUnLCAoKSA9PiB7XG4gICAgICBleHBlY3QoaW5mby5zdHJpZGUpLnRvRXF1YWwoOCk7XG4gICAgfSk7XG5cbiAgICBpdCgncHJldmlvdXNPZmZzZXQgaXMgY29ycmVjdCcsICgpID0+IHtcbiAgICAgIGV4cGVjdChpbmZvLnByZXZpb3VzT2Zmc2V0KS50b0VxdWFsKC00KTtcbiAgICB9KTtcblxuICAgIGl0KCdsYXllciBpcyBjb3JyZWN0JywgKCkgPT4ge1xuICAgICAgZXhwZWN0KGluZm8ubGF5ZXIpLnRvRXF1YWwoMSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCd3aGVuIG5leHQgaXMgY2FsbGVkJywgKCkgPT4ge1xuICAgIGl0KCdyZXR1cm5zIG9yaWdpbiBwb3NpdGlvbicsICgpID0+IHtcbiAgICAgIGxldCBbcmVzdWx0LCBpbmZvXSA9IHdvcmxkR2VuZXJhdG9yLm5leHQoe1xuICAgICAgICB4OiAwLCB5OiAwLCB6OiAwLCBzdHJpZGU6IDgsIGl0ZXJhdGlvbjogMCwgbGF5ZXI6IDEsIHByZXZpb3VzT2Zmc2V0OiAtNFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgICB4OiAtNCwgeTogLTQsIHo6IC00LCBzdHJpZGU6IDhcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoaW5mbykudG9FcXVhbCh7XG4gICAgICAgIHg6IDAsIHk6IDAsIHo6IDAsIHN0cmlkZTogOCwgaXRlcmF0aW9uOiAxLCBsYXllcjogMSwgcHJldmlvdXNPZmZzZXQ6IC00XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdyZXR1cm5zIG9yaWdpbiBwb3NpdGlvbiBmb3IgaXRlcmF0aW9uIDEnLCAoKSA9PiB7XG4gICAgICBsZXQgW3Jlc3VsdCwgaW5mb10gPSB3b3JsZEdlbmVyYXRvci5uZXh0KHtcbiAgICAgICAgeDogMCwgeTogMCwgejogMCwgc3RyaWRlOiA4LCBpdGVyYXRpb246IDEsIGxheWVyOiAxLCBwcmV2aW91c09mZnNldDogLTRcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHtcbiAgICAgICAgeDogLTQsIHk6IC00LCB6OiA0LCBzdHJpZGU6IDhcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoaW5mbykudG9FcXVhbCh7XG4gICAgICAgIHg6IDAsIHk6IDAsIHo6IDAsIHN0cmlkZTogOCwgaXRlcmF0aW9uOiAyLCBsYXllcjogMSwgcHJldmlvdXNPZmZzZXQ6IC00XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdyZXR1cm5zIG9yaWdpbiBwb3NpdGlvbiBmb3Igc2Vjb25kIGxheWVyJywgKCkgPT4ge1xuICAgICAgbGV0IFtyZXN1bHQsIGluZm9dID0gd29ybGRHZW5lcmF0b3IubmV4dCh7XG4gICAgICAgIHg6IDAsIHk6IDAsIHo6IDAsIHN0cmlkZTogOCwgaXRlcmF0aW9uOiAwLCBsYXllcjogMiwgcHJldmlvdXNPZmZzZXQ6IC00XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7XG4gICAgICAgIHg6IC0xMiwgeTogLTEyLCB6OiAtMTIsIHN0cmlkZTogOFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChpbmZvKS50b0VxdWFsKHtcbiAgICAgICAgeDogMCwgeTogMCwgejogMCwgc3RyaWRlOiA4LCBpdGVyYXRpb246IDEsIGxheWVyOiAyLCBwcmV2aW91c09mZnNldDogLTRcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3JldHVybnMgb3JpZ2luIHBvc2l0aW9uIGZvciBzZWNvbmQgbGF5ZXIgc2Vjb25kIGl0ZXJhdGlvbicsICgpID0+IHtcbiAgICAgIGxldCBbcmVzdWx0LCBpbmZvXSA9IHdvcmxkR2VuZXJhdG9yLm5leHQoe1xuICAgICAgICB4OiAwLCB5OiAwLCB6OiAwLCBzdHJpZGU6IDgsIGl0ZXJhdGlvbjogNiwgbGF5ZXI6IDIsIHByZXZpb3VzT2Zmc2V0OiAtNFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgICB4OiAtMTIsIHk6IC00LCB6OiA0LCBzdHJpZGU6IDhcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoaW5mbykudG9FcXVhbCh7XG4gICAgICAgIHg6IDAsIHk6IDAsIHo6IDAsIHN0cmlkZTogOCwgaXRlcmF0aW9uOiA3LCBsYXllcjogMiwgcHJldmlvdXNPZmZzZXQ6IC00XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdvZmZzZXRzIHBvc2l0aW9uIGJ5IHJvb3QnLCAoKSA9PiB7XG4gICAgICBsZXQgW3Jlc3VsdCwgaW5mb10gPSB3b3JsZEdlbmVyYXRvci5uZXh0KHtcbiAgICAgICAgeDogNDAsIHk6IDI0LCB6OiAzMiwgc3RyaWRlOiA4LCBpdGVyYXRpb246IDAsIGxheWVyOiAxLCBwcmV2aW91c09mZnNldDogLTRcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHtcbiAgICAgICAgeDogMzYsIHk6IDIwLCB6OiAyOCwgc3RyaWRlOiA4XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KGluZm8pLnRvRXF1YWwoe1xuICAgICAgICB4OiA0MCwgeTogMjQsIHo6IDMyLCBzdHJpZGU6IDgsIGl0ZXJhdGlvbjogMSwgbGF5ZXI6IDEsIHByZXZpb3VzT2Zmc2V0OiAtNFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnb2Zmc2V0cyBwb3NpdGlvbiBieSBpdGVyYXRpb24nLCAoKSA9PiB7XG4gICAgICBsZXQgW3Jlc3VsdCwgaW5mb10gPSB3b3JsZEdlbmVyYXRvci5uZXh0KHtcbiAgICAgICAgeDogNDAsIHk6IDI0LCB6OiAzMiwgc3RyaWRlOiA4LCBpdGVyYXRpb246IDEsIGxheWVyOiAxLCBwcmV2aW91c09mZnNldDogLTRcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHtcbiAgICAgICAgeDogMzYsIHk6IDIwLCB6OiAzNiwgc3RyaWRlOiA4XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KGluZm8pLnRvRXF1YWwoe1xuICAgICAgICB4OiA0MCwgeTogMjQsIHo6IDMyLCBzdHJpZGU6IDgsIGl0ZXJhdGlvbjogMiwgbGF5ZXI6IDEsIHByZXZpb3VzT2Zmc2V0OiAtNFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnb2Zmc2V0cyBwb3NpdGlvbiBieSBsYXN0IGl0ZXJhdGlvbicsICgpID0+IHtcbiAgICAgIGxldCBbcmVzdWx0LCBpbmZvXSA9IHdvcmxkR2VuZXJhdG9yLm5leHQoe1xuICAgICAgICB4OiA0MCwgeTogMjQsIHo6IDMyLCBzdHJpZGU6IDgsIGl0ZXJhdGlvbjogNywgbGF5ZXI6IDEsIHByZXZpb3VzT2Zmc2V0OiAtNFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgICB4OiA0NCwgeTogMjgsIHo6IDM2LCBzdHJpZGU6IDhcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoaW5mbykudG9FcXVhbCh7XG4gICAgICAgIHg6IDQwLCB5OiAyNCwgejogMzIsIHN0cmlkZTogOCwgaXRlcmF0aW9uOiAwLCBsYXllcjogMiwgcHJldmlvdXNPZmZzZXQ6IC00XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdvZmZzZXRzIHBvc2l0aW9uIGJ5IGxhc3QgbGF5ZXInLCAoKSA9PiB7XG4gICAgICBsZXQgW3Jlc3VsdCwgaW5mb10gPSB3b3JsZEdlbmVyYXRvci5uZXh0KHtcbiAgICAgICAgeDogNDAsIHk6IDI0LCB6OiAzMiwgc3RyaWRlOiA4LCBpdGVyYXRpb246IDU1LCBsYXllcjogMiwgcHJldmlvdXNPZmZzZXQ6IC00XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7XG4gICAgICAgIHg6IDUyLCB5OiAzNiwgejogNDQsIHN0cmlkZTogOFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChpbmZvKS50b0VxdWFsKHtcbiAgICAgICAgeDogNDAsIHk6IDI0LCB6OiAzMiwgc3RyaWRlOiAxNiwgaXRlcmF0aW9uOiAwLCBsYXllcjogMSwgcHJldmlvdXNPZmZzZXQ6IDhcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3JldHVybnMgY29ycmVjdCBwb3NpdGlvbiBmb3IgbmV4dCBzdHJpZGUnLCAoKSA9PiB7XG4gICAgICBsZXQgW3Jlc3VsdCwgaW5mb10gPSB3b3JsZEdlbmVyYXRvci5uZXh0KHtcbiAgICAgICAgeDogMCwgeTogMCwgejogMCwgc3RyaWRlOiAxNiwgaXRlcmF0aW9uOiAwLCBsYXllcjogMSwgcHJldmlvdXNPZmZzZXQ6IDhcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHtcbiAgICAgICAgeDogLTI0LCB5OiAtMjQsIHo6IC0yNCwgc3RyaWRlOiAxNlxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChpbmZvKS50b0VxdWFsKHtcbiAgICAgICAgeDogMCwgeTogMCwgejogMCwgc3RyaWRlOiAxNiwgaXRlcmF0aW9uOiAxLCBsYXllcjogMSwgcHJldmlvdXNPZmZzZXQ6IDhcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3JldHVybnMgY29ycmVjdCBwb3NpdGlvbiAzMi8wLzEnLCAoKSA9PiB7XG4gICAgICBsZXQgW3Jlc3VsdCwgaW5mb10gPSB3b3JsZEdlbmVyYXRvci5uZXh0KHtcbiAgICAgICAgeDogMCwgeTogMCwgejogMCwgc3RyaWRlOiAzMiwgaXRlcmF0aW9uOiAwLCBsYXllcjogMSwgcHJldmlvdXNPZmZzZXQ6IDQ4XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7XG4gICAgICAgIHg6IC04MCwgeTogLTgwLCB6OiAtODAsIHN0cmlkZTogMzJcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoaW5mbykudG9FcXVhbCh7XG4gICAgICAgIHg6IDAsIHk6IDAsIHo6IDAsIHN0cmlkZTogMzIsIGl0ZXJhdGlvbjogMSwgbGF5ZXI6IDEsIHByZXZpb3VzT2Zmc2V0OiA0OFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCd3aGVuIHJhZGl1cyBpcyBjYWxsZWQnLCAoKSA9PiB7XG4gICAgbGV0IGV4cGVjdGVkUmVzdWx0cyA9IFtcbiAgICAgIHsgbGF5ZXI6IDEsIHN0cmlkZTogOCwgcHJldmlvdXNPZmZzZXQ6IC00LCByZXN1bHQ6IDR9LFxuICAgICAgeyBsYXllcjogMiwgc3RyaWRlOiA4LCBwcmV2aW91c09mZnNldDogLTQsIHJlc3VsdDogMTJ9LFxuICAgICAgeyBsYXllcjogMSwgc3RyaWRlOiAxNiwgcHJldmlvdXNPZmZzZXQ6IDgsIHJlc3VsdDogMjR9LFxuICAgICAgeyBsYXllcjogMiwgc3RyaWRlOiAxNiwgcHJldmlvdXNPZmZzZXQ6IDgsIHJlc3VsdDogNDB9LFxuICAgICAgeyBsYXllcjogLTIsIHN0cmlkZTogMTYsIHByZXZpb3VzT2Zmc2V0OiA4LCByZXN1bHQ6IC00MH0sXG4gICAgXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwZWN0ZWRSZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB7bGF5ZXIsIHN0cmlkZSwgcHJldmlvdXNPZmZzZXQsIHJlc3VsdH0gPSBleHBlY3RlZFJlc3VsdHNbaV07XG4gICAgICBpdChgdGhlbiByaW5nICR7aSsxfSBpcyBjb3JyZWN0YCwgKCkgPT4ge1xuICAgICAgICBleHBlY3Qod29ybGRHZW5lcmF0b3IucmFkaXVzKGxheWVyLCBzdHJpZGUsIHByZXZpb3VzT2Zmc2V0KSkudG9FcXVhbChyZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICBkZXNjcmliZSgnd2hlbiBsYXllclJhZGl1cyBpcyBjYWxsZWQnLCAoKSA9PiB7XG4gICAgbGV0IGV4cGVjdGVkUmVzdWx0cyA9IFtcbiAgICAgIHsgbGF5ZXI6IDEsIHN0cmlkZTogOCwgcmVzdWx0OiAxfSxcbiAgICAgIHsgbGF5ZXI6IDIsIHN0cmlkZTogOCwgcmVzdWx0OiAyfSxcbiAgICAgIHsgbGF5ZXI6IDEsIHN0cmlkZTogMTYsIHJlc3VsdDogMn0sXG4gICAgICB7IGxheWVyOiAyLCBzdHJpZGU6IDE2LCByZXN1bHQ6IDN9LFxuICAgICAgeyBsYXllcjogMywgc3RyaWRlOiAxNiwgcmVzdWx0OiA0fSxcbiAgICAgIHsgbGF5ZXI6IDEsIHN0cmlkZTogMzIsIHJlc3VsdDogM30sXG4gICAgICB7IGxheWVyOiAyLCBzdHJpZGU6IDMyLCByZXN1bHQ6IDR9LFxuICAgIF07XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cGVjdGVkUmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qge2xheWVyLCBzdHJpZGUsIHJlc3VsdH0gPSBleHBlY3RlZFJlc3VsdHNbaV07XG4gICAgICBpdChgdGhlbiByaW5nICR7aSsxfSBpcyBjb3JyZWN0YCwgKCkgPT4ge1xuICAgICAgICBleHBlY3Qod29ybGRHZW5lcmF0b3IubGF5ZXJSYWRpdXMobGF5ZXIsIHN0cmlkZSkpLnRvRXF1YWwocmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3doZW4gbGF5ZXJDb3VudCBpcyBjYWxsZWQnLCAoKSA9PiB7XG4gICAgaXQoJ3JldHVybnMgMiBmb3IgZmlyc3Qgc3RyaWRlJywgKCkgPT4ge1xuICAgICAgZXhwZWN0KHdvcmxkR2VuZXJhdG9yLmxheWVyQ291bnQoOCkpLnRvRXF1YWwoMik7XG4gICAgfSk7XG5cbiAgICBpdCgncmV0dXJucyAzIGZvciBzZWNvbmQgc3RyaWRlJywgKCkgPT4ge1xuICAgICAgZXhwZWN0KHdvcmxkR2VuZXJhdG9yLmxheWVyQ291bnQoMTYpKS50b0VxdWFsKDMpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3JldHVybnMgMiBmb3Igc3Vic2VxdWVudCBzdHJpZGVzJywgKCkgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDMyOyBpIDwgMTAyNDsgaSs9aSkge1xuICAgICAgICBleHBlY3Qod29ybGRHZW5lcmF0b3IubGF5ZXJDb3VudChpKSkudG9FcXVhbCgyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dlbmVyYXRlIHBvaW50cycsICgpID0+IHtcbiAgICBpdCgncmV0dXJucyB0aGUgY29ycmVjdCB2YWx1ZXMnLCAoKSA9PiB7XG4gICAgICBleHBlY3QoZ2VuZXJhdGVQb2ludHMoMSkpLnRvRXF1YWwoW1xuICAgICAgICB7IHg6IC0xLCB5OiAtMSwgejogLTEgfSxcbiAgICAgICAgeyB4OiAtMSwgeTogLTEsIHo6IDEgfSxcbiAgICAgICAgeyB4OiAtMSwgeTogMSwgejogLTEgfSxcbiAgICAgICAgeyB4OiAtMSwgeTogMSwgejogMSB9LFxuICAgICAgICB7IHg6IDEsIHk6IC0xLCB6OiAtMSB9LFxuICAgICAgICB7IHg6IDEsIHk6IC0xLCB6OiAxIH0sXG4gICAgICAgIHsgeDogMSwgeTogMSwgejogLTEgfSxcbiAgICAgICAgeyB4OiAxLCB5OiAxLCB6OiAxIH0sXG4gICAgICBdKTtcbiAgICB9KTtcblxuICAgIGl0KCdyZXR1cm5zIHRoZSBjb3JyZWN0IHZhbHVlcyAyJywgKCkgPT4ge1xuICAgICAgZXhwZWN0KGdlbmVyYXRlUG9pbnRzKDIpLmxlbmd0aCkudG9FcXVhbCg1Nik7XG4gICAgfSk7XG4gIH0pXG59KTsiLCJleHBvcnQgaW50ZXJmYWNlIFdvcmxkR2VuZXJhdG9ySW5mbyB7XG4gIHg6IG51bWJlcjtcbiAgeTogbnVtYmVyO1xuICB6OiBudW1iZXI7XG4gIHN0cmlkZTogbnVtYmVyO1xuICBpdGVyYXRpb246IG51bWJlcjtcbiAgbGF5ZXI6IG51bWJlcjtcbiAgcHJldmlvdXNPZmZzZXQ6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFdvcmxkUG9zaXRpb24ge1xuICB4OiBudW1iZXI7XG4gIHk6IG51bWJlcjtcbiAgejogbnVtYmVyO1xuICBzdHJpZGU6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFBvaW50IHtcbiAgeDogbnVtYmVyO1xuICB5OiBudW1iZXI7XG4gIHo6IG51bWJlcjtcbn1cblxuZnVuY3Rpb24gZml4UG9pbnQoaTogbnVtYmVyKTogbnVtYmVyIHtcbiAgaWYgKGkgPj0gMCkgcmV0dXJuIGkgKyAxO1xuICByZXR1cm4gaTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUG9pbnRzKHJhZGl1czogbnVtYmVyKTogUG9pbnRbXSB7XG4gIGxldCBwb2ludHM6IFBvaW50W10gPSBbXTtcblxuICBsZXQgZGlhbWV0ZXIgPSByYWRpdXMgKiAyO1xuXG4gIGZvciAobGV0IHggPSAwOyB4IDwgZGlhbWV0ZXI7IHgrKylcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGRpYW1ldGVyOyB5KyspXG4gICAgICBmb3IgKGxldCB6ID0gMDsgeiA8IGRpYW1ldGVyOyB6KyspIHtcbiAgICAgICAgaWYgKCEoeCA9PT0gMCB8fCB4ID09PSBkaWFtZXRlciAtIDEgfHwgeSA9PT0gMCB8fCB5ID09PSBkaWFtZXRlciAtIDEgfHwgeiA9PT0gMCB8fCB6ID09PSBkaWFtZXRlciAtIDEpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBvaW50ID0ge1xuICAgICAgICAgIHg6IGZpeFBvaW50KHggLSByYWRpdXMpLFxuICAgICAgICAgIHk6IGZpeFBvaW50KHkgLSByYWRpdXMpLFxuICAgICAgICAgIHo6IGZpeFBvaW50KHogLSByYWRpdXMpXG4gICAgICAgIH07XG5cbiAgICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgfVxuXG4gIHJldHVybiBwb2ludHM7XG59XG5cbmNvbnN0IHBvaW50cyA9IFtdO1xuXG5mb3IgKGxldCBpID0gMDsgaSA8PSA2OyBpKyspIHtcbiAgcG9pbnRzW2ldID0gZ2VuZXJhdGVQb2ludHMoaSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdvcmxkR2VuZXJhdG9yIHtcbiAgcHJpdmF0ZSByZWFkb25seSBtaW5TdHJpZGU6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihtaW5TdHJpZGU6IG51bWJlcikge1xuICAgIHRoaXMubWluU3RyaWRlID0gbWluU3RyaWRlO1xuICB9XG5cbiAgaW5pdCh4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyKTogV29ybGRHZW5lcmF0b3JJbmZvIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogTWF0aC5yb3VuZCh4IC8gdGhpcy5taW5TdHJpZGUpICogdGhpcy5taW5TdHJpZGUsXG4gICAgICB5OiBNYXRoLnJvdW5kKHkgLyB0aGlzLm1pblN0cmlkZSkgKiB0aGlzLm1pblN0cmlkZSxcbiAgICAgIHo6IE1hdGgucm91bmQoeiAvIHRoaXMubWluU3RyaWRlKSAqIHRoaXMubWluU3RyaWRlLFxuICAgICAgc3RyaWRlOiB0aGlzLm1pblN0cmlkZSxcbiAgICAgIGl0ZXJhdGlvbjogMCxcbiAgICAgIGxheWVyOiAxLFxuICAgICAgcHJldmlvdXNPZmZzZXQ6IC0xICogdGhpcy5taW5TdHJpZGUgLyAyXG4gICAgfTtcbiAgfVxuXG4gIGxheWVyUmFkaXVzKGxheWVyOiBudW1iZXIsIHN0cmlkZTogbnVtYmVyKSB7XG4gICAgaWYgKHN0cmlkZSA9PT0gdGhpcy5taW5TdHJpZGUpIHtcbiAgICAgIHJldHVybiBsYXllcjtcbiAgICB9XG4gICAgaWYgKHN0cmlkZSA9PT0gdGhpcy5taW5TdHJpZGUgKiAyKSB7XG4gICAgICByZXR1cm4gbGF5ZXIgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gbGF5ZXIgKyAyO1xuICB9XG5cbiAgcmFkaXVzKGxheWVyOiBudW1iZXIsIHN0cmlkZTogbnVtYmVyLCBwcmV2aW91c09mZnNldDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5zaWduKGxheWVyKSAqIChwcmV2aW91c09mZnNldCArIChNYXRoLmFicyhsYXllcikgKiBzdHJpZGUpKTtcbiAgfVxuXG4gIGxheWVyQ291bnQoc3RyaWRlOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChzdHJpZGUgPT0gdGhpcy5taW5TdHJpZGUgKiAyKVxuICAgICAgcmV0dXJuIDM7XG4gICAgcmV0dXJuIDI7XG4gIH1cblxuICBuZXh0KGluZm86IFdvcmxkR2VuZXJhdG9ySW5mbyk6IFtXb3JsZFBvc2l0aW9uLCBXb3JsZEdlbmVyYXRvckluZm9dIHtcbiAgICBjb25zdCBvZmZzZXRzID0gcG9pbnRzW3RoaXMubGF5ZXJSYWRpdXMoaW5mby5sYXllciwgaW5mby5zdHJpZGUpXTtcblxuICAgIGNvbnN0IG9mZnNldCA9IG9mZnNldHNbaW5mby5pdGVyYXRpb25dO1xuICAgIGNvbnN0IGhhbGZTdHJpZGUgPSBpbmZvLnN0cmlkZSAvIDI7XG5cbiAgICBsZXQgaXRlcmF0aW9uID0gaW5mby5pdGVyYXRpb24gKyAxO1xuICAgIGxldCBsYXllciA9IGluZm8ubGF5ZXI7XG4gICAgbGV0IHN0cmlkZSA9IGluZm8uc3RyaWRlO1xuICAgIGxldCBwcmV2aW91c09mZnNldCA9IGluZm8ucHJldmlvdXNPZmZzZXQ7XG5cbiAgICBpZiAoaXRlcmF0aW9uID49IG9mZnNldHMubGVuZ3RoKSB7XG4gICAgICBpdGVyYXRpb24gPSAwO1xuICAgICAgbGF5ZXIrKztcblxuICAgICAgY29uc3QgbGF5ZXJDb3VudCA9IHRoaXMubGF5ZXJDb3VudChpbmZvLnN0cmlkZSk7XG4gICAgICBpZiAobGF5ZXIgPiBsYXllckNvdW50KSB7XG4gICAgICAgIGxheWVyID0gMTtcbiAgICAgICAgc3RyaWRlICo9IDI7XG4gICAgICAgIHByZXZpb3VzT2Zmc2V0ID0gdGhpcy5yYWRpdXMoaW5mby5sYXllciwgaW5mby5zdHJpZGUsIGluZm8ucHJldmlvdXNPZmZzZXQpIC0gaW5mby5zdHJpZGUgLyAyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB4OiBpbmZvLnN0cmlkZSAqIG9mZnNldC54ICsgaW5mby54IC0gTWF0aC5zaWduKG9mZnNldC54KSAqIGhhbGZTdHJpZGUsXG4gICAgICAgIHk6IGluZm8uc3RyaWRlICogb2Zmc2V0LnkgKyBpbmZvLnkgLSBNYXRoLnNpZ24ob2Zmc2V0LnkpICogaGFsZlN0cmlkZSxcbiAgICAgICAgejogaW5mby5zdHJpZGUgKiBvZmZzZXQueiArIGluZm8ueiAtIE1hdGguc2lnbihvZmZzZXQueikgKiBoYWxmU3RyaWRlLFxuICAgICAgICBzdHJpZGU6IGluZm8uc3RyaWRlXG4gICAgICB9LFxuICAgICAgeyAuLi5pbmZvLCBpdGVyYXRpb24sIGxheWVyLCBzdHJpZGUsIHByZXZpb3VzT2Zmc2V0IH1cbiAgICBdO1xuICB9XG59IiwidmFyIG1hcCA9IHtcblx0XCIuL2NvbXB1dGUtdm94ZWxzLnRlc3QudHNcIjogXCIuL3NyYy9jb21wdXRlLXZveGVscy50ZXN0LnRzXCIsXG5cdFwiLi9yZW5kZXJlci50ZXN0LnRzXCI6IFwiLi9zcmMvcmVuZGVyZXIudGVzdC50c1wiLFxuXHRcIi4vd29ybGQtZ2VuZXJhdG9yLnRlc3QudHNcIjogXCIuL3NyYy93b3JsZC1nZW5lcmF0b3IudGVzdC50c1wiXG59O1xuXG5cbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0KHJlcSkge1xuXHR2YXIgaWQgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKTtcblx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oaWQpO1xufVxuZnVuY3Rpb24gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkge1xuXHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKG1hcCwgcmVxKSkge1xuXHRcdHZhciBlID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJ1wiKTtcblx0XHRlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG5cdFx0dGhyb3cgZTtcblx0fVxuXHRyZXR1cm4gbWFwW3JlcV07XG59XG53ZWJwYWNrQ29udGV4dC5rZXlzID0gZnVuY3Rpb24gd2VicGFja0NvbnRleHRLZXlzKCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMobWFwKTtcbn07XG53ZWJwYWNrQ29udGV4dC5yZXNvbHZlID0gd2VicGFja0NvbnRleHRSZXNvbHZlO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrQ29udGV4dDtcbndlYnBhY2tDb250ZXh0LmlkID0gXCIuL3NyYyBzeW5jIHJlY3Vyc2l2ZSAudGVzdC4oanx0KXMkXCI7IiwiLyogKGlnbm9yZWQpICovIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0aWYoX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSkge1xuXHRcdHJldHVybiBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0aWQ6IG1vZHVsZUlkLFxuXHRcdGxvYWRlZDogZmFsc2UsXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuXHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIl9fd2VicGFja19yZXF1aXJlX18uYW1kRCA9IGZ1bmN0aW9uICgpIHtcblx0dGhyb3cgbmV3IEVycm9yKCdkZWZpbmUgY2Fubm90IGJlIHVzZWQgaW5kaXJlY3QnKTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5hbWRPID0ge307IiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm5tZCA9IChtb2R1bGUpID0+IHtcblx0bW9kdWxlLnBhdGhzID0gW107XG5cdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0cmV0dXJuIG1vZHVsZTtcbn07IiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGVcbl9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy90ZXN0cy50c1wiKTtcbi8vIFRoaXMgZW50cnkgbW9kdWxlIHVzZWQgJ2V4cG9ydHMnIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbiJdLCJzb3VyY2VSb290IjoiIn0=