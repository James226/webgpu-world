/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/jasmine-core/lib/jasmine-core/jasmine.css":
/*!******************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/jasmine-core/lib/jasmine-core/jasmine.css ***!
  \******************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "@charset \"UTF-8\";\nbody {\n  overflow-y: scroll;\n}\n\n.jasmine_html-reporter {\n  width: 100%;\n  background-color: #eee;\n  padding: 5px;\n  margin: -8px;\n  font-size: 11px;\n  font-family: Monaco, \"Lucida Console\", monospace;\n  line-height: 14px;\n  color: #333;\n}\n.jasmine_html-reporter a {\n  text-decoration: none;\n}\n.jasmine_html-reporter a:hover {\n  text-decoration: underline;\n}\n.jasmine_html-reporter p, .jasmine_html-reporter h1, .jasmine_html-reporter h2, .jasmine_html-reporter h3, .jasmine_html-reporter h4, .jasmine_html-reporter h5, .jasmine_html-reporter h6 {\n  margin: 0;\n  line-height: 14px;\n}\n.jasmine_html-reporter .jasmine-banner,\n.jasmine_html-reporter .jasmine-symbol-summary,\n.jasmine_html-reporter .jasmine-summary,\n.jasmine_html-reporter .jasmine-result-message,\n.jasmine_html-reporter .jasmine-spec .jasmine-description,\n.jasmine_html-reporter .jasmine-spec-detail .jasmine-description,\n.jasmine_html-reporter .jasmine-alert .jasmine-bar,\n.jasmine_html-reporter .jasmine-stack-trace {\n  padding-left: 9px;\n  padding-right: 9px;\n}\n.jasmine_html-reporter .jasmine-banner {\n  position: relative;\n}\n.jasmine_html-reporter .jasmine-banner .jasmine-title {\n  background: url(\"data:image/png;base64,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\") no-repeat;\n  background: url(\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgdmVyc2lvbj0iMS4xIgogICB3aWR0aD0iNjgxLjk2MjUyIgogICBoZWlnaHQ9IjE4Ny41IgogICBpZD0ic3ZnMiIKICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhOCI+PHJkZjpSREY+PGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPjxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PjxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz48L2NjOldvcms+PC9yZGY6UkRGPjwvbWV0YWRhdGE+PGRlZnMKICAgICBpZD0iZGVmczYiPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMTgiPjxwYXRoCiAgICAgICAgIGQ9Ik0gMCwxNTAwIDAsMCBsIDU0NTUuNzQsMCAwLDE1MDAgTCAwLDE1MDAgeiIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgaWQ9InBhdGgyMCIgLz48L2NsaXBQYXRoPjwvZGVmcz48ZwogICAgIHRyYW5zZm9ybT0ibWF0cml4KDEuMjUsMCwwLC0xLjI1LDAsMTg3LjUpIgogICAgIGlkPSJnMTAiPjxnCiAgICAgICB0cmFuc2Zvcm09InNjYWxlKDAuMSwwLjEpIgogICAgICAgaWQ9ImcxMiI+PGcKICAgICAgICAgaWQ9ImcxNCI+PGcKICAgICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGgxOCkiCiAgICAgICAgICAgaWQ9ImcxNiI+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMTU0NCw1OTkuNDM0IGMgMC45MiwtNDAuMzUyIDI1LjY4LC04MS42MDIgNzEuNTMsLTgxLjYwMiAyNy41MSwwIDQ3LjY4LDEyLjgzMiA2MS40NCwzNS43NTQgMTIuODMsMjIuOTMgMTIuODMsNTYuODUyIDEyLjgzLDgyLjUyNyBsIDAsMzI5LjE4NCAtNzEuNTIsMCAwLDEwNC41NDMgMjY2LjgzLDAgMCwtMTA0LjU0MyAtNzAuNiwwIDAsLTM0NC43NyBjIDAsLTU4LjY5MSAtMy42OCwtMTA0LjUzMSAtNDQuOTMsLTE1Mi4yMTggLTM2LjY4LC00Mi4xOCAtOTYuMjgsLTY2LjAyIC0xNTMuMTQsLTY2LjAyIC0xMTcuMzcsMCAtMjA3LjI0LDc3Ljk0MSAtMjAyLjY0LDE5Ny4xNDUgbCAxMzAuMiwwIgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMjIiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDIzMDEuNCw2NjIuNjk1IGMgMCw4MC43MDMgLTY2Ljk0LDE0NS44MTMgLTE0Ny42MywxNDUuODEzIC04My40NCwwIC0xNDcuNjMsLTY4Ljc4MSAtMTQ3LjYzLC0xNTEuMzAxIDAsLTc5Ljc4NSA2Ni45NCwtMTQ1LjgwMSAxNDUuOCwtMTQ1LjgwMSA4NC4zNSwwIDE0OS40Niw2Ny44NTIgMTQ5LjQ2LDE1MS4yODkgeiBtIC0xLjgzLC0xODEuNTQ3IGMgLTM1Ljc3LC01NC4wOTcgLTkzLjUzLC03OC44NTkgLTE1Ny43MiwtNzguODU5IC0xNDAuMywwIC0yNTEuMjQsMTE2LjQ0OSAtMjUxLjI0LDI1NC45MTggMCwxNDIuMTI5IDExMy43LDI2MC40MSAyNTYuNzQsMjYwLjQxIDYzLjI3LDAgMTE4LjI5LC0yOS4zMzYgMTUyLjIyLC04Mi41MjMgbCAwLDY5LjY4NyAxNzUuMTQsMCAwLC0xMDQuNTI3IC02MS40NCwwIDAsLTI4MC41OTggNjEuNDQsMCAwLC0xMDQuNTI3IC0xNzUuMTQsMCAwLDY2LjAxOSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDI0IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSAyNjIyLjMzLDU1Ny4yNTggYyAzLjY3LC00NC4wMTYgMzMuMDEsLTczLjM0OCA3OC44NiwtNzMuMzQ4IDMzLjkzLDAgNjYuOTMsMjMuODI0IDY2LjkzLDYwLjUwNCAwLDQ4LjYwNiAtNDUuODQsNTYuODU2IC04My40NCw2Ni45NDEgLTg1LjI4LDIyLjAwNCAtMTc4LjgxLDQ4LjYwNiAtMTc4LjgxLDE1NS44NzkgMCw5My41MzYgNzguODYsMTQ3LjYzMyAxNjUuOTgsMTQ3LjYzMyA0NCwwIDgzLjQzLC05LjE3NiAxMTAuOTQsLTQ0LjAwOCBsIDAsMzMuOTIyIDgyLjUzLDAgMCwtMTMyLjk2NSAtMTA4LjIxLDAgYyAtMS44MywzNC44NTYgLTI4LjQyLDU3Ljc3NCAtNjMuMjYsNTcuNzc0IC0zMC4yNiwwIC02Mi4zNSwtMTcuNDIyIC02Mi4zNSwtNTEuMzQ4IDAsLTQ1Ljg0NyA0NC45MywtNTUuOTMgODAuNjksLTY0LjE4IDg4LjAyLC0yMC4xNzUgMTgyLjQ3LC00Ny42OTUgMTgyLjQ3LC0xNTcuNzM0IDAsLTk5LjAyNyAtODMuNDQsLTE1NC4wMzkgLTE3NS4xMywtMTU0LjAzOSAtNDkuNTMsMCAtOTQuNDYsMTUuNTgyIC0xMjYuNTUsNTMuMTggbCAwLC00MC4zNCAtODUuMjcsMCAwLDE0Mi4xMjkgMTE0LjYyLDAiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGgyNiIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMjk4OC4xOCw4MDAuMjU0IC02My4yNiwwIDAsMTA0LjUyNyAxNjUuMDUsMCAwLC03My4zNTUgYyAzMS4xOCw1MS4zNDcgNzguODYsODUuMjc3IDE0MS4yMSw4NS4yNzcgNjcuODUsMCAxMjQuNzEsLTQxLjI1OCAxNTIuMjEsLTEwMi42OTkgMjYuNiw2Mi4zNTEgOTIuNjIsMTAyLjY5OSAxNjAuNDcsMTAyLjY5OSA1My4xOSwwIDEwNS40NiwtMjIgMTQxLjIxLC02Mi4zNTEgMzguNTIsLTQ0LjkzOCAzOC41MiwtOTMuNTMyIDM4LjUyLC0xNDkuNDU3IGwgMCwtMTg1LjIzOSA2My4yNywwIDAsLTEwNC41MjcgLTIzOC40MiwwIDAsMTA0LjUyNyA2My4yOCwwIDAsMTU3LjcxNSBjIDAsMzIuMTAyIDAsNjAuNTI3IC0xNC42Nyw4OC45NTcgLTE4LjM0LDI2LjU4MiAtNDguNjEsNDAuMzQ0IC03OS43Nyw0MC4zNDQgLTMwLjI2LDAgLTYzLjI4LC0xMi44NDQgLTgyLjUzLC0zNi42NzIgLTIyLjkzLC0yOS4zNTUgLTIyLjkzLC01Ni44NjMgLTIyLjkzLC05Mi42MjkgbCAwLC0xNTcuNzE1IDYzLjI3LDAgMCwtMTA0LjUyNyAtMjM4LjQxLDAgMCwxMDQuNTI3IDYzLjI4LDAgMCwxNTAuMzgzIGMgMCwyOS4zNDggMCw2Ni4wMjMgLTE0LjY3LDkxLjY5OSAtMTUuNTksMjkuMzM2IC00Ny42OSw0NC45MzQgLTgwLjcsNDQuOTM0IC0zMS4xOCwwIC01Ny43NywtMTEuMDA4IC03Ny45NCwtMzUuNzc0IC0yNC43NywtMzAuMjUzIC0yNi42LC02Mi4zNDMgLTI2LjYsLTk5Ljk0MSBsIDAsLTE1MS4zMDEgNjMuMjcsMCAwLC0xMDQuNTI3IC0yMzguNCwwIDAsMTA0LjUyNyA2My4yNiwwIDAsMjgwLjU5OCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDI4IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSAzOTk4LjY2LDk1MS41NDcgLTExMS44NywwIDAsMTE4LjI5MyAxMTEuODcsMCAwLC0xMTguMjkzIHogbSAwLC00MzEuODkxIDYzLjI3LDAgMCwtMTA0LjUyNyAtMjM5LjMzLDAgMCwxMDQuNTI3IDY0LjE5LDAgMCwyODAuNTk4IC02My4yNywwIDAsMTA0LjUyNyAxNzUuMTQsMCAwLC0zODUuMTI1IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzAiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDQxNTkuMTIsODAwLjI1NCAtNjMuMjcsMCAwLDEwNC41MjcgMTc1LjE0LDAgMCwtNjkuNjg3IGMgMjkuMzUsNTQuMTAxIDg0LjM2LDgwLjY5OSAxNDQuODcsODAuNjk5IDUzLjE5LDAgMTA1LjQ1LC0yMi4wMTYgMTQxLjIyLC02MC41MjcgNDAuMzQsLTQ0LjkzNCA0MS4yNiwtODguMDMyIDQxLjI2LC0xNDMuOTU3IGwgMCwtMTkxLjY1MyA2My4yNywwIDAsLTEwNC41MjcgLTIzOC40LDAgMCwxMDQuNTI3IDYzLjI2LDAgMCwxNTguNjM3IGMgMCwzMC4yNjIgMCw2MS40MzQgLTE5LjI2LDg4LjAzNSAtMjAuMTcsMjYuNTgyIC01My4xOCwzOS40MTQgLTg2LjE5LDM5LjQxNCAtMzMuOTMsMCAtNjguNzcsLTEzLjc1IC04OC45NCwtNDEuMjUgLTIxLjA5LC0yNy41IC0yMS4wOSwtNjkuNjg3IC0yMS4wOSwtMTAyLjcwNyBsIDAsLTE0Mi4xMjkgNjMuMjYsMCAwLC0xMDQuNTI3IC0yMzguNCwwIDAsMTA0LjUyNyA2My4yNywwIDAsMjgwLjU5OCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDMyIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA1MDgyLjQ4LDcwMy45NjUgYyAtMTkuMjQsNzAuNjA1IC04MS42LDExNS41NDcgLTE1NC4wNCwxMTUuNTQ3IC02Ni4wNCwwIC0xMjkuMywtNTEuMzQ4IC0xNDMuMDUsLTExNS41NDcgbCAyOTcuMDksMCB6IG0gODUuMjcsLTE0NC44ODMgYyAtMzguNTEsLTkzLjUyMyAtMTI5LjI3LC0xNTYuNzkzIC0yMzEuMDUsLTE1Ni43OTMgLTE0My4wNywwIC0yNTcuNjgsMTExLjg3MSAtMjU3LjY4LDI1NS44MzYgMCwxNDQuODgzIDEwOS4xMiwyNjEuMzI4IDI1NC45MSwyNjEuMzI4IDY3Ljg3LDAgMTM1LjcyLC0zMC4yNTggMTgzLjM5LC03OC44NjMgNDguNjIsLTUxLjM0NCA2OC43OSwtMTEzLjY5NSA2OC43OSwtMTgzLjM4MyBsIC0zLjY3LC0zOS40MzQgLTM5Ni4xMywwIGMgMTQuNjcsLTY3Ljg2MyA3Ny4wMywtMTE3LjM2MyAxNDYuNzIsLTExNy4zNjMgNDguNTksMCA5MC43NiwxOC4zMjggMTE4LjI4LDU4LjY3MiBsIDExNi40NCwwIgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzQiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDY5MC44OTUsODUwLjcwMyA5MC43NSwwIDIyLjU0MywzMS4wMzUgMCwyNDMuMTIyIC0xMzUuODI5LDAgMCwtMjQzLjE0MSAyMi41MzYsLTMxLjAxNiIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDM2IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA2MzIuMzk1LDc0Mi4yNTggMjguMDM5LDg2LjMwNCAtMjIuNTUxLDMxLjA0IC0yMzEuMjIzLDc1LjEyOCAtNDEuOTc2LC0xMjkuMTgzIDIzMS4yNTcsLTc1LjEzNyAzNi40NTQsMTEuODQ4IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzgiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDcxNy40NDksNjUzLjEwNSAtNzMuNDEsNTMuMzYgLTM2LjQ4OCwtMTEuODc1IC0xNDIuOTAzLC0xOTYuNjkyIDEwOS44ODMsLTc5LjgyOCAxNDIuOTE4LDE5Ni43MDMgMCwzOC4zMzIiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGg0MCIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gODI4LjUyLDcwNi40NjUgLTczLjQyNiwtNTMuMzQgMC4wMTEsLTM4LjM1OSBMIDg5OC4wMDQsNDE4LjA3IDEwMDcuOSw0OTcuODk4IDg2NC45NzMsNjk0LjYwOSA4MjguNTIsNzA2LjQ2NSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDQyIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA4MTIuMDg2LDgyOC41ODYgMjguMDU1LC04Ni4zMiAzNi40ODQsLTExLjgzNiAyMzEuMjI1LDc1LjExNyAtNDEuOTcsMTI5LjE4MyAtMjMxLjIzOSwtNzUuMTQgLTIyLjU1NSwtMzEuMDA0IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNDQiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDczNi4zMDEsMTMzNS44OCBjIC0zMjMuMDQ3LDAgLTU4NS44NzUsLTI2Mi43OCAtNTg1Ljg3NSwtNTg1Ljc4MiAwLC0zMjMuMTE4IDI2Mi44MjgsLTU4NS45NzcgNTg1Ljg3NSwtNTg1Ljk3NyAzMjMuMDE5LDAgNTg1LjgwOSwyNjIuODU5IDU4NS44MDksNTg1Ljk3NyAwLDMyMy4wMDIgLTI2Mi43OSw1ODUuNzgyIC01ODUuODA5LDU4NS43ODIgbCAwLDAgeiBtIDAsLTExOC42MSBjIDI1Ny45NzIsMCA0NjcuMTg5LC0yMDkuMTMgNDY3LjE4OSwtNDY3LjE3MiAwLC0yNTguMTI5IC0yMDkuMjE3LC00NjcuMzQ4IC00NjcuMTg5LC00NjcuMzQ4IC0yNTguMDc0LDAgLTQ2Ny4yNTQsMjA5LjIxOSAtNDY3LjI1NCw0NjcuMzQ4IDAsMjU4LjA0MiAyMDkuMTgsNDY3LjE3MiA0NjcuMjU0LDQ2Ny4xNzIiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGg0NiIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMTA5MS4xMyw2MTkuODgzIC0xNzUuNzcxLDU3LjEyMSAxMS42MjksMzUuODA4IDE3NS43NjIsLTU3LjEyMSAtMTEuNjIsLTM1LjgwOCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDQ4IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0iTSA4NjYuOTU3LDkwMi4wNzQgODM2LjUsOTI0LjE5OSA5NDUuMTIxLDEwNzMuNzMgOTc1LjU4NiwxMDUxLjYxIDg2Ni45NTcsOTAyLjA3NCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDUwIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0iTSA2MDcuNDY1LDkwMy40NDUgNDk4Ljg1NSwxMDUyLjk3IDUyOS4zMiwxMDc1LjEgNjM3LjkzLDkyNS41NjYgNjA3LjQ2NSw5MDMuNDQ1IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNTIiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDM4MC42ODgsNjIyLjEyOSAtMTEuNjI2LDM1LjgwMSAxNzUuNzU4LDU3LjA5IDExLjYyMSwtMzUuODAxIC0xNzUuNzUzLC01Ny4wOSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDU0IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA3MTYuMjg5LDM3Ni41OSAzNy42NDA2LDAgMCwxODQuODE2IC0zNy42NDA2LDAgMCwtMTg0LjgxNiB6IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNTYiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjwvZz48L2c+PC9nPjwvZz48L3N2Zz4=\") no-repeat, none;\n  -moz-background-size: 100%;\n  -o-background-size: 100%;\n  -webkit-background-size: 100%;\n  background-size: 100%;\n  display: block;\n  float: left;\n  width: 90px;\n  height: 25px;\n}\n.jasmine_html-reporter .jasmine-banner .jasmine-version {\n  margin-left: 14px;\n  position: relative;\n  top: 6px;\n}\n.jasmine_html-reporter #jasmine_content {\n  position: fixed;\n  right: 100%;\n}\n.jasmine_html-reporter .jasmine-version {\n  color: #aaa;\n}\n.jasmine_html-reporter .jasmine-banner {\n  margin-top: 14px;\n}\n.jasmine_html-reporter .jasmine-duration {\n  color: #fff;\n  float: right;\n  line-height: 28px;\n  padding-right: 9px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary {\n  overflow: hidden;\n  margin: 14px 0;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li {\n  display: inline-block;\n  height: 10px;\n  width: 14px;\n  font-size: 16px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-passed {\n  font-size: 14px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-passed:before {\n  color: #007069;\n  content: \"•\";\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-failed {\n  line-height: 9px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-failed:before {\n  color: #ca3a11;\n  content: \"×\";\n  font-weight: bold;\n  margin-left: -1px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-excluded {\n  font-size: 14px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-excluded:before {\n  color: #bababa;\n  content: \"•\";\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-excluded-no-display {\n  font-size: 14px;\n  display: none;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-pending {\n  line-height: 17px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-pending:before {\n  color: #ba9d37;\n  content: \"*\";\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-empty {\n  font-size: 14px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-empty:before {\n  color: #ba9d37;\n  content: \"•\";\n}\n.jasmine_html-reporter .jasmine-run-options {\n  float: right;\n  margin-right: 5px;\n  border: 1px solid #8a4182;\n  color: #8a4182;\n  position: relative;\n  line-height: 20px;\n}\n.jasmine_html-reporter .jasmine-run-options .jasmine-trigger {\n  cursor: pointer;\n  padding: 8px 16px;\n}\n.jasmine_html-reporter .jasmine-run-options .jasmine-payload {\n  position: absolute;\n  display: none;\n  right: -1px;\n  border: 1px solid #8a4182;\n  background-color: #eee;\n  white-space: nowrap;\n  padding: 4px 8px;\n}\n.jasmine_html-reporter .jasmine-run-options .jasmine-payload.jasmine-open {\n  display: block;\n}\n.jasmine_html-reporter .jasmine-bar {\n  line-height: 28px;\n  font-size: 14px;\n  display: block;\n  color: #eee;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-failed, .jasmine_html-reporter .jasmine-bar.jasmine-errored {\n  background-color: #ca3a11;\n  border-bottom: 1px solid #eee;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-passed {\n  background-color: #007069;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-incomplete {\n  background-color: #bababa;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-skipped {\n  background-color: #bababa;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-warning {\n  margin-top: 14px;\n  margin-bottom: 14px;\n  background-color: #ba9d37;\n  color: #333;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-menu {\n  background-color: #fff;\n  color: #aaa;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-menu a {\n  color: #333;\n}\n.jasmine_html-reporter .jasmine-bar a {\n  color: white;\n}\n.jasmine_html-reporter.jasmine-spec-list .jasmine-bar.jasmine-menu.jasmine-failure-list,\n.jasmine_html-reporter.jasmine-spec-list .jasmine-results .jasmine-failures {\n  display: none;\n}\n.jasmine_html-reporter.jasmine-failure-list .jasmine-bar.jasmine-menu.jasmine-spec-list,\n.jasmine_html-reporter.jasmine-failure-list .jasmine-summary {\n  display: none;\n}\n.jasmine_html-reporter .jasmine-results {\n  margin-top: 14px;\n}\n.jasmine_html-reporter .jasmine-summary {\n  margin-top: 14px;\n}\n.jasmine_html-reporter .jasmine-summary ul {\n  list-style-type: none;\n  margin-left: 14px;\n  padding-top: 0;\n  padding-left: 0;\n}\n.jasmine_html-reporter .jasmine-summary ul.jasmine-suite {\n  margin-top: 7px;\n  margin-bottom: 7px;\n}\n.jasmine_html-reporter .jasmine-summary li.jasmine-passed a {\n  color: #007069;\n}\n.jasmine_html-reporter .jasmine-summary li.jasmine-failed a {\n  color: #ca3a11;\n}\n.jasmine_html-reporter .jasmine-summary li.jasmine-empty a {\n  color: #ba9d37;\n}\n.jasmine_html-reporter .jasmine-summary li.jasmine-pending a {\n  color: #ba9d37;\n}\n.jasmine_html-reporter .jasmine-summary li.jasmine-excluded a {\n  color: #bababa;\n}\n.jasmine_html-reporter .jasmine-specs li.jasmine-passed a:before {\n  content: \"• \";\n}\n.jasmine_html-reporter .jasmine-specs li.jasmine-failed a:before {\n  content: \"× \";\n}\n.jasmine_html-reporter .jasmine-specs li.jasmine-empty a:before {\n  content: \"* \";\n}\n.jasmine_html-reporter .jasmine-specs li.jasmine-pending a:before {\n  content: \"• \";\n}\n.jasmine_html-reporter .jasmine-specs li.jasmine-excluded a:before {\n  content: \"• \";\n}\n.jasmine_html-reporter .jasmine-description + .jasmine-suite {\n  margin-top: 0;\n}\n.jasmine_html-reporter .jasmine-suite {\n  margin-top: 14px;\n}\n.jasmine_html-reporter .jasmine-suite a {\n  color: #333;\n}\n.jasmine_html-reporter .jasmine-failures .jasmine-spec-detail {\n  margin-bottom: 28px;\n}\n.jasmine_html-reporter .jasmine-failures .jasmine-spec-detail .jasmine-description {\n  background-color: #ca3a11;\n  color: white;\n}\n.jasmine_html-reporter .jasmine-failures .jasmine-spec-detail .jasmine-description a {\n  color: white;\n}\n.jasmine_html-reporter .jasmine-result-message {\n  padding-top: 14px;\n  color: #333;\n  white-space: pre-wrap;\n}\n.jasmine_html-reporter .jasmine-result-message span.jasmine-result {\n  display: block;\n}\n.jasmine_html-reporter .jasmine-stack-trace {\n  margin: 5px 0 0 0;\n  max-height: 224px;\n  overflow: auto;\n  line-height: 18px;\n  color: #666;\n  border: 1px solid #ddd;\n  background: white;\n  white-space: pre;\n}\n.jasmine_html-reporter .jasmine-expander a {\n  display: block;\n  margin-left: 14px;\n  color: blue;\n  text-decoration: underline;\n}\n.jasmine_html-reporter .jasmine-expander-contents {\n  display: none;\n}\n.jasmine_html-reporter .jasmine-expanded {\n  padding-bottom: 10px;\n}\n.jasmine_html-reporter .jasmine-expanded .jasmine-expander-contents {\n  display: block;\n  margin-left: 14px;\n  padding: 5px;\n}\n.jasmine_html-reporter .jasmine-debug-log {\n  margin: 5px 0 0 0;\n  padding: 5px;\n  color: #666;\n  border: 1px solid #ddd;\n  background: white;\n}\n.jasmine_html-reporter .jasmine-debug-log table {\n  border-spacing: 0;\n}\n.jasmine_html-reporter .jasmine-debug-log table, .jasmine_html-reporter .jasmine-debug-log th, .jasmine_html-reporter .jasmine-debug-log td {\n  border: 1px solid #ddd;\n}", "",{"version":3,"sources":["webpack://./node_modules/jasmine-core/lib/jasmine-core/jasmine.css"],"names":[],"mappings":"AAAA,gBAAgB;AAChB;EACE,kBAAkB;AACpB;;AAEA;EACE,WAAW;EACX,sBAAsB;EACtB,YAAY;EACZ,YAAY;EACZ,eAAe;EACf,gDAAgD;EAChD,iBAAiB;EACjB,WAAW;AACb;AACA;EACE,qBAAqB;AACvB;AACA;EACE,0BAA0B;AAC5B;AACA;EACE,SAAS;EACT,iBAAiB;AACnB;AACA;;;;;;;;EAQE,iBAAiB;EACjB,kBAAkB;AACpB;AACA;EACE,kBAAkB;AACpB;AACA;EACE,myEAAmyE;EACnyE,ikXAAikX;EACjkX,0BAA0B;EAC1B,wBAAwB;EACxB,6BAA6B;EAC7B,qBAAqB;EACrB,cAAc;EACd,WAAW;EACX,WAAW;EACX,YAAY;AACd;AACA;EACE,iBAAiB;EACjB,kBAAkB;EAClB,QAAQ;AACV;AACA;EACE,eAAe;EACf,WAAW;AACb;AACA;EACE,WAAW;AACb;AACA;EACE,gBAAgB;AAClB;AACA;EACE,WAAW;EACX,YAAY;EACZ,iBAAiB;EACjB,kBAAkB;AACpB;AACA;EACE,gBAAgB;EAChB,cAAc;AAChB;AACA;EACE,qBAAqB;EACrB,YAAY;EACZ,WAAW;EACX,eAAe;AACjB;AACA;EACE,eAAe;AACjB;AACA;EACE,cAAc;EACd,YAAY;AACd;AACA;EACE,gBAAgB;AAClB;AACA;EACE,cAAc;EACd,YAAY;EACZ,iBAAiB;EACjB,iBAAiB;AACnB;AACA;EACE,eAAe;AACjB;AACA;EACE,cAAc;EACd,YAAY;AACd;AACA;EACE,eAAe;EACf,aAAa;AACf;AACA;EACE,iBAAiB;AACnB;AACA;EACE,cAAc;EACd,YAAY;AACd;AACA;EACE,eAAe;AACjB;AACA;EACE,cAAc;EACd,YAAY;AACd;AACA;EACE,YAAY;EACZ,iBAAiB;EACjB,yBAAyB;EACzB,cAAc;EACd,kBAAkB;EAClB,iBAAiB;AACnB;AACA;EACE,eAAe;EACf,iBAAiB;AACnB;AACA;EACE,kBAAkB;EAClB,aAAa;EACb,WAAW;EACX,yBAAyB;EACzB,sBAAsB;EACtB,mBAAmB;EACnB,gBAAgB;AAClB;AACA;EACE,cAAc;AAChB;AACA;EACE,iBAAiB;EACjB,eAAe;EACf,cAAc;EACd,WAAW;AACb;AACA;EACE,yBAAyB;EACzB,6BAA6B;AAC/B;AACA;EACE,yBAAyB;AAC3B;AACA;EACE,yBAAyB;AAC3B;AACA;EACE,yBAAyB;AAC3B;AACA;EACE,gBAAgB;EAChB,mBAAmB;EACnB,yBAAyB;EACzB,WAAW;AACb;AACA;EACE,sBAAsB;EACtB,WAAW;AACb;AACA;EACE,WAAW;AACb;AACA;EACE,YAAY;AACd;AACA;;EAEE,aAAa;AACf;AACA;;EAEE,aAAa;AACf;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,qBAAqB;EACrB,iBAAiB;EACjB,cAAc;EACd,eAAe;AACjB;AACA;EACE,eAAe;EACf,kBAAkB;AACpB;AACA;EACE,cAAc;AAChB;AACA;EACE,cAAc;AAChB;AACA;EACE,cAAc;AAChB;AACA;EACE,cAAc;AAChB;AACA;EACE,cAAc;AAChB;AACA;EACE,aAAa;AACf;AACA;EACE,aAAa;AACf;AACA;EACE,aAAa;AACf;AACA;EACE,aAAa;AACf;AACA;EACE,aAAa;AACf;AACA;EACE,aAAa;AACf;AACA;EACE,gBAAgB;AAClB;AACA;EACE,WAAW;AACb;AACA;EACE,mBAAmB;AACrB;AACA;EACE,yBAAyB;EACzB,YAAY;AACd;AACA;EACE,YAAY;AACd;AACA;EACE,iBAAiB;EACjB,WAAW;EACX,qBAAqB;AACvB;AACA;EACE,cAAc;AAChB;AACA;EACE,iBAAiB;EACjB,iBAAiB;EACjB,cAAc;EACd,iBAAiB;EACjB,WAAW;EACX,sBAAsB;EACtB,iBAAiB;EACjB,gBAAgB;AAClB;AACA;EACE,cAAc;EACd,iBAAiB;EACjB,WAAW;EACX,0BAA0B;AAC5B;AACA;EACE,aAAa;AACf;AACA;EACE,oBAAoB;AACtB;AACA;EACE,cAAc;EACd,iBAAiB;EACjB,YAAY;AACd;AACA;EACE,iBAAiB;EACjB,YAAY;EACZ,WAAW;EACX,sBAAsB;EACtB,iBAAiB;AACnB;AACA;EACE,iBAAiB;AACnB;AACA;EACE,sBAAsB;AACxB","sourcesContent":["@charset \"UTF-8\";\nbody {\n  overflow-y: scroll;\n}\n\n.jasmine_html-reporter {\n  width: 100%;\n  background-color: #eee;\n  padding: 5px;\n  margin: -8px;\n  font-size: 11px;\n  font-family: Monaco, \"Lucida Console\", monospace;\n  line-height: 14px;\n  color: #333;\n}\n.jasmine_html-reporter a {\n  text-decoration: none;\n}\n.jasmine_html-reporter a:hover {\n  text-decoration: underline;\n}\n.jasmine_html-reporter p, .jasmine_html-reporter h1, .jasmine_html-reporter h2, .jasmine_html-reporter h3, .jasmine_html-reporter h4, .jasmine_html-reporter h5, .jasmine_html-reporter h6 {\n  margin: 0;\n  line-height: 14px;\n}\n.jasmine_html-reporter .jasmine-banner,\n.jasmine_html-reporter .jasmine-symbol-summary,\n.jasmine_html-reporter .jasmine-summary,\n.jasmine_html-reporter .jasmine-result-message,\n.jasmine_html-reporter .jasmine-spec .jasmine-description,\n.jasmine_html-reporter .jasmine-spec-detail .jasmine-description,\n.jasmine_html-reporter .jasmine-alert .jasmine-bar,\n.jasmine_html-reporter .jasmine-stack-trace {\n  padding-left: 9px;\n  padding-right: 9px;\n}\n.jasmine_html-reporter .jasmine-banner {\n  position: relative;\n}\n.jasmine_html-reporter .jasmine-banner .jasmine-title {\n  background: url(\"data:image/png;base64,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\") no-repeat;\n  background: url(\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgdmVyc2lvbj0iMS4xIgogICB3aWR0aD0iNjgxLjk2MjUyIgogICBoZWlnaHQ9IjE4Ny41IgogICBpZD0ic3ZnMiIKICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhOCI+PHJkZjpSREY+PGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPjxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PjxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz48L2NjOldvcms+PC9yZGY6UkRGPjwvbWV0YWRhdGE+PGRlZnMKICAgICBpZD0iZGVmczYiPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMTgiPjxwYXRoCiAgICAgICAgIGQ9Ik0gMCwxNTAwIDAsMCBsIDU0NTUuNzQsMCAwLDE1MDAgTCAwLDE1MDAgeiIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgaWQ9InBhdGgyMCIgLz48L2NsaXBQYXRoPjwvZGVmcz48ZwogICAgIHRyYW5zZm9ybT0ibWF0cml4KDEuMjUsMCwwLC0xLjI1LDAsMTg3LjUpIgogICAgIGlkPSJnMTAiPjxnCiAgICAgICB0cmFuc2Zvcm09InNjYWxlKDAuMSwwLjEpIgogICAgICAgaWQ9ImcxMiI+PGcKICAgICAgICAgaWQ9ImcxNCI+PGcKICAgICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGgxOCkiCiAgICAgICAgICAgaWQ9ImcxNiI+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMTU0NCw1OTkuNDM0IGMgMC45MiwtNDAuMzUyIDI1LjY4LC04MS42MDIgNzEuNTMsLTgxLjYwMiAyNy41MSwwIDQ3LjY4LDEyLjgzMiA2MS40NCwzNS43NTQgMTIuODMsMjIuOTMgMTIuODMsNTYuODUyIDEyLjgzLDgyLjUyNyBsIDAsMzI5LjE4NCAtNzEuNTIsMCAwLDEwNC41NDMgMjY2LjgzLDAgMCwtMTA0LjU0MyAtNzAuNiwwIDAsLTM0NC43NyBjIDAsLTU4LjY5MSAtMy42OCwtMTA0LjUzMSAtNDQuOTMsLTE1Mi4yMTggLTM2LjY4LC00Mi4xOCAtOTYuMjgsLTY2LjAyIC0xNTMuMTQsLTY2LjAyIC0xMTcuMzcsMCAtMjA3LjI0LDc3Ljk0MSAtMjAyLjY0LDE5Ny4xNDUgbCAxMzAuMiwwIgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMjIiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDIzMDEuNCw2NjIuNjk1IGMgMCw4MC43MDMgLTY2Ljk0LDE0NS44MTMgLTE0Ny42MywxNDUuODEzIC04My40NCwwIC0xNDcuNjMsLTY4Ljc4MSAtMTQ3LjYzLC0xNTEuMzAxIDAsLTc5Ljc4NSA2Ni45NCwtMTQ1LjgwMSAxNDUuOCwtMTQ1LjgwMSA4NC4zNSwwIDE0OS40Niw2Ny44NTIgMTQ5LjQ2LDE1MS4yODkgeiBtIC0xLjgzLC0xODEuNTQ3IGMgLTM1Ljc3LC01NC4wOTcgLTkzLjUzLC03OC44NTkgLTE1Ny43MiwtNzguODU5IC0xNDAuMywwIC0yNTEuMjQsMTE2LjQ0OSAtMjUxLjI0LDI1NC45MTggMCwxNDIuMTI5IDExMy43LDI2MC40MSAyNTYuNzQsMjYwLjQxIDYzLjI3LDAgMTE4LjI5LC0yOS4zMzYgMTUyLjIyLC04Mi41MjMgbCAwLDY5LjY4NyAxNzUuMTQsMCAwLC0xMDQuNTI3IC02MS40NCwwIDAsLTI4MC41OTggNjEuNDQsMCAwLC0xMDQuNTI3IC0xNzUuMTQsMCAwLDY2LjAxOSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDI0IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSAyNjIyLjMzLDU1Ny4yNTggYyAzLjY3LC00NC4wMTYgMzMuMDEsLTczLjM0OCA3OC44NiwtNzMuMzQ4IDMzLjkzLDAgNjYuOTMsMjMuODI0IDY2LjkzLDYwLjUwNCAwLDQ4LjYwNiAtNDUuODQsNTYuODU2IC04My40NCw2Ni45NDEgLTg1LjI4LDIyLjAwNCAtMTc4LjgxLDQ4LjYwNiAtMTc4LjgxLDE1NS44NzkgMCw5My41MzYgNzguODYsMTQ3LjYzMyAxNjUuOTgsMTQ3LjYzMyA0NCwwIDgzLjQzLC05LjE3NiAxMTAuOTQsLTQ0LjAwOCBsIDAsMzMuOTIyIDgyLjUzLDAgMCwtMTMyLjk2NSAtMTA4LjIxLDAgYyAtMS44MywzNC44NTYgLTI4LjQyLDU3Ljc3NCAtNjMuMjYsNTcuNzc0IC0zMC4yNiwwIC02Mi4zNSwtMTcuNDIyIC02Mi4zNSwtNTEuMzQ4IDAsLTQ1Ljg0NyA0NC45MywtNTUuOTMgODAuNjksLTY0LjE4IDg4LjAyLC0yMC4xNzUgMTgyLjQ3LC00Ny42OTUgMTgyLjQ3LC0xNTcuNzM0IDAsLTk5LjAyNyAtODMuNDQsLTE1NC4wMzkgLTE3NS4xMywtMTU0LjAzOSAtNDkuNTMsMCAtOTQuNDYsMTUuNTgyIC0xMjYuNTUsNTMuMTggbCAwLC00MC4zNCAtODUuMjcsMCAwLDE0Mi4xMjkgMTE0LjYyLDAiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGgyNiIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMjk4OC4xOCw4MDAuMjU0IC02My4yNiwwIDAsMTA0LjUyNyAxNjUuMDUsMCAwLC03My4zNTUgYyAzMS4xOCw1MS4zNDcgNzguODYsODUuMjc3IDE0MS4yMSw4NS4yNzcgNjcuODUsMCAxMjQuNzEsLTQxLjI1OCAxNTIuMjEsLTEwMi42OTkgMjYuNiw2Mi4zNTEgOTIuNjIsMTAyLjY5OSAxNjAuNDcsMTAyLjY5OSA1My4xOSwwIDEwNS40NiwtMjIgMTQxLjIxLC02Mi4zNTEgMzguNTIsLTQ0LjkzOCAzOC41MiwtOTMuNTMyIDM4LjUyLC0xNDkuNDU3IGwgMCwtMTg1LjIzOSA2My4yNywwIDAsLTEwNC41MjcgLTIzOC40MiwwIDAsMTA0LjUyNyA2My4yOCwwIDAsMTU3LjcxNSBjIDAsMzIuMTAyIDAsNjAuNTI3IC0xNC42Nyw4OC45NTcgLTE4LjM0LDI2LjU4MiAtNDguNjEsNDAuMzQ0IC03OS43Nyw0MC4zNDQgLTMwLjI2LDAgLTYzLjI4LC0xMi44NDQgLTgyLjUzLC0zNi42NzIgLTIyLjkzLC0yOS4zNTUgLTIyLjkzLC01Ni44NjMgLTIyLjkzLC05Mi42MjkgbCAwLC0xNTcuNzE1IDYzLjI3LDAgMCwtMTA0LjUyNyAtMjM4LjQxLDAgMCwxMDQuNTI3IDYzLjI4LDAgMCwxNTAuMzgzIGMgMCwyOS4zNDggMCw2Ni4wMjMgLTE0LjY3LDkxLjY5OSAtMTUuNTksMjkuMzM2IC00Ny42OSw0NC45MzQgLTgwLjcsNDQuOTM0IC0zMS4xOCwwIC01Ny43NywtMTEuMDA4IC03Ny45NCwtMzUuNzc0IC0yNC43NywtMzAuMjUzIC0yNi42LC02Mi4zNDMgLTI2LjYsLTk5Ljk0MSBsIDAsLTE1MS4zMDEgNjMuMjcsMCAwLC0xMDQuNTI3IC0yMzguNCwwIDAsMTA0LjUyNyA2My4yNiwwIDAsMjgwLjU5OCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDI4IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSAzOTk4LjY2LDk1MS41NDcgLTExMS44NywwIDAsMTE4LjI5MyAxMTEuODcsMCAwLC0xMTguMjkzIHogbSAwLC00MzEuODkxIDYzLjI3LDAgMCwtMTA0LjUyNyAtMjM5LjMzLDAgMCwxMDQuNTI3IDY0LjE5LDAgMCwyODAuNTk4IC02My4yNywwIDAsMTA0LjUyNyAxNzUuMTQsMCAwLC0zODUuMTI1IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzAiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDQxNTkuMTIsODAwLjI1NCAtNjMuMjcsMCAwLDEwNC41MjcgMTc1LjE0LDAgMCwtNjkuNjg3IGMgMjkuMzUsNTQuMTAxIDg0LjM2LDgwLjY5OSAxNDQuODcsODAuNjk5IDUzLjE5LDAgMTA1LjQ1LC0yMi4wMTYgMTQxLjIyLC02MC41MjcgNDAuMzQsLTQ0LjkzNCA0MS4yNiwtODguMDMyIDQxLjI2LC0xNDMuOTU3IGwgMCwtMTkxLjY1MyA2My4yNywwIDAsLTEwNC41MjcgLTIzOC40LDAgMCwxMDQuNTI3IDYzLjI2LDAgMCwxNTguNjM3IGMgMCwzMC4yNjIgMCw2MS40MzQgLTE5LjI2LDg4LjAzNSAtMjAuMTcsMjYuNTgyIC01My4xOCwzOS40MTQgLTg2LjE5LDM5LjQxNCAtMzMuOTMsMCAtNjguNzcsLTEzLjc1IC04OC45NCwtNDEuMjUgLTIxLjA5LC0yNy41IC0yMS4wOSwtNjkuNjg3IC0yMS4wOSwtMTAyLjcwNyBsIDAsLTE0Mi4xMjkgNjMuMjYsMCAwLC0xMDQuNTI3IC0yMzguNCwwIDAsMTA0LjUyNyA2My4yNywwIDAsMjgwLjU5OCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDMyIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA1MDgyLjQ4LDcwMy45NjUgYyAtMTkuMjQsNzAuNjA1IC04MS42LDExNS41NDcgLTE1NC4wNCwxMTUuNTQ3IC02Ni4wNCwwIC0xMjkuMywtNTEuMzQ4IC0xNDMuMDUsLTExNS41NDcgbCAyOTcuMDksMCB6IG0gODUuMjcsLTE0NC44ODMgYyAtMzguNTEsLTkzLjUyMyAtMTI5LjI3LC0xNTYuNzkzIC0yMzEuMDUsLTE1Ni43OTMgLTE0My4wNywwIC0yNTcuNjgsMTExLjg3MSAtMjU3LjY4LDI1NS44MzYgMCwxNDQuODgzIDEwOS4xMiwyNjEuMzI4IDI1NC45MSwyNjEuMzI4IDY3Ljg3LDAgMTM1LjcyLC0zMC4yNTggMTgzLjM5LC03OC44NjMgNDguNjIsLTUxLjM0NCA2OC43OSwtMTEzLjY5NSA2OC43OSwtMTgzLjM4MyBsIC0zLjY3LC0zOS40MzQgLTM5Ni4xMywwIGMgMTQuNjcsLTY3Ljg2MyA3Ny4wMywtMTE3LjM2MyAxNDYuNzIsLTExNy4zNjMgNDguNTksMCA5MC43NiwxOC4zMjggMTE4LjI4LDU4LjY3MiBsIDExNi40NCwwIgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzQiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDY5MC44OTUsODUwLjcwMyA5MC43NSwwIDIyLjU0MywzMS4wMzUgMCwyNDMuMTIyIC0xMzUuODI5LDAgMCwtMjQzLjE0MSAyMi41MzYsLTMxLjAxNiIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDM2IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA2MzIuMzk1LDc0Mi4yNTggMjguMDM5LDg2LjMwNCAtMjIuNTUxLDMxLjA0IC0yMzEuMjIzLDc1LjEyOCAtNDEuOTc2LC0xMjkuMTgzIDIzMS4yNTcsLTc1LjEzNyAzNi40NTQsMTEuODQ4IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzgiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDcxNy40NDksNjUzLjEwNSAtNzMuNDEsNTMuMzYgLTM2LjQ4OCwtMTEuODc1IC0xNDIuOTAzLC0xOTYuNjkyIDEwOS44ODMsLTc5LjgyOCAxNDIuOTE4LDE5Ni43MDMgMCwzOC4zMzIiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGg0MCIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gODI4LjUyLDcwNi40NjUgLTczLjQyNiwtNTMuMzQgMC4wMTEsLTM4LjM1OSBMIDg5OC4wMDQsNDE4LjA3IDEwMDcuOSw0OTcuODk4IDg2NC45NzMsNjk0LjYwOSA4MjguNTIsNzA2LjQ2NSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDQyIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA4MTIuMDg2LDgyOC41ODYgMjguMDU1LC04Ni4zMiAzNi40ODQsLTExLjgzNiAyMzEuMjI1LDc1LjExNyAtNDEuOTcsMTI5LjE4MyAtMjMxLjIzOSwtNzUuMTQgLTIyLjU1NSwtMzEuMDA0IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNDQiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDczNi4zMDEsMTMzNS44OCBjIC0zMjMuMDQ3LDAgLTU4NS44NzUsLTI2Mi43OCAtNTg1Ljg3NSwtNTg1Ljc4MiAwLC0zMjMuMTE4IDI2Mi44MjgsLTU4NS45NzcgNTg1Ljg3NSwtNTg1Ljk3NyAzMjMuMDE5LDAgNTg1LjgwOSwyNjIuODU5IDU4NS44MDksNTg1Ljk3NyAwLDMyMy4wMDIgLTI2Mi43OSw1ODUuNzgyIC01ODUuODA5LDU4NS43ODIgbCAwLDAgeiBtIDAsLTExOC42MSBjIDI1Ny45NzIsMCA0NjcuMTg5LC0yMDkuMTMgNDY3LjE4OSwtNDY3LjE3MiAwLC0yNTguMTI5IC0yMDkuMjE3LC00NjcuMzQ4IC00NjcuMTg5LC00NjcuMzQ4IC0yNTguMDc0LDAgLTQ2Ny4yNTQsMjA5LjIxOSAtNDY3LjI1NCw0NjcuMzQ4IDAsMjU4LjA0MiAyMDkuMTgsNDY3LjE3MiA0NjcuMjU0LDQ2Ny4xNzIiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGg0NiIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMTA5MS4xMyw2MTkuODgzIC0xNzUuNzcxLDU3LjEyMSAxMS42MjksMzUuODA4IDE3NS43NjIsLTU3LjEyMSAtMTEuNjIsLTM1LjgwOCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDQ4IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0iTSA4NjYuOTU3LDkwMi4wNzQgODM2LjUsOTI0LjE5OSA5NDUuMTIxLDEwNzMuNzMgOTc1LjU4NiwxMDUxLjYxIDg2Ni45NTcsOTAyLjA3NCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDUwIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0iTSA2MDcuNDY1LDkwMy40NDUgNDk4Ljg1NSwxMDUyLjk3IDUyOS4zMiwxMDc1LjEgNjM3LjkzLDkyNS41NjYgNjA3LjQ2NSw5MDMuNDQ1IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNTIiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDM4MC42ODgsNjIyLjEyOSAtMTEuNjI2LDM1LjgwMSAxNzUuNzU4LDU3LjA5IDExLjYyMSwtMzUuODAxIC0xNzUuNzUzLC01Ny4wOSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDU0IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA3MTYuMjg5LDM3Ni41OSAzNy42NDA2LDAgMCwxODQuODE2IC0zNy42NDA2LDAgMCwtMTg0LjgxNiB6IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNTYiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjwvZz48L2c+PC9nPjwvZz48L3N2Zz4=\") no-repeat, none;\n  -moz-background-size: 100%;\n  -o-background-size: 100%;\n  -webkit-background-size: 100%;\n  background-size: 100%;\n  display: block;\n  float: left;\n  width: 90px;\n  height: 25px;\n}\n.jasmine_html-reporter .jasmine-banner .jasmine-version {\n  margin-left: 14px;\n  position: relative;\n  top: 6px;\n}\n.jasmine_html-reporter #jasmine_content {\n  position: fixed;\n  right: 100%;\n}\n.jasmine_html-reporter .jasmine-version {\n  color: #aaa;\n}\n.jasmine_html-reporter .jasmine-banner {\n  margin-top: 14px;\n}\n.jasmine_html-reporter .jasmine-duration {\n  color: #fff;\n  float: right;\n  line-height: 28px;\n  padding-right: 9px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary {\n  overflow: hidden;\n  margin: 14px 0;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li {\n  display: inline-block;\n  height: 10px;\n  width: 14px;\n  font-size: 16px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-passed {\n  font-size: 14px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-passed:before {\n  color: #007069;\n  content: \"•\";\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-failed {\n  line-height: 9px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-failed:before {\n  color: #ca3a11;\n  content: \"×\";\n  font-weight: bold;\n  margin-left: -1px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-excluded {\n  font-size: 14px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-excluded:before {\n  color: #bababa;\n  content: \"•\";\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-excluded-no-display {\n  font-size: 14px;\n  display: none;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-pending {\n  line-height: 17px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-pending:before {\n  color: #ba9d37;\n  content: \"*\";\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-empty {\n  font-size: 14px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-empty:before {\n  color: #ba9d37;\n  content: \"•\";\n}\n.jasmine_html-reporter .jasmine-run-options {\n  float: right;\n  margin-right: 5px;\n  border: 1px solid #8a4182;\n  color: #8a4182;\n  position: relative;\n  line-height: 20px;\n}\n.jasmine_html-reporter .jasmine-run-options .jasmine-trigger {\n  cursor: pointer;\n  padding: 8px 16px;\n}\n.jasmine_html-reporter .jasmine-run-options .jasmine-payload {\n  position: absolute;\n  display: none;\n  right: -1px;\n  border: 1px solid #8a4182;\n  background-color: #eee;\n  white-space: nowrap;\n  padding: 4px 8px;\n}\n.jasmine_html-reporter .jasmine-run-options .jasmine-payload.jasmine-open {\n  display: block;\n}\n.jasmine_html-reporter .jasmine-bar {\n  line-height: 28px;\n  font-size: 14px;\n  display: block;\n  color: #eee;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-failed, .jasmine_html-reporter .jasmine-bar.jasmine-errored {\n  background-color: #ca3a11;\n  border-bottom: 1px solid #eee;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-passed {\n  background-color: #007069;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-incomplete {\n  background-color: #bababa;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-skipped {\n  background-color: #bababa;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-warning {\n  margin-top: 14px;\n  margin-bottom: 14px;\n  background-color: #ba9d37;\n  color: #333;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-menu {\n  background-color: #fff;\n  color: #aaa;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-menu a {\n  color: #333;\n}\n.jasmine_html-reporter .jasmine-bar a {\n  color: white;\n}\n.jasmine_html-reporter.jasmine-spec-list .jasmine-bar.jasmine-menu.jasmine-failure-list,\n.jasmine_html-reporter.jasmine-spec-list .jasmine-results .jasmine-failures {\n  display: none;\n}\n.jasmine_html-reporter.jasmine-failure-list .jasmine-bar.jasmine-menu.jasmine-spec-list,\n.jasmine_html-reporter.jasmine-failure-list .jasmine-summary {\n  display: none;\n}\n.jasmine_html-reporter .jasmine-results {\n  margin-top: 14px;\n}\n.jasmine_html-reporter .jasmine-summary {\n  margin-top: 14px;\n}\n.jasmine_html-reporter .jasmine-summary ul {\n  list-style-type: none;\n  margin-left: 14px;\n  padding-top: 0;\n  padding-left: 0;\n}\n.jasmine_html-reporter .jasmine-summary ul.jasmine-suite {\n  margin-top: 7px;\n  margin-bottom: 7px;\n}\n.jasmine_html-reporter .jasmine-summary li.jasmine-passed a {\n  color: #007069;\n}\n.jasmine_html-reporter .jasmine-summary li.jasmine-failed a {\n  color: #ca3a11;\n}\n.jasmine_html-reporter .jasmine-summary li.jasmine-empty a {\n  color: #ba9d37;\n}\n.jasmine_html-reporter .jasmine-summary li.jasmine-pending a {\n  color: #ba9d37;\n}\n.jasmine_html-reporter .jasmine-summary li.jasmine-excluded a {\n  color: #bababa;\n}\n.jasmine_html-reporter .jasmine-specs li.jasmine-passed a:before {\n  content: \"• \";\n}\n.jasmine_html-reporter .jasmine-specs li.jasmine-failed a:before {\n  content: \"× \";\n}\n.jasmine_html-reporter .jasmine-specs li.jasmine-empty a:before {\n  content: \"* \";\n}\n.jasmine_html-reporter .jasmine-specs li.jasmine-pending a:before {\n  content: \"• \";\n}\n.jasmine_html-reporter .jasmine-specs li.jasmine-excluded a:before {\n  content: \"• \";\n}\n.jasmine_html-reporter .jasmine-description + .jasmine-suite {\n  margin-top: 0;\n}\n.jasmine_html-reporter .jasmine-suite {\n  margin-top: 14px;\n}\n.jasmine_html-reporter .jasmine-suite a {\n  color: #333;\n}\n.jasmine_html-reporter .jasmine-failures .jasmine-spec-detail {\n  margin-bottom: 28px;\n}\n.jasmine_html-reporter .jasmine-failures .jasmine-spec-detail .jasmine-description {\n  background-color: #ca3a11;\n  color: white;\n}\n.jasmine_html-reporter .jasmine-failures .jasmine-spec-detail .jasmine-description a {\n  color: white;\n}\n.jasmine_html-reporter .jasmine-result-message {\n  padding-top: 14px;\n  color: #333;\n  white-space: pre-wrap;\n}\n.jasmine_html-reporter .jasmine-result-message span.jasmine-result {\n  display: block;\n}\n.jasmine_html-reporter .jasmine-stack-trace {\n  margin: 5px 0 0 0;\n  max-height: 224px;\n  overflow: auto;\n  line-height: 18px;\n  color: #666;\n  border: 1px solid #ddd;\n  background: white;\n  white-space: pre;\n}\n.jasmine_html-reporter .jasmine-expander a {\n  display: block;\n  margin-left: 14px;\n  color: blue;\n  text-decoration: underline;\n}\n.jasmine_html-reporter .jasmine-expander-contents {\n  display: none;\n}\n.jasmine_html-reporter .jasmine-expanded {\n  padding-bottom: 10px;\n}\n.jasmine_html-reporter .jasmine-expanded .jasmine-expander-contents {\n  display: block;\n  margin-left: 14px;\n  padding: 5px;\n}\n.jasmine_html-reporter .jasmine-debug-log {\n  margin: 5px 0 0 0;\n  padding: 5px;\n  color: #666;\n  border: 1px solid #ddd;\n  background: white;\n}\n.jasmine_html-reporter .jasmine-debug-log table {\n  border-spacing: 0;\n}\n.jasmine_html-reporter .jasmine-debug-log table, .jasmine_html-reporter .jasmine-debug-log th, .jasmine_html-reporter .jasmine-debug-log td {\n  border: 1px solid #ddd;\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";

      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }

      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }

      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }

      content += cssWithMappingToString(item);

      if (needLayer) {
        content += "}";
      }

      if (item[2]) {
        content += "}";
      }

      if (item[4]) {
        content += "}";
      }

      return content;
    }).join("");
  }; // import a list of modules into the list


  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }

      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }

      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }

      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/jasmine-core/lib/jasmine-core/boot0.js":
/*!*************************************************************!*\
  !*** ./node_modules/jasmine-core/lib/jasmine-core/boot0.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/*
Copyright (c) 2008-2022 Pivotal Labs

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
/**
 This file starts the process of "booting" Jasmine. It initializes Jasmine,
 makes its globals available, and creates the env. This file should be loaded
 after `jasmine.js` and `jasmine_html.js`, but before `boot1.js` or any project
 source files or spec files are loaded.
 */
(function() {
  var jasmineRequire = window.jasmineRequire || __webpack_require__(/*! ./jasmine.js */ "./node_modules/jasmine-core/lib/jasmine-core/jasmine.js");

  /**
   * ## Require &amp; Instantiate
   *
   * Require Jasmine's core files. Specifically, this requires and attaches all of Jasmine's code to the `jasmine` reference.
   */
  var jasmine = jasmineRequire.core(jasmineRequire),
    global = jasmine.getGlobal();
  global.jasmine = jasmine;

  /**
   * Since this is being run in a browser and the results should populate to an HTML page, require the HTML-specific Jasmine code, injecting the same reference.
   */
  jasmineRequire.html(jasmine);

  /**
   * Create the Jasmine environment. This is used to run all specs in a project.
   */
  var env = jasmine.getEnv();

  /**
   * ## The Global Interface
   *
   * Build up the functions that will be exposed as the Jasmine public interface. A project can customize, rename or alias any of these functions as desired, provided the implementation remains unchanged.
   */
  var jasmineInterface = jasmineRequire.interface(jasmine, env);

  /**
   * Add all of the Jasmine global/public interface to the global scope, so a project can use the public interface directly. For example, calling `describe` in specs instead of `jasmine.getEnv().describe`.
   */
  for (var property in jasmineInterface) {
    global[property] = jasmineInterface[property];
  }
})();


/***/ }),

/***/ "./node_modules/jasmine-core/lib/jasmine-core/boot1.js":
/*!*************************************************************!*\
  !*** ./node_modules/jasmine-core/lib/jasmine-core/boot1.js ***!
  \*************************************************************/
/***/ (() => {

/*
Copyright (c) 2008-2022 Pivotal Labs

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
/**
 This file finishes 'booting' Jasmine, performing all of the necessary
 initialization before executing the loaded environment and all of a project's
 specs. This file should be loaded after `boot0.js` but before any project
 source files or spec files are loaded. Thus this file can also be used to
 customize Jasmine for a project.

 If a project is using Jasmine via the standalone distribution, this file can
 be customized directly. If you only wish to configure the Jasmine env, you
 can load another file that calls `jasmine.getEnv().configure({...})`
 after `boot0.js` is loaded and before this file is loaded.
 */

(function() {
  var env = jasmine.getEnv();

  /**
   * ## Runner Parameters
   *
   * More browser specific code - wrap the query string in an object and to allow for getting/setting parameters from the runner user interface.
   */

  var queryString = new jasmine.QueryString({
    getWindowLocation: function() {
      return window.location;
    }
  });

  var filterSpecs = !!queryString.getParam('spec');

  var config = {
    stopOnSpecFailure: queryString.getParam('stopOnSpecFailure'),
    stopSpecOnExpectationFailure: queryString.getParam(
      'stopSpecOnExpectationFailure'
    ),
    hideDisabled: queryString.getParam('hideDisabled')
  };

  var random = queryString.getParam('random');

  if (random !== undefined && random !== '') {
    config.random = random;
  }

  var seed = queryString.getParam('seed');
  if (seed) {
    config.seed = seed;
  }

  /**
   * ## Reporters
   * The `HtmlReporter` builds all of the HTML UI for the runner page. This reporter paints the dots, stars, and x's for specs, as well as all spec names and all failures (if any).
   */
  var htmlReporter = new jasmine.HtmlReporter({
    env: env,
    navigateWithNewParam: function(key, value) {
      return queryString.navigateWithNewParam(key, value);
    },
    addToExistingQueryString: function(key, value) {
      return queryString.fullStringWithNewParam(key, value);
    },
    getContainer: function() {
      return document.body;
    },
    createElement: function() {
      return document.createElement.apply(document, arguments);
    },
    createTextNode: function() {
      return document.createTextNode.apply(document, arguments);
    },
    timer: new jasmine.Timer(),
    filterSpecs: filterSpecs
  });

  /**
   * The `jsApiReporter` also receives spec results, and is used by any environment that needs to extract the results  from JavaScript.
   */
  env.addReporter(jsApiReporter);
  env.addReporter(htmlReporter);

  /**
   * Filter which specs will be run by matching the start of the full name against the `spec` query param.
   */
  var specFilter = new jasmine.HtmlSpecFilter({
    filterString: function() {
      return queryString.getParam('spec');
    }
  });

  config.specFilter = function(spec) {
    return specFilter.matches(spec.getFullName());
  };

  env.configure(config);

  /**
   * ## Execution
   *
   * Replace the browser window's `onload`, ensure it's called, and then run all of the loaded specs. This includes initializing the `HtmlReporter` instance and then executing the loaded Jasmine environment. All of this will happen after all of the specs are loaded.
   */
  var currentWindowOnload = window.onload;

  window.onload = function() {
    if (currentWindowOnload) {
      currentWindowOnload();
    }
    htmlReporter.initialize();
    env.execute();
  };
})();


/***/ }),

/***/ "./node_modules/jasmine-core/lib/jasmine-core/jasmine-html.js":
/*!********************************************************************!*\
  !*** ./node_modules/jasmine-core/lib/jasmine-core/jasmine-html.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/*
Copyright (c) 2008-2022 Pivotal Labs

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
var jasmineRequire = window.jasmineRequire || __webpack_require__(/*! ./jasmine.js */ "./node_modules/jasmine-core/lib/jasmine-core/jasmine.js");

jasmineRequire.html = function(j$) {
  j$.ResultsNode = jasmineRequire.ResultsNode();
  j$.HtmlReporter = jasmineRequire.HtmlReporter(j$);
  j$.QueryString = jasmineRequire.QueryString();
  j$.HtmlSpecFilter = jasmineRequire.HtmlSpecFilter();
};

jasmineRequire.HtmlReporter = function(j$) {
  function ResultsStateBuilder() {
    this.topResults = new j$.ResultsNode({}, '', null);
    this.currentParent = this.topResults;
    this.specsExecuted = 0;
    this.failureCount = 0;
    this.pendingSpecCount = 0;
  }

  ResultsStateBuilder.prototype.suiteStarted = function(result) {
    this.currentParent.addChild(result, 'suite');
    this.currentParent = this.currentParent.last();
  };

  ResultsStateBuilder.prototype.suiteDone = function(result) {
    this.currentParent.updateResult(result);
    if (this.currentParent !== this.topResults) {
      this.currentParent = this.currentParent.parent;
    }

    if (result.status === 'failed') {
      this.failureCount++;
    }
  };

  ResultsStateBuilder.prototype.specStarted = function(result) {};

  ResultsStateBuilder.prototype.specDone = function(result) {
    this.currentParent.addChild(result, 'spec');

    if (result.status !== 'excluded') {
      this.specsExecuted++;
    }

    if (result.status === 'failed') {
      this.failureCount++;
    }

    if (result.status == 'pending') {
      this.pendingSpecCount++;
    }
  };

  ResultsStateBuilder.prototype.jasmineDone = function(result) {
    if (result.failedExpectations) {
      this.failureCount += result.failedExpectations.length;
    }
  };

  function HtmlReporter(options) {
    var config = function() {
        return (options.env && options.env.configuration()) || {};
      },
      getContainer = options.getContainer,
      createElement = options.createElement,
      createTextNode = options.createTextNode,
      navigateWithNewParam = options.navigateWithNewParam || function() {},
      addToExistingQueryString =
        options.addToExistingQueryString || defaultQueryString,
      filterSpecs = options.filterSpecs,
      htmlReporterMain,
      symbols,
      deprecationWarnings = [];

    this.initialize = function() {
      clearPrior();
      htmlReporterMain = createDom(
        'div',
        { className: 'jasmine_html-reporter' },
        createDom(
          'div',
          { className: 'jasmine-banner' },
          createDom('a', {
            className: 'jasmine-title',
            href: 'http://jasmine.github.io/',
            target: '_blank'
          }),
          createDom('span', { className: 'jasmine-version' }, j$.version)
        ),
        createDom('ul', { className: 'jasmine-symbol-summary' }),
        createDom('div', { className: 'jasmine-alert' }),
        createDom(
          'div',
          { className: 'jasmine-results' },
          createDom('div', { className: 'jasmine-failures' })
        )
      );
      getContainer().appendChild(htmlReporterMain);
    };

    var totalSpecsDefined;
    this.jasmineStarted = function(options) {
      totalSpecsDefined = options.totalSpecsDefined || 0;
    };

    var summary = createDom('div', { className: 'jasmine-summary' });

    var stateBuilder = new ResultsStateBuilder();

    this.suiteStarted = function(result) {
      stateBuilder.suiteStarted(result);
    };

    this.suiteDone = function(result) {
      stateBuilder.suiteDone(result);

      if (result.status === 'failed') {
        failures.push(failureDom(result));
      }
      addDeprecationWarnings(result, 'suite');
    };

    this.specStarted = function(result) {
      stateBuilder.specStarted(result);
    };

    var failures = [];
    this.specDone = function(result) {
      stateBuilder.specDone(result);

      if (noExpectations(result)) {
        var noSpecMsg = "Spec '" + result.fullName + "' has no expectations.";
        if (result.status === 'failed') {
          console.error(noSpecMsg);
        } else {
          console.warn(noSpecMsg);
        }
      }

      if (!symbols) {
        symbols = find('.jasmine-symbol-summary');
      }

      symbols.appendChild(
        createDom('li', {
          className: this.displaySpecInCorrectFormat(result),
          id: 'spec_' + result.id,
          title: result.fullName
        })
      );

      if (result.status === 'failed') {
        failures.push(failureDom(result));
      }

      addDeprecationWarnings(result, 'spec');
    };

    this.displaySpecInCorrectFormat = function(result) {
      return noExpectations(result) && result.status === 'passed'
        ? 'jasmine-empty'
        : this.resultStatus(result.status);
    };

    this.resultStatus = function(status) {
      if (status === 'excluded') {
        return config().hideDisabled
          ? 'jasmine-excluded-no-display'
          : 'jasmine-excluded';
      }
      return 'jasmine-' + status;
    };

    this.jasmineDone = function(doneResult) {
      stateBuilder.jasmineDone(doneResult);
      var banner = find('.jasmine-banner');
      var alert = find('.jasmine-alert');
      var order = doneResult && doneResult.order;
      var i;
      alert.appendChild(
        createDom(
          'span',
          { className: 'jasmine-duration' },
          'finished in ' + doneResult.totalTime / 1000 + 's'
        )
      );

      banner.appendChild(optionsMenu(config()));

      if (stateBuilder.specsExecuted < totalSpecsDefined) {
        var skippedMessage =
          'Ran ' +
          stateBuilder.specsExecuted +
          ' of ' +
          totalSpecsDefined +
          ' specs - run all';
        // include window.location.pathname to fix issue with karma-jasmine-html-reporter in angular: see https://github.com/jasmine/jasmine/issues/1906
        var skippedLink =
          (window.location.pathname || '') +
          addToExistingQueryString('spec', '');
        alert.appendChild(
          createDom(
            'span',
            { className: 'jasmine-bar jasmine-skipped' },
            createDom(
              'a',
              { href: skippedLink, title: 'Run all specs' },
              skippedMessage
            )
          )
        );
      }
      var statusBarMessage = '';
      var statusBarClassName = 'jasmine-overall-result jasmine-bar ';
      var globalFailures = (doneResult && doneResult.failedExpectations) || [];
      var failed = stateBuilder.failureCount + globalFailures.length > 0;

      if (totalSpecsDefined > 0 || failed) {
        statusBarMessage +=
          pluralize('spec', stateBuilder.specsExecuted) +
          ', ' +
          pluralize('failure', stateBuilder.failureCount);
        if (stateBuilder.pendingSpecCount) {
          statusBarMessage +=
            ', ' + pluralize('pending spec', stateBuilder.pendingSpecCount);
        }
      }

      if (doneResult.overallStatus === 'passed') {
        statusBarClassName += ' jasmine-passed ';
      } else if (doneResult.overallStatus === 'incomplete') {
        statusBarClassName += ' jasmine-incomplete ';
        statusBarMessage =
          'Incomplete: ' +
          doneResult.incompleteReason +
          ', ' +
          statusBarMessage;
      } else {
        statusBarClassName += ' jasmine-failed ';
      }

      var seedBar;
      if (order && order.random) {
        seedBar = createDom(
          'span',
          { className: 'jasmine-seed-bar' },
          ', randomized with seed ',
          createDom(
            'a',
            {
              title: 'randomized with seed ' + order.seed,
              href: seedHref(order.seed)
            },
            order.seed
          )
        );
      }

      alert.appendChild(
        createDom(
          'span',
          { className: statusBarClassName },
          statusBarMessage,
          seedBar
        )
      );

      var errorBarClassName = 'jasmine-bar jasmine-errored';
      var afterAllMessagePrefix = 'AfterAll ';

      for (i = 0; i < globalFailures.length; i++) {
        alert.appendChild(
          createDom(
            'span',
            { className: errorBarClassName },
            globalFailureMessage(globalFailures[i])
          )
        );
      }

      function globalFailureMessage(failure) {
        if (failure.globalErrorType === 'load') {
          var prefix = 'Error during loading: ' + failure.message;

          if (failure.filename) {
            return (
              prefix + ' in ' + failure.filename + ' line ' + failure.lineno
            );
          } else {
            return prefix;
          }
        } else if (failure.globalErrorType === 'afterAll') {
          return afterAllMessagePrefix + failure.message;
        } else {
          return failure.message;
        }
      }

      addDeprecationWarnings(doneResult);

      for (i = 0; i < deprecationWarnings.length; i++) {
        var children = [],
          context;

        switch (deprecationWarnings[i].runnableType) {
          case 'spec':
            context = '(in spec: ' + deprecationWarnings[i].runnableName + ')';
            break;
          case 'suite':
            context = '(in suite: ' + deprecationWarnings[i].runnableName + ')';
            break;
          default:
            context = '';
        }

        deprecationWarnings[i].message.split('\n').forEach(function(line) {
          children.push(line);
          children.push(createDom('br'));
        });

        children[0] = 'DEPRECATION: ' + children[0];
        children.push(context);

        if (deprecationWarnings[i].stack) {
          children.push(createExpander(deprecationWarnings[i].stack));
        }

        alert.appendChild(
          createDom(
            'span',
            { className: 'jasmine-bar jasmine-warning' },
            children
          )
        );
      }

      var results = find('.jasmine-results');
      results.appendChild(summary);

      summaryList(stateBuilder.topResults, summary);

      if (failures.length) {
        alert.appendChild(
          createDom(
            'span',
            { className: 'jasmine-menu jasmine-bar jasmine-spec-list' },
            createDom('span', {}, 'Spec List | '),
            createDom(
              'a',
              { className: 'jasmine-failures-menu', href: '#' },
              'Failures'
            )
          )
        );
        alert.appendChild(
          createDom(
            'span',
            { className: 'jasmine-menu jasmine-bar jasmine-failure-list' },
            createDom(
              'a',
              { className: 'jasmine-spec-list-menu', href: '#' },
              'Spec List'
            ),
            createDom('span', {}, ' | Failures ')
          )
        );

        find('.jasmine-failures-menu').onclick = function() {
          setMenuModeTo('jasmine-failure-list');
          return false;
        };
        find('.jasmine-spec-list-menu').onclick = function() {
          setMenuModeTo('jasmine-spec-list');
          return false;
        };

        setMenuModeTo('jasmine-failure-list');

        var failureNode = find('.jasmine-failures');
        for (i = 0; i < failures.length; i++) {
          failureNode.appendChild(failures[i]);
        }
      }
    };

    return this;

    function failureDom(result) {
      var failure = createDom(
        'div',
        { className: 'jasmine-spec-detail jasmine-failed' },
        failureDescription(result, stateBuilder.currentParent),
        createDom('div', { className: 'jasmine-messages' })
      );
      var messages = failure.childNodes[1];

      for (var i = 0; i < result.failedExpectations.length; i++) {
        var expectation = result.failedExpectations[i];
        messages.appendChild(
          createDom(
            'div',
            { className: 'jasmine-result-message' },
            expectation.message
          )
        );
        messages.appendChild(
          createDom(
            'div',
            { className: 'jasmine-stack-trace' },
            expectation.stack
          )
        );
      }

      if (result.failedExpectations.length === 0) {
        messages.appendChild(
          createDom(
            'div',
            { className: 'jasmine-result-message' },
            'Spec has no expectations'
          )
        );
      }

      if (result.debugLogs) {
        messages.appendChild(debugLogTable(result.debugLogs));
      }

      return failure;
    }

    function debugLogTable(debugLogs) {
      var tbody = createDom('tbody');

      debugLogs.forEach(function(entry) {
        tbody.appendChild(
          createDom(
            'tr',
            {},
            createDom('td', {}, entry.timestamp.toString()),
            createDom('td', {}, entry.message)
          )
        );
      });

      return createDom(
        'div',
        { className: 'jasmine-debug-log' },
        createDom(
          'div',
          { className: 'jasmine-debug-log-header' },
          'Debug logs'
        ),
        createDom(
          'table',
          {},
          createDom(
            'thead',
            {},
            createDom(
              'tr',
              {},
              createDom('th', {}, 'Time (ms)'),
              createDom('th', {}, 'Message')
            )
          ),
          tbody
        )
      );
    }

    function summaryList(resultsTree, domParent) {
      var specListNode;
      for (var i = 0; i < resultsTree.children.length; i++) {
        var resultNode = resultsTree.children[i];
        if (filterSpecs && !hasActiveSpec(resultNode)) {
          continue;
        }
        if (resultNode.type === 'suite') {
          var suiteListNode = createDom(
            'ul',
            { className: 'jasmine-suite', id: 'suite-' + resultNode.result.id },
            createDom(
              'li',
              {
                className:
                  'jasmine-suite-detail jasmine-' + resultNode.result.status
              },
              createDom(
                'a',
                { href: specHref(resultNode.result) },
                resultNode.result.description
              )
            )
          );

          summaryList(resultNode, suiteListNode);
          domParent.appendChild(suiteListNode);
        }
        if (resultNode.type === 'spec') {
          if (domParent.getAttribute('class') !== 'jasmine-specs') {
            specListNode = createDom('ul', { className: 'jasmine-specs' });
            domParent.appendChild(specListNode);
          }
          var specDescription = resultNode.result.description;
          if (noExpectations(resultNode.result)) {
            specDescription = 'SPEC HAS NO EXPECTATIONS ' + specDescription;
          }
          if (
            resultNode.result.status === 'pending' &&
            resultNode.result.pendingReason !== ''
          ) {
            specDescription =
              specDescription +
              ' PENDING WITH MESSAGE: ' +
              resultNode.result.pendingReason;
          }
          specListNode.appendChild(
            createDom(
              'li',
              {
                className: 'jasmine-' + resultNode.result.status,
                id: 'spec-' + resultNode.result.id
              },
              createDom(
                'a',
                { href: specHref(resultNode.result) },
                specDescription
              )
            )
          );
        }
      }
    }

    function optionsMenu(config) {
      var optionsMenuDom = createDom(
        'div',
        { className: 'jasmine-run-options' },
        createDom('span', { className: 'jasmine-trigger' }, 'Options'),
        createDom(
          'div',
          { className: 'jasmine-payload' },
          createDom(
            'div',
            { className: 'jasmine-stop-on-failure' },
            createDom('input', {
              className: 'jasmine-fail-fast',
              id: 'jasmine-fail-fast',
              type: 'checkbox'
            }),
            createDom(
              'label',
              { className: 'jasmine-label', for: 'jasmine-fail-fast' },
              'stop execution on spec failure'
            )
          ),
          createDom(
            'div',
            { className: 'jasmine-throw-failures' },
            createDom('input', {
              className: 'jasmine-throw',
              id: 'jasmine-throw-failures',
              type: 'checkbox'
            }),
            createDom(
              'label',
              { className: 'jasmine-label', for: 'jasmine-throw-failures' },
              'stop spec on expectation failure'
            )
          ),
          createDom(
            'div',
            { className: 'jasmine-random-order' },
            createDom('input', {
              className: 'jasmine-random',
              id: 'jasmine-random-order',
              type: 'checkbox'
            }),
            createDom(
              'label',
              { className: 'jasmine-label', for: 'jasmine-random-order' },
              'run tests in random order'
            )
          ),
          createDom(
            'div',
            { className: 'jasmine-hide-disabled' },
            createDom('input', {
              className: 'jasmine-disabled',
              id: 'jasmine-hide-disabled',
              type: 'checkbox'
            }),
            createDom(
              'label',
              { className: 'jasmine-label', for: 'jasmine-hide-disabled' },
              'hide disabled tests'
            )
          )
        )
      );

      var failFastCheckbox = optionsMenuDom.querySelector('#jasmine-fail-fast');
      failFastCheckbox.checked = config.stopOnSpecFailure;
      failFastCheckbox.onclick = function() {
        navigateWithNewParam('stopOnSpecFailure', !config.stopOnSpecFailure);
      };

      var throwCheckbox = optionsMenuDom.querySelector(
        '#jasmine-throw-failures'
      );
      throwCheckbox.checked = config.stopSpecOnExpectationFailure;
      throwCheckbox.onclick = function() {
        navigateWithNewParam(
          'stopSpecOnExpectationFailure',
          !config.stopSpecOnExpectationFailure
        );
      };

      var randomCheckbox = optionsMenuDom.querySelector(
        '#jasmine-random-order'
      );
      randomCheckbox.checked = config.random;
      randomCheckbox.onclick = function() {
        navigateWithNewParam('random', !config.random);
      };

      var hideDisabled = optionsMenuDom.querySelector('#jasmine-hide-disabled');
      hideDisabled.checked = config.hideDisabled;
      hideDisabled.onclick = function() {
        navigateWithNewParam('hideDisabled', !config.hideDisabled);
      };

      var optionsTrigger = optionsMenuDom.querySelector('.jasmine-trigger'),
        optionsPayload = optionsMenuDom.querySelector('.jasmine-payload'),
        isOpen = /\bjasmine-open\b/;

      optionsTrigger.onclick = function() {
        if (isOpen.test(optionsPayload.className)) {
          optionsPayload.className = optionsPayload.className.replace(
            isOpen,
            ''
          );
        } else {
          optionsPayload.className += ' jasmine-open';
        }
      };

      return optionsMenuDom;
    }

    function failureDescription(result, suite) {
      var wrapper = createDom(
        'div',
        { className: 'jasmine-description' },
        createDom(
          'a',
          { title: result.description, href: specHref(result) },
          result.description
        )
      );
      var suiteLink;

      while (suite && suite.parent) {
        wrapper.insertBefore(createTextNode(' > '), wrapper.firstChild);
        suiteLink = createDom(
          'a',
          { href: suiteHref(suite) },
          suite.result.description
        );
        wrapper.insertBefore(suiteLink, wrapper.firstChild);

        suite = suite.parent;
      }

      return wrapper;
    }

    function suiteHref(suite) {
      var els = [];

      while (suite && suite.parent) {
        els.unshift(suite.result.description);
        suite = suite.parent;
      }

      // include window.location.pathname to fix issue with karma-jasmine-html-reporter in angular: see https://github.com/jasmine/jasmine/issues/1906
      return (
        (window.location.pathname || '') +
        addToExistingQueryString('spec', els.join(' '))
      );
    }

    function addDeprecationWarnings(result, runnableType) {
      if (result && result.deprecationWarnings) {
        for (var i = 0; i < result.deprecationWarnings.length; i++) {
          var warning = result.deprecationWarnings[i].message;
          deprecationWarnings.push({
            message: warning,
            stack: result.deprecationWarnings[i].stack,
            runnableName: result.fullName,
            runnableType: runnableType
          });
        }
      }
    }

    function createExpander(stackTrace) {
      var expandLink = createDom('a', { href: '#' }, 'Show stack trace');
      var root = createDom(
        'div',
        { className: 'jasmine-expander' },
        expandLink,
        createDom(
          'div',
          { className: 'jasmine-expander-contents jasmine-stack-trace' },
          stackTrace
        )
      );

      expandLink.addEventListener('click', function(e) {
        e.preventDefault();

        if (root.classList.contains('jasmine-expanded')) {
          root.classList.remove('jasmine-expanded');
          expandLink.textContent = 'Show stack trace';
        } else {
          root.classList.add('jasmine-expanded');
          expandLink.textContent = 'Hide stack trace';
        }
      });

      return root;
    }

    function find(selector) {
      return getContainer().querySelector('.jasmine_html-reporter ' + selector);
    }

    function clearPrior() {
      // return the reporter
      var oldReporter = find('');

      if (oldReporter) {
        getContainer().removeChild(oldReporter);
      }
    }

    function createDom(type, attrs, childrenArrayOrVarArgs) {
      var el = createElement(type),
        children,
        i;

      if (j$.isArray_(childrenArrayOrVarArgs)) {
        children = childrenArrayOrVarArgs;
      } else {
        children = [];

        for (i = 2; i < arguments.length; i++) {
          children.push(arguments[i]);
        }
      }

      for (i = 0; i < children.length; i++) {
        var child = children[i];

        if (typeof child === 'string') {
          el.appendChild(createTextNode(child));
        } else {
          if (child) {
            el.appendChild(child);
          }
        }
      }

      for (var attr in attrs) {
        if (attr == 'className') {
          el[attr] = attrs[attr];
        } else {
          el.setAttribute(attr, attrs[attr]);
        }
      }

      return el;
    }

    function pluralize(singular, count) {
      var word = count == 1 ? singular : singular + 's';

      return '' + count + ' ' + word;
    }

    function specHref(result) {
      // include window.location.pathname to fix issue with karma-jasmine-html-reporter in angular: see https://github.com/jasmine/jasmine/issues/1906
      return (
        (window.location.pathname || '') +
        addToExistingQueryString('spec', result.fullName)
      );
    }

    function seedHref(seed) {
      // include window.location.pathname to fix issue with karma-jasmine-html-reporter in angular: see https://github.com/jasmine/jasmine/issues/1906
      return (
        (window.location.pathname || '') +
        addToExistingQueryString('seed', seed)
      );
    }

    function defaultQueryString(key, value) {
      return '?' + key + '=' + value;
    }

    function setMenuModeTo(mode) {
      htmlReporterMain.setAttribute('class', 'jasmine_html-reporter ' + mode);
    }

    function noExpectations(result) {
      var allExpectations =
        result.failedExpectations.length + result.passedExpectations.length;

      return (
        allExpectations === 0 &&
        (result.status === 'passed' || result.status === 'failed')
      );
    }

    function hasActiveSpec(resultNode) {
      if (resultNode.type == 'spec' && resultNode.result.status != 'excluded') {
        return true;
      }

      if (resultNode.type == 'suite') {
        for (var i = 0, j = resultNode.children.length; i < j; i++) {
          if (hasActiveSpec(resultNode.children[i])) {
            return true;
          }
        }
      }
    }
  }

  return HtmlReporter;
};

jasmineRequire.HtmlSpecFilter = function() {
  function HtmlSpecFilter(options) {
    var filterString =
      options &&
      options.filterString() &&
      options.filterString().replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
    var filterPattern = new RegExp(filterString);

    this.matches = function(specName) {
      return filterPattern.test(specName);
    };
  }

  return HtmlSpecFilter;
};

jasmineRequire.ResultsNode = function() {
  function ResultsNode(result, type, parent) {
    this.result = result;
    this.type = type;
    this.parent = parent;

    this.children = [];

    this.addChild = function(result, type) {
      this.children.push(new ResultsNode(result, type, this));
    };

    this.last = function() {
      return this.children[this.children.length - 1];
    };

    this.updateResult = function(result) {
      this.result = result;
    };
  }

  return ResultsNode;
};

jasmineRequire.QueryString = function() {
  function QueryString(options) {
    this.navigateWithNewParam = function(key, value) {
      options.getWindowLocation().search = this.fullStringWithNewParam(
        key,
        value
      );
    };

    this.fullStringWithNewParam = function(key, value) {
      var paramMap = queryStringToParamMap();
      paramMap[key] = value;
      return toQueryString(paramMap);
    };

    this.getParam = function(key) {
      return queryStringToParamMap()[key];
    };

    return this;

    function toQueryString(paramMap) {
      var qStrPairs = [];
      for (var prop in paramMap) {
        qStrPairs.push(
          encodeURIComponent(prop) + '=' + encodeURIComponent(paramMap[prop])
        );
      }
      return '?' + qStrPairs.join('&');
    }

    function queryStringToParamMap() {
      var paramStr = options.getWindowLocation().search.substring(1),
        params = [],
        paramMap = {};

      if (paramStr.length > 0) {
        params = paramStr.split('&');
        for (var i = 0; i < params.length; i++) {
          var p = params[i].split('=');
          var value = decodeURIComponent(p[1]);
          if (value === 'true' || value === 'false') {
            value = JSON.parse(value);
          }
          paramMap[decodeURIComponent(p[0])] = value;
        }
      }

      return paramMap;
    }
  }

  return QueryString;
};


/***/ }),

/***/ "./node_modules/jasmine-core/lib/jasmine-core/jasmine.js":
/*!***************************************************************!*\
  !*** ./node_modules/jasmine-core/lib/jasmine-core/jasmine.js ***!
  \***************************************************************/
/***/ (function(module, exports, __webpack_require__) {

/*
Copyright (c) 2008-2022 Pivotal Labs

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
// eslint-disable-next-line no-unused-vars
var getJasmineRequireObj = (function(jasmineGlobal) {
  var jasmineRequire;

  if (
     true &&
    module.exports &&
    typeof exports !== 'undefined'
  ) {
    if (typeof __webpack_require__.g !== 'undefined') {
      jasmineGlobal = __webpack_require__.g;
    } else {
      jasmineGlobal = {};
    }
    jasmineRequire = exports;
  } else {
    if (
      typeof window !== 'undefined' &&
      typeof window.toString === 'function' &&
      window.toString() === '[object GjsGlobal]'
    ) {
      jasmineGlobal = window;
    }
    jasmineRequire = jasmineGlobal.jasmineRequire = {};
  }

  function getJasmineRequire() {
    return jasmineRequire;
  }

  getJasmineRequire().core = function(jRequire) {
    var j$ = {};

    jRequire.base(j$, jasmineGlobal);
    j$.util = jRequire.util(j$);
    j$.errors = jRequire.errors();
    j$.formatErrorMsg = jRequire.formatErrorMsg();
    j$.Any = jRequire.Any(j$);
    j$.Anything = jRequire.Anything(j$);
    j$.CallTracker = jRequire.CallTracker(j$);
    j$.MockDate = jRequire.MockDate(j$);
    j$.getClearStack = jRequire.clearStack(j$);
    j$.Clock = jRequire.Clock();
    j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler(j$);
    j$.Deprecator = jRequire.Deprecator(j$);
    j$.Env = jRequire.Env(j$);
    j$.StackTrace = jRequire.StackTrace(j$);
    j$.ExceptionFormatter = jRequire.ExceptionFormatter(j$);
    j$.ExpectationFilterChain = jRequire.ExpectationFilterChain();
    j$.Expector = jRequire.Expector(j$);
    j$.Expectation = jRequire.Expectation(j$);
    j$.buildExpectationResult = jRequire.buildExpectationResult(j$);
    j$.JsApiReporter = jRequire.JsApiReporter(j$);
    j$.makePrettyPrinter = jRequire.makePrettyPrinter(j$);
    j$.basicPrettyPrinter_ = j$.makePrettyPrinter();
    j$.MatchersUtil = jRequire.MatchersUtil(j$);
    j$.ObjectContaining = jRequire.ObjectContaining(j$);
    j$.ArrayContaining = jRequire.ArrayContaining(j$);
    j$.ArrayWithExactContents = jRequire.ArrayWithExactContents(j$);
    j$.MapContaining = jRequire.MapContaining(j$);
    j$.SetContaining = jRequire.SetContaining(j$);
    j$.QueueRunner = jRequire.QueueRunner(j$);
    j$.NeverSkipPolicy = jRequire.NeverSkipPolicy(j$);
    j$.SkipAfterBeforeAllErrorPolicy = jRequire.SkipAfterBeforeAllErrorPolicy(
      j$
    );
    j$.CompleteOnFirstErrorSkipPolicy = jRequire.CompleteOnFirstErrorSkipPolicy(
      j$
    );
    j$.ReportDispatcher = jRequire.ReportDispatcher(j$);
    j$.Spec = jRequire.Spec(j$);
    j$.Spy = jRequire.Spy(j$);
    j$.SpyFactory = jRequire.SpyFactory(j$);
    j$.SpyRegistry = jRequire.SpyRegistry(j$);
    j$.SpyStrategy = jRequire.SpyStrategy(j$);
    j$.StringMatching = jRequire.StringMatching(j$);
    j$.StringContaining = jRequire.StringContaining(j$);
    j$.UserContext = jRequire.UserContext(j$);
    j$.Suite = jRequire.Suite(j$);
    j$.Timer = jRequire.Timer();
    j$.TreeProcessor = jRequire.TreeProcessor();
    j$.version = jRequire.version();
    j$.Order = jRequire.Order();
    j$.DiffBuilder = jRequire.DiffBuilder(j$);
    j$.NullDiffBuilder = jRequire.NullDiffBuilder(j$);
    j$.ObjectPath = jRequire.ObjectPath(j$);
    j$.MismatchTree = jRequire.MismatchTree(j$);
    j$.GlobalErrors = jRequire.GlobalErrors(j$);

    j$.Truthy = jRequire.Truthy(j$);
    j$.Falsy = jRequire.Falsy(j$);
    j$.Empty = jRequire.Empty(j$);
    j$.NotEmpty = jRequire.NotEmpty(j$);

    j$.matchers = jRequire.requireMatchers(jRequire, j$);
    j$.asyncMatchers = jRequire.requireAsyncMatchers(jRequire, j$);

    return j$;
  };

  return getJasmineRequire;
})(this);

getJasmineRequireObj().requireMatchers = function(jRequire, j$) {
  var availableMatchers = [
      'nothing',
      'toBe',
      'toBeCloseTo',
      'toBeDefined',
      'toBeInstanceOf',
      'toBeFalse',
      'toBeFalsy',
      'toBeGreaterThan',
      'toBeGreaterThanOrEqual',
      'toBeLessThan',
      'toBeLessThanOrEqual',
      'toBeNaN',
      'toBeNegativeInfinity',
      'toBeNull',
      'toBePositiveInfinity',
      'toBeTrue',
      'toBeTruthy',
      'toBeUndefined',
      'toContain',
      'toEqual',
      'toHaveSize',
      'toHaveBeenCalled',
      'toHaveBeenCalledBefore',
      'toHaveBeenCalledOnceWith',
      'toHaveBeenCalledTimes',
      'toHaveBeenCalledWith',
      'toHaveClass',
      'toMatch',
      'toThrow',
      'toThrowError',
      'toThrowMatching'
    ],
    matchers = {};

  for (var i = 0; i < availableMatchers.length; i++) {
    var name = availableMatchers[i];
    matchers[name] = jRequire[name](j$);
  }

  return matchers;
};

getJasmineRequireObj().base = function(j$, jasmineGlobal) {
  j$.unimplementedMethod_ = function() {
    throw new Error('unimplemented method');
  };

  /**
   * Maximum object depth the pretty printer will print to.
   * Set this to a lower value to speed up pretty printing if you have large objects.
   * @name jasmine.MAX_PRETTY_PRINT_DEPTH
   * @default 8
   * @since 1.3.0
   */
  j$.MAX_PRETTY_PRINT_DEPTH = 8;
  /**
   * Maximum number of array elements to display when pretty printing objects.
   * This will also limit the number of keys and values displayed for an object.
   * Elements past this number will be ellipised.
   * @name jasmine.MAX_PRETTY_PRINT_ARRAY_LENGTH
   * @default 50
   * @since 2.7.0
   */
  j$.MAX_PRETTY_PRINT_ARRAY_LENGTH = 50;
  /**
   * Maximum number of characters to display when pretty printing objects.
   * Characters past this number will be ellipised.
   * @name jasmine.MAX_PRETTY_PRINT_CHARS
   * @default 100
   * @since 2.9.0
   */
  j$.MAX_PRETTY_PRINT_CHARS = 1000;
  /**
   * Default number of milliseconds Jasmine will wait for an asynchronous spec,
   * before, or after function to complete. This can be overridden on a case by
   * case basis by passing a time limit as the third argument to {@link it},
   * {@link beforeEach}, {@link afterEach}, {@link beforeAll}, or
   * {@link afterAll}. The value must be no greater than the largest number of
   * milliseconds supported by setTimeout, which is usually 2147483647.
   *
   * While debugging tests, you may want to set this to a large number (or pass
   * a large number to one of the functions mentioned above) so that Jasmine
   * does not move on to after functions or the next spec while you're debugging.
   * @name jasmine.DEFAULT_TIMEOUT_INTERVAL
   * @default 5000
   * @since 1.3.0
   */
  var DEFAULT_TIMEOUT_INTERVAL = 5000;
  Object.defineProperty(j$, 'DEFAULT_TIMEOUT_INTERVAL', {
    get: function() {
      return DEFAULT_TIMEOUT_INTERVAL;
    },
    set: function(newValue) {
      j$.util.validateTimeout(newValue, 'jasmine.DEFAULT_TIMEOUT_INTERVAL');
      DEFAULT_TIMEOUT_INTERVAL = newValue;
    }
  });

  j$.getGlobal = function() {
    return jasmineGlobal;
  };

  /**
   * Get the currently booted Jasmine Environment.
   *
   * @name jasmine.getEnv
   * @since 1.3.0
   * @function
   * @return {Env}
   */
  j$.getEnv = function(options) {
    var env = (j$.currentEnv_ = j$.currentEnv_ || new j$.Env(options));
    //jasmine. singletons in here (setTimeout blah blah).
    return env;
  };

  j$.isArray_ = function(value) {
    return j$.isA_('Array', value);
  };

  j$.isObject_ = function(value) {
    return (
      !j$.util.isUndefined(value) && value !== null && j$.isA_('Object', value)
    );
  };

  j$.isString_ = function(value) {
    return j$.isA_('String', value);
  };

  j$.isNumber_ = function(value) {
    return j$.isA_('Number', value);
  };

  j$.isFunction_ = function(value) {
    return j$.isA_('Function', value);
  };

  j$.isAsyncFunction_ = function(value) {
    return j$.isA_('AsyncFunction', value);
  };

  j$.isGeneratorFunction_ = function(value) {
    return j$.isA_('GeneratorFunction', value);
  };

  j$.isTypedArray_ = function(value) {
    return (
      j$.isA_('Float32Array', value) ||
      j$.isA_('Float64Array', value) ||
      j$.isA_('Int16Array', value) ||
      j$.isA_('Int32Array', value) ||
      j$.isA_('Int8Array', value) ||
      j$.isA_('Uint16Array', value) ||
      j$.isA_('Uint32Array', value) ||
      j$.isA_('Uint8Array', value) ||
      j$.isA_('Uint8ClampedArray', value)
    );
  };

  j$.isA_ = function(typeName, value) {
    return j$.getType_(value) === '[object ' + typeName + ']';
  };

  j$.isError_ = function(value) {
    if (!value) {
      return false;
    }

    if (value instanceof Error) {
      return true;
    }

    return typeof value.stack === 'string' && typeof value.message === 'string';
  };

  j$.isAsymmetricEqualityTester_ = function(obj) {
    return obj ? j$.isA_('Function', obj.asymmetricMatch) : false;
  };

  j$.getType_ = function(value) {
    return Object.prototype.toString.apply(value);
  };

  j$.isDomNode = function(obj) {
    // Node is a function, because constructors
    return typeof jasmineGlobal.Node !== 'undefined'
      ? obj instanceof jasmineGlobal.Node
      : obj !== null &&
          typeof obj === 'object' &&
          typeof obj.nodeType === 'number' &&
          typeof obj.nodeName === 'string';
    // return obj.nodeType > 0;
  };

  j$.isMap = function(obj) {
    return (
      obj !== null &&
      typeof obj !== 'undefined' &&
      obj.constructor === jasmineGlobal.Map
    );
  };

  j$.isSet = function(obj) {
    return (
      obj !== null &&
      typeof obj !== 'undefined' &&
      obj.constructor === jasmineGlobal.Set
    );
  };

  j$.isWeakMap = function(obj) {
    return (
      obj !== null &&
      typeof obj !== 'undefined' &&
      obj.constructor === jasmineGlobal.WeakMap
    );
  };

  j$.isURL = function(obj) {
    return (
      obj !== null &&
      typeof obj !== 'undefined' &&
      obj.constructor === jasmineGlobal.URL
    );
  };

  j$.isIterable_ = function(value) {
    return value && !!value[Symbol.iterator];
  };

  j$.isDataView = function(obj) {
    return (
      obj !== null &&
      typeof obj !== 'undefined' &&
      obj.constructor === jasmineGlobal.DataView
    );
  };

  j$.isPromise = function(obj) {
    return !!obj && obj.constructor === jasmineGlobal.Promise;
  };

  j$.isPromiseLike = function(obj) {
    return !!obj && j$.isFunction_(obj.then);
  };

  j$.fnNameFor = function(func) {
    if (func.name) {
      return func.name;
    }

    var matches =
      func.toString().match(/^\s*function\s*(\w+)\s*\(/) ||
      func.toString().match(/^\s*\[object\s*(\w+)Constructor\]/);

    return matches ? matches[1] : '<anonymous>';
  };

  j$.isPending_ = function(promise) {
    var sentinel = {};
    return Promise.race([promise, Promise.resolve(sentinel)]).then(
      function(result) {
        return result === sentinel;
      },
      function() {
        return false;
      }
    );
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared is an instance of the specified class/constructor.
   * @name jasmine.any
   * @since 1.3.0
   * @function
   * @param {Constructor} clazz - The constructor to check against.
   */
  j$.any = function(clazz) {
    return new j$.Any(clazz);
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared is not `null` and not `undefined`.
   * @name jasmine.anything
   * @since 2.2.0
   * @function
   */
  j$.anything = function() {
    return new j$.Anything();
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared is `true` or anything truthy.
   * @name jasmine.truthy
   * @since 3.1.0
   * @function
   */
  j$.truthy = function() {
    return new j$.Truthy();
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared is  `null`, `undefined`, `0`, `false` or anything falsey.
   * @name jasmine.falsy
   * @since 3.1.0
   * @function
   */
  j$.falsy = function() {
    return new j$.Falsy();
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared is empty.
   * @name jasmine.empty
   * @since 3.1.0
   * @function
   */
  j$.empty = function() {
    return new j$.Empty();
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared is not empty.
   * @name jasmine.notEmpty
   * @since 3.1.0
   * @function
   */
  j$.notEmpty = function() {
    return new j$.NotEmpty();
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared contains at least the keys and values.
   * @name jasmine.objectContaining
   * @since 1.3.0
   * @function
   * @param {Object} sample - The subset of properties that _must_ be in the actual.
   */
  j$.objectContaining = function(sample) {
    return new j$.ObjectContaining(sample);
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value is a `String` that matches the `RegExp` or `String`.
   * @name jasmine.stringMatching
   * @since 2.2.0
   * @function
   * @param {RegExp|String} expected
   */
  j$.stringMatching = function(expected) {
    return new j$.StringMatching(expected);
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value is a `String` that contains the specified `String`.
   * @name jasmine.stringContaining
   * @since 3.10.0
   * @function
   * @param {String} expected
   */
  j$.stringContaining = function(expected) {
    return new j$.StringContaining(expected);
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value is an `Array` that contains at least the elements in the sample.
   * @name jasmine.arrayContaining
   * @since 2.2.0
   * @function
   * @param {Array} sample
   */
  j$.arrayContaining = function(sample) {
    return new j$.ArrayContaining(sample);
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value is an `Array` that contains all of the elements in the sample in any order.
   * @name jasmine.arrayWithExactContents
   * @since 2.8.0
   * @function
   * @param {Array} sample
   */
  j$.arrayWithExactContents = function(sample) {
    return new j$.ArrayWithExactContents(sample);
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if every key/value pair in the sample passes the deep equality comparison
   * with at least one key/value pair in the actual value being compared
   * @name jasmine.mapContaining
   * @since 3.5.0
   * @function
   * @param {Map} sample - The subset of items that _must_ be in the actual.
   */
  j$.mapContaining = function(sample) {
    return new j$.MapContaining(sample);
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if every item in the sample passes the deep equality comparison
   * with at least one item in the actual value being compared
   * @name jasmine.setContaining
   * @since 3.5.0
   * @function
   * @param {Set} sample - The subset of items that _must_ be in the actual.
   */
  j$.setContaining = function(sample) {
    return new j$.SetContaining(sample);
  };

  /**
   * Determines whether the provided function is a Jasmine spy.
   * @name jasmine.isSpy
   * @since 2.0.0
   * @function
   * @param {Function} putativeSpy - The function to check.
   * @return {Boolean}
   */
  j$.isSpy = function(putativeSpy) {
    if (!putativeSpy) {
      return false;
    }
    return (
      putativeSpy.and instanceof j$.SpyStrategy &&
      putativeSpy.calls instanceof j$.CallTracker
    );
  };

  /**
   * Logs a message for use in debugging. If the spec fails, trace messages
   * will be included in the {@link SpecResult|result} passed to the
   * reporter's specDone method.
   *
   * This method should be called only when a spec (including any associated
   * beforeEach or afterEach functions) is running.
   * @function
   * @name jasmine.debugLog
   * @since 4.0.0
   * @param {String} msg - The message to log
   */
  j$.debugLog = function(msg) {
    j$.getEnv().debugLog(msg);
  };
};

getJasmineRequireObj().util = function(j$) {
  var util = {};

  util.inherit = function(childClass, parentClass) {
    var Subclass = function() {};
    Subclass.prototype = parentClass.prototype;
    childClass.prototype = new Subclass();
  };

  util.argsToArray = function(args) {
    var arrayOfArgs = [];
    for (var i = 0; i < args.length; i++) {
      arrayOfArgs.push(args[i]);
    }
    return arrayOfArgs;
  };

  util.isUndefined = function(obj) {
    return obj === void 0;
  };

  util.arrayContains = function(array, search) {
    var i = array.length;
    while (i--) {
      if (array[i] === search) {
        return true;
      }
    }
    return false;
  };

  util.clone = function(obj) {
    if (Object.prototype.toString.apply(obj) === '[object Array]') {
      return obj.slice();
    }

    var cloned = {};
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        cloned[prop] = obj[prop];
      }
    }

    return cloned;
  };

  util.cloneArgs = function(args) {
    var clonedArgs = [];
    var argsAsArray = j$.util.argsToArray(args);
    for (var i = 0; i < argsAsArray.length; i++) {
      var str = Object.prototype.toString.apply(argsAsArray[i]),
        primitives = /^\[object (Boolean|String|RegExp|Number)/;

      // All falsey values are either primitives, `null`, or `undefined.
      if (!argsAsArray[i] || str.match(primitives)) {
        clonedArgs.push(argsAsArray[i]);
      } else {
        clonedArgs.push(j$.util.clone(argsAsArray[i]));
      }
    }
    return clonedArgs;
  };

  util.getPropertyDescriptor = function(obj, methodName) {
    var descriptor,
      proto = obj;

    do {
      descriptor = Object.getOwnPropertyDescriptor(proto, methodName);
      proto = Object.getPrototypeOf(proto);
    } while (!descriptor && proto);

    return descriptor;
  };

  util.objectDifference = function(obj, toRemove) {
    var diff = {};

    for (var key in obj) {
      if (util.has(obj, key) && !util.has(toRemove, key)) {
        diff[key] = obj[key];
      }
    }

    return diff;
  };

  util.has = function(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  };

  util.errorWithStack = function errorWithStack() {
    // Don't throw and catch. That makes it harder for users to debug their
    // code with exception breakpoints, and it's unnecessary since all
    // supported environments populate new Error().stack
    return new Error();
  };

  function callerFile() {
    var trace = new j$.StackTrace(util.errorWithStack());
    return trace.frames[2].file;
  }

  util.jasmineFile = (function() {
    var result;

    return function() {
      if (!result) {
        result = callerFile();
      }

      return result;
    };
  })();

  function StopIteration() {}
  StopIteration.prototype = Object.create(Error.prototype);
  StopIteration.prototype.constructor = StopIteration;

  util.validateTimeout = function(timeout, msgPrefix) {
    // Timeouts are implemented with setTimeout, which only supports a limited
    // range of values. The limit is unspecified, as is the behavior when it's
    // exceeded. But on all currently supported JS runtimes, setTimeout calls
    // the callback immediately when the timeout is greater than 2147483647
    // (the maximum value of a signed 32 bit integer).
    var max = 2147483647;

    if (timeout > max) {
      throw new Error(
        (msgPrefix || 'Timeout value') + ' cannot be greater than ' + max
      );
    }
  };

  return util;
};

getJasmineRequireObj().Spec = function(j$) {
  /**
   * @interface Spec
   * @see Configuration#specFilter
   * @since 2.0.0
   */
  function Spec(attrs) {
    this.expectationFactory = attrs.expectationFactory;
    this.asyncExpectationFactory = attrs.asyncExpectationFactory;
    this.resultCallback = attrs.resultCallback || function() {};
    /**
     * The unique ID of this spec.
     * @name Spec#id
     * @readonly
     * @type {string}
     * @since 2.0.0
     */
    this.id = attrs.id;
    /**
     * The description passed to the {@link it} that created this spec.
     * @name Spec#description
     * @readonly
     * @type {string}
     * @since 2.0.0
     */
    this.description = attrs.description || '';
    this.queueableFn = attrs.queueableFn;
    this.beforeAndAfterFns =
      attrs.beforeAndAfterFns ||
      function() {
        return { befores: [], afters: [] };
      };
    this.userContext =
      attrs.userContext ||
      function() {
        return {};
      };
    this.onStart = attrs.onStart || function() {};
    this.autoCleanClosures =
      attrs.autoCleanClosures === undefined ? true : !!attrs.autoCleanClosures;
    this.getSpecName =
      attrs.getSpecName ||
      function() {
        return '';
      };
    this.expectationResultFactory =
      attrs.expectationResultFactory || function() {};
    this.onLateError = attrs.onLateError || function() {};
    this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};
    this.catchingExceptions =
      attrs.catchingExceptions ||
      function() {
        return true;
      };
    this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;
    this.timer = attrs.timer || new j$.Timer();

    if (!this.queueableFn.fn) {
      this.exclude();
    }

    /**
     * @typedef SpecResult
     * @property {Int} id - The unique id of this spec.
     * @property {String} description - The description passed to the {@link it} that created this spec.
     * @property {String} fullName - The full description including all ancestors of this spec.
     * @property {Expectation[]} failedExpectations - The list of expectations that failed during execution of this spec.
     * @property {Expectation[]} passedExpectations - The list of expectations that passed during execution of this spec.
     * @property {Expectation[]} deprecationWarnings - The list of deprecation warnings that occurred during execution this spec.
     * @property {String} pendingReason - If the spec is {@link pending}, this will be the reason.
     * @property {String} status - Once the spec has completed, this string represents the pass/fail status of this spec.
     * @property {number} duration - The time in ms used by the spec execution, including any before/afterEach.
     * @property {Object} properties - User-supplied properties, if any, that were set using {@link Env#setSpecProperty}
     * @property {DebugLogEntry[]|null} debugLogs - Messages, if any, that were logged using {@link jasmine.debugLog} during a failing spec.
     * @since 2.0.0
     */
    this.result = {
      id: this.id,
      description: this.description,
      fullName: this.getFullName(),
      failedExpectations: [],
      passedExpectations: [],
      deprecationWarnings: [],
      pendingReason: '',
      duration: null,
      properties: null,
      debugLogs: null
    };
  }

  Spec.prototype.addExpectationResult = function(passed, data, isError) {
    var expectationResult = this.expectationResultFactory(data);
    if (passed) {
      this.result.passedExpectations.push(expectationResult);
    } else {
      this.result.failedExpectations.push(expectationResult);

      if (this.throwOnExpectationFailure && !isError) {
        throw new j$.errors.ExpectationFailed();
      }
    }
  };

  Spec.prototype.setSpecProperty = function(key, value) {
    this.result.properties = this.result.properties || {};
    this.result.properties[key] = value;
  };

  Spec.prototype.expect = function(actual) {
    return this.expectationFactory(actual, this);
  };

  Spec.prototype.expectAsync = function(actual) {
    return this.asyncExpectationFactory(actual, this);
  };

  Spec.prototype.execute = function(onComplete, excluded, failSpecWithNoExp) {
    var self = this;

    var onStart = {
      fn: function(done) {
        self.timer.start();
        self.onStart(self, done);
      }
    };

    var complete = {
      fn: function(done) {
        if (self.autoCleanClosures) {
          self.queueableFn.fn = null;
        }
        self.result.status = self.status(excluded, failSpecWithNoExp);
        self.result.duration = self.timer.elapsed();

        if (self.result.status !== 'failed') {
          self.result.debugLogs = null;
        }

        self.resultCallback(self.result, done);
      },
      type: 'specCleanup'
    };

    var fns = this.beforeAndAfterFns();

    var runnerConfig = {
      isLeaf: true,
      queueableFns: [...fns.befores, this.queueableFn, ...fns.afters],
      onException: function() {
        self.onException.apply(self, arguments);
      },
      onMultipleDone: function() {
        // Issue a deprecation. Include the context ourselves and pass
        // ignoreRunnable: true, since getting here always means that we've already
        // moved on and the current runnable isn't the one that caused the problem.
        self.onLateError(
          new Error(
            'An asynchronous spec, beforeEach, or afterEach function called its ' +
              "'done' callback more than once.\n(in spec: " +
              self.getFullName() +
              ')'
          )
        );
      },
      onComplete: function() {
        if (self.result.status === 'failed') {
          onComplete(new j$.StopExecutionError('spec failed'));
        } else {
          onComplete();
        }
      },
      userContext: this.userContext(),
      runnableName: this.getFullName.bind(this)
    };

    if (this.markedPending || excluded === true) {
      runnerConfig.queueableFns = [];
    }

    runnerConfig.queueableFns.unshift(onStart);
    runnerConfig.queueableFns.push(complete);

    this.queueRunnerFactory(runnerConfig);
  };

  Spec.prototype.reset = function() {
    this.result = {
      id: this.id,
      description: this.description,
      fullName: this.getFullName(),
      failedExpectations: [],
      passedExpectations: [],
      deprecationWarnings: [],
      pendingReason: this.excludeMessage,
      duration: null,
      properties: null,
      debugLogs: null
    };
    this.markedPending = this.markedExcluding;
  };

  Spec.prototype.onException = function onException(e) {
    if (Spec.isPendingSpecException(e)) {
      this.pend(extractCustomPendingMessage(e));
      return;
    }

    if (e instanceof j$.errors.ExpectationFailed) {
      return;
    }

    this.addExpectationResult(
      false,
      {
        matcherName: '',
        passed: false,
        expected: '',
        actual: '',
        error: e
      },
      true
    );
  };

  /*
   * Marks state as pending
   * @param {string} [message] An optional reason message
   */
  Spec.prototype.pend = function(message) {
    this.markedPending = true;
    if (message) {
      this.result.pendingReason = message;
    }
  };

  /*
   * Like {@link Spec#pend}, but pending state will survive {@link Spec#reset}
   * Useful for fit, xit, where pending state remains.
   * @param {string} [message] An optional reason message
   */
  Spec.prototype.exclude = function(message) {
    this.markedExcluding = true;
    if (this.message) {
      this.excludeMessage = message;
    }
    this.pend(message);
  };

  Spec.prototype.getResult = function() {
    this.result.status = this.status();
    return this.result;
  };

  Spec.prototype.status = function(excluded, failSpecWithNoExpectations) {
    if (excluded === true) {
      return 'excluded';
    }

    if (this.markedPending) {
      return 'pending';
    }

    if (
      this.result.failedExpectations.length > 0 ||
      (failSpecWithNoExpectations &&
        this.result.failedExpectations.length +
          this.result.passedExpectations.length ===
          0)
    ) {
      return 'failed';
    }

    return 'passed';
  };

  /**
   * The full description including all ancestors of this spec.
   * @name Spec#getFullName
   * @function
   * @returns {string}
   * @since 2.0.0
   */
  Spec.prototype.getFullName = function() {
    return this.getSpecName(this);
  };

  Spec.prototype.addDeprecationWarning = function(deprecation) {
    if (typeof deprecation === 'string') {
      deprecation = { message: deprecation };
    }
    this.result.deprecationWarnings.push(
      this.expectationResultFactory(deprecation)
    );
  };

  Spec.prototype.debugLog = function(msg) {
    if (!this.result.debugLogs) {
      this.result.debugLogs = [];
    }

    /**
     * @typedef DebugLogEntry
     * @property {String} message - The message that was passed to {@link jasmine.debugLog}.
     * @property {number} timestamp - The time when the entry was added, in
     * milliseconds from the spec's start time
     */
    this.result.debugLogs.push({
      message: msg,
      timestamp: this.timer.elapsed()
    });
  };

  var extractCustomPendingMessage = function(e) {
    var fullMessage = e.toString(),
      boilerplateStart = fullMessage.indexOf(Spec.pendingSpecExceptionMessage),
      boilerplateEnd =
        boilerplateStart + Spec.pendingSpecExceptionMessage.length;

    return fullMessage.substr(boilerplateEnd);
  };

  Spec.pendingSpecExceptionMessage = '=> marked Pending';

  Spec.isPendingSpecException = function(e) {
    return !!(
      e &&
      e.toString &&
      e.toString().indexOf(Spec.pendingSpecExceptionMessage) !== -1
    );
  };

  /**
   * @interface Spec
   * @see Configuration#specFilter
   */
  Object.defineProperty(Spec.prototype, 'metadata', {
    get: function() {
      if (!this.metadata_) {
        this.metadata_ = {
          /**
           * The unique ID of this spec.
           * @name Spec#id
           * @readonly
           * @type {string}
           */
          id: this.id,

          /**
           * The description passed to the {@link it} that created this spec.
           * @name Spec#description
           * @readonly
           * @type {string}
           */
          description: this.description,

          /**
           * The full description including all ancestors of this spec.
           * @name Spec#getFullName
           * @function
           * @returns {string}
           */
          getFullName: this.getFullName.bind(this)
        };
      }

      return this.metadata_;
    }
  });

  return Spec;
};

/*jshint bitwise: false*/

getJasmineRequireObj().Order = function() {
  function Order(options) {
    this.random = 'random' in options ? options.random : true;
    var seed = (this.seed = options.seed || generateSeed());
    this.sort = this.random ? randomOrder : naturalOrder;

    function naturalOrder(items) {
      return items;
    }

    function randomOrder(items) {
      var copy = items.slice();
      copy.sort(function(a, b) {
        return jenkinsHash(seed + a.id) - jenkinsHash(seed + b.id);
      });
      return copy;
    }

    function generateSeed() {
      return String(Math.random()).slice(-5);
    }

    // Bob Jenkins One-at-a-Time Hash algorithm is a non-cryptographic hash function
    // used to get a different output when the key changes slightly.
    // We use your return to sort the children randomly in a consistent way when
    // used in conjunction with a seed

    function jenkinsHash(key) {
      var hash, i;
      for (hash = i = 0; i < key.length; ++i) {
        hash += key.charCodeAt(i);
        hash += hash << 10;
        hash ^= hash >> 6;
      }
      hash += hash << 3;
      hash ^= hash >> 11;
      hash += hash << 15;
      return hash;
    }
  }

  return Order;
};

getJasmineRequireObj().Env = function(j$) {
  /**
   * @class Env
   * @since 2.0.0
   * @classdesc The Jasmine environment.<br>
   * _Note:_ Do not construct this directly. You can obtain the Env instance by
   * calling {@link jasmine.getEnv}.
   * @hideconstructor
   */
  function Env(options) {
    options = options || {};

    var self = this;
    var global = options.global || j$.getGlobal();

    var totalSpecsDefined = 0;

    var realSetTimeout = global.setTimeout;
    var realClearTimeout = global.clearTimeout;
    var clearStack = j$.getClearStack(global);
    this.clock = new j$.Clock(
      global,
      function() {
        return new j$.DelayedFunctionScheduler();
      },
      new j$.MockDate(global)
    );

    var runnableResources = {};

    var currentSpec = null;
    var currentlyExecutingSuites = [];
    var currentDeclarationSuite = null;
    var hasFailures = false;

    /**
     * This represents the available options to configure Jasmine.
     * Options that are not provided will use their default values.
     * @see Env#configure
     * @interface Configuration
     * @since 3.3.0
     */
    var config = {
      /**
       * Whether to randomize spec execution order
       * @name Configuration#random
       * @since 3.3.0
       * @type Boolean
       * @default true
       */
      random: true,
      /**
       * Seed to use as the basis of randomization.
       * Null causes the seed to be determined randomly at the start of execution.
       * @name Configuration#seed
       * @since 3.3.0
       * @type (number|string)
       * @default null
       */
      seed: null,
      /**
       * Whether to stop execution of the suite after the first spec failure
       * @name Configuration#stopOnSpecFailure
       * @since 3.9.0
       * @type Boolean
       * @default false
       */
      stopOnSpecFailure: false,
      /**
       * Whether to fail the spec if it ran no expectations. By default
       * a spec that ran no expectations is reported as passed. Setting this
       * to true will report such spec as a failure.
       * @name Configuration#failSpecWithNoExpectations
       * @since 3.5.0
       * @type Boolean
       * @default false
       */
      failSpecWithNoExpectations: false,
      /**
       * Whether to cause specs to only have one expectation failure.
       * @name Configuration#stopSpecOnExpectationFailure
       * @since 3.3.0
       * @type Boolean
       * @default false
       */
      stopSpecOnExpectationFailure: false,
      /**
       * A function that takes a spec and returns true if it should be executed
       * or false if it should be skipped.
       * @callback SpecFilter
       * @param {Spec} spec - The spec that the filter is being applied to.
       * @return boolean
       */
      /**
       * Function to use to filter specs
       * @name Configuration#specFilter
       * @since 3.3.0
       * @type SpecFilter
       * @default A function that always returns true.
       */
      specFilter: function() {
        return true;
      },
      /**
       * Whether or not reporters should hide disabled specs from their output.
       * Currently only supported by Jasmine's HTMLReporter
       * @name Configuration#hideDisabled
       * @since 3.3.0
       * @type Boolean
       * @default false
       */
      hideDisabled: false,
      /**
       * Clean closures when a suite is done running (done by clearing the stored function reference).
       * This prevents memory leaks, but you won't be able to run jasmine multiple times.
       * @name Configuration#autoCleanClosures
       * @since 3.10.0
       * @type boolean
       * @default true
       */
      autoCleanClosures: true,
      /**
       * Whether or not to issue warnings for certain deprecated functionality
       * every time it's used. If not set or set to false, deprecation warnings
       * for methods that tend to be called frequently will be issued only once
       * or otherwise throttled to to prevent the suite output from being flooded
       * with warnings.
       * @name Configuration#verboseDeprecations
       * @since 3.6.0
       * @type Boolean
       * @default false
       */
      verboseDeprecations: false
    };

    var currentSuite = function() {
      return currentlyExecutingSuites[currentlyExecutingSuites.length - 1];
    };

    var currentRunnable = function() {
      return currentSpec || currentSuite();
    };

    var globalErrors = null;

    var installGlobalErrors = function() {
      if (globalErrors) {
        return;
      }

      globalErrors = new j$.GlobalErrors();
      globalErrors.install();
    };

    if (!options.suppressLoadErrors) {
      installGlobalErrors();
      globalErrors.pushListener(function(
        message,
        filename,
        lineno,
        colNo,
        err
      ) {
        topSuite.result.failedExpectations.push({
          passed: false,
          globalErrorType: 'load',
          message: message,
          stack: err && err.stack,
          filename: filename,
          lineno: lineno
        });
      });
    }

    /**
     * Configure your jasmine environment
     * @name Env#configure
     * @since 3.3.0
     * @argument {Configuration} configuration
     * @function
     */
    this.configure = function(configuration) {
      var booleanProps = [
        'random',
        'failSpecWithNoExpectations',
        'hideDisabled',
        'stopOnSpecFailure',
        'stopSpecOnExpectationFailure',
        'autoCleanClosures'
      ];

      booleanProps.forEach(function(prop) {
        if (typeof configuration[prop] !== 'undefined') {
          config[prop] = !!configuration[prop];
        }
      });

      if (configuration.specFilter) {
        config.specFilter = configuration.specFilter;
      }

      if (typeof configuration.seed !== 'undefined') {
        config.seed = configuration.seed;
      }

      if (configuration.hasOwnProperty('verboseDeprecations')) {
        config.verboseDeprecations = configuration.verboseDeprecations;
        deprecator.verboseDeprecations(config.verboseDeprecations);
      }
    };

    /**
     * Get the current configuration for your jasmine environment
     * @name Env#configuration
     * @since 3.3.0
     * @function
     * @returns {Configuration}
     */
    this.configuration = function() {
      var result = {};
      for (var property in config) {
        result[property] = config[property];
      }
      return result;
    };

    this.setDefaultSpyStrategy = function(defaultStrategyFn) {
      if (!currentRunnable()) {
        throw new Error(
          'Default spy strategy must be set in a before function or a spec'
        );
      }
      runnableResources[
        currentRunnable().id
      ].defaultStrategyFn = defaultStrategyFn;
    };

    this.addSpyStrategy = function(name, fn) {
      if (!currentRunnable()) {
        throw new Error(
          'Custom spy strategies must be added in a before function or a spec'
        );
      }
      runnableResources[currentRunnable().id].customSpyStrategies[name] = fn;
    };

    this.addCustomEqualityTester = function(tester) {
      if (!currentRunnable()) {
        throw new Error(
          'Custom Equalities must be added in a before function or a spec'
        );
      }
      runnableResources[currentRunnable().id].customEqualityTesters.push(
        tester
      );
    };

    this.addMatchers = function(matchersToAdd) {
      if (!currentRunnable()) {
        throw new Error(
          'Matchers must be added in a before function or a spec'
        );
      }
      var customMatchers =
        runnableResources[currentRunnable().id].customMatchers;

      for (var matcherName in matchersToAdd) {
        customMatchers[matcherName] = matchersToAdd[matcherName];
      }
    };

    this.addAsyncMatchers = function(matchersToAdd) {
      if (!currentRunnable()) {
        throw new Error(
          'Async Matchers must be added in a before function or a spec'
        );
      }
      var customAsyncMatchers =
        runnableResources[currentRunnable().id].customAsyncMatchers;

      for (var matcherName in matchersToAdd) {
        customAsyncMatchers[matcherName] = matchersToAdd[matcherName];
      }
    };

    this.addCustomObjectFormatter = function(formatter) {
      if (!currentRunnable()) {
        throw new Error(
          'Custom object formatters must be added in a before function or a spec'
        );
      }

      runnableResources[currentRunnable().id].customObjectFormatters.push(
        formatter
      );
    };

    j$.Expectation.addCoreMatchers(j$.matchers);
    j$.Expectation.addAsyncCoreMatchers(j$.asyncMatchers);

    var nextSpecId = 0;
    var getNextSpecId = function() {
      return 'spec' + nextSpecId++;
    };

    var nextSuiteId = 0;
    var getNextSuiteId = function() {
      return 'suite' + nextSuiteId++;
    };

    var makePrettyPrinter = function() {
      var customObjectFormatters =
        runnableResources[currentRunnable().id].customObjectFormatters;
      return j$.makePrettyPrinter(customObjectFormatters);
    };

    var makeMatchersUtil = function() {
      const cr = currentRunnable();

      if (cr) {
        const customEqualityTesters =
          runnableResources[cr.id].customEqualityTesters;
        return new j$.MatchersUtil({
          customTesters: customEqualityTesters,
          pp: makePrettyPrinter()
        });
      } else {
        return new j$.MatchersUtil({ pp: j$.basicPrettyPrinter_ });
      }
    };

    var expectationFactory = function(actual, spec) {
      return j$.Expectation.factory({
        matchersUtil: makeMatchersUtil(),
        customMatchers: runnableResources[spec.id].customMatchers,
        actual: actual,
        addExpectationResult: addExpectationResult
      });

      function addExpectationResult(passed, result) {
        return spec.addExpectationResult(passed, result);
      }
    };

    function recordLateError(error) {
      const result = expectationResultFactory({
        error,
        passed: false,
        matcherName: '',
        expected: '',
        actual: ''
      });
      result.globalErrorType = 'lateError';
      topSuite.result.failedExpectations.push(result);
    }

    function recordLateExpectation(runable, runableType, result) {
      var delayedExpectationResult = {};
      Object.keys(result).forEach(function(k) {
        delayedExpectationResult[k] = result[k];
      });
      delayedExpectationResult.passed = false;
      delayedExpectationResult.globalErrorType = 'lateExpectation';
      delayedExpectationResult.message =
        runableType +
        ' "' +
        runable.getFullName() +
        '" ran a "' +
        result.matcherName +
        '" expectation after it finished.\n';

      if (result.message) {
        delayedExpectationResult.message +=
          'Message: "' + result.message + '"\n';
      }

      delayedExpectationResult.message +=
        '1. Did you forget to return or await the result of expectAsync?\n' +
        '2. Was done() invoked before an async operation completed?\n' +
        '3. Did an expectation follow a call to done()?';

      topSuite.result.failedExpectations.push(delayedExpectationResult);
    }

    var asyncExpectationFactory = function(actual, spec, runableType) {
      return j$.Expectation.asyncFactory({
        matchersUtil: makeMatchersUtil(),
        customAsyncMatchers: runnableResources[spec.id].customAsyncMatchers,
        actual: actual,
        addExpectationResult: addExpectationResult
      });

      function addExpectationResult(passed, result) {
        if (currentRunnable() !== spec) {
          recordLateExpectation(spec, runableType, result);
        }
        return spec.addExpectationResult(passed, result);
      }
    };
    var suiteAsyncExpectationFactory = function(actual, suite) {
      return asyncExpectationFactory(actual, suite, 'Suite');
    };

    var specAsyncExpectationFactory = function(actual, suite) {
      return asyncExpectationFactory(actual, suite, 'Spec');
    };

    var defaultResourcesForRunnable = function(id, parentRunnableId) {
      var resources = {
        spies: [],
        customEqualityTesters: [],
        customMatchers: {},
        customAsyncMatchers: {},
        customSpyStrategies: {},
        defaultStrategyFn: undefined,
        customObjectFormatters: []
      };

      if (runnableResources[parentRunnableId]) {
        resources.customEqualityTesters = j$.util.clone(
          runnableResources[parentRunnableId].customEqualityTesters
        );
        resources.customMatchers = j$.util.clone(
          runnableResources[parentRunnableId].customMatchers
        );
        resources.customAsyncMatchers = j$.util.clone(
          runnableResources[parentRunnableId].customAsyncMatchers
        );
        resources.customObjectFormatters = j$.util.clone(
          runnableResources[parentRunnableId].customObjectFormatters
        );
        resources.customSpyStrategies = j$.util.clone(
          runnableResources[parentRunnableId].customSpyStrategies
        );
        resources.defaultStrategyFn =
          runnableResources[parentRunnableId].defaultStrategyFn;
      }

      runnableResources[id] = resources;
    };

    var clearResourcesForRunnable = function(id) {
      spyRegistry.clearSpies();
      delete runnableResources[id];
    };

    var beforeAndAfterFns = function(targetSuite) {
      return function() {
        var befores = [],
          afters = [],
          suite = targetSuite;

        while (suite) {
          befores = befores.concat(suite.beforeFns);
          afters = afters.concat(suite.afterFns);

          suite = suite.parentSuite;
        }

        return {
          befores: befores.reverse(),
          afters: afters
        };
      };
    };

    var getSpecName = function(spec, suite) {
      var fullName = [spec.description],
        suiteFullName = suite.getFullName();

      if (suiteFullName !== '') {
        fullName.unshift(suiteFullName);
      }
      return fullName.join(' ');
    };

    // TODO: we may just be able to pass in the fn instead of wrapping here
    var buildExpectationResult = j$.buildExpectationResult,
      exceptionFormatter = new j$.ExceptionFormatter(),
      expectationResultFactory = function(attrs) {
        attrs.messageFormatter = exceptionFormatter.message;
        attrs.stackFormatter = exceptionFormatter.stack;

        return buildExpectationResult(attrs);
      };

    /**
     * Causes a deprecation warning to be logged to the console and reported to
     * reporters.
     *
     * The optional second parameter is an object that can have either of the
     * following properties:
     *
     * omitStackTrace: Whether to omit the stack trace. Optional. Defaults to
     * false. This option is ignored if the deprecation is an Error. Set this
     * when the stack trace will not contain anything that helps the user find
     * the source of the deprecation.
     *
     * ignoreRunnable: Whether to log the deprecation on the root suite, ignoring
     * the spec or suite that's running when it happens. Optional. Defaults to
     * false.
     *
     * @name Env#deprecated
     * @since 2.99
     * @function
     * @param {String|Error} deprecation The deprecation message
     * @param {Object} [options] Optional extra options, as described above
     */
    this.deprecated = function(deprecation, options) {
      var runnable = currentRunnable() || topSuite;
      deprecator.addDeprecationWarning(runnable, deprecation, options);
    };

    var queueRunnerFactory = function(options, args) {
      if (options.isLeaf) {
        // A spec
        options.SkipPolicy = j$.CompleteOnFirstErrorSkipPolicy;
      } else if (options.isReporter) {
        // A reporter queue
        options.SkipPolicy = j$.NeverSkipPolicy;
      } else {
        // A suite
        if (config.stopOnSpecFailure) {
          options.SkipPolicy = j$.CompleteOnFirstErrorSkipPolicy;
        } else {
          options.SkipPolicy = j$.SkipAfterBeforeAllErrorPolicy;
        }
      }

      options.clearStack = options.clearStack || clearStack;
      options.timeout = {
        setTimeout: realSetTimeout,
        clearTimeout: realClearTimeout
      };
      options.fail = self.fail;
      options.globalErrors = globalErrors;
      options.onException =
        options.onException ||
        function(e) {
          (currentRunnable() || topSuite).onException(e);
        };
      options.deprecated = self.deprecated;

      new j$.QueueRunner(options).execute(args);
    };

    var topSuite = new j$.Suite({
      id: getNextSuiteId(),
      description: 'Jasmine__TopLevel__Suite',
      expectationFactory: expectationFactory,
      asyncExpectationFactory: suiteAsyncExpectationFactory,
      expectationResultFactory: expectationResultFactory,
      autoCleanClosures: config.autoCleanClosures,
      onLateError: recordLateError
    });
    var deprecator = new j$.Deprecator(topSuite);
    currentDeclarationSuite = topSuite;

    /**
     * Provides the root suite, through which all suites and specs can be
     * accessed.
     * @function
     * @name Env#topSuite
     * @return {Suite} the root suite
     * @since 2.0.0
     */
    this.topSuite = function() {
      return topSuite.metadata;
    };

    /**
     * This represents the available reporter callback for an object passed to {@link Env#addReporter}.
     * @interface Reporter
     * @see custom_reporter
     */
    var reporter = new j$.ReportDispatcher(
      [
        /**
         * `jasmineStarted` is called after all of the specs have been loaded, but just before execution starts.
         * @function
         * @name Reporter#jasmineStarted
         * @param {JasmineStartedInfo} suiteInfo Information about the full Jasmine suite that is being run
         * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.
         * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.
         * @see async
         */
        'jasmineStarted',
        /**
         * When the entire suite has finished execution `jasmineDone` is called
         * @function
         * @name Reporter#jasmineDone
         * @param {JasmineDoneInfo} suiteInfo Information about the full Jasmine suite that just finished running.
         * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.
         * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.
         * @see async
         */
        'jasmineDone',
        /**
         * `suiteStarted` is invoked when a `describe` starts to run
         * @function
         * @name Reporter#suiteStarted
         * @param {SuiteResult} result Information about the individual {@link describe} being run
         * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.
         * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.
         * @see async
         */
        'suiteStarted',
        /**
         * `suiteDone` is invoked when all of the child specs and suites for a given suite have been run
         *
         * While jasmine doesn't require any specific functions, not defining a `suiteDone` will make it impossible for a reporter to know when a suite has failures in an `afterAll`.
         * @function
         * @name Reporter#suiteDone
         * @param {SuiteResult} result
         * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.
         * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.
         * @see async
         */
        'suiteDone',
        /**
         * `specStarted` is invoked when an `it` starts to run (including associated `beforeEach` functions)
         * @function
         * @name Reporter#specStarted
         * @param {SpecResult} result Information about the individual {@link it} being run
         * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.
         * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.
         * @see async
         */
        'specStarted',
        /**
         * `specDone` is invoked when an `it` and its associated `beforeEach` and `afterEach` functions have been run.
         *
         * While jasmine doesn't require any specific functions, not defining a `specDone` will make it impossible for a reporter to know when a spec has failed.
         * @function
         * @name Reporter#specDone
         * @param {SpecResult} result
         * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.
         * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.
         * @see async
         */
        'specDone'
      ],
      queueRunnerFactory,
      recordLateError
    );

    /**
     * Executes the specs.
     *
     * If called with no parameters or with a falsy value as the first parameter,
     * all specs will be executed except those that are excluded by a
     * [spec filter]{@link Configuration#specFilter} or other mechanism. If the
     * first parameter is a list of spec/suite IDs, only those specs/suites will
     * be run.
     *
     * Both parameters are optional, but a completion callback is only valid as
     * the second parameter. To specify a completion callback but not a list of
     * specs/suites to run, pass null or undefined as the first parameter. The
     * completion callback is supported for backward compatibility. In most
     * cases it will be more convenient to use the returned promise instead.
     *
     * execute should not be called more than once unless the env has been
     * configured with `{autoCleanClosures: false}`.
     *
     * execute returns a promise. The promise will be resolved to the same
     * {@link JasmineDoneInfo|overall result} that's passed to a reporter's
     * `jasmineDone` method, even if the suite did not pass. To determine
     * whether the suite passed, check the value that the promise resolves to
     * or use a {@link Reporter}.
     *
     * @name Env#execute
     * @since 2.0.0
     * @function
     * @param {(string[])=} runnablesToRun IDs of suites and/or specs to run
     * @param {Function=} onComplete Function that will be called after all specs have run
     * @return {Promise<JasmineDoneInfo>}
     */
    this.execute = function(runnablesToRun, onComplete) {
      if (this._executedBefore) {
        topSuite.reset();
      }
      this._executedBefore = true;
      defaultResourcesForRunnable(topSuite.id);
      installGlobalErrors();

      if (!runnablesToRun) {
        if (focusedRunnables.length) {
          runnablesToRun = focusedRunnables;
        } else {
          runnablesToRun = [topSuite.id];
        }
      }

      var order = new j$.Order({
        random: config.random,
        seed: config.seed
      });

      var processor = new j$.TreeProcessor({
        tree: topSuite,
        runnableIds: runnablesToRun,
        queueRunnerFactory: queueRunnerFactory,
        failSpecWithNoExpectations: config.failSpecWithNoExpectations,
        nodeStart: function(suite, next) {
          currentlyExecutingSuites.push(suite);
          defaultResourcesForRunnable(suite.id, suite.parentSuite.id);
          reporter.suiteStarted(suite.result, next);
          suite.startTimer();
        },
        nodeComplete: function(suite, result, next) {
          if (suite !== currentSuite()) {
            throw new Error('Tried to complete the wrong suite');
          }

          clearResourcesForRunnable(suite.id);
          currentlyExecutingSuites.pop();

          if (result.status === 'failed') {
            hasFailures = true;
          }
          suite.endTimer();

          if (suite.hadBeforeAllFailure) {
            reportChildrenOfBeforeAllFailure(suite).then(function() {
              reporter.suiteDone(result, next);
            });
          } else {
            reporter.suiteDone(result, next);
          }
        },
        orderChildren: function(node) {
          return order.sort(node.children);
        },
        excludeNode: function(spec) {
          return !config.specFilter(spec);
        }
      });

      if (!processor.processTree().valid) {
        throw new Error(
          'Invalid order: would cause a beforeAll or afterAll to be run multiple times'
        );
      }

      var jasmineTimer = new j$.Timer();
      jasmineTimer.start();

      return new Promise(function(resolve) {
        runAll(function(jasmineDoneInfo) {
          if (onComplete) {
            onComplete();
          }

          resolve(jasmineDoneInfo);
        });
      });

      function runAll(done) {
        /**
         * Information passed to the {@link Reporter#jasmineStarted} event.
         * @typedef JasmineStartedInfo
         * @property {Int} totalSpecsDefined - The total number of specs defined in this suite.
         * @property {Order} order - Information about the ordering (random or not) of this execution of the suite.
         * @since 2.0.0
         */
        reporter.jasmineStarted(
          {
            totalSpecsDefined: totalSpecsDefined,
            order: order
          },
          function() {
            currentlyExecutingSuites.push(topSuite);

            processor.execute(function() {
              (async function() {
                if (topSuite.hadBeforeAllFailure) {
                  await reportChildrenOfBeforeAllFailure(topSuite);
                }

                clearResourcesForRunnable(topSuite.id);
                currentlyExecutingSuites.pop();
                var overallStatus, incompleteReason;

                if (
                  hasFailures ||
                  topSuite.result.failedExpectations.length > 0
                ) {
                  overallStatus = 'failed';
                } else if (focusedRunnables.length > 0) {
                  overallStatus = 'incomplete';
                  incompleteReason = 'fit() or fdescribe() was found';
                } else if (totalSpecsDefined === 0) {
                  overallStatus = 'incomplete';
                  incompleteReason = 'No specs found';
                } else {
                  overallStatus = 'passed';
                }

                /**
                 * Information passed to the {@link Reporter#jasmineDone} event.
                 * @typedef JasmineDoneInfo
                 * @property {OverallStatus} overallStatus - The overall result of the suite: 'passed', 'failed', or 'incomplete'.
                 * @property {Int} totalTime - The total time (in ms) that it took to execute the suite
                 * @property {IncompleteReason} incompleteReason - Explanation of why the suite was incomplete.
                 * @property {Order} order - Information about the ordering (random or not) of this execution of the suite.
                 * @property {Expectation[]} failedExpectations - List of expectations that failed in an {@link afterAll} at the global level.
                 * @property {Expectation[]} deprecationWarnings - List of deprecation warnings that occurred at the global level.
                 * @since 2.4.0
                 */
                const jasmineDoneInfo = {
                  overallStatus: overallStatus,
                  totalTime: jasmineTimer.elapsed(),
                  incompleteReason: incompleteReason,
                  order: order,
                  failedExpectations: topSuite.result.failedExpectations,
                  deprecationWarnings: topSuite.result.deprecationWarnings
                };
                reporter.jasmineDone(jasmineDoneInfo, function() {
                  done(jasmineDoneInfo);
                });
              })();
            });
          }
        );
      }

      async function reportChildrenOfBeforeAllFailure(suite) {
        for (const child of suite.children) {
          if (child instanceof j$.Suite) {
            await new Promise(function(resolve) {
              reporter.suiteStarted(child.result, resolve);
            });
            await reportChildrenOfBeforeAllFailure(child);

            // Marking the suite passed is consistent with how suites that
            // contain failed specs but no suite-level failures are reported.
            child.result.status = 'passed';

            await new Promise(function(resolve) {
              reporter.suiteDone(child.result, resolve);
            });
          } else {
            /* a spec */
            await new Promise(function(resolve) {
              reporter.specStarted(child.result, resolve);
            });

            child.addExpectationResult(
              false,
              {
                passed: false,
                message:
                  'Not run because a beforeAll function failed. The ' +
                  'beforeAll failure will be reported on the suite that ' +
                  'caused it.'
              },
              true
            );
            child.result.status = 'failed';

            await new Promise(function(resolve) {
              reporter.specDone(child.result, resolve);
            });
          }
        }
      }
    };

    /**
     * Add a custom reporter to the Jasmine environment.
     * @name Env#addReporter
     * @since 2.0.0
     * @function
     * @param {Reporter} reporterToAdd The reporter to be added.
     * @see custom_reporter
     */
    this.addReporter = function(reporterToAdd) {
      reporter.addReporter(reporterToAdd);
    };

    /**
     * Provide a fallback reporter if no other reporters have been specified.
     * @name Env#provideFallbackReporter
     * @since 2.5.0
     * @function
     * @param {Reporter} reporterToAdd The reporter
     * @see custom_reporter
     */
    this.provideFallbackReporter = function(reporterToAdd) {
      reporter.provideFallbackReporter(reporterToAdd);
    };

    /**
     * Clear all registered reporters
     * @name Env#clearReporters
     * @since 2.5.2
     * @function
     */
    this.clearReporters = function() {
      reporter.clearReporters();
    };

    var spyFactory = new j$.SpyFactory(
      function getCustomStrategies() {
        var runnable = currentRunnable();

        if (runnable) {
          return runnableResources[runnable.id].customSpyStrategies;
        }

        return {};
      },
      function getDefaultStrategyFn() {
        var runnable = currentRunnable();

        if (runnable) {
          return runnableResources[runnable.id].defaultStrategyFn;
        }

        return undefined;
      },
      makeMatchersUtil
    );

    var spyRegistry = new j$.SpyRegistry({
      currentSpies: function() {
        if (!currentRunnable()) {
          throw new Error(
            'Spies must be created in a before function or a spec'
          );
        }
        return runnableResources[currentRunnable().id].spies;
      },
      createSpy: function(name, originalFn) {
        return self.createSpy(name, originalFn);
      }
    });

    /**
     * Configures whether Jasmine should allow the same function to be spied on
     * more than once during the execution of a spec. By default, spying on
     * a function that is already a spy will cause an error.
     * @name Env#allowRespy
     * @function
     * @since 2.5.0
     * @param {boolean} allow Whether to allow respying
     */
    this.allowRespy = function(allow) {
      spyRegistry.allowRespy(allow);
    };

    this.spyOn = function() {
      return spyRegistry.spyOn.apply(spyRegistry, arguments);
    };

    this.spyOnProperty = function() {
      return spyRegistry.spyOnProperty.apply(spyRegistry, arguments);
    };

    this.spyOnAllFunctions = function() {
      return spyRegistry.spyOnAllFunctions.apply(spyRegistry, arguments);
    };

    this.createSpy = function(name, originalFn) {
      if (arguments.length === 1 && j$.isFunction_(name)) {
        originalFn = name;
        name = originalFn.name;
      }

      return spyFactory.createSpy(name, originalFn);
    };

    this.createSpyObj = function(baseName, methodNames, propertyNames) {
      return spyFactory.createSpyObj(baseName, methodNames, propertyNames);
    };

    var ensureIsFunction = function(fn, caller) {
      if (!j$.isFunction_(fn)) {
        throw new Error(
          caller + ' expects a function argument; received ' + j$.getType_(fn)
        );
      }
    };

    var ensureIsFunctionOrAsync = function(fn, caller) {
      if (!j$.isFunction_(fn) && !j$.isAsyncFunction_(fn)) {
        throw new Error(
          caller + ' expects a function argument; received ' + j$.getType_(fn)
        );
      }
    };

    function ensureIsNotNested(method) {
      var runnable = currentRunnable();
      if (runnable !== null && runnable !== undefined) {
        throw new Error(
          "'" + method + "' should only be used in 'describe' function"
        );
      }
    }

    var suiteFactory = function(description) {
      var suite = new j$.Suite({
        id: getNextSuiteId(),
        description: description,
        parentSuite: currentDeclarationSuite,
        timer: new j$.Timer(),
        expectationFactory: expectationFactory,
        asyncExpectationFactory: suiteAsyncExpectationFactory,
        expectationResultFactory: expectationResultFactory,
        throwOnExpectationFailure: config.stopSpecOnExpectationFailure,
        autoCleanClosures: config.autoCleanClosures,
        onLateError: recordLateError
      });

      return suite;
    };

    this.describe = function(description, specDefinitions) {
      ensureIsNotNested('describe');
      ensureIsFunction(specDefinitions, 'describe');
      var suite = suiteFactory(description);
      if (specDefinitions.length > 0) {
        throw new Error('describe does not expect any arguments');
      }
      if (currentDeclarationSuite.markedExcluding) {
        suite.exclude();
      }
      addSpecsToSuite(suite, specDefinitions);
      if (suite.parentSuite && !suite.children.length) {
        throw new Error('describe with no children (describe() or it())');
      }
      return suite.metadata;
    };

    this.xdescribe = function(description, specDefinitions) {
      ensureIsNotNested('xdescribe');
      ensureIsFunction(specDefinitions, 'xdescribe');
      var suite = suiteFactory(description);
      suite.exclude();
      addSpecsToSuite(suite, specDefinitions);
      return suite.metadata;
    };

    var focusedRunnables = [];

    this.fdescribe = function(description, specDefinitions) {
      ensureIsNotNested('fdescribe');
      ensureIsFunction(specDefinitions, 'fdescribe');
      var suite = suiteFactory(description);
      suite.isFocused = true;

      focusedRunnables.push(suite.id);
      unfocusAncestor();
      addSpecsToSuite(suite, specDefinitions);

      return suite.metadata;
    };

    function addSpecsToSuite(suite, specDefinitions) {
      var parentSuite = currentDeclarationSuite;
      parentSuite.addChild(suite);
      currentDeclarationSuite = suite;

      var declarationError = null;
      try {
        specDefinitions();
      } catch (e) {
        declarationError = e;
      }

      if (declarationError) {
        suite.onException(declarationError);
      }

      currentDeclarationSuite = parentSuite;
    }

    function findFocusedAncestor(suite) {
      while (suite) {
        if (suite.isFocused) {
          return suite.id;
        }
        suite = suite.parentSuite;
      }

      return null;
    }

    function unfocusAncestor() {
      var focusedAncestor = findFocusedAncestor(currentDeclarationSuite);
      if (focusedAncestor) {
        for (var i = 0; i < focusedRunnables.length; i++) {
          if (focusedRunnables[i] === focusedAncestor) {
            focusedRunnables.splice(i, 1);
            break;
          }
        }
      }
    }

    var specFactory = function(description, fn, suite, timeout) {
      totalSpecsDefined++;
      var spec = new j$.Spec({
        id: getNextSpecId(),
        beforeAndAfterFns: beforeAndAfterFns(suite),
        expectationFactory: expectationFactory,
        asyncExpectationFactory: specAsyncExpectationFactory,
        onLateError: recordLateError,
        resultCallback: specResultCallback,
        getSpecName: function(spec) {
          return getSpecName(spec, suite);
        },
        onStart: specStarted,
        description: description,
        expectationResultFactory: expectationResultFactory,
        queueRunnerFactory: queueRunnerFactory,
        userContext: function() {
          return suite.clonedSharedUserContext();
        },
        queueableFn: {
          fn: fn,
          timeout: timeout || 0
        },
        throwOnExpectationFailure: config.stopSpecOnExpectationFailure,
        autoCleanClosures: config.autoCleanClosures,
        timer: new j$.Timer()
      });
      return spec;

      function specResultCallback(result, next) {
        clearResourcesForRunnable(spec.id);
        currentSpec = null;

        if (result.status === 'failed') {
          hasFailures = true;
        }

        reporter.specDone(result, next);
      }

      function specStarted(spec, next) {
        currentSpec = spec;
        defaultResourcesForRunnable(spec.id, suite.id);
        reporter.specStarted(spec.result, next);
      }
    };

    this.it_ = function(description, fn, timeout) {
      ensureIsNotNested('it');
      // it() sometimes doesn't have a fn argument, so only check the type if
      // it's given.
      if (arguments.length > 1 && typeof fn !== 'undefined') {
        ensureIsFunctionOrAsync(fn, 'it');
      }

      if (timeout) {
        j$.util.validateTimeout(timeout);
      }

      var spec = specFactory(description, fn, currentDeclarationSuite, timeout);
      if (currentDeclarationSuite.markedExcluding) {
        spec.exclude();
      }
      currentDeclarationSuite.addChild(spec);

      return spec;
    };

    this.it = function(description, fn, timeout) {
      const spec = this.it_(description, fn, timeout);
      return spec.metadata;
    };

    this.xit = function(description, fn, timeout) {
      ensureIsNotNested('xit');
      // xit(), like it(), doesn't always have a fn argument, so only check the
      // type when needed.
      if (arguments.length > 1 && typeof fn !== 'undefined') {
        ensureIsFunctionOrAsync(fn, 'xit');
      }
      var spec = this.it_.apply(this, arguments);
      spec.exclude('Temporarily disabled with xit');
      return spec.metadata;
    };

    this.fit = function(description, fn, timeout) {
      ensureIsNotNested('fit');
      ensureIsFunctionOrAsync(fn, 'fit');

      if (timeout) {
        j$.util.validateTimeout(timeout);
      }
      var spec = specFactory(description, fn, currentDeclarationSuite, timeout);
      currentDeclarationSuite.addChild(spec);
      focusedRunnables.push(spec.id);
      unfocusAncestor();
      return spec.metadata;
    };

    /**
     * Sets a user-defined property that will be provided to reporters as part of the properties field of {@link SpecResult}
     * @name Env#setSpecProperty
     * @since 3.6.0
     * @function
     * @param {String} key The name of the property
     * @param {*} value The value of the property
     */
    this.setSpecProperty = function(key, value) {
      if (!currentRunnable() || currentRunnable() == currentSuite()) {
        throw new Error(
          "'setSpecProperty' was used when there was no current spec"
        );
      }
      currentRunnable().setSpecProperty(key, value);
    };

    /**
     * Sets a user-defined property that will be provided to reporters as part of the properties field of {@link SuiteResult}
     * @name Env#setSuiteProperty
     * @since 3.6.0
     * @function
     * @param {String} key The name of the property
     * @param {*} value The value of the property
     */
    this.setSuiteProperty = function(key, value) {
      if (!currentSuite()) {
        throw new Error(
          "'setSuiteProperty' was used when there was no current suite"
        );
      }
      currentSuite().setSuiteProperty(key, value);
    };

    this.debugLog = function(msg) {
      var maybeSpec = currentRunnable();

      if (!maybeSpec || !maybeSpec.debugLog) {
        throw new Error("'debugLog' was called when there was no current spec");
      }

      maybeSpec.debugLog(msg);
    };

    this.expect = function(actual) {
      if (!currentRunnable()) {
        throw new Error(
          "'expect' was used when there was no current spec, this could be because an asynchronous test timed out"
        );
      }

      return currentRunnable().expect(actual);
    };

    this.expectAsync = function(actual) {
      if (!currentRunnable()) {
        throw new Error(
          "'expectAsync' was used when there was no current spec, this could be because an asynchronous test timed out"
        );
      }

      return currentRunnable().expectAsync(actual);
    };

    this.beforeEach = function(beforeEachFunction, timeout) {
      ensureIsNotNested('beforeEach');
      ensureIsFunctionOrAsync(beforeEachFunction, 'beforeEach');

      if (timeout) {
        j$.util.validateTimeout(timeout);
      }

      currentDeclarationSuite.beforeEach({
        fn: beforeEachFunction,
        timeout: timeout || 0
      });
    };

    this.beforeAll = function(beforeAllFunction, timeout) {
      ensureIsNotNested('beforeAll');
      ensureIsFunctionOrAsync(beforeAllFunction, 'beforeAll');

      if (timeout) {
        j$.util.validateTimeout(timeout);
      }

      currentDeclarationSuite.beforeAll({
        fn: beforeAllFunction,
        timeout: timeout || 0
      });
    };

    this.afterEach = function(afterEachFunction, timeout) {
      ensureIsNotNested('afterEach');
      ensureIsFunctionOrAsync(afterEachFunction, 'afterEach');

      if (timeout) {
        j$.util.validateTimeout(timeout);
      }

      afterEachFunction.isCleanup = true;
      currentDeclarationSuite.afterEach({
        fn: afterEachFunction,
        timeout: timeout || 0
      });
    };

    this.afterAll = function(afterAllFunction, timeout) {
      ensureIsNotNested('afterAll');
      ensureIsFunctionOrAsync(afterAllFunction, 'afterAll');

      if (timeout) {
        j$.util.validateTimeout(timeout);
      }

      currentDeclarationSuite.afterAll({
        fn: afterAllFunction,
        timeout: timeout || 0
      });
    };

    this.pending = function(message) {
      var fullMessage = j$.Spec.pendingSpecExceptionMessage;
      if (message) {
        fullMessage += message;
      }
      throw fullMessage;
    };

    this.fail = function(error) {
      if (!currentRunnable()) {
        throw new Error(
          "'fail' was used when there was no current spec, this could be because an asynchronous test timed out"
        );
      }

      var message = 'Failed';
      if (error) {
        message += ': ';
        if (error.message) {
          message += error.message;
        } else if (j$.isString_(error)) {
          message += error;
        } else {
          // pretty print all kind of objects. This includes arrays.
          message += makePrettyPrinter()(error);
        }
      }

      currentRunnable().addExpectationResult(false, {
        matcherName: '',
        passed: false,
        expected: '',
        actual: '',
        message: message,
        error: error && error.message ? error : null
      });

      if (config.stopSpecOnExpectationFailure) {
        throw new Error(message);
      }
    };

    this.cleanup_ = function() {
      if (globalErrors) {
        globalErrors.uninstall();
      }
    };
  }

  return Env;
};

getJasmineRequireObj().JsApiReporter = function(j$) {
  /**
   * @name jsApiReporter
   * @classdesc {@link Reporter} added by default in `boot.js` to record results for retrieval in javascript code. An instance is made available as `jsApiReporter` on the global object.
   * @class
   * @hideconstructor
   */
  function JsApiReporter(options) {
    var timer = options.timer || new j$.Timer(),
      status = 'loaded';

    this.started = false;
    this.finished = false;
    this.runDetails = {};

    this.jasmineStarted = function() {
      this.started = true;
      status = 'started';
      timer.start();
    };

    var executionTime;

    this.jasmineDone = function(runDetails) {
      this.finished = true;
      this.runDetails = runDetails;
      executionTime = timer.elapsed();
      status = 'done';
    };

    /**
     * Get the current status for the Jasmine environment.
     * @name jsApiReporter#status
     * @since 2.0.0
     * @function
     * @return {String} - One of `loaded`, `started`, or `done`
     */
    this.status = function() {
      return status;
    };

    var suites = [],
      suites_hash = {};

    this.suiteStarted = function(result) {
      suites_hash[result.id] = result;
    };

    this.suiteDone = function(result) {
      storeSuite(result);
    };

    /**
     * Get the results for a set of suites.
     *
     * Retrievable in slices for easier serialization.
     * @name jsApiReporter#suiteResults
     * @since 2.1.0
     * @function
     * @param {Number} index - The position in the suites list to start from.
     * @param {Number} length - Maximum number of suite results to return.
     * @return {SuiteResult[]}
     */
    this.suiteResults = function(index, length) {
      return suites.slice(index, index + length);
    };

    function storeSuite(result) {
      suites.push(result);
      suites_hash[result.id] = result;
    }

    /**
     * Get all of the suites in a single object, with their `id` as the key.
     * @name jsApiReporter#suites
     * @since 2.0.0
     * @function
     * @return {Object} - Map of suite id to {@link SuiteResult}
     */
    this.suites = function() {
      return suites_hash;
    };

    var specs = [];

    this.specDone = function(result) {
      specs.push(result);
    };

    /**
     * Get the results for a set of specs.
     *
     * Retrievable in slices for easier serialization.
     * @name jsApiReporter#specResults
     * @since 2.0.0
     * @function
     * @param {Number} index - The position in the specs list to start from.
     * @param {Number} length - Maximum number of specs results to return.
     * @return {SpecResult[]}
     */
    this.specResults = function(index, length) {
      return specs.slice(index, index + length);
    };

    /**
     * Get all spec results.
     * @name jsApiReporter#specs
     * @since 2.0.0
     * @function
     * @return {SpecResult[]}
     */
    this.specs = function() {
      return specs;
    };

    /**
     * Get the number of milliseconds it took for the full Jasmine suite to run.
     * @name jsApiReporter#executionTime
     * @since 2.0.0
     * @function
     * @return {Number}
     */
    this.executionTime = function() {
      return executionTime;
    };
  }

  return JsApiReporter;
};

getJasmineRequireObj().Any = function(j$) {
  function Any(expectedObject) {
    if (typeof expectedObject === 'undefined') {
      throw new TypeError(
        'jasmine.any() expects to be passed a constructor function. ' +
          'Please pass one or use jasmine.anything() to match any object.'
      );
    }
    this.expectedObject = expectedObject;
  }

  Any.prototype.asymmetricMatch = function(other) {
    if (this.expectedObject == String) {
      return typeof other == 'string' || other instanceof String;
    }

    if (this.expectedObject == Number) {
      return typeof other == 'number' || other instanceof Number;
    }

    if (this.expectedObject == Function) {
      return typeof other == 'function' || other instanceof Function;
    }

    if (this.expectedObject == Object) {
      return other !== null && typeof other == 'object';
    }

    if (this.expectedObject == Boolean) {
      return typeof other == 'boolean';
    }

    /* jshint -W122 */
    /* global Symbol */
    if (typeof Symbol != 'undefined' && this.expectedObject == Symbol) {
      return typeof other == 'symbol';
    }
    /* jshint +W122 */

    return other instanceof this.expectedObject;
  };

  Any.prototype.jasmineToString = function() {
    return '<jasmine.any(' + j$.fnNameFor(this.expectedObject) + ')>';
  };

  return Any;
};

getJasmineRequireObj().Anything = function(j$) {
  function Anything() {}

  Anything.prototype.asymmetricMatch = function(other) {
    return !j$.util.isUndefined(other) && other !== null;
  };

  Anything.prototype.jasmineToString = function() {
    return '<jasmine.anything>';
  };

  return Anything;
};

getJasmineRequireObj().ArrayContaining = function(j$) {
  function ArrayContaining(sample) {
    this.sample = sample;
  }

  ArrayContaining.prototype.asymmetricMatch = function(other, matchersUtil) {
    if (!j$.isArray_(this.sample)) {
      throw new Error(
        'You must provide an array to arrayContaining, not ' +
          j$.basicPrettyPrinter_(this.sample) +
          '.'
      );
    }

    // If the actual parameter is not an array, we can fail immediately, since it couldn't
    // possibly be an "array containing" anything. However, we also want an empty sample
    // array to match anything, so we need to double-check we aren't in that case
    if (!j$.isArray_(other) && this.sample.length > 0) {
      return false;
    }

    for (var i = 0; i < this.sample.length; i++) {
      var item = this.sample[i];
      if (!matchersUtil.contains(other, item)) {
        return false;
      }
    }

    return true;
  };

  ArrayContaining.prototype.jasmineToString = function(pp) {
    return '<jasmine.arrayContaining(' + pp(this.sample) + ')>';
  };

  return ArrayContaining;
};

getJasmineRequireObj().ArrayWithExactContents = function(j$) {
  function ArrayWithExactContents(sample) {
    this.sample = sample;
  }

  ArrayWithExactContents.prototype.asymmetricMatch = function(
    other,
    matchersUtil
  ) {
    if (!j$.isArray_(this.sample)) {
      throw new Error(
        'You must provide an array to arrayWithExactContents, not ' +
          j$.basicPrettyPrinter_(this.sample) +
          '.'
      );
    }

    if (this.sample.length !== other.length) {
      return false;
    }

    for (var i = 0; i < this.sample.length; i++) {
      var item = this.sample[i];
      if (!matchersUtil.contains(other, item)) {
        return false;
      }
    }

    return true;
  };

  ArrayWithExactContents.prototype.jasmineToString = function(pp) {
    return '<jasmine.arrayWithExactContents(' + pp(this.sample) + ')>';
  };

  return ArrayWithExactContents;
};

getJasmineRequireObj().Empty = function(j$) {
  function Empty() {}

  Empty.prototype.asymmetricMatch = function(other) {
    if (j$.isString_(other) || j$.isArray_(other) || j$.isTypedArray_(other)) {
      return other.length === 0;
    }

    if (j$.isMap(other) || j$.isSet(other)) {
      return other.size === 0;
    }

    if (j$.isObject_(other)) {
      return Object.keys(other).length === 0;
    }
    return false;
  };

  Empty.prototype.jasmineToString = function() {
    return '<jasmine.empty>';
  };

  return Empty;
};

getJasmineRequireObj().Falsy = function(j$) {
  function Falsy() {}

  Falsy.prototype.asymmetricMatch = function(other) {
    return !other;
  };

  Falsy.prototype.jasmineToString = function() {
    return '<jasmine.falsy>';
  };

  return Falsy;
};

getJasmineRequireObj().MapContaining = function(j$) {
  function MapContaining(sample) {
    if (!j$.isMap(sample)) {
      throw new Error(
        'You must provide a map to `mapContaining`, not ' +
          j$.basicPrettyPrinter_(sample)
      );
    }

    this.sample = sample;
  }

  MapContaining.prototype.asymmetricMatch = function(other, matchersUtil) {
    if (!j$.isMap(other)) return false;

    for (const [key, value] of this.sample) {
      // for each key/value pair in `sample`
      // there should be at least one pair in `other` whose key and value both match
      var hasMatch = false;
      for (const [oKey, oValue] of other) {
        if (
          matchersUtil.equals(oKey, key) &&
          matchersUtil.equals(oValue, value)
        ) {
          hasMatch = true;
          break;
        }
      }

      if (!hasMatch) {
        return false;
      }
    }

    return true;
  };

  MapContaining.prototype.jasmineToString = function(pp) {
    return '<jasmine.mapContaining(' + pp(this.sample) + ')>';
  };

  return MapContaining;
};

getJasmineRequireObj().NotEmpty = function(j$) {
  function NotEmpty() {}

  NotEmpty.prototype.asymmetricMatch = function(other) {
    if (j$.isString_(other) || j$.isArray_(other) || j$.isTypedArray_(other)) {
      return other.length !== 0;
    }

    if (j$.isMap(other) || j$.isSet(other)) {
      return other.size !== 0;
    }

    if (j$.isObject_(other)) {
      return Object.keys(other).length !== 0;
    }

    return false;
  };

  NotEmpty.prototype.jasmineToString = function() {
    return '<jasmine.notEmpty>';
  };

  return NotEmpty;
};

getJasmineRequireObj().ObjectContaining = function(j$) {
  function ObjectContaining(sample) {
    this.sample = sample;
  }

  function hasProperty(obj, property) {
    if (!obj || typeof obj !== 'object') {
      return false;
    }

    if (Object.prototype.hasOwnProperty.call(obj, property)) {
      return true;
    }

    return hasProperty(Object.getPrototypeOf(obj), property);
  }

  ObjectContaining.prototype.asymmetricMatch = function(other, matchersUtil) {
    if (typeof this.sample !== 'object') {
      throw new Error(
        "You must provide an object to objectContaining, not '" +
          this.sample +
          "'."
      );
    }
    if (typeof other !== 'object') {
      return false;
    }

    for (var property in this.sample) {
      if (
        !hasProperty(other, property) ||
        !matchersUtil.equals(this.sample[property], other[property])
      ) {
        return false;
      }
    }

    return true;
  };

  ObjectContaining.prototype.valuesForDiff_ = function(other, pp) {
    if (!j$.isObject_(other)) {
      return {
        self: this.jasmineToString(pp),
        other: other
      };
    }

    var filteredOther = {};
    Object.keys(this.sample).forEach(function(k) {
      // eq short-circuits comparison of objects that have different key sets,
      // so include all keys even if undefined.
      filteredOther[k] = other[k];
    });

    return {
      self: this.sample,
      other: filteredOther
    };
  };

  ObjectContaining.prototype.jasmineToString = function(pp) {
    return '<jasmine.objectContaining(' + pp(this.sample) + ')>';
  };

  return ObjectContaining;
};

getJasmineRequireObj().SetContaining = function(j$) {
  function SetContaining(sample) {
    if (!j$.isSet(sample)) {
      throw new Error(
        'You must provide a set to `setContaining`, not ' +
          j$.basicPrettyPrinter_(sample)
      );
    }

    this.sample = sample;
  }

  SetContaining.prototype.asymmetricMatch = function(other, matchersUtil) {
    if (!j$.isSet(other)) return false;

    for (const item of this.sample) {
      // for each item in `sample` there should be at least one matching item in `other`
      // (not using `matchersUtil.contains` because it compares set members by reference,
      // not by deep value equality)
      var hasMatch = false;
      for (const oItem of other) {
        if (matchersUtil.equals(oItem, item)) {
          hasMatch = true;
          break;
        }
      }

      if (!hasMatch) {
        return false;
      }
    }

    return true;
  };

  SetContaining.prototype.jasmineToString = function(pp) {
    return '<jasmine.setContaining(' + pp(this.sample) + ')>';
  };

  return SetContaining;
};

getJasmineRequireObj().StringContaining = function(j$) {
  function StringContaining(expected) {
    if (!j$.isString_(expected)) {
      throw new Error('Expected is not a String');
    }

    this.expected = expected;
  }

  StringContaining.prototype.asymmetricMatch = function(other) {
    if (!j$.isString_(other)) {
      // Arrays, etc. don't match no matter what their indexOf returns.
      return false;
    }

    return other.indexOf(this.expected) !== -1;
  };

  StringContaining.prototype.jasmineToString = function() {
    return '<jasmine.stringContaining("' + this.expected + '")>';
  };

  return StringContaining;
};

getJasmineRequireObj().StringMatching = function(j$) {
  function StringMatching(expected) {
    if (!j$.isString_(expected) && !j$.isA_('RegExp', expected)) {
      throw new Error('Expected is not a String or a RegExp');
    }

    this.regexp = new RegExp(expected);
  }

  StringMatching.prototype.asymmetricMatch = function(other) {
    return this.regexp.test(other);
  };

  StringMatching.prototype.jasmineToString = function() {
    return '<jasmine.stringMatching(' + this.regexp + ')>';
  };

  return StringMatching;
};

getJasmineRequireObj().Truthy = function(j$) {
  function Truthy() {}

  Truthy.prototype.asymmetricMatch = function(other) {
    return !!other;
  };

  Truthy.prototype.jasmineToString = function() {
    return '<jasmine.truthy>';
  };

  return Truthy;
};

getJasmineRequireObj().CallTracker = function(j$) {
  /**
   * @namespace Spy#calls
   * @since 2.0.0
   */
  function CallTracker() {
    var calls = [];
    var opts = {};

    this.track = function(context) {
      if (opts.cloneArgs) {
        context.args = j$.util.cloneArgs(context.args);
      }
      calls.push(context);
    };

    /**
     * Check whether this spy has been invoked.
     * @name Spy#calls#any
     * @since 2.0.0
     * @function
     * @return {Boolean}
     */
    this.any = function() {
      return !!calls.length;
    };

    /**
     * Get the number of invocations of this spy.
     * @name Spy#calls#count
     * @since 2.0.0
     * @function
     * @return {Integer}
     */
    this.count = function() {
      return calls.length;
    };

    /**
     * Get the arguments that were passed to a specific invocation of this spy.
     * @name Spy#calls#argsFor
     * @since 2.0.0
     * @function
     * @param {Integer} index The 0-based invocation index.
     * @return {Array}
     */
    this.argsFor = function(index) {
      var call = calls[index];
      return call ? call.args : [];
    };

    /**
     * Get the "this" object that was passed to a specific invocation of this spy.
     * @name Spy#calls#thisFor
     * @since 3.8.0
     * @function
     * @param {Integer} index The 0-based invocation index.
     * @return {Object?}
     */
    this.thisFor = function(index) {
      var call = calls[index];
      return call ? call.object : undefined;
    };

    /**
     * Get the raw calls array for this spy.
     * @name Spy#calls#all
     * @since 2.0.0
     * @function
     * @return {Spy.callData[]}
     */
    this.all = function() {
      return calls;
    };

    /**
     * Get all of the arguments for each invocation of this spy in the order they were received.
     * @name Spy#calls#allArgs
     * @since 2.0.0
     * @function
     * @return {Array}
     */
    this.allArgs = function() {
      var callArgs = [];
      for (var i = 0; i < calls.length; i++) {
        callArgs.push(calls[i].args);
      }

      return callArgs;
    };

    /**
     * Get the first invocation of this spy.
     * @name Spy#calls#first
     * @since 2.0.0
     * @function
     * @return {ObjecSpy.callData}
     */
    this.first = function() {
      return calls[0];
    };

    /**
     * Get the most recent invocation of this spy.
     * @name Spy#calls#mostRecent
     * @since 2.0.0
     * @function
     * @return {ObjecSpy.callData}
     */
    this.mostRecent = function() {
      return calls[calls.length - 1];
    };

    /**
     * Reset this spy as if it has never been called.
     * @name Spy#calls#reset
     * @since 2.0.0
     * @function
     */
    this.reset = function() {
      calls = [];
    };

    /**
     * Set this spy to do a shallow clone of arguments passed to each invocation.
     * @name Spy#calls#saveArgumentsByValue
     * @since 2.5.0
     * @function
     */
    this.saveArgumentsByValue = function() {
      opts.cloneArgs = true;
    };
  }

  return CallTracker;
};

getJasmineRequireObj().clearStack = function(j$) {
  var maxInlineCallCount = 10;

  function messageChannelImpl(global, setTimeout) {
    var channel = new global.MessageChannel(),
      head = {},
      tail = head;

    var taskRunning = false;
    channel.port1.onmessage = function() {
      head = head.next;
      var task = head.task;
      delete head.task;

      if (taskRunning) {
        global.setTimeout(task, 0);
      } else {
        try {
          taskRunning = true;
          task();
        } finally {
          taskRunning = false;
        }
      }
    };

    var currentCallCount = 0;
    return function clearStack(fn) {
      currentCallCount++;

      if (currentCallCount < maxInlineCallCount) {
        tail = tail.next = { task: fn };
        channel.port2.postMessage(0);
      } else {
        currentCallCount = 0;
        setTimeout(fn);
      }
    };
  }

  function getClearStack(global) {
    var currentCallCount = 0;
    var realSetTimeout = global.setTimeout;
    var setTimeoutImpl = function clearStack(fn) {
      Function.prototype.apply.apply(realSetTimeout, [global, [fn, 0]]);
    };

    if (j$.isFunction_(global.setImmediate)) {
      var realSetImmediate = global.setImmediate;
      return function(fn) {
        currentCallCount++;

        if (currentCallCount < maxInlineCallCount) {
          realSetImmediate(fn);
        } else {
          currentCallCount = 0;

          setTimeoutImpl(fn);
        }
      };
    } else if (!j$.util.isUndefined(global.MessageChannel)) {
      return messageChannelImpl(global, setTimeoutImpl);
    } else {
      return setTimeoutImpl;
    }
  }

  return getClearStack;
};

getJasmineRequireObj().Clock = function() {
  /* global process */
  var NODE_JS =
    typeof process !== 'undefined' &&
    process.versions &&
    typeof process.versions.node === 'string';

  /**
   * @class Clock
   * @since 1.3.0
   * @classdesc Jasmine's mock clock is used when testing time dependent code.<br>
   * _Note:_ Do not construct this directly. You can get the current clock with
   * {@link jasmine.clock}.
   * @hideconstructor
   */
  function Clock(global, delayedFunctionSchedulerFactory, mockDate) {
    var self = this,
      realTimingFunctions = {
        setTimeout: global.setTimeout,
        clearTimeout: global.clearTimeout,
        setInterval: global.setInterval,
        clearInterval: global.clearInterval
      },
      fakeTimingFunctions = {
        setTimeout: setTimeout,
        clearTimeout: clearTimeout,
        setInterval: setInterval,
        clearInterval: clearInterval
      },
      installed = false,
      delayedFunctionScheduler,
      timer;

    self.FakeTimeout = FakeTimeout;

    /**
     * Install the mock clock over the built-in methods.
     * @name Clock#install
     * @since 2.0.0
     * @function
     * @return {Clock}
     */
    self.install = function() {
      if (!originalTimingFunctionsIntact()) {
        throw new Error(
          'Jasmine Clock was unable to install over custom global timer functions. Is the clock already installed?'
        );
      }
      replace(global, fakeTimingFunctions);
      timer = fakeTimingFunctions;
      delayedFunctionScheduler = delayedFunctionSchedulerFactory();
      installed = true;

      return self;
    };

    /**
     * Uninstall the mock clock, returning the built-in methods to their places.
     * @name Clock#uninstall
     * @since 2.0.0
     * @function
     */
    self.uninstall = function() {
      delayedFunctionScheduler = null;
      mockDate.uninstall();
      replace(global, realTimingFunctions);

      timer = realTimingFunctions;
      installed = false;
    };

    /**
     * Execute a function with a mocked Clock
     *
     * The clock will be {@link Clock#install|install}ed before the function is called and {@link Clock#uninstall|uninstall}ed in a `finally` after the function completes.
     * @name Clock#withMock
     * @since 2.3.0
     * @function
     * @param {Function} closure The function to be called.
     */
    self.withMock = function(closure) {
      this.install();
      try {
        closure();
      } finally {
        this.uninstall();
      }
    };

    /**
     * Instruct the installed Clock to also mock the date returned by `new Date()`
     * @name Clock#mockDate
     * @since 2.1.0
     * @function
     * @param {Date} [initialDate=now] The `Date` to provide.
     */
    self.mockDate = function(initialDate) {
      mockDate.install(initialDate);
    };

    self.setTimeout = function(fn, delay, params) {
      return Function.prototype.apply.apply(timer.setTimeout, [
        global,
        arguments
      ]);
    };

    self.setInterval = function(fn, delay, params) {
      return Function.prototype.apply.apply(timer.setInterval, [
        global,
        arguments
      ]);
    };

    self.clearTimeout = function(id) {
      return Function.prototype.call.apply(timer.clearTimeout, [global, id]);
    };

    self.clearInterval = function(id) {
      return Function.prototype.call.apply(timer.clearInterval, [global, id]);
    };

    /**
     * Tick the Clock forward, running any enqueued timeouts along the way
     * @name Clock#tick
     * @since 1.3.0
     * @function
     * @param {int} millis The number of milliseconds to tick.
     */
    self.tick = function(millis) {
      if (installed) {
        delayedFunctionScheduler.tick(millis, function(millis) {
          mockDate.tick(millis);
        });
      } else {
        throw new Error(
          'Mock clock is not installed, use jasmine.clock().install()'
        );
      }
    };

    return self;

    function originalTimingFunctionsIntact() {
      return (
        global.setTimeout === realTimingFunctions.setTimeout &&
        global.clearTimeout === realTimingFunctions.clearTimeout &&
        global.setInterval === realTimingFunctions.setInterval &&
        global.clearInterval === realTimingFunctions.clearInterval
      );
    }

    function replace(dest, source) {
      for (var prop in source) {
        dest[prop] = source[prop];
      }
    }

    function setTimeout(fn, delay) {
      if (!NODE_JS) {
        return delayedFunctionScheduler.scheduleFunction(
          fn,
          delay,
          argSlice(arguments, 2)
        );
      }

      var timeout = new FakeTimeout();

      delayedFunctionScheduler.scheduleFunction(
        fn,
        delay,
        argSlice(arguments, 2),
        false,
        timeout
      );

      return timeout;
    }

    function clearTimeout(id) {
      return delayedFunctionScheduler.removeFunctionWithId(id);
    }

    function setInterval(fn, interval) {
      if (!NODE_JS) {
        return delayedFunctionScheduler.scheduleFunction(
          fn,
          interval,
          argSlice(arguments, 2),
          true
        );
      }

      var timeout = new FakeTimeout();

      delayedFunctionScheduler.scheduleFunction(
        fn,
        interval,
        argSlice(arguments, 2),
        true,
        timeout
      );

      return timeout;
    }

    function clearInterval(id) {
      return delayedFunctionScheduler.removeFunctionWithId(id);
    }

    function argSlice(argsObj, n) {
      return Array.prototype.slice.call(argsObj, n);
    }
  }

  /**
   * Mocks Node.js Timeout class
   */
  function FakeTimeout() {}

  FakeTimeout.prototype.ref = function() {
    return this;
  };

  FakeTimeout.prototype.unref = function() {
    return this;
  };

  return Clock;
};

getJasmineRequireObj().CompleteOnFirstErrorSkipPolicy = function(j$) {
  function CompleteOnFirstErrorSkipPolicy(queueableFns) {
    this.queueableFns_ = queueableFns;
    this.erroredFnIx_ = null;
  }

  CompleteOnFirstErrorSkipPolicy.prototype.skipTo = function(lastRanFnIx) {
    let i;

    for (
      i = lastRanFnIx + 1;
      i < this.queueableFns_.length && this.shouldSkip_(i);
      i++
    ) {}
    return i;
  };

  CompleteOnFirstErrorSkipPolicy.prototype.fnErrored = function(fnIx) {
    this.erroredFnIx_ = fnIx;
  };

  CompleteOnFirstErrorSkipPolicy.prototype.shouldSkip_ = function(fnIx) {
    if (this.erroredFnIx_ === null) {
      return false;
    }

    const fn = this.queueableFns_[fnIx];
    const candidateSuite = fn.suite;
    const errorSuite = this.queueableFns_[this.erroredFnIx_].suite;
    const wasCleanupFn =
      fn.type === 'afterEach' ||
      fn.type === 'afterAll' ||
      fn.type === 'specCleanup';
    return (
      !wasCleanupFn ||
      (candidateSuite && isDescendent(candidateSuite, errorSuite))
    );
  };

  function isDescendent(candidate, ancestor) {
    if (!candidate.parentSuite) {
      return false;
    } else if (candidate.parentSuite === ancestor) {
      return true;
    } else {
      return isDescendent(candidate.parentSuite, ancestor);
    }
  }

  return CompleteOnFirstErrorSkipPolicy;
};

getJasmineRequireObj().DelayedFunctionScheduler = function(j$) {
  function DelayedFunctionScheduler() {
    var self = this;
    var scheduledLookup = [];
    var scheduledFunctions = {};
    var currentTime = 0;
    var delayedFnCount = 0;
    var deletedKeys = [];

    self.tick = function(millis, tickDate) {
      millis = millis || 0;
      var endTime = currentTime + millis;

      runScheduledFunctions(endTime, tickDate);
    };

    self.scheduleFunction = function(
      funcToCall,
      millis,
      params,
      recurring,
      timeoutKey,
      runAtMillis
    ) {
      var f;
      if (typeof funcToCall === 'string') {
        /* jshint evil: true */
        f = function() {
          return eval(funcToCall);
        };
        /* jshint evil: false */
      } else {
        f = funcToCall;
      }

      millis = millis || 0;
      timeoutKey = timeoutKey || ++delayedFnCount;
      runAtMillis = runAtMillis || currentTime + millis;

      var funcToSchedule = {
        runAtMillis: runAtMillis,
        funcToCall: f,
        recurring: recurring,
        params: params,
        timeoutKey: timeoutKey,
        millis: millis
      };

      if (runAtMillis in scheduledFunctions) {
        scheduledFunctions[runAtMillis].push(funcToSchedule);
      } else {
        scheduledFunctions[runAtMillis] = [funcToSchedule];
        scheduledLookup.push(runAtMillis);
        scheduledLookup.sort(function(a, b) {
          return a - b;
        });
      }

      return timeoutKey;
    };

    self.removeFunctionWithId = function(timeoutKey) {
      deletedKeys.push(timeoutKey);

      for (var runAtMillis in scheduledFunctions) {
        var funcs = scheduledFunctions[runAtMillis];
        var i = indexOfFirstToPass(funcs, function(func) {
          return func.timeoutKey === timeoutKey;
        });

        if (i > -1) {
          if (funcs.length === 1) {
            delete scheduledFunctions[runAtMillis];
            deleteFromLookup(runAtMillis);
          } else {
            funcs.splice(i, 1);
          }

          // intervals get rescheduled when executed, so there's never more
          // than a single scheduled function with a given timeoutKey
          break;
        }
      }
    };

    return self;

    function indexOfFirstToPass(array, testFn) {
      var index = -1;

      for (var i = 0; i < array.length; ++i) {
        if (testFn(array[i])) {
          index = i;
          break;
        }
      }

      return index;
    }

    function deleteFromLookup(key) {
      var value = Number(key);
      var i = indexOfFirstToPass(scheduledLookup, function(millis) {
        return millis === value;
      });

      if (i > -1) {
        scheduledLookup.splice(i, 1);
      }
    }

    function reschedule(scheduledFn) {
      self.scheduleFunction(
        scheduledFn.funcToCall,
        scheduledFn.millis,
        scheduledFn.params,
        true,
        scheduledFn.timeoutKey,
        scheduledFn.runAtMillis + scheduledFn.millis
      );
    }

    function forEachFunction(funcsToRun, callback) {
      for (var i = 0; i < funcsToRun.length; ++i) {
        callback(funcsToRun[i]);
      }
    }

    function runScheduledFunctions(endTime, tickDate) {
      tickDate = tickDate || function() {};
      if (scheduledLookup.length === 0 || scheduledLookup[0] > endTime) {
        if (endTime >= currentTime) {
          tickDate(endTime - currentTime);
          currentTime = endTime;
        }
        return;
      }

      do {
        deletedKeys = [];
        var newCurrentTime = scheduledLookup.shift();
        if (newCurrentTime >= currentTime) {
          tickDate(newCurrentTime - currentTime);
          currentTime = newCurrentTime;
        }

        var funcsToRun = scheduledFunctions[currentTime];

        delete scheduledFunctions[currentTime];

        forEachFunction(funcsToRun, function(funcToRun) {
          if (funcToRun.recurring) {
            reschedule(funcToRun);
          }
        });

        forEachFunction(funcsToRun, function(funcToRun) {
          if (j$.util.arrayContains(deletedKeys, funcToRun.timeoutKey)) {
            // skip a timeoutKey deleted whilst we were running
            return;
          }
          funcToRun.funcToCall.apply(null, funcToRun.params || []);
        });
        deletedKeys = [];
      } while (
        scheduledLookup.length > 0 &&
        // checking first if we're out of time prevents setTimeout(0)
        // scheduled in a funcToRun from forcing an extra iteration
        currentTime !== endTime &&
        scheduledLookup[0] <= endTime
      );

      // ran out of functions to call, but still time left on the clock
      if (endTime >= currentTime) {
        tickDate(endTime - currentTime);
        currentTime = endTime;
      }
    }
  }

  return DelayedFunctionScheduler;
};

getJasmineRequireObj().Deprecator = function(j$) {
  function Deprecator(topSuite) {
    this.topSuite_ = topSuite;
    this.verbose_ = false;
    this.toSuppress_ = [];
  }

  var verboseNote =
    'Note: This message will be shown only once. Set the verboseDeprecations ' +
    'config property to true to see every occurrence.';

  Deprecator.prototype.verboseDeprecations = function(enabled) {
    this.verbose_ = enabled;
  };

  // runnable is a spec or a suite.
  // deprecation is a string or an Error.
  // See Env#deprecated for a description of the options argument.
  Deprecator.prototype.addDeprecationWarning = function(
    runnable,
    deprecation,
    options
  ) {
    options = options || {};

    if (!this.verbose_ && !j$.isError_(deprecation)) {
      if (this.toSuppress_.indexOf(deprecation) !== -1) {
        return;
      }
      this.toSuppress_.push(deprecation);
    }

    this.log_(runnable, deprecation, options);
    this.report_(runnable, deprecation, options);
  };

  Deprecator.prototype.log_ = function(runnable, deprecation, options) {
    var context;

    if (j$.isError_(deprecation)) {
      console.error(deprecation);
      return;
    }

    if (runnable === this.topSuite_ || options.ignoreRunnable) {
      context = '';
    } else if (runnable.children) {
      context = ' (in suite: ' + runnable.getFullName() + ')';
    } else {
      context = ' (in spec: ' + runnable.getFullName() + ')';
    }

    if (!options.omitStackTrace) {
      context += '\n' + this.stackTrace_();
    }

    if (!this.verbose_) {
      context += '\n' + verboseNote;
    }

    console.error('DEPRECATION: ' + deprecation + context);
  };

  Deprecator.prototype.stackTrace_ = function() {
    var formatter = new j$.ExceptionFormatter();
    return formatter.stack(j$.util.errorWithStack()).replace(/^Error\n/m, '');
  };

  Deprecator.prototype.report_ = function(runnable, deprecation, options) {
    if (options.ignoreRunnable) {
      runnable = this.topSuite_;
    }

    if (j$.isError_(deprecation)) {
      runnable.addDeprecationWarning(deprecation);
      return;
    }

    if (!this.verbose_) {
      deprecation += '\n' + verboseNote;
    }

    runnable.addDeprecationWarning({
      message: deprecation,
      omitStackTrace: options.omitStackTrace || false
    });
  };

  return Deprecator;
};

getJasmineRequireObj().errors = function() {
  function ExpectationFailed() {}

  ExpectationFailed.prototype = new Error();
  ExpectationFailed.prototype.constructor = ExpectationFailed;

  return {
    ExpectationFailed: ExpectationFailed
  };
};

getJasmineRequireObj().ExceptionFormatter = function(j$) {
  var ignoredProperties = [
    'name',
    'message',
    'stack',
    'fileName',
    'sourceURL',
    'line',
    'lineNumber',
    'column',
    'description',
    'jasmineMessage'
  ];

  function ExceptionFormatter(options) {
    var jasmineFile = (options && options.jasmineFile) || j$.util.jasmineFile();
    this.message = function(error) {
      var message = '';

      if (error.jasmineMessage) {
        message += error.jasmineMessage;
      } else if (error.name && error.message) {
        message += error.name + ': ' + error.message;
      } else if (error.message) {
        message += error.message;
      } else {
        message += error.toString() + ' thrown';
      }

      if (error.fileName || error.sourceURL) {
        message += ' in ' + (error.fileName || error.sourceURL);
      }

      if (error.line || error.lineNumber) {
        message += ' (line ' + (error.line || error.lineNumber) + ')';
      }

      return message;
    };

    this.stack = function(error, { omitMessage } = {}) {
      if (!error || !error.stack) {
        return null;
      }

      var stackTrace = new j$.StackTrace(error);
      var lines = filterJasmine(stackTrace);
      var result = '';

      if (stackTrace.message && !omitMessage) {
        lines.unshift(stackTrace.message);
      }

      result += formatProperties(error);
      result += lines.join('\n');

      return result;
    };

    function filterJasmine(stackTrace) {
      var result = [],
        jasmineMarker =
          stackTrace.style === 'webkit' ? '<Jasmine>' : '    at <Jasmine>';

      stackTrace.frames.forEach(function(frame) {
        if (frame.file !== jasmineFile) {
          result.push(frame.raw);
        } else if (result[result.length - 1] !== jasmineMarker) {
          result.push(jasmineMarker);
        }
      });

      return result;
    }

    function formatProperties(error) {
      if (!(error instanceof Object)) {
        return;
      }

      var result = {};
      var empty = true;

      for (var prop in error) {
        if (j$.util.arrayContains(ignoredProperties, prop)) {
          continue;
        }
        result[prop] = error[prop];
        empty = false;
      }

      if (!empty) {
        return 'error properties: ' + j$.basicPrettyPrinter_(result) + '\n';
      }

      return '';
    }
  }

  return ExceptionFormatter;
};

getJasmineRequireObj().Expectation = function(j$) {
  /**
   * Matchers that come with Jasmine out of the box.
   * @namespace matchers
   */
  function Expectation(options) {
    this.expector = new j$.Expector(options);

    var customMatchers = options.customMatchers || {};
    for (var matcherName in customMatchers) {
      this[matcherName] = wrapSyncCompare(
        matcherName,
        customMatchers[matcherName]
      );
    }
  }

  /**
   * Add some context for an {@link expect}
   * @function
   * @name matchers#withContext
   * @since 3.3.0
   * @param {String} message - Additional context to show when the matcher fails
   * @return {matchers}
   */
  Expectation.prototype.withContext = function withContext(message) {
    return addFilter(this, new ContextAddingFilter(message));
  };

  /**
   * Invert the matcher following this {@link expect}
   * @member
   * @name matchers#not
   * @since 1.3.0
   * @type {matchers}
   * @example
   * expect(something).not.toBe(true);
   */
  Object.defineProperty(Expectation.prototype, 'not', {
    get: function() {
      return addFilter(this, syncNegatingFilter);
    }
  });

  /**
   * Asynchronous matchers that operate on an actual value which is a promise,
   * and return a promise.
   *
   * Most async matchers will wait indefinitely for the promise to be resolved
   * or rejected, resulting in a spec timeout if that never happens. If you
   * expect that the promise will already be resolved or rejected at the time
   * the matcher is called, you can use the {@link async-matchers#already}
   * modifier to get a faster failure with a more helpful message.
   *
   * Note: Specs must await the result of each async matcher, return the
   * promise returned by the matcher, or return a promise that's derived from
   * the one returned by the matcher. Otherwise the matcher will not be
   * evaluated before the spec completes.
   *
   * @example
   * // Good
   * await expectAsync(aPromise).toBeResolved();
   * @example
   * // Good
   * return expectAsync(aPromise).toBeResolved();
   * @example
   * // Good
   * return expectAsync(aPromise).toBeResolved()
   *  .then(function() {
   *    // more spec code
   *  });
   * @example
   * // Bad
   * expectAsync(aPromise).toBeResolved();
   * @namespace async-matchers
   */
  function AsyncExpectation(options) {
    this.expector = new j$.Expector(options);

    var customAsyncMatchers = options.customAsyncMatchers || {};
    for (var matcherName in customAsyncMatchers) {
      this[matcherName] = wrapAsyncCompare(
        matcherName,
        customAsyncMatchers[matcherName]
      );
    }
  }

  /**
   * Add some context for an {@link expectAsync}
   * @function
   * @name async-matchers#withContext
   * @since 3.3.0
   * @param {String} message - Additional context to show when the async matcher fails
   * @return {async-matchers}
   */
  AsyncExpectation.prototype.withContext = function withContext(message) {
    return addFilter(this, new ContextAddingFilter(message));
  };

  /**
   * Invert the matcher following this {@link expectAsync}
   * @member
   * @name async-matchers#not
   * @type {async-matchers}
   * @example
   * await expectAsync(myPromise).not.toBeResolved();
   * @example
   * return expectAsync(myPromise).not.toBeResolved();
   */
  Object.defineProperty(AsyncExpectation.prototype, 'not', {
    get: function() {
      return addFilter(this, asyncNegatingFilter);
    }
  });

  /**
   * Fail as soon as possible if the actual is pending.
   * Otherwise evaluate the matcher.
   * @member
   * @name async-matchers#already
   * @since 3.8.0
   * @type {async-matchers}
   * @example
   * await expectAsync(myPromise).already.toBeResolved();
   * @example
   * return expectAsync(myPromise).already.toBeResolved();
   */
  Object.defineProperty(AsyncExpectation.prototype, 'already', {
    get: function() {
      return addFilter(this, expectSettledPromiseFilter);
    }
  });

  function wrapSyncCompare(name, matcherFactory) {
    return function() {
      var result = this.expector.compare(name, matcherFactory, arguments);
      this.expector.processResult(result);
    };
  }

  function wrapAsyncCompare(name, matcherFactory) {
    return function() {
      var self = this;

      // Capture the call stack here, before we go async, so that it will contain
      // frames that are relevant to the user instead of just parts of Jasmine.
      var errorForStack = j$.util.errorWithStack();

      return this.expector
        .compare(name, matcherFactory, arguments)
        .then(function(result) {
          self.expector.processResult(result, errorForStack);
        });
    };
  }

  function addCoreMatchers(prototype, matchers, wrapper) {
    for (var matcherName in matchers) {
      var matcher = matchers[matcherName];
      prototype[matcherName] = wrapper(matcherName, matcher);
    }
  }

  function addFilter(source, filter) {
    var result = Object.create(source);
    result.expector = source.expector.addFilter(filter);
    return result;
  }

  function negatedFailureMessage(result, matcherName, args, matchersUtil) {
    if (result.message) {
      if (j$.isFunction_(result.message)) {
        return result.message();
      } else {
        return result.message;
      }
    }

    args = args.slice();
    args.unshift(true);
    args.unshift(matcherName);
    return matchersUtil.buildFailureMessage.apply(matchersUtil, args);
  }

  function negate(result) {
    result.pass = !result.pass;
    return result;
  }

  var syncNegatingFilter = {
    selectComparisonFunc: function(matcher) {
      function defaultNegativeCompare() {
        return negate(matcher.compare.apply(null, arguments));
      }

      return matcher.negativeCompare || defaultNegativeCompare;
    },
    buildFailureMessage: negatedFailureMessage
  };

  var asyncNegatingFilter = {
    selectComparisonFunc: function(matcher) {
      function defaultNegativeCompare() {
        return matcher.compare.apply(this, arguments).then(negate);
      }

      return matcher.negativeCompare || defaultNegativeCompare;
    },
    buildFailureMessage: negatedFailureMessage
  };

  var expectSettledPromiseFilter = {
    selectComparisonFunc: function(matcher) {
      return function(actual) {
        var matcherArgs = arguments;

        return j$.isPending_(actual).then(function(isPending) {
          if (isPending) {
            return {
              pass: false,
              message:
                'Expected a promise to be settled (via ' +
                'expectAsync(...).already) but it was pending.'
            };
          } else {
            return matcher.compare.apply(null, matcherArgs);
          }
        });
      };
    }
  };

  function ContextAddingFilter(message) {
    this.message = message;
  }

  ContextAddingFilter.prototype.modifyFailureMessage = function(msg) {
    var nl = msg.indexOf('\n');

    if (nl === -1) {
      return this.message + ': ' + msg;
    } else {
      return this.message + ':\n' + indent(msg);
    }
  };

  function indent(s) {
    return s.replace(/^/gm, '    ');
  }

  return {
    factory: function(options) {
      return new Expectation(options || {});
    },
    addCoreMatchers: function(matchers) {
      addCoreMatchers(Expectation.prototype, matchers, wrapSyncCompare);
    },
    asyncFactory: function(options) {
      return new AsyncExpectation(options || {});
    },
    addAsyncCoreMatchers: function(matchers) {
      addCoreMatchers(AsyncExpectation.prototype, matchers, wrapAsyncCompare);
    }
  };
};

getJasmineRequireObj().ExpectationFilterChain = function() {
  function ExpectationFilterChain(maybeFilter, prev) {
    this.filter_ = maybeFilter;
    this.prev_ = prev;
  }

  ExpectationFilterChain.prototype.addFilter = function(filter) {
    return new ExpectationFilterChain(filter, this);
  };

  ExpectationFilterChain.prototype.selectComparisonFunc = function(matcher) {
    return this.callFirst_('selectComparisonFunc', arguments).result;
  };

  ExpectationFilterChain.prototype.buildFailureMessage = function(
    result,
    matcherName,
    args,
    matchersUtil
  ) {
    return this.callFirst_('buildFailureMessage', arguments).result;
  };

  ExpectationFilterChain.prototype.modifyFailureMessage = function(msg) {
    var result = this.callFirst_('modifyFailureMessage', arguments).result;
    return result || msg;
  };

  ExpectationFilterChain.prototype.callFirst_ = function(fname, args) {
    var prevResult;

    if (this.prev_) {
      prevResult = this.prev_.callFirst_(fname, args);

      if (prevResult.found) {
        return prevResult;
      }
    }

    if (this.filter_ && this.filter_[fname]) {
      return {
        found: true,
        result: this.filter_[fname].apply(this.filter_, args)
      };
    }

    return { found: false };
  };

  return ExpectationFilterChain;
};

//TODO: expectation result may make more sense as a presentation of an expectation.
getJasmineRequireObj().buildExpectationResult = function(j$) {
  function buildExpectationResult(options) {
    var messageFormatter = options.messageFormatter || function() {},
      stackFormatter = options.stackFormatter || function() {};

    /**
     * @typedef Expectation
     * @property {String} matcherName - The name of the matcher that was executed for this expectation.
     * @property {String} message - The failure message for the expectation.
     * @property {String} stack - The stack trace for the failure if available.
     * @property {Boolean} passed - Whether the expectation passed or failed.
     * @property {Object} expected - If the expectation failed, what was the expected value.
     * @property {Object} actual - If the expectation failed, what actual value was produced.
     * @property {String|undefined} globalErrorType - The type of an error that
     * is reported on the top suite. Valid values are undefined, "afterAll",
     * "load", "lateExpectation", and "lateError".
     */
    var result = {
      matcherName: options.matcherName,
      message: message(),
      stack: options.omitStackTrace ? '' : stack(),
      passed: options.passed
    };

    if (!result.passed) {
      result.expected = options.expected;
      result.actual = options.actual;

      if (options.error && !j$.isString_(options.error)) {
        if ('code' in options.error) {
          result.code = options.error.code;
        }

        if (
          options.error.code === 'ERR_ASSERTION' &&
          options.expected === '' &&
          options.actual === ''
        ) {
          result.expected = options.error.expected;
          result.actual = options.error.actual;
          result.matcherName = 'assert ' + options.error.operator;
        }
      }
    }

    return result;

    function message() {
      if (options.passed) {
        return 'Passed.';
      } else if (options.message) {
        return options.message;
      } else if (options.error) {
        return messageFormatter(options.error);
      }
      return '';
    }

    function stack() {
      if (options.passed) {
        return '';
      }

      var error = options.error;
      if (!error) {
        if (options.errorForStack) {
          error = options.errorForStack;
        } else if (options.stack) {
          error = options;
        } else {
          try {
            throw new Error(message());
          } catch (e) {
            error = e;
          }
        }
      }
      // Omit the message from the stack trace because it will be
      // included elsewhere.
      return stackFormatter(error, { omitMessage: true });
    }
  }

  return buildExpectationResult;
};

getJasmineRequireObj().Expector = function(j$) {
  function Expector(options) {
    this.matchersUtil = options.matchersUtil || {
      buildFailureMessage: function() {}
    };
    this.actual = options.actual;
    this.addExpectationResult = options.addExpectationResult || function() {};
    this.filters = new j$.ExpectationFilterChain();
  }

  Expector.prototype.instantiateMatcher = function(
    matcherName,
    matcherFactory,
    args
  ) {
    this.matcherName = matcherName;
    this.args = Array.prototype.slice.call(args, 0);
    this.expected = this.args.slice(0);

    this.args.unshift(this.actual);

    var matcher = matcherFactory(this.matchersUtil);

    var comparisonFunc = this.filters.selectComparisonFunc(matcher);
    return comparisonFunc || matcher.compare;
  };

  Expector.prototype.buildMessage = function(result) {
    var self = this;

    if (result.pass) {
      return '';
    }

    var msg = this.filters.buildFailureMessage(
      result,
      this.matcherName,
      this.args,
      this.matchersUtil,
      defaultMessage
    );
    return this.filters.modifyFailureMessage(msg || defaultMessage());

    function defaultMessage() {
      if (!result.message) {
        var args = self.args.slice();
        args.unshift(false);
        args.unshift(self.matcherName);
        return self.matchersUtil.buildFailureMessage.apply(
          self.matchersUtil,
          args
        );
      } else if (j$.isFunction_(result.message)) {
        return result.message();
      } else {
        return result.message;
      }
    }
  };

  Expector.prototype.compare = function(matcherName, matcherFactory, args) {
    var matcherCompare = this.instantiateMatcher(
      matcherName,
      matcherFactory,
      args
    );
    return matcherCompare.apply(null, this.args);
  };

  Expector.prototype.addFilter = function(filter) {
    var result = Object.create(this);
    result.filters = this.filters.addFilter(filter);
    return result;
  };

  Expector.prototype.processResult = function(result, errorForStack) {
    var message = this.buildMessage(result);

    if (this.expected.length === 1) {
      this.expected = this.expected[0];
    }

    this.addExpectationResult(result.pass, {
      matcherName: this.matcherName,
      passed: result.pass,
      message: message,
      error: errorForStack ? undefined : result.error,
      errorForStack: errorForStack || undefined,
      actual: this.actual,
      expected: this.expected // TODO: this may need to be arrayified/sliced
    });
  };

  return Expector;
};

getJasmineRequireObj().formatErrorMsg = function() {
  function generateErrorMsg(domain, usage) {
    var usageDefinition = usage ? '\nUsage: ' + usage : '';

    return function errorMsg(msg) {
      return domain + ' : ' + msg + usageDefinition;
    };
  }

  return generateErrorMsg;
};

getJasmineRequireObj().GlobalErrors = function(j$) {
  function GlobalErrors(global) {
    var handlers = [];
    global = global || j$.getGlobal();

    var onerror = function onerror() {
      var handler = handlers[handlers.length - 1];

      if (handler) {
        handler.apply(null, Array.prototype.slice.call(arguments, 0));
      } else {
        throw arguments[0];
      }
    };

    this.originalHandlers = {};
    this.jasmineHandlers = {};
    this.installOne_ = function installOne_(errorType, jasmineMessage) {
      function taggedOnError(error) {
        var substituteMsg;

        if (j$.isError_(error)) {
          error.jasmineMessage = jasmineMessage + ': ' + error;
        } else {
          if (error) {
            substituteMsg = jasmineMessage + ': ' + error;
          } else {
            substituteMsg = jasmineMessage + ' with no error or message';
          }

          if (errorType === 'unhandledRejection') {
            substituteMsg +=
              '\n' +
              '(Tip: to get a useful stack trace, use ' +
              'Promise.reject(new Error(...)) instead of Promise.reject(' +
              (error ? '...' : '') +
              ').)';
          }

          error = new Error(substituteMsg);
        }

        var handler = handlers[handlers.length - 1];

        if (handler) {
          handler(error);
        } else {
          throw error;
        }
      }

      this.originalHandlers[errorType] = global.process.listeners(errorType);
      this.jasmineHandlers[errorType] = taggedOnError;

      global.process.removeAllListeners(errorType);
      global.process.on(errorType, taggedOnError);

      this.uninstall = function uninstall() {
        var errorTypes = Object.keys(this.originalHandlers);
        for (var iType = 0; iType < errorTypes.length; iType++) {
          var errorType = errorTypes[iType];
          global.process.removeListener(
            errorType,
            this.jasmineHandlers[errorType]
          );
          for (var i = 0; i < this.originalHandlers[errorType].length; i++) {
            global.process.on(errorType, this.originalHandlers[errorType][i]);
          }
          delete this.originalHandlers[errorType];
          delete this.jasmineHandlers[errorType];
        }
      };
    };

    this.install = function install() {
      if (
        global.process &&
        global.process.listeners &&
        j$.isFunction_(global.process.on)
      ) {
        this.installOne_('uncaughtException', 'Uncaught exception');
        this.installOne_('unhandledRejection', 'Unhandled promise rejection');
      } else {
        var originalHandler = global.onerror;
        global.onerror = onerror;

        var browserRejectionHandler = function browserRejectionHandler(event) {
          if (j$.isError_(event.reason)) {
            event.reason.jasmineMessage =
              'Unhandled promise rejection: ' + event.reason;
            global.onerror(event.reason);
          } else {
            global.onerror('Unhandled promise rejection: ' + event.reason);
          }
        };

        if (global.addEventListener) {
          global.addEventListener(
            'unhandledrejection',
            browserRejectionHandler
          );
        }

        this.uninstall = function uninstall() {
          global.onerror = originalHandler;
          if (global.removeEventListener) {
            global.removeEventListener(
              'unhandledrejection',
              browserRejectionHandler
            );
          }
        };
      }
    };

    this.pushListener = function pushListener(listener) {
      handlers.push(listener);
    };

    this.popListener = function popListener(listener) {
      if (!listener) {
        throw new Error('popListener expects a listener');
      }

      handlers.pop();
    };
  }

  return GlobalErrors;
};

getJasmineRequireObj().toBePending = function(j$) {
  /**
   * Expect a promise to be pending, i.e. the promise is neither resolved nor rejected.
   * @function
   * @async
   * @name async-matchers#toBePending
   * @since 3.6
   * @example
   * await expectAsync(aPromise).toBePending();
   */
  return function toBePending() {
    return {
      compare: function(actual) {
        if (!j$.isPromiseLike(actual)) {
          throw new Error('Expected toBePending to be called on a promise.');
        }
        var want = {};
        return Promise.race([actual, Promise.resolve(want)]).then(
          function(got) {
            return { pass: want === got };
          },
          function() {
            return { pass: false };
          }
        );
      }
    };
  };
};

getJasmineRequireObj().toBeRejected = function(j$) {
  /**
   * Expect a promise to be rejected.
   * @function
   * @async
   * @name async-matchers#toBeRejected
   * @since 3.1.0
   * @example
   * await expectAsync(aPromise).toBeRejected();
   * @example
   * return expectAsync(aPromise).toBeRejected();
   */
  return function toBeRejected() {
    return {
      compare: function(actual) {
        if (!j$.isPromiseLike(actual)) {
          throw new Error('Expected toBeRejected to be called on a promise.');
        }
        return actual.then(
          function() {
            return { pass: false };
          },
          function() {
            return { pass: true };
          }
        );
      }
    };
  };
};

getJasmineRequireObj().toBeRejectedWith = function(j$) {
  /**
   * Expect a promise to be rejected with a value equal to the expected, using deep equality comparison.
   * @function
   * @async
   * @name async-matchers#toBeRejectedWith
   * @since 3.3.0
   * @param {Object} expected - Value that the promise is expected to be rejected with
   * @example
   * await expectAsync(aPromise).toBeRejectedWith({prop: 'value'});
   * @example
   * return expectAsync(aPromise).toBeRejectedWith({prop: 'value'});
   */
  return function toBeRejectedWith(matchersUtil) {
    return {
      compare: function(actualPromise, expectedValue) {
        if (!j$.isPromiseLike(actualPromise)) {
          throw new Error(
            'Expected toBeRejectedWith to be called on a promise.'
          );
        }

        function prefix(passed) {
          return (
            'Expected a promise ' +
            (passed ? 'not ' : '') +
            'to be rejected with ' +
            matchersUtil.pp(expectedValue)
          );
        }

        return actualPromise.then(
          function() {
            return {
              pass: false,
              message: prefix(false) + ' but it was resolved.'
            };
          },
          function(actualValue) {
            if (matchersUtil.equals(actualValue, expectedValue)) {
              return {
                pass: true,
                message: prefix(true) + '.'
              };
            } else {
              return {
                pass: false,
                message:
                  prefix(false) +
                  ' but it was rejected with ' +
                  matchersUtil.pp(actualValue) +
                  '.'
              };
            }
          }
        );
      }
    };
  };
};

getJasmineRequireObj().toBeRejectedWithError = function(j$) {
  /**
   * Expect a promise to be rejected with a value matched to the expected
   * @function
   * @async
   * @name async-matchers#toBeRejectedWithError
   * @since 3.5.0
   * @param {Error} [expected] - `Error` constructor the object that was thrown needs to be an instance of. If not provided, `Error` will be used.
   * @param {RegExp|String} [message] - The message that should be set on the thrown `Error`
   * @example
   * await expectAsync(aPromise).toBeRejectedWithError(MyCustomError, 'Error message');
   * await expectAsync(aPromise).toBeRejectedWithError(MyCustomError, /Error message/);
   * await expectAsync(aPromise).toBeRejectedWithError(MyCustomError);
   * await expectAsync(aPromise).toBeRejectedWithError('Error message');
   * return expectAsync(aPromise).toBeRejectedWithError(/Error message/);
   */
  return function toBeRejectedWithError(matchersUtil) {
    return {
      compare: function(actualPromise, arg1, arg2) {
        if (!j$.isPromiseLike(actualPromise)) {
          throw new Error(
            'Expected toBeRejectedWithError to be called on a promise.'
          );
        }

        var expected = getExpectedFromArgs(arg1, arg2, matchersUtil);

        return actualPromise.then(
          function() {
            return {
              pass: false,
              message: 'Expected a promise to be rejected but it was resolved.'
            };
          },
          function(actualValue) {
            return matchError(actualValue, expected, matchersUtil);
          }
        );
      }
    };
  };

  function matchError(actual, expected, matchersUtil) {
    if (!j$.isError_(actual)) {
      return fail(expected, 'rejected with ' + matchersUtil.pp(actual));
    }

    if (!(actual instanceof expected.error)) {
      return fail(
        expected,
        'rejected with type ' + j$.fnNameFor(actual.constructor)
      );
    }

    var actualMessage = actual.message;

    if (
      actualMessage === expected.message ||
      typeof expected.message === 'undefined'
    ) {
      return pass(expected);
    }

    if (
      expected.message instanceof RegExp &&
      expected.message.test(actualMessage)
    ) {
      return pass(expected);
    }

    return fail(expected, 'rejected with ' + matchersUtil.pp(actual));
  }

  function pass(expected) {
    return {
      pass: true,
      message:
        'Expected a promise not to be rejected with ' +
        expected.printValue +
        ', but it was.'
    };
  }

  function fail(expected, message) {
    return {
      pass: false,
      message:
        'Expected a promise to be rejected with ' +
        expected.printValue +
        ' but it was ' +
        message +
        '.'
    };
  }

  function getExpectedFromArgs(arg1, arg2, matchersUtil) {
    var error, message;

    if (isErrorConstructor(arg1)) {
      error = arg1;
      message = arg2;
    } else {
      error = Error;
      message = arg1;
    }

    return {
      error: error,
      message: message,
      printValue:
        j$.fnNameFor(error) +
        (typeof message === 'undefined' ? '' : ': ' + matchersUtil.pp(message))
    };
  }

  function isErrorConstructor(value) {
    return (
      typeof value === 'function' &&
      (value === Error || j$.isError_(value.prototype))
    );
  }
};

getJasmineRequireObj().toBeResolved = function(j$) {
  /**
   * Expect a promise to be resolved.
   * @function
   * @async
   * @name async-matchers#toBeResolved
   * @since 3.1.0
   * @example
   * await expectAsync(aPromise).toBeResolved();
   * @example
   * return expectAsync(aPromise).toBeResolved();
   */
  return function toBeResolved(matchersUtil) {
    return {
      compare: function(actual) {
        if (!j$.isPromiseLike(actual)) {
          throw new Error('Expected toBeResolved to be called on a promise.');
        }

        return actual.then(
          function() {
            return { pass: true };
          },
          function(e) {
            return {
              pass: false,
              message:
                'Expected a promise to be resolved but it was ' +
                'rejected with ' +
                matchersUtil.pp(e) +
                '.'
            };
          }
        );
      }
    };
  };
};

getJasmineRequireObj().toBeResolvedTo = function(j$) {
  /**
   * Expect a promise to be resolved to a value equal to the expected, using deep equality comparison.
   * @function
   * @async
   * @name async-matchers#toBeResolvedTo
   * @since 3.1.0
   * @param {Object} expected - Value that the promise is expected to resolve to
   * @example
   * await expectAsync(aPromise).toBeResolvedTo({prop: 'value'});
   * @example
   * return expectAsync(aPromise).toBeResolvedTo({prop: 'value'});
   */
  return function toBeResolvedTo(matchersUtil) {
    return {
      compare: function(actualPromise, expectedValue) {
        if (!j$.isPromiseLike(actualPromise)) {
          throw new Error('Expected toBeResolvedTo to be called on a promise.');
        }

        function prefix(passed) {
          return (
            'Expected a promise ' +
            (passed ? 'not ' : '') +
            'to be resolved to ' +
            matchersUtil.pp(expectedValue)
          );
        }

        return actualPromise.then(
          function(actualValue) {
            if (matchersUtil.equals(actualValue, expectedValue)) {
              return {
                pass: true,
                message: prefix(true) + '.'
              };
            } else {
              return {
                pass: false,
                message:
                  prefix(false) +
                  ' but it was resolved to ' +
                  matchersUtil.pp(actualValue) +
                  '.'
              };
            }
          },
          function(e) {
            return {
              pass: false,
              message:
                prefix(false) +
                ' but it was rejected with ' +
                matchersUtil.pp(e) +
                '.'
            };
          }
        );
      }
    };
  };
};

getJasmineRequireObj().DiffBuilder = function(j$) {
  return function DiffBuilder(config) {
    var prettyPrinter = (config || {}).prettyPrinter || j$.makePrettyPrinter(),
      mismatches = new j$.MismatchTree(),
      path = new j$.ObjectPath(),
      actualRoot = undefined,
      expectedRoot = undefined;

    return {
      setRoots: function(actual, expected) {
        actualRoot = actual;
        expectedRoot = expected;
      },

      recordMismatch: function(formatter) {
        mismatches.add(path, formatter);
      },

      getMessage: function() {
        var messages = [];

        mismatches.traverse(function(path, isLeaf, formatter) {
          var actualCustom,
            expectedCustom,
            useCustom,
            derefResult = dereferencePath(
              path,
              actualRoot,
              expectedRoot,
              prettyPrinter
            ),
            actual = derefResult.actual,
            expected = derefResult.expected;

          if (formatter) {
            messages.push(formatter(actual, expected, path, prettyPrinter));
            return true;
          }

          actualCustom = prettyPrinter.customFormat_(actual);
          expectedCustom = prettyPrinter.customFormat_(expected);
          useCustom = !(
            j$.util.isUndefined(actualCustom) &&
            j$.util.isUndefined(expectedCustom)
          );

          if (useCustom) {
            messages.push(
              wrapPrettyPrinted(actualCustom, expectedCustom, path)
            );
            return false; // don't recurse further
          }

          if (isLeaf) {
            messages.push(
              defaultFormatter(actual, expected, path, prettyPrinter)
            );
          }

          return true;
        });

        return messages.join('\n');
      },

      withPath: function(pathComponent, block) {
        var oldPath = path;
        path = path.add(pathComponent);
        block();
        path = oldPath;
      }
    };

    function defaultFormatter(actual, expected, path, prettyPrinter) {
      return wrapPrettyPrinted(
        prettyPrinter(actual),
        prettyPrinter(expected),
        path
      );
    }

    function wrapPrettyPrinted(actual, expected, path) {
      return (
        'Expected ' +
        path +
        (path.depth() ? ' = ' : '') +
        actual +
        ' to equal ' +
        expected +
        '.'
      );
    }
  };

  function dereferencePath(objectPath, actual, expected, pp) {
    function handleAsymmetricExpected() {
      if (
        j$.isAsymmetricEqualityTester_(expected) &&
        j$.isFunction_(expected.valuesForDiff_)
      ) {
        var asymmetricResult = expected.valuesForDiff_(actual, pp);
        expected = asymmetricResult.self;
        actual = asymmetricResult.other;
      }
    }

    var i;
    handleAsymmetricExpected();

    for (i = 0; i < objectPath.components.length; i++) {
      actual = actual[objectPath.components[i]];
      expected = expected[objectPath.components[i]];
      handleAsymmetricExpected();
    }

    return { actual: actual, expected: expected };
  }
};

getJasmineRequireObj().MatchersUtil = function(j$) {
  /**
   * @class MatchersUtil
   * @classdesc Utilities for use in implementing matchers.<br>
   * _Note:_ Do not construct this directly. Jasmine will construct one and
   * pass it to matchers and asymmetric equality testers.
   * @hideconstructor
   */
  function MatchersUtil(options) {
    options = options || {};
    this.customTesters_ = options.customTesters || [];
    /**
     * Formats a value for use in matcher failure messages and similar contexts,
     * taking into account the current set of custom value formatters.
     * @function
     * @name MatchersUtil#pp
     * @since 3.6.0
     * @param {*} value The value to pretty-print
     * @return {string} The pretty-printed value
     */
    this.pp = options.pp || function() {};
  }

  /**
   * Determines whether `haystack` contains `needle`, using the same comparison
   * logic as {@link MatchersUtil#equals}.
   * @function
   * @name MatchersUtil#contains
   * @since 2.0.0
   * @param {*} haystack The collection to search
   * @param {*} needle The value to search for
   * @returns {boolean} True if `needle` was found in `haystack`
   */
  MatchersUtil.prototype.contains = function(haystack, needle) {
    if (!haystack) {
      return false;
    }

    if (j$.isSet(haystack)) {
      // Try .has() first. It should be faster in cases where
      // needle === something in haystack. Fall back to .equals() comparison
      // if that fails.
      if (haystack.has(needle)) {
        return true;
      }
    }

    if (j$.isIterable_(haystack) && !j$.isString_(haystack)) {
      // Arrays, Sets, etc.
      for (const candidate of haystack) {
        if (this.equals(candidate, needle)) {
          return true;
        }
      }

      return false;
    }

    if (haystack.indexOf) {
      // Mainly strings
      return haystack.indexOf(needle) >= 0;
    }

    if (j$.isNumber_(haystack.length)) {
      // Objects that are shaped like arrays but aren't iterable
      for (var i = 0; i < haystack.length; i++) {
        if (this.equals(haystack[i], needle)) {
          return true;
        }
      }
    }

    return false;
  };

  MatchersUtil.prototype.buildFailureMessage = function() {
    var self = this;
    var args = Array.prototype.slice.call(arguments, 0),
      matcherName = args[0],
      isNot = args[1],
      actual = args[2],
      expected = args.slice(3),
      englishyPredicate = matcherName.replace(/[A-Z]/g, function(s) {
        return ' ' + s.toLowerCase();
      });

    var message =
      'Expected ' +
      self.pp(actual) +
      (isNot ? ' not ' : ' ') +
      englishyPredicate;

    if (expected.length > 0) {
      for (var i = 0; i < expected.length; i++) {
        if (i > 0) {
          message += ',';
        }
        message += ' ' + self.pp(expected[i]);
      }
    }

    return message + '.';
  };

  MatchersUtil.prototype.asymmetricDiff_ = function(
    a,
    b,
    aStack,
    bStack,
    diffBuilder
  ) {
    if (j$.isFunction_(b.valuesForDiff_)) {
      var values = b.valuesForDiff_(a, this.pp);
      this.eq_(values.other, values.self, aStack, bStack, diffBuilder);
    } else {
      diffBuilder.recordMismatch();
    }
  };

  MatchersUtil.prototype.asymmetricMatch_ = function(
    a,
    b,
    aStack,
    bStack,
    diffBuilder
  ) {
    var asymmetricA = j$.isAsymmetricEqualityTester_(a),
      asymmetricB = j$.isAsymmetricEqualityTester_(b),
      result;

    if (asymmetricA === asymmetricB) {
      return undefined;
    }

    if (asymmetricA) {
      result = a.asymmetricMatch(b, this);
      if (!result) {
        diffBuilder.recordMismatch();
      }
      return result;
    }

    if (asymmetricB) {
      result = b.asymmetricMatch(a, this);
      if (!result) {
        this.asymmetricDiff_(a, b, aStack, bStack, diffBuilder);
      }
      return result;
    }
  };

  /**
   * Determines whether two values are deeply equal to each other.
   * @function
   * @name MatchersUtil#equals
   * @since 2.0.0
   * @param {*} a The first value to compare
   * @param {*} b The second value to compare
   * @returns {boolean} True if the values are equal
   */
  MatchersUtil.prototype.equals = function(a, b, diffBuilder) {
    diffBuilder = diffBuilder || j$.NullDiffBuilder();
    diffBuilder.setRoots(a, b);

    return this.eq_(a, b, [], [], diffBuilder);
  };

  // Equality function lovingly adapted from isEqual in
  //   [Underscore](http://underscorejs.org)
  MatchersUtil.prototype.eq_ = function(a, b, aStack, bStack, diffBuilder) {
    var result = true,
      self = this,
      i;

    var asymmetricResult = this.asymmetricMatch_(
      a,
      b,
      aStack,
      bStack,
      diffBuilder
    );
    if (!j$.util.isUndefined(asymmetricResult)) {
      return asymmetricResult;
    }

    for (i = 0; i < this.customTesters_.length; i++) {
      var customTesterResult = this.customTesters_[i](a, b);
      if (!j$.util.isUndefined(customTesterResult)) {
        if (!customTesterResult) {
          diffBuilder.recordMismatch();
        }
        return customTesterResult;
      }
    }

    if (a instanceof Error && b instanceof Error) {
      result = a.message == b.message;
      if (!result) {
        diffBuilder.recordMismatch();
      }
      return result;
    }

    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) {
      result = a !== 0 || 1 / a == 1 / b;
      if (!result) {
        diffBuilder.recordMismatch();
      }
      return result;
    }
    // A strict comparison is necessary because `null == undefined`.
    if (a === null || b === null) {
      result = a === b;
      if (!result) {
        diffBuilder.recordMismatch();
      }
      return result;
    }
    var className = Object.prototype.toString.call(a);
    if (className != Object.prototype.toString.call(b)) {
      diffBuilder.recordMismatch();
      return false;
    }
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        result = a == String(b);
        if (!result) {
          diffBuilder.recordMismatch();
        }
        return result;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        result =
          a != +a ? b != +b : a === 0 && b === 0 ? 1 / a == 1 / b : a == +b;
        if (!result) {
          diffBuilder.recordMismatch();
        }
        return result;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        result = +a == +b;
        if (!result) {
          diffBuilder.recordMismatch();
        }
        return result;
      case '[object ArrayBuffer]':
        // If we have an instance of ArrayBuffer the Uint8Array ctor
        // will be defined as well
        return self.eq_(
          new Uint8Array(a),
          new Uint8Array(b),
          aStack,
          bStack,
          diffBuilder
        );
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return (
          a.source == b.source &&
          a.global == b.global &&
          a.multiline == b.multiline &&
          a.ignoreCase == b.ignoreCase
        );
    }
    if (typeof a != 'object' || typeof b != 'object') {
      diffBuilder.recordMismatch();
      return false;
    }

    var aIsDomNode = j$.isDomNode(a);
    var bIsDomNode = j$.isDomNode(b);
    if (aIsDomNode && bIsDomNode) {
      // At first try to use DOM3 method isEqualNode
      result = a.isEqualNode(b);
      if (!result) {
        diffBuilder.recordMismatch();
      }
      return result;
    }
    if (aIsDomNode || bIsDomNode) {
      diffBuilder.recordMismatch();
      return false;
    }

    var aIsPromise = j$.isPromise(a);
    var bIsPromise = j$.isPromise(b);
    if (aIsPromise && bIsPromise) {
      return a === b;
    }

    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) {
        return bStack[length] == b;
      }
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0;
    // Recursively compare objects and arrays.
    // Compare array lengths to determine if a deep comparison is necessary.
    if (className == '[object Array]') {
      var aLength = a.length;
      var bLength = b.length;

      diffBuilder.withPath('length', function() {
        if (aLength !== bLength) {
          diffBuilder.recordMismatch();
          result = false;
        }
      });

      for (i = 0; i < aLength || i < bLength; i++) {
        diffBuilder.withPath(i, function() {
          if (i >= bLength) {
            diffBuilder.recordMismatch(
              actualArrayIsLongerFormatter.bind(null, self.pp)
            );
            result = false;
          } else {
            result =
              self.eq_(
                i < aLength ? a[i] : void 0,
                i < bLength ? b[i] : void 0,
                aStack,
                bStack,
                diffBuilder
              ) && result;
          }
        });
      }
      if (!result) {
        return false;
      }
    } else if (j$.isMap(a) && j$.isMap(b)) {
      if (a.size != b.size) {
        diffBuilder.recordMismatch();
        return false;
      }

      var keysA = [];
      var keysB = [];
      a.forEach(function(valueA, keyA) {
        keysA.push(keyA);
      });
      b.forEach(function(valueB, keyB) {
        keysB.push(keyB);
      });

      // For both sets of keys, check they map to equal values in both maps.
      // Keep track of corresponding keys (in insertion order) in order to handle asymmetric obj keys.
      var mapKeys = [keysA, keysB];
      var cmpKeys = [keysB, keysA];
      var mapIter, mapKey, mapValueA, mapValueB;
      var cmpIter, cmpKey;
      for (i = 0; result && i < mapKeys.length; i++) {
        mapIter = mapKeys[i];
        cmpIter = cmpKeys[i];

        for (var j = 0; result && j < mapIter.length; j++) {
          mapKey = mapIter[j];
          cmpKey = cmpIter[j];
          mapValueA = a.get(mapKey);

          // Only use the cmpKey when one of the keys is asymmetric and the corresponding key matches,
          // otherwise explicitly look up the mapKey in the other Map since we want keys with unique
          // obj identity (that are otherwise equal) to not match.
          if (
            j$.isAsymmetricEqualityTester_(mapKey) ||
            (j$.isAsymmetricEqualityTester_(cmpKey) &&
              this.eq_(mapKey, cmpKey, aStack, bStack, j$.NullDiffBuilder()))
          ) {
            mapValueB = b.get(cmpKey);
          } else {
            mapValueB = b.get(mapKey);
          }
          result = this.eq_(
            mapValueA,
            mapValueB,
            aStack,
            bStack,
            j$.NullDiffBuilder()
          );
        }
      }

      if (!result) {
        diffBuilder.recordMismatch();
        return false;
      }
    } else if (j$.isSet(a) && j$.isSet(b)) {
      if (a.size != b.size) {
        diffBuilder.recordMismatch();
        return false;
      }

      var valuesA = [];
      a.forEach(function(valueA) {
        valuesA.push(valueA);
      });
      var valuesB = [];
      b.forEach(function(valueB) {
        valuesB.push(valueB);
      });

      // For both sets, check they are all contained in the other set
      var setPairs = [[valuesA, valuesB], [valuesB, valuesA]];
      var stackPairs = [[aStack, bStack], [bStack, aStack]];
      var baseValues, baseValue, baseStack;
      var otherValues, otherValue, otherStack;
      var found;
      var prevStackSize;
      for (i = 0; result && i < setPairs.length; i++) {
        baseValues = setPairs[i][0];
        otherValues = setPairs[i][1];
        baseStack = stackPairs[i][0];
        otherStack = stackPairs[i][1];
        // For each value in the base set...
        for (var k = 0; result && k < baseValues.length; k++) {
          baseValue = baseValues[k];
          found = false;
          // ... test that it is present in the other set
          for (var l = 0; !found && l < otherValues.length; l++) {
            otherValue = otherValues[l];
            prevStackSize = baseStack.length;
            // compare by value equality
            found = this.eq_(
              baseValue,
              otherValue,
              baseStack,
              otherStack,
              j$.NullDiffBuilder()
            );
            if (!found && prevStackSize !== baseStack.length) {
              baseStack.splice(prevStackSize);
              otherStack.splice(prevStackSize);
            }
          }
          result = result && found;
        }
      }

      if (!result) {
        diffBuilder.recordMismatch();
        return false;
      }
    } else if (j$.isURL(a) && j$.isURL(b)) {
      // URLs have no enumrable properties, so the default object comparison
      // would consider any two URLs to be equal.
      return a.toString() === b.toString();
    } else {
      // Objects with different constructors are not equivalent, but `Object`s
      // or `Array`s from different frames are.
      var aCtor = a.constructor,
        bCtor = b.constructor;
      if (
        aCtor !== bCtor &&
        isFunction(aCtor) &&
        isFunction(bCtor) &&
        a instanceof aCtor &&
        b instanceof bCtor &&
        !(aCtor instanceof aCtor && bCtor instanceof bCtor)
      ) {
        diffBuilder.recordMismatch(
          constructorsAreDifferentFormatter.bind(null, this.pp)
        );
        return false;
      }
    }

    // Deep compare objects.
    var aKeys = keys(a, className == '[object Array]'),
      key;
    size = aKeys.length;

    // Ensure that both objects contain the same number of properties before comparing deep equality.
    if (keys(b, className == '[object Array]').length !== size) {
      diffBuilder.recordMismatch(
        objectKeysAreDifferentFormatter.bind(null, this.pp)
      );
      return false;
    }

    for (i = 0; i < size; i++) {
      key = aKeys[i];
      // Deep compare each member
      if (!j$.util.has(b, key)) {
        diffBuilder.recordMismatch(
          objectKeysAreDifferentFormatter.bind(null, this.pp)
        );
        result = false;
        continue;
      }

      diffBuilder.withPath(key, function() {
        if (!self.eq_(a[key], b[key], aStack, bStack, diffBuilder)) {
          result = false;
        }
      });
    }

    if (!result) {
      return false;
    }

    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();

    return result;
  };

  function keys(obj, isArray) {
    var allKeys = Object.keys
      ? Object.keys(obj)
      : (function(o) {
          var keys = [];
          for (var key in o) {
            if (j$.util.has(o, key)) {
              keys.push(key);
            }
          }
          return keys;
        })(obj);

    if (!isArray) {
      return allKeys;
    }

    if (allKeys.length === 0) {
      return allKeys;
    }

    var extraKeys = [];
    for (var i = 0; i < allKeys.length; i++) {
      if (!/^[0-9]+$/.test(allKeys[i])) {
        extraKeys.push(allKeys[i]);
      }
    }

    return extraKeys;
  }

  function isFunction(obj) {
    return typeof obj === 'function';
  }

  function objectKeysAreDifferentFormatter(pp, actual, expected, path) {
    var missingProperties = j$.util.objectDifference(expected, actual),
      extraProperties = j$.util.objectDifference(actual, expected),
      missingPropertiesMessage = formatKeyValuePairs(pp, missingProperties),
      extraPropertiesMessage = formatKeyValuePairs(pp, extraProperties),
      messages = [];

    if (!path.depth()) {
      path = 'object';
    }

    if (missingPropertiesMessage.length) {
      messages.push(
        'Expected ' + path + ' to have properties' + missingPropertiesMessage
      );
    }

    if (extraPropertiesMessage.length) {
      messages.push(
        'Expected ' + path + ' not to have properties' + extraPropertiesMessage
      );
    }

    return messages.join('\n');
  }

  function constructorsAreDifferentFormatter(pp, actual, expected, path) {
    if (!path.depth()) {
      path = 'object';
    }

    return (
      'Expected ' +
      path +
      ' to be a kind of ' +
      j$.fnNameFor(expected.constructor) +
      ', but was ' +
      pp(actual) +
      '.'
    );
  }

  function actualArrayIsLongerFormatter(pp, actual, expected, path) {
    return (
      'Unexpected ' +
      path +
      (path.depth() ? ' = ' : '') +
      pp(actual) +
      ' in array.'
    );
  }

  function formatKeyValuePairs(pp, obj) {
    var formatted = '';
    for (var key in obj) {
      formatted += '\n    ' + key + ': ' + pp(obj[key]);
    }
    return formatted;
  }

  return MatchersUtil;
};

/**
 * @interface AsymmetricEqualityTester
 * @classdesc An asymmetric equality tester is an object that can match multiple
 * objects. Examples include jasmine.any() and jasmine.stringMatching(). Jasmine
 * includes a number of built-in asymmetric equality testers, such as
 * {@link jasmine.objectContaining}. User-defined asymmetric equality testers are
 * also supported.
 *
 * Asymmetric equality testers work with any matcher, including user-defined
 * custom matchers, that uses {@link MatchersUtil#equals} or
 * {@link MatchersUtil#contains}.
 *
 * @example
 * function numberDivisibleBy(divisor) {
 *   return {
 *     asymmetricMatch: function(n) {
 *       return typeof n === 'number' && n % divisor === 0;
 *     },
 *     jasmineToString: function() {
 *       return `<a number divisible by ${divisor}>`;
 *     }
 *   };
 * }
 *
 * var actual = {
 *   n: 2,
 *   otherFields: "don't care"
 * };
 *
 * expect(actual).toEqual(jasmine.objectContaining({n: numberDivisibleBy(2)}));
 * @see custom_asymmetric_equality_testers
 * @since 2.0.0
 */
/**
 * Determines whether a value matches this tester
 * @function
 * @name AsymmetricEqualityTester#asymmetricMatch
 * @param value {any} The value to test
 * @param matchersUtil {MatchersUtil} utilities for testing equality, etc
 * @return {Boolean}
 */
/**
 * Returns a string representation of this tester to use in matcher failure messages
 * @function
 * @name AsymmetricEqualityTester#jasmineToString
 * @param pp {function} Function that takes a value and returns a pretty-printed representation
 * @return {String}
 */

getJasmineRequireObj().MismatchTree = function(j$) {
  /*
    To be able to apply custom object formatters at all possible levels of an
    object graph, DiffBuilder needs to be able to know not just where the
    mismatch occurred but also all ancestors of the mismatched value in both
    the expected and actual object graphs. MismatchTree maintains that context
    and provides it via the traverse method.
   */
  function MismatchTree(path) {
    this.path = path || new j$.ObjectPath([]);
    this.formatter = undefined;
    this.children = [];
    this.isMismatch = false;
  }

  MismatchTree.prototype.add = function(path, formatter) {
    var key, child;

    if (path.depth() === 0) {
      this.formatter = formatter;
      this.isMismatch = true;
    } else {
      key = path.components[0];
      path = path.shift();
      child = this.child(key);

      if (!child) {
        child = new MismatchTree(this.path.add(key));
        this.children.push(child);
      }

      child.add(path, formatter);
    }
  };

  MismatchTree.prototype.traverse = function(visit) {
    var i,
      hasChildren = this.children.length > 0;

    if (this.isMismatch || hasChildren) {
      if (visit(this.path, !hasChildren, this.formatter)) {
        for (i = 0; i < this.children.length; i++) {
          this.children[i].traverse(visit);
        }
      }
    }
  };

  MismatchTree.prototype.child = function(key) {
    var i, pathEls;

    for (i = 0; i < this.children.length; i++) {
      pathEls = this.children[i].path.components;
      if (pathEls[pathEls.length - 1] === key) {
        return this.children[i];
      }
    }
  };

  return MismatchTree;
};

getJasmineRequireObj().nothing = function() {
  /**
   * {@link expect} nothing explicitly.
   * @function
   * @name matchers#nothing
   * @since 2.8.0
   * @example
   * expect().nothing();
   */
  function nothing() {
    return {
      compare: function() {
        return {
          pass: true
        };
      }
    };
  }

  return nothing;
};

getJasmineRequireObj().NullDiffBuilder = function(j$) {
  return function() {
    return {
      withPath: function(_, block) {
        block();
      },
      setRoots: function() {},
      recordMismatch: function() {}
    };
  };
};

getJasmineRequireObj().ObjectPath = function(j$) {
  function ObjectPath(components) {
    this.components = components || [];
  }

  ObjectPath.prototype.toString = function() {
    if (this.components.length) {
      return '$' + map(this.components, formatPropertyAccess).join('');
    } else {
      return '';
    }
  };

  ObjectPath.prototype.add = function(component) {
    return new ObjectPath(this.components.concat([component]));
  };

  ObjectPath.prototype.shift = function() {
    return new ObjectPath(this.components.slice(1));
  };

  ObjectPath.prototype.depth = function() {
    return this.components.length;
  };

  function formatPropertyAccess(prop) {
    if (typeof prop === 'number') {
      return '[' + prop + ']';
    }

    if (isValidIdentifier(prop)) {
      return '.' + prop;
    }

    return "['" + prop + "']";
  }

  function map(array, fn) {
    var results = [];
    for (var i = 0; i < array.length; i++) {
      results.push(fn(array[i]));
    }
    return results;
  }

  function isValidIdentifier(string) {
    return /^[A-Za-z\$_][A-Za-z0-9\$_]*$/.test(string);
  }

  return ObjectPath;
};

getJasmineRequireObj().requireAsyncMatchers = function(jRequire, j$) {
  var availableMatchers = [
      'toBePending',
      'toBeResolved',
      'toBeRejected',
      'toBeResolvedTo',
      'toBeRejectedWith',
      'toBeRejectedWithError'
    ],
    matchers = {};

  for (var i = 0; i < availableMatchers.length; i++) {
    var name = availableMatchers[i];
    matchers[name] = jRequire[name](j$);
  }

  return matchers;
};

getJasmineRequireObj().toBe = function(j$) {
  /**
   * {@link expect} the actual value to be `===` to the expected value.
   * @function
   * @name matchers#toBe
   * @since 1.3.0
   * @param {Object} expected - The expected value to compare against.
   * @example
   * expect(thing).toBe(realThing);
   */
  function toBe(matchersUtil) {
    var tip =
      ' Tip: To check for deep equality, use .toEqual() instead of .toBe().';

    return {
      compare: function(actual, expected) {
        var result = {
          pass: actual === expected
        };

        if (typeof expected === 'object') {
          result.message =
            matchersUtil.buildFailureMessage(
              'toBe',
              result.pass,
              actual,
              expected
            ) + tip;
        }

        return result;
      }
    };
  }

  return toBe;
};

getJasmineRequireObj().toBeCloseTo = function() {
  /**
   * {@link expect} the actual value to be within a specified precision of the expected value.
   * @function
   * @name matchers#toBeCloseTo
   * @since 1.3.0
   * @param {Object} expected - The expected value to compare against.
   * @param {Number} [precision=2] - The number of decimal points to check.
   * @example
   * expect(number).toBeCloseTo(42.2, 3);
   */
  function toBeCloseTo() {
    return {
      compare: function(actual, expected, precision) {
        if (precision !== 0) {
          precision = precision || 2;
        }

        if (expected === null || actual === null) {
          throw new Error(
            'Cannot use toBeCloseTo with null. Arguments evaluated to: ' +
              'expect(' +
              actual +
              ').toBeCloseTo(' +
              expected +
              ').'
          );
        }

        var pow = Math.pow(10, precision + 1);
        var delta = Math.abs(expected - actual);
        var maxDelta = Math.pow(10, -precision) / 2;

        return {
          pass: Math.round(delta * pow) <= maxDelta * pow
        };
      }
    };
  }

  return toBeCloseTo;
};

getJasmineRequireObj().toBeDefined = function() {
  /**
   * {@link expect} the actual value to be defined. (Not `undefined`)
   * @function
   * @name matchers#toBeDefined
   * @since 1.3.0
   * @example
   * expect(result).toBeDefined();
   */
  function toBeDefined() {
    return {
      compare: function(actual) {
        return {
          pass: void 0 !== actual
        };
      }
    };
  }

  return toBeDefined;
};

getJasmineRequireObj().toBeFalse = function() {
  /**
   * {@link expect} the actual value to be `false`.
   * @function
   * @name matchers#toBeFalse
   * @since 3.5.0
   * @example
   * expect(result).toBeFalse();
   */
  function toBeFalse() {
    return {
      compare: function(actual) {
        return {
          pass: actual === false
        };
      }
    };
  }

  return toBeFalse;
};

getJasmineRequireObj().toBeFalsy = function() {
  /**
   * {@link expect} the actual value to be falsy
   * @function
   * @name matchers#toBeFalsy
   * @since 2.0.0
   * @example
   * expect(result).toBeFalsy();
   */
  function toBeFalsy() {
    return {
      compare: function(actual) {
        return {
          pass: !actual
        };
      }
    };
  }

  return toBeFalsy;
};

getJasmineRequireObj().toBeGreaterThan = function() {
  /**
   * {@link expect} the actual value to be greater than the expected value.
   * @function
   * @name matchers#toBeGreaterThan
   * @since 2.0.0
   * @param {Number} expected - The value to compare against.
   * @example
   * expect(result).toBeGreaterThan(3);
   */
  function toBeGreaterThan() {
    return {
      compare: function(actual, expected) {
        return {
          pass: actual > expected
        };
      }
    };
  }

  return toBeGreaterThan;
};

getJasmineRequireObj().toBeGreaterThanOrEqual = function() {
  /**
   * {@link expect} the actual value to be greater than or equal to the expected value.
   * @function
   * @name matchers#toBeGreaterThanOrEqual
   * @since 2.0.0
   * @param {Number} expected - The expected value to compare against.
   * @example
   * expect(result).toBeGreaterThanOrEqual(25);
   */
  function toBeGreaterThanOrEqual() {
    return {
      compare: function(actual, expected) {
        return {
          pass: actual >= expected
        };
      }
    };
  }

  return toBeGreaterThanOrEqual;
};

getJasmineRequireObj().toBeInstanceOf = function(j$) {
  var usageError = j$.formatErrorMsg(
    '<toBeInstanceOf>',
    'expect(value).toBeInstanceOf(<ConstructorFunction>)'
  );

  /**
   * {@link expect} the actual to be an instance of the expected class
   * @function
   * @name matchers#toBeInstanceOf
   * @since 3.5.0
   * @param {Object} expected - The class or constructor function to check for
   * @example
   * expect('foo').toBeInstanceOf(String);
   * expect(3).toBeInstanceOf(Number);
   * expect(new Error()).toBeInstanceOf(Error);
   */
  function toBeInstanceOf(matchersUtil) {
    return {
      compare: function(actual, expected) {
        var actualType =
            actual && actual.constructor
              ? j$.fnNameFor(actual.constructor)
              : matchersUtil.pp(actual),
          expectedType = expected
            ? j$.fnNameFor(expected)
            : matchersUtil.pp(expected),
          expectedMatcher,
          pass;

        try {
          expectedMatcher = new j$.Any(expected);
          pass = expectedMatcher.asymmetricMatch(actual);
        } catch (error) {
          throw new Error(
            usageError('Expected value is not a constructor function')
          );
        }

        if (pass) {
          return {
            pass: true,
            message:
              'Expected instance of ' +
              actualType +
              ' not to be an instance of ' +
              expectedType
          };
        } else {
          return {
            pass: false,
            message:
              'Expected instance of ' +
              actualType +
              ' to be an instance of ' +
              expectedType
          };
        }
      }
    };
  }

  return toBeInstanceOf;
};

getJasmineRequireObj().toBeLessThan = function() {
  /**
   * {@link expect} the actual value to be less than the expected value.
   * @function
   * @name matchers#toBeLessThan
   * @since 2.0.0
   * @param {Number} expected - The expected value to compare against.
   * @example
   * expect(result).toBeLessThan(0);
   */
  function toBeLessThan() {
    return {
      compare: function(actual, expected) {
        return {
          pass: actual < expected
        };
      }
    };
  }

  return toBeLessThan;
};

getJasmineRequireObj().toBeLessThanOrEqual = function() {
  /**
   * {@link expect} the actual value to be less than or equal to the expected value.
   * @function
   * @name matchers#toBeLessThanOrEqual
   * @since 2.0.0
   * @param {Number} expected - The expected value to compare against.
   * @example
   * expect(result).toBeLessThanOrEqual(123);
   */
  function toBeLessThanOrEqual() {
    return {
      compare: function(actual, expected) {
        return {
          pass: actual <= expected
        };
      }
    };
  }

  return toBeLessThanOrEqual;
};

getJasmineRequireObj().toBeNaN = function(j$) {
  /**
   * {@link expect} the actual value to be `NaN` (Not a Number).
   * @function
   * @name matchers#toBeNaN
   * @since 1.3.0
   * @example
   * expect(thing).toBeNaN();
   */
  function toBeNaN(matchersUtil) {
    return {
      compare: function(actual) {
        var result = {
          pass: actual !== actual
        };

        if (result.pass) {
          result.message = 'Expected actual not to be NaN.';
        } else {
          result.message = function() {
            return 'Expected ' + matchersUtil.pp(actual) + ' to be NaN.';
          };
        }

        return result;
      }
    };
  }

  return toBeNaN;
};

getJasmineRequireObj().toBeNegativeInfinity = function(j$) {
  /**
   * {@link expect} the actual value to be `-Infinity` (-infinity).
   * @function
   * @name matchers#toBeNegativeInfinity
   * @since 2.6.0
   * @example
   * expect(thing).toBeNegativeInfinity();
   */
  function toBeNegativeInfinity(matchersUtil) {
    return {
      compare: function(actual) {
        var result = {
          pass: actual === Number.NEGATIVE_INFINITY
        };

        if (result.pass) {
          result.message = 'Expected actual not to be -Infinity.';
        } else {
          result.message = function() {
            return 'Expected ' + matchersUtil.pp(actual) + ' to be -Infinity.';
          };
        }

        return result;
      }
    };
  }

  return toBeNegativeInfinity;
};

getJasmineRequireObj().toBeNull = function() {
  /**
   * {@link expect} the actual value to be `null`.
   * @function
   * @name matchers#toBeNull
   * @since 1.3.0
   * @example
   * expect(result).toBeNull();
   */
  function toBeNull() {
    return {
      compare: function(actual) {
        return {
          pass: actual === null
        };
      }
    };
  }

  return toBeNull;
};

getJasmineRequireObj().toBePositiveInfinity = function(j$) {
  /**
   * {@link expect} the actual value to be `Infinity` (infinity).
   * @function
   * @name matchers#toBePositiveInfinity
   * @since 2.6.0
   * @example
   * expect(thing).toBePositiveInfinity();
   */
  function toBePositiveInfinity(matchersUtil) {
    return {
      compare: function(actual) {
        var result = {
          pass: actual === Number.POSITIVE_INFINITY
        };

        if (result.pass) {
          result.message = 'Expected actual not to be Infinity.';
        } else {
          result.message = function() {
            return 'Expected ' + matchersUtil.pp(actual) + ' to be Infinity.';
          };
        }

        return result;
      }
    };
  }

  return toBePositiveInfinity;
};

getJasmineRequireObj().toBeTrue = function() {
  /**
   * {@link expect} the actual value to be `true`.
   * @function
   * @name matchers#toBeTrue
   * @since 3.5.0
   * @example
   * expect(result).toBeTrue();
   */
  function toBeTrue() {
    return {
      compare: function(actual) {
        return {
          pass: actual === true
        };
      }
    };
  }

  return toBeTrue;
};

getJasmineRequireObj().toBeTruthy = function() {
  /**
   * {@link expect} the actual value to be truthy.
   * @function
   * @name matchers#toBeTruthy
   * @since 2.0.0
   * @example
   * expect(thing).toBeTruthy();
   */
  function toBeTruthy() {
    return {
      compare: function(actual) {
        return {
          pass: !!actual
        };
      }
    };
  }

  return toBeTruthy;
};

getJasmineRequireObj().toBeUndefined = function() {
  /**
   * {@link expect} the actual value to be `undefined`.
   * @function
   * @name matchers#toBeUndefined
   * @since 1.3.0
   * @example
   * expect(result).toBeUndefined():
   */
  function toBeUndefined() {
    return {
      compare: function(actual) {
        return {
          pass: void 0 === actual
        };
      }
    };
  }

  return toBeUndefined;
};

getJasmineRequireObj().toContain = function() {
  /**
   * {@link expect} the actual value to contain a specific value.
   * @function
   * @name matchers#toContain
   * @since 2.0.0
   * @param {Object} expected - The value to look for.
   * @example
   * expect(array).toContain(anElement);
   * expect(string).toContain(substring);
   */
  function toContain(matchersUtil) {
    return {
      compare: function(actual, expected) {
        return {
          pass: matchersUtil.contains(actual, expected)
        };
      }
    };
  }

  return toContain;
};

getJasmineRequireObj().toEqual = function(j$) {
  /**
   * {@link expect} the actual value to be equal to the expected, using deep equality comparison.
   * @function
   * @name matchers#toEqual
   * @since 1.3.0
   * @param {Object} expected - Expected value
   * @example
   * expect(bigObject).toEqual({"foo": ['bar', 'baz']});
   */
  function toEqual(matchersUtil) {
    return {
      compare: function(actual, expected) {
        var result = {
            pass: false
          },
          diffBuilder = j$.DiffBuilder({ prettyPrinter: matchersUtil.pp });

        result.pass = matchersUtil.equals(actual, expected, diffBuilder);

        // TODO: only set error message if test fails
        result.message = diffBuilder.getMessage();

        return result;
      }
    };
  }

  return toEqual;
};

getJasmineRequireObj().toHaveBeenCalled = function(j$) {
  var getErrorMsg = j$.formatErrorMsg(
    '<toHaveBeenCalled>',
    'expect(<spyObj>).toHaveBeenCalled()'
  );

  /**
   * {@link expect} the actual (a {@link Spy}) to have been called.
   * @function
   * @name matchers#toHaveBeenCalled
   * @since 1.3.0
   * @example
   * expect(mySpy).toHaveBeenCalled();
   * expect(mySpy).not.toHaveBeenCalled();
   */
  function toHaveBeenCalled(matchersUtil) {
    return {
      compare: function(actual) {
        var result = {};

        if (!j$.isSpy(actual)) {
          throw new Error(
            getErrorMsg(
              'Expected a spy, but got ' + matchersUtil.pp(actual) + '.'
            )
          );
        }

        if (arguments.length > 1) {
          throw new Error(
            getErrorMsg('Does not take arguments, use toHaveBeenCalledWith')
          );
        }

        result.pass = actual.calls.any();

        result.message = result.pass
          ? 'Expected spy ' + actual.and.identity + ' not to have been called.'
          : 'Expected spy ' + actual.and.identity + ' to have been called.';

        return result;
      }
    };
  }

  return toHaveBeenCalled;
};

getJasmineRequireObj().toHaveBeenCalledBefore = function(j$) {
  var getErrorMsg = j$.formatErrorMsg(
    '<toHaveBeenCalledBefore>',
    'expect(<spyObj>).toHaveBeenCalledBefore(<spyObj>)'
  );

  /**
   * {@link expect} the actual value (a {@link Spy}) to have been called before another {@link Spy}.
   * @function
   * @name matchers#toHaveBeenCalledBefore
   * @since 2.6.0
   * @param {Spy} expected - {@link Spy} that should have been called after the `actual` {@link Spy}.
   * @example
   * expect(mySpy).toHaveBeenCalledBefore(otherSpy);
   */
  function toHaveBeenCalledBefore(matchersUtil) {
    return {
      compare: function(firstSpy, latterSpy) {
        if (!j$.isSpy(firstSpy)) {
          throw new Error(
            getErrorMsg(
              'Expected a spy, but got ' + matchersUtil.pp(firstSpy) + '.'
            )
          );
        }
        if (!j$.isSpy(latterSpy)) {
          throw new Error(
            getErrorMsg(
              'Expected a spy, but got ' + matchersUtil.pp(latterSpy) + '.'
            )
          );
        }

        var result = { pass: false };

        if (!firstSpy.calls.count()) {
          result.message =
            'Expected spy ' + firstSpy.and.identity + ' to have been called.';
          return result;
        }
        if (!latterSpy.calls.count()) {
          result.message =
            'Expected spy ' + latterSpy.and.identity + ' to have been called.';
          return result;
        }

        var latest1stSpyCall = firstSpy.calls.mostRecent().invocationOrder;
        var first2ndSpyCall = latterSpy.calls.first().invocationOrder;

        result.pass = latest1stSpyCall < first2ndSpyCall;

        if (result.pass) {
          result.message =
            'Expected spy ' +
            firstSpy.and.identity +
            ' to not have been called before spy ' +
            latterSpy.and.identity +
            ', but it was';
        } else {
          var first1stSpyCall = firstSpy.calls.first().invocationOrder;
          var latest2ndSpyCall = latterSpy.calls.mostRecent().invocationOrder;

          if (first1stSpyCall < first2ndSpyCall) {
            result.message =
              'Expected latest call to spy ' +
              firstSpy.and.identity +
              ' to have been called before first call to spy ' +
              latterSpy.and.identity +
              ' (no interleaved calls)';
          } else if (latest2ndSpyCall > latest1stSpyCall) {
            result.message =
              'Expected first call to spy ' +
              latterSpy.and.identity +
              ' to have been called after latest call to spy ' +
              firstSpy.and.identity +
              ' (no interleaved calls)';
          } else {
            result.message =
              'Expected spy ' +
              firstSpy.and.identity +
              ' to have been called before spy ' +
              latterSpy.and.identity;
          }
        }

        return result;
      }
    };
  }

  return toHaveBeenCalledBefore;
};

getJasmineRequireObj().toHaveBeenCalledOnceWith = function(j$) {
  var getErrorMsg = j$.formatErrorMsg(
    '<toHaveBeenCalledOnceWith>',
    'expect(<spyObj>).toHaveBeenCalledOnceWith(...arguments)'
  );

  /**
   * {@link expect} the actual (a {@link Spy}) to have been called exactly once, and exactly with the particular arguments.
   * @function
   * @name matchers#toHaveBeenCalledOnceWith
   * @since 3.6.0
   * @param {...Object} - The arguments to look for
   * @example
   * expect(mySpy).toHaveBeenCalledOnceWith('foo', 'bar', 2);
   */
  function toHaveBeenCalledOnceWith(util) {
    return {
      compare: function() {
        var args = Array.prototype.slice.call(arguments, 0),
          actual = args[0],
          expectedArgs = args.slice(1);

        if (!j$.isSpy(actual)) {
          throw new Error(
            getErrorMsg('Expected a spy, but got ' + util.pp(actual) + '.')
          );
        }

        var prettyPrintedCalls = actual.calls
          .allArgs()
          .map(function(argsForCall) {
            return '  ' + util.pp(argsForCall);
          });

        if (
          actual.calls.count() === 1 &&
          util.contains(actual.calls.allArgs(), expectedArgs)
        ) {
          return {
            pass: true,
            message:
              'Expected spy ' +
              actual.and.identity +
              ' to have been called 0 times, multiple times, or once, but with arguments different from:\n' +
              '  ' +
              util.pp(expectedArgs) +
              '\n' +
              'But the actual call was:\n' +
              prettyPrintedCalls.join(',\n') +
              '.\n\n'
          };
        }

        function getDiffs() {
          return actual.calls.allArgs().map(function(argsForCall, callIx) {
            var diffBuilder = new j$.DiffBuilder();
            util.equals(argsForCall, expectedArgs, diffBuilder);
            return diffBuilder.getMessage();
          });
        }

        function butString() {
          switch (actual.calls.count()) {
            case 0:
              return 'But it was never called.\n\n';
            case 1:
              return (
                'But the actual call was:\n' +
                prettyPrintedCalls.join(',\n') +
                '.\n' +
                getDiffs().join('\n') +
                '\n\n'
              );
            default:
              return (
                'But the actual calls were:\n' +
                prettyPrintedCalls.join(',\n') +
                '.\n\n'
              );
          }
        }

        return {
          pass: false,
          message:
            'Expected spy ' +
            actual.and.identity +
            ' to have been called only once, and with given args:\n' +
            '  ' +
            util.pp(expectedArgs) +
            '\n' +
            butString()
        };
      }
    };
  }

  return toHaveBeenCalledOnceWith;
};

getJasmineRequireObj().toHaveBeenCalledTimes = function(j$) {
  var getErrorMsg = j$.formatErrorMsg(
    '<toHaveBeenCalledTimes>',
    'expect(<spyObj>).toHaveBeenCalledTimes(<Number>)'
  );

  /**
   * {@link expect} the actual (a {@link Spy}) to have been called the specified number of times.
   * @function
   * @name matchers#toHaveBeenCalledTimes
   * @since 2.4.0
   * @param {Number} expected - The number of invocations to look for.
   * @example
   * expect(mySpy).toHaveBeenCalledTimes(3);
   */
  function toHaveBeenCalledTimes(matchersUtil) {
    return {
      compare: function(actual, expected) {
        if (!j$.isSpy(actual)) {
          throw new Error(
            getErrorMsg(
              'Expected a spy, but got ' + matchersUtil.pp(actual) + '.'
            )
          );
        }

        var args = Array.prototype.slice.call(arguments, 0),
          result = { pass: false };

        if (!j$.isNumber_(expected)) {
          throw new Error(
            getErrorMsg(
              'The expected times failed is a required argument and must be a number.'
            )
          );
        }

        actual = args[0];
        var calls = actual.calls.count();
        var timesMessage = expected === 1 ? 'once' : expected + ' times';
        result.pass = calls === expected;
        result.message = result.pass
          ? 'Expected spy ' +
            actual.and.identity +
            ' not to have been called ' +
            timesMessage +
            '. It was called ' +
            calls +
            ' times.'
          : 'Expected spy ' +
            actual.and.identity +
            ' to have been called ' +
            timesMessage +
            '. It was called ' +
            calls +
            ' times.';
        return result;
      }
    };
  }

  return toHaveBeenCalledTimes;
};

getJasmineRequireObj().toHaveBeenCalledWith = function(j$) {
  var getErrorMsg = j$.formatErrorMsg(
    '<toHaveBeenCalledWith>',
    'expect(<spyObj>).toHaveBeenCalledWith(...arguments)'
  );

  /**
   * {@link expect} the actual (a {@link Spy}) to have been called with particular arguments at least once.
   * @function
   * @name matchers#toHaveBeenCalledWith
   * @since 1.3.0
   * @param {...Object} - The arguments to look for
   * @example
   * expect(mySpy).toHaveBeenCalledWith('foo', 'bar', 2);
   */
  function toHaveBeenCalledWith(matchersUtil) {
    return {
      compare: function() {
        var args = Array.prototype.slice.call(arguments, 0),
          actual = args[0],
          expectedArgs = args.slice(1),
          result = { pass: false };

        if (!j$.isSpy(actual)) {
          throw new Error(
            getErrorMsg(
              'Expected a spy, but got ' + matchersUtil.pp(actual) + '.'
            )
          );
        }

        if (!actual.calls.any()) {
          result.message = function() {
            return (
              'Expected spy ' +
              actual.and.identity +
              ' to have been called with:\n' +
              '  ' +
              matchersUtil.pp(expectedArgs) +
              '\nbut it was never called.'
            );
          };
          return result;
        }

        if (matchersUtil.contains(actual.calls.allArgs(), expectedArgs)) {
          result.pass = true;
          result.message = function() {
            return (
              'Expected spy ' +
              actual.and.identity +
              ' not to have been called with:\n' +
              '  ' +
              matchersUtil.pp(expectedArgs) +
              '\nbut it was.'
            );
          };
        } else {
          result.message = function() {
            var prettyPrintedCalls = actual.calls
              .allArgs()
              .map(function(argsForCall) {
                return '  ' + matchersUtil.pp(argsForCall);
              });

            var diffs = actual.calls
              .allArgs()
              .map(function(argsForCall, callIx) {
                var diffBuilder = new j$.DiffBuilder();
                matchersUtil.equals(argsForCall, expectedArgs, diffBuilder);
                return (
                  'Call ' +
                  callIx +
                  ':\n' +
                  diffBuilder.getMessage().replace(/^/gm, '  ')
                );
              });

            return (
              'Expected spy ' +
              actual.and.identity +
              ' to have been called with:\n' +
              '  ' +
              matchersUtil.pp(expectedArgs) +
              '\n' +
              '' +
              'but actual calls were:\n' +
              prettyPrintedCalls.join(',\n') +
              '.\n\n' +
              diffs.join('\n')
            );
          };
        }

        return result;
      }
    };
  }

  return toHaveBeenCalledWith;
};

getJasmineRequireObj().toHaveClass = function(j$) {
  /**
   * {@link expect} the actual value to be a DOM element that has the expected class
   * @function
   * @name matchers#toHaveClass
   * @since 3.0.0
   * @param {Object} expected - The class name to test for
   * @example
   * var el = document.createElement('div');
   * el.className = 'foo bar baz';
   * expect(el).toHaveClass('bar');
   */
  function toHaveClass(matchersUtil) {
    return {
      compare: function(actual, expected) {
        if (!isElement(actual)) {
          throw new Error(matchersUtil.pp(actual) + ' is not a DOM element');
        }

        return {
          pass: actual.classList.contains(expected)
        };
      }
    };
  }

  function isElement(maybeEl) {
    return (
      maybeEl && maybeEl.classList && j$.isFunction_(maybeEl.classList.contains)
    );
  }

  return toHaveClass;
};

getJasmineRequireObj().toHaveSize = function(j$) {
  /**
   * {@link expect} the actual size to be equal to the expected, using array-like length or object keys size.
   * @function
   * @name matchers#toHaveSize
   * @since 3.6.0
   * @param {Object} expected - Expected size
   * @example
   * array = [1,2];
   * expect(array).toHaveSize(2);
   */
  function toHaveSize() {
    return {
      compare: function(actual, expected) {
        var result = {
          pass: false
        };

        if (
          j$.isA_('WeakSet', actual) ||
          j$.isWeakMap(actual) ||
          j$.isDataView(actual)
        ) {
          throw new Error('Cannot get size of ' + actual + '.');
        }

        if (j$.isSet(actual) || j$.isMap(actual)) {
          result.pass = actual.size === expected;
        } else if (isLength(actual.length)) {
          result.pass = actual.length === expected;
        } else {
          result.pass = Object.keys(actual).length === expected;
        }

        return result;
      }
    };
  }

  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  function isLength(value) {
    return (
      typeof value == 'number' &&
      value > -1 &&
      value % 1 === 0 &&
      value <= MAX_SAFE_INTEGER
    );
  }

  return toHaveSize;
};

getJasmineRequireObj().toMatch = function(j$) {
  var getErrorMsg = j$.formatErrorMsg(
    '<toMatch>',
    'expect(<expectation>).toMatch(<string> || <regexp>)'
  );

  /**
   * {@link expect} the actual value to match a regular expression
   * @function
   * @name matchers#toMatch
   * @since 1.3.0
   * @param {RegExp|String} expected - Value to look for in the string.
   * @example
   * expect("my string").toMatch(/string$/);
   * expect("other string").toMatch("her");
   */
  function toMatch() {
    return {
      compare: function(actual, expected) {
        if (!j$.isString_(expected) && !j$.isA_('RegExp', expected)) {
          throw new Error(getErrorMsg('Expected is not a String or a RegExp'));
        }

        var regexp = new RegExp(expected);

        return {
          pass: regexp.test(actual)
        };
      }
    };
  }

  return toMatch;
};

getJasmineRequireObj().toThrow = function(j$) {
  var getErrorMsg = j$.formatErrorMsg(
    '<toThrow>',
    'expect(function() {<expectation>}).toThrow()'
  );

  /**
   * {@link expect} a function to `throw` something.
   * @function
   * @name matchers#toThrow
   * @since 2.0.0
   * @param {Object} [expected] - Value that should be thrown. If not provided, simply the fact that something was thrown will be checked.
   * @example
   * expect(function() { return 'things'; }).toThrow('foo');
   * expect(function() { return 'stuff'; }).toThrow();
   */
  function toThrow(matchersUtil) {
    return {
      compare: function(actual, expected) {
        var result = { pass: false },
          threw = false,
          thrown;

        if (typeof actual != 'function') {
          throw new Error(getErrorMsg('Actual is not a Function'));
        }

        try {
          actual();
        } catch (e) {
          threw = true;
          thrown = e;
        }

        if (!threw) {
          result.message = 'Expected function to throw an exception.';
          return result;
        }

        if (arguments.length == 1) {
          result.pass = true;
          result.message = function() {
            return (
              'Expected function not to throw, but it threw ' +
              matchersUtil.pp(thrown) +
              '.'
            );
          };

          return result;
        }

        if (matchersUtil.equals(thrown, expected)) {
          result.pass = true;
          result.message = function() {
            return (
              'Expected function not to throw ' +
              matchersUtil.pp(expected) +
              '.'
            );
          };
        } else {
          result.message = function() {
            return (
              'Expected function to throw ' +
              matchersUtil.pp(expected) +
              ', but it threw ' +
              matchersUtil.pp(thrown) +
              '.'
            );
          };
        }

        return result;
      }
    };
  }

  return toThrow;
};

getJasmineRequireObj().toThrowError = function(j$) {
  var getErrorMsg = j$.formatErrorMsg(
    '<toThrowError>',
    'expect(function() {<expectation>}).toThrowError(<ErrorConstructor>, <message>)'
  );

  /**
   * {@link expect} a function to `throw` an `Error`.
   * @function
   * @name matchers#toThrowError
   * @since 2.0.0
   * @param {Error} [expected] - `Error` constructor the object that was thrown needs to be an instance of. If not provided, `Error` will be used.
   * @param {RegExp|String} [message] - The message that should be set on the thrown `Error`
   * @example
   * expect(function() { return 'things'; }).toThrowError(MyCustomError, 'message');
   * expect(function() { return 'things'; }).toThrowError(MyCustomError, /bar/);
   * expect(function() { return 'stuff'; }).toThrowError(MyCustomError);
   * expect(function() { return 'other'; }).toThrowError(/foo/);
   * expect(function() { return 'other'; }).toThrowError();
   */
  function toThrowError(matchersUtil) {
    return {
      compare: function(actual) {
        var errorMatcher = getMatcher.apply(null, arguments),
          thrown;

        if (typeof actual != 'function') {
          throw new Error(getErrorMsg('Actual is not a Function'));
        }

        try {
          actual();
          return fail('Expected function to throw an Error.');
        } catch (e) {
          thrown = e;
        }

        if (!j$.isError_(thrown)) {
          return fail(function() {
            return (
              'Expected function to throw an Error, but it threw ' +
              matchersUtil.pp(thrown) +
              '.'
            );
          });
        }

        return errorMatcher.match(thrown);
      }
    };

    function getMatcher() {
      var expected, errorType;

      if (arguments[2]) {
        errorType = arguments[1];
        expected = arguments[2];
        if (!isAnErrorType(errorType)) {
          throw new Error(getErrorMsg('Expected error type is not an Error.'));
        }

        return exactMatcher(expected, errorType);
      } else if (arguments[1]) {
        expected = arguments[1];

        if (isAnErrorType(arguments[1])) {
          return exactMatcher(null, arguments[1]);
        } else {
          return exactMatcher(arguments[1], null);
        }
      } else {
        return anyMatcher();
      }
    }

    function anyMatcher() {
      return {
        match: function(error) {
          return pass(
            'Expected function not to throw an Error, but it threw ' +
              j$.fnNameFor(error) +
              '.'
          );
        }
      };
    }

    function exactMatcher(expected, errorType) {
      if (expected && !isStringOrRegExp(expected)) {
        if (errorType) {
          throw new Error(
            getErrorMsg('Expected error message is not a string or RegExp.')
          );
        } else {
          throw new Error(
            getErrorMsg('Expected is not an Error, string, or RegExp.')
          );
        }
      }

      function messageMatch(message) {
        if (typeof expected == 'string') {
          return expected == message;
        } else {
          return expected.test(message);
        }
      }

      var errorTypeDescription = errorType
        ? j$.fnNameFor(errorType)
        : 'an exception';

      function thrownDescription(thrown) {
        var thrownName = errorType
            ? j$.fnNameFor(thrown.constructor)
            : 'an exception',
          thrownMessage = '';

        if (expected) {
          thrownMessage = ' with message ' + matchersUtil.pp(thrown.message);
        }

        return thrownName + thrownMessage;
      }

      function messageDescription() {
        if (expected === null) {
          return '';
        } else if (expected instanceof RegExp) {
          return ' with a message matching ' + matchersUtil.pp(expected);
        } else {
          return ' with message ' + matchersUtil.pp(expected);
        }
      }

      function matches(error) {
        return (
          (errorType === null || error instanceof errorType) &&
          (expected === null || messageMatch(error.message))
        );
      }

      return {
        match: function(thrown) {
          if (matches(thrown)) {
            return pass(function() {
              return (
                'Expected function not to throw ' +
                errorTypeDescription +
                messageDescription() +
                '.'
              );
            });
          } else {
            return fail(function() {
              return (
                'Expected function to throw ' +
                errorTypeDescription +
                messageDescription() +
                ', but it threw ' +
                thrownDescription(thrown) +
                '.'
              );
            });
          }
        }
      };
    }

    function isStringOrRegExp(potential) {
      return potential instanceof RegExp || typeof potential == 'string';
    }

    function isAnErrorType(type) {
      if (typeof type !== 'function') {
        return false;
      }

      var Surrogate = function() {};
      Surrogate.prototype = type.prototype;
      return j$.isError_(new Surrogate());
    }
  }

  function pass(message) {
    return {
      pass: true,
      message: message
    };
  }

  function fail(message) {
    return {
      pass: false,
      message: message
    };
  }

  return toThrowError;
};

getJasmineRequireObj().toThrowMatching = function(j$) {
  var usageError = j$.formatErrorMsg(
    '<toThrowMatching>',
    'expect(function() {<expectation>}).toThrowMatching(<Predicate>)'
  );

  /**
   * {@link expect} a function to `throw` something matching a predicate.
   * @function
   * @name matchers#toThrowMatching
   * @since 3.0.0
   * @param {Function} predicate - A function that takes the thrown exception as its parameter and returns true if it matches.
   * @example
   * expect(function() { throw new Error('nope'); }).toThrowMatching(function(thrown) { return thrown.message === 'nope'; });
   */
  function toThrowMatching(matchersUtil) {
    return {
      compare: function(actual, predicate) {
        var thrown;

        if (typeof actual !== 'function') {
          throw new Error(usageError('Actual is not a Function'));
        }

        if (typeof predicate !== 'function') {
          throw new Error(usageError('Predicate is not a Function'));
        }

        try {
          actual();
          return fail('Expected function to throw an exception.');
        } catch (e) {
          thrown = e;
        }

        if (predicate(thrown)) {
          return pass(
            'Expected function not to throw an exception matching a predicate.'
          );
        } else {
          return fail(function() {
            return (
              'Expected function to throw an exception matching a predicate, ' +
              'but it threw ' +
              thrownDescription(thrown) +
              '.'
            );
          });
        }
      }
    };

    function thrownDescription(thrown) {
      if (thrown && thrown.constructor) {
        return (
          j$.fnNameFor(thrown.constructor) +
          ' with message ' +
          matchersUtil.pp(thrown.message)
        );
      } else {
        return matchersUtil.pp(thrown);
      }
    }
  }

  function pass(message) {
    return {
      pass: true,
      message: message
    };
  }

  function fail(message) {
    return {
      pass: false,
      message: message
    };
  }

  return toThrowMatching;
};

getJasmineRequireObj().MockDate = function(j$) {
  function MockDate(global) {
    var self = this;
    var currentTime = 0;

    if (!global || !global.Date) {
      self.install = function() {};
      self.tick = function() {};
      self.uninstall = function() {};
      return self;
    }

    var GlobalDate = global.Date;

    self.install = function(mockDate) {
      if (mockDate instanceof GlobalDate) {
        currentTime = mockDate.getTime();
      } else {
        if (!j$.util.isUndefined(mockDate)) {
          throw new Error(
            'The argument to jasmine.clock().mockDate(), if specified, ' +
              'should be a Date instance.'
          );
        }

        currentTime = new GlobalDate().getTime();
      }

      global.Date = FakeDate;
    };

    self.tick = function(millis) {
      millis = millis || 0;
      currentTime = currentTime + millis;
    };

    self.uninstall = function() {
      currentTime = 0;
      global.Date = GlobalDate;
    };

    createDateProperties();

    return self;

    function FakeDate() {
      switch (arguments.length) {
        case 0:
          return new GlobalDate(currentTime);
        case 1:
          return new GlobalDate(arguments[0]);
        case 2:
          return new GlobalDate(arguments[0], arguments[1]);
        case 3:
          return new GlobalDate(arguments[0], arguments[1], arguments[2]);
        case 4:
          return new GlobalDate(
            arguments[0],
            arguments[1],
            arguments[2],
            arguments[3]
          );
        case 5:
          return new GlobalDate(
            arguments[0],
            arguments[1],
            arguments[2],
            arguments[3],
            arguments[4]
          );
        case 6:
          return new GlobalDate(
            arguments[0],
            arguments[1],
            arguments[2],
            arguments[3],
            arguments[4],
            arguments[5]
          );
        default:
          return new GlobalDate(
            arguments[0],
            arguments[1],
            arguments[2],
            arguments[3],
            arguments[4],
            arguments[5],
            arguments[6]
          );
      }
    }

    function createDateProperties() {
      FakeDate.prototype = GlobalDate.prototype;

      FakeDate.now = function() {
        return currentTime;
      };

      FakeDate.toSource = GlobalDate.toSource;
      FakeDate.toString = GlobalDate.toString;
      FakeDate.parse = GlobalDate.parse;
      FakeDate.UTC = GlobalDate.UTC;
    }
  }

  return MockDate;
};

getJasmineRequireObj().NeverSkipPolicy = function(j$) {
  function NeverSkipPolicy(queueableFns) {}

  NeverSkipPolicy.prototype.skipTo = function(lastRanFnIx) {
    return lastRanFnIx + 1;
  };

  NeverSkipPolicy.prototype.fnErrored = function(fnIx) {};

  return NeverSkipPolicy;
};

getJasmineRequireObj().makePrettyPrinter = function(j$) {
  function SinglePrettyPrintRun(customObjectFormatters, pp) {
    this.customObjectFormatters_ = customObjectFormatters;
    this.ppNestLevel_ = 0;
    this.seen = [];
    this.length = 0;
    this.stringParts = [];
    this.pp_ = pp;
  }

  function hasCustomToString(value) {
    // value.toString !== Object.prototype.toString if value has no custom toString but is from another context (e.g.
    // iframe, web worker)
    try {
      return (
        j$.isFunction_(value.toString) &&
        value.toString !== Object.prototype.toString &&
        value.toString() !== Object.prototype.toString.call(value)
      );
    } catch (e) {
      // The custom toString() threw.
      return true;
    }
  }

  SinglePrettyPrintRun.prototype.format = function(value) {
    this.ppNestLevel_++;
    try {
      var customFormatResult = this.applyCustomFormatters_(value);

      if (customFormatResult) {
        this.emitScalar(customFormatResult);
      } else if (j$.util.isUndefined(value)) {
        this.emitScalar('undefined');
      } else if (value === null) {
        this.emitScalar('null');
      } else if (value === 0 && 1 / value === -Infinity) {
        this.emitScalar('-0');
      } else if (value === j$.getGlobal()) {
        this.emitScalar('<global>');
      } else if (value.jasmineToString) {
        this.emitScalar(value.jasmineToString(this.pp_));
      } else if (typeof value === 'string') {
        this.emitString(value);
      } else if (j$.isSpy(value)) {
        this.emitScalar('spy on ' + value.and.identity);
      } else if (j$.isSpy(value.toString)) {
        this.emitScalar('spy on ' + value.toString.and.identity);
      } else if (value instanceof RegExp) {
        this.emitScalar(value.toString());
      } else if (typeof value === 'function') {
        this.emitScalar('Function');
      } else if (j$.isDomNode(value)) {
        if (value.tagName) {
          this.emitDomElement(value);
        } else {
          this.emitScalar('HTMLNode');
        }
      } else if (value instanceof Date) {
        this.emitScalar('Date(' + value + ')');
      } else if (j$.isSet(value)) {
        this.emitSet(value);
      } else if (j$.isMap(value)) {
        this.emitMap(value);
      } else if (j$.isTypedArray_(value)) {
        this.emitTypedArray(value);
      } else if (
        value.toString &&
        typeof value === 'object' &&
        !j$.isArray_(value) &&
        hasCustomToString(value)
      ) {
        try {
          this.emitScalar(value.toString());
        } catch (e) {
          this.emitScalar('has-invalid-toString-method');
        }
      } else if (j$.util.arrayContains(this.seen, value)) {
        this.emitScalar(
          '<circular reference: ' +
            (j$.isArray_(value) ? 'Array' : 'Object') +
            '>'
        );
      } else if (j$.isArray_(value) || j$.isA_('Object', value)) {
        this.seen.push(value);
        if (j$.isArray_(value)) {
          this.emitArray(value);
        } else {
          this.emitObject(value);
        }
        this.seen.pop();
      } else {
        this.emitScalar(value.toString());
      }
    } catch (e) {
      if (this.ppNestLevel_ > 1 || !(e instanceof MaxCharsReachedError)) {
        throw e;
      }
    } finally {
      this.ppNestLevel_--;
    }
  };

  SinglePrettyPrintRun.prototype.applyCustomFormatters_ = function(value) {
    return customFormat(value, this.customObjectFormatters_);
  };

  SinglePrettyPrintRun.prototype.iterateObject = function(obj, fn) {
    var objKeys = keys(obj, j$.isArray_(obj));
    var isGetter = function isGetter(prop) {};

    if (obj.__lookupGetter__) {
      isGetter = function isGetter(prop) {
        var getter = obj.__lookupGetter__(prop);
        return !j$.util.isUndefined(getter) && getter !== null;
      };
    }
    var length = Math.min(objKeys.length, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);
    for (var i = 0; i < length; i++) {
      var property = objKeys[i];
      fn(property, isGetter(property));
    }

    return objKeys.length > length;
  };

  SinglePrettyPrintRun.prototype.emitScalar = function(value) {
    this.append(value);
  };

  SinglePrettyPrintRun.prototype.emitString = function(value) {
    this.append("'" + value + "'");
  };

  SinglePrettyPrintRun.prototype.emitArray = function(array) {
    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {
      this.append('Array');
      return;
    }
    var length = Math.min(array.length, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);
    this.append('[ ');
    for (var i = 0; i < length; i++) {
      if (i > 0) {
        this.append(', ');
      }
      this.format(array[i]);
    }
    if (array.length > length) {
      this.append(', ...');
    }

    var self = this;
    var first = array.length === 0;
    var truncated = this.iterateObject(array, function(property, isGetter) {
      if (first) {
        first = false;
      } else {
        self.append(', ');
      }

      self.formatProperty(array, property, isGetter);
    });

    if (truncated) {
      this.append(', ...');
    }

    this.append(' ]');
  };

  SinglePrettyPrintRun.prototype.emitSet = function(set) {
    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {
      this.append('Set');
      return;
    }
    this.append('Set( ');
    var size = Math.min(set.size, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);
    var i = 0;
    set.forEach(function(value, key) {
      if (i >= size) {
        return;
      }
      if (i > 0) {
        this.append(', ');
      }
      this.format(value);

      i++;
    }, this);
    if (set.size > size) {
      this.append(', ...');
    }
    this.append(' )');
  };

  SinglePrettyPrintRun.prototype.emitMap = function(map) {
    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {
      this.append('Map');
      return;
    }
    this.append('Map( ');
    var size = Math.min(map.size, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);
    var i = 0;
    map.forEach(function(value, key) {
      if (i >= size) {
        return;
      }
      if (i > 0) {
        this.append(', ');
      }
      this.format([key, value]);

      i++;
    }, this);
    if (map.size > size) {
      this.append(', ...');
    }
    this.append(' )');
  };

  SinglePrettyPrintRun.prototype.emitObject = function(obj) {
    var ctor = obj.constructor,
      constructorName;

    constructorName =
      typeof ctor === 'function' && obj instanceof ctor
        ? j$.fnNameFor(obj.constructor)
        : 'null';

    this.append(constructorName);

    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {
      return;
    }

    var self = this;
    this.append('({ ');
    var first = true;

    var truncated = this.iterateObject(obj, function(property, isGetter) {
      if (first) {
        first = false;
      } else {
        self.append(', ');
      }

      self.formatProperty(obj, property, isGetter);
    });

    if (truncated) {
      this.append(', ...');
    }

    this.append(' })');
  };

  SinglePrettyPrintRun.prototype.emitTypedArray = function(arr) {
    var constructorName = j$.fnNameFor(arr.constructor),
      limitedArray = Array.prototype.slice.call(
        arr,
        0,
        j$.MAX_PRETTY_PRINT_ARRAY_LENGTH
      ),
      itemsString = Array.prototype.join.call(limitedArray, ', ');

    if (limitedArray.length !== arr.length) {
      itemsString += ', ...';
    }

    this.append(constructorName + ' [ ' + itemsString + ' ]');
  };

  SinglePrettyPrintRun.prototype.emitDomElement = function(el) {
    var tagName = el.tagName.toLowerCase(),
      attrs = el.attributes,
      i,
      len = attrs.length,
      out = '<' + tagName,
      attr;

    for (i = 0; i < len; i++) {
      attr = attrs[i];
      out += ' ' + attr.name;

      if (attr.value !== '') {
        out += '="' + attr.value + '"';
      }
    }

    out += '>';

    if (el.childElementCount !== 0 || el.textContent !== '') {
      out += '...</' + tagName + '>';
    }

    this.append(out);
  };

  SinglePrettyPrintRun.prototype.formatProperty = function(
    obj,
    property,
    isGetter
  ) {
    this.append(property);
    this.append(': ');
    if (isGetter) {
      this.append('<getter>');
    } else {
      this.format(obj[property]);
    }
  };

  SinglePrettyPrintRun.prototype.append = function(value) {
    // This check protects us from the rare case where an object has overriden
    // `toString()` with an invalid implementation (returning a non-string).
    if (typeof value !== 'string') {
      value = Object.prototype.toString.call(value);
    }

    var result = truncate(value, j$.MAX_PRETTY_PRINT_CHARS - this.length);
    this.length += result.value.length;
    this.stringParts.push(result.value);

    if (result.truncated) {
      throw new MaxCharsReachedError();
    }
  };

  function truncate(s, maxlen) {
    if (s.length <= maxlen) {
      return { value: s, truncated: false };
    }

    s = s.substring(0, maxlen - 4) + ' ...';
    return { value: s, truncated: true };
  }

  function MaxCharsReachedError() {
    this.message =
      'Exceeded ' +
      j$.MAX_PRETTY_PRINT_CHARS +
      ' characters while pretty-printing a value';
  }

  MaxCharsReachedError.prototype = new Error();

  function keys(obj, isArray) {
    var allKeys = Object.keys
      ? Object.keys(obj)
      : (function(o) {
          var keys = [];
          for (var key in o) {
            if (j$.util.has(o, key)) {
              keys.push(key);
            }
          }
          return keys;
        })(obj);

    if (!isArray) {
      return allKeys;
    }

    if (allKeys.length === 0) {
      return allKeys;
    }

    var extraKeys = [];
    for (var i = 0; i < allKeys.length; i++) {
      if (!/^[0-9]+$/.test(allKeys[i])) {
        extraKeys.push(allKeys[i]);
      }
    }

    return extraKeys;
  }

  function customFormat(value, customObjectFormatters) {
    var i, result;

    for (i = 0; i < customObjectFormatters.length; i++) {
      result = customObjectFormatters[i](value);

      if (result !== undefined) {
        return result;
      }
    }
  }

  return function(customObjectFormatters) {
    customObjectFormatters = customObjectFormatters || [];

    var pp = function(value) {
      var prettyPrinter = new SinglePrettyPrintRun(customObjectFormatters, pp);
      prettyPrinter.format(value);
      return prettyPrinter.stringParts.join('');
    };

    pp.customFormat_ = function(value) {
      return customFormat(value, customObjectFormatters);
    };

    return pp;
  };
};

getJasmineRequireObj().QueueRunner = function(j$) {
  var nextid = 1;

  function StopExecutionError() {}
  StopExecutionError.prototype = new Error();
  j$.StopExecutionError = StopExecutionError;

  function once(fn, onTwice) {
    var called = false;
    return function(arg) {
      if (called) {
        if (onTwice) {
          onTwice();
        }
      } else {
        called = true;
        // Direct call using single parameter, because cleanup/next does not need more
        fn(arg);
      }
      return null;
    };
  }

  function fallbackOnMultipleDone() {
    console.error(
      new Error(
        "An asynchronous function called its 'done' " +
          'callback more than once, in a QueueRunner without a onMultipleDone ' +
          'handler.'
      )
    );
  }

  function emptyFn() {}

  function QueueRunner(attrs) {
    this.id_ = nextid++;
    this.queueableFns = attrs.queueableFns || [];
    this.onComplete = attrs.onComplete || emptyFn;
    this.clearStack =
      attrs.clearStack ||
      function(fn) {
        fn();
      };
    this.onException = attrs.onException || emptyFn;
    this.onMultipleDone = attrs.onMultipleDone || fallbackOnMultipleDone;
    this.userContext = attrs.userContext || new j$.UserContext();
    this.timeout = attrs.timeout || {
      setTimeout: setTimeout,
      clearTimeout: clearTimeout
    };
    this.fail = attrs.fail || emptyFn;
    this.globalErrors = attrs.globalErrors || {
      pushListener: emptyFn,
      popListener: emptyFn
    };

    const SkipPolicy = attrs.SkipPolicy || j$.NeverSkipPolicy;
    this.skipPolicy_ = new SkipPolicy(this.queueableFns);
    this.errored_ = false;

    if (typeof this.onComplete !== 'function') {
      throw new Error('invalid onComplete ' + JSON.stringify(this.onComplete));
    }
    this.deprecated = attrs.deprecated;
  }

  QueueRunner.prototype.execute = function() {
    var self = this;
    this.handleFinalError = function(message, source, lineno, colno, error) {
      // Older browsers would send the error as the first parameter. HTML5
      // specifies the the five parameters above. The error instance should
      // be preffered, otherwise the call stack would get lost.
      self.onException(error || message);
    };
    this.globalErrors.pushListener(this.handleFinalError);
    this.run(0);
  };

  QueueRunner.prototype.clearTimeout = function(timeoutId) {
    Function.prototype.apply.apply(this.timeout.clearTimeout, [
      j$.getGlobal(),
      [timeoutId]
    ]);
  };

  QueueRunner.prototype.setTimeout = function(fn, timeout) {
    return Function.prototype.apply.apply(this.timeout.setTimeout, [
      j$.getGlobal(),
      [fn, timeout]
    ]);
  };

  QueueRunner.prototype.attempt = function attempt(iterativeIndex) {
    var self = this,
      completedSynchronously = true,
      handleError = function handleError(error) {
        // TODO probably shouldn't next() right away here.
        // That makes debugging async failures much more confusing.
        onException(error);
      },
      cleanup = once(function cleanup() {
        if (timeoutId !== void 0) {
          self.clearTimeout(timeoutId);
        }
        self.globalErrors.popListener(handleError);
      }),
      next = once(
        function next(err) {
          cleanup();

          if (typeof err !== 'undefined') {
            if (!(err instanceof StopExecutionError) && !err.jasmineMessage) {
              self.fail(err);
            }
            self.recordError_(iterativeIndex);
          }

          function runNext() {
            self.run(self.nextFnIx_(iterativeIndex));
          }

          if (completedSynchronously) {
            self.setTimeout(runNext);
          } else {
            runNext();
          }
        },
        function() {
          try {
            if (!timedOut) {
              self.onMultipleDone();
            }
          } catch (error) {
            // Any error we catch here is probably due to a bug in Jasmine,
            // and it's not likely to end up anywhere useful if we let it
            // propagate. Log it so it can at least show up when debugging.
            console.error(error);
          }
        }
      ),
      timedOut = false,
      queueableFn = self.queueableFns[iterativeIndex],
      timeoutId,
      maybeThenable;

    next.fail = function nextFail() {
      self.fail.apply(null, arguments);
      self.recordError_(iterativeIndex);
      next();
    };

    self.globalErrors.pushListener(handleError);

    if (queueableFn.timeout !== undefined) {
      var timeoutInterval = queueableFn.timeout || j$.DEFAULT_TIMEOUT_INTERVAL;
      timeoutId = self.setTimeout(function() {
        timedOut = true;
        var error = new Error(
          'Timeout - Async function did not complete within ' +
            timeoutInterval +
            'ms ' +
            (queueableFn.timeout
              ? '(custom timeout)'
              : '(set by jasmine.DEFAULT_TIMEOUT_INTERVAL)')
        );
        // TODO Need to decide what to do about a successful completion after a
        //   timeout. That should probably not be a deprecation, and maybe not
        //   an error in 4.0. (But a diagnostic of some sort might be helpful.)
        onException(error);
        next();
      }, timeoutInterval);
    }

    try {
      if (queueableFn.fn.length === 0) {
        maybeThenable = queueableFn.fn.call(self.userContext);

        if (maybeThenable && j$.isFunction_(maybeThenable.then)) {
          maybeThenable.then(
            wrapInPromiseResolutionHandler(next),
            onPromiseRejection
          );
          completedSynchronously = false;
          return { completedSynchronously: false };
        }
      } else {
        maybeThenable = queueableFn.fn.call(self.userContext, next);
        this.diagnoseConflictingAsync_(queueableFn.fn, maybeThenable);
        completedSynchronously = false;
        return { completedSynchronously: false };
      }
    } catch (e) {
      onException(e);
      self.recordError_(iterativeIndex);
    }

    cleanup();
    return { completedSynchronously: true };

    function onException(e) {
      self.onException(e);
      self.recordError_(iterativeIndex);
    }

    function onPromiseRejection(e) {
      onException(e);
      next();
    }
  };

  QueueRunner.prototype.run = function(recursiveIndex) {
    var length = this.queueableFns.length,
      self = this,
      iterativeIndex;

    for (
      iterativeIndex = recursiveIndex;
      iterativeIndex < length;
      iterativeIndex = this.nextFnIx_(iterativeIndex)
    ) {
      var result = this.attempt(iterativeIndex);

      if (!result.completedSynchronously) {
        return;
      }
    }

    this.clearStack(function() {
      self.globalErrors.popListener(self.handleFinalError);

      if (self.errored_) {
        self.onComplete(new StopExecutionError());
      } else {
        self.onComplete();
      }
    });
  };

  QueueRunner.prototype.nextFnIx_ = function(currentFnIx) {
    const result = this.skipPolicy_.skipTo(currentFnIx);

    if (result === currentFnIx) {
      throw new Error("Can't skip to the same queueable fn that just finished");
    }

    return result;
  };

  QueueRunner.prototype.recordError_ = function(currentFnIx) {
    this.errored_ = true;
    this.skipPolicy_.fnErrored(currentFnIx);
  };

  QueueRunner.prototype.diagnoseConflictingAsync_ = function(fn, retval) {
    var msg;

    if (retval && j$.isFunction_(retval.then)) {
      // Issue a warning that matches the user's code.
      // Omit the stack trace because there's almost certainly no user code
      // on the stack at this point.
      if (j$.isAsyncFunction_(fn)) {
        this.onException(
          'An asynchronous before/it/after ' +
            'function was defined with the async keyword but also took a ' +
            'done callback. Either remove the done callback (recommended) or ' +
            'remove the async keyword.'
        );
      } else {
        this.onException(
          'An asynchronous before/it/after ' +
            'function took a done callback but also returned a promise. ' +
            'Either remove the done callback (recommended) or change the ' +
            'function to not return a promise.'
        );
      }

      this.deprecated(msg, { omitStackTrace: true });
    }
  };

  function wrapInPromiseResolutionHandler(fn) {
    return function(maybeArg) {
      if (j$.isError_(maybeArg)) {
        fn(maybeArg);
      } else {
        fn();
      }
    };
  }

  return QueueRunner;
};

getJasmineRequireObj().ReportDispatcher = function(j$) {
  function ReportDispatcher(methods, queueRunnerFactory, onLateError) {
    var dispatchedMethods = methods || [];

    for (var i = 0; i < dispatchedMethods.length; i++) {
      var method = dispatchedMethods[i];
      this[method] = (function(m) {
        return function() {
          dispatch(m, arguments);
        };
      })(method);
    }

    var reporters = [];
    var fallbackReporter = null;

    this.addReporter = function(reporter) {
      reporters.push(reporter);
    };

    this.provideFallbackReporter = function(reporter) {
      fallbackReporter = reporter;
    };

    this.clearReporters = function() {
      reporters = [];
    };

    return this;

    function dispatch(method, args) {
      if (reporters.length === 0 && fallbackReporter !== null) {
        reporters.push(fallbackReporter);
      }
      var onComplete = args[args.length - 1];
      args = j$.util.argsToArray(args).splice(0, args.length - 1);
      var fns = [];
      for (var i = 0; i < reporters.length; i++) {
        var reporter = reporters[i];
        addFn(fns, reporter, method, args);
      }

      queueRunnerFactory({
        queueableFns: fns,
        onComplete: onComplete,
        isReporter: true,
        onMultipleDone: function() {
          onLateError(
            new Error(
              "An asynchronous reporter callback called its 'done' callback " +
                'more than once.'
            )
          );
        }
      });
    }

    function addFn(fns, reporter, method, args) {
      var fn = reporter[method];
      if (!fn) {
        return;
      }

      var thisArgs = j$.util.cloneArgs(args);
      if (fn.length <= 1) {
        fns.push({
          fn: function() {
            return fn.apply(reporter, thisArgs);
          }
        });
      } else {
        fns.push({
          fn: function(done) {
            return fn.apply(reporter, thisArgs.concat([done]));
          }
        });
      }
    }
  }

  return ReportDispatcher;
};

getJasmineRequireObj().interface = function(jasmine, env) {
  var jasmineInterface = {
    /**
     * Callback passed to parts of the Jasmine base interface.
     *
     * By default Jasmine assumes this function completes synchronously.
     * If you have code that you need to test asynchronously, you can declare that you receive a `done` callback, return a Promise, or use the `async` keyword if it is supported in your environment.
     * @callback implementationCallback
     * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.
     * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.
     */

    /**
     * Create a group of specs (often called a suite).
     *
     * Calls to `describe` can be nested within other calls to compose your suite as a tree.
     * @name describe
     * @since 1.3.0
     * @function
     * @global
     * @param {String} description Textual description of the group
     * @param {Function} specDefinitions Function for Jasmine to invoke that will define inner suites and specs
     */
    describe: function(description, specDefinitions) {
      return env.describe(description, specDefinitions);
    },

    /**
     * A temporarily disabled [`describe`]{@link describe}
     *
     * Specs within an `xdescribe` will be marked pending and not executed
     * @name xdescribe
     * @since 1.3.0
     * @function
     * @global
     * @param {String} description Textual description of the group
     * @param {Function} specDefinitions Function for Jasmine to invoke that will define inner suites and specs
     */
    xdescribe: function(description, specDefinitions) {
      return env.xdescribe(description, specDefinitions);
    },

    /**
     * A focused [`describe`]{@link describe}
     *
     * If suites or specs are focused, only those that are focused will be executed
     * @see fit
     * @name fdescribe
     * @since 2.1.0
     * @function
     * @global
     * @param {String} description Textual description of the group
     * @param {Function} specDefinitions Function for Jasmine to invoke that will define inner suites and specs
     */
    fdescribe: function(description, specDefinitions) {
      return env.fdescribe(description, specDefinitions);
    },

    /**
     * Define a single spec. A spec should contain one or more {@link expect|expectations} that test the state of the code.
     *
     * A spec whose expectations all succeed will be passing and a spec with any failures will fail.
     * The name `it` is a pronoun for the test target, not an abbreviation of anything. It makes the
     * spec more readable by connecting the function name `it` and the argument `description` as a
     * complete sentence.
     * @name it
     * @since 1.3.0
     * @function
     * @global
     * @param {String} description Textual description of what this spec is checking
     * @param {implementationCallback} [testFunction] Function that contains the code of your test. If not provided the test will be `pending`.
     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async spec.
     * @see async
     */
    it: function() {
      return env.it.apply(env, arguments);
    },

    /**
     * A temporarily disabled [`it`]{@link it}
     *
     * The spec will report as `pending` and will not be executed.
     * @name xit
     * @since 1.3.0
     * @function
     * @global
     * @param {String} description Textual description of what this spec is checking.
     * @param {implementationCallback} [testFunction] Function that contains the code of your test. Will not be executed.
     */
    xit: function() {
      return env.xit.apply(env, arguments);
    },

    /**
     * A focused [`it`]{@link it}
     *
     * If suites or specs are focused, only those that are focused will be executed.
     * @name fit
     * @since 2.1.0
     * @function
     * @global
     * @param {String} description Textual description of what this spec is checking.
     * @param {implementationCallback} testFunction Function that contains the code of your test.
     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async spec.
     * @see async
     */
    fit: function() {
      return env.fit.apply(env, arguments);
    },

    /**
     * Run some shared setup before each of the specs in the {@link describe} in which it is called.
     * @name beforeEach
     * @since 1.3.0
     * @function
     * @global
     * @param {implementationCallback} [function] Function that contains the code to setup your specs.
     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async beforeEach.
     * @see async
     */
    beforeEach: function() {
      return env.beforeEach.apply(env, arguments);
    },

    /**
     * Run some shared teardown after each of the specs in the {@link describe} in which it is called.
     * @name afterEach
     * @since 1.3.0
     * @function
     * @global
     * @param {implementationCallback} [function] Function that contains the code to teardown your specs.
     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async afterEach.
     * @see async
     */
    afterEach: function() {
      return env.afterEach.apply(env, arguments);
    },

    /**
     * Run some shared setup once before all of the specs in the {@link describe} are run.
     *
     * _Note:_ Be careful, sharing the setup from a beforeAll makes it easy to accidentally leak state between your specs so that they erroneously pass or fail.
     * @name beforeAll
     * @since 2.1.0
     * @function
     * @global
     * @param {implementationCallback} [function] Function that contains the code to setup your specs.
     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async beforeAll.
     * @see async
     */
    beforeAll: function() {
      return env.beforeAll.apply(env, arguments);
    },

    /**
     * Run some shared teardown once after all of the specs in the {@link describe} are run.
     *
     * _Note:_ Be careful, sharing the teardown from a afterAll makes it easy to accidentally leak state between your specs so that they erroneously pass or fail.
     * @name afterAll
     * @since 2.1.0
     * @function
     * @global
     * @param {implementationCallback} [function] Function that contains the code to teardown your specs.
     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async afterAll.
     * @see async
     */
    afterAll: function() {
      return env.afterAll.apply(env, arguments);
    },

    /**
     * Sets a user-defined property that will be provided to reporters as part of the properties field of {@link SpecResult}
     * @name setSpecProperty
     * @since 3.6.0
     * @function
     * @param {String} key The name of the property
     * @param {*} value The value of the property
     */
    setSpecProperty: function(key, value) {
      return env.setSpecProperty(key, value);
    },

    /**
     * Sets a user-defined property that will be provided to reporters as part of the properties field of {@link SuiteResult}
     * @name setSuiteProperty
     * @since 3.6.0
     * @function
     * @param {String} key The name of the property
     * @param {*} value The value of the property
     */
    setSuiteProperty: function(key, value) {
      return env.setSuiteProperty(key, value);
    },

    /**
     * Create an expectation for a spec.
     * @name expect
     * @since 1.3.0
     * @function
     * @global
     * @param {Object} actual - Actual computed value to test expectations against.
     * @return {matchers}
     */
    expect: function(actual) {
      return env.expect(actual);
    },

    /**
     * Create an asynchronous expectation for a spec. Note that the matchers
     * that are provided by an asynchronous expectation all return promises
     * which must be either returned from the spec or waited for using `await`
     * in order for Jasmine to associate them with the correct spec.
     * @name expectAsync
     * @since 3.3.0
     * @function
     * @global
     * @param {Object} actual - Actual computed value to test expectations against.
     * @return {async-matchers}
     * @example
     * await expectAsync(somePromise).toBeResolved();
     * @example
     * return expectAsync(somePromise).toBeResolved();
     */
    expectAsync: function(actual) {
      return env.expectAsync(actual);
    },

    /**
     * Mark a spec as pending, expectation results will be ignored.
     * @name pending
     * @since 2.0.0
     * @function
     * @global
     * @param {String} [message] - Reason the spec is pending.
     */
    pending: function() {
      return env.pending.apply(env, arguments);
    },

    /**
     * Explicitly mark a spec as failed.
     * @name fail
     * @since 2.1.0
     * @function
     * @global
     * @param {String|Error} [error] - Reason for the failure.
     */
    fail: function() {
      return env.fail.apply(env, arguments);
    },

    /**
     * Install a spy onto an existing object.
     * @name spyOn
     * @since 1.3.0
     * @function
     * @global
     * @param {Object} obj - The object upon which to install the {@link Spy}.
     * @param {String} methodName - The name of the method to replace with a {@link Spy}.
     * @returns {Spy}
     */
    spyOn: function(obj, methodName) {
      return env.spyOn(obj, methodName);
    },

    /**
     * Install a spy on a property installed with `Object.defineProperty` onto an existing object.
     * @name spyOnProperty
     * @since 2.6.0
     * @function
     * @global
     * @param {Object} obj - The object upon which to install the {@link Spy}
     * @param {String} propertyName - The name of the property to replace with a {@link Spy}.
     * @param {String} [accessType=get] - The access type (get|set) of the property to {@link Spy} on.
     * @returns {Spy}
     */
    spyOnProperty: function(obj, methodName, accessType) {
      return env.spyOnProperty(obj, methodName, accessType);
    },

    /**
     * Installs spies on all writable and configurable properties of an object.
     * @name spyOnAllFunctions
     * @since 3.2.1
     * @function
     * @global
     * @param {Object} obj - The object upon which to install the {@link Spy}s
     * @param {boolean} includeNonEnumerable - Whether or not to add spies to non-enumerable properties
     * @returns {Object} the spied object
     */
    spyOnAllFunctions: function(obj, includeNonEnumerable) {
      return env.spyOnAllFunctions(obj, includeNonEnumerable);
    },

    jsApiReporter: new jasmine.JsApiReporter({
      timer: new jasmine.Timer()
    }),

    /**
     * @namespace jasmine
     */
    jasmine: jasmine
  };

  /**
   * Add a custom equality tester for the current scope of specs.
   *
   * _Note:_ This is only callable from within a {@link beforeEach}, {@link it}, or {@link beforeAll}.
   * @name jasmine.addCustomEqualityTester
   * @since 2.0.0
   * @function
   * @param {Function} tester - A function which takes two arguments to compare and returns a `true` or `false` comparison result if it knows how to compare them, and `undefined` otherwise.
   * @see custom_equality
   */
  jasmine.addCustomEqualityTester = function(tester) {
    env.addCustomEqualityTester(tester);
  };

  /**
   * Add custom matchers for the current scope of specs.
   *
   * _Note:_ This is only callable from within a {@link beforeEach}, {@link it}, or {@link beforeAll}.
   * @name jasmine.addMatchers
   * @since 2.0.0
   * @function
   * @param {Object} matchers - Keys from this object will be the new matcher names.
   * @see custom_matcher
   */
  jasmine.addMatchers = function(matchers) {
    return env.addMatchers(matchers);
  };

  /**
   * Add custom async matchers for the current scope of specs.
   *
   * _Note:_ This is only callable from within a {@link beforeEach}, {@link it}, or {@link beforeAll}.
   * @name jasmine.addAsyncMatchers
   * @since 3.5.0
   * @function
   * @param {Object} matchers - Keys from this object will be the new async matcher names.
   * @see custom_matcher
   */
  jasmine.addAsyncMatchers = function(matchers) {
    return env.addAsyncMatchers(matchers);
  };

  /**
   * Add a custom object formatter for the current scope of specs.
   *
   * _Note:_ This is only callable from within a {@link beforeEach}, {@link it}, or {@link beforeAll}.
   * @name jasmine.addCustomObjectFormatter
   * @since 3.6.0
   * @function
   * @param {Function} formatter - A function which takes a value to format and returns a string if it knows how to format it, and `undefined` otherwise.
   * @see custom_object_formatters
   */
  jasmine.addCustomObjectFormatter = function(formatter) {
    return env.addCustomObjectFormatter(formatter);
  };

  /**
   * Get the currently booted mock {Clock} for this Jasmine environment.
   * @name jasmine.clock
   * @since 2.0.0
   * @function
   * @returns {Clock}
   */
  jasmine.clock = function() {
    return env.clock;
  };

  /**
   * Create a bare {@link Spy} object. This won't be installed anywhere and will not have any implementation behind it.
   * @name jasmine.createSpy
   * @since 1.3.0
   * @function
   * @param {String} [name] - Name to give the spy. This will be displayed in failure messages.
   * @param {Function} [originalFn] - Function to act as the real implementation.
   * @return {Spy}
   */
  jasmine.createSpy = function(name, originalFn) {
    return env.createSpy(name, originalFn);
  };

  /**
   * Create an object with multiple {@link Spy}s as its members.
   * @name jasmine.createSpyObj
   * @since 1.3.0
   * @function
   * @param {String} [baseName] - Base name for the spies in the object.
   * @param {String[]|Object} methodNames - Array of method names to create spies for, or Object whose keys will be method names and values the {@link Spy#and#returnValue|returnValue}.
   * @param {String[]|Object} [propertyNames] - Array of property names to create spies for, or Object whose keys will be propertynames and values the {@link Spy#and#returnValue|returnValue}.
   * @return {Object}
   */
  jasmine.createSpyObj = function(baseName, methodNames, propertyNames) {
    return env.createSpyObj(baseName, methodNames, propertyNames);
  };

  /**
   * Add a custom spy strategy for the current scope of specs.
   *
   * _Note:_ This is only callable from within a {@link beforeEach}, {@link it}, or {@link beforeAll}.
   * @name jasmine.addSpyStrategy
   * @since 3.5.0
   * @function
   * @param {String} name - The name of the strategy (i.e. what you call from `and`)
   * @param {Function} factory - Factory function that returns the plan to be executed.
   */
  jasmine.addSpyStrategy = function(name, factory) {
    return env.addSpyStrategy(name, factory);
  };

  /**
   * Set the default spy strategy for the current scope of specs.
   *
   * _Note:_ This is only callable from within a {@link beforeEach}, {@link it}, or {@link beforeAll}.
   * @name jasmine.setDefaultSpyStrategy
   * @function
   * @param {Function} defaultStrategyFn - a function that assigns a strategy
   * @example
   * beforeEach(function() {
   *   jasmine.setDefaultSpyStrategy(and => and.returnValue(true));
   * });
   */
  jasmine.setDefaultSpyStrategy = function(defaultStrategyFn) {
    return env.setDefaultSpyStrategy(defaultStrategyFn);
  };

  return jasmineInterface;
};

getJasmineRequireObj().SkipAfterBeforeAllErrorPolicy = function(j$) {
  function SkipAfterBeforeAllErrorPolicy(queueableFns) {
    this.queueableFns_ = queueableFns;
    this.skipping_ = false;
  }

  SkipAfterBeforeAllErrorPolicy.prototype.skipTo = function(lastRanFnIx) {
    if (this.skipping_) {
      return this.nextAfterAllAfter_(lastRanFnIx);
    } else {
      return lastRanFnIx + 1;
    }
  };

  SkipAfterBeforeAllErrorPolicy.prototype.nextAfterAllAfter_ = function(i) {
    for (
      i++;
      i < this.queueableFns_.length &&
      this.queueableFns_[i].type !== 'afterAll';
      i++
    ) {}
    return i;
  };

  SkipAfterBeforeAllErrorPolicy.prototype.fnErrored = function(fnIx) {
    if (this.queueableFns_[fnIx].type === 'beforeAll') {
      this.skipping_ = true;
      // Failures need to be reported for each contained spec. But we can't do
      // that from here because reporting is async. This function isn't async
      // (and can't be without greatly complicating QueueRunner). Mark the
      // failure so that the code that reports the suite result (which is
      // already async) can detect the failure and report the specs.
      this.queueableFns_[fnIx].suite.hadBeforeAllFailure = true;
    }
  };

  return SkipAfterBeforeAllErrorPolicy;
};

getJasmineRequireObj().Spy = function(j$) {
  var nextOrder = (function() {
    var order = 0;

    return function() {
      return order++;
    };
  })();

  /**
   * @classdesc _Note:_ Do not construct this directly. Use {@link spyOn},
   * {@link spyOnProperty}, {@link jasmine.createSpy}, or
   * {@link jasmine.createSpyObj} instead.
   * @class Spy
   * @hideconstructor
   */
  function Spy(name, matchersUtil, optionals) {
    const { originalFn, customStrategies, defaultStrategyFn } = optionals || {};

    var numArgs = typeof originalFn === 'function' ? originalFn.length : 0,
      wrapper = makeFunc(numArgs, function(context, args, invokeNew) {
        return spy(context, args, invokeNew);
      }),
      strategyDispatcher = new SpyStrategyDispatcher(
        {
          name: name,
          fn: originalFn,
          getSpy: function() {
            return wrapper;
          },
          customStrategies: customStrategies
        },
        matchersUtil
      ),
      callTracker = new j$.CallTracker(),
      spy = function(context, args, invokeNew) {
        /**
         * @name Spy.callData
         * @property {object} object - `this` context for the invocation.
         * @property {number} invocationOrder - Order of the invocation.
         * @property {Array} args - The arguments passed for this invocation.
         * @property returnValue - The value that was returned from this invocation.
         */
        var callData = {
          object: context,
          invocationOrder: nextOrder(),
          args: Array.prototype.slice.apply(args)
        };

        callTracker.track(callData);
        var returnValue = strategyDispatcher.exec(context, args, invokeNew);
        callData.returnValue = returnValue;

        return returnValue;
      };

    function makeFunc(length, fn) {
      switch (length) {
        case 1:
          return function wrap1(a) {
            return fn(this, arguments, this instanceof wrap1);
          };
        case 2:
          return function wrap2(a, b) {
            return fn(this, arguments, this instanceof wrap2);
          };
        case 3:
          return function wrap3(a, b, c) {
            return fn(this, arguments, this instanceof wrap3);
          };
        case 4:
          return function wrap4(a, b, c, d) {
            return fn(this, arguments, this instanceof wrap4);
          };
        case 5:
          return function wrap5(a, b, c, d, e) {
            return fn(this, arguments, this instanceof wrap5);
          };
        case 6:
          return function wrap6(a, b, c, d, e, f) {
            return fn(this, arguments, this instanceof wrap6);
          };
        case 7:
          return function wrap7(a, b, c, d, e, f, g) {
            return fn(this, arguments, this instanceof wrap7);
          };
        case 8:
          return function wrap8(a, b, c, d, e, f, g, h) {
            return fn(this, arguments, this instanceof wrap8);
          };
        case 9:
          return function wrap9(a, b, c, d, e, f, g, h, i) {
            return fn(this, arguments, this instanceof wrap9);
          };
        default:
          return function wrap() {
            return fn(this, arguments, this instanceof wrap);
          };
      }
    }

    for (var prop in originalFn) {
      if (prop === 'and' || prop === 'calls') {
        throw new Error(
          "Jasmine spies would overwrite the 'and' and 'calls' properties on the object being spied upon"
        );
      }

      wrapper[prop] = originalFn[prop];
    }

    /**
     * @member {SpyStrategy} - Accesses the default strategy for the spy. This strategy will be used
     * whenever the spy is called with arguments that don't match any strategy
     * created with {@link Spy#withArgs}.
     * @name Spy#and
     * @since 2.0.0
     * @example
     * spyOn(someObj, 'func').and.returnValue(42);
     */
    wrapper.and = strategyDispatcher.and;
    /**
     * Specifies a strategy to be used for calls to the spy that have the
     * specified arguments.
     * @name Spy#withArgs
     * @since 3.0.0
     * @function
     * @param {...*} args - The arguments to match
     * @type {SpyStrategy}
     * @example
     * spyOn(someObj, 'func').withArgs(1, 2, 3).and.returnValue(42);
     * someObj.func(1, 2, 3); // returns 42
     */
    wrapper.withArgs = function() {
      return strategyDispatcher.withArgs.apply(strategyDispatcher, arguments);
    };
    wrapper.calls = callTracker;

    if (defaultStrategyFn) {
      defaultStrategyFn(wrapper.and);
    }

    return wrapper;
  }

  function SpyStrategyDispatcher(strategyArgs, matchersUtil) {
    var baseStrategy = new j$.SpyStrategy(strategyArgs);
    var argsStrategies = new StrategyDict(function() {
      return new j$.SpyStrategy(strategyArgs);
    }, matchersUtil);

    this.and = baseStrategy;

    this.exec = function(spy, args, invokeNew) {
      var strategy = argsStrategies.get(args);

      if (!strategy) {
        if (argsStrategies.any() && !baseStrategy.isConfigured()) {
          throw new Error(
            "Spy '" +
              strategyArgs.name +
              "' received a call with arguments " +
              j$.basicPrettyPrinter_(Array.prototype.slice.call(args)) +
              ' but all configured strategies specify other arguments.'
          );
        } else {
          strategy = baseStrategy;
        }
      }

      return strategy.exec(spy, args, invokeNew);
    };

    this.withArgs = function() {
      return { and: argsStrategies.getOrCreate(arguments) };
    };
  }

  function StrategyDict(strategyFactory, matchersUtil) {
    this.strategies = [];
    this.strategyFactory = strategyFactory;
    this.matchersUtil = matchersUtil;
  }

  StrategyDict.prototype.any = function() {
    return this.strategies.length > 0;
  };

  StrategyDict.prototype.getOrCreate = function(args) {
    var strategy = this.get(args);

    if (!strategy) {
      strategy = this.strategyFactory();
      this.strategies.push({
        args: args,
        strategy: strategy
      });
    }

    return strategy;
  };

  StrategyDict.prototype.get = function(args) {
    var i;

    for (i = 0; i < this.strategies.length; i++) {
      if (this.matchersUtil.equals(args, this.strategies[i].args)) {
        return this.strategies[i].strategy;
      }
    }
  };

  return Spy;
};

getJasmineRequireObj().SpyFactory = function(j$) {
  function SpyFactory(
    getCustomStrategies,
    getDefaultStrategyFn,
    getMatchersUtil
  ) {
    var self = this;

    this.createSpy = function(name, originalFn) {
      return j$.Spy(name, getMatchersUtil(), {
        originalFn,
        customStrategies: getCustomStrategies(),
        defaultStrategyFn: getDefaultStrategyFn()
      });
    };

    this.createSpyObj = function(baseName, methodNames, propertyNames) {
      var baseNameIsCollection =
        j$.isObject_(baseName) || j$.isArray_(baseName);

      if (baseNameIsCollection) {
        propertyNames = methodNames;
        methodNames = baseName;
        baseName = 'unknown';
      }

      var obj = {};
      var spy, descriptor;

      var methods = normalizeKeyValues(methodNames);
      for (var i = 0; i < methods.length; i++) {
        spy = obj[methods[i][0]] = self.createSpy(
          baseName + '.' + methods[i][0]
        );
        if (methods[i].length > 1) {
          spy.and.returnValue(methods[i][1]);
        }
      }

      var properties = normalizeKeyValues(propertyNames);
      for (var i = 0; i < properties.length; i++) {
        descriptor = {
          enumerable: true,
          get: self.createSpy(baseName + '.' + properties[i][0] + '.get'),
          set: self.createSpy(baseName + '.' + properties[i][0] + '.set')
        };
        if (properties[i].length > 1) {
          descriptor.get.and.returnValue(properties[i][1]);
          descriptor.set.and.returnValue(properties[i][1]);
        }
        Object.defineProperty(obj, properties[i][0], descriptor);
      }

      if (methods.length === 0 && properties.length === 0) {
        throw 'createSpyObj requires a non-empty array or object of method names to create spies for';
      }

      return obj;
    };
  }

  function normalizeKeyValues(object) {
    var result = [];
    if (j$.isArray_(object)) {
      for (var i = 0; i < object.length; i++) {
        result.push([object[i]]);
      }
    } else if (j$.isObject_(object)) {
      for (var key in object) {
        if (object.hasOwnProperty(key)) {
          result.push([key, object[key]]);
        }
      }
    }
    return result;
  }

  return SpyFactory;
};

getJasmineRequireObj().SpyRegistry = function(j$) {
  var spyOnMsg = j$.formatErrorMsg('<spyOn>', 'spyOn(<object>, <methodName>)');
  var spyOnPropertyMsg = j$.formatErrorMsg(
    '<spyOnProperty>',
    'spyOnProperty(<object>, <propName>, [accessType])'
  );

  function SpyRegistry(options) {
    options = options || {};
    var global = options.global || j$.getGlobal();
    var createSpy = options.createSpy;
    var currentSpies =
      options.currentSpies ||
      function() {
        return [];
      };

    this.allowRespy = function(allow) {
      this.respy = allow;
    };

    this.spyOn = function(obj, methodName) {
      var getErrorMsg = spyOnMsg;

      if (j$.util.isUndefined(obj) || obj === null) {
        throw new Error(
          getErrorMsg(
            'could not find an object to spy upon for ' + methodName + '()'
          )
        );
      }

      if (j$.util.isUndefined(methodName) || methodName === null) {
        throw new Error(getErrorMsg('No method name supplied'));
      }

      if (j$.util.isUndefined(obj[methodName])) {
        throw new Error(getErrorMsg(methodName + '() method does not exist'));
      }

      if (obj[methodName] && j$.isSpy(obj[methodName])) {
        if (this.respy) {
          return obj[methodName];
        } else {
          throw new Error(
            getErrorMsg(methodName + ' has already been spied upon')
          );
        }
      }

      var descriptor = Object.getOwnPropertyDescriptor(obj, methodName);

      if (descriptor && !(descriptor.writable || descriptor.set)) {
        throw new Error(
          getErrorMsg(methodName + ' is not declared writable or has no setter')
        );
      }

      var originalMethod = obj[methodName],
        spiedMethod = createSpy(methodName, originalMethod),
        restoreStrategy;

      if (
        Object.prototype.hasOwnProperty.call(obj, methodName) ||
        (obj === global && methodName === 'onerror')
      ) {
        restoreStrategy = function() {
          obj[methodName] = originalMethod;
        };
      } else {
        restoreStrategy = function() {
          if (!delete obj[methodName]) {
            obj[methodName] = originalMethod;
          }
        };
      }

      currentSpies().push({
        restoreObjectToOriginalState: restoreStrategy
      });

      obj[methodName] = spiedMethod;

      return spiedMethod;
    };

    this.spyOnProperty = function(obj, propertyName, accessType) {
      var getErrorMsg = spyOnPropertyMsg;

      accessType = accessType || 'get';

      if (j$.util.isUndefined(obj)) {
        throw new Error(
          getErrorMsg(
            'spyOn could not find an object to spy upon for ' +
              propertyName +
              ''
          )
        );
      }

      if (j$.util.isUndefined(propertyName)) {
        throw new Error(getErrorMsg('No property name supplied'));
      }

      var descriptor = j$.util.getPropertyDescriptor(obj, propertyName);

      if (!descriptor) {
        throw new Error(getErrorMsg(propertyName + ' property does not exist'));
      }

      if (!descriptor.configurable) {
        throw new Error(
          getErrorMsg(propertyName + ' is not declared configurable')
        );
      }

      if (!descriptor[accessType]) {
        throw new Error(
          getErrorMsg(
            'Property ' +
              propertyName +
              ' does not have access type ' +
              accessType
          )
        );
      }

      if (j$.isSpy(descriptor[accessType])) {
        if (this.respy) {
          return descriptor[accessType];
        } else {
          throw new Error(
            getErrorMsg(
              propertyName + '#' + accessType + ' has already been spied upon'
            )
          );
        }
      }

      var originalDescriptor = j$.util.clone(descriptor),
        spy = createSpy(propertyName, descriptor[accessType]),
        restoreStrategy;

      if (Object.prototype.hasOwnProperty.call(obj, propertyName)) {
        restoreStrategy = function() {
          Object.defineProperty(obj, propertyName, originalDescriptor);
        };
      } else {
        restoreStrategy = function() {
          delete obj[propertyName];
        };
      }

      currentSpies().push({
        restoreObjectToOriginalState: restoreStrategy
      });

      descriptor[accessType] = spy;

      Object.defineProperty(obj, propertyName, descriptor);

      return spy;
    };

    this.spyOnAllFunctions = function(obj, includeNonEnumerable) {
      if (j$.util.isUndefined(obj)) {
        throw new Error(
          'spyOnAllFunctions could not find an object to spy upon'
        );
      }

      var pointer = obj,
        propsToSpyOn = [],
        properties,
        propertiesToSkip = [];

      while (
        pointer &&
        (!includeNonEnumerable || pointer !== Object.prototype)
      ) {
        properties = getProps(pointer, includeNonEnumerable);
        properties = properties.filter(function(prop) {
          return propertiesToSkip.indexOf(prop) === -1;
        });
        propertiesToSkip = propertiesToSkip.concat(properties);
        propsToSpyOn = propsToSpyOn.concat(
          getSpyableFunctionProps(pointer, properties)
        );
        pointer = Object.getPrototypeOf(pointer);
      }

      for (var i = 0; i < propsToSpyOn.length; i++) {
        this.spyOn(obj, propsToSpyOn[i]);
      }

      return obj;
    };

    this.clearSpies = function() {
      var spies = currentSpies();
      for (var i = spies.length - 1; i >= 0; i--) {
        var spyEntry = spies[i];
        spyEntry.restoreObjectToOriginalState();
      }
    };
  }

  function getProps(obj, includeNonEnumerable) {
    var enumerableProperties = Object.keys(obj);

    if (!includeNonEnumerable) {
      return enumerableProperties;
    }

    return Object.getOwnPropertyNames(obj).filter(function(prop) {
      return (
        prop !== 'constructor' ||
        enumerableProperties.indexOf('constructor') > -1
      );
    });
  }

  function getSpyableFunctionProps(obj, propertiesToCheck) {
    var props = [],
      prop;
    for (var i = 0; i < propertiesToCheck.length; i++) {
      prop = propertiesToCheck[i];
      if (
        Object.prototype.hasOwnProperty.call(obj, prop) &&
        isSpyableProp(obj, prop)
      ) {
        props.push(prop);
      }
    }
    return props;
  }

  function isSpyableProp(obj, prop) {
    var value, descriptor;
    try {
      value = obj[prop];
    } catch (e) {
      return false;
    }
    if (value instanceof Function) {
      descriptor = Object.getOwnPropertyDescriptor(obj, prop);
      return (descriptor.writable || descriptor.set) && descriptor.configurable;
    }
    return false;
  }

  return SpyRegistry;
};

getJasmineRequireObj().SpyStrategy = function(j$) {
  /**
   * @interface SpyStrategy
   */
  function SpyStrategy(options) {
    options = options || {};

    var self = this;

    /**
     * Get the identifying information for the spy.
     * @name SpyStrategy#identity
     * @since 3.0.0
     * @member
     * @type {String}
     */
    this.identity = options.name || 'unknown';
    this.originalFn = options.fn || function() {};
    this.getSpy = options.getSpy || function() {};
    this.plan = this._defaultPlan = function() {};

    var k,
      cs = options.customStrategies || {};
    for (k in cs) {
      if (j$.util.has(cs, k) && !this[k]) {
        this[k] = createCustomPlan(cs[k]);
      }
    }

    /**
     * Tell the spy to return a promise resolving to the specified value when invoked.
     * @name SpyStrategy#resolveTo
     * @since 3.5.0
     * @function
     * @param {*} value The value to return.
     */
    this.resolveTo = function(value) {
      self.plan = function() {
        return Promise.resolve(value);
      };
      return self.getSpy();
    };

    /**
     * Tell the spy to return a promise rejecting with the specified value when invoked.
     * @name SpyStrategy#rejectWith
     * @since 3.5.0
     * @function
     * @param {*} value The value to return.
     */
    this.rejectWith = function(value) {
      self.plan = function() {
        return Promise.reject(value);
      };
      return self.getSpy();
    };
  }

  function createCustomPlan(factory) {
    return function() {
      var plan = factory.apply(null, arguments);

      if (!j$.isFunction_(plan)) {
        throw new Error('Spy strategy must return a function');
      }

      this.plan = plan;
      return this.getSpy();
    };
  }

  /**
   * Execute the current spy strategy.
   * @name SpyStrategy#exec
   * @since 2.0.0
   * @function
   */
  SpyStrategy.prototype.exec = function(context, args, invokeNew) {
    var contextArgs = [context].concat(
      args ? Array.prototype.slice.call(args) : []
    );
    var target = this.plan.bind.apply(this.plan, contextArgs);

    return invokeNew ? new target() : target();
  };

  /**
   * Tell the spy to call through to the real implementation when invoked.
   * @name SpyStrategy#callThrough
   * @since 2.0.0
   * @function
   */
  SpyStrategy.prototype.callThrough = function() {
    this.plan = this.originalFn;
    return this.getSpy();
  };

  /**
   * Tell the spy to return the value when invoked.
   * @name SpyStrategy#returnValue
   * @since 2.0.0
   * @function
   * @param {*} value The value to return.
   */
  SpyStrategy.prototype.returnValue = function(value) {
    this.plan = function() {
      return value;
    };
    return this.getSpy();
  };

  /**
   * Tell the spy to return one of the specified values (sequentially) each time the spy is invoked.
   * @name SpyStrategy#returnValues
   * @since 2.1.0
   * @function
   * @param {...*} values - Values to be returned on subsequent calls to the spy.
   */
  SpyStrategy.prototype.returnValues = function() {
    var values = Array.prototype.slice.call(arguments);
    this.plan = function() {
      return values.shift();
    };
    return this.getSpy();
  };

  /**
   * Tell the spy to throw an error when invoked.
   * @name SpyStrategy#throwError
   * @since 2.0.0
   * @function
   * @param {Error|Object|String} something Thing to throw
   */
  SpyStrategy.prototype.throwError = function(something) {
    var error = j$.isString_(something) ? new Error(something) : something;
    this.plan = function() {
      throw error;
    };
    return this.getSpy();
  };

  /**
   * Tell the spy to call a fake implementation when invoked.
   * @name SpyStrategy#callFake
   * @since 2.0.0
   * @function
   * @param {Function} fn The function to invoke with the passed parameters.
   */
  SpyStrategy.prototype.callFake = function(fn) {
    if (
      !(
        j$.isFunction_(fn) ||
        j$.isAsyncFunction_(fn) ||
        j$.isGeneratorFunction_(fn)
      )
    ) {
      throw new Error(
        'Argument passed to callFake should be a function, got ' + fn
      );
    }
    this.plan = fn;
    return this.getSpy();
  };

  /**
   * Tell the spy to do nothing when invoked. This is the default.
   * @name SpyStrategy#stub
   * @since 2.0.0
   * @function
   */
  SpyStrategy.prototype.stub = function(fn) {
    this.plan = function() {};
    return this.getSpy();
  };

  SpyStrategy.prototype.isConfigured = function() {
    return this.plan !== this._defaultPlan;
  };

  return SpyStrategy;
};

getJasmineRequireObj().StackTrace = function(j$) {
  function StackTrace(error) {
    var lines = error.stack.split('\n').filter(function(line) {
      return line !== '';
    });

    var extractResult = extractMessage(error.message, lines);

    if (extractResult) {
      this.message = extractResult.message;
      lines = extractResult.remainder;
    }

    var parseResult = tryParseFrames(lines);
    this.frames = parseResult.frames;
    this.style = parseResult.style;
  }

  var framePatterns = [
    // Node, Chrome, Edge
    // e.g. "   at QueueRunner.run (http://localhost:8888/__jasmine__/jasmine.js:4320:20)"
    // Note that the "function name" can include a surprisingly large set of
    // characters, including angle brackets and square brackets.
    {
      re: /^\s*at ([^\)]+) \(([^\)]+)\)$/,
      fnIx: 1,
      fileLineColIx: 2,
      style: 'v8'
    },

    // NodeJS alternate form, often mixed in with the Chrome style
    // e.g. "  at /some/path:4320:20
    { re: /\s*at (.+)$/, fileLineColIx: 1, style: 'v8' },

    // PhantomJS on OS X, Safari, Firefox
    // e.g. "run@http://localhost:8888/__jasmine__/jasmine.js:4320:27"
    // or "http://localhost:8888/__jasmine__/jasmine.js:4320:27"
    {
      re: /^(?:(([^@\s]+)@)|@)?([^\s]+)$/,
      fnIx: 2,
      fileLineColIx: 3,
      style: 'webkit'
    }
  ];

  // regexes should capture the function name (if any) as group 1
  // and the file, line, and column as group 2.
  function tryParseFrames(lines) {
    var style = null;
    var frames = lines.map(function(line) {
      var convertedLine = first(framePatterns, function(pattern) {
        var overallMatch = line.match(pattern.re),
          fileLineColMatch;
        if (!overallMatch) {
          return null;
        }

        fileLineColMatch = overallMatch[pattern.fileLineColIx].match(
          /^(.*):(\d+):\d+$/
        );
        if (!fileLineColMatch) {
          return null;
        }

        style = style || pattern.style;
        return {
          raw: line,
          file: fileLineColMatch[1],
          line: parseInt(fileLineColMatch[2], 10),
          func: overallMatch[pattern.fnIx]
        };
      });

      return convertedLine || { raw: line };
    });

    return {
      style: style,
      frames: frames
    };
  }

  function first(items, fn) {
    var i, result;

    for (i = 0; i < items.length; i++) {
      result = fn(items[i]);

      if (result) {
        return result;
      }
    }
  }

  function extractMessage(message, stackLines) {
    var len = messagePrefixLength(message, stackLines);

    if (len > 0) {
      return {
        message: stackLines.slice(0, len).join('\n'),
        remainder: stackLines.slice(len)
      };
    }
  }

  function messagePrefixLength(message, stackLines) {
    if (!stackLines[0].match(/^\w*Error/)) {
      return 0;
    }

    var messageLines = message.split('\n');
    var i;

    for (i = 1; i < messageLines.length; i++) {
      if (messageLines[i] !== stackLines[i]) {
        return 0;
      }
    }

    return messageLines.length;
  }

  return StackTrace;
};

getJasmineRequireObj().Suite = function(j$) {
  /**
   * @interface Suite
   * @see Env#topSuite
   * @since 2.0.0
   */
  function Suite(attrs) {
    this.env = attrs.env;
    /**
     * The unique ID of this suite.
     * @name Suite#id
     * @readonly
     * @type {string}
     * @since 2.0.0
     */
    this.id = attrs.id;
    this.parentSuite = attrs.parentSuite;
    /**
     * The description passed to the {@link describe} that created this suite.
     * @name Suite#description
     * @readonly
     * @type {string}
     * @since 2.0.0
     */
    this.description = attrs.description;
    this.expectationFactory = attrs.expectationFactory;
    this.asyncExpectationFactory = attrs.asyncExpectationFactory;
    this.expectationResultFactory = attrs.expectationResultFactory;
    this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;
    this.autoCleanClosures =
      attrs.autoCleanClosures === undefined ? true : !!attrs.autoCleanClosures;
    this.onLateError = attrs.onLateError;

    this.beforeFns = [];
    this.afterFns = [];
    this.beforeAllFns = [];
    this.afterAllFns = [];
    this.timer = attrs.timer || new j$.Timer();

    /**
     * The suite's children.
     * @name Suite#children
     * @type {Array.<(Spec|Suite)>}
     * @since 2.0.0
     */
    this.children = [];

    this.reset();
  }

  Suite.prototype.setSuiteProperty = function(key, value) {
    this.result.properties = this.result.properties || {};
    this.result.properties[key] = value;
  };

  Suite.prototype.expect = function(actual) {
    return this.expectationFactory(actual, this);
  };

  Suite.prototype.expectAsync = function(actual) {
    return this.asyncExpectationFactory(actual, this);
  };

  /**
   * The full description including all ancestors of this suite.
   * @name Suite#getFullName
   * @function
   * @returns {string}
   * @since 2.0.0
   */
  Suite.prototype.getFullName = function() {
    var fullName = [];
    for (
      var parentSuite = this;
      parentSuite;
      parentSuite = parentSuite.parentSuite
    ) {
      if (parentSuite.parentSuite) {
        fullName.unshift(parentSuite.description);
      }
    }
    return fullName.join(' ');
  };

  /*
   * Mark the suite with "pending" status
   */
  Suite.prototype.pend = function() {
    this.markedPending = true;
  };

  /*
   * Like {@link Suite#pend}, but pending state will survive {@link Spec#reset}
   * Useful for fdescribe, xdescribe, where pending state should remain.
   */
  Suite.prototype.exclude = function() {
    this.pend();
    this.markedExcluding = true;
  };

  Suite.prototype.beforeEach = function(fn) {
    this.beforeFns.unshift({ ...fn, suite: this });
  };

  Suite.prototype.beforeAll = function(fn) {
    this.beforeAllFns.push({ ...fn, type: 'beforeAll', suite: this });
  };

  Suite.prototype.afterEach = function(fn) {
    this.afterFns.unshift({ ...fn, suite: this, type: 'afterEach' });
  };

  Suite.prototype.afterAll = function(fn) {
    this.afterAllFns.unshift({ ...fn, type: 'afterAll' });
  };

  Suite.prototype.startTimer = function() {
    this.timer.start();
  };

  Suite.prototype.endTimer = function() {
    this.result.duration = this.timer.elapsed();
  };

  function removeFns(queueableFns) {
    for (var i = 0; i < queueableFns.length; i++) {
      queueableFns[i].fn = null;
    }
  }

  Suite.prototype.cleanupBeforeAfter = function() {
    if (this.autoCleanClosures) {
      removeFns(this.beforeAllFns);
      removeFns(this.afterAllFns);
      removeFns(this.beforeFns);
      removeFns(this.afterFns);
    }
  };

  Suite.prototype.reset = function() {
    /**
     * @typedef SuiteResult
     * @property {Int} id - The unique id of this suite.
     * @property {String} description - The description text passed to the {@link describe} that made this suite.
     * @property {String} fullName - The full description including all ancestors of this suite.
     * @property {Expectation[]} failedExpectations - The list of expectations that failed in an {@link afterAll} for this suite.
     * @property {Expectation[]} deprecationWarnings - The list of deprecation warnings that occurred on this suite.
     * @property {String} status - Once the suite has completed, this string represents the pass/fail status of this suite.
     * @property {number} duration - The time in ms for Suite execution, including any before/afterAll, before/afterEach.
     * @property {Object} properties - User-supplied properties, if any, that were set using {@link Env#setSuiteProperty}
     * @since 2.0.0
     */
    this.result = {
      id: this.id,
      description: this.description,
      fullName: this.getFullName(),
      failedExpectations: [],
      deprecationWarnings: [],
      duration: null,
      properties: null
    };
    this.markedPending = this.markedExcluding;
    this.children.forEach(function(child) {
      child.reset();
    });
  };

  Suite.prototype.addChild = function(child) {
    this.children.push(child);
  };

  Suite.prototype.status = function() {
    if (this.markedPending) {
      return 'pending';
    }

    if (this.result.failedExpectations.length > 0) {
      return 'failed';
    } else {
      return 'passed';
    }
  };

  Suite.prototype.canBeReentered = function() {
    return this.beforeAllFns.length === 0 && this.afterAllFns.length === 0;
  };

  Suite.prototype.getResult = function() {
    this.result.status = this.status();
    return this.result;
  };

  Suite.prototype.sharedUserContext = function() {
    if (!this.sharedContext) {
      this.sharedContext = this.parentSuite
        ? this.parentSuite.clonedSharedUserContext()
        : new j$.UserContext();
    }

    return this.sharedContext;
  };

  Suite.prototype.clonedSharedUserContext = function() {
    return j$.UserContext.fromExisting(this.sharedUserContext());
  };

  Suite.prototype.onException = function() {
    if (arguments[0] instanceof j$.errors.ExpectationFailed) {
      return;
    }

    var data = {
      matcherName: '',
      passed: false,
      expected: '',
      actual: '',
      error: arguments[0]
    };
    var failedExpectation = this.expectationResultFactory(data);

    if (!this.parentSuite) {
      failedExpectation.globalErrorType = 'afterAll';
    }

    this.result.failedExpectations.push(failedExpectation);
  };

  Suite.prototype.onMultipleDone = function() {
    let msg;

    // Issue a deprecation. Include the context ourselves and pass
    // ignoreRunnable: true, since getting here always means that we've already
    // moved on and the current runnable isn't the one that caused the problem.
    if (this.parentSuite) {
      msg =
        "An asynchronous beforeAll or afterAll function called its 'done' " +
        'callback more than once.\n' +
        '(in suite: ' +
        this.getFullName() +
        ')';
    } else {
      msg =
        'A top-level beforeAll or afterAll function called its ' +
        "'done' callback more than once.";
    }

    this.onLateError(new Error(msg));
  };

  Suite.prototype.addExpectationResult = function() {
    if (isFailure(arguments)) {
      var data = arguments[1];
      this.result.failedExpectations.push(this.expectationResultFactory(data));
      if (this.throwOnExpectationFailure) {
        throw new j$.errors.ExpectationFailed();
      }
    }
  };

  Suite.prototype.addDeprecationWarning = function(deprecation) {
    if (typeof deprecation === 'string') {
      deprecation = { message: deprecation };
    }
    this.result.deprecationWarnings.push(
      this.expectationResultFactory(deprecation)
    );
  };

  Object.defineProperty(Suite.prototype, 'metadata', {
    get: function() {
      if (!this.metadata_) {
        this.metadata_ = new SuiteMetadata(this);
      }

      return this.metadata_;
    }
  });

  /**
   * @interface Suite
   * @see Env#topSuite
   */
  function SuiteMetadata(suite) {
    this.suite_ = suite;
    /**
     * The unique ID of this suite.
     * @name Suite#id
     * @readonly
     * @type {string}
     */
    this.id = suite.id;

    /**
     * The parent of this suite, or null if this is the top suite.
     * @name Suite#parentSuite
     * @readonly
     * @type {Suite}
     */
    this.parentSuite = suite.parentSuite ? suite.parentSuite.metadata : null;

    /**
     * The description passed to the {@link describe} that created this suite.
     * @name Suite#description
     * @readonly
     * @type {string}
     */
    this.description = suite.description;
  }

  /**
   * The full description including all ancestors of this suite.
   * @name Suite#getFullName
   * @function
   * @returns {string}
   */
  SuiteMetadata.prototype.getFullName = function() {
    return this.suite_.getFullName();
  };

  /**
   * The suite's children.
   * @name Suite#children
   * @type {Array.<(Spec|Suite)>}
   */
  Object.defineProperty(SuiteMetadata.prototype, 'children', {
    get: function() {
      return this.suite_.children.map(child => child.metadata);
    }
  });

  function isFailure(args) {
    return !args[0];
  }

  return Suite;
};

getJasmineRequireObj().Timer = function() {
  var defaultNow = (function(Date) {
    return function() {
      return new Date().getTime();
    };
  })(Date);

  function Timer(options) {
    options = options || {};

    var now = options.now || defaultNow,
      startTime;

    this.start = function() {
      startTime = now();
    };

    this.elapsed = function() {
      return now() - startTime;
    };
  }

  return Timer;
};

getJasmineRequireObj().TreeProcessor = function() {
  function TreeProcessor(attrs) {
    var tree = attrs.tree,
      runnableIds = attrs.runnableIds,
      queueRunnerFactory = attrs.queueRunnerFactory,
      nodeStart = attrs.nodeStart || function() {},
      nodeComplete = attrs.nodeComplete || function() {},
      failSpecWithNoExpectations = !!attrs.failSpecWithNoExpectations,
      orderChildren =
        attrs.orderChildren ||
        function(node) {
          return node.children;
        },
      excludeNode =
        attrs.excludeNode ||
        function(node) {
          return false;
        },
      stats = { valid: true },
      processed = false,
      defaultMin = Infinity,
      defaultMax = 1 - Infinity;

    this.processTree = function() {
      processNode(tree, true);
      processed = true;
      return stats;
    };

    this.execute = function(done) {
      if (!processed) {
        this.processTree();
      }

      if (!stats.valid) {
        throw 'invalid order';
      }

      var childFns = wrapChildren(tree, 0);

      queueRunnerFactory({
        queueableFns: childFns,
        userContext: tree.sharedUserContext(),
        onException: function() {
          tree.onException.apply(tree, arguments);
        },
        onComplete: done,
        onMultipleDone: tree.onMultipleDone
          ? tree.onMultipleDone.bind(tree)
          : null
      });
    };

    function runnableIndex(id) {
      for (var i = 0; i < runnableIds.length; i++) {
        if (runnableIds[i] === id) {
          return i;
        }
      }
    }

    function processNode(node, parentExcluded) {
      var executableIndex = runnableIndex(node.id);

      if (executableIndex !== undefined) {
        parentExcluded = false;
      }

      if (!node.children) {
        var excluded = parentExcluded || excludeNode(node);
        stats[node.id] = {
          excluded: excluded,
          willExecute: !excluded && !node.markedPending,
          segments: [
            {
              index: 0,
              owner: node,
              nodes: [node],
              min: startingMin(executableIndex),
              max: startingMax(executableIndex)
            }
          ]
        };
      } else {
        var hasExecutableChild = false;

        var orderedChildren = orderChildren(node);

        for (var i = 0; i < orderedChildren.length; i++) {
          var child = orderedChildren[i];

          processNode(child, parentExcluded);

          if (!stats.valid) {
            return;
          }

          var childStats = stats[child.id];

          hasExecutableChild = hasExecutableChild || childStats.willExecute;
        }

        stats[node.id] = {
          excluded: parentExcluded,
          willExecute: hasExecutableChild
        };

        segmentChildren(node, orderedChildren, stats[node.id], executableIndex);

        if (!node.canBeReentered() && stats[node.id].segments.length > 1) {
          stats = { valid: false };
        }
      }
    }

    function startingMin(executableIndex) {
      return executableIndex === undefined ? defaultMin : executableIndex;
    }

    function startingMax(executableIndex) {
      return executableIndex === undefined ? defaultMax : executableIndex;
    }

    function segmentChildren(
      node,
      orderedChildren,
      nodeStats,
      executableIndex
    ) {
      var currentSegment = {
          index: 0,
          owner: node,
          nodes: [],
          min: startingMin(executableIndex),
          max: startingMax(executableIndex)
        },
        result = [currentSegment],
        lastMax = defaultMax,
        orderedChildSegments = orderChildSegments(orderedChildren);

      function isSegmentBoundary(minIndex) {
        return (
          lastMax !== defaultMax &&
          minIndex !== defaultMin &&
          lastMax < minIndex - 1
        );
      }

      for (var i = 0; i < orderedChildSegments.length; i++) {
        var childSegment = orderedChildSegments[i],
          maxIndex = childSegment.max,
          minIndex = childSegment.min;

        if (isSegmentBoundary(minIndex)) {
          currentSegment = {
            index: result.length,
            owner: node,
            nodes: [],
            min: defaultMin,
            max: defaultMax
          };
          result.push(currentSegment);
        }

        currentSegment.nodes.push(childSegment);
        currentSegment.min = Math.min(currentSegment.min, minIndex);
        currentSegment.max = Math.max(currentSegment.max, maxIndex);
        lastMax = maxIndex;
      }

      nodeStats.segments = result;
    }

    function orderChildSegments(children) {
      var specifiedOrder = [],
        unspecifiedOrder = [];

      for (var i = 0; i < children.length; i++) {
        var child = children[i],
          segments = stats[child.id].segments;

        for (var j = 0; j < segments.length; j++) {
          var seg = segments[j];

          if (seg.min === defaultMin) {
            unspecifiedOrder.push(seg);
          } else {
            specifiedOrder.push(seg);
          }
        }
      }

      specifiedOrder.sort(function(a, b) {
        return a.min - b.min;
      });

      return specifiedOrder.concat(unspecifiedOrder);
    }

    function executeNode(node, segmentNumber) {
      if (node.children) {
        return {
          fn: function(done) {
            var onStart = {
              fn: function(next) {
                nodeStart(node, next);
              }
            };

            queueRunnerFactory({
              onComplete: function() {
                var args = Array.prototype.slice.call(arguments, [0]);
                node.cleanupBeforeAfter();
                nodeComplete(node, node.getResult(), function() {
                  done.apply(undefined, args);
                });
              },
              queueableFns: [onStart].concat(wrapChildren(node, segmentNumber)),
              userContext: node.sharedUserContext(),
              onException: function() {
                node.onException.apply(node, arguments);
              },
              onMultipleDone: node.onMultipleDone
                ? node.onMultipleDone.bind(node)
                : null
            });
          }
        };
      } else {
        return {
          fn: function(done) {
            node.execute(
              done,
              stats[node.id].excluded,
              failSpecWithNoExpectations
            );
          }
        };
      }
    }

    function wrapChildren(node, segmentNumber) {
      var result = [],
        segmentChildren = stats[node.id].segments[segmentNumber].nodes;

      for (var i = 0; i < segmentChildren.length; i++) {
        result.push(
          executeNode(segmentChildren[i].owner, segmentChildren[i].index)
        );
      }

      if (!stats[node.id].willExecute) {
        return result;
      }

      return node.beforeAllFns.concat(result).concat(node.afterAllFns);
    }
  }

  return TreeProcessor;
};

getJasmineRequireObj().UserContext = function(j$) {
  function UserContext() {}

  UserContext.fromExisting = function(oldContext) {
    var context = new UserContext();

    for (var prop in oldContext) {
      if (oldContext.hasOwnProperty(prop)) {
        context[prop] = oldContext[prop];
      }
    }

    return context;
  };

  return UserContext;
};

getJasmineRequireObj().version = function() {
  return '4.0.1';
};


/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/compute-voxels.wgsl":
/*!***********************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/compute-voxels.wgsl ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("struct Permutations {\n  Perm : array<i32, 512>,\n};\n\n@binding(0) @group(0)\nvar<storage, read> perm : Permutations;\n\nstruct CornerMaterials {\n  cornerMaterials : array<u32>,\n};\n\n@binding(1) @group(0)\nvar<storage, read_write> cornerMaterials: CornerMaterials;\n\nstruct VoxelMaterials {\n  voxelMaterials : array<u32>,\n};\n\n@binding(2) @group(0)\nvar<storage, read_write> voxelMaterials: VoxelMaterials;\n\nstruct CornerIndex {\n  cornerCount : u32,\n  cornerIndexes : array<u32>\n};\n\n@binding(3) @group(0)\nvar<storage, read_write> cornerIndex: CornerIndex;\n\nstruct GPUVOX\n{\n\tvoxMin: vec3<f32>,\n\tcorners: f32,\n\tvertPoint: vec3<f32>,\n\tavgNormal: vec3<f32>,\n\tnumPoints: f32\n};\nstruct GPUVOXS {\n  voxels : array<GPUVOX>,\n};\n\n@binding(4) @group(0)\nvar<storage, read_write> voxels: GPUVOXS;\n\nstruct UniformBufferObject {\n  chunkPosition : vec3<f32>,\n  stride : f32,\n\twidth: u32\n};\n\n@binding(5) @group(0)\nvar<uniform> uniforms : UniformBufferObject;\n\nstruct Actor {\n  position: vec3<f32>,\n  velocity: vec3<f32>\n};\n\n\nstruct Physics {\n  actors: array<Actor>\n};\n\n@binding(6) @group(0)\nvar<storage, read_write> physics : Physics;\n\n\nlet CHILD_MIN_OFFSETS: array<vec3<u32>, 8> = array<vec3<u32>, 8>\n(\n  vec3<u32>(0u, 0u, 0u),\n  vec3<u32>(0u, 0u, 1u),\n  vec3<u32>(0u, 1u, 0u),\n  vec3<u32>(0u, 1u, 1u),\n  vec3<u32>(1u, 0u, 0u),\n  vec3<u32>(1u, 0u, 1u),\n  vec3<u32>(1u, 1u, 0u),\n  vec3<u32>(1u, 1u, 1u)\n);\n\nlet edgevmap: array<vec2<i32>, 12> = array<vec2<i32>, 12>\n(\n\tvec2<i32>(0,4), vec2<i32>(1,5), vec2<i32>(2,6), vec2<i32>(3,7),\n\tvec2<i32>(0,2), vec2<i32>(1,3), vec2<i32>(4,6), vec2<i32>(5,7),\n\tvec2<i32>(0,1), vec2<i32>(2,3), vec2<i32>(4,5), vec2<i32>(6,7)\n);\n\nfn random(i: vec2<f32>) -> f32 {\n  return fract(sin(dot(i,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nfn Vec3Dot(a: vec3<f32>, b: vec3<f32>) -> f32\n{\n\treturn (a.x * b.x) + (a.y * b.y) + (a.z * b.z);\n}\n\nlet Grad3: array<vec3<f32>, 12> = array<vec3<f32>, 12>(\n\tvec3<f32>(1.0,1.0,0.0), vec3<f32>(-1.0,1.0,0.0), vec3<f32>(1.0,-1.0,0.0), vec3<f32>(-1.0,-1.0,0.0),\n\tvec3<f32>(1.0,0.0,1.0), vec3<f32>(-1.0,0.0,1.0), vec3<f32>(1.0,0.0,-1.0), vec3<f32>(-1.0,0.0,-1.0),\n\tvec3<f32>(0.0,1.0,1.0), vec3<f32>(0.0,-1.0,1.0), vec3<f32>(0.0,1.0,-1.0), vec3<f32>(0.0,-1.0,-1.0)\n);\n\nfn Perlin(x1: f32, y1: f32, z1: f32) -> f32\n{\n\tvar X: i32 = 0;\n\tif (x1 > 0.0) {\n\t\tX = i32(x1);\n\t} else {\n\t\tX = i32(x1) - 1;\n\t}\n\n\tvar Y: i32 = 0;\n\tif (y1 > 0.0) {\n\t\tY = i32(y1);\n\t} else {\n\t\tY = i32(y1) - 1;\n\t}\n\n\tvar Z: i32 = 0;\n\tif (z1 > 0.0) {\n\t\tZ = i32(z1);\n\t} else {\n\t\tZ = i32(z1) - 1;\n\t}\n\t\n\tlet x: f32 = x1 - f32(X);\n\tlet y: f32 = y1 - f32(Y);\n\tlet z: f32 = z1 - f32(Z);\n\t\n\tX = X & 255;\n\tY = Y & 255;\n\tZ = Z & 255;\n\t\n\tlet gi000: i32 = (perm.Perm[X + perm.Perm[Y + perm.Perm[Z] ] ] % 12);\n\tlet gi001: i32 = (perm.Perm[X + perm.Perm[Y + perm.Perm[Z + 1] ] ] % 12);\n\tlet gi010: i32 = (perm.Perm[X + perm.Perm[Y + 1 + perm.Perm[Z] ] ] % 12);\n\tlet gi011: i32 = (perm.Perm[X + perm.Perm[Y + 1 + perm.Perm[Z + 1] ] ] % 12);\n\tlet gi100: i32 = (perm.Perm[X + 1 + perm.Perm[Y + perm.Perm[Z] ] ] % 12);\n\tlet gi101: i32 = (perm.Perm[X + 1 + perm.Perm[Y + perm.Perm[Z + 1] ] ] % 12);\n\tlet gi110: i32 = (perm.Perm[X + 1 + perm.Perm[Y + 1 + perm.Perm[Z] ] ] % 12);\n\tlet gi111: i32 = (perm.Perm[X + 1 + perm.Perm[Y + 1 + perm.Perm[Z + 1] ] ] % 12);\n\n\tlet n000: f32 = dot(Grad3[gi000], vec3<f32>(x, y, z));\n\tlet n100: f32 = dot(Grad3[gi100], vec3<f32>(x - 1.0, y, z));\n\tlet n010: f32 = dot(Grad3[gi010], vec3<f32>(x, y - 1.0, z));\n\tlet n110: f32 = dot(Grad3[gi110], vec3<f32>(x - 1.0, y - 1.0, z));\n\tlet n001: f32 = dot(Grad3[gi001], vec3<f32>(x, y, z - 1.0));\n\tlet n101: f32 = dot(Grad3[gi101], vec3<f32>(x - 1.0, y, z - 1.0));\n\tlet n011: f32 = dot(Grad3[gi011], vec3<f32>(x, y - 1.0, z - 1.0));\n\tlet n111: f32 = dot(Grad3[gi111], vec3<f32>(x - 1.0, y - 1.0, z - 1.0));\n\t\n\tlet u: f32 = f32(x * x * x * (x * (x * 6.0 - 15.0) + 10.0));\n\tlet v: f32 = f32(y * y * y * (y * (y * 6.0 - 15.0) + 10.0));\n\tlet w: f32 = f32(z * z * z * (z * (z * 6.0 - 15.0) + 10.0));\n\tlet nx00: f32 = mix(n000, n100, u);\n\tlet nx01: f32 = mix(n001, n101, u);\n\tlet nx10: f32 = mix(n010, n110, u);\n\tlet nx11: f32 = mix(n011, n111, u);\n\tlet nxy0: f32 = mix(nx00, nx10, v);\n\tlet nxy1: f32 = mix(nx01, nx11, v);\n\tlet nxyz: f32 = mix(nxy0, nxy1, w);\n\t\n\treturn nxyz;\n}\n\nfn FractalNoise(octaves: i32, frequency: f32, lacunarity: f32, persistence: f32, position: vec3<f32>) -> f32\n{\n\tlet SCALE: f32 = 1.0 / 128.0;\n\tvar p: vec3<f32> = position * SCALE;\n\tvar nois: f32 = 0.0;\n\n\tvar amplitude: f32 = 1.0;\n\tp = p * frequency;\n\n\tvar i: i32 = 0;\n\tloop {\n\t\tif (i >= octaves) { break; }\n\n\t\tnois = nois + Perlin(p.x, p.y, p.z) * amplitude;\n\t\tp = p * lacunarity;\n\t\tamplitude = amplitude * persistence;\n\n\t\tcontinuing {\n\t\t\ti = i + 1;\n\t\t}\n\t}\n\t\n\treturn nois;\n}\n\nfn FractalNoise1(frequency: f32, lacunarity: f32, persistence: f32, position: vec3<f32>) -> f32\n{\n\tlet SCALE: f32 = 1.0 / 128.0;\n\tvar p: vec3<f32> = position * SCALE;\n\tvar nois: f32 = 0.0;\n\n\tvar amplitude: f32 = 1.0;\n\tp = p * frequency;\n\t\n\tnois = nois + Perlin(p.x, p.y, p.z) * amplitude;\n\tp = p * lacunarity;\n\tamplitude = amplitude * persistence;\n\t\n\treturn nois;\n}\n\nfn CalculateNoiseValue(pos: vec3<f32>, scale: f32) -> f32\n{\n\treturn FractalNoise(4, 0.5343, 2.2324, 0.68324, pos * scale);\n}\n\nfn CLerp(a: f32, b: f32, t: f32) -> f32\n{\n\treturn (1.0 - t) * a + t * b;\n}\n\n// SVD\n\nlet SVD_NUM_SWEEPS: i32 = 4;\nlet PSUEDO_INVERSE_THRESHOLD: f32 = 0.00000001;\n\nfn svd_mul_matrix_vec(m: mat3x3<f32>, b: vec4<f32>) -> vec4<f32>\n{\n\tvar a: mat3x3<f32> = m;\n\t\n\treturn vec4<f32>(\n\t\tdot(vec4<f32>(a[0][0], a[0][1], a[0][2], 0.0), b),\n\t\tdot(vec4<f32>(a[1][0], a[1][1], a[1][2], 0.0), b),\n\t\tdot(vec4<f32>(a[2][0], a[2][1], a[2][2], 0.0), b),\n\t\t0.0\n\t);\n}\n\nfn givens_coeffs_sym(a_pp: f32, a_pq: f32, a_qq: f32) -> vec2<f32>\n{\n\tif (a_pq == 0.0) {\n\t\treturn vec2<f32>(1.0, 0.0);\n\t}\n\t\n\tlet tau: f32 = (a_qq - a_pp) / (2.0 * a_pq);\n\tlet stt: f32 = sqrt(1.0 + tau * tau);\n\tvar tan: f32;\n\tif ((tau >= 0.0)) {\n\t\ttan = (tau + stt);\n\t} else {\n\t\ttan = (tau - stt);\n\t}\n\ttan = 1.0 / tan;\n\n\tlet c: f32 = inverseSqrt(1.0 + tan * tan);\n\tlet s: f32 = tan * c;\n\n\treturn vec2<f32>(c, s);\n}\n\nfn svd_rotate_xy(x: f32, y: f32, c: f32, s: f32) -> vec2<f32>\n{\n\treturn vec2<f32>(c * x - s * y, s * x + c * y);\n}\n\nfn svd_rotateq_xy(x: f32, y: f32, z: f32, c: f32, s: f32) -> vec2<f32>\n{\n\tlet cc: f32 = c * c;\n\tlet ss: f32 = s * s;\n\tlet mx: f32 = 2.0 * c * s * z;\n\n\treturn vec2<f32>(\n\t\tcc * x - mx + ss * y,\n\t\tss * x + mx + cc * z\n\t);\n}\n\nvar<private> vtav: mat3x3<f32>;\nvar<private> v: mat3x3<f32>;\nvar<private> ATA: array<f32, 6>;\nvar<private> Atb: vec4<f32>;\nvar<private> pointaccum: vec4<f32>;\nvar<private> btb: f32;\n\nfn svd_rotate(a: i32, b: i32)\n{\n\tif (vtav[a][b] == 0.0) { return; }\n\n\n\t\n\tlet coeffs: vec2<f32> = givens_coeffs_sym(vtav[a][a], vtav[a][b], vtav[b][b]);\n\tlet c: f32 = coeffs.x;\n\tlet s: f32 = coeffs.y;\n\t\n\tlet rot1: vec2<f32> = svd_rotateq_xy(vtav[a][a], vtav[b][b], vtav[a][b], c, s);\n\tvtav[a][a] = rot1.x;\n\tvtav[b][b] = rot1.y;\n\t\n\tlet rot2: vec2<f32> = svd_rotate_xy(vtav[0][3-b], vtav[1-a][2], c, s);\n\tvtav[0][3-b] = rot2.x; \n\tvtav[1-a][2] = rot2.y;\n\t\n\tvtav[a][b] = 0.0;\n\t\n\tlet rot3: vec2<f32> = svd_rotate_xy(v[0][a], v[0][b], c, s);\n\tv[0][a] = rot3.x; v[0][b] = rot3.y;\n\t\n\tlet rot4: vec2<f32> = svd_rotate_xy(v[1][a], v[1][b], c, s);\n\tv[1][a] = rot4.x; v[1][b] = rot4.y;\n\t\n\tlet rot5: vec2<f32> = svd_rotate_xy(v[2][a], v[2][b], c, s);\n\tv[2][a] = rot5.x; v[2][b] = rot5.y;\n}\n\nfn svd_solve_sym(b: array<f32, 6>) -> vec4<f32>\n{\n\tvar a: array<f32, 6> = b;\n\t\n\tvtav = mat3x3<f32>( \n\t\tvec3<f32>(a[0], a[1], a[2]), \n\t\tvec3<f32>(0.0, a[3], a[4]), \n\t\tvec3<f32>(0.0, 0.0, a[5])\n\t);\n\n\tvar i: i32;\n\tloop {\n\t\tif (i >= SVD_NUM_SWEEPS) { break; }\n\n\t\tsvd_rotate(0, 1);\n\t\tsvd_rotate(0, 2);\n\t\tsvd_rotate(1, 2);\n\n\t\tcontinuing {\n\t\t\ti = i + 1;\n\t\t}\n\t}\n\n\tvar copy: mat3x3<f32> = vtav;\n\treturn vec4<f32>(copy[0][0], copy[1][1], copy[2][2], 0.0);\n}\n\n\nfn svd_invdet(x: f32, tol: f32) -> f32\n{\n\tif (abs(x) < tol || abs(1.0 / x) < tol) {\n\t\treturn 0.0;\n\t}\n\treturn (1.0 / x);\n}\n\nfn svd_pseudoinverse(sigma: vec4<f32>, c: mat3x3<f32>) -> mat3x3<f32>\n{\n\tlet d0: f32 = svd_invdet(sigma.x, PSUEDO_INVERSE_THRESHOLD);\n\tlet d1: f32 = svd_invdet(sigma.y, PSUEDO_INVERSE_THRESHOLD);\n\tlet d2: f32 = svd_invdet(sigma.z, PSUEDO_INVERSE_THRESHOLD);\n\n\tvar copy: mat3x3<f32> = c;\n\n\treturn mat3x3<f32> (\n\t\tvec3<f32>(\n\t\t\tcopy[0][0] * d0 * copy[0][0] + copy[0][1] * d1 * copy[0][1] + copy[0][2] * d2 * copy[0][2],\n\t\t\tcopy[0][0] * d0 * copy[1][0] + copy[0][1] * d1 * copy[1][1] + copy[0][2] * d2 * copy[1][2],\n\t\t\tcopy[0][0] * d0 * copy[2][0] + copy[0][1] * d1 * copy[2][1] + copy[0][2] * d2 * copy[2][2]\n\t\t),\n\t\tvec3<f32>(\n\t\t\tcopy[1][0] * d0 * copy[0][0] + copy[1][1] * d1 * copy[0][1] + copy[1][2] * d2 * copy[0][2],\n\t\t\tcopy[1][0] * d0 * copy[1][0] + copy[1][1] * d1 * copy[1][1] + copy[1][2] * d2 * copy[1][2],\n\t\t\tcopy[1][0] * d0 * copy[2][0] + copy[1][1] * d1 * copy[2][1] + copy[1][2] * d2 * copy[2][2]\n\t\t),\n\t\tvec3<f32>(\n\t\t\tcopy[2][0] * d0 * copy[0][0] + copy[2][1] * d1 * copy[0][1] + copy[2][2] * d2 * copy[0][2],\n\t\t\tcopy[2][0] * d0 * copy[1][0] + copy[2][1] * d1 * copy[1][1] + copy[2][2] * d2 * copy[1][2],\n\t\t\tcopy[2][0] * d0 * copy[2][0] + copy[2][1] * d1 * copy[2][1] + copy[2][2] * d2 * copy[2][2]\n\t\t),\n\t);\n}\n\nfn svd_solve_ATA_Atb(a: vec4<f32>) -> vec4<f32>\n{\n\tv = mat3x3<f32>(vec3<f32>(1.0, 0.0, 0.0), vec3<f32>(0.0, 1.0, 0.0), vec3<f32>(0.0, 0.0, 1.0));\n\t\n\tlet sigma: vec4<f32> = svd_solve_sym(ATA);\n\t\n\tlet Vinv: mat3x3<f32> = svd_pseudoinverse(sigma, v);\n\treturn svd_mul_matrix_vec(Vinv, a);\n}\n\nfn svd_vmul_sym(v: vec4<f32>) -> vec4<f32>\n{\n\tlet A_row_x: vec4<f32> = vec4<f32>(ATA[0], ATA[1], ATA[2], 0.0);\n\treturn vec4<f32> (\n\t\tdot(A_row_x, v),\n\t\tATA[1] * v.x + ATA[3] * v.y + ATA[4] * v.z,\n\t\tATA[2] * v.x + ATA[4] * v.y + ATA[5] * v.z,\n\t\t0.0\n\t);\n}\n\n\n// // QEF\n\nfn qef_add(n: vec4<f32>, p: vec4<f32>)\n{\n\tATA[0] = ATA[0] + n.x * n.x;\n\tATA[1] = ATA[1] + n.x * n.y;\n\tATA[2] = ATA[2] + n.x * n.z;\n\tATA[3] = ATA[3] + n.y * n.y;\n\tATA[4] = ATA[4] + n.y * n.z;\n\tATA[5] = ATA[5] + n.z * n.z;\n\t\n\tlet b: f32 = dot(p, n);\n\tAtb.x = Atb.x +n.x * b;\n\tAtb.y = Atb.y +n.y * b;\n\tAtb.z = Atb.z +n.z * b;\n\tbtb = btb + b * b;\n\t\n\tpointaccum.x = pointaccum.x +p.x;\n\tpointaccum.y = pointaccum.y +p.y;\n\tpointaccum.z = pointaccum.z +p.z;\n\tpointaccum.w = pointaccum.w +1.0;\n}\n\nfn qef_calc_error(x: vec4<f32>) -> f32\n{\n\tvar tmp: vec4<f32> = svd_vmul_sym(x);\n\ttmp = Atb - tmp;\n\t\n\treturn dot(tmp, tmp);\n}\n\nfn qef_solve() -> vec4<f32>\n{\n\tlet masspoint: vec4<f32> = vec4<f32>(pointaccum.x / pointaccum.w, pointaccum.y / pointaccum.w, pointaccum.z / pointaccum.w, pointaccum.w / pointaccum.w);\n\t\n\tvar A_mp: vec4<f32> = svd_vmul_sym(masspoint);\n\tA_mp = Atb - A_mp;\n\t\n\tlet x: vec4<f32> = svd_solve_ATA_Atb(A_mp);\n\t\n\tlet error: f32 = qef_calc_error(x);\n\tlet r: vec4<f32> = x + masspoint;\n\t\n\treturn vec4<f32>(r.x, r.y, r.z, error);\n}\n\n#import density\n\nfn ApproximateZeroCrossingPosition(p0: vec3<f32>, p1: vec3<f32>) -> vec3<f32>\n{\n\tvar minValue: f32 = 100000.0;\n\tvar t: f32 = 0.0;\n\tvar currentT: f32 = 0.0;\n\tlet steps: f32 = 8.0;\n\tlet increment: f32 = 1.0 / steps;\n\tloop {\n\t\tif (currentT > 1.0) { break; }\n\n\t\tlet p: vec3<f32> = p0 + ((p1 - p0) * currentT);\n\t\tlet density: f32 = abs(getDensity(p));\n\t\tif (density < minValue)\n\t\t{\n\t\t\tminValue = density;\n\t\t\tt = currentT;\n\t\t}\n\n\t\tcontinuing {\n\t\t\tcurrentT = currentT + increment;\n\t\t}\n\t}\n\n\treturn p0 + ((p1 - p0) * t);\n}\n\nfn CalculateSurfaceNormal(p: vec3<f32>) -> vec3<f32>\n{\n\tlet H: f32 = uniforms.stride; // This needs to scale based on something...\n\tlet dx: f32 = getDensity(p + vec3<f32>(H, 0.0, 0.0)) - getDensity(p - vec3<f32>(H, 0.0, 0.0));\n\tlet dy: f32 = getDensity(p + vec3<f32>(0.0, H, 0.0)) - getDensity(p - vec3<f32>(0.0, H, 0.0));\n\tlet dz: f32 = getDensity(p + vec3<f32>(0.0, 0.0, H)) - getDensity(p - vec3<f32>(0.0, 0.0, H));\n\n\treturn normalize(vec3<f32>(dx, dy, dz));\n}\n\n@compute @workgroup_size(128)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n\tlet trueIndex: u32 = GlobalInvocationID.x;\n\n\tif (trueIndex < cornerIndex.cornerCount)\n\t{\n\t\tlet ures: u32 = 32u;\n\n\t\tlet nodeSize: u32 = u32(uniforms.stride);\n\n\t\tlet voxelIndex: u32 = cornerIndex.cornerIndexes[trueIndex];\n\t\tlet z: u32 = voxelIndex / (ures * ures);\n\t\tlet y: u32 = (voxelIndex - (z * ures * ures)) / ures;\n\t\tlet x: u32 = voxelIndex - (z * ures * ures) - (y * ures);\n\n\t\tlet corners: u32 = voxelMaterials.voxelMaterials[voxelIndex];\n\n\t\tlet nodePos: vec3<f32> = (vec3<f32>(f32(x), f32(y), f32 (z)) * uniforms.stride) + uniforms.chunkPosition;\n\t\tvoxels.voxels[trueIndex].voxMin = nodePos;\n\t\tlet MAX_CROSSINGS: i32 = 6;\n\t\tvar edgeCount: i32 = 0;\n\n\t\tpointaccum = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n\t\tATA = array<f32, 6>(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\n\t\tAtb = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n\t\tvar averageNormal: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);\n\t\tbtb = 0.0;\n\n\t\tvar j: i32 = 0;\n\t\tloop {\n\t\t\tif (!(j < 12 && edgeCount <= MAX_CROSSINGS)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlet c1: i32 = edgevmap[j].x;\n\t\t\tlet c2: i32 = edgevmap[j].y;\n\n\t\t\tlet m1: u32 = (corners >> u32(c1)) & 1u;\n\t\t\tlet m2: u32 = (corners >> u32(c2)) & 1u;\n\n\t\t\tif (!((m1 == 0u && m2 == 0u) || (m1 == 1u && m2 == 1u)))\n\t\t\t{\n\t\t\t\tlet p1: vec3<f32> = nodePos + vec3<f32>(f32(CHILD_MIN_OFFSETS[c1].x * nodeSize), f32(CHILD_MIN_OFFSETS[c1].y * nodeSize), f32(CHILD_MIN_OFFSETS[c1].z * nodeSize));\n\t\t\t\tlet p2: vec3<f32> = nodePos + vec3<f32>(f32(CHILD_MIN_OFFSETS[c2].x * nodeSize), f32(CHILD_MIN_OFFSETS[c2].y * nodeSize), f32(CHILD_MIN_OFFSETS[c2].z * nodeSize));\n\t\t\t\tlet p: vec3<f32> = ApproximateZeroCrossingPosition(p1, p2);\n\t\t\t\tlet n: vec3<f32> = CalculateSurfaceNormal(p);\n\n\t\t\t\tqef_add(vec4<f32>(n.x, n.y, n.z, 0.0), vec4<f32>(p.x, p.y, p.z, 0.0));\n\n\t\t\t\taverageNormal = averageNormal + n;\n\n\t\t\t\tedgeCount = edgeCount + 1;\n\t\t\t}\n\n\t\t\tcontinuing {\n\t\t\t\tj = j + 1;\n\t\t\t}\n\t\t}\n\n\n\t\taverageNormal = normalize(averageNormal / vec3<f32>(f32(edgeCount), f32(edgeCount), f32(edgeCount)));\n\n\t\tlet com: vec3<f32> = vec3<f32>(pointaccum.x / pointaccum.w, pointaccum.y / pointaccum.w, pointaccum.z / pointaccum.w);\n\n\t\tlet result: vec4<f32> = qef_solve();\n\t\tvar solved_position: vec3<f32> = result.xyz;\n\t\tlet error: f32 = result.w;\n\n\n\t\tlet Min: vec3<f32> = nodePos;\n\t\tlet Max: vec3<f32> = nodePos + vec3<f32>(1.0, 1.0, 1.0);\n\t\tif (solved_position.x < Min.x || solved_position.x > Max.x ||\n\t\t\t\tsolved_position.y < Min.y || solved_position.y > Max.y ||\n\t\t\t\tsolved_position.z < Min.z || solved_position.z > Max.z)\n\t\t{\n\t\t\tsolved_position = com;\n\t\t}\n\n\t\tvoxels.voxels[trueIndex].vertPoint = solved_position;\n\t\tvoxels.voxels[trueIndex].avgNormal = averageNormal;\n\t\tvoxels.voxels[trueIndex].numPoints = f32(edgeCount);\n\t\tvoxels.voxels[trueIndex].corners = f32(voxelMaterials.voxelMaterials[voxelIndex]);\n\t}\n}\n\n@compute @workgroup_size(1)\nfn computeMaterials(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n\t\tlet width = uniforms.width;\n    let index: u32 = GlobalInvocationID.z * width * width + GlobalInvocationID.y * width + GlobalInvocationID.x;\n    let cornerPos: vec3<f32> = vec3<f32>(f32(GlobalInvocationID.x) * uniforms.stride, f32(GlobalInvocationID.y) * uniforms.stride, f32(GlobalInvocationID.z) * uniforms.stride);\n\n    let density: f32 = getDensity(cornerPos + uniforms.chunkPosition);\n\n\t\tif (density < 0.0) {\n\t\t\tif (length(cornerPos + uniforms.chunkPosition) < 2000.0) {\n        //cornerMaterials.cornerMaterials[index] = u32(random(vec2(f32(index))) * 255.0) + 1;\n\t\t\t  cornerMaterials.cornerMaterials[index] = 256u;\n\t\t\t} else {\n        cornerMaterials.cornerMaterials[index] = u32(length(cornerPos) / uniforms.stride * 256.0);\n\t\t\t}\n\t\t} else {\n\t\t\tcornerMaterials.cornerMaterials[index] = 0u;\n\t\t}\n}\n\n@compute @workgroup_size(1)\nfn computePhysics(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n  let actor: u32 = GlobalInvocationID.x;\n\n  if (getDensity(physics.actors[actor].position) < 0.0) {\n    physics.actors[actor].position = physics.actors[actor].position + vec3<f32>(10.0, 0.0, 0.0);\n  }\n\n  let direction = normalize(physics.actors[actor].velocity);\n  let pos = physics.actors[actor].position + physics.actors[actor].velocity;\n\n  if (getDensity(pos + (direction * 50.0)) >= 0.0) {\n    physics.actors[actor].position = pos;\n  }\n}");

/***/ }),

/***/ "./node_modules/seedrandom/index.js":
/*!******************************************!*\
  !*** ./node_modules/seedrandom/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

// alea, a 53-bit multiply-with-carry generator by Johannes Baagøe.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea = __webpack_require__(/*! ./lib/alea */ "./node_modules/seedrandom/lib/alea.js");

// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128 = __webpack_require__(/*! ./lib/xor128 */ "./node_modules/seedrandom/lib/xor128.js");

// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow = __webpack_require__(/*! ./lib/xorwow */ "./node_modules/seedrandom/lib/xorwow.js");

// xorshift7, by François Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7 = __webpack_require__(/*! ./lib/xorshift7 */ "./node_modules/seedrandom/lib/xorshift7.js");

// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096 = __webpack_require__(/*! ./lib/xor4096 */ "./node_modules/seedrandom/lib/xor4096.js");

// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei = __webpack_require__(/*! ./lib/tychei */ "./node_modules/seedrandom/lib/tychei.js");

// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr = __webpack_require__(/*! ./seedrandom */ "./node_modules/seedrandom/seedrandom.js");

sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;

module.exports = sr;


/***/ }),

/***/ "./node_modules/seedrandom/lib/alea.js":
/*!*********************************************!*\
  !*** ./node_modules/seedrandom/lib/alea.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -

// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



(function(global, module, define) {

function Alea(seed) {
  var me = this, mash = Mash();

  me.next = function() {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) { me.s0 += 1; }
  me.s1 -= mash(seed);
  if (me.s1 < 0) { me.s1 += 1; }
  me.s2 -= mash(seed);
  if (me.s2 < 0) { me.s2 += 1; }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function impl(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; }
  prng.double = function() {
    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
  };
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function(data) {
    data = String(data);
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}


if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.alea = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ }),

/***/ "./node_modules/seedrandom/lib/tychei.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/lib/tychei.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var b = me.b, c = me.c, d = me.d, a = me.a;
    b = (b << 25) ^ (b >>> 7) ^ c;
    c = (c - d) | 0;
    d = (d << 24) ^ (d >>> 8) ^ a;
    a = (a - b) | 0;
    me.b = b = (b << 20) ^ (b >>> 12) ^ c;
    me.c = c = (c - d) | 0;
    me.d = (d << 16) ^ (c >>> 16) ^ a;
    return me.a = (a - b) | 0;
  };

  /* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */

  me.a = 0;
  me.b = 0;
  me.c = 2654435769 | 0;
  me.d = 1367130551;

  if (seed === Math.floor(seed)) {
    // Integer seed.
    me.a = (seed / 0x100000000) | 0;
    me.b = seed | 0;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 20; k++) {
    me.b ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.a = f.a;
  t.b = f.b;
  t.c = f.c;
  t.d = f.d;
  return t;
};

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.tychei = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ }),

/***/ "./node_modules/seedrandom/lib/xor128.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/lib/xor128.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;

  // Set up generator function.
  me.next = function() {
    var t = me.x ^ (me.x << 11);
    me.x = me.y;
    me.y = me.z;
    me.z = me.w;
    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
  };

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xor128 = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ }),

/***/ "./node_modules/seedrandom/lib/xor4096.js":
/*!************************************************!*\
  !*** ./node_modules/seedrandom/lib/xor4096.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1004.3115v1.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    var w = me.w,
        X = me.X, i = me.i, t, v;
    // Update Weyl generator.
    me.w = w = (w + 0x61c88647) | 0;
    // Update xor generator.
    v = X[(i + 34) & 127];
    t = X[i = ((i + 1) & 127)];
    v ^= v << 13;
    t ^= t << 17;
    v ^= v >>> 15;
    t ^= t >>> 12;
    // Update Xor generator array state.
    v = X[i] = v ^ t;
    me.i = i;
    // Result is the combination.
    return (v + (w ^ (w >>> 16))) | 0;
  };

  function init(me, seed) {
    var t, v, i, j, w, X = [], limit = 128;
    if (seed === (seed | 0)) {
      // Numeric seeds initialize v, which is used to generates X.
      v = seed;
      seed = null;
    } else {
      // String seeds are mixed into v and X one character at a time.
      seed = seed + '\0';
      v = 0;
      limit = Math.max(limit, seed.length);
    }
    // Initialize circular array and weyl value.
    for (i = 0, j = -32; j < limit; ++j) {
      // Put the unicode characters into the array, and shuffle them.
      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
      // After 32 shuffles, take v as the starting w value.
      if (j === 0) w = v;
      v ^= v << 10;
      v ^= v >>> 15;
      v ^= v << 4;
      v ^= v >>> 13;
      if (j >= 0) {
        w = (w + 0x61c88647) | 0;     // Weyl.
        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
        i = (0 == t) ? i + 1 : 0;     // Count zeroes.
      }
    }
    // We have detected all zeroes; make the key nonzero.
    if (i >= 128) {
      X[(seed && seed.length || 0) & 127] = -1;
    }
    // Run the generator 512 times to further mix the state before using it.
    // Factoring this as a function slows the main generator, so it is just
    // unrolled here.  The weyl generator is not advanced while warming up.
    i = 127;
    for (j = 4 * 128; j > 0; --j) {
      v = X[(i + 34) & 127];
      t = X[i = ((i + 1) & 127)];
      v ^= v << 13;
      t ^= t << 17;
      v ^= v >>> 15;
      t ^= t >>> 12;
      X[i] = v ^ t;
    }
    // Storing state as object members is faster than using closure variables.
    me.w = w;
    me.X = X;
    me.i = i;
  }

  init(me, seed);
}

function copy(f, t) {
  t.i = f.i;
  t.w = f.w;
  t.X = f.X.slice();
  return t;
};

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.X) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xor4096 = impl;
}

})(
  this,                                     // window object or global
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);


/***/ }),

/***/ "./node_modules/seedrandom/lib/xorshift7.js":
/*!**************************************************!*\
  !*** ./node_modules/seedrandom/lib/xorshift7.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xorshift7" algorithm by
// François Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    // Update xor generator.
    var X = me.x, i = me.i, t, v, w;
    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
    X[i] = v;
    me.i = (i + 1) & 7;
    return v;
  };

  function init(me, seed) {
    var j, w, X = [];

    if (seed === (seed | 0)) {
      // Seed state array using a 32-bit integer.
      w = X[0] = seed;
    } else {
      // Seed state using a string.
      seed = '' + seed;
      for (j = 0; j < seed.length; ++j) {
        X[j & 7] = (X[j & 7] << 15) ^
            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
      }
    }
    // Enforce an array length of 8, not all zeroes.
    while (X.length < 8) X.push(0);
    for (j = 0; j < 8 && X[j] === 0; ++j);
    if (j == 8) w = X[7] = -1; else w = X[j];

    me.x = X;
    me.i = 0;

    // Discard an initial 256 values.
    for (j = 256; j > 0; --j) {
      me.next();
    }
  }

  init(me, seed);
}

function copy(f, t) {
  t.x = f.x.slice();
  t.i = f.i;
  return t;
}

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.x) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xorshift7 = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);



/***/ }),

/***/ "./node_modules/seedrandom/lib/xorwow.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/lib/xorwow.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var t = (me.x ^ (me.x >>> 2));
    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
    return (me.d = (me.d + 362437 | 0)) +
       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
  };

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;
  me.v = 0;

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    if (k == strseed.length) {
      me.d = me.x << 10 ^ me.x >>> 4;
    }
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  t.v = f.v;
  t.d = f.d;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xorwow = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ }),

/***/ "./node_modules/seedrandom/seedrandom.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/seedrandom.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
Copyright 2019 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function (global, pool, math) {
//
// The following constants are related to IEEE 754 limits.
//

var width = 256,        // each RC4 output is 0 <= x < 256
    chunks = 6,         // at least six RC4 outputs for each double
    digits = 52,        // there are 52 significant digits in a double
    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
    startdenom = math.pow(width, chunks),
    significance = math.pow(2, digits),
    overflow = significance * 2,
    mask = width - 1,
    nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed, options, callback) {
  var key = [];
  options = (options == true) ? { entropy: true } : (options || {});

  // Flatten the seed string or build one from local entropy if needed.
  var shortseed = mixkey(flatten(
    options.entropy ? [seed, tostring(pool)] :
    (seed == null) ? autoseed() : seed, 3), key);

  // Use the seed to initialize an ARC4 generator.
  var arc4 = new ARC4(key);

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.
  var prng = function() {
    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
        d = startdenom,                 //   and denominator d = 2 ^ 48.
        x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  prng.int32 = function() { return arc4.g(4) | 0; }
  prng.quick = function() { return arc4.g(4) / 0x100000000; }
  prng.double = prng;

  // Mix the randomness into accumulated entropy.
  mixkey(tostring(arc4.S), pool);

  // Calling convention: what to return as a function of prng, seed, is_math.
  return (options.pass || callback ||
      function(prng, seed, is_math_call, state) {
        if (state) {
          // Load the arc4 state from the given state if it has an S array.
          if (state.S) { copy(state, arc4); }
          // Only provide the .state method if requested via options.state.
          prng.state = function() { return copy(arc4, {}); }
        }

        // If called as a method of Math (Math.seedrandom()), mutate
        // Math.random because that is how seedrandom.js has worked since v1.0.
        if (is_math_call) { math[rngname] = prng; return seed; }

        // Otherwise, it is a newer calling convention, so return the
        // prng directly.
        else return prng;
      })(
  prng,
  shortseed,
  'global' in options ? options.global : (this == math),
  options.state);
}

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key) {
  var t, keylen = key.length,
      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) {
    s[i] = i++;
  }
  for (i = 0; i < width; i++) {
    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
    s[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  (me.g = function(count) {
    // Using instance members instead of closure state nearly doubles speed.
    var t, r = 0,
        i = me.i, j = me.j, s = me.S;
    while (count--) {
      t = s[i = mask & (i + 1)];
      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
    }
    me.i = i; me.j = j;
    return r;
    // For robust unpredictability, the function call below automatically
    // discards an initial batch of values.  This is called RC4-drop[256].
    // See http://google.com/search?q=rsa+fluhrer+response&btnI
  })(width);
}

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f, t) {
  t.i = f.i;
  t.j = f.j;
  t.S = f.S.slice();
  return t;
};

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
  var result = [], typ = (typeof obj), prop;
  if (depth && typ == 'object') {
    for (prop in obj) {
      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
    }
  }
  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
  var stringseed = seed + '', smear, j = 0;
  while (j < stringseed.length) {
    key[mask & j] =
      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
  }
  return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed() {
  try {
    var out;
    if (nodecrypto && (out = nodecrypto.randomBytes)) {
      // The use of 'out' to remember randomBytes makes tight minified code.
      out = out(width);
    } else {
      out = new Uint8Array(width);
      (global.crypto || global.msCrypto).getRandomValues(out);
    }
    return tostring(out);
  } catch (e) {
    var browser = global.navigator,
        plugins = browser && browser.plugins;
    return [+new Date, global, plugins, global.screen, tostring(pool)];
  }
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
  return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if ( true && module.exports) {
  module.exports = seedrandom;
  // When in node.js, try using crypto package for autoseeding.
  try {
    nodecrypto = __webpack_require__(/*! crypto */ "?8465");
  } catch (ex) {}
} else if (true) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return seedrandom; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}


// End anonymous scope, and pass initial values.
})(
  // global: `self` in browsers (including strict mode and web workers),
  // otherwise `this` in Node and other environments
  (typeof self !== 'undefined') ? self : this,
  [],     // pool: entropy pool starts empty
  Math    // math: package containing random, pow, and seedrandom
);


/***/ }),

/***/ "./node_modules/jasmine-core/lib/jasmine-core/jasmine.css":
/*!****************************************************************!*\
  !*** ./node_modules/jasmine-core/lib/jasmine-core/jasmine.css ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _css_loader_dist_cjs_js_jasmine_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../css-loader/dist/cjs.js!./jasmine.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/jasmine-core/lib/jasmine-core/jasmine.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_jasmine_css__WEBPACK_IMPORTED_MODULE_6__.default, options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_jasmine_css__WEBPACK_IMPORTED_MODULE_6__.default && _css_loader_dist_cjs_js_jasmine_css__WEBPACK_IMPORTED_MODULE_6__.default.locals ? _css_loader_dist_cjs_js_jasmine_css__WEBPACK_IMPORTED_MODULE_6__.default.locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";


var stylesInDOM = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };

    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);

  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }

      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };

  return updater;
}

module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();

        stylesInDOM.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


var memo = {};
/* istanbul ignore next  */

function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }

    memo[target] = styleTarget;
  }

  return memo[target];
}
/* istanbul ignore next  */


function insertBySelector(insert, style) {
  var target = getTarget(insert);

  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }

  target.appendChild(style);
}

module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}

module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;

  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}

module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";

  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }

  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }

  var needLayer = typeof obj.layer !== "undefined";

  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }

  css += obj.css;

  if (needLayer) {
    css += "}";
  }

  if (obj.media) {
    css += "}";
  }

  if (obj.supports) {
    css += "}";
  }

  var sourceMap = obj.sourceMap;

  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  options.styleTagTransform(css, styleElement, options.options);
}

function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }

  styleElement.parentNode.removeChild(styleElement);
}
/* istanbul ignore next  */


function domAPI(options) {
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}

module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }

    styleElement.appendChild(document.createTextNode(css));
  }
}

module.exports = styleTagTransform;

/***/ }),

/***/ "./src/compute-voxels.test.ts":
/*!************************************!*\
  !*** ./src/compute-voxels.test.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _raw_loader_compute_voxels_wgsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !!raw-loader!./compute-voxels.wgsl */ "./node_modules/raw-loader/dist/cjs.js!./src/compute-voxels.wgsl");
/* harmony import */ var seedrandom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! seedrandom */ "./node_modules/seedrandom/index.js");
/* harmony import */ var seedrandom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(seedrandom__WEBPACK_IMPORTED_MODULE_1__);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};


describe('compute-voxels', function () {
    describe('computeMaterials', function () {
        var materials;
        beforeAll(function () { return __awaiter(void 0, void 0, void 0, function () {
            var adapter, device, density, computeVoxels, computePipeline, permutations, random, i, i, permutationsBuffer, cornerMaterials, cornerMaterialsRead, uniformBufferSize, uniformBuffer, computeBindGroup, computeEncoder, computePassEncoder, copyEncoder, buffer, uniform, queue, arrayBuffer;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, navigator.gpu.requestAdapter()];
                    case 1:
                        adapter = _a.sent();
                        return [4 /*yield*/, adapter.requestDevice()];
                    case 2:
                        device = _a.sent();
                        density = "fn getDensity(worldPosition: vec3<f32>) -> f32 { \n        if (worldPosition.y < 3.0) {\n          return -1.0;\n        } else {\n          return 1.0;\n        }\n       }";
                        computeVoxels = _raw_loader_compute_voxels_wgsl__WEBPACK_IMPORTED_MODULE_0__.default.replace("#import density", density);
                        return [4 /*yield*/, device.createComputePipelineAsync({
                                layout: 'auto',
                                compute: {
                                    module: device.createShaderModule({
                                        code: computeVoxels,
                                    }),
                                    entryPoint: 'computeMaterials',
                                },
                            })];
                    case 3:
                        computePipeline = _a.sent();
                        permutations = new Int32Array(512);
                        random = new (seedrandom__WEBPACK_IMPORTED_MODULE_1___default())(6452);
                        for (i = 0; i < 256; i++)
                            permutations[i] = (256 * (random()));
                        for (i = 256; i < 512; i++)
                            permutations[i] = permutations[i - 256];
                        permutationsBuffer = device.createBuffer({
                            size: permutations.byteLength,
                            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                            mappedAtCreation: true,
                        });
                        new Int32Array(permutationsBuffer.getMappedRange()).set(permutations);
                        permutationsBuffer.unmap();
                        cornerMaterials = device.createBuffer({
                            size: Uint32Array.BYTES_PER_ELEMENT * 5 * 5 * 5,
                            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
                            mappedAtCreation: false,
                        });
                        cornerMaterialsRead = device.createBuffer({
                            size: Uint32Array.BYTES_PER_ELEMENT * 5 * 5 * 5,
                            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
                        });
                        uniformBufferSize = 4 * 5;
                        uniformBuffer = device.createBuffer({
                            size: uniformBufferSize,
                            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
                        });
                        computeBindGroup = device.createBindGroup({
                            layout: computePipeline.getBindGroupLayout(0),
                            entries: [
                                {
                                    binding: 1,
                                    resource: {
                                        buffer: cornerMaterials
                                    },
                                },
                                {
                                    binding: 5,
                                    resource: {
                                        buffer: uniformBuffer
                                    },
                                }
                            ]
                        });
                        computeEncoder = device.createCommandEncoder();
                        computePassEncoder = computeEncoder.beginComputePass();
                        computePassEncoder.setPipeline(computePipeline);
                        computePassEncoder.setBindGroup(0, computeBindGroup);
                        computePassEncoder.dispatchWorkgroups(5, 5, 5);
                        computePassEncoder.end();
                        copyEncoder = device.createCommandEncoder();
                        copyEncoder.copyBufferToBuffer(cornerMaterials, 0, cornerMaterialsRead, 0, Uint32Array.BYTES_PER_ELEMENT * 5 * 5 * 5);
                        buffer = new ArrayBuffer(4 * 5);
                        uniform = new Float32Array(buffer, 0, 4);
                        uniform[3] = 1;
                        new Uint32Array(buffer, 16, 1)[0] = 5;
                        device.queue.writeBuffer(uniformBuffer, 0, buffer, 0, buffer.byteLength);
                        queue = device.queue.onSubmittedWorkDone();
                        device.queue.submit([computeEncoder.finish(), copyEncoder.finish()]);
                        return [4 /*yield*/, queue];
                    case 4:
                        _a.sent();
                        return [4 /*yield*/, cornerMaterialsRead.mapAsync(GPUMapMode.READ)];
                    case 5:
                        _a.sent();
                        arrayBuffer = cornerMaterialsRead.getMappedRange();
                        materials = new Uint32Array(arrayBuffer).slice();
                        cornerMaterialsRead.unmap();
                        return [2 /*return*/];
                }
            });
        }); });
        it('then materials is not null', function () {
            var expectedResult = new Uint32Array(5 * 5 * 5);
            for (var x = 0; x < 5; x++)
                for (var y = 0; y < 5; y++)
                    for (var z = 0; z < 5; z++) {
                        expectedResult[z * 5 * 5 + y * 5 + x] = y < 3 ? 1 : 0;
                    }
            expect(materials).toEqual(expectedResult);
        });
    });
});


/***/ }),

/***/ "./src/renderer.test.ts":
/*!******************************!*\
  !*** ./src/renderer.test.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./renderer */ "./src/renderer.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};

describe('Renderer', function () {
    var canvas;
    beforeEach(function () {
        canvas = document.getElementById('canvas');
    });
    it('should not throw when initialized', function () { return __awaiter(void 0, void 0, void 0, function () {
        var renderer;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    renderer = new _renderer__WEBPACK_IMPORTED_MODULE_0__.default();
                    return [4 /*yield*/, expectAsync(renderer.init(canvas)).toBeResolved()];
                case 1:
                    _a.sent();
                    expect(function () { return renderer.configure(canvas.width, canvas.height); }).not.toThrow();
                    expect(function () { return renderer.render(function () { }); }).not.toThrow();
                    return [2 /*return*/];
            }
        });
    }); });
});


/***/ }),

/***/ "./src/renderer.ts":
/*!*************************!*\
  !*** ./src/renderer.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var Renderer = /** @class */ (function () {
    function Renderer() {
    }
    Renderer.prototype.init = function (canvas) {
        return __awaiter(this, void 0, void 0, function () {
            var adapter, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, navigator.gpu.requestAdapter()];
                    case 1:
                        adapter = _b.sent();
                        _a = this;
                        return [4 /*yield*/, adapter.requestDevice()];
                    case 2:
                        _a.device = _b.sent();
                        this.context = canvas.getContext('webgpu');
                        this.presentationFormat = navigator.gpu.getPreferredCanvasFormat();
                        return [2 /*return*/];
                }
            });
        });
    };
    Renderer.prototype.configure = function (width, height) {
        this.context.configure({
            device: this.device,
            format: this.presentationFormat,
            alphaMode: 'opaque'
        });
        this.depthTexture = this.device.createTexture({
            size: { width: width, height: height },
            format: 'depth24plus-stencil8',
            usage: GPUTextureUsage.RENDER_ATTACHMENT,
        });
    };
    Renderer.prototype.render = function (callback) {
        var commandEncoder = this.device.createCommandEncoder();
        var textureView = this.context.getCurrentTexture().createView();
        var renderPassDescriptor = {
            colorAttachments: [
                {
                    view: textureView,
                    clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },
                    loadOp: 'clear',
                    storeOp: 'store'
                }
            ],
            depthStencilAttachment: {
                view: this.depthTexture.createView(),
                depthClearValue: 1.0,
                depthLoadOp: 'clear',
                depthStoreOp: 'store',
                stencilClearValue: 0,
                stencilLoadOp: 'clear',
                stencilStoreOp: 'store',
            }
        };
        var passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
        callback(passEncoder);
        passEncoder.end();
        this.device.queue.submit([commandEncoder.finish()]);
    };
    return Renderer;
}());
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Renderer);


/***/ }),

/***/ "./src/tests.ts":
/*!**********************!*\
  !*** ./src/tests.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jasmine_core_lib_jasmine_core_jasmine_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jasmine-core/lib/jasmine-core/jasmine.css */ "./node_modules/jasmine-core/lib/jasmine-core/jasmine.css");
/* harmony import */ var jasmine_core_lib_jasmine_core_jasmine_html_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jasmine-core/lib/jasmine-core/jasmine-html.js */ "./node_modules/jasmine-core/lib/jasmine-core/jasmine-html.js");
/* harmony import */ var jasmine_core_lib_jasmine_core_jasmine_html_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jasmine_core_lib_jasmine_core_jasmine_html_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var jasmine_core_lib_jasmine_core_boot0_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jasmine-core/lib/jasmine-core/boot0.js */ "./node_modules/jasmine-core/lib/jasmine-core/boot0.js");
/* harmony import */ var jasmine_core_lib_jasmine_core_boot0_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jasmine_core_lib_jasmine_core_boot0_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var jasmine_core_lib_jasmine_core_boot1_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! jasmine-core/lib/jasmine-core/boot1.js */ "./node_modules/jasmine-core/lib/jasmine-core/boot1.js");
/* harmony import */ var jasmine_core_lib_jasmine_core_boot1_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(jasmine_core_lib_jasmine_core_boot1_js__WEBPACK_IMPORTED_MODULE_3__);




// @ts-ignore
var tests = __webpack_require__("./src sync recursive .test.(j|t)s$");
var testFiles = tests.keys();
for (var test in testFiles) {
    tests(testFiles[test]);
}


/***/ }),

/***/ "./src/world-generator.test.ts":
/*!*************************************!*\
  !*** ./src/world-generator.test.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _world_generator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./world-generator */ "./src/world-generator.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};

describe('World Generator', function () {
    var worldGenerator;
    beforeEach(function () {
        worldGenerator = new _world_generator__WEBPACK_IMPORTED_MODULE_0__.default(8);
    });
    describe('when init is called', function () {
        var info;
        beforeEach(function () {
            info = worldGenerator.init(3, 20, 43);
        });
        it('position is rounded to nearest stride', function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                expect(info.x).toEqual(0);
                expect(info.y).toEqual(24);
                expect(info.z).toEqual(40);
                return [2 /*return*/];
            });
        }); });
        it('current stride defaults to minimum stride', function () {
            expect(info.stride).toEqual(8);
        });
        it('previousOffset is correct', function () {
            expect(info.previousOffset).toEqual(-4);
        });
        it('layer is correct', function () {
            expect(info.layer).toEqual(1);
        });
    });
    describe('when next is called', function () {
        it('returns origin position', function () {
            var _a = __read(worldGenerator.next({
                x: 0, y: 0, z: 0, stride: 8, iteration: 0, layer: 1, previousOffset: -4
            }), 2), result = _a[0], info = _a[1];
            expect(result).toEqual({
                x: -4, y: -4, z: -4, stride: 8
            });
            expect(info).toEqual({
                x: 0, y: 0, z: 0, stride: 8, iteration: 1, layer: 1, previousOffset: -4
            });
        });
        it('returns origin position for iteration 1', function () {
            var _a = __read(worldGenerator.next({
                x: 0, y: 0, z: 0, stride: 8, iteration: 1, layer: 1, previousOffset: -4
            }), 2), result = _a[0], info = _a[1];
            expect(result).toEqual({
                x: -4, y: -4, z: 4, stride: 8
            });
            expect(info).toEqual({
                x: 0, y: 0, z: 0, stride: 8, iteration: 2, layer: 1, previousOffset: -4
            });
        });
        it('returns origin position for second layer', function () {
            var _a = __read(worldGenerator.next({
                x: 0, y: 0, z: 0, stride: 8, iteration: 0, layer: 2, previousOffset: -4
            }), 2), result = _a[0], info = _a[1];
            expect(result).toEqual({
                x: -12, y: -12, z: -12, stride: 8
            });
            expect(info).toEqual({
                x: 0, y: 0, z: 0, stride: 8, iteration: 1, layer: 2, previousOffset: -4
            });
        });
        it('returns origin position for second layer second iteration', function () {
            var _a = __read(worldGenerator.next({
                x: 0, y: 0, z: 0, stride: 8, iteration: 6, layer: 2, previousOffset: -4
            }), 2), result = _a[0], info = _a[1];
            expect(result).toEqual({
                x: -12, y: -4, z: 4, stride: 8
            });
            expect(info).toEqual({
                x: 0, y: 0, z: 0, stride: 8, iteration: 7, layer: 2, previousOffset: -4
            });
        });
        it('offsets position by root', function () {
            var _a = __read(worldGenerator.next({
                x: 40, y: 24, z: 32, stride: 8, iteration: 0, layer: 1, previousOffset: -4
            }), 2), result = _a[0], info = _a[1];
            expect(result).toEqual({
                x: 36, y: 20, z: 28, stride: 8
            });
            expect(info).toEqual({
                x: 40, y: 24, z: 32, stride: 8, iteration: 1, layer: 1, previousOffset: -4
            });
        });
        it('offsets position by iteration', function () {
            var _a = __read(worldGenerator.next({
                x: 40, y: 24, z: 32, stride: 8, iteration: 1, layer: 1, previousOffset: -4
            }), 2), result = _a[0], info = _a[1];
            expect(result).toEqual({
                x: 36, y: 20, z: 36, stride: 8
            });
            expect(info).toEqual({
                x: 40, y: 24, z: 32, stride: 8, iteration: 2, layer: 1, previousOffset: -4
            });
        });
        it('offsets position by last iteration', function () {
            var _a = __read(worldGenerator.next({
                x: 40, y: 24, z: 32, stride: 8, iteration: 7, layer: 1, previousOffset: -4
            }), 2), result = _a[0], info = _a[1];
            expect(result).toEqual({
                x: 44, y: 28, z: 36, stride: 8
            });
            expect(info).toEqual({
                x: 40, y: 24, z: 32, stride: 8, iteration: 0, layer: 2, previousOffset: -4
            });
        });
        it('offsets position by last layer', function () {
            var _a = __read(worldGenerator.next({
                x: 40, y: 24, z: 32, stride: 8, iteration: 55, layer: 2, previousOffset: -4
            }), 2), result = _a[0], info = _a[1];
            expect(result).toEqual({
                x: 52, y: 36, z: 44, stride: 8
            });
            expect(info).toEqual({
                x: 40, y: 24, z: 32, stride: 16, iteration: 0, layer: 1, previousOffset: 8
            });
        });
        it('returns correct position for next stride', function () {
            var _a = __read(worldGenerator.next({
                x: 0, y: 0, z: 0, stride: 16, iteration: 0, layer: 1, previousOffset: 8
            }), 2), result = _a[0], info = _a[1];
            expect(result).toEqual({
                x: -24, y: -24, z: -24, stride: 16
            });
            expect(info).toEqual({
                x: 0, y: 0, z: 0, stride: 16, iteration: 1, layer: 1, previousOffset: 8
            });
        });
        it('returns correct position 32/0/1', function () {
            var _a = __read(worldGenerator.next({
                x: 0, y: 0, z: 0, stride: 32, iteration: 0, layer: 1, previousOffset: 48
            }), 2), result = _a[0], info = _a[1];
            expect(result).toEqual({
                x: -80, y: -80, z: -80, stride: 32
            });
            expect(info).toEqual({
                x: 0, y: 0, z: 0, stride: 32, iteration: 1, layer: 1, previousOffset: 48
            });
        });
    });
    describe('when radius is called', function () {
        var expectedResults = [
            { layer: 1, stride: 8, previousOffset: -4, result: 4 },
            { layer: 2, stride: 8, previousOffset: -4, result: 12 },
            { layer: 1, stride: 16, previousOffset: 8, result: 24 },
            { layer: 2, stride: 16, previousOffset: 8, result: 40 },
            { layer: -2, stride: 16, previousOffset: 8, result: -40 },
        ];
        var _loop_1 = function (i) {
            var _a = expectedResults[i], layer = _a.layer, stride = _a.stride, previousOffset = _a.previousOffset, result = _a.result;
            it("then ring ".concat(i + 1, " is correct"), function () {
                expect(worldGenerator.radius(layer, stride, previousOffset)).toEqual(result);
            });
        };
        for (var i = 0; i < expectedResults.length; i++) {
            _loop_1(i);
        }
    });
    describe('when layerRadius is called', function () {
        var expectedResults = [
            { layer: 1, stride: 8, result: 1 },
            { layer: 2, stride: 8, result: 2 },
            { layer: 1, stride: 16, result: 2 },
            { layer: 2, stride: 16, result: 3 },
            { layer: 3, stride: 16, result: 4 },
            { layer: 1, stride: 32, result: 3 },
            { layer: 2, stride: 32, result: 4 },
        ];
        var _loop_2 = function (i) {
            var _a = expectedResults[i], layer = _a.layer, stride = _a.stride, result = _a.result;
            it("then ring ".concat(i + 1, " is correct"), function () {
                expect(worldGenerator.layerRadius(layer, stride)).toEqual(result);
            });
        };
        for (var i = 0; i < expectedResults.length; i++) {
            _loop_2(i);
        }
    });
    describe('when layerCount is called', function () {
        it('returns 2 for first stride', function () {
            expect(worldGenerator.layerCount(8)).toEqual(2);
        });
        it('returns 3 for second stride', function () {
            expect(worldGenerator.layerCount(16)).toEqual(3);
        });
        it('returns 2 for subsequent strides', function () {
            for (var i = 32; i < 1024; i += i) {
                expect(worldGenerator.layerCount(i)).toEqual(2);
            }
        });
    });
    describe('generate points', function () {
        it('returns the correct values', function () {
            expect((0,_world_generator__WEBPACK_IMPORTED_MODULE_0__.generatePoints)(1)).toEqual([
                { x: -1, y: -1, z: -1 },
                { x: -1, y: -1, z: 1 },
                { x: -1, y: 1, z: -1 },
                { x: -1, y: 1, z: 1 },
                { x: 1, y: -1, z: -1 },
                { x: 1, y: -1, z: 1 },
                { x: 1, y: 1, z: -1 },
                { x: 1, y: 1, z: 1 },
            ]);
        });
        it('returns the correct values 2', function () {
            expect((0,_world_generator__WEBPACK_IMPORTED_MODULE_0__.generatePoints)(2).length).toEqual(56);
        });
    });
});


/***/ }),

/***/ "./src/world-generator.ts":
/*!********************************!*\
  !*** ./src/world-generator.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "generatePoints": () => (/* binding */ generatePoints),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
function fixPoint(i) {
    if (i >= 0)
        return i + 1;
    return i;
}
function generatePoints(radius) {
    var points = [];
    var diameter = radius * 2;
    for (var x = 0; x < diameter; x++)
        for (var y = 0; y < diameter; y++)
            for (var z = 0; z < diameter; z++) {
                if (!(x === 0 || x === diameter - 1 || y === 0 || y === diameter - 1 || z === 0 || z === diameter - 1)) {
                    continue;
                }
                var point = {
                    x: fixPoint(x - radius),
                    y: fixPoint(y - radius),
                    z: fixPoint(z - radius)
                };
                points.push(point);
            }
    return points;
}
var points = [];
for (var i = 0; i <= 6; i++) {
    points[i] = generatePoints(i);
}
var WorldGenerator = /** @class */ (function () {
    function WorldGenerator(minStride) {
        this.minStride = minStride;
    }
    WorldGenerator.prototype.init = function (x, y, z) {
        return {
            x: Math.round(x / this.minStride) * this.minStride,
            y: Math.round(y / this.minStride) * this.minStride,
            z: Math.round(z / this.minStride) * this.minStride,
            stride: this.minStride,
            iteration: 0,
            layer: 1,
            previousOffset: -1 * this.minStride / 2
        };
    };
    WorldGenerator.prototype.layerRadius = function (layer, stride) {
        if (stride === this.minStride) {
            return layer;
        }
        if (stride === this.minStride * 2) {
            return layer + 1;
        }
        return layer + 2;
    };
    WorldGenerator.prototype.radius = function (layer, stride, previousOffset) {
        return Math.sign(layer) * (previousOffset + (Math.abs(layer) * stride));
    };
    WorldGenerator.prototype.layerCount = function (stride) {
        if (stride == this.minStride * 2)
            return 3;
        return 2;
    };
    WorldGenerator.prototype.next = function (info) {
        var offsets = points[this.layerRadius(info.layer, info.stride)];
        var offset = offsets[info.iteration];
        var halfStride = info.stride / 2;
        var iteration = info.iteration + 1;
        var layer = info.layer;
        var stride = info.stride;
        var previousOffset = info.previousOffset;
        if (iteration >= offsets.length) {
            iteration = 0;
            layer++;
            var layerCount = this.layerCount(info.stride);
            if (layer > layerCount) {
                layer = 1;
                stride *= 2;
                previousOffset = this.radius(info.layer, info.stride, info.previousOffset) - info.stride / 2;
            }
        }
        return [
            {
                x: info.stride * offset.x + info.x - Math.sign(offset.x) * halfStride,
                y: info.stride * offset.y + info.y - Math.sign(offset.y) * halfStride,
                z: info.stride * offset.z + info.z - Math.sign(offset.z) * halfStride,
                stride: info.stride
            },
            __assign(__assign({}, info), { iteration: iteration, layer: layer, stride: stride, previousOffset: previousOffset })
        ];
    };
    return WorldGenerator;
}());
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WorldGenerator);


/***/ }),

/***/ "./src sync recursive .test.(j|t)s$":
/*!*********************************!*\
  !*** ./src/ sync .test.(j|t)s$ ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./compute-voxels.test.ts": "./src/compute-voxels.test.ts",
	"./renderer.test.ts": "./src/renderer.test.ts",
	"./world-generator.test.ts": "./src/world-generator.test.ts"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./src sync recursive .test.(j|t)s$";

/***/ }),

/***/ "?8465":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd define */
/******/ 	(() => {
/******/ 		__webpack_require__.amdD = function () {
/******/ 			throw new Error('define cannot be used indirect');
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./src/tests.ts");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL25vZGVfbW9kdWxlcy9qYXNtaW5lLWNvcmUvbGliL2phc21pbmUtY29yZS9qYXNtaW5lLmNzcyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qcyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL25vZGVfbW9kdWxlcy9qYXNtaW5lLWNvcmUvbGliL2phc21pbmUtY29yZS9ib290MC5qcyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL25vZGVfbW9kdWxlcy9qYXNtaW5lLWNvcmUvbGliL2phc21pbmUtY29yZS9ib290MS5qcyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL25vZGVfbW9kdWxlcy9qYXNtaW5lLWNvcmUvbGliL2phc21pbmUtY29yZS9qYXNtaW5lLWh0bWwuanMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvLi9ub2RlX21vZHVsZXMvamFzbWluZS1jb3JlL2xpYi9qYXNtaW5lLWNvcmUvamFzbWluZS5qcyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL3NyYy9jb21wdXRlLXZveGVscy53Z3NsIiwid2VicGFjazovL3dlYmdwdS1jb21wdXRlLy4vbm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIvYWxlYS5qcyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL25vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi90eWNoZWkuanMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yMTI4LmpzIiwid2VicGFjazovL3dlYmdwdS1jb21wdXRlLy4vbm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vbGliL3hvcjQwOTYuanMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yc2hpZnQ3LmpzIiwid2VicGFjazovL3dlYmdwdS1jb21wdXRlLy4vbm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vbGliL3hvcndvdy5qcyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL25vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL3NlZWRyYW5kb20uanMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvLi9ub2RlX21vZHVsZXMvamFzbWluZS1jb3JlL2xpYi9qYXNtaW5lLWNvcmUvamFzbWluZS5jc3M/NGU4ZiIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzIiwid2VicGFjazovL3dlYmdwdS1jb21wdXRlLy4vc3JjL2NvbXB1dGUtdm94ZWxzLnRlc3QudHMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvLi9zcmMvcmVuZGVyZXIudGVzdC50cyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL3NyYy9yZW5kZXJlci50cyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL3NyYy90ZXN0cy50cyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL3NyYy93b3JsZC1nZW5lcmF0b3IudGVzdC50cyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL3NyYy93b3JsZC1nZW5lcmF0b3IudHMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvL2hvbWUvcnVubmVyL3dvcmsvd2ViZ3B1LXdvcmxkL3dlYmdwdS13b3JsZC9zcmN8c3luY3wvLnRlc3QuKGp8dClzJC8iLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvaWdub3JlZHxjcnlwdG8iLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvd2VicGFjay9ydW50aW1lL2FtZCBkZWZpbmUiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvd2VicGFjay9ydW50aW1lL2FtZCBvcHRpb25zIiwid2VicGFjazovL3dlYmdwdS1jb21wdXRlL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL3dlYmdwdS1jb21wdXRlL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL3dlYmdwdS1jb21wdXRlL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS93ZWJwYWNrL3J1bnRpbWUvbm9kZSBtb2R1bGUgZGVjb3JhdG9yIiwid2VicGFjazovL3dlYmdwdS1jb21wdXRlL3dlYnBhY2svc3RhcnR1cCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNtRztBQUNqQjtBQUNsRiw4QkFBOEIsc0VBQTJCLENBQUMsK0VBQXFDO0FBQy9GO0FBQ0EsNkRBQTZELFFBQVEsdUJBQXVCLEdBQUcsNEJBQTRCLGdCQUFnQiwyQkFBMkIsaUJBQWlCLGlCQUFpQixvQkFBb0IsdURBQXVELHNCQUFzQixnQkFBZ0IsR0FBRyw0QkFBNEIsMEJBQTBCLEdBQUcsa0NBQWtDLCtCQUErQixHQUFHLDhMQUE4TCxjQUFjLHNCQUFzQixHQUFHLHdaQUF3WixzQkFBc0IsdUJBQXVCLEdBQUcsMENBQTBDLHVCQUF1QixHQUFHLHlEQUF5RCxxQ0FBcUMscXdFQUFxd0UseUNBQXlDLCtoWEFBK2hYLCtCQUErQiw2QkFBNkIsa0NBQWtDLDBCQUEwQixtQkFBbUIsZ0JBQWdCLGdCQUFnQixpQkFBaUIsR0FBRywyREFBMkQsc0JBQXNCLHVCQUF1QixhQUFhLEdBQUcsMkNBQTJDLG9CQUFvQixnQkFBZ0IsR0FBRywyQ0FBMkMsZ0JBQWdCLEdBQUcsMENBQTBDLHFCQUFxQixHQUFHLDRDQUE0QyxnQkFBZ0IsaUJBQWlCLHNCQUFzQix1QkFBdUIsR0FBRyxrREFBa0QscUJBQXFCLG1CQUFtQixHQUFHLHFEQUFxRCwwQkFBMEIsaUJBQWlCLGdCQUFnQixvQkFBb0IsR0FBRyxvRUFBb0Usb0JBQW9CLEdBQUcsMkVBQTJFLG1CQUFtQixtQkFBbUIsR0FBRyxvRUFBb0UscUJBQXFCLEdBQUcsMkVBQTJFLG1CQUFtQixtQkFBbUIsc0JBQXNCLHNCQUFzQixHQUFHLHNFQUFzRSxvQkFBb0IsR0FBRyw2RUFBNkUsbUJBQW1CLG1CQUFtQixHQUFHLGlGQUFpRixvQkFB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VUFBVSxLQUFLLEtBQUssVUFBVSxNQUFNLEtBQUssVUFBVSxVQUFVLEtBQUssS0FBSyxVQUFVLFlBQVksYUFBYSxXQUFXLFlBQVksYUFBYSxNQUFNLEtBQUssVUFBVSxZQUFZLE1BQU0sS0FBSyxZQUFZLFdBQVcsVUFBVSxZQUFZLGFBQWEsYUFBYSxhQUFhLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxZQUFZLFdBQVcsVUFBVSxVQUFVLEtBQUssS0FBSyxZQUFZLGFBQWEsTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLFlBQVksYUFBYSxhQUFhLFdBQVcsS0FBSyxLQUFLLFlBQVksV0FBVyxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLE1BQU0sVUFBVSxLQUFLLE1BQU0sVUFBVSxLQUFLLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxhQUFhLFdBQVcsVUFBVSxNQUFNLEtBQUssVUFBVSxZQUFZLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxZQUFZLE1BQU0sS0FBSyxVQUFVLEtBQUssS0FBSyxZQUFZLE1BQU0sS0FBSyxZQUFZLFdBQVcsS0FBSyxLQUFLLFVBQVUsS0FBSyxLQUFLLFlBQVksV0FBVyxZQUFZLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxZQUFZLGFBQWEsV0FBVyxZQUFZLFdBQVcsWUFBWSxhQUFhLGFBQWEsTUFBTSxLQUFLLFVBQVUsWUFBWSxXQUFXLFlBQVksTUFBTSxLQUFLLFVBQVUsS0FBSyxLQUFLLFlBQVksTUFBTSxLQUFLLFVBQVUsWUFBWSxXQUFXLEtBQUssS0FBSyxZQUFZLFdBQVcsVUFBVSxZQUFZLGFBQWEs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QUNBLEU7Ozs7Ozs7Ozs7QUNyQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxtQkFBTyxDQUFDLDZFQUFjOztBQUV0RTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7O0FDL0REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrREFBK0QsSUFBSTtBQUNuRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFF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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIscUJBQXFCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7OztBQzk3QkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEtBQTZCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUJBQU07QUFDckIsc0JBQXNCLHFCQUFNO0FBQzVCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsOEJBQThCO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFNBQVM7QUFDM0UsTUFBTSxpQkFBaUIsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0I7QUFDN0QsTUFBTSxlQUFlO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLG9DQUFvQyw2QkFBNkI7QUFDakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiwrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2QkFBNkI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkdBQTJHO0FBQzNHO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkdBQTJHO0FBQzNHO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG9CQUFvQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0QkFBNEIsc0NBQXNDLGdDQUFnQztBQUM1SDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsSUFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQ0FBa0MsY0FBYyxLQUFLO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLCtDQUErQztBQUMvQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLE9BQU87QUFDekIsa0JB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VztBQUNYO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLG1EQUFtRCxjQUFjO0FBQ2pFO0FBQ0Esb0RBQW9ELGNBQWM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixhQUFhLEVBQUU7QUFDZixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxnQ0FBZ0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLGlCQUFpQiw0QkFBNEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOEJBQThCO0FBQy9DO0FBQ0E7O0FBRUEsdUJBQXVCLDhCQUE4QjtBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0JBQStCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUNBQWlDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQ0FBa0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrQkFBK0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsK0JBQStC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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLGFBQWE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLGFBQWE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLGFBQWE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxhQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxhQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxhQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sYUFBYTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLGFBQWE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sYUFBYTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLGFBQWE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sYUFBYTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxhQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLGFBQWE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sYUFBYTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxnQ0FBZ0Msc0JBQXNCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCx3Q0FBd0MsaUNBQWlDOztBQUV6RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sYUFBYSxnQkFBZ0IsVUFBVTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sYUFBYSxzQkFBc0IsVUFBVSxzQ0FBc0MsVUFBVTtBQUNuRztBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUksYUFBYSxVQUFVLGtEQUFrRCxVQUFVO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sYUFBYSxnQkFBZ0IsVUFBVTtBQUM3QztBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLGFBQWEsZ0JBQWdCLFVBQVU7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZUFBZSxtQ0FBbUM7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLLG1EQUFtRDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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LENBQUMsRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLFNBQVMsRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFDO2FBQ3hFLENBQUMsTUFGRyxNQUFNLFVBQUUsSUFBSSxRQUVmLENBQUM7WUFFSCxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDO2dCQUNyQixDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxNQUFNLEVBQUUsQ0FBQzthQUNsQyxDQUFDLENBQUM7WUFFSCxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDO2dCQUNuQixDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLFNBQVMsRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFDO2FBQ3hFLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLDJEQUEyRCxFQUFFO1lBQzFELGdCQUFpQixjQUFjLENBQUMsSUFBSSxDQUFDO2dCQUN2QyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLFNBQVMsRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFDO2FBQ3hFLENBQUMsTUFGRyxNQUFNLFVBQUUsSUFBSSxRQUVmLENBQUM7WUFFSCxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDO2dCQUNyQixDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxFQUFFLENBQUM7YUFDL0IsQ0FBQyxD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VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3hCQTtXQUNBO1dBQ0EsRTs7Ozs7V0NGQSw4Qjs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsZ0NBQWdDLFlBQVk7V0FDNUM7V0FDQSxFOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0Esd0NBQXdDLHlDQUF5QztXQUNqRjtXQUNBO1dBQ0EsRTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEVBQUU7V0FDRjtXQUNBO1dBQ0EsQ0FBQyxJOzs7OztXQ1BELHdGOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHNEQUFzRCxrQkFBa0I7V0FDeEU7V0FDQSwrQ0FBK0MsY0FBYztXQUM3RCxFOzs7OztXQ05BO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsRTs7OztVQ0pBO1VBQ0E7VUFDQTtVQUNBIiwiZmlsZSI6InRlc3RzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiQGNoYXJzZXQgXFxcIlVURi04XFxcIjtcXG5ib2R5IHtcXG4gIG92ZXJmbG93LXk6IHNjcm9sbDtcXG59XFxuXFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlZWU7XFxuICBwYWRkaW5nOiA1cHg7XFxuICBtYXJnaW46IC04cHg7XFxuICBmb250LXNpemU6IDExcHg7XFxuICBmb250LWZhbWlseTogTW9uYWNvLCBcXFwiTHVjaWRhIENvbnNvbGVcXFwiLCBtb25vc3BhY2U7XFxuICBsaW5lLWhlaWdodDogMTRweDtcXG4gIGNvbG9yOiAjMzMzO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIGEge1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIGE6aG92ZXIge1xcbiAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgcCwgLmphc21pbmVfaHRtbC1yZXBvcnRlciBoMSwgLmphc21pbmVfaHRtbC1yZXBvcnRlciBoMiwgLmphc21pbmVfaHRtbC1yZXBvcnRlciBoMywgLmphc21pbmVfaHRtbC1yZXBvcnRlciBoNCwgLmphc21pbmVfaHRtbC1yZXBvcnRlciBoNSwgLmphc21pbmVfaHRtbC1yZXBvcnRlciBoNiB7XFxuICBtYXJnaW46IDA7XFxuICBsaW5lLWhlaWdodDogMTRweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYW5uZXIsXFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSxcXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1bW1hcnksXFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1yZXN1bHQtbWVzc2FnZSxcXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXNwZWMgLmphc21pbmUtZGVzY3JpcHRpb24sXFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zcGVjLWRldGFpbCAuamFzbWluZS1kZXNjcmlwdGlvbixcXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWFsZXJ0IC5qYXNtaW5lLWJhcixcXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN0YWNrLXRyYWNlIHtcXG4gIHBhZGRpbmctbGVmdDogOXB4O1xcbiAgcGFkZGluZy1yaWdodDogOXB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhbm5lciB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFubmVyIC5qYXNtaW5lLXRpdGxlIHtcXG4gIGJhY2tncm91bmQ6IHVybChcXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFGb0FBQUFaQ0FNQUFBQ0d1c255QUFBQ2RsQk1WRVgvLy8vL0FQK0FnSUNxVmFxQVFJQ1pNNW1BVllDU1NaS0FRSUNPT1k2QVRZQ0xSb3VBUUlDSk80bVNTWUNJUklpUFFJQ0hQSWVPUjRDR1E0YU1RSUNHUFlhTFJvQ0ZRNFdLUUlDUFBZV0pSWUNPUW9TSlFJQ05Qb1NJUklDTVFvU0hRSUNIUklDS1FvT0hRSUNLUG9PSk80T0pRWU9NUUlDTVE0Q0lRWUtMUUlDSVBvS0xRNENLUUlDTlBvS0pRSVNNUTRLSlFvU0xRWUtKUUlTTFE0S0lRb1NLUVlLSVFJQ0lRSVNNUW9TS1FZS0xRSU9MUW9PSlFZR0xRSU9LUUlPTVFvR0tRWU9MUVlHS1FJT0xRb0dKUVlPSlFJT0tRWUdKUUlPS1FvR0tRSUdMUUlLTFE0S0tRb0dMUVlLSlFJR0tRWUtKUUlHS1FJS0pRb0dLUVlLTFFJR0tRWUtMUUlPSlFvS0tRb09KUVlLS1FJT0pRb0tLUW9PS1FJT0xRb0tLUVlPTFFZS0pRSU9LUW9LS1FZS0tRb0tKUVlPS1FZS0xRSU9LUW9LTFFZT0tRWUtMUUlPSlFvR0tRWUtKUVlHSlFvR0tRWUtMUW9HTFFZR0tRb0dKUVlLS1FZR0pRSUtLUW9HSlFZS0xRSUtLUVlHTFFZS0tRWUdLUVlHS1FZS0pRWU9LUW9LSlFZT0tRWUtMUVlPTFFZT0tRWUtMUVlPS1FvS0tRWUtLUVlPS1FZT0pRWUtLUVlLTFFZS0tRSUtLUW9LS1FZS0tRWUtLUW9LSlFJS0tRWUtMUVlLS1FZS0tRSUtLUVlLS1FZS0tRWUtLUUlLS1FZS0pRWUdMUVlHS1FZS0tRWUtLUVlHS1FJS0tRWUdLUVlPSlFvS0tRWU9MUVlLS1FZT0tRb0tLUVlLS1FvS0tRWUtLUVlLSlFZS0xRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0pRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0xRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUttSURwRUFBQUEwWFJTVGxNQUFRSURCQVVHQndnSkNnc01EUTRQRUJFU0V4UVZGaGNZR1JvYkhCMGVIeUFpSXlRbEp5Y29LaXNzTFM0d01UUTFOamM0T1RvN1BEdytQMEJDUTBSSVNVcExURTFPVUZOVVZWZFlXRmxhVzE1ZllHRmlZMlpuYUdscWEyeHRiM0J4Y25OMGRuaDVlbnQ4Zlg1L2dJR0NoSVdJaW95TmpvK1FrWk9VbFphWW1acWJuSjJlb0tHaW82V21xS21zcmE2dnNMR3p0cmU0dWJxN3ZMMit3TUhEeE1qSnlzdk56cy9RMGRMVTF0ZlkyZHZjM3QvZzRlTGo1ZWJuNk9ucTYrenQ3dS93OHZQMDlmYjMrUG42Ky96OS92a1ZRWEFBQUFNYVNVUkJWSGhlNWRYeFYxTjFHTWZ4ejJBQmJEZ0lBbTVWREpPeVZESUpMVU1hVnBCV1VaVWFHYm1xb0dwWlJTaUdpUldwNktvWjVBQjBaWTUwUkltWlFJbGFoS2tNWVh2L1I5MGRCdkVUL3JKZk9yM091Yzh2OTl6UGVjNTl6dmY1NmordllLbFZpU2Y3MjUwWDRNcjNPMjlUZ3EwOEJkR0I0RGhjZWtFSjVZa1FLRnNnV1pkdGo5SnBWK0k4eFBqTEZxa3JzRUlxTzhQSFNwaXMzNmpXYXpjcWpFc2ZKamt2UnNzVlUzN1NkSU91NFhDZjV2RUpQc253SnBuUk5VOUpteGhNazhsMWdlaElycTdoVEZqek9EK1ZmODg2MjlxS01KVk5sdEluRmVSZXhSUXlKbE5lcWQxaUdEbFN6cklVSXlYYnlGZm0zUllwcmNRUmU3bHF0V3lHWWJmYzZkVDBSMnZtZE9Pa1gzdTU1QzFyUDM3ZnRpSCt0RGJ5NHIvUkJUMHc4VHlFa3IrZXBCOVhnUERtU1lZV2JyaEN1RllhSXl3M2ZEUUFYVG5Ta2grQU5vZmlIbVdmOWwrRlkxSTkwRmRRVGV0c3RPMDBvMjNub3Z6VnNKN3VCMy9DNVRrYmpSd1o1SmVyd1Y0aVJXcTlIRmJGTWFLL2QwVFlxYXlSaVFQdUl4eFMzQnU4SldVOTAvNjB0S2k3dmtoYXpuZXowYS9UYlZPS2o1Q2FPWmg2ZldHNi9MeXY5Qi9aTFIxZ3cvUy9mcGJlVkQzTUNXMWxpNlN2V0RPbjY1dHI5OS91dld0QlMwWERtNHMxdCtzT0hwRzBrcEJLeC9sNzd3T1NueExwY3g2VFhtWExUUFFPS1lPZjlRMWRmcjgvU0oybUZkQ3ZsMVlsOTNEaUhVWnZYZUxKYkdTell1NWdWSjJzbGJTYWtPUjhkeENxNWFkUTJvRkxxc0U5RXgzTDRxUU8wZU9QZVU1eDU2YnlwWHA0b25TRWI1T2tJQ1g2bERhdDU1VGVvenROS1FjSmFha3J6OUtDYjk1b0Q2OUlLcSt5S1c0WFBqa25hUzUyVjBUWnFFMmNUdFhqY0hTQ1JtVU84OGUrODVoajNFUDc0aTlwOHB5bHc3bHhnTUR5eWw2T1Y3WmVqbmpOTWZhdHU4N0x4UmJIMElTMzVndDJhNFpqbUdwVkJkS0szV3I2SU5rOGpXV1NHcWJBNTVDS2dqQlJDNkU5dzc4eWRUZzNBQlMzQUZWMVFOMFk0QWEycGdFalduUVVSajlMMGF5SzZSMnlzRXF4SFVLelluTHZ2eVUraTlLTTJKSEp6RTR2eVpPeURjT3dPc3lTYWplTFBjOHNOdlBKa0ZseUpkMjB3cHFBelplQWZaM29XeWJ4ZCtQLzNqK1NHM3VTQmRmMlZRQUFBQUJKUlU1RXJrSmdnZz09XFxcIikgbm8tcmVwZWF0O1xcbiAgYmFja2dyb3VuZDogdXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBEOTRiV3dnZG1WeWMybHZiajBpTVM0d0lpQmxibU52WkdsdVp6MGlWVlJHTFRnaUlITjBZVzVrWVd4dmJtVTlJbTV2SWo4K0Nqd2hMUzBnUTNKbFlYUmxaQ0IzYVhSb0lFbHVhM05qWVhCbElDaG9kSFJ3T2k4dmQzZDNMbWx1YTNOallYQmxMbTl5Wnk4cElDMHRQZ29LUEhOMlp3b2dJQ0I0Yld4dWN6cGtZejBpYUhSMGNEb3ZMM0IxY213dWIzSm5MMlJqTDJWc1pXMWxiblJ6THpFdU1TOGlDaUFnSUhodGJHNXpPbU5qUFNKb2RIUndPaTh2WTNKbFlYUnBkbVZqYjIxdGIyNXpMbTl5Wnk5dWN5TWlDaUFnSUhodGJHNXpPbkprWmowaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1UazVPUzh3TWk4eU1pMXlaR1l0YzNsdWRHRjRMVzV6SXlJS0lDQWdlRzFzYm5NNmMzWm5QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUlLSUNBZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWdvZ0lDQjRiV3h1Y3pwcGJtdHpZMkZ3WlQwaWFIUjBjRG92TDNkM2R5NXBibXR6WTJGd1pTNXZjbWN2Ym1GdFpYTndZV05sY3k5cGJtdHpZMkZ3WlNJS0lDQWdkbVZ5YzJsdmJqMGlNUzR4SWdvZ0lDQjNhV1IwYUQwaU5qZ3hMamsyTWpVeUlnb2dJQ0JvWldsbmFIUTlJakU0Tnk0MUlnb2dJQ0JwWkQwaWMzWm5NaUlLSUNBZ2VHMXNPbk53WVdObFBTSndjbVZ6WlhKMlpTSStQRzFsZEdGa1lYUmhDaUFnSUNBZ2FXUTlJbTFsZEdGa1lYUmhPQ0krUEhKa1pqcFNSRVkrUEdOak9sZHZjbXNLSUNBZ0lDQWdJQ0FnY21SbU9tRmliM1YwUFNJaVBqeGtZenBtYjNKdFlYUSthVzFoWjJVdmMzWm5LM2h0YkR3dlpHTTZabTl5YldGMFBqeGtZenAwZVhCbENpQWdJQ0FnSUNBZ0lDQWdjbVJtT25KbGMyOTFjbU5sUFNKb2RIUndPaTh2Y0hWeWJDNXZjbWN2WkdNdlpHTnRhWFI1Y0dVdlUzUnBiR3hKYldGblpTSWdMejQ4TDJOak9sZHZjbXMrUEM5eVpHWTZVa1JHUGp3dmJXVjBZV1JoZEdFK1BHUmxabk1LSUNBZ0lDQnBaRDBpWkdWbWN6WWlQanhqYkdsd1VHRjBhQW9nSUNBZ0lDQWdhV1E5SW1Oc2FYQlFZWFJvTVRnaVBqeHdZWFJvQ2lBZ0lDQWdJQ0FnSUdROUlrMGdNQ3d4TlRBd0lEQXNNQ0JzSURVME5UVXVOelFzTUNBd0xERTFNREFnVENBd0xERTFNREFnZWlJS0lDQWdJQ0FnSUNBZ2FXNXJjMk5oY0dVNlkyOXVibVZqZEc5eUxXTjFjblpoZEhWeVpUMGlNQ0lLSUNBZ0lDQWdJQ0FnYVdROUluQmhkR2d5TUNJZ0x6NDhMMk5zYVhCUVlYUm9Qand2WkdWbWN6NDhad29nSUNBZ0lIUnlZVzV6Wm05eWJUMGliV0YwY21sNEtERXVNalVzTUN3d0xDMHhMakkxTERBc01UZzNMalVwSWdvZ0lDQWdJR2xrUFNKbk1UQWlQanhuQ2lBZ0lDQWdJQ0IwY21GdWMyWnZjbTA5SW5OallXeGxLREF1TVN3d0xqRXBJZ29nSUNBZ0lDQWdhV1E5SW1jeE1pSStQR2NLSUNBZ0lDQWdJQ0FnYVdROUltY3hOQ0krUEdjS0lDQWdJQ0FnSUNBZ0lDQmpiR2x3TFhCaGRHZzlJblZ5YkNnalkyeHBjRkJoZEdneE9Da2lDaUFnSUNBZ0lDQWdJQ0FnYVdROUltY3hOaUkrUEhCaGRHZ0tJQ0FnSUNBZ0lDQWdJQ0FnSUdROUltMGdNVFUwTkN3MU9Ua3VORE0wSUdNZ01DNDVNaXd0TkRBdU16VXlJREkxTGpZNExDMDRNUzQyTURJZ056RXVOVE1zTFRneExqWXdNaUF5Tnk0MU1Td3dJRFEzTGpZNExERXlMamd6TWlBMk1TNDBOQ3d6TlM0M05UUWdNVEl1T0RNc01qSXVPVE1nTVRJdU9ETXNOVFl1T0RVeUlERXlMamd6TERneUxqVXlOeUJzSURBc016STVMakU0TkNBdE56RXVOVElzTUNBd0xERXdOQzQxTkRNZ01qWTJMamd6TERBZ01Dd3RNVEEwTGpVME15QXROekF1Tml3d0lEQXNMVE0wTkM0M055QmpJREFzTFRVNExqWTVNU0F0TXk0Mk9Dd3RNVEEwTGpVek1TQXRORFF1T1RNc0xURTFNaTR5TVRnZ0xUTTJMalk0TEMwME1pNHhPQ0F0T1RZdU1qZ3NMVFkyTGpBeUlDMHhOVE11TVRRc0xUWTJMakF5SUMweE1UY3VNemNzTUNBdE1qQTNMakkwTERjM0xqazBNU0F0TWpBeUxqWTBMREU1Tnk0eE5EVWdiQ0F4TXpBdU1pd3dJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXNXJjMk5oY0dVNlkyOXVibVZqZEc5eUxXTjFjblpoZEhWeVpUMGlNQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbGtQU0p3WVhSb01qSWlDaUFnSUNBZ0lDQWdJQ0FnSUNCemRIbHNaVDBpWm1sc2JEb2pPR0UwTVRneU8yWnBiR3d0YjNCaFkybDBlVG94TzJacGJHd3RjblZzWlRwdWIyNTZaWEp2TzNOMGNtOXJaVHB1YjI1bElpQXZQanh3WVhSb0NpQWdJQ0FnSUNBZ0lDQWdJQ0JrUFNKdElESXpNREV1TkN3Mk5qSXVOamsxSUdNZ01DdzRNQzQzTURNZ0xUWTJMamswTERFME5TNDRNVE1nTFRFME55NDJNeXd4TkRVdU9ERXpJQzA0TXk0ME5Dd3dJQzB4TkRjdU5qTXNMVFk0TGpjNE1TQXRNVFEzTGpZekxDMHhOVEV1TXpBeElEQXNMVGM1TGpjNE5TQTJOaTQ1TkN3dE1UUTFMamd3TVNBeE5EVXVPQ3d0TVRRMUxqZ3dNU0E0TkM0ek5Td3dJREUwT1M0ME5pdzJOeTQ0TlRJZ01UUTVMalEyTERFMU1TNHlPRGtnZWlCdElDMHhMamd6TEMweE9ERXVOVFEzSUdNZ0xUTTFMamMzTEMwMU5DNHdPVGNnTFRrekxqVXpMQzAzT0M0NE5Ua2dMVEUxTnk0M01pd3ROemd1T0RVNUlDMHhOREF1TXl3d0lDMHlOVEV1TWpRc01URTJMalEwT1NBdE1qVXhMakkwTERJMU5DNDVNVGdnTUN3eE5ESXVNVEk1SURFeE15NDNMREkyTUM0ME1TQXlOVFl1TnpRc01qWXdMalF4SURZekxqSTNMREFnTVRFNExqSTVMQzB5T1M0ek16WWdNVFV5TGpJeUxDMDRNaTQxTWpNZ2JDQXdMRFk1TGpZNE55QXhOelV1TVRRc01DQXdMQzB4TURRdU5USTNJQzAyTVM0ME5Dd3dJREFzTFRJNE1DNDFPVGdnTmpFdU5EUXNNQ0F3TEMweE1EUXVOVEkzSUMweE56VXVNVFFzTUNBd0xEWTJMakF4T1NJS0lDQWdJQ0FnSUNBZ0lDQWdJR2x1YTNOallYQmxPbU52Ym01bFkzUnZjaTFqZFhKMllYUjFjbVU5SWpBaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwWkQwaWNHRjBhREkwSWdvZ0lDQWdJQ0FnSUNBZ0lDQWdjM1I1YkdVOUltWnBiR3c2SXpoaE5ERTRNanRtYVd4c0xXOXdZV05wZEhrNk1UdG1hV3hzTFhKMWJHVTZibTl1ZW1WeWJ6dHpkSEp2YTJVNmJtOXVaU0lnTHo0OGNHRjBhQW9nSUNBZ0lDQWdJQ0FnSUNBZ1pEMGliU0F5TmpJeUxqTXpMRFUxTnk0eU5UZ2dZeUF6TGpZM0xDMDBOQzR3TVRZZ016TXVNREVzTFRjekxqTTBPQ0EzT0M0NE5pd3ROek11TXpRNElETXpMamt6TERBZ05qWXVPVE1zTWpNdU9ESTBJRFkyTGprekxEWXdMalV3TkNBd0xEUTRMall3TmlBdE5EVXVPRFFzTlRZdU9EVTJJQzA0TXk0ME5DdzJOaTQ1TkRFZ0xUZzFMakk0TERJeUxqQXdOQ0F0TVRjNExqZ3hMRFE0TGpZd05pQXRNVGM0TGpneExERTFOUzQ0TnprZ01DdzVNeTQxTXpZZ056Z3VPRFlzTVRRM0xqWXpNeUF4TmpVdU9UZ3NNVFEzTGpZek15QTBOQ3d3SURnekxqUXpMQzA1TGpFM05pQXhNVEF1T1RRc0xUUTBMakF3T0NCc0lEQXNNek11T1RJeUlEZ3lMalV6TERBZ01Dd3RNVE15TGprMk5TQXRNVEE0TGpJeExEQWdZeUF0TVM0NE15d3pOQzQ0TlRZZ0xUSTRMalF5TERVM0xqYzNOQ0F0TmpNdU1qWXNOVGN1TnpjMElDMHpNQzR5Tml3d0lDMDJNaTR6TlN3dE1UY3VOREl5SUMwMk1pNHpOU3d0TlRFdU16UTRJREFzTFRRMUxqZzBOeUEwTkM0NU15d3ROVFV1T1RNZ09EQXVOamtzTFRZMExqRTRJRGc0TGpBeUxDMHlNQzR4TnpVZ01UZ3lMalEzTEMwME55NDJPVFVnTVRneUxqUTNMQzB4TlRjdU56TTBJREFzTFRrNUxqQXlOeUF0T0RNdU5EUXNMVEUxTkM0d016a2dMVEUzTlM0eE15d3RNVFUwTGpBek9TQXRORGt1TlRNc01DQXRPVFF1TkRZc01UVXVOVGd5SUMweE1qWXVOVFVzTlRNdU1UZ2diQ0F3TEMwME1DNHpOQ0F0T0RVdU1qY3NNQ0F3TERFME1pNHhNamtnTVRFMExqWXlMREFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBibXR6WTJGd1pUcGpiMjV1WldOMGIzSXRZM1Z5ZG1GMGRYSmxQU0l3SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdhV1E5SW5CaGRHZ3lOaUlLSUNBZ0lDQWdJQ0FnSUNBZ0lITjBlV3hsUFNKbWFXeHNPaU00WVRReE9ESTdabWxzYkMxdmNHRmphWFI1T2pFN1ptbHNiQzF5ZFd4bE9tNXZibnBsY204N2MzUnliMnRsT201dmJtVWlJQzgrUEhCaGRHZ0tJQ0FnSUNBZ0lDQWdJQ0FnSUdROUltMGdNams0T0M0eE9DdzRNREF1TWpVMElDMDJNeTR5Tml3d0lEQXNNVEEwTGpVeU55QXhOalV1TURVc01DQXdMQzAzTXk0ek5UVWdZeUF6TVM0eE9DdzFNUzR6TkRjZ056Z3VPRFlzT0RVdU1qYzNJREUwTVM0eU1TdzROUzR5TnpjZ05qY3VPRFVzTUNBeE1qUXVOekVzTFRReExqSTFPQ0F4TlRJdU1qRXNMVEV3TWk0Mk9Ua2dNall1Tml3Mk1pNHpOVEVnT1RJdU5qSXNNVEF5TGpZNU9TQXhOakF1TkRjc01UQXlMalk1T1NBMU15NHhPU3d3SURFd05TNDBOaXd0TWpJZ01UUXhMakl4TEMwMk1pNHpOVEVnTXpndU5USXNMVFEwTGprek9DQXpPQzQxTWl3dE9UTXVOVE15SURNNExqVXlMQzB4TkRrdU5EVTNJR3dnTUN3dE1UZzFMakl6T1NBMk15NHlOeXd3SURBc0xURXdOQzQxTWpjZ0xUSXpPQzQwTWl3d0lEQXNNVEEwTGpVeU55QTJNeTR5T0N3d0lEQXNNVFUzTGpjeE5TQmpJREFzTXpJdU1UQXlJREFzTmpBdU5USTNJQzB4TkM0Mk55dzRPQzQ1TlRjZ0xURTRMak0wTERJMkxqVTRNaUF0TkRndU5qRXNOREF1TXpRMElDMDNPUzQzTnl3ME1DNHpORFFnTFRNd0xqSTJMREFnTFRZekxqSTRMQzB4TWk0NE5EUWdMVGd5TGpVekxDMHpOaTQyTnpJZ0xUSXlMamt6TEMweU9TNHpOVFVnTFRJeUxqa3pMQzAxTmk0NE5qTWdMVEl5TGprekxDMDVNaTQyTWprZ2JDQXdMQzB4TlRjdU56RTFJRFl6TGpJM0xEQWdNQ3d0TVRBMExqVXlOeUF0TWpNNExqUXhMREFnTUN3eE1EUXVOVEkzSURZekxqSTRMREFnTUN3eE5UQXVNemd6SUdNZ01Dd3lPUzR6TkRnZ01DdzJOaTR3TWpNZ0xURTBMalkzTERreExqWTVPU0F0TVRVdU5Ua3NNamt1TXpNMklDMDBOeTQyT1N3ME5DNDVNelFnTFRnd0xqY3NORFF1T1RNMElDMHpNUzR4T0N3d0lDMDFOeTQzTnl3dE1URXVNREE0SUMwM055NDVOQ3d0TXpVdU56YzBJQzB5TkM0M055d3RNekF1TWpVeklDMHlOaTQyTEMwMk1pNHpORE1nTFRJMkxqWXNMVGs1TGprME1TQnNJREFzTFRFMU1TNHpNREVnTmpNdU1qY3NNQ0F3TEMweE1EUXVOVEkzSUMweU16Z3VOQ3d3SURBc01UQTBMalV5TnlBMk15NHlOaXd3SURBc01qZ3dMalU1T0NJS0lDQWdJQ0FnSUNBZ0lDQWdJR2x1YTNOallYQmxPbU52Ym01bFkzUnZjaTFqZFhKMllYUjFjbVU5SWpBaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwWkQwaWNHRjBhREk0SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdjM1I1YkdVOUltWnBiR3c2SXpoaE5ERTRNanRtYVd4c0xXOXdZV05wZEhrNk1UdG1hV3hzTFhKMWJHVTZibTl1ZW1WeWJ6dHpkSEp2YTJVNmJtOXVaU0lnTHo0OGNHRjBhQW9nSUNBZ0lDQWdJQ0FnSUNBZ1pEMGliU0F6T1RrNExqWTJMRGsxTVM0MU5EY2dMVEV4TVM0NE55d3dJREFzTVRFNExqSTVNeUF4TVRFdU9EY3NNQ0F3TEMweE1UZ3VNamt6SUhvZ2JTQXdMQzAwTXpFdU9Ea3hJRFl6TGpJM0xEQWdNQ3d0TVRBMExqVXlOeUF0TWpNNUxqTXpMREFnTUN3eE1EUXVOVEkzSURZMExqRTVMREFnTUN3eU9EQXVOVGs0SUMwMk15NHlOeXd3SURBc01UQTBMalV5TnlBeE56VXVNVFFzTUNBd0xDMHpPRFV1TVRJMUlnb2dJQ0FnSUNBZ0lDQWdJQ0FnYVc1cmMyTmhjR1U2WTI5dWJtVmpkRzl5TFdOMWNuWmhkSFZ5WlQwaU1DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsa1BTSndZWFJvTXpBaUNpQWdJQ0FnSUNBZ0lDQWdJQ0J6ZEhsc1pUMGlabWxzYkRvak9HRTBNVGd5TzJacGJHd3RiM0JoWTJsMGVUb3hPMlpwYkd3dGNuVnNaVHB1YjI1NlpYSnZPM04wY205clpUcHViMjVsSWlBdlBqeHdZWFJvQ2lBZ0lDQWdJQ0FnSUNBZ0lDQmtQU0p0SURReE5Ua3VNVElzT0RBd0xqSTFOQ0F0TmpNdU1qY3NNQ0F3TERFd05DNDFNamNnTVRjMUxqRTBMREFnTUN3dE5qa3VOamczSUdNZ01qa3VNelVzTlRRdU1UQXhJRGcwTGpNMkxEZ3dMalk1T1NBeE5EUXVPRGNzT0RBdU5qazVJRFV6TGpFNUxEQWdNVEExTGpRMUxDMHlNaTR3TVRZZ01UUXhMakl5TEMwMk1DNDFNamNnTkRBdU16UXNMVFEwTGprek5DQTBNUzR5Tml3dE9EZ3VNRE15SURReExqSTJMQzB4TkRNdU9UVTNJR3dnTUN3dE1Ua3hMalkxTXlBMk15NHlOeXd3SURBc0xURXdOQzQxTWpjZ0xUSXpPQzQwTERBZ01Dd3hNRFF1TlRJM0lEWXpMakkyTERBZ01Dd3hOVGd1TmpNM0lHTWdNQ3d6TUM0eU5qSWdNQ3cyTVM0ME16UWdMVEU1TGpJMkxEZzRMakF6TlNBdE1qQXVNVGNzTWpZdU5UZ3lJQzAxTXk0eE9Dd3pPUzQwTVRRZ0xUZzJMakU1TERNNUxqUXhOQ0F0TXpNdU9UTXNNQ0F0TmpndU56Y3NMVEV6TGpjMUlDMDRPQzQ1TkN3dE5ERXVNalVnTFRJeExqQTVMQzB5Tnk0MUlDMHlNUzR3T1N3dE5qa3VOamczSUMweU1TNHdPU3d0TVRBeUxqY3dOeUJzSURBc0xURTBNaTR4TWprZ05qTXVNallzTUNBd0xDMHhNRFF1TlRJM0lDMHlNemd1TkN3d0lEQXNNVEEwTGpVeU55QTJNeTR5Tnl3d0lEQXNNamd3TGpVNU9DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsdWEzTmpZWEJsT21OdmJtNWxZM1J2Y2kxamRYSjJZWFIxY21VOUlqQWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcFpEMGljR0YwYURNeUlnb2dJQ0FnSUNBZ0lDQWdJQ0FnYzNSNWJHVTlJbVpwYkd3Nkl6aGhOREU0TWp0bWFXeHNMVzl3WVdOcGRIazZNVHRtYVd4c0xYSjFiR1U2Ym05dWVtVnlienR6ZEhKdmEyVTZibTl1WlNJZ0x6NDhjR0YwYUFvZ0lDQWdJQ0FnSUNBZ0lDQWdaRDBpYlNBMU1EZ3lMalE0TERjd015NDVOalVnWXlBdE1Ua3VNalFzTnpBdU5qQTFJQzA0TVM0MkxERXhOUzQxTkRjZ0xURTFOQzR3TkN3eE1UVXVOVFEzSUMwMk5pNHdOQ3d3SUMweE1qa3VNeXd0TlRFdU16UTRJQzB4TkRNdU1EVXNMVEV4TlM0MU5EY2diQ0F5T1RjdU1Ea3NNQ0I2SUcwZ09EVXVNamNzTFRFME5DNDRPRE1nWXlBdE16Z3VOVEVzTFRrekxqVXlNeUF0TVRJNUxqSTNMQzB4TlRZdU56a3pJQzB5TXpFdU1EVXNMVEUxTmk0M09UTWdMVEUwTXk0d055d3dJQzB5TlRjdU5qZ3NNVEV4TGpnM01TQXRNalUzTGpZNExESTFOUzQ0TXpZZ01Dd3hORFF1T0RneklERXdPUzR4TWl3eU5qRXVNekk0SURJMU5DNDVNU3d5TmpFdU16STRJRFkzTGpnM0xEQWdNVE0xTGpjeUxDMHpNQzR5TlRnZ01UZ3pMak01TEMwM09DNDROak1nTkRndU5qSXNMVFV4TGpNME5DQTJPQzQzT1N3dE1URXpMalk1TlNBMk9DNDNPU3d0TVRnekxqTTRNeUJzSUMwekxqWTNMQzB6T1M0ME16UWdMVE01Tmk0eE15d3dJR01nTVRRdU5qY3NMVFkzTGpnMk15QTNOeTR3TXl3dE1URTNMak0yTXlBeE5EWXVOeklzTFRFeE55NHpOak1nTkRndU5Ua3NNQ0E1TUM0M05pd3hPQzR6TWpnZ01URTRMakk0TERVNExqWTNNaUJzSURFeE5pNDBOQ3d3SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdhVzVyYzJOaGNHVTZZMjl1Ym1WamRHOXlMV04xY25aaGRIVnlaVDBpTUNJS0lDQWdJQ0FnSUNBZ0lDQWdJR2xrUFNKd1lYUm9NelFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnpkSGxzWlQwaVptbHNiRG9qT0dFME1UZ3lPMlpwYkd3dGIzQmhZMmwwZVRveE8yWnBiR3d0Y25Wc1pUcHViMjU2WlhKdk8zTjBjbTlyWlRwdWIyNWxJaUF2UGp4d1lYUm9DaUFnSUNBZ0lDQWdJQ0FnSUNCa1BTSnRJRFk1TUM0NE9UVXNPRFV3TGpjd015QTVNQzQzTlN3d0lESXlMalUwTXl3ek1TNHdNelVnTUN3eU5ETXVNVEl5SUMweE16VXVPREk1TERBZ01Dd3RNalF6TGpFME1TQXlNaTQxTXpZc0xUTXhMakF4TmlJS0lDQWdJQ0FnSUNBZ0lDQWdJR2x1YTNOallYQmxPbU52Ym01bFkzUnZjaTFqZFhKMllYUjFjbVU5SWpBaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwWkQwaWNHRjBhRE0ySWdvZ0lDQWdJQ0FnSUNBZ0lDQWdjM1I1YkdVOUltWnBiR3c2SXpoaE5ERTRNanRtYVd4c0xXOXdZV05wZEhrNk1UdG1hV3hzTFhKMWJHVTZibTl1ZW1WeWJ6dHpkSEp2YTJVNmJtOXVaU0lnTHo0OGNHRjBhQW9nSUNBZ0lDQWdJQ0FnSUNBZ1pEMGliU0EyTXpJdU16azFMRGMwTWk0eU5UZ2dNamd1TURNNUxEZzJMak13TkNBdE1qSXVOVFV4TERNeExqQTBJQzB5TXpFdU1qSXpMRGMxTGpFeU9DQXROREV1T1RjMkxDMHhNamt1TVRneklESXpNUzR5TlRjc0xUYzFMakV6TnlBek5pNDBOVFFzTVRFdU9EUTRJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXNXJjMk5oY0dVNlkyOXVibVZqZEc5eUxXTjFjblpoZEhWeVpUMGlNQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbGtQU0p3WVhSb016Z2lDaUFnSUNBZ0lDQWdJQ0FnSUNCemRIbHNaVDBpWm1sc2JEb2pPR0UwTVRneU8yWnBiR3d0YjNCaFkybDBlVG94TzJacGJHd3RjblZzWlRwdWIyNTZaWEp2TzNOMGNtOXJaVHB1YjI1bElpQXZQanh3WVhSb0NpQWdJQ0FnSUNBZ0lDQWdJQ0JrUFNKdElEY3hOeTQwTkRrc05qVXpMakV3TlNBdE56TXVOREVzTlRNdU16WWdMVE0yTGpRNE9Dd3RNVEV1T0RjMUlDMHhOREl1T1RBekxDMHhPVFl1TmpreUlERXdPUzQ0T0RNc0xUYzVMamd5T0NBeE5ESXVPVEU0TERFNU5pNDNNRE1nTUN3ek9DNHpNeklpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBibXR6WTJGd1pUcGpiMjV1WldOMGIzSXRZM1Z5ZG1GMGRYSmxQU0l3SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdhV1E5SW5CaGRHZzBNQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lITjBlV3hsUFNKbWFXeHNPaU00WVRReE9ESTdabWxzYkMxdmNHRmphWFI1T2pFN1ptbHNiQzF5ZFd4bE9tNXZibnBsY204N2MzUnliMnRsT201dmJtVWlJQzgrUEhCaGRHZ0tJQ0FnSUNBZ0lDQWdJQ0FnSUdROUltMGdPREk0TGpVeUxEY3dOaTQwTmpVZ0xUY3pMalF5Tml3dE5UTXVNelFnTUM0d01URXNMVE00TGpNMU9TQk1JRGc1T0M0d01EUXNOREU0TGpBM0lERXdNRGN1T1N3ME9UY3VPRGs0SURnMk5DNDVOek1zTmprMExqWXdPU0E0TWpndU5USXNOekEyTGpRMk5TSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsdWEzTmpZWEJsT21OdmJtNWxZM1J2Y2kxamRYSjJZWFIxY21VOUlqQWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcFpEMGljR0YwYURReUlnb2dJQ0FnSUNBZ0lDQWdJQ0FnYzNSNWJHVTlJbVpwYkd3Nkl6aGhOREU0TWp0bWFXeHNMVzl3WVdOcGRIazZNVHRtYVd4c0xYSjFiR1U2Ym05dWVtVnlienR6ZEhKdmEyVTZibTl1WlNJZ0x6NDhjR0YwYUFvZ0lDQWdJQ0FnSUNBZ0lDQWdaRDBpYlNBNE1USXVNRGcyTERneU9DNDFPRFlnTWpndU1EVTFMQzA0Tmk0ek1pQXpOaTQwT0RRc0xURXhMamd6TmlBeU16RXVNakkxTERjMUxqRXhOeUF0TkRFdU9UY3NNVEk1TGpFNE15QXRNak14TGpJek9Td3ROelV1TVRRZ0xUSXlMalUxTlN3dE16RXVNREEwSWdvZ0lDQWdJQ0FnSUNBZ0lDQWdhVzVyYzJOaGNHVTZZMjl1Ym1WamRHOXlMV04xY25aaGRIVnlaVDBpTUNJS0lDQWdJQ0FnSUNBZ0lDQWdJR2xrUFNKd1lYUm9ORFFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnpkSGxzWlQwaVptbHNiRG9qT0dFME1UZ3lPMlpwYkd3dGIzQmhZMmwwZVRveE8yWnBiR3d0Y25Wc1pUcHViMjU2WlhKdk8zTjBjbTlyWlRwdWIyNWxJaUF2UGp4d1lYUm9DaUFnSUNBZ0lDQWdJQ0FnSUNCa1BTSnRJRGN6Tmk0ek1ERXNNVE16TlM0NE9DQmpJQzB6TWpNdU1EUTNMREFnTFRVNE5TNDROelVzTFRJMk1pNDNPQ0F0TlRnMUxqZzNOU3d0TlRnMUxqYzRNaUF3TEMwek1qTXVNVEU0SURJMk1pNDRNamdzTFRVNE5TNDVOemNnTlRnMUxqZzNOU3d0TlRnMUxqazNOeUF6TWpNdU1ERTVMREFnTlRnMUxqZ3dPU3d5TmpJdU9EVTVJRFU0TlM0NE1Ea3NOVGcxTGprM055QXdMRE15TXk0d01ESWdMVEkyTWk0M09TdzFPRFV1TnpneUlDMDFPRFV1T0RBNUxEVTROUzQzT0RJZ2JDQXdMREFnZWlCdElEQXNMVEV4T0M0Mk1TQmpJREkxTnk0NU56SXNNQ0EwTmpjdU1UZzVMQzB5TURrdU1UTWdORFkzTGpFNE9Td3RORFkzTGpFM01pQXdMQzB5TlRndU1USTVJQzB5TURrdU1qRTNMQzAwTmpjdU16UTRJQzAwTmpjdU1UZzVMQzAwTmpjdU16UTRJQzB5TlRndU1EYzBMREFnTFRRMk55NHlOVFFzTWpBNUxqSXhPU0F0TkRZM0xqSTFOQ3cwTmpjdU16UTRJREFzTWpVNExqQTBNaUF5TURrdU1UZ3NORFkzTGpFM01pQTBOamN1TWpVMExEUTJOeTR4TnpJaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwYm10elkyRndaVHBqYjI1dVpXTjBiM0l0WTNWeWRtRjBkWEpsUFNJd0lnb2dJQ0FnSUNBZ0lDQWdJQ0FnYVdROUluQmhkR2cwTmlJS0lDQWdJQ0FnSUNBZ0lDQWdJSE4wZVd4bFBTSm1hV3hzT2lNNFlUUXhPREk3Wm1sc2JDMXZjR0ZqYVhSNU9qRTdabWxzYkMxeWRXeGxPbTV2Ym5wbGNtODdjM1J5YjJ0bE9tNXZibVVpSUM4K1BIQmhkR2dLSUNBZ0lDQWdJQ0FnSUNBZ0lHUTlJbTBnTVRBNU1TNHhNeXcyTVRrdU9EZ3pJQzB4TnpVdU56Y3hMRFUzTGpFeU1TQXhNUzQyTWprc016VXVPREE0SURFM05TNDNOaklzTFRVM0xqRXlNU0F0TVRFdU5qSXNMVE0xTGpnd09DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsdWEzTmpZWEJsT21OdmJtNWxZM1J2Y2kxamRYSjJZWFIxY21VOUlqQWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcFpEMGljR0YwYURRNElnb2dJQ0FnSUNBZ0lDQWdJQ0FnYzNSNWJHVTlJbVpwYkd3Nkl6aGhOREU0TWp0bWFXeHNMVzl3WVdOcGRIazZNVHRtYVd4c0xYSjFiR1U2Ym05dWVtVnlienR6ZEhKdmEyVTZibTl1WlNJZ0x6NDhjR0YwYUFvZ0lDQWdJQ0FnSUNBZ0lDQWdaRDBpVFNBNE5qWXVPVFUzTERrd01pNHdOelFnT0RNMkxqVXNPVEkwTGpFNU9TQTVORFV1TVRJeExERXdOek11TnpNZ09UYzFMalU0Tml3eE1EVXhMall4SURnMk5pNDVOVGNzT1RBeUxqQTNOQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbHVhM05qWVhCbE9tTnZibTVsWTNSdmNpMWpkWEoyWVhSMWNtVTlJakFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBaRDBpY0dGMGFEVXdJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2MzUjViR1U5SW1acGJHdzZJemhoTkRFNE1qdG1hV3hzTFc5d1lXTnBkSGs2TVR0bWFXeHNMWEoxYkdVNmJtOXVlbVZ5Ynp0emRISnZhMlU2Ym05dVpTSWdMejQ4Y0dGMGFBb2dJQ0FnSUNBZ0lDQWdJQ0FnWkQwaVRTQTJNRGN1TkRZMUxEa3dNeTQwTkRVZ05EazRMamcxTlN3eE1EVXlMamszSURVeU9TNHpNaXd4TURjMUxqRWdOak0zTGprekxEa3lOUzQxTmpZZ05qQTNMalEyTlN3NU1ETXVORFExSWdvZ0lDQWdJQ0FnSUNBZ0lDQWdhVzVyYzJOaGNHVTZZMjl1Ym1WamRHOXlMV04xY25aaGRIVnlaVDBpTUNJS0lDQWdJQ0FnSUNBZ0lDQWdJR2xrUFNKd1lYUm9OVElpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnpkSGxzWlQwaVptbHNiRG9qT0dFME1UZ3lPMlpwYkd3dGIzQmhZMmwwZVRveE8yWnBiR3d0Y25Wc1pUcHViMjU2WlhKdk8zTjBjbTlyWlRwdWIyNWxJaUF2UGp4d1lYUm9DaUFnSUNBZ0lDQWdJQ0FnSUNCa1BTSnRJRE00TUM0Mk9EZ3NOakl5TGpFeU9TQXRNVEV1TmpJMkxETTFMamd3TVNBeE56VXVOelU0TERVM0xqQTVJREV4TGpZeU1Td3RNelV1T0RBeElDMHhOelV1TnpVekxDMDFOeTR3T1NJS0lDQWdJQ0FnSUNBZ0lDQWdJR2x1YTNOallYQmxPbU52Ym01bFkzUnZjaTFqZFhKMllYUjFjbVU5SWpBaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwWkQwaWNHRjBhRFUwSWdvZ0lDQWdJQ0FnSUNBZ0lDQWdjM1I1YkdVOUltWnBiR3c2SXpoaE5ERTRNanRtYVd4c0xXOXdZV05wZEhrNk1UdG1hV3hzTFhKMWJHVTZibTl1ZW1WeWJ6dHpkSEp2YTJVNmJtOXVaU0lnTHo0OGNHRjBhQW9nSUNBZ0lDQWdJQ0FnSUNBZ1pEMGliU0EzTVRZdU1qZzVMRE0zTmk0MU9TQXpOeTQyTkRBMkxEQWdNQ3d4T0RRdU9ERTJJQzB6Tnk0Mk5EQTJMREFnTUN3dE1UZzBMamd4TmlCNklnb2dJQ0FnSUNBZ0lDQWdJQ0FnYVc1cmMyTmhjR1U2WTI5dWJtVmpkRzl5TFdOMWNuWmhkSFZ5WlQwaU1DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsa1BTSndZWFJvTlRZaUNpQWdJQ0FnSUNBZ0lDQWdJQ0J6ZEhsc1pUMGlabWxzYkRvak9HRTBNVGd5TzJacGJHd3RiM0JoWTJsMGVUb3hPMlpwYkd3dGNuVnNaVHB1YjI1NlpYSnZPM04wY205clpUcHViMjVsSWlBdlBqd3ZaejQ4TDJjK1BDOW5Qand2Wno0OEwzTjJaejQ9XFxcIikgbm8tcmVwZWF0LCBub25lO1xcbiAgLW1vei1iYWNrZ3JvdW5kLXNpemU6IDEwMCU7XFxuICAtby1iYWNrZ3JvdW5kLXNpemU6IDEwMCU7XFxuICAtd2Via2l0LWJhY2tncm91bmQtc2l6ZTogMTAwJTtcXG4gIGJhY2tncm91bmQtc2l6ZTogMTAwJTtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICB3aWR0aDogOTBweDtcXG4gIGhlaWdodDogMjVweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYW5uZXIgLmphc21pbmUtdmVyc2lvbiB7XFxuICBtYXJnaW4tbGVmdDogMTRweDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHRvcDogNnB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyICNqYXNtaW5lX2NvbnRlbnQge1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgcmlnaHQ6IDEwMCU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtdmVyc2lvbiB7XFxuICBjb2xvcjogI2FhYTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYW5uZXIge1xcbiAgbWFyZ2luLXRvcDogMTRweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1kdXJhdGlvbiB7XFxuICBjb2xvcjogI2ZmZjtcXG4gIGZsb2F0OiByaWdodDtcXG4gIGxpbmUtaGVpZ2h0OiAyOHB4O1xcbiAgcGFkZGluZy1yaWdodDogOXB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IHtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBtYXJnaW46IDE0cHggMDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaSB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBoZWlnaHQ6IDEwcHg7XFxuICB3aWR0aDogMTRweDtcXG4gIGZvbnQtc2l6ZTogMTZweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaS5qYXNtaW5lLXBhc3NlZCB7XFxuICBmb250LXNpemU6IDE0cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkgbGkuamFzbWluZS1wYXNzZWQ6YmVmb3JlIHtcXG4gIGNvbG9yOiAjMDA3MDY5O1xcbiAgY29udGVudDogXFxcIuKAolxcXCI7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkgbGkuamFzbWluZS1mYWlsZWQge1xcbiAgbGluZS1oZWlnaHQ6IDlweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaS5qYXNtaW5lLWZhaWxlZDpiZWZvcmUge1xcbiAgY29sb3I6ICNjYTNhMTE7XFxuICBjb250ZW50OiBcXFwiw5dcXFwiO1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBtYXJnaW4tbGVmdDogLTFweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaS5qYXNtaW5lLWV4Y2x1ZGVkIHtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaS5qYXNtaW5lLWV4Y2x1ZGVkOmJlZm9yZSB7XFxuICBjb2xvcjogI2JhYmFiYTtcXG4gIGNvbnRlbnQ6IFxcXCLigKJcXFwiO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpLmphc21pbmUtZXhjbHVkZWQtbm8tZGlzcGxheSB7XFxuICBmb250LXNpemU6IDE0cHg7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpLmphc21pbmUtcGVuZGluZyB7XFxuICBsaW5lLWhlaWdodDogMTdweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaS5qYXNtaW5lLXBlbmRpbmc6YmVmb3JlIHtcXG4gIGNvbG9yOiAjYmE5ZDM3O1xcbiAgY29udGVudDogXFxcIipcXFwiO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpLmphc21pbmUtZW1wdHkge1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpLmphc21pbmUtZW1wdHk6YmVmb3JlIHtcXG4gIGNvbG9yOiAjYmE5ZDM3O1xcbiAgY29udGVudDogXFxcIuKAolxcXCI7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtcnVuLW9wdGlvbnMge1xcbiAgZmxvYXQ6IHJpZ2h0O1xcbiAgbWFyZ2luLXJpZ2h0OiA1cHg7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjOGE0MTgyO1xcbiAgY29sb3I6ICM4YTQxODI7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBsaW5lLWhlaWdodDogMjBweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1ydW4tb3B0aW9ucyAuamFzbWluZS10cmlnZ2VyIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIHBhZGRpbmc6IDhweCAxNnB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXJ1bi1vcHRpb25zIC5qYXNtaW5lLXBheWxvYWQge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIHJpZ2h0OiAtMXB4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgIzhhNDE4MjtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlZWU7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgcGFkZGluZzogNHB4IDhweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1ydW4tb3B0aW9ucyAuamFzbWluZS1wYXlsb2FkLmphc21pbmUtb3BlbiB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYXIge1xcbiAgbGluZS1oZWlnaHQ6IDI4cHg7XFxuICBmb250LXNpemU6IDE0cHg7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGNvbG9yOiAjZWVlO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhci5qYXNtaW5lLWZhaWxlZCwgLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYXIuamFzbWluZS1lcnJvcmVkIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNjYTNhMTE7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2VlZTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYXIuamFzbWluZS1wYXNzZWQge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzAwNzA2OTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYXIuamFzbWluZS1pbmNvbXBsZXRlIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNiYWJhYmE7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFyLmphc21pbmUtc2tpcHBlZCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjYmFiYWJhO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhci5qYXNtaW5lLXdhcm5pbmcge1xcbiAgbWFyZ2luLXRvcDogMTRweDtcXG4gIG1hcmdpbi1ib3R0b206IDE0cHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjYmE5ZDM3O1xcbiAgY29sb3I6ICMzMzM7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFyLmphc21pbmUtbWVudSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgY29sb3I6ICNhYWE7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFyLmphc21pbmUtbWVudSBhIHtcXG4gIGNvbG9yOiAjMzMzO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhciBhIHtcXG4gIGNvbG9yOiB3aGl0ZTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlci5qYXNtaW5lLXNwZWMtbGlzdCAuamFzbWluZS1iYXIuamFzbWluZS1tZW51Lmphc21pbmUtZmFpbHVyZS1saXN0LFxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIuamFzbWluZS1zcGVjLWxpc3QgLmphc21pbmUtcmVzdWx0cyAuamFzbWluZS1mYWlsdXJlcyB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyLmphc21pbmUtZmFpbHVyZS1saXN0IC5qYXNtaW5lLWJhci5qYXNtaW5lLW1lbnUuamFzbWluZS1zcGVjLWxpc3QsXFxuLmphc21pbmVfaHRtbC1yZXBvcnRlci5qYXNtaW5lLWZhaWx1cmUtbGlzdCAuamFzbWluZS1zdW1tYXJ5IHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtcmVzdWx0cyB7XFxuICBtYXJnaW4tdG9wOiAxNHB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1bW1hcnkge1xcbiAgbWFyZ2luLXRvcDogMTRweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdW1tYXJ5IHVsIHtcXG4gIGxpc3Qtc3R5bGUtdHlwZTogbm9uZTtcXG4gIG1hcmdpbi1sZWZ0OiAxNHB4O1xcbiAgcGFkZGluZy10b3A6IDA7XFxuICBwYWRkaW5nLWxlZnQ6IDA7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3VtbWFyeSB1bC5qYXNtaW5lLXN1aXRlIHtcXG4gIG1hcmdpbi10b3A6IDdweDtcXG4gIG1hcmdpbi1ib3R0b206IDdweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdW1tYXJ5IGxpLmphc21pbmUtcGFzc2VkIGEge1xcbiAgY29sb3I6ICMwMDcwNjk7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3VtbWFyeSBsaS5qYXNtaW5lLWZhaWxlZCBhIHtcXG4gIGNvbG9yOiAjY2EzYTExO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1bW1hcnkgbGkuamFzbWluZS1lbXB0eSBhIHtcXG4gIGNvbG9yOiAjYmE5ZDM3O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1bW1hcnkgbGkuamFzbWluZS1wZW5kaW5nIGEge1xcbiAgY29sb3I6ICNiYTlkMzc7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3VtbWFyeSBsaS5qYXNtaW5lLWV4Y2x1ZGVkIGEge1xcbiAgY29sb3I6ICNiYWJhYmE7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3BlY3MgbGkuamFzbWluZS1wYXNzZWQgYTpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIuKAoiBcXFwiO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXNwZWNzIGxpLmphc21pbmUtZmFpbGVkIGE6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCLDlyBcXFwiO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXNwZWNzIGxpLmphc21pbmUtZW1wdHkgYTpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIiogXFxcIjtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zcGVjcyBsaS5qYXNtaW5lLXBlbmRpbmcgYTpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIuKAoiBcXFwiO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXNwZWNzIGxpLmphc21pbmUtZXhjbHVkZWQgYTpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIuKAoiBcXFwiO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWRlc2NyaXB0aW9uICsgLmphc21pbmUtc3VpdGUge1xcbiAgbWFyZ2luLXRvcDogMDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdWl0ZSB7XFxuICBtYXJnaW4tdG9wOiAxNHB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1aXRlIGEge1xcbiAgY29sb3I6ICMzMzM7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZmFpbHVyZXMgLmphc21pbmUtc3BlYy1kZXRhaWwge1xcbiAgbWFyZ2luLWJvdHRvbTogMjhweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1mYWlsdXJlcyAuamFzbWluZS1zcGVjLWRldGFpbCAuamFzbWluZS1kZXNjcmlwdGlvbiB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjY2EzYTExO1xcbiAgY29sb3I6IHdoaXRlO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWZhaWx1cmVzIC5qYXNtaW5lLXNwZWMtZGV0YWlsIC5qYXNtaW5lLWRlc2NyaXB0aW9uIGEge1xcbiAgY29sb3I6IHdoaXRlO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXJlc3VsdC1tZXNzYWdlIHtcXG4gIHBhZGRpbmctdG9wOiAxNHB4O1xcbiAgY29sb3I6ICMzMzM7XFxuICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtcmVzdWx0LW1lc3NhZ2Ugc3Bhbi5qYXNtaW5lLXJlc3VsdCB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdGFjay10cmFjZSB7XFxuICBtYXJnaW46IDVweCAwIDAgMDtcXG4gIG1heC1oZWlnaHQ6IDIyNHB4O1xcbiAgb3ZlcmZsb3c6IGF1dG87XFxuICBsaW5lLWhlaWdodDogMThweDtcXG4gIGNvbG9yOiAjNjY2O1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2RkZDtcXG4gIGJhY2tncm91bmQ6IHdoaXRlO1xcbiAgd2hpdGUtc3BhY2U6IHByZTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1leHBhbmRlciBhIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgbWFyZ2luLWxlZnQ6IDE0cHg7XFxuICBjb2xvcjogYmx1ZTtcXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWV4cGFuZGVyLWNvbnRlbnRzIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZXhwYW5kZWQge1xcbiAgcGFkZGluZy1ib3R0b206IDEwcHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZXhwYW5kZWQgLmphc21pbmUtZXhwYW5kZXItY29udGVudHMge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBtYXJnaW4tbGVmdDogMTRweDtcXG4gIHBhZGRpbmc6IDVweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1kZWJ1Zy1sb2cge1xcbiAgbWFyZ2luOiA1cHggMCAwIDA7XFxuICBwYWRkaW5nOiA1cHg7XFxuICBjb2xvcjogIzY2NjtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNkZGQ7XFxuICBiYWNrZ3JvdW5kOiB3aGl0ZTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1kZWJ1Zy1sb2cgdGFibGUge1xcbiAgYm9yZGVyLXNwYWNpbmc6IDA7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZGVidWctbG9nIHRhYmxlLCAuamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWRlYnVnLWxvZyB0aCwgLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1kZWJ1Zy1sb2cgdGQge1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2RkZDtcXG59XCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vbm9kZV9tb2R1bGVzL2phc21pbmUtY29yZS9saWIvamFzbWluZS1jb3JlL2phc21pbmUuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBLGdCQUFnQjtBQUNoQjtFQUNFLGtCQUFrQjtBQUNwQjs7QUFFQTtFQUNFLFdBQVc7RUFDWCxzQkFBc0I7RUFDdEIsWUFBWTtFQUNaLFlBQVk7RUFDWixlQUFlO0VBQ2YsZ0RBQWdEO0VBQ2hELGlCQUFpQjtFQUNqQixXQUFXO0FBQ2I7QUFDQTtFQUNFLHFCQUFxQjtBQUN2QjtBQUNBO0VBQ0UsMEJBQTBCO0FBQzVCO0FBQ0E7RUFDRSxTQUFTO0VBQ1QsaUJBQWlCO0FBQ25CO0FBQ0E7Ozs7Ozs7O0VBUUUsaUJBQWlCO0VBQ2pCLGtCQUFrQjtBQUNwQjtBQUNBO0VBQ0Usa0JBQWtCO0FBQ3BCO0FBQ0E7RUFDRSxteUVBQW15RTtFQUNueUUsaWtYQUFpa1g7RUFDamtYLDBCQUEwQjtFQUMxQix3QkFBd0I7RUFDeEIsNkJBQTZCO0VBQzdCLHFCQUFxQjtFQUNyQixjQUFjO0VBQ2QsV0FBVztFQUNYLFdBQVc7RUFDWCxZQUFZO0FBQ2Q7QUFDQTtFQUNFLGlCQUFpQjtFQUNqQixrQkFBa0I7RUFDbEIsUUFBUTtBQUNWO0FBQ0E7RUFDRSxlQUFlO0VBQ2YsV0FBVztBQUNiO0FBQ0E7RUFDRSxXQUFX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QUN0QjtBQUNBO0VBQ0UsY0FBYztFQUNkLGlCQUFpQjtFQUNqQixZQUFZO0FBQ2Q7QUFDQTtFQUNFLGlCQUFpQjtFQUNqQixZQUFZO0VBQ1osV0FBVztFQUNYLHNCQUFzQjtFQUN0QixpQkFBaUI7QUFDbkI7QUFDQTtFQUNFLGlCQUFpQjtBQUNuQjtBQUNBO0VBQ0Usc0JBQXNCO0FBQ3hCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIkBjaGFyc2V0IFxcXCJVVEYtOFxcXCI7XFxuYm9keSB7XFxuICBvdmVyZmxvdy15OiBzY3JvbGw7XFxufVxcblxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlO1xcbiAgcGFkZGluZzogNXB4O1xcbiAgbWFyZ2luOiAtOHB4O1xcbiAgZm9udC1zaXplOiAxMXB4O1xcbiAgZm9udC1mYW1pbHk6IE1vbmFjbywgXFxcIkx1Y2lkYSBDb25zb2xlXFxcIiwgbW9ub3NwYWNlO1xcbiAgbGluZS1oZWlnaHQ6IDE0cHg7XFxuICBjb2xvcjogIzMzMztcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciBhIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciBhOmhvdmVyIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIHAsIC5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgaDEsIC5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgaDIsIC5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgaDMsIC5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgaDQsIC5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgaDUsIC5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgaDYge1xcbiAgbWFyZ2luOiAwO1xcbiAgbGluZS1oZWlnaHQ6IDE0cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFubmVyLFxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnksXFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdW1tYXJ5LFxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtcmVzdWx0LW1lc3NhZ2UsXFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zcGVjIC5qYXNtaW5lLWRlc2NyaXB0aW9uLFxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3BlYy1kZXRhaWwgLmphc21pbmUtZGVzY3JpcHRpb24sXFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1hbGVydCAuamFzbWluZS1iYXIsXFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdGFjay10cmFjZSB7XFxuICBwYWRkaW5nLWxlZnQ6IDlweDtcXG4gIHBhZGRpbmctcmlnaHQ6IDlweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYW5uZXIge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhbm5lciAuamFzbWluZS10aXRsZSB7XFxuICBiYWNrZ3JvdW5kOiB1cmwoXFxcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBRm9BQUFBWkNBTUFBQUNHdXNueUFBQUNkbEJNVkVYLy8vLy9BUCtBZ0lDcVZhcUFRSUNaTTVtQVZZQ1NTWktBUUlDT09ZNkFUWUNMUm91QVFJQ0pPNG1TU1lDSVJJaVBRSUNIUEllT1I0Q0dRNGFNUUlDR1BZYUxSb0NGUTRXS1FJQ1BQWVdKUllDT1FvU0pRSUNOUG9TSVJJQ01Rb1NIUUlDSFJJQ0tRb09IUUlDS1BvT0pPNE9KUVlPTVFJQ01RNENJUVlLTFFJQ0lQb0tMUTRDS1FJQ05Qb0tKUUlTTVE0S0pRb1NMUVlLSlFJU0xRNEtJUW9TS1FZS0lRSUNJUUlTTVFvU0tRWUtMUUlPTFFvT0pRWUdMUUlPS1FJT01Rb0dLUVlPTFFZR0tRSU9MUW9HSlFZT0pRSU9LUVlHSlFJT0tRb0dLUUlHTFFJS0xRNEtLUW9HTFFZS0pRSUdLUVlLSlFJR0tRSUtKUW9HS1FZS0xRSUdLUVlLTFFJT0pRb0tLUW9PSlFZS0tRSU9KUW9LS1FvT0tRSU9MUW9LS1FZT0xRWUtKUUlPS1FvS0tRWUtLUW9LSlFZT0tRWUtMUUlPS1FvS0xRWU9LUVlLTFFJT0pRb0dLUVlLSlFZR0pRb0dLUVlLTFFvR0xRWUdLUW9HSlFZS0tRWUdKUUlLS1FvR0pRWUtMUUlLS1FZR0xRWUtLUVlHS1FZR0tRWUtKUVlPS1FvS0pRWU9LUVlLTFFZT0xRWU9LUVlLTFFZT0tRb0tLUVlLS1FZT0tRWU9KUVlLS1FZS0xRWUtLUUlLS1FvS0tRWUtLUVlLS1FvS0pRSUtLUVlLTFFZS0tRWUtLUUlLS1FZS0tRWUtLUVlLS1FJS0tRWUtKUVlHTFFZR0tRWUtLUVlLS1FZR0tRSUtLUVlHS1FZT0pRb0tLUVlPTFFZS0tRWU9LUW9LS1FZS0tRb0tLUVlLS1FZS0pRWUtMUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtKUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtMUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLbUlEcEVBQUFBMFhSU1RsTUFBUUlEQkFVR0J3Z0pDZ3NNRFE0UEVCRVNFeFFWRmhjWUdSb2JIQjBlSHlBaUl5UWxKeWNvS2lzc0xTNHdNVFExTmpjNE9UbzdQRHcrUDBCQ1EwUklTVXBMVEUxT1VGTlVWVmRZV0ZsYVcxNWZZR0ZpWTJabmFHbHFhMnh0YjNCeGNuTjBkbmg1ZW50OGZYNS9nSUdDaElXSWlveU5qbytRa1pPVWxaYVltWnFibkoyZW9LR2lvNldtcUttc3JhNnZzTEd6dHJlNHVicTd2TDIrd01IRHhNakp5c3ZOenMvUTBkTFUxdGZZMmR2YzN0L2c0ZUxqNWVibjZPbnE2K3p0N3Uvdzh2UDA5ZmIzK1BuNisvejkvdmtWUVhBQUFBTWFTVVJCVkhoZTVkWHhWMU4xR01meHoyQUJiRGdJQW01VkRKT3lWRElKTFVNYVZwQldVWlVhR2JtcW9HcFpSU2lHaVJXcDZLb1o1QUIwWlk1MFJJbVpRSWxhaEtrTVlYdi9SOTBkQnZFVC9ySmZPcjNPdWM4djk5elBlYzU5enZmNTZqK3ZZS2xWaVNmNzI1MFg0TXIzTzI5VGdxMDhCZEdCNERoY2VrRUo1WWtRS0ZzZ1daZHRqOUpwVitJOHhQakxGcWtyc0VJcU84UEhTcGlzMzZqV2F6Y3FqRXNmSmprdlJzc1ZVMzdTZElPdTRYQ2Y1dkVKUHNud0pwblJOVTlKbXhoTWs4bDFnZWhJcnE3aFRGanpPRCtWZjg4NjI5cUtNSlZObHRJbkZlUmV4UlF5SmxOZXFkMWlHRGxTenJJVUl5WGJ5RmZtM1JZcHJjUVJlN2xxdFd5R1liZmM2ZFQwUjJ2bWRPT2tYM3U1NUMxclAzN2Z0aUgrdERieTRyL1JCVDB3OFR5RWtyK2VwQjlYZ1BEbVNZWVdicmhDdUZZYUl5dzNmRFFBWFRuU2toK0FOb2ZpSG1XZjlsK0ZZMUk5MEZkUVRldHN0TzAwbzIzbm92elZzSjd1QjMvQzVUa2JqUndaNUplcndWNGlSV3E5SEZiRk1hSy9kMFRZcWF5UmlRUHVJeHhTM0J1OEpXVTkwLzYwdEtpN3ZraGF6bmV6MGEvVGJWT0tqNUNhT1poNmZXRzYvTHl2OUIvWkxSMWd3L1MvZnBiZVZEM01DVzFsaTZTdldET242NXRyOTkvdXZXdEJTMFhEbTRzMXQrc09IcEcwa3BCS3gvbDc3d09TbnhMcGN4NlRYbVhMVFBRT0tZT2Y5UTFkZnI4L1NKMm1GZEN2bDFZbDkzRGlIVVp2WGVMSmJHU3pZdTVnVkoyc2xiU2FrT1I4ZHhDcTVhZFEyb0ZMcXNFOUV4M0w0cVFPMGVPUGVVNXg1NmJ5cFhwNG9uU0ViNU9rSUNYNmxEYXQ1NVRlb3p0TktRY0phYWtyejlLQ2I5NW9ENjlJS3EreUtXNFhQamtuYVM1MlYwVFpxRTJjVHRYamNIU0NSbVVPODhlKzg1aGozRVA3NGk5cDhweWx3N2x4Z01EeXlsNk9WN1plam5qTk1mYXR1ODdMeFJiSDBJUzM1Z3QyYTRaam1HcFZCZEtLM1dyNklOazhqV1dTR3FiQTU1Q0tnakJSQzZFOXc3OHlkVGczQUJTM0FGVjFRTjBZNEFhMnBnRWpXblFVUmo5TDBheUs2UjJ5c0VxeEhVS3pZbkx2dnlVK2k5S00ySkhKekU0dnlaT3lEY093T3N5U2FqZUxQYzhzTnZQSmtGbHlKZDIwd3BxQXpaZUFmWjNvV3lieGQrUC8zaitTRzN1U0JkZjJWUUFBQUFCSlJVNUVya0pnZ2c9PVxcXCIpIG5vLXJlcGVhdDtcXG4gIGJhY2tncm91bmQ6IHVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQRDk0Yld3Z2RtVnljMmx2YmowaU1TNHdJaUJsYm1OdlpHbHVaejBpVlZSR0xUZ2lJSE4wWVc1a1lXeHZibVU5SW01dklqOCtDandoTFMwZ1EzSmxZWFJsWkNCM2FYUm9JRWx1YTNOallYQmxJQ2hvZEhSd09pOHZkM2QzTG1sdWEzTmpZWEJsTG05eVp5OHBJQzB0UGdvS1BITjJad29nSUNCNGJXeHVjenBrWXowaWFIUjBjRG92TDNCMWNtd3ViM0puTDJSakwyVnNaVzFsYm5Sekx6RXVNUzhpQ2lBZ0lIaHRiRzV6T21OalBTSm9kSFJ3T2k4dlkzSmxZWFJwZG1WamIyMXRiMjV6TG05eVp5OXVjeU1pQ2lBZ0lIaHRiRzV6T25Ka1pqMGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNVGs1T1M4d01pOHlNaTF5WkdZdGMzbHVkR0Y0TFc1ekl5SUtJQ0FnZUcxc2JuTTZjM1puUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJS0lDQWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklnb2dJQ0I0Yld4dWN6cHBibXR6WTJGd1pUMGlhSFIwY0RvdkwzZDNkeTVwYm10elkyRndaUzV2Y21jdmJtRnRaWE53WVdObGN5OXBibXR6WTJGd1pTSUtJQ0FnZG1WeWMybHZiajBpTVM0eElnb2dJQ0IzYVdSMGFEMGlOamd4TGprMk1qVXlJZ29nSUNCb1pXbG5hSFE5SWpFNE55NDFJZ29nSUNCcFpEMGljM1puTWlJS0lDQWdlRzFzT25Od1lXTmxQU0p3Y21WelpYSjJaU0krUEcxbGRHRmtZWFJoQ2lBZ0lDQWdhV1E5SW0xbGRHRmtZWFJoT0NJK1BISmtaanBTUkVZK1BHTmpPbGR2Y21zS0lDQWdJQ0FnSUNBZ2NtUm1PbUZpYjNWMFBTSWlQanhrWXpwbWIzSnRZWFErYVcxaFoyVXZjM1puSzNodGJEd3ZaR002Wm05eWJXRjBQanhrWXpwMGVYQmxDaUFnSUNBZ0lDQWdJQ0FnY21SbU9uSmxjMjkxY21ObFBTSm9kSFJ3T2k4dmNIVnliQzV2Y21jdlpHTXZaR050YVhSNWNHVXZVM1JwYkd4SmJXRm5aU0lnTHo0OEwyTmpPbGR2Y21zK1BDOXlaR1k2VWtSR1Bqd3ZiV1YwWVdSaGRHRStQR1JsWm5NS0lDQWdJQ0JwWkQwaVpHVm1jellpUGp4amJHbHdVR0YwYUFvZ0lDQWdJQ0FnYVdROUltTnNhWEJRWVhSb01UZ2lQanh3WVhSb0NpQWdJQ0FnSUNBZ0lHUTlJazBnTUN3eE5UQXdJREFzTUNCc0lEVTBOVFV1TnpRc01DQXdMREUxTURBZ1RDQXdMREUxTURBZ2VpSUtJQ0FnSUNBZ0lDQWdhVzVyYzJOaGNHVTZZMjl1Ym1WamRHOXlMV04xY25aaGRIVnlaVDBpTUNJS0lDQWdJQ0FnSUNBZ2FXUTlJbkJoZEdneU1DSWdMejQ4TDJOc2FYQlFZWFJvUGp3dlpHVm1jejQ4WndvZ0lDQWdJSFJ5WVc1elptOXliVDBpYldGMGNtbDRLREV1TWpVc01Dd3dMQzB4TGpJMUxEQXNNVGczTGpVcElnb2dJQ0FnSUdsa1BTSm5NVEFpUGp4bkNpQWdJQ0FnSUNCMGNtRnVjMlp2Y20wOUluTmpZV3hsS0RBdU1Td3dMakVwSWdvZ0lDQWdJQ0FnYVdROUltY3hNaUkrUEdjS0lDQWdJQ0FnSUNBZ2FXUTlJbWN4TkNJK1BHY0tJQ0FnSUNBZ0lDQWdJQ0JqYkdsd0xYQmhkR2c5SW5WeWJDZ2pZMnhwY0ZCaGRHZ3hPQ2tpQ2lBZ0lDQWdJQ0FnSUNBZ2FXUTlJbWN4TmlJK1BIQmhkR2dLSUNBZ0lDQWdJQ0FnSUNBZ0lHUTlJbTBnTVRVME5DdzFPVGt1TkRNMElHTWdNQzQ1TWl3dE5EQXVNelV5SURJMUxqWTRMQzA0TVM0Mk1ESWdOekV1TlRNc0xUZ3hMall3TWlBeU55NDFNU3d3SURRM0xqWTRMREV5TGpnek1pQTJNUzQwTkN3ek5TNDNOVFFnTVRJdU9ETXNNakl1T1RNZ01USXVPRE1zTlRZdU9EVXlJREV5TGpnekxEZ3lMalV5TnlCc0lEQXNNekk1TGpFNE5DQXROekV1TlRJc01DQXdMREV3TkM0MU5ETWdNalkyTGpnekxEQWdNQ3d0TVRBMExqVTBNeUF0TnpBdU5pd3dJREFzTFRNME5DNDNOeUJqSURBc0xUVTRMalk1TVNBdE15NDJPQ3d0TVRBMExqVXpNU0F0TkRRdU9UTXNMVEUxTWk0eU1UZ2dMVE0yTGpZNExDMDBNaTR4T0NBdE9UWXVNamdzTFRZMkxqQXlJQzB4TlRNdU1UUXNMVFkyTGpBeUlDMHhNVGN1TXpjc01DQXRNakEzTGpJMExEYzNMamswTVNBdE1qQXlMalkwTERFNU55NHhORFVnYkNBeE16QXVNaXd3SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdhVzVyYzJOaGNHVTZZMjl1Ym1WamRHOXlMV04xY25aaGRIVnlaVDBpTUNJS0lDQWdJQ0FnSUNBZ0lDQWdJR2xrUFNKd1lYUm9NaklpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnpkSGxzWlQwaVptbHNiRG9qT0dFME1UZ3lPMlpwYkd3dGIzQmhZMmwwZVRveE8yWnBiR3d0Y25Wc1pUcHViMjU2WlhKdk8zTjBjbTlyWlRwdWIyNWxJaUF2UGp4d1lYUm9DaUFnSUNBZ0lDQWdJQ0FnSUNCa1BTSnRJREl6TURFdU5DdzJOakl1TmprMUlHTWdNQ3c0TUM0M01ETWdMVFkyTGprMExERTBOUzQ0TVRNZ0xURTBOeTQyTXl3eE5EVXVPREV6SUMwNE15NDBOQ3d3SUMweE5EY3VOak1zTFRZNExqYzRNU0F0TVRRM0xqWXpMQzB4TlRFdU16QXhJREFzTFRjNUxqYzROU0EyTmk0NU5Dd3RNVFExTGpnd01TQXhORFV1T0N3dE1UUTFMamd3TVNBNE5DNHpOU3d3SURFME9TNDBOaXcyTnk0NE5USWdNVFE1TGpRMkxERTFNUzR5T0RrZ2VpQnRJQzB4TGpnekxDMHhPREV1TlRRM0lHTWdMVE0xTGpjM0xDMDFOQzR3T1RjZ0xUa3pMalV6TEMwM09DNDROVGtnTFRFMU55NDNNaXd0TnpndU9EVTVJQzB4TkRBdU15d3dJQzB5TlRFdU1qUXNNVEUyTGpRME9TQXRNalV4TGpJMExESTFOQzQ1TVRnZ01Dd3hOREl1TVRJNUlERXhNeTQzTERJMk1DNDBNU0F5TlRZdU56UXNNall3TGpReElEWXpMakkzTERBZ01URTRMakk1TEMweU9TNHpNellnTVRVeUxqSXlMQzA0TWk0MU1qTWdiQ0F3TERZNUxqWTROeUF4TnpVdU1UUXNNQ0F3TEMweE1EUXVOVEkzSUMwMk1TNDBOQ3d3SURBc0xUSTRNQzQxT1RnZ05qRXVORFFzTUNBd0xDMHhNRFF1TlRJM0lDMHhOelV1TVRRc01DQXdMRFkyTGpBeE9TSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsdWEzTmpZWEJsT21OdmJtNWxZM1J2Y2kxamRYSjJZWFIxY21VOUlqQWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcFpEMGljR0YwYURJMElnb2dJQ0FnSUNBZ0lDQWdJQ0FnYzNSNWJHVTlJbVpwYkd3Nkl6aGhOREU0TWp0bWFXeHNMVzl3WVdOcGRIazZNVHRtYVd4c0xYSjFiR1U2Ym05dWVtVnlienR6ZEhKdmEyVTZibTl1WlNJZ0x6NDhjR0YwYUFvZ0lDQWdJQ0FnSUNBZ0lDQWdaRDBpYlNBeU5qSXlMak16TERVMU55NHlOVGdnWXlBekxqWTNMQzAwTkM0d01UWWdNek11TURFc0xUY3pMak0wT0NBM09DNDROaXd0TnpNdU16UTRJRE16TGprekxEQWdOall1T1RNc01qTXVPREkwSURZMkxqa3pMRFl3TGpVd05DQXdMRFE0TGpZd05pQXRORFV1T0RRc05UWXVPRFUySUMwNE15NDBOQ3cyTmk0NU5ERWdMVGcxTGpJNExESXlMakF3TkNBdE1UYzRMamd4TERRNExqWXdOaUF0TVRjNExqZ3hMREUxTlM0NE56a2dNQ3c1TXk0MU16WWdOemd1T0RZc01UUTNMall6TXlBeE5qVXVPVGdzTVRRM0xqWXpNeUEwTkN3d0lEZ3pMalF6TEMwNUxqRTNOaUF4TVRBdU9UUXNMVFEwTGpBd09DQnNJREFzTXpNdU9USXlJRGd5TGpVekxEQWdNQ3d0TVRNeUxqazJOU0F0TVRBNExqSXhMREFnWXlBdE1TNDRNeXd6TkM0NE5UWWdMVEk0TGpReUxEVTNMamMzTkNBdE5qTXVNallzTlRjdU56YzBJQzB6TUM0eU5pd3dJQzAyTWk0ek5Td3RNVGN1TkRJeUlDMDJNaTR6TlN3dE5URXVNelE0SURBc0xUUTFMamcwTnlBME5DNDVNeXd0TlRVdU9UTWdPREF1Tmprc0xUWTBMakU0SURnNExqQXlMQzB5TUM0eE56VWdNVGd5TGpRM0xDMDBOeTQyT1RVZ01UZ3lMalEzTEMweE5UY3VOek0wSURBc0xUazVMakF5TnlBdE9ETXVORFFzTFRFMU5DNHdNemtnTFRFM05TNHhNeXd0TVRVMExqQXpPU0F0TkRrdU5UTXNNQ0F0T1RRdU5EWXNNVFV1TlRneUlDMHhNall1TlRVc05UTXVNVGdnYkNBd0xDMDBNQzR6TkNBdE9EVXVNamNzTUNBd0xERTBNaTR4TWprZ01URTBMall5TERBaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwYm10elkyRndaVHBqYjI1dVpXTjBiM0l0WTNWeWRtRjBkWEpsUFNJd0lnb2dJQ0FnSUNBZ0lDQWdJQ0FnYVdROUluQmhkR2d5TmlJS0lDQWdJQ0FnSUNBZ0lDQWdJSE4wZVd4bFBTSm1hV3hzT2lNNFlUUXhPREk3Wm1sc2JDMXZjR0ZqYVhSNU9qRTdabWxzYkMxeWRXeGxPbTV2Ym5wbGNtODdjM1J5YjJ0bE9tNXZibVVpSUM4K1BIQmhkR2dLSUNBZ0lDQWdJQ0FnSUNBZ0lHUTlJbTBnTWprNE9DNHhPQ3c0TURBdU1qVTBJQzAyTXk0eU5pd3dJREFzTVRBMExqVXlOeUF4TmpVdU1EVXNNQ0F3TEMwM015NHpOVFVnWXlBek1TNHhPQ3cxTVM0ek5EY2dOemd1T0RZc09EVXVNamMzSURFME1TNHlNU3c0TlM0eU56Y2dOamN1T0RVc01DQXhNalF1TnpFc0xUUXhMakkxT0NBeE5USXVNakVzTFRFd01pNDJPVGtnTWpZdU5pdzJNaTR6TlRFZ09USXVOaklzTVRBeUxqWTVPU0F4TmpBdU5EY3NNVEF5TGpZNU9TQTFNeTR4T1N3d0lERXdOUzQwTml3dE1qSWdNVFF4TGpJeExDMDJNaTR6TlRFZ016Z3VOVElzTFRRMExqa3pPQ0F6T0M0MU1pd3RPVE11TlRNeUlETTRMalV5TEMweE5Ea3VORFUzSUd3Z01Dd3RNVGcxTGpJek9TQTJNeTR5Tnl3d0lEQXNMVEV3TkM0MU1qY2dMVEl6T0M0ME1pd3dJREFzTVRBMExqVXlOeUEyTXk0eU9Dd3dJREFzTVRVM0xqY3hOU0JqSURBc016SXVNVEF5SURBc05qQXVOVEkzSUMweE5DNDJOeXc0T0M0NU5UY2dMVEU0TGpNMExESTJMalU0TWlBdE5EZ3VOakVzTkRBdU16UTBJQzAzT1M0M055dzBNQzR6TkRRZ0xUTXdMakkyTERBZ0xUWXpMakk0TEMweE1pNDRORFFnTFRneUxqVXpMQzB6Tmk0Mk56SWdMVEl5TGprekxDMHlPUzR6TlRVZ0xUSXlMamt6TEMwMU5pNDROak1nTFRJeUxqa3pMQzA1TWk0Mk1qa2diQ0F3TEMweE5UY3VOekUxSURZekxqSTNMREFnTUN3dE1UQTBMalV5TnlBdE1qTTRMalF4TERBZ01Dd3hNRFF1TlRJM0lEWXpMakk0TERBZ01Dd3hOVEF1TXpneklHTWdNQ3d5T1M0ek5EZ2dNQ3cyTmk0d01qTWdMVEUwTGpZM0xEa3hMalk1T1NBdE1UVXVOVGtzTWprdU16TTJJQzAwTnk0Mk9TdzBOQzQ1TXpRZ0xUZ3dMamNzTkRRdU9UTTBJQzB6TVM0eE9Dd3dJQzAxTnk0M055d3RNVEV1TURBNElDMDNOeTQ1TkN3dE16VXVOemMwSUMweU5DNDNOeXd0TXpBdU1qVXpJQzB5Tmk0MkxDMDJNaTR6TkRNZ0xUSTJMallzTFRrNUxqazBNU0JzSURBc0xURTFNUzR6TURFZ05qTXVNamNzTUNBd0xDMHhNRFF1TlRJM0lDMHlNemd1TkN3d0lEQXNNVEEwTGpVeU55QTJNeTR5Tml3d0lEQXNNamd3TGpVNU9DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsdWEzTmpZWEJsT21OdmJtNWxZM1J2Y2kxamRYSjJZWFIxY21VOUlqQWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcFpEMGljR0YwYURJNElnb2dJQ0FnSUNBZ0lDQWdJQ0FnYzNSNWJHVTlJbVpwYkd3Nkl6aGhOREU0TWp0bWFXeHNMVzl3WVdOcGRIazZNVHRtYVd4c0xYSjFiR1U2Ym05dWVtVnlienR6ZEhKdmEyVTZibTl1WlNJZ0x6NDhjR0YwYUFvZ0lDQWdJQ0FnSUNBZ0lDQWdaRDBpYlNBek9UazRMalkyTERrMU1TNDFORGNnTFRFeE1TNDROeXd3SURBc01URTRMakk1TXlBeE1URXVPRGNzTUNBd0xDMHhNVGd1TWpreklIb2diU0F3TEMwME16RXVPRGt4SURZekxqSTNMREFnTUN3dE1UQTBMalV5TnlBdE1qTTVMak16TERBZ01Dd3hNRFF1TlRJM0lEWTBMakU1TERBZ01Dd3lPREF1TlRrNElDMDJNeTR5Tnl3d0lEQXNNVEEwTGpVeU55QXhOelV1TVRRc01DQXdMQzB6T0RVdU1USTFJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXNXJjMk5oY0dVNlkyOXVibVZqZEc5eUxXTjFjblpoZEhWeVpUMGlNQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbGtQU0p3WVhSb016QWlDaUFnSUNBZ0lDQWdJQ0FnSUNCemRIbHNaVDBpWm1sc2JEb2pPR0UwTVRneU8yWnBiR3d0YjNCaFkybDBlVG94TzJacGJHd3RjblZzWlRwdWIyNTZaWEp2TzNOMGNtOXJaVHB1YjI1bElpQXZQanh3WVhSb0NpQWdJQ0FnSUNBZ0lDQWdJQ0JrUFNKdElEUXhOVGt1TVRJc09EQXdMakkxTkNBdE5qTXVNamNzTUNBd0xERXdOQzQxTWpjZ01UYzFMakUwTERBZ01Dd3ROamt1TmpnM0lHTWdNamt1TXpVc05UUXVNVEF4SURnMExqTTJMRGd3TGpZNU9TQXhORFF1T0Rjc09EQXVOams1SURVekxqRTVMREFnTVRBMUxqUTFMQzB5TWk0d01UWWdNVFF4TGpJeUxDMDJNQzQxTWpjZ05EQXVNelFzTFRRMExqa3pOQ0EwTVM0eU5pd3RPRGd1TURNeUlEUXhMakkyTEMweE5ETXVPVFUzSUd3Z01Dd3RNVGt4TGpZMU15QTJNeTR5Tnl3d0lEQXNMVEV3TkM0MU1qY2dMVEl6T0M0MExEQWdNQ3d4TURRdU5USTNJRFl6TGpJMkxEQWdNQ3d4TlRndU5qTTNJR01nTUN3ek1DNHlOaklnTUN3Mk1TNDBNelFnTFRFNUxqSTJMRGc0TGpBek5TQXRNakF1TVRjc01qWXVOVGd5SUMwMU15NHhPQ3d6T1M0ME1UUWdMVGcyTGpFNUxETTVMalF4TkNBdE16TXVPVE1zTUNBdE5qZ3VOemNzTFRFekxqYzFJQzA0T0M0NU5Dd3ROREV1TWpVZ0xUSXhMakE1TEMweU55NDFJQzB5TVM0d09Td3ROamt1TmpnM0lDMHlNUzR3T1N3dE1UQXlMamN3TnlCc0lEQXNMVEUwTWk0eE1qa2dOak11TWpZc01DQXdMQzB4TURRdU5USTNJQzB5TXpndU5Dd3dJREFzTVRBMExqVXlOeUEyTXk0eU55d3dJREFzTWpnd0xqVTVPQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbHVhM05qWVhCbE9tTnZibTVsWTNSdmNpMWpkWEoyWVhSMWNtVTlJakFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBaRDBpY0dGMGFETXlJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2MzUjViR1U5SW1acGJHdzZJemhoTkRFNE1qdG1hV3hzTFc5d1lXTnBkSGs2TVR0bWFXeHNMWEoxYkdVNmJtOXVlbVZ5Ynp0emRISnZhMlU2Ym05dVpTSWdMejQ4Y0dGMGFBb2dJQ0FnSUNBZ0lDQWdJQ0FnWkQwaWJTQTFNRGd5TGpRNExEY3dNeTQ1TmpVZ1l5QXRNVGt1TWpRc056QXVOakExSUMwNE1TNDJMREV4TlM0MU5EY2dMVEUxTkM0d05Dd3hNVFV1TlRRM0lDMDJOaTR3TkN3d0lDMHhNamt1TXl3dE5URXVNelE0SUMweE5ETXVNRFVzTFRFeE5TNDFORGNnYkNBeU9UY3VNRGtzTUNCNklHMGdPRFV1TWpjc0xURTBOQzQ0T0RNZ1l5QXRNemd1TlRFc0xUa3pMalV5TXlBdE1USTVMakkzTEMweE5UWXVOemt6SUMweU16RXVNRFVzTFRFMU5pNDNPVE1nTFRFME15NHdOeXd3SUMweU5UY3VOamdzTVRFeExqZzNNU0F0TWpVM0xqWTRMREkxTlM0NE16WWdNQ3d4TkRRdU9EZ3pJREV3T1M0eE1pd3lOakV1TXpJNElESTFOQzQ1TVN3eU5qRXVNekk0SURZM0xqZzNMREFnTVRNMUxqY3lMQzB6TUM0eU5UZ2dNVGd6TGpNNUxDMDNPQzQ0TmpNZ05EZ3VOaklzTFRVeExqTTBOQ0EyT0M0M09Td3RNVEV6TGpZNU5TQTJPQzQzT1N3dE1UZ3pMak00TXlCc0lDMHpMalkzTEMwek9TNDBNelFnTFRNNU5pNHhNeXd3SUdNZ01UUXVOamNzTFRZM0xqZzJNeUEzTnk0d015d3RNVEUzTGpNMk15QXhORFl1TnpJc0xURXhOeTR6TmpNZ05EZ3VOVGtzTUNBNU1DNDNOaXd4T0M0ek1qZ2dNVEU0TGpJNExEVTRMalkzTWlCc0lERXhOaTQwTkN3d0lnb2dJQ0FnSUNBZ0lDQWdJQ0FnYVc1cmMyTmhjR1U2WTI5dWJtVmpkRzl5TFdOMWNuWmhkSFZ5WlQwaU1DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsa1BTSndZWFJvTXpRaUNpQWdJQ0FnSUNBZ0lDQWdJQ0J6ZEhsc1pUMGlabWxzYkRvak9HRTBNVGd5TzJacGJHd3RiM0JoWTJsMGVUb3hPMlpwYkd3dGNuVnNaVHB1YjI1NlpYSnZPM04wY205clpUcHViMjVsSWlBdlBqeHdZWFJvQ2lBZ0lDQWdJQ0FnSUNBZ0lDQmtQU0p0SURZNU1DNDRPVFVzT0RVd0xqY3dNeUE1TUM0M05Td3dJREl5TGpVME15d3pNUzR3TXpVZ01Dd3lORE11TVRJeUlDMHhNelV1T0RJNUxEQWdNQ3d0TWpRekxqRTBNU0F5TWk0MU16WXNMVE14TGpBeE5pSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsdWEzTmpZWEJsT21OdmJtNWxZM1J2Y2kxamRYSjJZWFIxY21VOUlqQWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcFpEMGljR0YwYURNMklnb2dJQ0FnSUNBZ0lDQWdJQ0FnYzNSNWJHVTlJbVpwYkd3Nkl6aGhOREU0TWp0bWFXeHNMVzl3WVdOcGRIazZNVHRtYVd4c0xYSjFiR1U2Ym05dWVtVnlienR6ZEhKdmEyVTZibTl1WlNJZ0x6NDhjR0YwYUFvZ0lDQWdJQ0FnSUNBZ0lDQWdaRDBpYlNBMk16SXVNemsxTERjME1pNHlOVGdnTWpndU1ETTVMRGcyTGpNd05DQXRNakl1TlRVeExETXhMakEwSUMweU16RXVNakl6TERjMUxqRXlPQ0F0TkRFdU9UYzJMQzB4TWprdU1UZ3pJREl6TVM0eU5UY3NMVGMxTGpFek55QXpOaTQwTlRRc01URXVPRFE0SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdhVzVyYzJOaGNHVTZZMjl1Ym1WamRHOXlMV04xY25aaGRIVnlaVDBpTUNJS0lDQWdJQ0FnSUNBZ0lDQWdJR2xrUFNKd1lYUm9NemdpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnpkSGxzWlQwaVptbHNiRG9qT0dFME1UZ3lPMlpwYkd3dGIzQmhZMmwwZVRveE8yWnBiR3d0Y25Wc1pUcHViMjU2WlhKdk8zTjBjbTlyWlRwdWIyNWxJaUF2UGp4d1lYUm9DaUFnSUNBZ0lDQWdJQ0FnSUNCa1BTSnRJRGN4Tnk0ME5Ea3NOalV6TGpFd05TQXROek11TkRFc05UTXVNellnTFRNMkxqUTRPQ3d0TVRFdU9EYzFJQzB4TkRJdU9UQXpMQzB4T1RZdU5qa3lJREV3T1M0NE9ETXNMVGM1TGpneU9DQXhOREl1T1RFNExERTVOaTQzTURNZ01Dd3pPQzR6TXpJaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwYm10elkyRndaVHBqYjI1dVpXTjBiM0l0WTNWeWRtRjBkWEpsUFNJd0lnb2dJQ0FnSUNBZ0lDQWdJQ0FnYVdROUluQmhkR2cwTUNJS0lDQWdJQ0FnSUNBZ0lDQWdJSE4wZVd4bFBTSm1hV3hzT2lNNFlUUXhPREk3Wm1sc2JDMXZjR0ZqYVhSNU9qRTdabWxzYkMxeWRXeGxPbTV2Ym5wbGNtODdjM1J5YjJ0bE9tNXZibVVpSUM4K1BIQmhkR2dLSUNBZ0lDQWdJQ0FnSUNBZ0lHUTlJbTBnT0RJNExqVXlMRGN3Tmk0ME5qVWdMVGN6TGpReU5pd3ROVE11TXpRZ01DNHdNVEVzTFRNNExqTTFPU0JNSURnNU9DNHdNRFFzTkRFNExqQTNJREV3TURjdU9TdzBPVGN1T0RrNElEZzJOQzQ1TnpNc05qazBMall3T1NBNE1qZ3VOVElzTnpBMkxqUTJOU0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbHVhM05qWVhCbE9tTnZibTVsWTNSdmNpMWpkWEoyWVhSMWNtVTlJakFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBaRDBpY0dGMGFEUXlJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2MzUjViR1U5SW1acGJHdzZJemhoTkRFNE1qdG1hV3hzTFc5d1lXTnBkSGs2TVR0bWFXeHNMWEoxYkdVNmJtOXVlbVZ5Ynp0emRISnZhMlU2Ym05dVpTSWdMejQ4Y0dGMGFBb2dJQ0FnSUNBZ0lDQWdJQ0FnWkQwaWJTQTRNVEl1TURnMkxEZ3lPQzQxT0RZZ01qZ3VNRFUxTEMwNE5pNHpNaUF6Tmk0ME9EUXNMVEV4TGpnek5pQXlNekV1TWpJMUxEYzFMakV4TnlBdE5ERXVPVGNzTVRJNUxqRTRNeUF0TWpNeExqSXpPU3d0TnpVdU1UUWdMVEl5TGpVMU5Td3RNekV1TURBMElnb2dJQ0FnSUNBZ0lDQWdJQ0FnYVc1cmMyTmhjR1U2WTI5dWJtVmpkRzl5TFdOMWNuWmhkSFZ5WlQwaU1DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsa1BTSndZWFJvTkRRaUNpQWdJQ0FnSUNBZ0lDQWdJQ0J6ZEhsc1pUMGlabWxzYkRvak9HRTBNVGd5TzJacGJHd3RiM0JoWTJsMGVUb3hPMlpwYkd3dGNuVnNaVHB1YjI1NlpYSnZPM04wY205clpUcHViMjVsSWlBdlBqeHdZWFJvQ2lBZ0lDQWdJQ0FnSUNBZ0lDQmtQU0p0SURjek5pNHpNREVzTVRNek5TNDRPQ0JqSUMwek1qTXVNRFEzTERBZ0xUVTROUzQ0TnpVc0xUSTJNaTQzT0NBdE5UZzFMamczTlN3dE5UZzFMamM0TWlBd0xDMHpNak11TVRFNElESTJNaTQ0TWpnc0xUVTROUzQ1TnpjZ05UZzFMamczTlN3dE5UZzFMamszTnlBek1qTXVNREU1TERBZ05UZzFMamd3T1N3eU5qSXVPRFU1SURVNE5TNDRNRGtzTlRnMUxqazNOeUF3TERNeU15NHdNRElnTFRJMk1pNDNPU3cxT0RVdU56Z3lJQzAxT0RVdU9EQTVMRFU0TlM0M09ESWdiQ0F3TERBZ2VpQnRJREFzTFRFeE9DNDJNU0JqSURJMU55NDVOeklzTUNBME5qY3VNVGc1TEMweU1Ea3VNVE1nTkRZM0xqRTRPU3d0TkRZM0xqRTNNaUF3TEMweU5UZ3VNVEk1SUMweU1Ea3VNakUzTEMwME5qY3VNelE0SUMwME5qY3VNVGc1TEMwME5qY3VNelE0SUMweU5UZ3VNRGMwTERBZ0xUUTJOeTR5TlRRc01qQTVMakl4T1NBdE5EWTNMakkxTkN3ME5qY3VNelE0SURBc01qVTRMakEwTWlBeU1Ea3VNVGdzTkRZM0xqRTNNaUEwTmpjdU1qVTBMRFEyTnk0eE56SWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcGJtdHpZMkZ3WlRwamIyNXVaV04wYjNJdFkzVnlkbUYwZFhKbFBTSXdJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXUTlJbkJoZEdnME5pSUtJQ0FnSUNBZ0lDQWdJQ0FnSUhOMGVXeGxQU0ptYVd4c09pTTRZVFF4T0RJN1ptbHNiQzF2Y0dGamFYUjVPakU3Wm1sc2JDMXlkV3hsT201dmJucGxjbTg3YzNSeWIydGxPbTV2Ym1VaUlDOCtQSEJoZEdnS0lDQWdJQ0FnSUNBZ0lDQWdJR1E5SW0wZ01UQTVNUzR4TXl3Mk1Ua3VPRGd6SUMweE56VXVOemN4TERVM0xqRXlNU0F4TVM0Mk1qa3NNelV1T0RBNElERTNOUzQzTmpJc0xUVTNMakV5TVNBdE1URXVOaklzTFRNMUxqZ3dPQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbHVhM05qWVhCbE9tTnZibTVsWTNSdmNpMWpkWEoyWVhSMWNtVTlJakFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBaRDBpY0dGMGFEUTRJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2MzUjViR1U5SW1acGJHdzZJemhoTkRFNE1qdG1hV3hzTFc5d1lXTnBkSGs2TVR0bWFXeHNMWEoxYkdVNmJtOXVlbVZ5Ynp0emRISnZhMlU2Ym05dVpTSWdMejQ4Y0dGMGFBb2dJQ0FnSUNBZ0lDQWdJQ0FnWkQwaVRTQTROall1T1RVM0xEa3dNaTR3TnpRZ09ETTJMalVzT1RJMExqRTVPU0E1TkRVdU1USXhMREV3TnpNdU56TWdPVGMxTGpVNE5pd3hNRFV4TGpZeElEZzJOaTQ1TlRjc09UQXlMakEzTkNJS0lDQWdJQ0FnSUNBZ0lDQWdJR2x1YTNOallYQmxPbU52Ym01bFkzUnZjaTFqZFhKMllYUjFjbVU5SWpBaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwWkQwaWNHRjBhRFV3SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdjM1I1YkdVOUltWnBiR3c2SXpoaE5ERTRNanRtYVd4c0xXOXdZV05wZEhrNk1UdG1hV3hzTFhKMWJHVTZibTl1ZW1WeWJ6dHpkSEp2YTJVNmJtOXVaU0lnTHo0OGNHRjBhQW9nSUNBZ0lDQWdJQ0FnSUNBZ1pEMGlUU0EyTURjdU5EWTFMRGt3TXk0ME5EVWdORGs0TGpnMU5Td3hNRFV5TGprM0lEVXlPUzR6TWl3eE1EYzFMakVnTmpNM0xqa3pMRGt5TlM0MU5qWWdOakEzTGpRMk5TdzVNRE11TkRRMUlnb2dJQ0FnSUNBZ0lDQWdJQ0FnYVc1cmMyTmhjR1U2WTI5dWJtVmpkRzl5TFdOMWNuWmhkSFZ5WlQwaU1DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsa1BTSndZWFJvTlRJaUNpQWdJQ0FnSUNBZ0lDQWdJQ0J6ZEhsc1pUMGlabWxzYkRvak9HRTBNVGd5TzJacGJHd3RiM0JoWTJsMGVUb3hPMlpwYkd3dGNuVnNaVHB1YjI1NlpYSnZPM04wY205clpUcHViMjVsSWlBdlBqeHdZWFJvQ2lBZ0lDQWdJQ0FnSUNBZ0lDQmtQU0p0SURNNE1DNDJPRGdzTmpJeUxqRXlPU0F0TVRFdU5qSTJMRE0xTGpnd01TQXhOelV1TnpVNExEVTNMakE1SURFeExqWXlNU3d0TXpVdU9EQXhJQzB4TnpVdU56VXpMQzAxTnk0d09TSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsdWEzTmpZWEJsT21OdmJtNWxZM1J2Y2kxamRYSjJZWFIxY21VOUlqQWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcFpEMGljR0YwYURVMElnb2dJQ0FnSUNBZ0lDQWdJQ0FnYzNSNWJHVTlJbVpwYkd3Nkl6aGhOREU0TWp0bWFXeHNMVzl3WVdOcGRIazZNVHRtYVd4c0xYSjFiR1U2Ym05dWVtVnlienR6ZEhKdmEyVTZibTl1WlNJZ0x6NDhjR0YwYUFvZ0lDQWdJQ0FnSUNBZ0lDQWdaRDBpYlNBM01UWXVNamc1TERNM05pNDFPU0F6Tnk0Mk5EQTJMREFnTUN3eE9EUXVPREUySUMwek55NDJOREEyTERBZ01Dd3RNVGcwTGpneE5pQjZJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXNXJjMk5oY0dVNlkyOXVibVZqZEc5eUxXTjFjblpoZEhWeVpUMGlNQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbGtQU0p3WVhSb05UWWlDaUFnSUNBZ0lDQWdJQ0FnSUNCemRIbHNaVDBpWm1sc2JEb2pPR0UwTVRneU8yWnBiR3d0YjNCaFkybDBlVG94TzJacGJHd3RjblZzWlRwdWIyNTZaWEp2TzNOMGNtOXJaVHB1YjI1bElpQXZQand2Wno0OEwyYytQQzluUGp3dlp6NDhMM04yWno0PVxcXCIpIG5vLXJlcGVhdCwgbm9uZTtcXG4gIC1tb3otYmFja2dyb3VuZC1zaXplOiAxMDAlO1xcbiAgLW8tYmFja2dyb3VuZC1zaXplOiAxMDAlO1xcbiAgLXdlYmtpdC1iYWNrZ3JvdW5kLXNpemU6IDEwMCU7XFxuICBiYWNrZ3JvdW5kLXNpemU6IDEwMCU7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgd2lkdGg6IDkwcHg7XFxuICBoZWlnaHQ6IDI1cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFubmVyIC5qYXNtaW5lLXZlcnNpb24ge1xcbiAgbWFyZ2luLWxlZnQ6IDE0cHg7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB0b3A6IDZweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAjamFzbWluZV9jb250ZW50IHtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHJpZ2h0OiAxMDAlO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXZlcnNpb24ge1xcbiAgY29sb3I6ICNhYWE7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFubmVyIHtcXG4gIG1hcmdpbi10b3A6IDE0cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZHVyYXRpb24ge1xcbiAgY29sb3I6ICNmZmY7XFxuICBmbG9hdDogcmlnaHQ7XFxuICBsaW5lLWhlaWdodDogMjhweDtcXG4gIHBhZGRpbmctcmlnaHQ6IDlweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSB7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgbWFyZ2luOiAxNHB4IDA7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkgbGkge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgaGVpZ2h0OiAxMHB4O1xcbiAgd2lkdGg6IDE0cHg7XFxuICBmb250LXNpemU6IDE2cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkgbGkuamFzbWluZS1wYXNzZWQge1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpLmphc21pbmUtcGFzc2VkOmJlZm9yZSB7XFxuICBjb2xvcjogIzAwNzA2OTtcXG4gIGNvbnRlbnQ6IFxcXCLigKJcXFwiO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpLmphc21pbmUtZmFpbGVkIHtcXG4gIGxpbmUtaGVpZ2h0OiA5cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkgbGkuamFzbWluZS1mYWlsZWQ6YmVmb3JlIHtcXG4gIGNvbG9yOiAjY2EzYTExO1xcbiAgY29udGVudDogXFxcIsOXXFxcIjtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgbWFyZ2luLWxlZnQ6IC0xcHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkgbGkuamFzbWluZS1leGNsdWRlZCB7XFxuICBmb250LXNpemU6IDE0cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkgbGkuamFzbWluZS1leGNsdWRlZDpiZWZvcmUge1xcbiAgY29sb3I6ICNiYWJhYmE7XFxuICBjb250ZW50OiBcXFwi4oCiXFxcIjtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaS5qYXNtaW5lLWV4Y2x1ZGVkLW5vLWRpc3BsYXkge1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaS5qYXNtaW5lLXBlbmRpbmcge1xcbiAgbGluZS1oZWlnaHQ6IDE3cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkgbGkuamFzbWluZS1wZW5kaW5nOmJlZm9yZSB7XFxuICBjb2xvcjogI2JhOWQzNztcXG4gIGNvbnRlbnQ6IFxcXCIqXFxcIjtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaS5qYXNtaW5lLWVtcHR5IHtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaS5qYXNtaW5lLWVtcHR5OmJlZm9yZSB7XFxuICBjb2xvcjogI2JhOWQzNztcXG4gIGNvbnRlbnQ6IFxcXCLigKJcXFwiO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXJ1bi1vcHRpb25zIHtcXG4gIGZsb2F0OiByaWdodDtcXG4gIG1hcmdpbi1yaWdodDogNXB4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgIzhhNDE4MjtcXG4gIGNvbG9yOiAjOGE0MTgyO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgbGluZS1oZWlnaHQ6IDIwcHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtcnVuLW9wdGlvbnMgLmphc21pbmUtdHJpZ2dlciB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBwYWRkaW5nOiA4cHggMTZweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1ydW4tb3B0aW9ucyAuamFzbWluZS1wYXlsb2FkIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGRpc3BsYXk6IG5vbmU7XFxuICByaWdodDogLTFweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICM4YTQxODI7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlO1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gIHBhZGRpbmc6IDRweCA4cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtcnVuLW9wdGlvbnMgLmphc21pbmUtcGF5bG9hZC5qYXNtaW5lLW9wZW4ge1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFyIHtcXG4gIGxpbmUtaGVpZ2h0OiAyOHB4O1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBjb2xvcjogI2VlZTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYXIuamFzbWluZS1mYWlsZWQsIC5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFyLmphc21pbmUtZXJyb3JlZCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjY2EzYTExO1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNlZWU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFyLmphc21pbmUtcGFzc2VkIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMwMDcwNjk7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFyLmphc21pbmUtaW5jb21wbGV0ZSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjYmFiYWJhO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhci5qYXNtaW5lLXNraXBwZWQge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2JhYmFiYTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYXIuamFzbWluZS13YXJuaW5nIHtcXG4gIG1hcmdpbi10b3A6IDE0cHg7XFxuICBtYXJnaW4tYm90dG9tOiAxNHB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2JhOWQzNztcXG4gIGNvbG9yOiAjMzMzO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhci5qYXNtaW5lLW1lbnUge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIGNvbG9yOiAjYWFhO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhci5qYXNtaW5lLW1lbnUgYSB7XFxuICBjb2xvcjogIzMzMztcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYXIgYSB7XFxuICBjb2xvcjogd2hpdGU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIuamFzbWluZS1zcGVjLWxpc3QgLmphc21pbmUtYmFyLmphc21pbmUtbWVudS5qYXNtaW5lLWZhaWx1cmUtbGlzdCxcXG4uamFzbWluZV9odG1sLXJlcG9ydGVyLmphc21pbmUtc3BlYy1saXN0IC5qYXNtaW5lLXJlc3VsdHMgLmphc21pbmUtZmFpbHVyZXMge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlci5qYXNtaW5lLWZhaWx1cmUtbGlzdCAuamFzbWluZS1iYXIuamFzbWluZS1tZW51Lmphc21pbmUtc3BlYy1saXN0LFxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIuamFzbWluZS1mYWlsdXJlLWxpc3QgLmphc21pbmUtc3VtbWFyeSB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXJlc3VsdHMge1xcbiAgbWFyZ2luLXRvcDogMTRweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdW1tYXJ5IHtcXG4gIG1hcmdpbi10b3A6IDE0cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3VtbWFyeSB1bCB7XFxuICBsaXN0LXN0eWxlLXR5cGU6IG5vbmU7XFxuICBtYXJnaW4tbGVmdDogMTRweDtcXG4gIHBhZGRpbmctdG9wOiAwO1xcbiAgcGFkZGluZy1sZWZ0OiAwO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1bW1hcnkgdWwuamFzbWluZS1zdWl0ZSB7XFxuICBtYXJnaW4tdG9wOiA3cHg7XFxuICBtYXJnaW4tYm90dG9tOiA3cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3VtbWFyeSBsaS5qYXNtaW5lLXBhc3NlZCBhIHtcXG4gIGNvbG9yOiAjMDA3MDY5O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1bW1hcnkgbGkuamFzbWluZS1mYWlsZWQgYSB7XFxuICBjb2xvcjogI2NhM2ExMTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdW1tYXJ5IGxpLmphc21pbmUtZW1wdHkgYSB7XFxuICBjb2xvcjogI2JhOWQzNztcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdW1tYXJ5IGxpLmphc21pbmUtcGVuZGluZyBhIHtcXG4gIGNvbG9yOiAjYmE5ZDM3O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1bW1hcnkgbGkuamFzbWluZS1leGNsdWRlZCBhIHtcXG4gIGNvbG9yOiAjYmFiYWJhO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXNwZWNzIGxpLmphc21pbmUtcGFzc2VkIGE6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCLigKIgXFxcIjtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zcGVjcyBsaS5qYXNtaW5lLWZhaWxlZCBhOmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwiw5cgXFxcIjtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zcGVjcyBsaS5qYXNtaW5lLWVtcHR5IGE6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCIqIFxcXCI7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3BlY3MgbGkuamFzbWluZS1wZW5kaW5nIGE6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCLigKIgXFxcIjtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zcGVjcyBsaS5qYXNtaW5lLWV4Y2x1ZGVkIGE6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCLigKIgXFxcIjtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1kZXNjcmlwdGlvbiArIC5qYXNtaW5lLXN1aXRlIHtcXG4gIG1hcmdpbi10b3A6IDA7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3VpdGUge1xcbiAgbWFyZ2luLXRvcDogMTRweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdWl0ZSBhIHtcXG4gIGNvbG9yOiAjMzMzO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWZhaWx1cmVzIC5qYXNtaW5lLXNwZWMtZGV0YWlsIHtcXG4gIG1hcmdpbi1ib3R0b206IDI4cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZmFpbHVyZXMgLmphc21pbmUtc3BlYy1kZXRhaWwgLmphc21pbmUtZGVzY3JpcHRpb24ge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2NhM2ExMTtcXG4gIGNvbG9yOiB3aGl0ZTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1mYWlsdXJlcyAuamFzbWluZS1zcGVjLWRldGFpbCAuamFzbWluZS1kZXNjcmlwdGlvbiBhIHtcXG4gIGNvbG9yOiB3aGl0ZTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1yZXN1bHQtbWVzc2FnZSB7XFxuICBwYWRkaW5nLXRvcDogMTRweDtcXG4gIGNvbG9yOiAjMzMzO1xcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXJlc3VsdC1tZXNzYWdlIHNwYW4uamFzbWluZS1yZXN1bHQge1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3RhY2stdHJhY2Uge1xcbiAgbWFyZ2luOiA1cHggMCAwIDA7XFxuICBtYXgtaGVpZ2h0OiAyMjRweDtcXG4gIG92ZXJmbG93OiBhdXRvO1xcbiAgbGluZS1oZWlnaHQ6IDE4cHg7XFxuICBjb2xvcjogIzY2NjtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNkZGQ7XFxuICBiYWNrZ3JvdW5kOiB3aGl0ZTtcXG4gIHdoaXRlLXNwYWNlOiBwcmU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZXhwYW5kZXIgYSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIG1hcmdpbi1sZWZ0OiAxNHB4O1xcbiAgY29sb3I6IGJsdWU7XFxuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1leHBhbmRlci1jb250ZW50cyB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWV4cGFuZGVkIHtcXG4gIHBhZGRpbmctYm90dG9tOiAxMHB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWV4cGFuZGVkIC5qYXNtaW5lLWV4cGFuZGVyLWNvbnRlbnRzIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgbWFyZ2luLWxlZnQ6IDE0cHg7XFxuICBwYWRkaW5nOiA1cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZGVidWctbG9nIHtcXG4gIG1hcmdpbjogNXB4IDAgMCAwO1xcbiAgcGFkZGluZzogNXB4O1xcbiAgY29sb3I6ICM2NjY7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZGRkO1xcbiAgYmFja2dyb3VuZDogd2hpdGU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZGVidWctbG9nIHRhYmxlIHtcXG4gIGJvcmRlci1zcGFjaW5nOiAwO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWRlYnVnLWxvZyB0YWJsZSwgLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1kZWJ1Zy1sb2cgdGgsIC5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZGVidWctbG9nIHRkIHtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNkZGQ7XFxufVwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcpIHtcbiAgdmFyIGxpc3QgPSBbXTsgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gXCJcIjtcbiAgICAgIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2YgaXRlbVs1XSAhPT0gXCJ1bmRlZmluZWRcIjtcblxuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmVlZExheWVyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKTtcbiAgICAgIH1cblxuICAgICAgY29udGVudCArPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pO1xuXG4gICAgICBpZiAobmVlZExheWVyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oXCJcIik7XG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cblxuICBsaXN0LmkgPSBmdW5jdGlvbiBpKG1vZHVsZXMsIG1lZGlhLCBkZWR1cGUsIHN1cHBvcnRzLCBsYXllcikge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgdW5kZWZpbmVkXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2tdWzBdO1xuXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2sgPSAwOyBfayA8IG1vZHVsZXMubGVuZ3RoOyBfaysrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19rXSk7XG5cbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBsYXllciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW1bNV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBpdGVtWzVdID0gbGF5ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzVdID0gbGF5ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN1cHBvcnRzKSB7XG4gICAgICAgIGlmICghaXRlbVs0XSkge1xuICAgICAgICAgIGl0ZW1bNF0gPSBcIlwiLmNvbmNhdChzdXBwb3J0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzRdID0gc3VwcG9ydHM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdO1xuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShjc3NNYXBwaW5nKSkpKTtcbiAgICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG4gICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCBcIlwiKS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKFwiXFxuXCIpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKFwiXFxuXCIpO1xufTsiLCIvKlxuQ29weXJpZ2h0IChjKSAyMDA4LTIwMjIgUGl2b3RhbCBMYWJzXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG5cIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbndpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbmRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xucGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG50aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG5pbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbkVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbk5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkVcbkxJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cbk9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xuLyoqXG4gVGhpcyBmaWxlIHN0YXJ0cyB0aGUgcHJvY2VzcyBvZiBcImJvb3RpbmdcIiBKYXNtaW5lLiBJdCBpbml0aWFsaXplcyBKYXNtaW5lLFxuIG1ha2VzIGl0cyBnbG9iYWxzIGF2YWlsYWJsZSwgYW5kIGNyZWF0ZXMgdGhlIGVudi4gVGhpcyBmaWxlIHNob3VsZCBiZSBsb2FkZWRcbiBhZnRlciBgamFzbWluZS5qc2AgYW5kIGBqYXNtaW5lX2h0bWwuanNgLCBidXQgYmVmb3JlIGBib290MS5qc2Agb3IgYW55IHByb2plY3RcbiBzb3VyY2UgZmlsZXMgb3Igc3BlYyBmaWxlcyBhcmUgbG9hZGVkLlxuICovXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBqYXNtaW5lUmVxdWlyZSA9IHdpbmRvdy5qYXNtaW5lUmVxdWlyZSB8fCByZXF1aXJlKCcuL2phc21pbmUuanMnKTtcblxuICAvKipcbiAgICogIyMgUmVxdWlyZSAmYW1wOyBJbnN0YW50aWF0ZVxuICAgKlxuICAgKiBSZXF1aXJlIEphc21pbmUncyBjb3JlIGZpbGVzLiBTcGVjaWZpY2FsbHksIHRoaXMgcmVxdWlyZXMgYW5kIGF0dGFjaGVzIGFsbCBvZiBKYXNtaW5lJ3MgY29kZSB0byB0aGUgYGphc21pbmVgIHJlZmVyZW5jZS5cbiAgICovXG4gIHZhciBqYXNtaW5lID0gamFzbWluZVJlcXVpcmUuY29yZShqYXNtaW5lUmVxdWlyZSksXG4gICAgZ2xvYmFsID0gamFzbWluZS5nZXRHbG9iYWwoKTtcbiAgZ2xvYmFsLmphc21pbmUgPSBqYXNtaW5lO1xuXG4gIC8qKlxuICAgKiBTaW5jZSB0aGlzIGlzIGJlaW5nIHJ1biBpbiBhIGJyb3dzZXIgYW5kIHRoZSByZXN1bHRzIHNob3VsZCBwb3B1bGF0ZSB0byBhbiBIVE1MIHBhZ2UsIHJlcXVpcmUgdGhlIEhUTUwtc3BlY2lmaWMgSmFzbWluZSBjb2RlLCBpbmplY3RpbmcgdGhlIHNhbWUgcmVmZXJlbmNlLlxuICAgKi9cbiAgamFzbWluZVJlcXVpcmUuaHRtbChqYXNtaW5lKTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBKYXNtaW5lIGVudmlyb25tZW50LiBUaGlzIGlzIHVzZWQgdG8gcnVuIGFsbCBzcGVjcyBpbiBhIHByb2plY3QuXG4gICAqL1xuICB2YXIgZW52ID0gamFzbWluZS5nZXRFbnYoKTtcblxuICAvKipcbiAgICogIyMgVGhlIEdsb2JhbCBJbnRlcmZhY2VcbiAgICpcbiAgICogQnVpbGQgdXAgdGhlIGZ1bmN0aW9ucyB0aGF0IHdpbGwgYmUgZXhwb3NlZCBhcyB0aGUgSmFzbWluZSBwdWJsaWMgaW50ZXJmYWNlLiBBIHByb2plY3QgY2FuIGN1c3RvbWl6ZSwgcmVuYW1lIG9yIGFsaWFzIGFueSBvZiB0aGVzZSBmdW5jdGlvbnMgYXMgZGVzaXJlZCwgcHJvdmlkZWQgdGhlIGltcGxlbWVudGF0aW9uIHJlbWFpbnMgdW5jaGFuZ2VkLlxuICAgKi9cbiAgdmFyIGphc21pbmVJbnRlcmZhY2UgPSBqYXNtaW5lUmVxdWlyZS5pbnRlcmZhY2UoamFzbWluZSwgZW52KTtcblxuICAvKipcbiAgICogQWRkIGFsbCBvZiB0aGUgSmFzbWluZSBnbG9iYWwvcHVibGljIGludGVyZmFjZSB0byB0aGUgZ2xvYmFsIHNjb3BlLCBzbyBhIHByb2plY3QgY2FuIHVzZSB0aGUgcHVibGljIGludGVyZmFjZSBkaXJlY3RseS4gRm9yIGV4YW1wbGUsIGNhbGxpbmcgYGRlc2NyaWJlYCBpbiBzcGVjcyBpbnN0ZWFkIG9mIGBqYXNtaW5lLmdldEVudigpLmRlc2NyaWJlYC5cbiAgICovXG4gIGZvciAodmFyIHByb3BlcnR5IGluIGphc21pbmVJbnRlcmZhY2UpIHtcbiAgICBnbG9iYWxbcHJvcGVydHldID0gamFzbWluZUludGVyZmFjZVtwcm9wZXJ0eV07XG4gIH1cbn0pKCk7XG4iLCIvKlxuQ29weXJpZ2h0IChjKSAyMDA4LTIwMjIgUGl2b3RhbCBMYWJzXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG5cIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbndpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbmRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xucGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG50aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG5pbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbkVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbk5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkVcbkxJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cbk9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xuLyoqXG4gVGhpcyBmaWxlIGZpbmlzaGVzICdib290aW5nJyBKYXNtaW5lLCBwZXJmb3JtaW5nIGFsbCBvZiB0aGUgbmVjZXNzYXJ5XG4gaW5pdGlhbGl6YXRpb24gYmVmb3JlIGV4ZWN1dGluZyB0aGUgbG9hZGVkIGVudmlyb25tZW50IGFuZCBhbGwgb2YgYSBwcm9qZWN0J3NcbiBzcGVjcy4gVGhpcyBmaWxlIHNob3VsZCBiZSBsb2FkZWQgYWZ0ZXIgYGJvb3QwLmpzYCBidXQgYmVmb3JlIGFueSBwcm9qZWN0XG4gc291cmNlIGZpbGVzIG9yIHNwZWMgZmlsZXMgYXJlIGxvYWRlZC4gVGh1cyB0aGlzIGZpbGUgY2FuIGFsc28gYmUgdXNlZCB0b1xuIGN1c3RvbWl6ZSBKYXNtaW5lIGZvciBhIHByb2plY3QuXG5cbiBJZiBhIHByb2plY3QgaXMgdXNpbmcgSmFzbWluZSB2aWEgdGhlIHN0YW5kYWxvbmUgZGlzdHJpYnV0aW9uLCB0aGlzIGZpbGUgY2FuXG4gYmUgY3VzdG9taXplZCBkaXJlY3RseS4gSWYgeW91IG9ubHkgd2lzaCB0byBjb25maWd1cmUgdGhlIEphc21pbmUgZW52LCB5b3VcbiBjYW4gbG9hZCBhbm90aGVyIGZpbGUgdGhhdCBjYWxscyBgamFzbWluZS5nZXRFbnYoKS5jb25maWd1cmUoey4uLn0pYFxuIGFmdGVyIGBib290MC5qc2AgaXMgbG9hZGVkIGFuZCBiZWZvcmUgdGhpcyBmaWxlIGlzIGxvYWRlZC5cbiAqL1xuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBlbnYgPSBqYXNtaW5lLmdldEVudigpO1xuXG4gIC8qKlxuICAgKiAjIyBSdW5uZXIgUGFyYW1ldGVyc1xuICAgKlxuICAgKiBNb3JlIGJyb3dzZXIgc3BlY2lmaWMgY29kZSAtIHdyYXAgdGhlIHF1ZXJ5IHN0cmluZyBpbiBhbiBvYmplY3QgYW5kIHRvIGFsbG93IGZvciBnZXR0aW5nL3NldHRpbmcgcGFyYW1ldGVycyBmcm9tIHRoZSBydW5uZXIgdXNlciBpbnRlcmZhY2UuXG4gICAqL1xuXG4gIHZhciBxdWVyeVN0cmluZyA9IG5ldyBqYXNtaW5lLlF1ZXJ5U3RyaW5nKHtcbiAgICBnZXRXaW5kb3dMb2NhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGZpbHRlclNwZWNzID0gISFxdWVyeVN0cmluZy5nZXRQYXJhbSgnc3BlYycpO1xuXG4gIHZhciBjb25maWcgPSB7XG4gICAgc3RvcE9uU3BlY0ZhaWx1cmU6IHF1ZXJ5U3RyaW5nLmdldFBhcmFtKCdzdG9wT25TcGVjRmFpbHVyZScpLFxuICAgIHN0b3BTcGVjT25FeHBlY3RhdGlvbkZhaWx1cmU6IHF1ZXJ5U3RyaW5nLmdldFBhcmFtKFxuICAgICAgJ3N0b3BTcGVjT25FeHBlY3RhdGlvbkZhaWx1cmUnXG4gICAgKSxcbiAgICBoaWRlRGlzYWJsZWQ6IHF1ZXJ5U3RyaW5nLmdldFBhcmFtKCdoaWRlRGlzYWJsZWQnKVxuICB9O1xuXG4gIHZhciByYW5kb20gPSBxdWVyeVN0cmluZy5nZXRQYXJhbSgncmFuZG9tJyk7XG5cbiAgaWYgKHJhbmRvbSAhPT0gdW5kZWZpbmVkICYmIHJhbmRvbSAhPT0gJycpIHtcbiAgICBjb25maWcucmFuZG9tID0gcmFuZG9tO1xuICB9XG5cbiAgdmFyIHNlZWQgPSBxdWVyeVN0cmluZy5nZXRQYXJhbSgnc2VlZCcpO1xuICBpZiAoc2VlZCkge1xuICAgIGNvbmZpZy5zZWVkID0gc2VlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyBSZXBvcnRlcnNcbiAgICogVGhlIGBIdG1sUmVwb3J0ZXJgIGJ1aWxkcyBhbGwgb2YgdGhlIEhUTUwgVUkgZm9yIHRoZSBydW5uZXIgcGFnZS4gVGhpcyByZXBvcnRlciBwYWludHMgdGhlIGRvdHMsIHN0YXJzLCBhbmQgeCdzIGZvciBzcGVjcywgYXMgd2VsbCBhcyBhbGwgc3BlYyBuYW1lcyBhbmQgYWxsIGZhaWx1cmVzIChpZiBhbnkpLlxuICAgKi9cbiAgdmFyIGh0bWxSZXBvcnRlciA9IG5ldyBqYXNtaW5lLkh0bWxSZXBvcnRlcih7XG4gICAgZW52OiBlbnYsXG4gICAgbmF2aWdhdGVXaXRoTmV3UGFyYW06IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBxdWVyeVN0cmluZy5uYXZpZ2F0ZVdpdGhOZXdQYXJhbShrZXksIHZhbHVlKTtcbiAgICB9LFxuICAgIGFkZFRvRXhpc3RpbmdRdWVyeVN0cmluZzogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHF1ZXJ5U3RyaW5nLmZ1bGxTdHJpbmdXaXRoTmV3UGFyYW0oa2V5LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBnZXRDb250YWluZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gICAgfSxcbiAgICBjcmVhdGVFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50LmFwcGx5KGRvY3VtZW50LCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgY3JlYXRlVGV4dE5vZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlLmFwcGx5KGRvY3VtZW50LCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgdGltZXI6IG5ldyBqYXNtaW5lLlRpbWVyKCksXG4gICAgZmlsdGVyU3BlY3M6IGZpbHRlclNwZWNzXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGUgYGpzQXBpUmVwb3J0ZXJgIGFsc28gcmVjZWl2ZXMgc3BlYyByZXN1bHRzLCBhbmQgaXMgdXNlZCBieSBhbnkgZW52aXJvbm1lbnQgdGhhdCBuZWVkcyB0byBleHRyYWN0IHRoZSByZXN1bHRzICBmcm9tIEphdmFTY3JpcHQuXG4gICAqL1xuICBlbnYuYWRkUmVwb3J0ZXIoanNBcGlSZXBvcnRlcik7XG4gIGVudi5hZGRSZXBvcnRlcihodG1sUmVwb3J0ZXIpO1xuXG4gIC8qKlxuICAgKiBGaWx0ZXIgd2hpY2ggc3BlY3Mgd2lsbCBiZSBydW4gYnkgbWF0Y2hpbmcgdGhlIHN0YXJ0IG9mIHRoZSBmdWxsIG5hbWUgYWdhaW5zdCB0aGUgYHNwZWNgIHF1ZXJ5IHBhcmFtLlxuICAgKi9cbiAgdmFyIHNwZWNGaWx0ZXIgPSBuZXcgamFzbWluZS5IdG1sU3BlY0ZpbHRlcih7XG4gICAgZmlsdGVyU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBxdWVyeVN0cmluZy5nZXRQYXJhbSgnc3BlYycpO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uZmlnLnNwZWNGaWx0ZXIgPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgcmV0dXJuIHNwZWNGaWx0ZXIubWF0Y2hlcyhzcGVjLmdldEZ1bGxOYW1lKCkpO1xuICB9O1xuXG4gIGVudi5jb25maWd1cmUoY29uZmlnKTtcblxuICAvKipcbiAgICogIyMgRXhlY3V0aW9uXG4gICAqXG4gICAqIFJlcGxhY2UgdGhlIGJyb3dzZXIgd2luZG93J3MgYG9ubG9hZGAsIGVuc3VyZSBpdCdzIGNhbGxlZCwgYW5kIHRoZW4gcnVuIGFsbCBvZiB0aGUgbG9hZGVkIHNwZWNzLiBUaGlzIGluY2x1ZGVzIGluaXRpYWxpemluZyB0aGUgYEh0bWxSZXBvcnRlcmAgaW5zdGFuY2UgYW5kIHRoZW4gZXhlY3V0aW5nIHRoZSBsb2FkZWQgSmFzbWluZSBlbnZpcm9ubWVudC4gQWxsIG9mIHRoaXMgd2lsbCBoYXBwZW4gYWZ0ZXIgYWxsIG9mIHRoZSBzcGVjcyBhcmUgbG9hZGVkLlxuICAgKi9cbiAgdmFyIGN1cnJlbnRXaW5kb3dPbmxvYWQgPSB3aW5kb3cub25sb2FkO1xuXG4gIHdpbmRvdy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoY3VycmVudFdpbmRvd09ubG9hZCkge1xuICAgICAgY3VycmVudFdpbmRvd09ubG9hZCgpO1xuICAgIH1cbiAgICBodG1sUmVwb3J0ZXIuaW5pdGlhbGl6ZSgpO1xuICAgIGVudi5leGVjdXRlKCk7XG4gIH07XG59KSgpO1xuIiwiLypcbkNvcHlyaWdodCAoYykgMjAwOC0yMDIyIFBpdm90YWwgTGFic1xuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbmEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG53aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG5kaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbnBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xudGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG5FWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbk1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG5OT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXG5MSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OXG5PRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbldJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuKi9cbnZhciBqYXNtaW5lUmVxdWlyZSA9IHdpbmRvdy5qYXNtaW5lUmVxdWlyZSB8fCByZXF1aXJlKCcuL2phc21pbmUuanMnKTtcblxuamFzbWluZVJlcXVpcmUuaHRtbCA9IGZ1bmN0aW9uKGokKSB7XG4gIGokLlJlc3VsdHNOb2RlID0gamFzbWluZVJlcXVpcmUuUmVzdWx0c05vZGUoKTtcbiAgaiQuSHRtbFJlcG9ydGVyID0gamFzbWluZVJlcXVpcmUuSHRtbFJlcG9ydGVyKGokKTtcbiAgaiQuUXVlcnlTdHJpbmcgPSBqYXNtaW5lUmVxdWlyZS5RdWVyeVN0cmluZygpO1xuICBqJC5IdG1sU3BlY0ZpbHRlciA9IGphc21pbmVSZXF1aXJlLkh0bWxTcGVjRmlsdGVyKCk7XG59O1xuXG5qYXNtaW5lUmVxdWlyZS5IdG1sUmVwb3J0ZXIgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBSZXN1bHRzU3RhdGVCdWlsZGVyKCkge1xuICAgIHRoaXMudG9wUmVzdWx0cyA9IG5ldyBqJC5SZXN1bHRzTm9kZSh7fSwgJycsIG51bGwpO1xuICAgIHRoaXMuY3VycmVudFBhcmVudCA9IHRoaXMudG9wUmVzdWx0cztcbiAgICB0aGlzLnNwZWNzRXhlY3V0ZWQgPSAwO1xuICAgIHRoaXMuZmFpbHVyZUNvdW50ID0gMDtcbiAgICB0aGlzLnBlbmRpbmdTcGVjQ291bnQgPSAwO1xuICB9XG5cbiAgUmVzdWx0c1N0YXRlQnVpbGRlci5wcm90b3R5cGUuc3VpdGVTdGFydGVkID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgdGhpcy5jdXJyZW50UGFyZW50LmFkZENoaWxkKHJlc3VsdCwgJ3N1aXRlJyk7XG4gICAgdGhpcy5jdXJyZW50UGFyZW50ID0gdGhpcy5jdXJyZW50UGFyZW50Lmxhc3QoKTtcbiAgfTtcblxuICBSZXN1bHRzU3RhdGVCdWlsZGVyLnByb3RvdHlwZS5zdWl0ZURvbmUgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICB0aGlzLmN1cnJlbnRQYXJlbnQudXBkYXRlUmVzdWx0KHJlc3VsdCk7XG4gICAgaWYgKHRoaXMuY3VycmVudFBhcmVudCAhPT0gdGhpcy50b3BSZXN1bHRzKSB7XG4gICAgICB0aGlzLmN1cnJlbnRQYXJlbnQgPSB0aGlzLmN1cnJlbnRQYXJlbnQucGFyZW50O1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZmFpbGVkJykge1xuICAgICAgdGhpcy5mYWlsdXJlQ291bnQrKztcbiAgICB9XG4gIH07XG5cbiAgUmVzdWx0c1N0YXRlQnVpbGRlci5wcm90b3R5cGUuc3BlY1N0YXJ0ZWQgPSBmdW5jdGlvbihyZXN1bHQpIHt9O1xuXG4gIFJlc3VsdHNTdGF0ZUJ1aWxkZXIucHJvdG90eXBlLnNwZWNEb25lID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgdGhpcy5jdXJyZW50UGFyZW50LmFkZENoaWxkKHJlc3VsdCwgJ3NwZWMnKTtcblxuICAgIGlmIChyZXN1bHQuc3RhdHVzICE9PSAnZXhjbHVkZWQnKSB7XG4gICAgICB0aGlzLnNwZWNzRXhlY3V0ZWQrKztcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgIHRoaXMuZmFpbHVyZUNvdW50Kys7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5zdGF0dXMgPT0gJ3BlbmRpbmcnKSB7XG4gICAgICB0aGlzLnBlbmRpbmdTcGVjQ291bnQrKztcbiAgICB9XG4gIH07XG5cbiAgUmVzdWx0c1N0YXRlQnVpbGRlci5wcm90b3R5cGUuamFzbWluZURvbmUgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9ucykge1xuICAgICAgdGhpcy5mYWlsdXJlQ291bnQgKz0gcmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIEh0bWxSZXBvcnRlcihvcHRpb25zKSB7XG4gICAgdmFyIGNvbmZpZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuZW52ICYmIG9wdGlvbnMuZW52LmNvbmZpZ3VyYXRpb24oKSkgfHwge307XG4gICAgICB9LFxuICAgICAgZ2V0Q29udGFpbmVyID0gb3B0aW9ucy5nZXRDb250YWluZXIsXG4gICAgICBjcmVhdGVFbGVtZW50ID0gb3B0aW9ucy5jcmVhdGVFbGVtZW50LFxuICAgICAgY3JlYXRlVGV4dE5vZGUgPSBvcHRpb25zLmNyZWF0ZVRleHROb2RlLFxuICAgICAgbmF2aWdhdGVXaXRoTmV3UGFyYW0gPSBvcHRpb25zLm5hdmlnYXRlV2l0aE5ld1BhcmFtIHx8IGZ1bmN0aW9uKCkge30sXG4gICAgICBhZGRUb0V4aXN0aW5nUXVlcnlTdHJpbmcgPVxuICAgICAgICBvcHRpb25zLmFkZFRvRXhpc3RpbmdRdWVyeVN0cmluZyB8fCBkZWZhdWx0UXVlcnlTdHJpbmcsXG4gICAgICBmaWx0ZXJTcGVjcyA9IG9wdGlvbnMuZmlsdGVyU3BlY3MsXG4gICAgICBodG1sUmVwb3J0ZXJNYWluLFxuICAgICAgc3ltYm9scyxcbiAgICAgIGRlcHJlY2F0aW9uV2FybmluZ3MgPSBbXTtcblxuICAgIHRoaXMuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgY2xlYXJQcmlvcigpO1xuICAgICAgaHRtbFJlcG9ydGVyTWFpbiA9IGNyZWF0ZURvbShcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZV9odG1sLXJlcG9ydGVyJyB9LFxuICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lLWJhbm5lcicgfSxcbiAgICAgICAgICBjcmVhdGVEb20oJ2EnLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdqYXNtaW5lLXRpdGxlJyxcbiAgICAgICAgICAgIGhyZWY6ICdodHRwOi8vamFzbWluZS5naXRodWIuaW8vJyxcbiAgICAgICAgICAgIHRhcmdldDogJ19ibGFuaydcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBjcmVhdGVEb20oJ3NwYW4nLCB7IGNsYXNzTmFtZTogJ2phc21pbmUtdmVyc2lvbicgfSwgaiQudmVyc2lvbilcbiAgICAgICAgKSxcbiAgICAgICAgY3JlYXRlRG9tKCd1bCcsIHsgY2xhc3NOYW1lOiAnamFzbWluZS1zeW1ib2wtc3VtbWFyeScgfSksXG4gICAgICAgIGNyZWF0ZURvbSgnZGl2JywgeyBjbGFzc05hbWU6ICdqYXNtaW5lLWFsZXJ0JyB9KSxcbiAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICdkaXYnLFxuICAgICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZS1yZXN1bHRzJyB9LFxuICAgICAgICAgIGNyZWF0ZURvbSgnZGl2JywgeyBjbGFzc05hbWU6ICdqYXNtaW5lLWZhaWx1cmVzJyB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgZ2V0Q29udGFpbmVyKCkuYXBwZW5kQ2hpbGQoaHRtbFJlcG9ydGVyTWFpbik7XG4gICAgfTtcblxuICAgIHZhciB0b3RhbFNwZWNzRGVmaW5lZDtcbiAgICB0aGlzLmphc21pbmVTdGFydGVkID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdG90YWxTcGVjc0RlZmluZWQgPSBvcHRpb25zLnRvdGFsU3BlY3NEZWZpbmVkIHx8IDA7XG4gICAgfTtcblxuICAgIHZhciBzdW1tYXJ5ID0gY3JlYXRlRG9tKCdkaXYnLCB7IGNsYXNzTmFtZTogJ2phc21pbmUtc3VtbWFyeScgfSk7XG5cbiAgICB2YXIgc3RhdGVCdWlsZGVyID0gbmV3IFJlc3VsdHNTdGF0ZUJ1aWxkZXIoKTtcblxuICAgIHRoaXMuc3VpdGVTdGFydGVkID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICBzdGF0ZUJ1aWxkZXIuc3VpdGVTdGFydGVkKHJlc3VsdCk7XG4gICAgfTtcblxuICAgIHRoaXMuc3VpdGVEb25lID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICBzdGF0ZUJ1aWxkZXIuc3VpdGVEb25lKHJlc3VsdCk7XG5cbiAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZmFpbGVkJykge1xuICAgICAgICBmYWlsdXJlcy5wdXNoKGZhaWx1cmVEb20ocmVzdWx0KSk7XG4gICAgICB9XG4gICAgICBhZGREZXByZWNhdGlvbldhcm5pbmdzKHJlc3VsdCwgJ3N1aXRlJyk7XG4gICAgfTtcblxuICAgIHRoaXMuc3BlY1N0YXJ0ZWQgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIHN0YXRlQnVpbGRlci5zcGVjU3RhcnRlZChyZXN1bHQpO1xuICAgIH07XG5cbiAgICB2YXIgZmFpbHVyZXMgPSBbXTtcbiAgICB0aGlzLnNwZWNEb25lID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICBzdGF0ZUJ1aWxkZXIuc3BlY0RvbmUocmVzdWx0KTtcblxuICAgICAgaWYgKG5vRXhwZWN0YXRpb25zKHJlc3VsdCkpIHtcbiAgICAgICAgdmFyIG5vU3BlY01zZyA9IFwiU3BlYyAnXCIgKyByZXN1bHQuZnVsbE5hbWUgKyBcIicgaGFzIG5vIGV4cGVjdGF0aW9ucy5cIjtcbiAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihub1NwZWNNc2cpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2Fybihub1NwZWNNc2cpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghc3ltYm9scykge1xuICAgICAgICBzeW1ib2xzID0gZmluZCgnLmphc21pbmUtc3ltYm9sLXN1bW1hcnknKTtcbiAgICAgIH1cblxuICAgICAgc3ltYm9scy5hcHBlbmRDaGlsZChcbiAgICAgICAgY3JlYXRlRG9tKCdsaScsIHtcbiAgICAgICAgICBjbGFzc05hbWU6IHRoaXMuZGlzcGxheVNwZWNJbkNvcnJlY3RGb3JtYXQocmVzdWx0KSxcbiAgICAgICAgICBpZDogJ3NwZWNfJyArIHJlc3VsdC5pZCxcbiAgICAgICAgICB0aXRsZTogcmVzdWx0LmZ1bGxOYW1lXG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgZmFpbHVyZXMucHVzaChmYWlsdXJlRG9tKHJlc3VsdCkpO1xuICAgICAgfVxuXG4gICAgICBhZGREZXByZWNhdGlvbldhcm5pbmdzKHJlc3VsdCwgJ3NwZWMnKTtcbiAgICB9O1xuXG4gICAgdGhpcy5kaXNwbGF5U3BlY0luQ29ycmVjdEZvcm1hdCA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIG5vRXhwZWN0YXRpb25zKHJlc3VsdCkgJiYgcmVzdWx0LnN0YXR1cyA9PT0gJ3Bhc3NlZCdcbiAgICAgICAgPyAnamFzbWluZS1lbXB0eSdcbiAgICAgICAgOiB0aGlzLnJlc3VsdFN0YXR1cyhyZXN1bHQuc3RhdHVzKTtcbiAgICB9O1xuXG4gICAgdGhpcy5yZXN1bHRTdGF0dXMgPSBmdW5jdGlvbihzdGF0dXMpIHtcbiAgICAgIGlmIChzdGF0dXMgPT09ICdleGNsdWRlZCcpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZygpLmhpZGVEaXNhYmxlZFxuICAgICAgICAgID8gJ2phc21pbmUtZXhjbHVkZWQtbm8tZGlzcGxheSdcbiAgICAgICAgICA6ICdqYXNtaW5lLWV4Y2x1ZGVkJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnamFzbWluZS0nICsgc3RhdHVzO1xuICAgIH07XG5cbiAgICB0aGlzLmphc21pbmVEb25lID0gZnVuY3Rpb24oZG9uZVJlc3VsdCkge1xuICAgICAgc3RhdGVCdWlsZGVyLmphc21pbmVEb25lKGRvbmVSZXN1bHQpO1xuICAgICAgdmFyIGJhbm5lciA9IGZpbmQoJy5qYXNtaW5lLWJhbm5lcicpO1xuICAgICAgdmFyIGFsZXJ0ID0gZmluZCgnLmphc21pbmUtYWxlcnQnKTtcbiAgICAgIHZhciBvcmRlciA9IGRvbmVSZXN1bHQgJiYgZG9uZVJlc3VsdC5vcmRlcjtcbiAgICAgIHZhciBpO1xuICAgICAgYWxlcnQuYXBwZW5kQ2hpbGQoXG4gICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lLWR1cmF0aW9uJyB9LFxuICAgICAgICAgICdmaW5pc2hlZCBpbiAnICsgZG9uZVJlc3VsdC50b3RhbFRpbWUgLyAxMDAwICsgJ3MnXG4gICAgICAgIClcbiAgICAgICk7XG5cbiAgICAgIGJhbm5lci5hcHBlbmRDaGlsZChvcHRpb25zTWVudShjb25maWcoKSkpO1xuXG4gICAgICBpZiAoc3RhdGVCdWlsZGVyLnNwZWNzRXhlY3V0ZWQgPCB0b3RhbFNwZWNzRGVmaW5lZCkge1xuICAgICAgICB2YXIgc2tpcHBlZE1lc3NhZ2UgPVxuICAgICAgICAgICdSYW4gJyArXG4gICAgICAgICAgc3RhdGVCdWlsZGVyLnNwZWNzRXhlY3V0ZWQgK1xuICAgICAgICAgICcgb2YgJyArXG4gICAgICAgICAgdG90YWxTcGVjc0RlZmluZWQgK1xuICAgICAgICAgICcgc3BlY3MgLSBydW4gYWxsJztcbiAgICAgICAgLy8gaW5jbHVkZSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgdG8gZml4IGlzc3VlIHdpdGgga2FybWEtamFzbWluZS1odG1sLXJlcG9ydGVyIGluIGFuZ3VsYXI6IHNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzbWluZS9qYXNtaW5lL2lzc3Vlcy8xOTA2XG4gICAgICAgIHZhciBza2lwcGVkTGluayA9XG4gICAgICAgICAgKHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSB8fCAnJykgK1xuICAgICAgICAgIGFkZFRvRXhpc3RpbmdRdWVyeVN0cmluZygnc3BlYycsICcnKTtcbiAgICAgICAgYWxlcnQuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lLWJhciBqYXNtaW5lLXNraXBwZWQnIH0sXG4gICAgICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICAgeyBocmVmOiBza2lwcGVkTGluaywgdGl0bGU6ICdSdW4gYWxsIHNwZWNzJyB9LFxuICAgICAgICAgICAgICBza2lwcGVkTWVzc2FnZVxuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZhciBzdGF0dXNCYXJNZXNzYWdlID0gJyc7XG4gICAgICB2YXIgc3RhdHVzQmFyQ2xhc3NOYW1lID0gJ2phc21pbmUtb3ZlcmFsbC1yZXN1bHQgamFzbWluZS1iYXIgJztcbiAgICAgIHZhciBnbG9iYWxGYWlsdXJlcyA9IChkb25lUmVzdWx0ICYmIGRvbmVSZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zKSB8fCBbXTtcbiAgICAgIHZhciBmYWlsZWQgPSBzdGF0ZUJ1aWxkZXIuZmFpbHVyZUNvdW50ICsgZ2xvYmFsRmFpbHVyZXMubGVuZ3RoID4gMDtcblxuICAgICAgaWYgKHRvdGFsU3BlY3NEZWZpbmVkID4gMCB8fCBmYWlsZWQpIHtcbiAgICAgICAgc3RhdHVzQmFyTWVzc2FnZSArPVxuICAgICAgICAgIHBsdXJhbGl6ZSgnc3BlYycsIHN0YXRlQnVpbGRlci5zcGVjc0V4ZWN1dGVkKSArXG4gICAgICAgICAgJywgJyArXG4gICAgICAgICAgcGx1cmFsaXplKCdmYWlsdXJlJywgc3RhdGVCdWlsZGVyLmZhaWx1cmVDb3VudCk7XG4gICAgICAgIGlmIChzdGF0ZUJ1aWxkZXIucGVuZGluZ1NwZWNDb3VudCkge1xuICAgICAgICAgIHN0YXR1c0Jhck1lc3NhZ2UgKz1cbiAgICAgICAgICAgICcsICcgKyBwbHVyYWxpemUoJ3BlbmRpbmcgc3BlYycsIHN0YXRlQnVpbGRlci5wZW5kaW5nU3BlY0NvdW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZG9uZVJlc3VsdC5vdmVyYWxsU3RhdHVzID09PSAncGFzc2VkJykge1xuICAgICAgICBzdGF0dXNCYXJDbGFzc05hbWUgKz0gJyBqYXNtaW5lLXBhc3NlZCAnO1xuICAgICAgfSBlbHNlIGlmIChkb25lUmVzdWx0Lm92ZXJhbGxTdGF0dXMgPT09ICdpbmNvbXBsZXRlJykge1xuICAgICAgICBzdGF0dXNCYXJDbGFzc05hbWUgKz0gJyBqYXNtaW5lLWluY29tcGxldGUgJztcbiAgICAgICAgc3RhdHVzQmFyTWVzc2FnZSA9XG4gICAgICAgICAgJ0luY29tcGxldGU6ICcgK1xuICAgICAgICAgIGRvbmVSZXN1bHQuaW5jb21wbGV0ZVJlYXNvbiArXG4gICAgICAgICAgJywgJyArXG4gICAgICAgICAgc3RhdHVzQmFyTWVzc2FnZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXR1c0JhckNsYXNzTmFtZSArPSAnIGphc21pbmUtZmFpbGVkICc7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWVkQmFyO1xuICAgICAgaWYgKG9yZGVyICYmIG9yZGVyLnJhbmRvbSkge1xuICAgICAgICBzZWVkQmFyID0gY3JlYXRlRG9tKFxuICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmUtc2VlZC1iYXInIH0sXG4gICAgICAgICAgJywgcmFuZG9taXplZCB3aXRoIHNlZWQgJyxcbiAgICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgICAnYScsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRpdGxlOiAncmFuZG9taXplZCB3aXRoIHNlZWQgJyArIG9yZGVyLnNlZWQsXG4gICAgICAgICAgICAgIGhyZWY6IHNlZWRIcmVmKG9yZGVyLnNlZWQpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3JkZXIuc2VlZFxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgYWxlcnQuYXBwZW5kQ2hpbGQoXG4gICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgeyBjbGFzc05hbWU6IHN0YXR1c0JhckNsYXNzTmFtZSB9LFxuICAgICAgICAgIHN0YXR1c0Jhck1lc3NhZ2UsXG4gICAgICAgICAgc2VlZEJhclxuICAgICAgICApXG4gICAgICApO1xuXG4gICAgICB2YXIgZXJyb3JCYXJDbGFzc05hbWUgPSAnamFzbWluZS1iYXIgamFzbWluZS1lcnJvcmVkJztcbiAgICAgIHZhciBhZnRlckFsbE1lc3NhZ2VQcmVmaXggPSAnQWZ0ZXJBbGwgJztcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGdsb2JhbEZhaWx1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFsZXJ0LmFwcGVuZENoaWxkKFxuICAgICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBlcnJvckJhckNsYXNzTmFtZSB9LFxuICAgICAgICAgICAgZ2xvYmFsRmFpbHVyZU1lc3NhZ2UoZ2xvYmFsRmFpbHVyZXNbaV0pXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnbG9iYWxGYWlsdXJlTWVzc2FnZShmYWlsdXJlKSB7XG4gICAgICAgIGlmIChmYWlsdXJlLmdsb2JhbEVycm9yVHlwZSA9PT0gJ2xvYWQnKSB7XG4gICAgICAgICAgdmFyIHByZWZpeCA9ICdFcnJvciBkdXJpbmcgbG9hZGluZzogJyArIGZhaWx1cmUubWVzc2FnZTtcblxuICAgICAgICAgIGlmIChmYWlsdXJlLmZpbGVuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBwcmVmaXggKyAnIGluICcgKyBmYWlsdXJlLmZpbGVuYW1lICsgJyBsaW5lICcgKyBmYWlsdXJlLmxpbmVub1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHByZWZpeDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZmFpbHVyZS5nbG9iYWxFcnJvclR5cGUgPT09ICdhZnRlckFsbCcpIHtcbiAgICAgICAgICByZXR1cm4gYWZ0ZXJBbGxNZXNzYWdlUHJlZml4ICsgZmFpbHVyZS5tZXNzYWdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWlsdXJlLm1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYWRkRGVwcmVjYXRpb25XYXJuaW5ncyhkb25lUmVzdWx0KTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGRlcHJlY2F0aW9uV2FybmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gW10sXG4gICAgICAgICAgY29udGV4dDtcblxuICAgICAgICBzd2l0Y2ggKGRlcHJlY2F0aW9uV2FybmluZ3NbaV0ucnVubmFibGVUeXBlKSB7XG4gICAgICAgICAgY2FzZSAnc3BlYyc6XG4gICAgICAgICAgICBjb250ZXh0ID0gJyhpbiBzcGVjOiAnICsgZGVwcmVjYXRpb25XYXJuaW5nc1tpXS5ydW5uYWJsZU5hbWUgKyAnKSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzdWl0ZSc6XG4gICAgICAgICAgICBjb250ZXh0ID0gJyhpbiBzdWl0ZTogJyArIGRlcHJlY2F0aW9uV2FybmluZ3NbaV0ucnVubmFibGVOYW1lICsgJyknO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnRleHQgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGRlcHJlY2F0aW9uV2FybmluZ3NbaV0ubWVzc2FnZS5zcGxpdCgnXFxuJykuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChsaW5lKTtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNyZWF0ZURvbSgnYnInKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNoaWxkcmVuWzBdID0gJ0RFUFJFQ0FUSU9OOiAnICsgY2hpbGRyZW5bMF07XG4gICAgICAgIGNoaWxkcmVuLnB1c2goY29udGV4dCk7XG5cbiAgICAgICAgaWYgKGRlcHJlY2F0aW9uV2FybmluZ3NbaV0uc3RhY2spIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNyZWF0ZUV4cGFuZGVyKGRlcHJlY2F0aW9uV2FybmluZ3NbaV0uc3RhY2spKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFsZXJ0LmFwcGVuZENoaWxkKFxuICAgICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZS1iYXIgamFzbWluZS13YXJuaW5nJyB9LFxuICAgICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHRzID0gZmluZCgnLmphc21pbmUtcmVzdWx0cycpO1xuICAgICAgcmVzdWx0cy5hcHBlbmRDaGlsZChzdW1tYXJ5KTtcblxuICAgICAgc3VtbWFyeUxpc3Qoc3RhdGVCdWlsZGVyLnRvcFJlc3VsdHMsIHN1bW1hcnkpO1xuXG4gICAgICBpZiAoZmFpbHVyZXMubGVuZ3RoKSB7XG4gICAgICAgIGFsZXJ0LmFwcGVuZENoaWxkKFxuICAgICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZS1tZW51IGphc21pbmUtYmFyIGphc21pbmUtc3BlYy1saXN0JyB9LFxuICAgICAgICAgICAgY3JlYXRlRG9tKCdzcGFuJywge30sICdTcGVjIExpc3QgfCAnKSxcbiAgICAgICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmUtZmFpbHVyZXMtbWVudScsIGhyZWY6ICcjJyB9LFxuICAgICAgICAgICAgICAnRmFpbHVyZXMnXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBhbGVydC5hcHBlbmRDaGlsZChcbiAgICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmUtbWVudSBqYXNtaW5lLWJhciBqYXNtaW5lLWZhaWx1cmUtbGlzdCcgfSxcbiAgICAgICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmUtc3BlYy1saXN0LW1lbnUnLCBocmVmOiAnIycgfSxcbiAgICAgICAgICAgICAgJ1NwZWMgTGlzdCdcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjcmVhdGVEb20oJ3NwYW4nLCB7fSwgJyB8IEZhaWx1cmVzICcpXG4gICAgICAgICAgKVxuICAgICAgICApO1xuXG4gICAgICAgIGZpbmQoJy5qYXNtaW5lLWZhaWx1cmVzLW1lbnUnKS5vbmNsaWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2V0TWVudU1vZGVUbygnamFzbWluZS1mYWlsdXJlLWxpc3QnKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIGZpbmQoJy5qYXNtaW5lLXNwZWMtbGlzdC1tZW51Jykub25jbGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNldE1lbnVNb2RlVG8oJ2phc21pbmUtc3BlYy1saXN0Jyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNldE1lbnVNb2RlVG8oJ2phc21pbmUtZmFpbHVyZS1saXN0Jyk7XG5cbiAgICAgICAgdmFyIGZhaWx1cmVOb2RlID0gZmluZCgnLmphc21pbmUtZmFpbHVyZXMnKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZhaWx1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZmFpbHVyZU5vZGUuYXBwZW5kQ2hpbGQoZmFpbHVyZXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gICAgZnVuY3Rpb24gZmFpbHVyZURvbShyZXN1bHQpIHtcbiAgICAgIHZhciBmYWlsdXJlID0gY3JlYXRlRG9tKFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lLXNwZWMtZGV0YWlsIGphc21pbmUtZmFpbGVkJyB9LFxuICAgICAgICBmYWlsdXJlRGVzY3JpcHRpb24ocmVzdWx0LCBzdGF0ZUJ1aWxkZXIuY3VycmVudFBhcmVudCksXG4gICAgICAgIGNyZWF0ZURvbSgnZGl2JywgeyBjbGFzc05hbWU6ICdqYXNtaW5lLW1lc3NhZ2VzJyB9KVxuICAgICAgKTtcbiAgICAgIHZhciBtZXNzYWdlcyA9IGZhaWx1cmUuY2hpbGROb2Rlc1sxXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBleHBlY3RhdGlvbiA9IHJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnNbaV07XG4gICAgICAgIG1lc3NhZ2VzLmFwcGVuZENoaWxkKFxuICAgICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lLXJlc3VsdC1tZXNzYWdlJyB9LFxuICAgICAgICAgICAgZXhwZWN0YXRpb24ubWVzc2FnZVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgbWVzc2FnZXMuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmUtc3RhY2stdHJhY2UnIH0sXG4gICAgICAgICAgICBleHBlY3RhdGlvbi5zdGFja1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG1lc3NhZ2VzLmFwcGVuZENoaWxkKFxuICAgICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lLXJlc3VsdC1tZXNzYWdlJyB9LFxuICAgICAgICAgICAgJ1NwZWMgaGFzIG5vIGV4cGVjdGF0aW9ucydcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHQuZGVidWdMb2dzKSB7XG4gICAgICAgIG1lc3NhZ2VzLmFwcGVuZENoaWxkKGRlYnVnTG9nVGFibGUocmVzdWx0LmRlYnVnTG9ncykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFpbHVyZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWJ1Z0xvZ1RhYmxlKGRlYnVnTG9ncykge1xuICAgICAgdmFyIHRib2R5ID0gY3JlYXRlRG9tKCd0Ym9keScpO1xuXG4gICAgICBkZWJ1Z0xvZ3MuZm9yRWFjaChmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICB0Ym9keS5hcHBlbmRDaGlsZChcbiAgICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgICAndHInLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICBjcmVhdGVEb20oJ3RkJywge30sIGVudHJ5LnRpbWVzdGFtcC50b1N0cmluZygpKSxcbiAgICAgICAgICAgIGNyZWF0ZURvbSgndGQnLCB7fSwgZW50cnkubWVzc2FnZSlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGNyZWF0ZURvbShcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZS1kZWJ1Zy1sb2cnIH0sXG4gICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmUtZGVidWctbG9nLWhlYWRlcicgfSxcbiAgICAgICAgICAnRGVidWcgbG9ncydcbiAgICAgICAgKSxcbiAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICd0YWJsZScsXG4gICAgICAgICAge30sXG4gICAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICAgJ3RoZWFkJyxcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICAgICAndHInLFxuICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgY3JlYXRlRG9tKCd0aCcsIHt9LCAnVGltZSAobXMpJyksXG4gICAgICAgICAgICAgIGNyZWF0ZURvbSgndGgnLCB7fSwgJ01lc3NhZ2UnKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICksXG4gICAgICAgICAgdGJvZHlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdW1tYXJ5TGlzdChyZXN1bHRzVHJlZSwgZG9tUGFyZW50KSB7XG4gICAgICB2YXIgc3BlY0xpc3ROb2RlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRzVHJlZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmVzdWx0Tm9kZSA9IHJlc3VsdHNUcmVlLmNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoZmlsdGVyU3BlY3MgJiYgIWhhc0FjdGl2ZVNwZWMocmVzdWx0Tm9kZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0Tm9kZS50eXBlID09PSAnc3VpdGUnKSB7XG4gICAgICAgICAgdmFyIHN1aXRlTGlzdE5vZGUgPSBjcmVhdGVEb20oXG4gICAgICAgICAgICAndWwnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lLXN1aXRlJywgaWQ6ICdzdWl0ZS0nICsgcmVzdWx0Tm9kZS5yZXN1bHQuaWQgfSxcbiAgICAgICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAgICAgJ2xpJyxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTpcbiAgICAgICAgICAgICAgICAgICdqYXNtaW5lLXN1aXRlLWRldGFpbCBqYXNtaW5lLScgKyByZXN1bHROb2RlLnJlc3VsdC5zdGF0dXNcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICAgICB7IGhyZWY6IHNwZWNIcmVmKHJlc3VsdE5vZGUucmVzdWx0KSB9LFxuICAgICAgICAgICAgICAgIHJlc3VsdE5vZGUucmVzdWx0LmRlc2NyaXB0aW9uXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgc3VtbWFyeUxpc3QocmVzdWx0Tm9kZSwgc3VpdGVMaXN0Tm9kZSk7XG4gICAgICAgICAgZG9tUGFyZW50LmFwcGVuZENoaWxkKHN1aXRlTGlzdE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHROb2RlLnR5cGUgPT09ICdzcGVjJykge1xuICAgICAgICAgIGlmIChkb21QYXJlbnQuZ2V0QXR0cmlidXRlKCdjbGFzcycpICE9PSAnamFzbWluZS1zcGVjcycpIHtcbiAgICAgICAgICAgIHNwZWNMaXN0Tm9kZSA9IGNyZWF0ZURvbSgndWwnLCB7IGNsYXNzTmFtZTogJ2phc21pbmUtc3BlY3MnIH0pO1xuICAgICAgICAgICAgZG9tUGFyZW50LmFwcGVuZENoaWxkKHNwZWNMaXN0Tm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzcGVjRGVzY3JpcHRpb24gPSByZXN1bHROb2RlLnJlc3VsdC5kZXNjcmlwdGlvbjtcbiAgICAgICAgICBpZiAobm9FeHBlY3RhdGlvbnMocmVzdWx0Tm9kZS5yZXN1bHQpKSB7XG4gICAgICAgICAgICBzcGVjRGVzY3JpcHRpb24gPSAnU1BFQyBIQVMgTk8gRVhQRUNUQVRJT05TICcgKyBzcGVjRGVzY3JpcHRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHJlc3VsdE5vZGUucmVzdWx0LnN0YXR1cyA9PT0gJ3BlbmRpbmcnICYmXG4gICAgICAgICAgICByZXN1bHROb2RlLnJlc3VsdC5wZW5kaW5nUmVhc29uICE9PSAnJ1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgc3BlY0Rlc2NyaXB0aW9uID1cbiAgICAgICAgICAgICAgc3BlY0Rlc2NyaXB0aW9uICtcbiAgICAgICAgICAgICAgJyBQRU5ESU5HIFdJVEggTUVTU0FHRTogJyArXG4gICAgICAgICAgICAgIHJlc3VsdE5vZGUucmVzdWx0LnBlbmRpbmdSZWFzb247XG4gICAgICAgICAgfVxuICAgICAgICAgIHNwZWNMaXN0Tm9kZS5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAgICAgJ2xpJyxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2phc21pbmUtJyArIHJlc3VsdE5vZGUucmVzdWx0LnN0YXR1cyxcbiAgICAgICAgICAgICAgICBpZDogJ3NwZWMtJyArIHJlc3VsdE5vZGUucmVzdWx0LmlkXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAgICAgICAnYScsXG4gICAgICAgICAgICAgICAgeyBocmVmOiBzcGVjSHJlZihyZXN1bHROb2RlLnJlc3VsdCkgfSxcbiAgICAgICAgICAgICAgICBzcGVjRGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvcHRpb25zTWVudShjb25maWcpIHtcbiAgICAgIHZhciBvcHRpb25zTWVudURvbSA9IGNyZWF0ZURvbShcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZS1ydW4tb3B0aW9ucycgfSxcbiAgICAgICAgY3JlYXRlRG9tKCdzcGFuJywgeyBjbGFzc05hbWU6ICdqYXNtaW5lLXRyaWdnZXInIH0sICdPcHRpb25zJyksXG4gICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmUtcGF5bG9hZCcgfSxcbiAgICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZS1zdG9wLW9uLWZhaWx1cmUnIH0sXG4gICAgICAgICAgICBjcmVhdGVEb20oJ2lucHV0Jywge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6ICdqYXNtaW5lLWZhaWwtZmFzdCcsXG4gICAgICAgICAgICAgIGlkOiAnamFzbWluZS1mYWlsLWZhc3QnLFxuICAgICAgICAgICAgICB0eXBlOiAnY2hlY2tib3gnXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAgICAgJ2xhYmVsJyxcbiAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lLWxhYmVsJywgZm9yOiAnamFzbWluZS1mYWlsLWZhc3QnIH0sXG4gICAgICAgICAgICAgICdzdG9wIGV4ZWN1dGlvbiBvbiBzcGVjIGZhaWx1cmUnXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSxcbiAgICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZS10aHJvdy1mYWlsdXJlcycgfSxcbiAgICAgICAgICAgIGNyZWF0ZURvbSgnaW5wdXQnLCB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2phc21pbmUtdGhyb3cnLFxuICAgICAgICAgICAgICBpZDogJ2phc21pbmUtdGhyb3ctZmFpbHVyZXMnLFxuICAgICAgICAgICAgICB0eXBlOiAnY2hlY2tib3gnXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAgICAgJ2xhYmVsJyxcbiAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lLWxhYmVsJywgZm9yOiAnamFzbWluZS10aHJvdy1mYWlsdXJlcycgfSxcbiAgICAgICAgICAgICAgJ3N0b3Agc3BlYyBvbiBleHBlY3RhdGlvbiBmYWlsdXJlJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgICksXG4gICAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmUtcmFuZG9tLW9yZGVyJyB9LFxuICAgICAgICAgICAgY3JlYXRlRG9tKCdpbnB1dCcsIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnamFzbWluZS1yYW5kb20nLFxuICAgICAgICAgICAgICBpZDogJ2phc21pbmUtcmFuZG9tLW9yZGVyJyxcbiAgICAgICAgICAgICAgdHlwZTogJ2NoZWNrYm94J1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgICAgICdsYWJlbCcsXG4gICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZS1sYWJlbCcsIGZvcjogJ2phc21pbmUtcmFuZG9tLW9yZGVyJyB9LFxuICAgICAgICAgICAgICAncnVuIHRlc3RzIGluIHJhbmRvbSBvcmRlcidcbiAgICAgICAgICAgIClcbiAgICAgICAgICApLFxuICAgICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lLWhpZGUtZGlzYWJsZWQnIH0sXG4gICAgICAgICAgICBjcmVhdGVEb20oJ2lucHV0Jywge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6ICdqYXNtaW5lLWRpc2FibGVkJyxcbiAgICAgICAgICAgICAgaWQ6ICdqYXNtaW5lLWhpZGUtZGlzYWJsZWQnLFxuICAgICAgICAgICAgICB0eXBlOiAnY2hlY2tib3gnXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAgICAgJ2xhYmVsJyxcbiAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lLWxhYmVsJywgZm9yOiAnamFzbWluZS1oaWRlLWRpc2FibGVkJyB9LFxuICAgICAgICAgICAgICAnaGlkZSBkaXNhYmxlZCB0ZXN0cydcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICk7XG5cbiAgICAgIHZhciBmYWlsRmFzdENoZWNrYm94ID0gb3B0aW9uc01lbnVEb20ucXVlcnlTZWxlY3RvcignI2phc21pbmUtZmFpbC1mYXN0Jyk7XG4gICAgICBmYWlsRmFzdENoZWNrYm94LmNoZWNrZWQgPSBjb25maWcuc3RvcE9uU3BlY0ZhaWx1cmU7XG4gICAgICBmYWlsRmFzdENoZWNrYm94Lm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbmF2aWdhdGVXaXRoTmV3UGFyYW0oJ3N0b3BPblNwZWNGYWlsdXJlJywgIWNvbmZpZy5zdG9wT25TcGVjRmFpbHVyZSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgdGhyb3dDaGVja2JveCA9IG9wdGlvbnNNZW51RG9tLnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICcjamFzbWluZS10aHJvdy1mYWlsdXJlcydcbiAgICAgICk7XG4gICAgICB0aHJvd0NoZWNrYm94LmNoZWNrZWQgPSBjb25maWcuc3RvcFNwZWNPbkV4cGVjdGF0aW9uRmFpbHVyZTtcbiAgICAgIHRocm93Q2hlY2tib3gub25jbGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBuYXZpZ2F0ZVdpdGhOZXdQYXJhbShcbiAgICAgICAgICAnc3RvcFNwZWNPbkV4cGVjdGF0aW9uRmFpbHVyZScsXG4gICAgICAgICAgIWNvbmZpZy5zdG9wU3BlY09uRXhwZWN0YXRpb25GYWlsdXJlXG4gICAgICAgICk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgcmFuZG9tQ2hlY2tib3ggPSBvcHRpb25zTWVudURvbS5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAnI2phc21pbmUtcmFuZG9tLW9yZGVyJ1xuICAgICAgKTtcbiAgICAgIHJhbmRvbUNoZWNrYm94LmNoZWNrZWQgPSBjb25maWcucmFuZG9tO1xuICAgICAgcmFuZG9tQ2hlY2tib3gub25jbGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBuYXZpZ2F0ZVdpdGhOZXdQYXJhbSgncmFuZG9tJywgIWNvbmZpZy5yYW5kb20pO1xuICAgICAgfTtcblxuICAgICAgdmFyIGhpZGVEaXNhYmxlZCA9IG9wdGlvbnNNZW51RG9tLnF1ZXJ5U2VsZWN0b3IoJyNqYXNtaW5lLWhpZGUtZGlzYWJsZWQnKTtcbiAgICAgIGhpZGVEaXNhYmxlZC5jaGVja2VkID0gY29uZmlnLmhpZGVEaXNhYmxlZDtcbiAgICAgIGhpZGVEaXNhYmxlZC5vbmNsaWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG5hdmlnYXRlV2l0aE5ld1BhcmFtKCdoaWRlRGlzYWJsZWQnLCAhY29uZmlnLmhpZGVEaXNhYmxlZCk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgb3B0aW9uc1RyaWdnZXIgPSBvcHRpb25zTWVudURvbS5xdWVyeVNlbGVjdG9yKCcuamFzbWluZS10cmlnZ2VyJyksXG4gICAgICAgIG9wdGlvbnNQYXlsb2FkID0gb3B0aW9uc01lbnVEb20ucXVlcnlTZWxlY3RvcignLmphc21pbmUtcGF5bG9hZCcpLFxuICAgICAgICBpc09wZW4gPSAvXFxiamFzbWluZS1vcGVuXFxiLztcblxuICAgICAgb3B0aW9uc1RyaWdnZXIub25jbGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoaXNPcGVuLnRlc3Qob3B0aW9uc1BheWxvYWQuY2xhc3NOYW1lKSkge1xuICAgICAgICAgIG9wdGlvbnNQYXlsb2FkLmNsYXNzTmFtZSA9IG9wdGlvbnNQYXlsb2FkLmNsYXNzTmFtZS5yZXBsYWNlKFxuICAgICAgICAgICAgaXNPcGVuLFxuICAgICAgICAgICAgJydcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnNQYXlsb2FkLmNsYXNzTmFtZSArPSAnIGphc21pbmUtb3Blbic7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBvcHRpb25zTWVudURvbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmYWlsdXJlRGVzY3JpcHRpb24ocmVzdWx0LCBzdWl0ZSkge1xuICAgICAgdmFyIHdyYXBwZXIgPSBjcmVhdGVEb20oXG4gICAgICAgICdkaXYnLFxuICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmUtZGVzY3JpcHRpb24nIH0sXG4gICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAnYScsXG4gICAgICAgICAgeyB0aXRsZTogcmVzdWx0LmRlc2NyaXB0aW9uLCBocmVmOiBzcGVjSHJlZihyZXN1bHQpIH0sXG4gICAgICAgICAgcmVzdWx0LmRlc2NyaXB0aW9uXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICB2YXIgc3VpdGVMaW5rO1xuXG4gICAgICB3aGlsZSAoc3VpdGUgJiYgc3VpdGUucGFyZW50KSB7XG4gICAgICAgIHdyYXBwZXIuaW5zZXJ0QmVmb3JlKGNyZWF0ZVRleHROb2RlKCcgPiAnKSwgd3JhcHBlci5maXJzdENoaWxkKTtcbiAgICAgICAgc3VpdGVMaW5rID0gY3JlYXRlRG9tKFxuICAgICAgICAgICdhJyxcbiAgICAgICAgICB7IGhyZWY6IHN1aXRlSHJlZihzdWl0ZSkgfSxcbiAgICAgICAgICBzdWl0ZS5yZXN1bHQuZGVzY3JpcHRpb25cbiAgICAgICAgKTtcbiAgICAgICAgd3JhcHBlci5pbnNlcnRCZWZvcmUoc3VpdGVMaW5rLCB3cmFwcGVyLmZpcnN0Q2hpbGQpO1xuXG4gICAgICAgIHN1aXRlID0gc3VpdGUucGFyZW50O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdWl0ZUhyZWYoc3VpdGUpIHtcbiAgICAgIHZhciBlbHMgPSBbXTtcblxuICAgICAgd2hpbGUgKHN1aXRlICYmIHN1aXRlLnBhcmVudCkge1xuICAgICAgICBlbHMudW5zaGlmdChzdWl0ZS5yZXN1bHQuZGVzY3JpcHRpb24pO1xuICAgICAgICBzdWl0ZSA9IHN1aXRlLnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgLy8gaW5jbHVkZSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgdG8gZml4IGlzc3VlIHdpdGgga2FybWEtamFzbWluZS1odG1sLXJlcG9ydGVyIGluIGFuZ3VsYXI6IHNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzbWluZS9qYXNtaW5lL2lzc3Vlcy8xOTA2XG4gICAgICByZXR1cm4gKFxuICAgICAgICAod2luZG93LmxvY2F0aW9uLnBhdGhuYW1lIHx8ICcnKSArXG4gICAgICAgIGFkZFRvRXhpc3RpbmdRdWVyeVN0cmluZygnc3BlYycsIGVscy5qb2luKCcgJykpXG4gICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZERlcHJlY2F0aW9uV2FybmluZ3MocmVzdWx0LCBydW5uYWJsZVR5cGUpIHtcbiAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LmRlcHJlY2F0aW9uV2FybmluZ3MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQuZGVwcmVjYXRpb25XYXJuaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciB3YXJuaW5nID0gcmVzdWx0LmRlcHJlY2F0aW9uV2FybmluZ3NbaV0ubWVzc2FnZTtcbiAgICAgICAgICBkZXByZWNhdGlvbldhcm5pbmdzLnB1c2goe1xuICAgICAgICAgICAgbWVzc2FnZTogd2FybmluZyxcbiAgICAgICAgICAgIHN0YWNrOiByZXN1bHQuZGVwcmVjYXRpb25XYXJuaW5nc1tpXS5zdGFjayxcbiAgICAgICAgICAgIHJ1bm5hYmxlTmFtZTogcmVzdWx0LmZ1bGxOYW1lLFxuICAgICAgICAgICAgcnVubmFibGVUeXBlOiBydW5uYWJsZVR5cGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUV4cGFuZGVyKHN0YWNrVHJhY2UpIHtcbiAgICAgIHZhciBleHBhbmRMaW5rID0gY3JlYXRlRG9tKCdhJywgeyBocmVmOiAnIycgfSwgJ1Nob3cgc3RhY2sgdHJhY2UnKTtcbiAgICAgIHZhciByb290ID0gY3JlYXRlRG9tKFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lLWV4cGFuZGVyJyB9LFxuICAgICAgICBleHBhbmRMaW5rLFxuICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lLWV4cGFuZGVyLWNvbnRlbnRzIGphc21pbmUtc3RhY2stdHJhY2UnIH0sXG4gICAgICAgICAgc3RhY2tUcmFjZVxuICAgICAgICApXG4gICAgICApO1xuXG4gICAgICBleHBhbmRMaW5rLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKHJvb3QuY2xhc3NMaXN0LmNvbnRhaW5zKCdqYXNtaW5lLWV4cGFuZGVkJykpIHtcbiAgICAgICAgICByb290LmNsYXNzTGlzdC5yZW1vdmUoJ2phc21pbmUtZXhwYW5kZWQnKTtcbiAgICAgICAgICBleHBhbmRMaW5rLnRleHRDb250ZW50ID0gJ1Nob3cgc3RhY2sgdHJhY2UnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvb3QuY2xhc3NMaXN0LmFkZCgnamFzbWluZS1leHBhbmRlZCcpO1xuICAgICAgICAgIGV4cGFuZExpbmsudGV4dENvbnRlbnQgPSAnSGlkZSBzdGFjayB0cmFjZSc7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gZ2V0Q29udGFpbmVyKCkucXVlcnlTZWxlY3RvcignLmphc21pbmVfaHRtbC1yZXBvcnRlciAnICsgc2VsZWN0b3IpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFyUHJpb3IoKSB7XG4gICAgICAvLyByZXR1cm4gdGhlIHJlcG9ydGVyXG4gICAgICB2YXIgb2xkUmVwb3J0ZXIgPSBmaW5kKCcnKTtcblxuICAgICAgaWYgKG9sZFJlcG9ydGVyKSB7XG4gICAgICAgIGdldENvbnRhaW5lcigpLnJlbW92ZUNoaWxkKG9sZFJlcG9ydGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEb20odHlwZSwgYXR0cnMsIGNoaWxkcmVuQXJyYXlPclZhckFyZ3MpIHtcbiAgICAgIHZhciBlbCA9IGNyZWF0ZUVsZW1lbnQodHlwZSksXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBpO1xuXG4gICAgICBpZiAoaiQuaXNBcnJheV8oY2hpbGRyZW5BcnJheU9yVmFyQXJncykpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlbkFycmF5T3JWYXJBcmdzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGRyZW4gPSBbXTtcblxuICAgICAgICBmb3IgKGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChhcmd1bWVudHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcblxuICAgICAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGVsLmFwcGVuZENoaWxkKGNyZWF0ZVRleHROb2RlKGNoaWxkKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgICAgaWYgKGF0dHIgPT0gJ2NsYXNzTmFtZScpIHtcbiAgICAgICAgICBlbFthdHRyXSA9IGF0dHJzW2F0dHJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyLCBhdHRyc1thdHRyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBsdXJhbGl6ZShzaW5ndWxhciwgY291bnQpIHtcbiAgICAgIHZhciB3b3JkID0gY291bnQgPT0gMSA/IHNpbmd1bGFyIDogc2luZ3VsYXIgKyAncyc7XG5cbiAgICAgIHJldHVybiAnJyArIGNvdW50ICsgJyAnICsgd29yZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzcGVjSHJlZihyZXN1bHQpIHtcbiAgICAgIC8vIGluY2x1ZGUgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lIHRvIGZpeCBpc3N1ZSB3aXRoIGthcm1hLWphc21pbmUtaHRtbC1yZXBvcnRlciBpbiBhbmd1bGFyOiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc21pbmUvamFzbWluZS9pc3N1ZXMvMTkwNlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSB8fCAnJykgK1xuICAgICAgICBhZGRUb0V4aXN0aW5nUXVlcnlTdHJpbmcoJ3NwZWMnLCByZXN1bHQuZnVsbE5hbWUpXG4gICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlZWRIcmVmKHNlZWQpIHtcbiAgICAgIC8vIGluY2x1ZGUgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lIHRvIGZpeCBpc3N1ZSB3aXRoIGthcm1hLWphc21pbmUtaHRtbC1yZXBvcnRlciBpbiBhbmd1bGFyOiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc21pbmUvamFzbWluZS9pc3N1ZXMvMTkwNlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSB8fCAnJykgK1xuICAgICAgICBhZGRUb0V4aXN0aW5nUXVlcnlTdHJpbmcoJ3NlZWQnLCBzZWVkKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0UXVlcnlTdHJpbmcoa2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuICc/JyArIGtleSArICc9JyArIHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE1lbnVNb2RlVG8obW9kZSkge1xuICAgICAgaHRtbFJlcG9ydGVyTWFpbi5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2phc21pbmVfaHRtbC1yZXBvcnRlciAnICsgbW9kZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9FeHBlY3RhdGlvbnMocmVzdWx0KSB7XG4gICAgICB2YXIgYWxsRXhwZWN0YXRpb25zID1cbiAgICAgICAgcmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9ucy5sZW5ndGggKyByZXN1bHQucGFzc2VkRXhwZWN0YXRpb25zLmxlbmd0aDtcblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgYWxsRXhwZWN0YXRpb25zID09PSAwICYmXG4gICAgICAgIChyZXN1bHQuc3RhdHVzID09PSAncGFzc2VkJyB8fCByZXN1bHQuc3RhdHVzID09PSAnZmFpbGVkJylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzQWN0aXZlU3BlYyhyZXN1bHROb2RlKSB7XG4gICAgICBpZiAocmVzdWx0Tm9kZS50eXBlID09ICdzcGVjJyAmJiByZXN1bHROb2RlLnJlc3VsdC5zdGF0dXMgIT0gJ2V4Y2x1ZGVkJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdE5vZGUudHlwZSA9PSAnc3VpdGUnKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gcmVzdWx0Tm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICBpZiAoaGFzQWN0aXZlU3BlYyhyZXN1bHROb2RlLmNoaWxkcmVuW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEh0bWxSZXBvcnRlcjtcbn07XG5cbmphc21pbmVSZXF1aXJlLkh0bWxTcGVjRmlsdGVyID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIEh0bWxTcGVjRmlsdGVyKG9wdGlvbnMpIHtcbiAgICB2YXIgZmlsdGVyU3RyaW5nID1cbiAgICAgIG9wdGlvbnMgJiZcbiAgICAgIG9wdGlvbnMuZmlsdGVyU3RyaW5nKCkgJiZcbiAgICAgIG9wdGlvbnMuZmlsdGVyU3RyaW5nKCkucmVwbGFjZSgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csICdcXFxcJCYnKTtcbiAgICB2YXIgZmlsdGVyUGF0dGVybiA9IG5ldyBSZWdFeHAoZmlsdGVyU3RyaW5nKTtcblxuICAgIHRoaXMubWF0Y2hlcyA9IGZ1bmN0aW9uKHNwZWNOYW1lKSB7XG4gICAgICByZXR1cm4gZmlsdGVyUGF0dGVybi50ZXN0KHNwZWNOYW1lKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIEh0bWxTcGVjRmlsdGVyO1xufTtcblxuamFzbWluZVJlcXVpcmUuUmVzdWx0c05vZGUgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gUmVzdWx0c05vZGUocmVzdWx0LCB0eXBlLCBwYXJlbnQpIHtcbiAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuXG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuXG4gICAgdGhpcy5hZGRDaGlsZCA9IGZ1bmN0aW9uKHJlc3VsdCwgdHlwZSkge1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKG5ldyBSZXN1bHRzTm9kZShyZXN1bHQsIHR5cGUsIHRoaXMpKTtcbiAgICB9O1xuXG4gICAgdGhpcy5sYXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgIH07XG5cbiAgICB0aGlzLnVwZGF0ZVJlc3VsdCA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBSZXN1bHRzTm9kZTtcbn07XG5cbmphc21pbmVSZXF1aXJlLlF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFF1ZXJ5U3RyaW5nKG9wdGlvbnMpIHtcbiAgICB0aGlzLm5hdmlnYXRlV2l0aE5ld1BhcmFtID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgb3B0aW9ucy5nZXRXaW5kb3dMb2NhdGlvbigpLnNlYXJjaCA9IHRoaXMuZnVsbFN0cmluZ1dpdGhOZXdQYXJhbShcbiAgICAgICAga2V5LFxuICAgICAgICB2YWx1ZVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgdGhpcy5mdWxsU3RyaW5nV2l0aE5ld1BhcmFtID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIHBhcmFtTWFwID0gcXVlcnlTdHJpbmdUb1BhcmFtTWFwKCk7XG4gICAgICBwYXJhbU1hcFtrZXldID0gdmFsdWU7XG4gICAgICByZXR1cm4gdG9RdWVyeVN0cmluZyhwYXJhbU1hcCk7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0UGFyYW0gPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBxdWVyeVN0cmluZ1RvUGFyYW1NYXAoKVtrZXldO1xuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcztcblxuICAgIGZ1bmN0aW9uIHRvUXVlcnlTdHJpbmcocGFyYW1NYXApIHtcbiAgICAgIHZhciBxU3RyUGFpcnMgPSBbXTtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gcGFyYW1NYXApIHtcbiAgICAgICAgcVN0clBhaXJzLnB1c2goXG4gICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHByb3ApICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtTWFwW3Byb3BdKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuICc/JyArIHFTdHJQYWlycy5qb2luKCcmJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcXVlcnlTdHJpbmdUb1BhcmFtTWFwKCkge1xuICAgICAgdmFyIHBhcmFtU3RyID0gb3B0aW9ucy5nZXRXaW5kb3dMb2NhdGlvbigpLnNlYXJjaC5zdWJzdHJpbmcoMSksXG4gICAgICAgIHBhcmFtcyA9IFtdLFxuICAgICAgICBwYXJhbU1hcCA9IHt9O1xuXG4gICAgICBpZiAocGFyYW1TdHIubGVuZ3RoID4gMCkge1xuICAgICAgICBwYXJhbXMgPSBwYXJhbVN0ci5zcGxpdCgnJicpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwID0gcGFyYW1zW2ldLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gZGVjb2RlVVJJQ29tcG9uZW50KHBbMV0pO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ3RydWUnIHx8IHZhbHVlID09PSAnZmFsc2UnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJhbU1hcFtkZWNvZGVVUklDb21wb25lbnQocFswXSldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcmFtTWFwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBRdWVyeVN0cmluZztcbn07XG4iLCIvKlxuQ29weXJpZ2h0IChjKSAyMDA4LTIwMjIgUGl2b3RhbCBMYWJzXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG5cIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbndpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbmRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xucGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG50aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG5pbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbkVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbk5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkVcbkxJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cbk9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG52YXIgZ2V0SmFzbWluZVJlcXVpcmVPYmogPSAoZnVuY3Rpb24oamFzbWluZUdsb2JhbCkge1xuICB2YXIgamFzbWluZVJlcXVpcmU7XG5cbiAgaWYgKFxuICAgIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgbW9kdWxlLmV4cG9ydHMgJiZcbiAgICB0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCdcbiAgKSB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBqYXNtaW5lR2xvYmFsID0gZ2xvYmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICBqYXNtaW5lR2xvYmFsID0ge307XG4gICAgfVxuICAgIGphc21pbmVSZXF1aXJlID0gZXhwb3J0cztcbiAgfSBlbHNlIHtcbiAgICBpZiAoXG4gICAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgdHlwZW9mIHdpbmRvdy50b1N0cmluZyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgd2luZG93LnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IEdqc0dsb2JhbF0nXG4gICAgKSB7XG4gICAgICBqYXNtaW5lR2xvYmFsID0gd2luZG93O1xuICAgIH1cbiAgICBqYXNtaW5lUmVxdWlyZSA9IGphc21pbmVHbG9iYWwuamFzbWluZVJlcXVpcmUgPSB7fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEphc21pbmVSZXF1aXJlKCkge1xuICAgIHJldHVybiBqYXNtaW5lUmVxdWlyZTtcbiAgfVxuXG4gIGdldEphc21pbmVSZXF1aXJlKCkuY29yZSA9IGZ1bmN0aW9uKGpSZXF1aXJlKSB7XG4gICAgdmFyIGokID0ge307XG5cbiAgICBqUmVxdWlyZS5iYXNlKGokLCBqYXNtaW5lR2xvYmFsKTtcbiAgICBqJC51dGlsID0galJlcXVpcmUudXRpbChqJCk7XG4gICAgaiQuZXJyb3JzID0galJlcXVpcmUuZXJyb3JzKCk7XG4gICAgaiQuZm9ybWF0RXJyb3JNc2cgPSBqUmVxdWlyZS5mb3JtYXRFcnJvck1zZygpO1xuICAgIGokLkFueSA9IGpSZXF1aXJlLkFueShqJCk7XG4gICAgaiQuQW55dGhpbmcgPSBqUmVxdWlyZS5Bbnl0aGluZyhqJCk7XG4gICAgaiQuQ2FsbFRyYWNrZXIgPSBqUmVxdWlyZS5DYWxsVHJhY2tlcihqJCk7XG4gICAgaiQuTW9ja0RhdGUgPSBqUmVxdWlyZS5Nb2NrRGF0ZShqJCk7XG4gICAgaiQuZ2V0Q2xlYXJTdGFjayA9IGpSZXF1aXJlLmNsZWFyU3RhY2soaiQpO1xuICAgIGokLkNsb2NrID0galJlcXVpcmUuQ2xvY2soKTtcbiAgICBqJC5EZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIgPSBqUmVxdWlyZS5EZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIoaiQpO1xuICAgIGokLkRlcHJlY2F0b3IgPSBqUmVxdWlyZS5EZXByZWNhdG9yKGokKTtcbiAgICBqJC5FbnYgPSBqUmVxdWlyZS5FbnYoaiQpO1xuICAgIGokLlN0YWNrVHJhY2UgPSBqUmVxdWlyZS5TdGFja1RyYWNlKGokKTtcbiAgICBqJC5FeGNlcHRpb25Gb3JtYXR0ZXIgPSBqUmVxdWlyZS5FeGNlcHRpb25Gb3JtYXR0ZXIoaiQpO1xuICAgIGokLkV4cGVjdGF0aW9uRmlsdGVyQ2hhaW4gPSBqUmVxdWlyZS5FeHBlY3RhdGlvbkZpbHRlckNoYWluKCk7XG4gICAgaiQuRXhwZWN0b3IgPSBqUmVxdWlyZS5FeHBlY3RvcihqJCk7XG4gICAgaiQuRXhwZWN0YXRpb24gPSBqUmVxdWlyZS5FeHBlY3RhdGlvbihqJCk7XG4gICAgaiQuYnVpbGRFeHBlY3RhdGlvblJlc3VsdCA9IGpSZXF1aXJlLmJ1aWxkRXhwZWN0YXRpb25SZXN1bHQoaiQpO1xuICAgIGokLkpzQXBpUmVwb3J0ZXIgPSBqUmVxdWlyZS5Kc0FwaVJlcG9ydGVyKGokKTtcbiAgICBqJC5tYWtlUHJldHR5UHJpbnRlciA9IGpSZXF1aXJlLm1ha2VQcmV0dHlQcmludGVyKGokKTtcbiAgICBqJC5iYXNpY1ByZXR0eVByaW50ZXJfID0gaiQubWFrZVByZXR0eVByaW50ZXIoKTtcbiAgICBqJC5NYXRjaGVyc1V0aWwgPSBqUmVxdWlyZS5NYXRjaGVyc1V0aWwoaiQpO1xuICAgIGokLk9iamVjdENvbnRhaW5pbmcgPSBqUmVxdWlyZS5PYmplY3RDb250YWluaW5nKGokKTtcbiAgICBqJC5BcnJheUNvbnRhaW5pbmcgPSBqUmVxdWlyZS5BcnJheUNvbnRhaW5pbmcoaiQpO1xuICAgIGokLkFycmF5V2l0aEV4YWN0Q29udGVudHMgPSBqUmVxdWlyZS5BcnJheVdpdGhFeGFjdENvbnRlbnRzKGokKTtcbiAgICBqJC5NYXBDb250YWluaW5nID0galJlcXVpcmUuTWFwQ29udGFpbmluZyhqJCk7XG4gICAgaiQuU2V0Q29udGFpbmluZyA9IGpSZXF1aXJlLlNldENvbnRhaW5pbmcoaiQpO1xuICAgIGokLlF1ZXVlUnVubmVyID0galJlcXVpcmUuUXVldWVSdW5uZXIoaiQpO1xuICAgIGokLk5ldmVyU2tpcFBvbGljeSA9IGpSZXF1aXJlLk5ldmVyU2tpcFBvbGljeShqJCk7XG4gICAgaiQuU2tpcEFmdGVyQmVmb3JlQWxsRXJyb3JQb2xpY3kgPSBqUmVxdWlyZS5Ta2lwQWZ0ZXJCZWZvcmVBbGxFcnJvclBvbGljeShcbiAgICAgIGokXG4gICAgKTtcbiAgICBqJC5Db21wbGV0ZU9uRmlyc3RFcnJvclNraXBQb2xpY3kgPSBqUmVxdWlyZS5Db21wbGV0ZU9uRmlyc3RFcnJvclNraXBQb2xpY3koXG4gICAgICBqJFxuICAgICk7XG4gICAgaiQuUmVwb3J0RGlzcGF0Y2hlciA9IGpSZXF1aXJlLlJlcG9ydERpc3BhdGNoZXIoaiQpO1xuICAgIGokLlNwZWMgPSBqUmVxdWlyZS5TcGVjKGokKTtcbiAgICBqJC5TcHkgPSBqUmVxdWlyZS5TcHkoaiQpO1xuICAgIGokLlNweUZhY3RvcnkgPSBqUmVxdWlyZS5TcHlGYWN0b3J5KGokKTtcbiAgICBqJC5TcHlSZWdpc3RyeSA9IGpSZXF1aXJlLlNweVJlZ2lzdHJ5KGokKTtcbiAgICBqJC5TcHlTdHJhdGVneSA9IGpSZXF1aXJlLlNweVN0cmF0ZWd5KGokKTtcbiAgICBqJC5TdHJpbmdNYXRjaGluZyA9IGpSZXF1aXJlLlN0cmluZ01hdGNoaW5nKGokKTtcbiAgICBqJC5TdHJpbmdDb250YWluaW5nID0galJlcXVpcmUuU3RyaW5nQ29udGFpbmluZyhqJCk7XG4gICAgaiQuVXNlckNvbnRleHQgPSBqUmVxdWlyZS5Vc2VyQ29udGV4dChqJCk7XG4gICAgaiQuU3VpdGUgPSBqUmVxdWlyZS5TdWl0ZShqJCk7XG4gICAgaiQuVGltZXIgPSBqUmVxdWlyZS5UaW1lcigpO1xuICAgIGokLlRyZWVQcm9jZXNzb3IgPSBqUmVxdWlyZS5UcmVlUHJvY2Vzc29yKCk7XG4gICAgaiQudmVyc2lvbiA9IGpSZXF1aXJlLnZlcnNpb24oKTtcbiAgICBqJC5PcmRlciA9IGpSZXF1aXJlLk9yZGVyKCk7XG4gICAgaiQuRGlmZkJ1aWxkZXIgPSBqUmVxdWlyZS5EaWZmQnVpbGRlcihqJCk7XG4gICAgaiQuTnVsbERpZmZCdWlsZGVyID0galJlcXVpcmUuTnVsbERpZmZCdWlsZGVyKGokKTtcbiAgICBqJC5PYmplY3RQYXRoID0galJlcXVpcmUuT2JqZWN0UGF0aChqJCk7XG4gICAgaiQuTWlzbWF0Y2hUcmVlID0galJlcXVpcmUuTWlzbWF0Y2hUcmVlKGokKTtcbiAgICBqJC5HbG9iYWxFcnJvcnMgPSBqUmVxdWlyZS5HbG9iYWxFcnJvcnMoaiQpO1xuXG4gICAgaiQuVHJ1dGh5ID0galJlcXVpcmUuVHJ1dGh5KGokKTtcbiAgICBqJC5GYWxzeSA9IGpSZXF1aXJlLkZhbHN5KGokKTtcbiAgICBqJC5FbXB0eSA9IGpSZXF1aXJlLkVtcHR5KGokKTtcbiAgICBqJC5Ob3RFbXB0eSA9IGpSZXF1aXJlLk5vdEVtcHR5KGokKTtcblxuICAgIGokLm1hdGNoZXJzID0galJlcXVpcmUucmVxdWlyZU1hdGNoZXJzKGpSZXF1aXJlLCBqJCk7XG4gICAgaiQuYXN5bmNNYXRjaGVycyA9IGpSZXF1aXJlLnJlcXVpcmVBc3luY01hdGNoZXJzKGpSZXF1aXJlLCBqJCk7XG5cbiAgICByZXR1cm4gaiQ7XG4gIH07XG5cbiAgcmV0dXJuIGdldEphc21pbmVSZXF1aXJlO1xufSkodGhpcyk7XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkucmVxdWlyZU1hdGNoZXJzID0gZnVuY3Rpb24oalJlcXVpcmUsIGokKSB7XG4gIHZhciBhdmFpbGFibGVNYXRjaGVycyA9IFtcbiAgICAgICdub3RoaW5nJyxcbiAgICAgICd0b0JlJyxcbiAgICAgICd0b0JlQ2xvc2VUbycsXG4gICAgICAndG9CZURlZmluZWQnLFxuICAgICAgJ3RvQmVJbnN0YW5jZU9mJyxcbiAgICAgICd0b0JlRmFsc2UnLFxuICAgICAgJ3RvQmVGYWxzeScsXG4gICAgICAndG9CZUdyZWF0ZXJUaGFuJyxcbiAgICAgICd0b0JlR3JlYXRlclRoYW5PckVxdWFsJyxcbiAgICAgICd0b0JlTGVzc1RoYW4nLFxuICAgICAgJ3RvQmVMZXNzVGhhbk9yRXF1YWwnLFxuICAgICAgJ3RvQmVOYU4nLFxuICAgICAgJ3RvQmVOZWdhdGl2ZUluZmluaXR5JyxcbiAgICAgICd0b0JlTnVsbCcsXG4gICAgICAndG9CZVBvc2l0aXZlSW5maW5pdHknLFxuICAgICAgJ3RvQmVUcnVlJyxcbiAgICAgICd0b0JlVHJ1dGh5JyxcbiAgICAgICd0b0JlVW5kZWZpbmVkJyxcbiAgICAgICd0b0NvbnRhaW4nLFxuICAgICAgJ3RvRXF1YWwnLFxuICAgICAgJ3RvSGF2ZVNpemUnLFxuICAgICAgJ3RvSGF2ZUJlZW5DYWxsZWQnLFxuICAgICAgJ3RvSGF2ZUJlZW5DYWxsZWRCZWZvcmUnLFxuICAgICAgJ3RvSGF2ZUJlZW5DYWxsZWRPbmNlV2l0aCcsXG4gICAgICAndG9IYXZlQmVlbkNhbGxlZFRpbWVzJyxcbiAgICAgICd0b0hhdmVCZWVuQ2FsbGVkV2l0aCcsXG4gICAgICAndG9IYXZlQ2xhc3MnLFxuICAgICAgJ3RvTWF0Y2gnLFxuICAgICAgJ3RvVGhyb3cnLFxuICAgICAgJ3RvVGhyb3dFcnJvcicsXG4gICAgICAndG9UaHJvd01hdGNoaW5nJ1xuICAgIF0sXG4gICAgbWF0Y2hlcnMgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGF2YWlsYWJsZU1hdGNoZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSBhdmFpbGFibGVNYXRjaGVyc1tpXTtcbiAgICBtYXRjaGVyc1tuYW1lXSA9IGpSZXF1aXJlW25hbWVdKGokKTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVycztcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuYmFzZSA9IGZ1bmN0aW9uKGokLCBqYXNtaW5lR2xvYmFsKSB7XG4gIGokLnVuaW1wbGVtZW50ZWRNZXRob2RfID0gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmltcGxlbWVudGVkIG1ldGhvZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYXhpbXVtIG9iamVjdCBkZXB0aCB0aGUgcHJldHR5IHByaW50ZXIgd2lsbCBwcmludCB0by5cbiAgICogU2V0IHRoaXMgdG8gYSBsb3dlciB2YWx1ZSB0byBzcGVlZCB1cCBwcmV0dHkgcHJpbnRpbmcgaWYgeW91IGhhdmUgbGFyZ2Ugb2JqZWN0cy5cbiAgICogQG5hbWUgamFzbWluZS5NQVhfUFJFVFRZX1BSSU5UX0RFUFRIXG4gICAqIEBkZWZhdWx0IDhcbiAgICogQHNpbmNlIDEuMy4wXG4gICAqL1xuICBqJC5NQVhfUFJFVFRZX1BSSU5UX0RFUFRIID0gODtcbiAgLyoqXG4gICAqIE1heGltdW0gbnVtYmVyIG9mIGFycmF5IGVsZW1lbnRzIHRvIGRpc3BsYXkgd2hlbiBwcmV0dHkgcHJpbnRpbmcgb2JqZWN0cy5cbiAgICogVGhpcyB3aWxsIGFsc28gbGltaXQgdGhlIG51bWJlciBvZiBrZXlzIGFuZCB2YWx1ZXMgZGlzcGxheWVkIGZvciBhbiBvYmplY3QuXG4gICAqIEVsZW1lbnRzIHBhc3QgdGhpcyBudW1iZXIgd2lsbCBiZSBlbGxpcGlzZWQuXG4gICAqIEBuYW1lIGphc21pbmUuTUFYX1BSRVRUWV9QUklOVF9BUlJBWV9MRU5HVEhcbiAgICogQGRlZmF1bHQgNTBcbiAgICogQHNpbmNlIDIuNy4wXG4gICAqL1xuICBqJC5NQVhfUFJFVFRZX1BSSU5UX0FSUkFZX0xFTkdUSCA9IDUwO1xuICAvKipcbiAgICogTWF4aW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBkaXNwbGF5IHdoZW4gcHJldHR5IHByaW50aW5nIG9iamVjdHMuXG4gICAqIENoYXJhY3RlcnMgcGFzdCB0aGlzIG51bWJlciB3aWxsIGJlIGVsbGlwaXNlZC5cbiAgICogQG5hbWUgamFzbWluZS5NQVhfUFJFVFRZX1BSSU5UX0NIQVJTXG4gICAqIEBkZWZhdWx0IDEwMFxuICAgKiBAc2luY2UgMi45LjBcbiAgICovXG4gIGokLk1BWF9QUkVUVFlfUFJJTlRfQ0hBUlMgPSAxMDAwO1xuICAvKipcbiAgICogRGVmYXVsdCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIEphc21pbmUgd2lsbCB3YWl0IGZvciBhbiBhc3luY2hyb25vdXMgc3BlYyxcbiAgICogYmVmb3JlLCBvciBhZnRlciBmdW5jdGlvbiB0byBjb21wbGV0ZS4gVGhpcyBjYW4gYmUgb3ZlcnJpZGRlbiBvbiBhIGNhc2UgYnlcbiAgICogY2FzZSBiYXNpcyBieSBwYXNzaW5nIGEgdGltZSBsaW1pdCBhcyB0aGUgdGhpcmQgYXJndW1lbnQgdG8ge0BsaW5rIGl0fSxcbiAgICoge0BsaW5rIGJlZm9yZUVhY2h9LCB7QGxpbmsgYWZ0ZXJFYWNofSwge0BsaW5rIGJlZm9yZUFsbH0sIG9yXG4gICAqIHtAbGluayBhZnRlckFsbH0uIFRoZSB2YWx1ZSBtdXN0IGJlIG5vIGdyZWF0ZXIgdGhhbiB0aGUgbGFyZ2VzdCBudW1iZXIgb2ZcbiAgICogbWlsbGlzZWNvbmRzIHN1cHBvcnRlZCBieSBzZXRUaW1lb3V0LCB3aGljaCBpcyB1c3VhbGx5IDIxNDc0ODM2NDcuXG4gICAqXG4gICAqIFdoaWxlIGRlYnVnZ2luZyB0ZXN0cywgeW91IG1heSB3YW50IHRvIHNldCB0aGlzIHRvIGEgbGFyZ2UgbnVtYmVyIChvciBwYXNzXG4gICAqIGEgbGFyZ2UgbnVtYmVyIHRvIG9uZSBvZiB0aGUgZnVuY3Rpb25zIG1lbnRpb25lZCBhYm92ZSkgc28gdGhhdCBKYXNtaW5lXG4gICAqIGRvZXMgbm90IG1vdmUgb24gdG8gYWZ0ZXIgZnVuY3Rpb25zIG9yIHRoZSBuZXh0IHNwZWMgd2hpbGUgeW91J3JlIGRlYnVnZ2luZy5cbiAgICogQG5hbWUgamFzbWluZS5ERUZBVUxUX1RJTUVPVVRfSU5URVJWQUxcbiAgICogQGRlZmF1bHQgNTAwMFxuICAgKiBAc2luY2UgMS4zLjBcbiAgICovXG4gIHZhciBERUZBVUxUX1RJTUVPVVRfSU5URVJWQUwgPSA1MDAwO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaiQsICdERUZBVUxUX1RJTUVPVVRfSU5URVJWQUwnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBERUZBVUxUX1RJTUVPVVRfSU5URVJWQUw7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XG4gICAgICBqJC51dGlsLnZhbGlkYXRlVGltZW91dChuZXdWYWx1ZSwgJ2phc21pbmUuREVGQVVMVF9USU1FT1VUX0lOVEVSVkFMJyk7XG4gICAgICBERUZBVUxUX1RJTUVPVVRfSU5URVJWQUwgPSBuZXdWYWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIGokLmdldEdsb2JhbCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBqYXNtaW5lR2xvYmFsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnRseSBib290ZWQgSmFzbWluZSBFbnZpcm9ubWVudC5cbiAgICpcbiAgICogQG5hbWUgamFzbWluZS5nZXRFbnZcbiAgICogQHNpbmNlIDEuMy4wXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcmV0dXJuIHtFbnZ9XG4gICAqL1xuICBqJC5nZXRFbnYgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGVudiA9IChqJC5jdXJyZW50RW52XyA9IGokLmN1cnJlbnRFbnZfIHx8IG5ldyBqJC5FbnYob3B0aW9ucykpO1xuICAgIC8vamFzbWluZS4gc2luZ2xldG9ucyBpbiBoZXJlIChzZXRUaW1lb3V0IGJsYWggYmxhaCkuXG4gICAgcmV0dXJuIGVudjtcbiAgfTtcblxuICBqJC5pc0FycmF5XyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGokLmlzQV8oJ0FycmF5JywgdmFsdWUpO1xuICB9O1xuXG4gIGokLmlzT2JqZWN0XyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICFqJC51dGlsLmlzVW5kZWZpbmVkKHZhbHVlKSAmJiB2YWx1ZSAhPT0gbnVsbCAmJiBqJC5pc0FfKCdPYmplY3QnLCB2YWx1ZSlcbiAgICApO1xuICB9O1xuXG4gIGokLmlzU3RyaW5nXyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGokLmlzQV8oJ1N0cmluZycsIHZhbHVlKTtcbiAgfTtcblxuICBqJC5pc051bWJlcl8gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBqJC5pc0FfKCdOdW1iZXInLCB2YWx1ZSk7XG4gIH07XG5cbiAgaiQuaXNGdW5jdGlvbl8gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBqJC5pc0FfKCdGdW5jdGlvbicsIHZhbHVlKTtcbiAgfTtcblxuICBqJC5pc0FzeW5jRnVuY3Rpb25fID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gaiQuaXNBXygnQXN5bmNGdW5jdGlvbicsIHZhbHVlKTtcbiAgfTtcblxuICBqJC5pc0dlbmVyYXRvckZ1bmN0aW9uXyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGokLmlzQV8oJ0dlbmVyYXRvckZ1bmN0aW9uJywgdmFsdWUpO1xuICB9O1xuXG4gIGokLmlzVHlwZWRBcnJheV8gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiAoXG4gICAgICBqJC5pc0FfKCdGbG9hdDMyQXJyYXknLCB2YWx1ZSkgfHxcbiAgICAgIGokLmlzQV8oJ0Zsb2F0NjRBcnJheScsIHZhbHVlKSB8fFxuICAgICAgaiQuaXNBXygnSW50MTZBcnJheScsIHZhbHVlKSB8fFxuICAgICAgaiQuaXNBXygnSW50MzJBcnJheScsIHZhbHVlKSB8fFxuICAgICAgaiQuaXNBXygnSW50OEFycmF5JywgdmFsdWUpIHx8XG4gICAgICBqJC5pc0FfKCdVaW50MTZBcnJheScsIHZhbHVlKSB8fFxuICAgICAgaiQuaXNBXygnVWludDMyQXJyYXknLCB2YWx1ZSkgfHxcbiAgICAgIGokLmlzQV8oJ1VpbnQ4QXJyYXknLCB2YWx1ZSkgfHxcbiAgICAgIGokLmlzQV8oJ1VpbnQ4Q2xhbXBlZEFycmF5JywgdmFsdWUpXG4gICAgKTtcbiAgfTtcblxuICBqJC5pc0FfID0gZnVuY3Rpb24odHlwZU5hbWUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGokLmdldFR5cGVfKHZhbHVlKSA9PT0gJ1tvYmplY3QgJyArIHR5cGVOYW1lICsgJ10nO1xuICB9O1xuXG4gIGokLmlzRXJyb3JfID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUuc3RhY2sgPT09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZS5tZXNzYWdlID09PSAnc3RyaW5nJztcbiAgfTtcblxuICBqJC5pc0FzeW1tZXRyaWNFcXVhbGl0eVRlc3Rlcl8gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID8gaiQuaXNBXygnRnVuY3Rpb24nLCBvYmouYXN5bW1ldHJpY01hdGNoKSA6IGZhbHNlO1xuICB9O1xuXG4gIGokLmdldFR5cGVfID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseSh2YWx1ZSk7XG4gIH07XG5cbiAgaiQuaXNEb21Ob2RlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgLy8gTm9kZSBpcyBhIGZ1bmN0aW9uLCBiZWNhdXNlIGNvbnN0cnVjdG9yc1xuICAgIHJldHVybiB0eXBlb2YgamFzbWluZUdsb2JhbC5Ob2RlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgPyBvYmogaW5zdGFuY2VvZiBqYXNtaW5lR2xvYmFsLk5vZGVcbiAgICAgIDogb2JqICE9PSBudWxsICYmXG4gICAgICAgICAgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICB0eXBlb2Ygb2JqLm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgIHR5cGVvZiBvYmoubm9kZU5hbWUgPT09ICdzdHJpbmcnO1xuICAgIC8vIHJldHVybiBvYmoubm9kZVR5cGUgPiAwO1xuICB9O1xuXG4gIGokLmlzTWFwID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIG9iaiAhPT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIG9iaiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3RvciA9PT0gamFzbWluZUdsb2JhbC5NYXBcbiAgICApO1xuICB9O1xuXG4gIGokLmlzU2V0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIG9iaiAhPT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIG9iaiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3RvciA9PT0gamFzbWluZUdsb2JhbC5TZXRcbiAgICApO1xuICB9O1xuXG4gIGokLmlzV2Vha01hcCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAoXG4gICAgICBvYmogIT09IG51bGwgJiZcbiAgICAgIHR5cGVvZiBvYmogIT09ICd1bmRlZmluZWQnICYmXG4gICAgICBvYmouY29uc3RydWN0b3IgPT09IGphc21pbmVHbG9iYWwuV2Vha01hcFxuICAgICk7XG4gIH07XG5cbiAgaiQuaXNVUkwgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gKFxuICAgICAgb2JqICE9PSBudWxsICYmXG4gICAgICB0eXBlb2Ygb2JqICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yID09PSBqYXNtaW5lR2xvYmFsLlVSTFxuICAgICk7XG4gIH07XG5cbiAgaiQuaXNJdGVyYWJsZV8gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiAhIXZhbHVlW1N5bWJvbC5pdGVyYXRvcl07XG4gIH07XG5cbiAgaiQuaXNEYXRhVmlldyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAoXG4gICAgICBvYmogIT09IG51bGwgJiZcbiAgICAgIHR5cGVvZiBvYmogIT09ICd1bmRlZmluZWQnICYmXG4gICAgICBvYmouY29uc3RydWN0b3IgPT09IGphc21pbmVHbG9iYWwuRGF0YVZpZXdcbiAgICApO1xuICB9O1xuXG4gIGokLmlzUHJvbWlzZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAhIW9iaiAmJiBvYmouY29uc3RydWN0b3IgPT09IGphc21pbmVHbG9iYWwuUHJvbWlzZTtcbiAgfTtcblxuICBqJC5pc1Byb21pc2VMaWtlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhb2JqICYmIGokLmlzRnVuY3Rpb25fKG9iai50aGVuKTtcbiAgfTtcblxuICBqJC5mbk5hbWVGb3IgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgaWYgKGZ1bmMubmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmMubmFtZTtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2hlcyA9XG4gICAgICBmdW5jLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb25cXHMqKFxcdyspXFxzKlxcKC8pIHx8XG4gICAgICBmdW5jLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqXFxbb2JqZWN0XFxzKihcXHcrKUNvbnN0cnVjdG9yXFxdLyk7XG5cbiAgICByZXR1cm4gbWF0Y2hlcyA/IG1hdGNoZXNbMV0gOiAnPGFub255bW91cz4nO1xuICB9O1xuXG4gIGokLmlzUGVuZGluZ18gPSBmdW5jdGlvbihwcm9taXNlKSB7XG4gICAgdmFyIHNlbnRpbmVsID0ge307XG4gICAgcmV0dXJuIFByb21pc2UucmFjZShbcHJvbWlzZSwgUHJvbWlzZS5yZXNvbHZlKHNlbnRpbmVsKV0pLnRoZW4oXG4gICAgICBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gc2VudGluZWw7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYW4ge0BsaW5rIEFzeW1tZXRyaWNFcXVhbGl0eVRlc3Rlcn0sIHVzYWJsZSBpbiBhbnkge0BsaW5rIG1hdGNoZXJzfG1hdGNoZXJ9IHRoYXQgdXNlcyBKYXNtaW5lJ3MgZXF1YWxpdHkgKGUuZy4ge0BsaW5rIG1hdGNoZXJzI3RvRXF1YWx8dG9FcXVhbH0sIHtAbGluayBtYXRjaGVycyN0b0NvbnRhaW58dG9Db250YWlufSwgb3Ige0BsaW5rIG1hdGNoZXJzI3RvSGF2ZUJlZW5DYWxsZWRXaXRofHRvSGF2ZUJlZW5DYWxsZWRXaXRofSksXG4gICAqIHRoYXQgd2lsbCBzdWNjZWVkIGlmIHRoZSBhY3R1YWwgdmFsdWUgYmVpbmcgY29tcGFyZWQgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIHNwZWNpZmllZCBjbGFzcy9jb25zdHJ1Y3Rvci5cbiAgICogQG5hbWUgamFzbWluZS5hbnlcbiAgICogQHNpbmNlIDEuMy4wXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0NvbnN0cnVjdG9yfSBjbGF6eiAtIFRoZSBjb25zdHJ1Y3RvciB0byBjaGVjayBhZ2FpbnN0LlxuICAgKi9cbiAgaiQuYW55ID0gZnVuY3Rpb24oY2xhenopIHtcbiAgICByZXR1cm4gbmV3IGokLkFueShjbGF6eik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiB7QGxpbmsgQXN5bW1ldHJpY0VxdWFsaXR5VGVzdGVyfSwgdXNhYmxlIGluIGFueSB7QGxpbmsgbWF0Y2hlcnN8bWF0Y2hlcn0gdGhhdCB1c2VzIEphc21pbmUncyBlcXVhbGl0eSAoZS5nLiB7QGxpbmsgbWF0Y2hlcnMjdG9FcXVhbHx0b0VxdWFsfSwge0BsaW5rIG1hdGNoZXJzI3RvQ29udGFpbnx0b0NvbnRhaW59LCBvciB7QGxpbmsgbWF0Y2hlcnMjdG9IYXZlQmVlbkNhbGxlZFdpdGh8dG9IYXZlQmVlbkNhbGxlZFdpdGh9KSxcbiAgICogdGhhdCB3aWxsIHN1Y2NlZWQgaWYgdGhlIGFjdHVhbCB2YWx1ZSBiZWluZyBjb21wYXJlZCBpcyBub3QgYG51bGxgIGFuZCBub3QgYHVuZGVmaW5lZGAuXG4gICAqIEBuYW1lIGphc21pbmUuYW55dGhpbmdcbiAgICogQHNpbmNlIDIuMi4wXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgaiQuYW55dGhpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IGokLkFueXRoaW5nKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiB7QGxpbmsgQXN5bW1ldHJpY0VxdWFsaXR5VGVzdGVyfSwgdXNhYmxlIGluIGFueSB7QGxpbmsgbWF0Y2hlcnN8bWF0Y2hlcn0gdGhhdCB1c2VzIEphc21pbmUncyBlcXVhbGl0eSAoZS5nLiB7QGxpbmsgbWF0Y2hlcnMjdG9FcXVhbHx0b0VxdWFsfSwge0BsaW5rIG1hdGNoZXJzI3RvQ29udGFpbnx0b0NvbnRhaW59LCBvciB7QGxpbmsgbWF0Y2hlcnMjdG9IYXZlQmVlbkNhbGxlZFdpdGh8dG9IYXZlQmVlbkNhbGxlZFdpdGh9KSxcbiAgICogdGhhdCB3aWxsIHN1Y2NlZWQgaWYgdGhlIGFjdHVhbCB2YWx1ZSBiZWluZyBjb21wYXJlZCBpcyBgdHJ1ZWAgb3IgYW55dGhpbmcgdHJ1dGh5LlxuICAgKiBAbmFtZSBqYXNtaW5lLnRydXRoeVxuICAgKiBAc2luY2UgMy4xLjBcbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBqJC50cnV0aHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IGokLlRydXRoeSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYW4ge0BsaW5rIEFzeW1tZXRyaWNFcXVhbGl0eVRlc3Rlcn0sIHVzYWJsZSBpbiBhbnkge0BsaW5rIG1hdGNoZXJzfG1hdGNoZXJ9IHRoYXQgdXNlcyBKYXNtaW5lJ3MgZXF1YWxpdHkgKGUuZy4ge0BsaW5rIG1hdGNoZXJzI3RvRXF1YWx8dG9FcXVhbH0sIHtAbGluayBtYXRjaGVycyN0b0NvbnRhaW58dG9Db250YWlufSwgb3Ige0BsaW5rIG1hdGNoZXJzI3RvSGF2ZUJlZW5DYWxsZWRXaXRofHRvSGF2ZUJlZW5DYWxsZWRXaXRofSksXG4gICAqIHRoYXQgd2lsbCBzdWNjZWVkIGlmIHRoZSBhY3R1YWwgdmFsdWUgYmVpbmcgY29tcGFyZWQgaXMgIGBudWxsYCwgYHVuZGVmaW5lZGAsIGAwYCwgYGZhbHNlYCBvciBhbnl0aGluZyBmYWxzZXkuXG4gICAqIEBuYW1lIGphc21pbmUuZmFsc3lcbiAgICogQHNpbmNlIDMuMS4wXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgaiQuZmFsc3kgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IGokLkZhbHN5KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiB7QGxpbmsgQXN5bW1ldHJpY0VxdWFsaXR5VGVzdGVyfSwgdXNhYmxlIGluIGFueSB7QGxpbmsgbWF0Y2hlcnN8bWF0Y2hlcn0gdGhhdCB1c2VzIEphc21pbmUncyBlcXVhbGl0eSAoZS5nLiB7QGxpbmsgbWF0Y2hlcnMjdG9FcXVhbHx0b0VxdWFsfSwge0BsaW5rIG1hdGNoZXJzI3RvQ29udGFpbnx0b0NvbnRhaW59LCBvciB7QGxpbmsgbWF0Y2hlcnMjdG9IYXZlQmVlbkNhbGxlZFdpdGh8dG9IYXZlQmVlbkNhbGxlZFdpdGh9KSxcbiAgICogdGhhdCB3aWxsIHN1Y2NlZWQgaWYgdGhlIGFjdHVhbCB2YWx1ZSBiZWluZyBjb21wYXJlZCBpcyBlbXB0eS5cbiAgICogQG5hbWUgamFzbWluZS5lbXB0eVxuICAgKiBAc2luY2UgMy4xLjBcbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBqJC5lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgaiQuRW1wdHkoKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFuIHtAbGluayBBc3ltbWV0cmljRXF1YWxpdHlUZXN0ZXJ9LCB1c2FibGUgaW4gYW55IHtAbGluayBtYXRjaGVyc3xtYXRjaGVyfSB0aGF0IHVzZXMgSmFzbWluZSdzIGVxdWFsaXR5IChlLmcuIHtAbGluayBtYXRjaGVycyN0b0VxdWFsfHRvRXF1YWx9LCB7QGxpbmsgbWF0Y2hlcnMjdG9Db250YWlufHRvQ29udGFpbn0sIG9yIHtAbGluayBtYXRjaGVycyN0b0hhdmVCZWVuQ2FsbGVkV2l0aHx0b0hhdmVCZWVuQ2FsbGVkV2l0aH0pLFxuICAgKiB0aGF0IHdpbGwgc3VjY2VlZCBpZiB0aGUgYWN0dWFsIHZhbHVlIGJlaW5nIGNvbXBhcmVkIGlzIG5vdCBlbXB0eS5cbiAgICogQG5hbWUgamFzbWluZS5ub3RFbXB0eVxuICAgKiBAc2luY2UgMy4xLjBcbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBqJC5ub3RFbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgaiQuTm90RW1wdHkoKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFuIHtAbGluayBBc3ltbWV0cmljRXF1YWxpdHlUZXN0ZXJ9LCB1c2FibGUgaW4gYW55IHtAbGluayBtYXRjaGVyc3xtYXRjaGVyfSB0aGF0IHVzZXMgSmFzbWluZSdzIGVxdWFsaXR5IChlLmcuIHtAbGluayBtYXRjaGVycyN0b0VxdWFsfHRvRXF1YWx9LCB7QGxpbmsgbWF0Y2hlcnMjdG9Db250YWlufHRvQ29udGFpbn0sIG9yIHtAbGluayBtYXRjaGVycyN0b0hhdmVCZWVuQ2FsbGVkV2l0aHx0b0hhdmVCZWVuQ2FsbGVkV2l0aH0pLFxuICAgKiB0aGF0IHdpbGwgc3VjY2VlZCBpZiB0aGUgYWN0dWFsIHZhbHVlIGJlaW5nIGNvbXBhcmVkIGNvbnRhaW5zIGF0IGxlYXN0IHRoZSBrZXlzIGFuZCB2YWx1ZXMuXG4gICAqIEBuYW1lIGphc21pbmUub2JqZWN0Q29udGFpbmluZ1xuICAgKiBAc2luY2UgMS4zLjBcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzYW1wbGUgLSBUaGUgc3Vic2V0IG9mIHByb3BlcnRpZXMgdGhhdCBfbXVzdF8gYmUgaW4gdGhlIGFjdHVhbC5cbiAgICovXG4gIGokLm9iamVjdENvbnRhaW5pbmcgPSBmdW5jdGlvbihzYW1wbGUpIHtcbiAgICByZXR1cm4gbmV3IGokLk9iamVjdENvbnRhaW5pbmcoc2FtcGxlKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFuIHtAbGluayBBc3ltbWV0cmljRXF1YWxpdHlUZXN0ZXJ9LCB1c2FibGUgaW4gYW55IHtAbGluayBtYXRjaGVyc3xtYXRjaGVyfSB0aGF0IHVzZXMgSmFzbWluZSdzIGVxdWFsaXR5IChlLmcuIHtAbGluayBtYXRjaGVycyN0b0VxdWFsfHRvRXF1YWx9LCB7QGxpbmsgbWF0Y2hlcnMjdG9Db250YWlufHRvQ29udGFpbn0sIG9yIHtAbGluayBtYXRjaGVycyN0b0hhdmVCZWVuQ2FsbGVkV2l0aHx0b0hhdmVCZWVuQ2FsbGVkV2l0aH0pLFxuICAgKiB0aGF0IHdpbGwgc3VjY2VlZCBpZiB0aGUgYWN0dWFsIHZhbHVlIGlzIGEgYFN0cmluZ2AgdGhhdCBtYXRjaGVzIHRoZSBgUmVnRXhwYCBvciBgU3RyaW5nYC5cbiAgICogQG5hbWUgamFzbWluZS5zdHJpbmdNYXRjaGluZ1xuICAgKiBAc2luY2UgMi4yLjBcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gZXhwZWN0ZWRcbiAgICovXG4gIGokLnN0cmluZ01hdGNoaW5nID0gZnVuY3Rpb24oZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gbmV3IGokLlN0cmluZ01hdGNoaW5nKGV4cGVjdGVkKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFuIHtAbGluayBBc3ltbWV0cmljRXF1YWxpdHlUZXN0ZXJ9LCB1c2FibGUgaW4gYW55IHtAbGluayBtYXRjaGVyc3xtYXRjaGVyfSB0aGF0IHVzZXMgSmFzbWluZSdzIGVxdWFsaXR5IChlLmcuIHtAbGluayBtYXRjaGVycyN0b0VxdWFsfHRvRXF1YWx9LCB7QGxpbmsgbWF0Y2hlcnMjdG9Db250YWlufHRvQ29udGFpbn0sIG9yIHtAbGluayBtYXRjaGVycyN0b0hhdmVCZWVuQ2FsbGVkV2l0aHx0b0hhdmVCZWVuQ2FsbGVkV2l0aH0pLFxuICAgKiB0aGF0IHdpbGwgc3VjY2VlZCBpZiB0aGUgYWN0dWFsIHZhbHVlIGlzIGEgYFN0cmluZ2AgdGhhdCBjb250YWlucyB0aGUgc3BlY2lmaWVkIGBTdHJpbmdgLlxuICAgKiBAbmFtZSBqYXNtaW5lLnN0cmluZ0NvbnRhaW5pbmdcbiAgICogQHNpbmNlIDMuMTAuMFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV4cGVjdGVkXG4gICAqL1xuICBqJC5zdHJpbmdDb250YWluaW5nID0gZnVuY3Rpb24oZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gbmV3IGokLlN0cmluZ0NvbnRhaW5pbmcoZXhwZWN0ZWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYW4ge0BsaW5rIEFzeW1tZXRyaWNFcXVhbGl0eVRlc3Rlcn0sIHVzYWJsZSBpbiBhbnkge0BsaW5rIG1hdGNoZXJzfG1hdGNoZXJ9IHRoYXQgdXNlcyBKYXNtaW5lJ3MgZXF1YWxpdHkgKGUuZy4ge0BsaW5rIG1hdGNoZXJzI3RvRXF1YWx8dG9FcXVhbH0sIHtAbGluayBtYXRjaGVycyN0b0NvbnRhaW58dG9Db250YWlufSwgb3Ige0BsaW5rIG1hdGNoZXJzI3RvSGF2ZUJlZW5DYWxsZWRXaXRofHRvSGF2ZUJlZW5DYWxsZWRXaXRofSksXG4gICAqIHRoYXQgd2lsbCBzdWNjZWVkIGlmIHRoZSBhY3R1YWwgdmFsdWUgaXMgYW4gYEFycmF5YCB0aGF0IGNvbnRhaW5zIGF0IGxlYXN0IHRoZSBlbGVtZW50cyBpbiB0aGUgc2FtcGxlLlxuICAgKiBAbmFtZSBqYXNtaW5lLmFycmF5Q29udGFpbmluZ1xuICAgKiBAc2luY2UgMi4yLjBcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNhbXBsZVxuICAgKi9cbiAgaiQuYXJyYXlDb250YWluaW5nID0gZnVuY3Rpb24oc2FtcGxlKSB7XG4gICAgcmV0dXJuIG5ldyBqJC5BcnJheUNvbnRhaW5pbmcoc2FtcGxlKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFuIHtAbGluayBBc3ltbWV0cmljRXF1YWxpdHlUZXN0ZXJ9LCB1c2FibGUgaW4gYW55IHtAbGluayBtYXRjaGVyc3xtYXRjaGVyfSB0aGF0IHVzZXMgSmFzbWluZSdzIGVxdWFsaXR5IChlLmcuIHtAbGluayBtYXRjaGVycyN0b0VxdWFsfHRvRXF1YWx9LCB7QGxpbmsgbWF0Y2hlcnMjdG9Db250YWlufHRvQ29udGFpbn0sIG9yIHtAbGluayBtYXRjaGVycyN0b0hhdmVCZWVuQ2FsbGVkV2l0aHx0b0hhdmVCZWVuQ2FsbGVkV2l0aH0pLFxuICAgKiB0aGF0IHdpbGwgc3VjY2VlZCBpZiB0aGUgYWN0dWFsIHZhbHVlIGlzIGFuIGBBcnJheWAgdGhhdCBjb250YWlucyBhbGwgb2YgdGhlIGVsZW1lbnRzIGluIHRoZSBzYW1wbGUgaW4gYW55IG9yZGVyLlxuICAgKiBAbmFtZSBqYXNtaW5lLmFycmF5V2l0aEV4YWN0Q29udGVudHNcbiAgICogQHNpbmNlIDIuOC4wXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0FycmF5fSBzYW1wbGVcbiAgICovXG4gIGokLmFycmF5V2l0aEV4YWN0Q29udGVudHMgPSBmdW5jdGlvbihzYW1wbGUpIHtcbiAgICByZXR1cm4gbmV3IGokLkFycmF5V2l0aEV4YWN0Q29udGVudHMoc2FtcGxlKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFuIHtAbGluayBBc3ltbWV0cmljRXF1YWxpdHlUZXN0ZXJ9LCB1c2FibGUgaW4gYW55IHtAbGluayBtYXRjaGVyc3xtYXRjaGVyfSB0aGF0IHVzZXMgSmFzbWluZSdzIGVxdWFsaXR5IChlLmcuIHtAbGluayBtYXRjaGVycyN0b0VxdWFsfHRvRXF1YWx9LCB7QGxpbmsgbWF0Y2hlcnMjdG9Db250YWlufHRvQ29udGFpbn0sIG9yIHtAbGluayBtYXRjaGVycyN0b0hhdmVCZWVuQ2FsbGVkV2l0aHx0b0hhdmVCZWVuQ2FsbGVkV2l0aH0pLFxuICAgKiB0aGF0IHdpbGwgc3VjY2VlZCBpZiBldmVyeSBrZXkvdmFsdWUgcGFpciBpbiB0aGUgc2FtcGxlIHBhc3NlcyB0aGUgZGVlcCBlcXVhbGl0eSBjb21wYXJpc29uXG4gICAqIHdpdGggYXQgbGVhc3Qgb25lIGtleS92YWx1ZSBwYWlyIGluIHRoZSBhY3R1YWwgdmFsdWUgYmVpbmcgY29tcGFyZWRcbiAgICogQG5hbWUgamFzbWluZS5tYXBDb250YWluaW5nXG4gICAqIEBzaW5jZSAzLjUuMFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtNYXB9IHNhbXBsZSAtIFRoZSBzdWJzZXQgb2YgaXRlbXMgdGhhdCBfbXVzdF8gYmUgaW4gdGhlIGFjdHVhbC5cbiAgICovXG4gIGokLm1hcENvbnRhaW5pbmcgPSBmdW5jdGlvbihzYW1wbGUpIHtcbiAgICByZXR1cm4gbmV3IGokLk1hcENvbnRhaW5pbmcoc2FtcGxlKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFuIHtAbGluayBBc3ltbWV0cmljRXF1YWxpdHlUZXN0ZXJ9LCB1c2FibGUgaW4gYW55IHtAbGluayBtYXRjaGVyc3xtYXRjaGVyfSB0aGF0IHVzZXMgSmFzbWluZSdzIGVxdWFsaXR5IChlLmcuIHtAbGluayBtYXRjaGVycyN0b0VxdWFsfHRvRXF1YWx9LCB7QGxpbmsgbWF0Y2hlcnMjdG9Db250YWlufHRvQ29udGFpbn0sIG9yIHtAbGluayBtYXRjaGVycyN0b0hhdmVCZWVuQ2FsbGVkV2l0aHx0b0hhdmVCZWVuQ2FsbGVkV2l0aH0pLFxuICAgKiB0aGF0IHdpbGwgc3VjY2VlZCBpZiBldmVyeSBpdGVtIGluIHRoZSBzYW1wbGUgcGFzc2VzIHRoZSBkZWVwIGVxdWFsaXR5IGNvbXBhcmlzb25cbiAgICogd2l0aCBhdCBsZWFzdCBvbmUgaXRlbSBpbiB0aGUgYWN0dWFsIHZhbHVlIGJlaW5nIGNvbXBhcmVkXG4gICAqIEBuYW1lIGphc21pbmUuc2V0Q29udGFpbmluZ1xuICAgKiBAc2luY2UgMy41LjBcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U2V0fSBzYW1wbGUgLSBUaGUgc3Vic2V0IG9mIGl0ZW1zIHRoYXQgX211c3RfIGJlIGluIHRoZSBhY3R1YWwuXG4gICAqL1xuICBqJC5zZXRDb250YWluaW5nID0gZnVuY3Rpb24oc2FtcGxlKSB7XG4gICAgcmV0dXJuIG5ldyBqJC5TZXRDb250YWluaW5nKHNhbXBsZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gaXMgYSBKYXNtaW5lIHNweS5cbiAgICogQG5hbWUgamFzbWluZS5pc1NweVxuICAgKiBAc2luY2UgMi4wLjBcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHB1dGF0aXZlU3B5IC0gVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaiQuaXNTcHkgPSBmdW5jdGlvbihwdXRhdGl2ZVNweSkge1xuICAgIGlmICghcHV0YXRpdmVTcHkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIHB1dGF0aXZlU3B5LmFuZCBpbnN0YW5jZW9mIGokLlNweVN0cmF0ZWd5ICYmXG4gICAgICBwdXRhdGl2ZVNweS5jYWxscyBpbnN0YW5jZW9mIGokLkNhbGxUcmFja2VyXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogTG9ncyBhIG1lc3NhZ2UgZm9yIHVzZSBpbiBkZWJ1Z2dpbmcuIElmIHRoZSBzcGVjIGZhaWxzLCB0cmFjZSBtZXNzYWdlc1xuICAgKiB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSB7QGxpbmsgU3BlY1Jlc3VsdHxyZXN1bHR9IHBhc3NlZCB0byB0aGVcbiAgICogcmVwb3J0ZXIncyBzcGVjRG9uZSBtZXRob2QuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgb25seSB3aGVuIGEgc3BlYyAoaW5jbHVkaW5nIGFueSBhc3NvY2lhdGVkXG4gICAqIGJlZm9yZUVhY2ggb3IgYWZ0ZXJFYWNoIGZ1bmN0aW9ucykgaXMgcnVubmluZy5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGphc21pbmUuZGVidWdMb2dcbiAgICogQHNpbmNlIDQuMC4wXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSBUaGUgbWVzc2FnZSB0byBsb2dcbiAgICovXG4gIGokLmRlYnVnTG9nID0gZnVuY3Rpb24obXNnKSB7XG4gICAgaiQuZ2V0RW52KCkuZGVidWdMb2cobXNnKTtcbiAgfTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudXRpbCA9IGZ1bmN0aW9uKGokKSB7XG4gIHZhciB1dGlsID0ge307XG5cbiAgdXRpbC5pbmhlcml0ID0gZnVuY3Rpb24oY2hpbGRDbGFzcywgcGFyZW50Q2xhc3MpIHtcbiAgICB2YXIgU3ViY2xhc3MgPSBmdW5jdGlvbigpIHt9O1xuICAgIFN1YmNsYXNzLnByb3RvdHlwZSA9IHBhcmVudENsYXNzLnByb3RvdHlwZTtcbiAgICBjaGlsZENsYXNzLnByb3RvdHlwZSA9IG5ldyBTdWJjbGFzcygpO1xuICB9O1xuXG4gIHV0aWwuYXJnc1RvQXJyYXkgPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgdmFyIGFycmF5T2ZBcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcnJheU9mQXJncy5wdXNoKGFyZ3NbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlPZkFyZ3M7XG4gIH07XG5cbiAgdXRpbC5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbiAgfTtcblxuICB1dGlsLmFycmF5Q29udGFpbnMgPSBmdW5jdGlvbihhcnJheSwgc2VhcmNoKSB7XG4gICAgdmFyIGkgPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWYgKGFycmF5W2ldID09PSBzZWFyY2gpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICB1dGlsLmNsb25lID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgcmV0dXJuIG9iai5zbGljZSgpO1xuICAgIH1cblxuICAgIHZhciBjbG9uZWQgPSB7fTtcbiAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICBjbG9uZWRbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfTtcblxuICB1dGlsLmNsb25lQXJncyA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICB2YXIgY2xvbmVkQXJncyA9IFtdO1xuICAgIHZhciBhcmdzQXNBcnJheSA9IGokLnV0aWwuYXJnc1RvQXJyYXkoYXJncyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzQXNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHN0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkoYXJnc0FzQXJyYXlbaV0pLFxuICAgICAgICBwcmltaXRpdmVzID0gL15cXFtvYmplY3QgKEJvb2xlYW58U3RyaW5nfFJlZ0V4cHxOdW1iZXIpLztcblxuICAgICAgLy8gQWxsIGZhbHNleSB2YWx1ZXMgYXJlIGVpdGhlciBwcmltaXRpdmVzLCBgbnVsbGAsIG9yIGB1bmRlZmluZWQuXG4gICAgICBpZiAoIWFyZ3NBc0FycmF5W2ldIHx8IHN0ci5tYXRjaChwcmltaXRpdmVzKSkge1xuICAgICAgICBjbG9uZWRBcmdzLnB1c2goYXJnc0FzQXJyYXlbaV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xvbmVkQXJncy5wdXNoKGokLnV0aWwuY2xvbmUoYXJnc0FzQXJyYXlbaV0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsb25lZEFyZ3M7XG4gIH07XG5cbiAgdXRpbC5nZXRQcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbihvYmosIG1ldGhvZE5hbWUpIHtcbiAgICB2YXIgZGVzY3JpcHRvcixcbiAgICAgIHByb3RvID0gb2JqO1xuXG4gICAgZG8ge1xuICAgICAgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIG1ldGhvZE5hbWUpO1xuICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgIH0gd2hpbGUgKCFkZXNjcmlwdG9yICYmIHByb3RvKTtcblxuICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICB9O1xuXG4gIHV0aWwub2JqZWN0RGlmZmVyZW5jZSA9IGZ1bmN0aW9uKG9iaiwgdG9SZW1vdmUpIHtcbiAgICB2YXIgZGlmZiA9IHt9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKHV0aWwuaGFzKG9iaiwga2V5KSAmJiAhdXRpbC5oYXModG9SZW1vdmUsIGtleSkpIHtcbiAgICAgICAgZGlmZltrZXldID0gb2JqW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpZmY7XG4gIH07XG5cbiAgdXRpbC5oYXMgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9O1xuXG4gIHV0aWwuZXJyb3JXaXRoU3RhY2sgPSBmdW5jdGlvbiBlcnJvcldpdGhTdGFjaygpIHtcbiAgICAvLyBEb24ndCB0aHJvdyBhbmQgY2F0Y2guIFRoYXQgbWFrZXMgaXQgaGFyZGVyIGZvciB1c2VycyB0byBkZWJ1ZyB0aGVpclxuICAgIC8vIGNvZGUgd2l0aCBleGNlcHRpb24gYnJlYWtwb2ludHMsIGFuZCBpdCdzIHVubmVjZXNzYXJ5IHNpbmNlIGFsbFxuICAgIC8vIHN1cHBvcnRlZCBlbnZpcm9ubWVudHMgcG9wdWxhdGUgbmV3IEVycm9yKCkuc3RhY2tcbiAgICByZXR1cm4gbmV3IEVycm9yKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gY2FsbGVyRmlsZSgpIHtcbiAgICB2YXIgdHJhY2UgPSBuZXcgaiQuU3RhY2tUcmFjZSh1dGlsLmVycm9yV2l0aFN0YWNrKCkpO1xuICAgIHJldHVybiB0cmFjZS5mcmFtZXNbMl0uZmlsZTtcbiAgfVxuXG4gIHV0aWwuamFzbWluZUZpbGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdCA9IGNhbGxlckZpbGUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9KSgpO1xuXG4gIGZ1bmN0aW9uIFN0b3BJdGVyYXRpb24oKSB7fVxuICBTdG9wSXRlcmF0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgU3RvcEl0ZXJhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdG9wSXRlcmF0aW9uO1xuXG4gIHV0aWwudmFsaWRhdGVUaW1lb3V0ID0gZnVuY3Rpb24odGltZW91dCwgbXNnUHJlZml4KSB7XG4gICAgLy8gVGltZW91dHMgYXJlIGltcGxlbWVudGVkIHdpdGggc2V0VGltZW91dCwgd2hpY2ggb25seSBzdXBwb3J0cyBhIGxpbWl0ZWRcbiAgICAvLyByYW5nZSBvZiB2YWx1ZXMuIFRoZSBsaW1pdCBpcyB1bnNwZWNpZmllZCwgYXMgaXMgdGhlIGJlaGF2aW9yIHdoZW4gaXQnc1xuICAgIC8vIGV4Y2VlZGVkLiBCdXQgb24gYWxsIGN1cnJlbnRseSBzdXBwb3J0ZWQgSlMgcnVudGltZXMsIHNldFRpbWVvdXQgY2FsbHNcbiAgICAvLyB0aGUgY2FsbGJhY2sgaW1tZWRpYXRlbHkgd2hlbiB0aGUgdGltZW91dCBpcyBncmVhdGVyIHRoYW4gMjE0NzQ4MzY0N1xuICAgIC8vICh0aGUgbWF4aW11bSB2YWx1ZSBvZiBhIHNpZ25lZCAzMiBiaXQgaW50ZWdlcikuXG4gICAgdmFyIG1heCA9IDIxNDc0ODM2NDc7XG5cbiAgICBpZiAodGltZW91dCA+IG1heCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAobXNnUHJlZml4IHx8ICdUaW1lb3V0IHZhbHVlJykgKyAnIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gJyArIG1heFxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHV0aWw7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlNwZWMgPSBmdW5jdGlvbihqJCkge1xuICAvKipcbiAgICogQGludGVyZmFjZSBTcGVjXG4gICAqIEBzZWUgQ29uZmlndXJhdGlvbiNzcGVjRmlsdGVyXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKi9cbiAgZnVuY3Rpb24gU3BlYyhhdHRycykge1xuICAgIHRoaXMuZXhwZWN0YXRpb25GYWN0b3J5ID0gYXR0cnMuZXhwZWN0YXRpb25GYWN0b3J5O1xuICAgIHRoaXMuYXN5bmNFeHBlY3RhdGlvbkZhY3RvcnkgPSBhdHRycy5hc3luY0V4cGVjdGF0aW9uRmFjdG9yeTtcbiAgICB0aGlzLnJlc3VsdENhbGxiYWNrID0gYXR0cnMucmVzdWx0Q2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcbiAgICAvKipcbiAgICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoaXMgc3BlYy5cbiAgICAgKiBAbmFtZSBTcGVjI2lkXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKi9cbiAgICB0aGlzLmlkID0gYXR0cnMuaWQ7XG4gICAgLyoqXG4gICAgICogVGhlIGRlc2NyaXB0aW9uIHBhc3NlZCB0byB0aGUge0BsaW5rIGl0fSB0aGF0IGNyZWF0ZWQgdGhpcyBzcGVjLlxuICAgICAqIEBuYW1lIFNwZWMjZGVzY3JpcHRpb25cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqL1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBhdHRycy5kZXNjcmlwdGlvbiB8fCAnJztcbiAgICB0aGlzLnF1ZXVlYWJsZUZuID0gYXR0cnMucXVldWVhYmxlRm47XG4gICAgdGhpcy5iZWZvcmVBbmRBZnRlckZucyA9XG4gICAgICBhdHRycy5iZWZvcmVBbmRBZnRlckZucyB8fFxuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7IGJlZm9yZXM6IFtdLCBhZnRlcnM6IFtdIH07XG4gICAgICB9O1xuICAgIHRoaXMudXNlckNvbnRleHQgPVxuICAgICAgYXR0cnMudXNlckNvbnRleHQgfHxcbiAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9O1xuICAgIHRoaXMub25TdGFydCA9IGF0dHJzLm9uU3RhcnQgfHwgZnVuY3Rpb24oKSB7fTtcbiAgICB0aGlzLmF1dG9DbGVhbkNsb3N1cmVzID1cbiAgICAgIGF0dHJzLmF1dG9DbGVhbkNsb3N1cmVzID09PSB1bmRlZmluZWQgPyB0cnVlIDogISFhdHRycy5hdXRvQ2xlYW5DbG9zdXJlcztcbiAgICB0aGlzLmdldFNwZWNOYW1lID1cbiAgICAgIGF0dHJzLmdldFNwZWNOYW1lIHx8XG4gICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfTtcbiAgICB0aGlzLmV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeSA9XG4gICAgICBhdHRycy5leHBlY3RhdGlvblJlc3VsdEZhY3RvcnkgfHwgZnVuY3Rpb24oKSB7fTtcbiAgICB0aGlzLm9uTGF0ZUVycm9yID0gYXR0cnMub25MYXRlRXJyb3IgfHwgZnVuY3Rpb24oKSB7fTtcbiAgICB0aGlzLnF1ZXVlUnVubmVyRmFjdG9yeSA9IGF0dHJzLnF1ZXVlUnVubmVyRmFjdG9yeSB8fCBmdW5jdGlvbigpIHt9O1xuICAgIHRoaXMuY2F0Y2hpbmdFeGNlcHRpb25zID1cbiAgICAgIGF0dHJzLmNhdGNoaW5nRXhjZXB0aW9ucyB8fFxuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB0aGlzLnRocm93T25FeHBlY3RhdGlvbkZhaWx1cmUgPSAhIWF0dHJzLnRocm93T25FeHBlY3RhdGlvbkZhaWx1cmU7XG4gICAgdGhpcy50aW1lciA9IGF0dHJzLnRpbWVyIHx8IG5ldyBqJC5UaW1lcigpO1xuXG4gICAgaWYgKCF0aGlzLnF1ZXVlYWJsZUZuLmZuKSB7XG4gICAgICB0aGlzLmV4Y2x1ZGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiBTcGVjUmVzdWx0XG4gICAgICogQHByb3BlcnR5IHtJbnR9IGlkIC0gVGhlIHVuaXF1ZSBpZCBvZiB0aGlzIHNwZWMuXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IGRlc2NyaXB0aW9uIC0gVGhlIGRlc2NyaXB0aW9uIHBhc3NlZCB0byB0aGUge0BsaW5rIGl0fSB0aGF0IGNyZWF0ZWQgdGhpcyBzcGVjLlxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBmdWxsTmFtZSAtIFRoZSBmdWxsIGRlc2NyaXB0aW9uIGluY2x1ZGluZyBhbGwgYW5jZXN0b3JzIG9mIHRoaXMgc3BlYy5cbiAgICAgKiBAcHJvcGVydHkge0V4cGVjdGF0aW9uW119IGZhaWxlZEV4cGVjdGF0aW9ucyAtIFRoZSBsaXN0IG9mIGV4cGVjdGF0aW9ucyB0aGF0IGZhaWxlZCBkdXJpbmcgZXhlY3V0aW9uIG9mIHRoaXMgc3BlYy5cbiAgICAgKiBAcHJvcGVydHkge0V4cGVjdGF0aW9uW119IHBhc3NlZEV4cGVjdGF0aW9ucyAtIFRoZSBsaXN0IG9mIGV4cGVjdGF0aW9ucyB0aGF0IHBhc3NlZCBkdXJpbmcgZXhlY3V0aW9uIG9mIHRoaXMgc3BlYy5cbiAgICAgKiBAcHJvcGVydHkge0V4cGVjdGF0aW9uW119IGRlcHJlY2F0aW9uV2FybmluZ3MgLSBUaGUgbGlzdCBvZiBkZXByZWNhdGlvbiB3YXJuaW5ncyB0aGF0IG9jY3VycmVkIGR1cmluZyBleGVjdXRpb24gdGhpcyBzcGVjLlxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwZW5kaW5nUmVhc29uIC0gSWYgdGhlIHNwZWMgaXMge0BsaW5rIHBlbmRpbmd9LCB0aGlzIHdpbGwgYmUgdGhlIHJlYXNvbi5cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gc3RhdHVzIC0gT25jZSB0aGUgc3BlYyBoYXMgY29tcGxldGVkLCB0aGlzIHN0cmluZyByZXByZXNlbnRzIHRoZSBwYXNzL2ZhaWwgc3RhdHVzIG9mIHRoaXMgc3BlYy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZHVyYXRpb24gLSBUaGUgdGltZSBpbiBtcyB1c2VkIGJ5IHRoZSBzcGVjIGV4ZWN1dGlvbiwgaW5jbHVkaW5nIGFueSBiZWZvcmUvYWZ0ZXJFYWNoLlxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gVXNlci1zdXBwbGllZCBwcm9wZXJ0aWVzLCBpZiBhbnksIHRoYXQgd2VyZSBzZXQgdXNpbmcge0BsaW5rIEVudiNzZXRTcGVjUHJvcGVydHl9XG4gICAgICogQHByb3BlcnR5IHtEZWJ1Z0xvZ0VudHJ5W118bnVsbH0gZGVidWdMb2dzIC0gTWVzc2FnZXMsIGlmIGFueSwgdGhhdCB3ZXJlIGxvZ2dlZCB1c2luZyB7QGxpbmsgamFzbWluZS5kZWJ1Z0xvZ30gZHVyaW5nIGEgZmFpbGluZyBzcGVjLlxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqL1xuICAgIHRoaXMucmVzdWx0ID0ge1xuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgIGZ1bGxOYW1lOiB0aGlzLmdldEZ1bGxOYW1lKCksXG4gICAgICBmYWlsZWRFeHBlY3RhdGlvbnM6IFtdLFxuICAgICAgcGFzc2VkRXhwZWN0YXRpb25zOiBbXSxcbiAgICAgIGRlcHJlY2F0aW9uV2FybmluZ3M6IFtdLFxuICAgICAgcGVuZGluZ1JlYXNvbjogJycsXG4gICAgICBkdXJhdGlvbjogbnVsbCxcbiAgICAgIHByb3BlcnRpZXM6IG51bGwsXG4gICAgICBkZWJ1Z0xvZ3M6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgU3BlYy5wcm90b3R5cGUuYWRkRXhwZWN0YXRpb25SZXN1bHQgPSBmdW5jdGlvbihwYXNzZWQsIGRhdGEsIGlzRXJyb3IpIHtcbiAgICB2YXIgZXhwZWN0YXRpb25SZXN1bHQgPSB0aGlzLmV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeShkYXRhKTtcbiAgICBpZiAocGFzc2VkKSB7XG4gICAgICB0aGlzLnJlc3VsdC5wYXNzZWRFeHBlY3RhdGlvbnMucHVzaChleHBlY3RhdGlvblJlc3VsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9ucy5wdXNoKGV4cGVjdGF0aW9uUmVzdWx0KTtcblxuICAgICAgaWYgKHRoaXMudGhyb3dPbkV4cGVjdGF0aW9uRmFpbHVyZSAmJiAhaXNFcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgaiQuZXJyb3JzLkV4cGVjdGF0aW9uRmFpbGVkKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFNwZWMucHJvdG90eXBlLnNldFNwZWNQcm9wZXJ0eSA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLnJlc3VsdC5wcm9wZXJ0aWVzID0gdGhpcy5yZXN1bHQucHJvcGVydGllcyB8fCB7fTtcbiAgICB0aGlzLnJlc3VsdC5wcm9wZXJ0aWVzW2tleV0gPSB2YWx1ZTtcbiAgfTtcblxuICBTcGVjLnByb3RvdHlwZS5leHBlY3QgPSBmdW5jdGlvbihhY3R1YWwpIHtcbiAgICByZXR1cm4gdGhpcy5leHBlY3RhdGlvbkZhY3RvcnkoYWN0dWFsLCB0aGlzKTtcbiAgfTtcblxuICBTcGVjLnByb3RvdHlwZS5leHBlY3RBc3luYyA9IGZ1bmN0aW9uKGFjdHVhbCkge1xuICAgIHJldHVybiB0aGlzLmFzeW5jRXhwZWN0YXRpb25GYWN0b3J5KGFjdHVhbCwgdGhpcyk7XG4gIH07XG5cbiAgU3BlYy5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKG9uQ29tcGxldGUsIGV4Y2x1ZGVkLCBmYWlsU3BlY1dpdGhOb0V4cCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBvblN0YXJ0ID0ge1xuICAgICAgZm46IGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgc2VsZi50aW1lci5zdGFydCgpO1xuICAgICAgICBzZWxmLm9uU3RhcnQoc2VsZiwgZG9uZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjb21wbGV0ZSA9IHtcbiAgICAgIGZuOiBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIGlmIChzZWxmLmF1dG9DbGVhbkNsb3N1cmVzKSB7XG4gICAgICAgICAgc2VsZi5xdWV1ZWFibGVGbi5mbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5yZXN1bHQuc3RhdHVzID0gc2VsZi5zdGF0dXMoZXhjbHVkZWQsIGZhaWxTcGVjV2l0aE5vRXhwKTtcbiAgICAgICAgc2VsZi5yZXN1bHQuZHVyYXRpb24gPSBzZWxmLnRpbWVyLmVsYXBzZWQoKTtcblxuICAgICAgICBpZiAoc2VsZi5yZXN1bHQuc3RhdHVzICE9PSAnZmFpbGVkJykge1xuICAgICAgICAgIHNlbGYucmVzdWx0LmRlYnVnTG9ncyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnJlc3VsdENhbGxiYWNrKHNlbGYucmVzdWx0LCBkb25lKTtcbiAgICAgIH0sXG4gICAgICB0eXBlOiAnc3BlY0NsZWFudXAnXG4gICAgfTtcblxuICAgIHZhciBmbnMgPSB0aGlzLmJlZm9yZUFuZEFmdGVyRm5zKCk7XG5cbiAgICB2YXIgcnVubmVyQ29uZmlnID0ge1xuICAgICAgaXNMZWFmOiB0cnVlLFxuICAgICAgcXVldWVhYmxlRm5zOiBbLi4uZm5zLmJlZm9yZXMsIHRoaXMucXVldWVhYmxlRm4sIC4uLmZucy5hZnRlcnNdLFxuICAgICAgb25FeGNlcHRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLm9uRXhjZXB0aW9uLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICB9LFxuICAgICAgb25NdWx0aXBsZURvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBJc3N1ZSBhIGRlcHJlY2F0aW9uLiBJbmNsdWRlIHRoZSBjb250ZXh0IG91cnNlbHZlcyBhbmQgcGFzc1xuICAgICAgICAvLyBpZ25vcmVSdW5uYWJsZTogdHJ1ZSwgc2luY2UgZ2V0dGluZyBoZXJlIGFsd2F5cyBtZWFucyB0aGF0IHdlJ3ZlIGFscmVhZHlcbiAgICAgICAgLy8gbW92ZWQgb24gYW5kIHRoZSBjdXJyZW50IHJ1bm5hYmxlIGlzbid0IHRoZSBvbmUgdGhhdCBjYXVzZWQgdGhlIHByb2JsZW0uXG4gICAgICAgIHNlbGYub25MYXRlRXJyb3IoXG4gICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0FuIGFzeW5jaHJvbm91cyBzcGVjLCBiZWZvcmVFYWNoLCBvciBhZnRlckVhY2ggZnVuY3Rpb24gY2FsbGVkIGl0cyAnICtcbiAgICAgICAgICAgICAgXCInZG9uZScgY2FsbGJhY2sgbW9yZSB0aGFuIG9uY2UuXFxuKGluIHNwZWM6IFwiICtcbiAgICAgICAgICAgICAgc2VsZi5nZXRGdWxsTmFtZSgpICtcbiAgICAgICAgICAgICAgJyknXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoc2VsZi5yZXN1bHQuc3RhdHVzID09PSAnZmFpbGVkJykge1xuICAgICAgICAgIG9uQ29tcGxldGUobmV3IGokLlN0b3BFeGVjdXRpb25FcnJvcignc3BlYyBmYWlsZWQnKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlckNvbnRleHQ6IHRoaXMudXNlckNvbnRleHQoKSxcbiAgICAgIHJ1bm5hYmxlTmFtZTogdGhpcy5nZXRGdWxsTmFtZS5iaW5kKHRoaXMpXG4gICAgfTtcblxuICAgIGlmICh0aGlzLm1hcmtlZFBlbmRpbmcgfHwgZXhjbHVkZWQgPT09IHRydWUpIHtcbiAgICAgIHJ1bm5lckNvbmZpZy5xdWV1ZWFibGVGbnMgPSBbXTtcbiAgICB9XG5cbiAgICBydW5uZXJDb25maWcucXVldWVhYmxlRm5zLnVuc2hpZnQob25TdGFydCk7XG4gICAgcnVubmVyQ29uZmlnLnF1ZXVlYWJsZUZucy5wdXNoKGNvbXBsZXRlKTtcblxuICAgIHRoaXMucXVldWVSdW5uZXJGYWN0b3J5KHJ1bm5lckNvbmZpZyk7XG4gIH07XG5cbiAgU3BlYy5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlc3VsdCA9IHtcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICBmdWxsTmFtZTogdGhpcy5nZXRGdWxsTmFtZSgpLFxuICAgICAgZmFpbGVkRXhwZWN0YXRpb25zOiBbXSxcbiAgICAgIHBhc3NlZEV4cGVjdGF0aW9uczogW10sXG4gICAgICBkZXByZWNhdGlvbldhcm5pbmdzOiBbXSxcbiAgICAgIHBlbmRpbmdSZWFzb246IHRoaXMuZXhjbHVkZU1lc3NhZ2UsXG4gICAgICBkdXJhdGlvbjogbnVsbCxcbiAgICAgIHByb3BlcnRpZXM6IG51bGwsXG4gICAgICBkZWJ1Z0xvZ3M6IG51bGxcbiAgICB9O1xuICAgIHRoaXMubWFya2VkUGVuZGluZyA9IHRoaXMubWFya2VkRXhjbHVkaW5nO1xuICB9O1xuXG4gIFNwZWMucHJvdG90eXBlLm9uRXhjZXB0aW9uID0gZnVuY3Rpb24gb25FeGNlcHRpb24oZSkge1xuICAgIGlmIChTcGVjLmlzUGVuZGluZ1NwZWNFeGNlcHRpb24oZSkpIHtcbiAgICAgIHRoaXMucGVuZChleHRyYWN0Q3VzdG9tUGVuZGluZ01lc3NhZ2UoZSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlIGluc3RhbmNlb2YgaiQuZXJyb3JzLkV4cGVjdGF0aW9uRmFpbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5hZGRFeHBlY3RhdGlvblJlc3VsdChcbiAgICAgIGZhbHNlLFxuICAgICAge1xuICAgICAgICBtYXRjaGVyTmFtZTogJycsXG4gICAgICAgIHBhc3NlZDogZmFsc2UsXG4gICAgICAgIGV4cGVjdGVkOiAnJyxcbiAgICAgICAgYWN0dWFsOiAnJyxcbiAgICAgICAgZXJyb3I6IGVcbiAgICAgIH0sXG4gICAgICB0cnVlXG4gICAgKTtcbiAgfTtcblxuICAvKlxuICAgKiBNYXJrcyBzdGF0ZSBhcyBwZW5kaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbWVzc2FnZV0gQW4gb3B0aW9uYWwgcmVhc29uIG1lc3NhZ2VcbiAgICovXG4gIFNwZWMucHJvdG90eXBlLnBlbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgdGhpcy5tYXJrZWRQZW5kaW5nID0gdHJ1ZTtcbiAgICBpZiAobWVzc2FnZSkge1xuICAgICAgdGhpcy5yZXN1bHQucGVuZGluZ1JlYXNvbiA9IG1lc3NhZ2U7XG4gICAgfVxuICB9O1xuXG4gIC8qXG4gICAqIExpa2Uge0BsaW5rIFNwZWMjcGVuZH0sIGJ1dCBwZW5kaW5nIHN0YXRlIHdpbGwgc3Vydml2ZSB7QGxpbmsgU3BlYyNyZXNldH1cbiAgICogVXNlZnVsIGZvciBmaXQsIHhpdCwgd2hlcmUgcGVuZGluZyBzdGF0ZSByZW1haW5zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW21lc3NhZ2VdIEFuIG9wdGlvbmFsIHJlYXNvbiBtZXNzYWdlXG4gICAqL1xuICBTcGVjLnByb3RvdHlwZS5leGNsdWRlID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIHRoaXMubWFya2VkRXhjbHVkaW5nID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5tZXNzYWdlKSB7XG4gICAgICB0aGlzLmV4Y2x1ZGVNZXNzYWdlID0gbWVzc2FnZTtcbiAgICB9XG4gICAgdGhpcy5wZW5kKG1lc3NhZ2UpO1xuICB9O1xuXG4gIFNwZWMucHJvdG90eXBlLmdldFJlc3VsdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVzdWx0LnN0YXR1cyA9IHRoaXMuc3RhdHVzKCk7XG4gICAgcmV0dXJuIHRoaXMucmVzdWx0O1xuICB9O1xuXG4gIFNwZWMucHJvdG90eXBlLnN0YXR1cyA9IGZ1bmN0aW9uKGV4Y2x1ZGVkLCBmYWlsU3BlY1dpdGhOb0V4cGVjdGF0aW9ucykge1xuICAgIGlmIChleGNsdWRlZCA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuICdleGNsdWRlZCc7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWFya2VkUGVuZGluZykge1xuICAgICAgcmV0dXJuICdwZW5kaW5nJztcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLnJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMubGVuZ3RoID4gMCB8fFxuICAgICAgKGZhaWxTcGVjV2l0aE5vRXhwZWN0YXRpb25zICYmXG4gICAgICAgIHRoaXMucmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9ucy5sZW5ndGggK1xuICAgICAgICAgIHRoaXMucmVzdWx0LnBhc3NlZEV4cGVjdGF0aW9ucy5sZW5ndGggPT09XG4gICAgICAgICAgMClcbiAgICApIHtcbiAgICAgIHJldHVybiAnZmFpbGVkJztcbiAgICB9XG5cbiAgICByZXR1cm4gJ3Bhc3NlZCc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBmdWxsIGRlc2NyaXB0aW9uIGluY2x1ZGluZyBhbGwgYW5jZXN0b3JzIG9mIHRoaXMgc3BlYy5cbiAgICogQG5hbWUgU3BlYyNnZXRGdWxsTmFtZVxuICAgKiBAZnVuY3Rpb25cbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQHNpbmNlIDIuMC4wXG4gICAqL1xuICBTcGVjLnByb3RvdHlwZS5nZXRGdWxsTmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldFNwZWNOYW1lKHRoaXMpO1xuICB9O1xuXG4gIFNwZWMucHJvdG90eXBlLmFkZERlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uKGRlcHJlY2F0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBkZXByZWNhdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGRlcHJlY2F0aW9uID0geyBtZXNzYWdlOiBkZXByZWNhdGlvbiB9O1xuICAgIH1cbiAgICB0aGlzLnJlc3VsdC5kZXByZWNhdGlvbldhcm5pbmdzLnB1c2goXG4gICAgICB0aGlzLmV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeShkZXByZWNhdGlvbilcbiAgICApO1xuICB9O1xuXG4gIFNwZWMucHJvdG90eXBlLmRlYnVnTG9nID0gZnVuY3Rpb24obXNnKSB7XG4gICAgaWYgKCF0aGlzLnJlc3VsdC5kZWJ1Z0xvZ3MpIHtcbiAgICAgIHRoaXMucmVzdWx0LmRlYnVnTG9ncyA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIERlYnVnTG9nRW50cnlcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIHRoYXQgd2FzIHBhc3NlZCB0byB7QGxpbmsgamFzbWluZS5kZWJ1Z0xvZ30uXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVzdGFtcCAtIFRoZSB0aW1lIHdoZW4gdGhlIGVudHJ5IHdhcyBhZGRlZCwgaW5cbiAgICAgKiBtaWxsaXNlY29uZHMgZnJvbSB0aGUgc3BlYydzIHN0YXJ0IHRpbWVcbiAgICAgKi9cbiAgICB0aGlzLnJlc3VsdC5kZWJ1Z0xvZ3MucHVzaCh7XG4gICAgICBtZXNzYWdlOiBtc2csXG4gICAgICB0aW1lc3RhbXA6IHRoaXMudGltZXIuZWxhcHNlZCgpXG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGV4dHJhY3RDdXN0b21QZW5kaW5nTWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZnVsbE1lc3NhZ2UgPSBlLnRvU3RyaW5nKCksXG4gICAgICBib2lsZXJwbGF0ZVN0YXJ0ID0gZnVsbE1lc3NhZ2UuaW5kZXhPZihTcGVjLnBlbmRpbmdTcGVjRXhjZXB0aW9uTWVzc2FnZSksXG4gICAgICBib2lsZXJwbGF0ZUVuZCA9XG4gICAgICAgIGJvaWxlcnBsYXRlU3RhcnQgKyBTcGVjLnBlbmRpbmdTcGVjRXhjZXB0aW9uTWVzc2FnZS5sZW5ndGg7XG5cbiAgICByZXR1cm4gZnVsbE1lc3NhZ2Uuc3Vic3RyKGJvaWxlcnBsYXRlRW5kKTtcbiAgfTtcblxuICBTcGVjLnBlbmRpbmdTcGVjRXhjZXB0aW9uTWVzc2FnZSA9ICc9PiBtYXJrZWQgUGVuZGluZyc7XG5cbiAgU3BlYy5pc1BlbmRpbmdTcGVjRXhjZXB0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiAhIShcbiAgICAgIGUgJiZcbiAgICAgIGUudG9TdHJpbmcgJiZcbiAgICAgIGUudG9TdHJpbmcoKS5pbmRleE9mKFNwZWMucGVuZGluZ1NwZWNFeGNlcHRpb25NZXNzYWdlKSAhPT0gLTFcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW50ZXJmYWNlIFNwZWNcbiAgICogQHNlZSBDb25maWd1cmF0aW9uI3NwZWNGaWx0ZXJcbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTcGVjLnByb3RvdHlwZSwgJ21ldGFkYXRhJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMubWV0YWRhdGFfKSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGFfID0ge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhpcyBzcGVjLlxuICAgICAgICAgICAqIEBuYW1lIFNwZWMjaWRcbiAgICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGlkOiB0aGlzLmlkLFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIGRlc2NyaXB0aW9uIHBhc3NlZCB0byB0aGUge0BsaW5rIGl0fSB0aGF0IGNyZWF0ZWQgdGhpcyBzcGVjLlxuICAgICAgICAgICAqIEBuYW1lIFNwZWMjZGVzY3JpcHRpb25cbiAgICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIGZ1bGwgZGVzY3JpcHRpb24gaW5jbHVkaW5nIGFsbCBhbmNlc3RvcnMgb2YgdGhpcyBzcGVjLlxuICAgICAgICAgICAqIEBuYW1lIFNwZWMjZ2V0RnVsbE5hbWVcbiAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGdldEZ1bGxOYW1lOiB0aGlzLmdldEZ1bGxOYW1lLmJpbmQodGhpcylcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMubWV0YWRhdGFfO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIFNwZWM7XG59O1xuXG4vKmpzaGludCBiaXR3aXNlOiBmYWxzZSovXG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuT3JkZXIgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gT3JkZXIob3B0aW9ucykge1xuICAgIHRoaXMucmFuZG9tID0gJ3JhbmRvbScgaW4gb3B0aW9ucyA/IG9wdGlvbnMucmFuZG9tIDogdHJ1ZTtcbiAgICB2YXIgc2VlZCA9ICh0aGlzLnNlZWQgPSBvcHRpb25zLnNlZWQgfHwgZ2VuZXJhdGVTZWVkKCkpO1xuICAgIHRoaXMuc29ydCA9IHRoaXMucmFuZG9tID8gcmFuZG9tT3JkZXIgOiBuYXR1cmFsT3JkZXI7XG5cbiAgICBmdW5jdGlvbiBuYXR1cmFsT3JkZXIoaXRlbXMpIHtcbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByYW5kb21PcmRlcihpdGVtcykge1xuICAgICAgdmFyIGNvcHkgPSBpdGVtcy5zbGljZSgpO1xuICAgICAgY29weS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGplbmtpbnNIYXNoKHNlZWQgKyBhLmlkKSAtIGplbmtpbnNIYXNoKHNlZWQgKyBiLmlkKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVTZWVkKCkge1xuICAgICAgcmV0dXJuIFN0cmluZyhNYXRoLnJhbmRvbSgpKS5zbGljZSgtNSk7XG4gICAgfVxuXG4gICAgLy8gQm9iIEplbmtpbnMgT25lLWF0LWEtVGltZSBIYXNoIGFsZ29yaXRobSBpcyBhIG5vbi1jcnlwdG9ncmFwaGljIGhhc2ggZnVuY3Rpb25cbiAgICAvLyB1c2VkIHRvIGdldCBhIGRpZmZlcmVudCBvdXRwdXQgd2hlbiB0aGUga2V5IGNoYW5nZXMgc2xpZ2h0bHkuXG4gICAgLy8gV2UgdXNlIHlvdXIgcmV0dXJuIHRvIHNvcnQgdGhlIGNoaWxkcmVuIHJhbmRvbWx5IGluIGEgY29uc2lzdGVudCB3YXkgd2hlblxuICAgIC8vIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBhIHNlZWRcblxuICAgIGZ1bmN0aW9uIGplbmtpbnNIYXNoKGtleSkge1xuICAgICAgdmFyIGhhc2gsIGk7XG4gICAgICBmb3IgKGhhc2ggPSBpID0gMDsgaSA8IGtleS5sZW5ndGg7ICsraSkge1xuICAgICAgICBoYXNoICs9IGtleS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBoYXNoICs9IGhhc2ggPDwgMTA7XG4gICAgICAgIGhhc2ggXj0gaGFzaCA+PiA2O1xuICAgICAgfVxuICAgICAgaGFzaCArPSBoYXNoIDw8IDM7XG4gICAgICBoYXNoIF49IGhhc2ggPj4gMTE7XG4gICAgICBoYXNoICs9IGhhc2ggPDwgMTU7XG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gT3JkZXI7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkVudiA9IGZ1bmN0aW9uKGokKSB7XG4gIC8qKlxuICAgKiBAY2xhc3MgRW52XG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKiBAY2xhc3NkZXNjIFRoZSBKYXNtaW5lIGVudmlyb25tZW50Ljxicj5cbiAgICogX05vdGU6XyBEbyBub3QgY29uc3RydWN0IHRoaXMgZGlyZWN0bHkuIFlvdSBjYW4gb2J0YWluIHRoZSBFbnYgaW5zdGFuY2UgYnlcbiAgICogY2FsbGluZyB7QGxpbmsgamFzbWluZS5nZXRFbnZ9LlxuICAgKiBAaGlkZWNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBFbnYob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBnbG9iYWwgPSBvcHRpb25zLmdsb2JhbCB8fCBqJC5nZXRHbG9iYWwoKTtcblxuICAgIHZhciB0b3RhbFNwZWNzRGVmaW5lZCA9IDA7XG5cbiAgICB2YXIgcmVhbFNldFRpbWVvdXQgPSBnbG9iYWwuc2V0VGltZW91dDtcbiAgICB2YXIgcmVhbENsZWFyVGltZW91dCA9IGdsb2JhbC5jbGVhclRpbWVvdXQ7XG4gICAgdmFyIGNsZWFyU3RhY2sgPSBqJC5nZXRDbGVhclN0YWNrKGdsb2JhbCk7XG4gICAgdGhpcy5jbG9jayA9IG5ldyBqJC5DbG9jayhcbiAgICAgIGdsb2JhbCxcbiAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IGokLkRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlcigpO1xuICAgICAgfSxcbiAgICAgIG5ldyBqJC5Nb2NrRGF0ZShnbG9iYWwpXG4gICAgKTtcblxuICAgIHZhciBydW5uYWJsZVJlc291cmNlcyA9IHt9O1xuXG4gICAgdmFyIGN1cnJlbnRTcGVjID0gbnVsbDtcbiAgICB2YXIgY3VycmVudGx5RXhlY3V0aW5nU3VpdGVzID0gW107XG4gICAgdmFyIGN1cnJlbnREZWNsYXJhdGlvblN1aXRlID0gbnVsbDtcbiAgICB2YXIgaGFzRmFpbHVyZXMgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgcmVwcmVzZW50cyB0aGUgYXZhaWxhYmxlIG9wdGlvbnMgdG8gY29uZmlndXJlIEphc21pbmUuXG4gICAgICogT3B0aW9ucyB0aGF0IGFyZSBub3QgcHJvdmlkZWQgd2lsbCB1c2UgdGhlaXIgZGVmYXVsdCB2YWx1ZXMuXG4gICAgICogQHNlZSBFbnYjY29uZmlndXJlXG4gICAgICogQGludGVyZmFjZSBDb25maWd1cmF0aW9uXG4gICAgICogQHNpbmNlIDMuMy4wXG4gICAgICovXG4gICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgIC8qKlxuICAgICAgICogV2hldGhlciB0byByYW5kb21pemUgc3BlYyBleGVjdXRpb24gb3JkZXJcbiAgICAgICAqIEBuYW1lIENvbmZpZ3VyYXRpb24jcmFuZG9tXG4gICAgICAgKiBAc2luY2UgMy4zLjBcbiAgICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAqL1xuICAgICAgcmFuZG9tOiB0cnVlLFxuICAgICAgLyoqXG4gICAgICAgKiBTZWVkIHRvIHVzZSBhcyB0aGUgYmFzaXMgb2YgcmFuZG9taXphdGlvbi5cbiAgICAgICAqIE51bGwgY2F1c2VzIHRoZSBzZWVkIHRvIGJlIGRldGVybWluZWQgcmFuZG9tbHkgYXQgdGhlIHN0YXJ0IG9mIGV4ZWN1dGlvbi5cbiAgICAgICAqIEBuYW1lIENvbmZpZ3VyYXRpb24jc2VlZFxuICAgICAgICogQHNpbmNlIDMuMy4wXG4gICAgICAgKiBAdHlwZSAobnVtYmVyfHN0cmluZylcbiAgICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgICAqL1xuICAgICAgc2VlZDogbnVsbCxcbiAgICAgIC8qKlxuICAgICAgICogV2hldGhlciB0byBzdG9wIGV4ZWN1dGlvbiBvZiB0aGUgc3VpdGUgYWZ0ZXIgdGhlIGZpcnN0IHNwZWMgZmFpbHVyZVxuICAgICAgICogQG5hbWUgQ29uZmlndXJhdGlvbiNzdG9wT25TcGVjRmFpbHVyZVxuICAgICAgICogQHNpbmNlIDMuOS4wXG4gICAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICovXG4gICAgICBzdG9wT25TcGVjRmFpbHVyZTogZmFsc2UsXG4gICAgICAvKipcbiAgICAgICAqIFdoZXRoZXIgdG8gZmFpbCB0aGUgc3BlYyBpZiBpdCByYW4gbm8gZXhwZWN0YXRpb25zLiBCeSBkZWZhdWx0XG4gICAgICAgKiBhIHNwZWMgdGhhdCByYW4gbm8gZXhwZWN0YXRpb25zIGlzIHJlcG9ydGVkIGFzIHBhc3NlZC4gU2V0dGluZyB0aGlzXG4gICAgICAgKiB0byB0cnVlIHdpbGwgcmVwb3J0IHN1Y2ggc3BlYyBhcyBhIGZhaWx1cmUuXG4gICAgICAgKiBAbmFtZSBDb25maWd1cmF0aW9uI2ZhaWxTcGVjV2l0aE5vRXhwZWN0YXRpb25zXG4gICAgICAgKiBAc2luY2UgMy41LjBcbiAgICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgKi9cbiAgICAgIGZhaWxTcGVjV2l0aE5vRXhwZWN0YXRpb25zOiBmYWxzZSxcbiAgICAgIC8qKlxuICAgICAgICogV2hldGhlciB0byBjYXVzZSBzcGVjcyB0byBvbmx5IGhhdmUgb25lIGV4cGVjdGF0aW9uIGZhaWx1cmUuXG4gICAgICAgKiBAbmFtZSBDb25maWd1cmF0aW9uI3N0b3BTcGVjT25FeHBlY3RhdGlvbkZhaWx1cmVcbiAgICAgICAqIEBzaW5jZSAzLjMuMFxuICAgICAgICogQHR5cGUgQm9vbGVhblxuICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAqL1xuICAgICAgc3RvcFNwZWNPbkV4cGVjdGF0aW9uRmFpbHVyZTogZmFsc2UsXG4gICAgICAvKipcbiAgICAgICAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHNwZWMgYW5kIHJldHVybnMgdHJ1ZSBpZiBpdCBzaG91bGQgYmUgZXhlY3V0ZWRcbiAgICAgICAqIG9yIGZhbHNlIGlmIGl0IHNob3VsZCBiZSBza2lwcGVkLlxuICAgICAgICogQGNhbGxiYWNrIFNwZWNGaWx0ZXJcbiAgICAgICAqIEBwYXJhbSB7U3BlY30gc3BlYyAtIFRoZSBzcGVjIHRoYXQgdGhlIGZpbHRlciBpcyBiZWluZyBhcHBsaWVkIHRvLlxuICAgICAgICogQHJldHVybiBib29sZWFuXG4gICAgICAgKi9cbiAgICAgIC8qKlxuICAgICAgICogRnVuY3Rpb24gdG8gdXNlIHRvIGZpbHRlciBzcGVjc1xuICAgICAgICogQG5hbWUgQ29uZmlndXJhdGlvbiNzcGVjRmlsdGVyXG4gICAgICAgKiBAc2luY2UgMy4zLjBcbiAgICAgICAqIEB0eXBlIFNwZWNGaWx0ZXJcbiAgICAgICAqIEBkZWZhdWx0IEEgZnVuY3Rpb24gdGhhdCBhbHdheXMgcmV0dXJucyB0cnVlLlxuICAgICAgICovXG4gICAgICBzcGVjRmlsdGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIG9yIG5vdCByZXBvcnRlcnMgc2hvdWxkIGhpZGUgZGlzYWJsZWQgc3BlY3MgZnJvbSB0aGVpciBvdXRwdXQuXG4gICAgICAgKiBDdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgYnkgSmFzbWluZSdzIEhUTUxSZXBvcnRlclxuICAgICAgICogQG5hbWUgQ29uZmlndXJhdGlvbiNoaWRlRGlzYWJsZWRcbiAgICAgICAqIEBzaW5jZSAzLjMuMFxuICAgICAgICogQHR5cGUgQm9vbGVhblxuICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAqL1xuICAgICAgaGlkZURpc2FibGVkOiBmYWxzZSxcbiAgICAgIC8qKlxuICAgICAgICogQ2xlYW4gY2xvc3VyZXMgd2hlbiBhIHN1aXRlIGlzIGRvbmUgcnVubmluZyAoZG9uZSBieSBjbGVhcmluZyB0aGUgc3RvcmVkIGZ1bmN0aW9uIHJlZmVyZW5jZSkuXG4gICAgICAgKiBUaGlzIHByZXZlbnRzIG1lbW9yeSBsZWFrcywgYnV0IHlvdSB3b24ndCBiZSBhYmxlIHRvIHJ1biBqYXNtaW5lIG11bHRpcGxlIHRpbWVzLlxuICAgICAgICogQG5hbWUgQ29uZmlndXJhdGlvbiNhdXRvQ2xlYW5DbG9zdXJlc1xuICAgICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICovXG4gICAgICBhdXRvQ2xlYW5DbG9zdXJlczogdHJ1ZSxcbiAgICAgIC8qKlxuICAgICAgICogV2hldGhlciBvciBub3QgdG8gaXNzdWUgd2FybmluZ3MgZm9yIGNlcnRhaW4gZGVwcmVjYXRlZCBmdW5jdGlvbmFsaXR5XG4gICAgICAgKiBldmVyeSB0aW1lIGl0J3MgdXNlZC4gSWYgbm90IHNldCBvciBzZXQgdG8gZmFsc2UsIGRlcHJlY2F0aW9uIHdhcm5pbmdzXG4gICAgICAgKiBmb3IgbWV0aG9kcyB0aGF0IHRlbmQgdG8gYmUgY2FsbGVkIGZyZXF1ZW50bHkgd2lsbCBiZSBpc3N1ZWQgb25seSBvbmNlXG4gICAgICAgKiBvciBvdGhlcndpc2UgdGhyb3R0bGVkIHRvIHRvIHByZXZlbnQgdGhlIHN1aXRlIG91dHB1dCBmcm9tIGJlaW5nIGZsb29kZWRcbiAgICAgICAqIHdpdGggd2FybmluZ3MuXG4gICAgICAgKiBAbmFtZSBDb25maWd1cmF0aW9uI3ZlcmJvc2VEZXByZWNhdGlvbnNcbiAgICAgICAqIEBzaW5jZSAzLjYuMFxuICAgICAgICogQHR5cGUgQm9vbGVhblxuICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAqL1xuICAgICAgdmVyYm9zZURlcHJlY2F0aW9uczogZmFsc2VcbiAgICB9O1xuXG4gICAgdmFyIGN1cnJlbnRTdWl0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRseUV4ZWN1dGluZ1N1aXRlc1tjdXJyZW50bHlFeGVjdXRpbmdTdWl0ZXMubGVuZ3RoIC0gMV07XG4gICAgfTtcblxuICAgIHZhciBjdXJyZW50UnVubmFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjdXJyZW50U3BlYyB8fCBjdXJyZW50U3VpdGUoKTtcbiAgICB9O1xuXG4gICAgdmFyIGdsb2JhbEVycm9ycyA9IG51bGw7XG5cbiAgICB2YXIgaW5zdGFsbEdsb2JhbEVycm9ycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGdsb2JhbEVycm9ycykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGdsb2JhbEVycm9ycyA9IG5ldyBqJC5HbG9iYWxFcnJvcnMoKTtcbiAgICAgIGdsb2JhbEVycm9ycy5pbnN0YWxsKCk7XG4gICAgfTtcblxuICAgIGlmICghb3B0aW9ucy5zdXBwcmVzc0xvYWRFcnJvcnMpIHtcbiAgICAgIGluc3RhbGxHbG9iYWxFcnJvcnMoKTtcbiAgICAgIGdsb2JhbEVycm9ycy5wdXNoTGlzdGVuZXIoZnVuY3Rpb24oXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIGZpbGVuYW1lLFxuICAgICAgICBsaW5lbm8sXG4gICAgICAgIGNvbE5vLFxuICAgICAgICBlcnJcbiAgICAgICkge1xuICAgICAgICB0b3BTdWl0ZS5yZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zLnB1c2goe1xuICAgICAgICAgIHBhc3NlZDogZmFsc2UsXG4gICAgICAgICAgZ2xvYmFsRXJyb3JUeXBlOiAnbG9hZCcsXG4gICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICBzdGFjazogZXJyICYmIGVyci5zdGFjayxcbiAgICAgICAgICBmaWxlbmFtZTogZmlsZW5hbWUsXG4gICAgICAgICAgbGluZW5vOiBsaW5lbm9cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmUgeW91ciBqYXNtaW5lIGVudmlyb25tZW50XG4gICAgICogQG5hbWUgRW52I2NvbmZpZ3VyZVxuICAgICAqIEBzaW5jZSAzLjMuMFxuICAgICAqIEBhcmd1bWVudCB7Q29uZmlndXJhdGlvbn0gY29uZmlndXJhdGlvblxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIHRoaXMuY29uZmlndXJlID0gZnVuY3Rpb24oY29uZmlndXJhdGlvbikge1xuICAgICAgdmFyIGJvb2xlYW5Qcm9wcyA9IFtcbiAgICAgICAgJ3JhbmRvbScsXG4gICAgICAgICdmYWlsU3BlY1dpdGhOb0V4cGVjdGF0aW9ucycsXG4gICAgICAgICdoaWRlRGlzYWJsZWQnLFxuICAgICAgICAnc3RvcE9uU3BlY0ZhaWx1cmUnLFxuICAgICAgICAnc3RvcFNwZWNPbkV4cGVjdGF0aW9uRmFpbHVyZScsXG4gICAgICAgICdhdXRvQ2xlYW5DbG9zdXJlcydcbiAgICAgIF07XG5cbiAgICAgIGJvb2xlYW5Qcm9wcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWd1cmF0aW9uW3Byb3BdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGNvbmZpZ1twcm9wXSA9ICEhY29uZmlndXJhdGlvbltwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChjb25maWd1cmF0aW9uLnNwZWNGaWx0ZXIpIHtcbiAgICAgICAgY29uZmlnLnNwZWNGaWx0ZXIgPSBjb25maWd1cmF0aW9uLnNwZWNGaWx0ZXI7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlndXJhdGlvbi5zZWVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25maWcuc2VlZCA9IGNvbmZpZ3VyYXRpb24uc2VlZDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbmZpZ3VyYXRpb24uaGFzT3duUHJvcGVydHkoJ3ZlcmJvc2VEZXByZWNhdGlvbnMnKSkge1xuICAgICAgICBjb25maWcudmVyYm9zZURlcHJlY2F0aW9ucyA9IGNvbmZpZ3VyYXRpb24udmVyYm9zZURlcHJlY2F0aW9ucztcbiAgICAgICAgZGVwcmVjYXRvci52ZXJib3NlRGVwcmVjYXRpb25zKGNvbmZpZy52ZXJib3NlRGVwcmVjYXRpb25zKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGNvbmZpZ3VyYXRpb24gZm9yIHlvdXIgamFzbWluZSBlbnZpcm9ubWVudFxuICAgICAqIEBuYW1lIEVudiNjb25maWd1cmF0aW9uXG4gICAgICogQHNpbmNlIDMuMy4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge0NvbmZpZ3VyYXRpb259XG4gICAgICovXG4gICAgdGhpcy5jb25maWd1cmF0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBjb25maWcpIHtcbiAgICAgICAgcmVzdWx0W3Byb3BlcnR5XSA9IGNvbmZpZ1twcm9wZXJ0eV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICB0aGlzLnNldERlZmF1bHRTcHlTdHJhdGVneSA9IGZ1bmN0aW9uKGRlZmF1bHRTdHJhdGVneUZuKSB7XG4gICAgICBpZiAoIWN1cnJlbnRSdW5uYWJsZSgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnRGVmYXVsdCBzcHkgc3RyYXRlZ3kgbXVzdCBiZSBzZXQgaW4gYSBiZWZvcmUgZnVuY3Rpb24gb3IgYSBzcGVjJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcnVubmFibGVSZXNvdXJjZXNbXG4gICAgICAgIGN1cnJlbnRSdW5uYWJsZSgpLmlkXG4gICAgICBdLmRlZmF1bHRTdHJhdGVneUZuID0gZGVmYXVsdFN0cmF0ZWd5Rm47XG4gICAgfTtcblxuICAgIHRoaXMuYWRkU3B5U3RyYXRlZ3kgPSBmdW5jdGlvbihuYW1lLCBmbikge1xuICAgICAgaWYgKCFjdXJyZW50UnVubmFibGUoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0N1c3RvbSBzcHkgc3RyYXRlZ2llcyBtdXN0IGJlIGFkZGVkIGluIGEgYmVmb3JlIGZ1bmN0aW9uIG9yIGEgc3BlYydcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJ1bm5hYmxlUmVzb3VyY2VzW2N1cnJlbnRSdW5uYWJsZSgpLmlkXS5jdXN0b21TcHlTdHJhdGVnaWVzW25hbWVdID0gZm47XG4gICAgfTtcblxuICAgIHRoaXMuYWRkQ3VzdG9tRXF1YWxpdHlUZXN0ZXIgPSBmdW5jdGlvbih0ZXN0ZXIpIHtcbiAgICAgIGlmICghY3VycmVudFJ1bm5hYmxlKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdDdXN0b20gRXF1YWxpdGllcyBtdXN0IGJlIGFkZGVkIGluIGEgYmVmb3JlIGZ1bmN0aW9uIG9yIGEgc3BlYydcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJ1bm5hYmxlUmVzb3VyY2VzW2N1cnJlbnRSdW5uYWJsZSgpLmlkXS5jdXN0b21FcXVhbGl0eVRlc3RlcnMucHVzaChcbiAgICAgICAgdGVzdGVyXG4gICAgICApO1xuICAgIH07XG5cbiAgICB0aGlzLmFkZE1hdGNoZXJzID0gZnVuY3Rpb24obWF0Y2hlcnNUb0FkZCkge1xuICAgICAgaWYgKCFjdXJyZW50UnVubmFibGUoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ01hdGNoZXJzIG11c3QgYmUgYWRkZWQgaW4gYSBiZWZvcmUgZnVuY3Rpb24gb3IgYSBzcGVjJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdmFyIGN1c3RvbU1hdGNoZXJzID1cbiAgICAgICAgcnVubmFibGVSZXNvdXJjZXNbY3VycmVudFJ1bm5hYmxlKCkuaWRdLmN1c3RvbU1hdGNoZXJzO1xuXG4gICAgICBmb3IgKHZhciBtYXRjaGVyTmFtZSBpbiBtYXRjaGVyc1RvQWRkKSB7XG4gICAgICAgIGN1c3RvbU1hdGNoZXJzW21hdGNoZXJOYW1lXSA9IG1hdGNoZXJzVG9BZGRbbWF0Y2hlck5hbWVdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmFkZEFzeW5jTWF0Y2hlcnMgPSBmdW5jdGlvbihtYXRjaGVyc1RvQWRkKSB7XG4gICAgICBpZiAoIWN1cnJlbnRSdW5uYWJsZSgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnQXN5bmMgTWF0Y2hlcnMgbXVzdCBiZSBhZGRlZCBpbiBhIGJlZm9yZSBmdW5jdGlvbiBvciBhIHNwZWMnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2YXIgY3VzdG9tQXN5bmNNYXRjaGVycyA9XG4gICAgICAgIHJ1bm5hYmxlUmVzb3VyY2VzW2N1cnJlbnRSdW5uYWJsZSgpLmlkXS5jdXN0b21Bc3luY01hdGNoZXJzO1xuXG4gICAgICBmb3IgKHZhciBtYXRjaGVyTmFtZSBpbiBtYXRjaGVyc1RvQWRkKSB7XG4gICAgICAgIGN1c3RvbUFzeW5jTWF0Y2hlcnNbbWF0Y2hlck5hbWVdID0gbWF0Y2hlcnNUb0FkZFttYXRjaGVyTmFtZV07XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuYWRkQ3VzdG9tT2JqZWN0Rm9ybWF0dGVyID0gZnVuY3Rpb24oZm9ybWF0dGVyKSB7XG4gICAgICBpZiAoIWN1cnJlbnRSdW5uYWJsZSgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnQ3VzdG9tIG9iamVjdCBmb3JtYXR0ZXJzIG11c3QgYmUgYWRkZWQgaW4gYSBiZWZvcmUgZnVuY3Rpb24gb3IgYSBzcGVjJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBydW5uYWJsZVJlc291cmNlc1tjdXJyZW50UnVubmFibGUoKS5pZF0uY3VzdG9tT2JqZWN0Rm9ybWF0dGVycy5wdXNoKFxuICAgICAgICBmb3JtYXR0ZXJcbiAgICAgICk7XG4gICAgfTtcblxuICAgIGokLkV4cGVjdGF0aW9uLmFkZENvcmVNYXRjaGVycyhqJC5tYXRjaGVycyk7XG4gICAgaiQuRXhwZWN0YXRpb24uYWRkQXN5bmNDb3JlTWF0Y2hlcnMoaiQuYXN5bmNNYXRjaGVycyk7XG5cbiAgICB2YXIgbmV4dFNwZWNJZCA9IDA7XG4gICAgdmFyIGdldE5leHRTcGVjSWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnc3BlYycgKyBuZXh0U3BlY0lkKys7XG4gICAgfTtcblxuICAgIHZhciBuZXh0U3VpdGVJZCA9IDA7XG4gICAgdmFyIGdldE5leHRTdWl0ZUlkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJ3N1aXRlJyArIG5leHRTdWl0ZUlkKys7XG4gICAgfTtcblxuICAgIHZhciBtYWtlUHJldHR5UHJpbnRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGN1c3RvbU9iamVjdEZvcm1hdHRlcnMgPVxuICAgICAgICBydW5uYWJsZVJlc291cmNlc1tjdXJyZW50UnVubmFibGUoKS5pZF0uY3VzdG9tT2JqZWN0Rm9ybWF0dGVycztcbiAgICAgIHJldHVybiBqJC5tYWtlUHJldHR5UHJpbnRlcihjdXN0b21PYmplY3RGb3JtYXR0ZXJzKTtcbiAgICB9O1xuXG4gICAgdmFyIG1ha2VNYXRjaGVyc1V0aWwgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGNyID0gY3VycmVudFJ1bm5hYmxlKCk7XG5cbiAgICAgIGlmIChjcikge1xuICAgICAgICBjb25zdCBjdXN0b21FcXVhbGl0eVRlc3RlcnMgPVxuICAgICAgICAgIHJ1bm5hYmxlUmVzb3VyY2VzW2NyLmlkXS5jdXN0b21FcXVhbGl0eVRlc3RlcnM7XG4gICAgICAgIHJldHVybiBuZXcgaiQuTWF0Y2hlcnNVdGlsKHtcbiAgICAgICAgICBjdXN0b21UZXN0ZXJzOiBjdXN0b21FcXVhbGl0eVRlc3RlcnMsXG4gICAgICAgICAgcHA6IG1ha2VQcmV0dHlQcmludGVyKClcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IGokLk1hdGNoZXJzVXRpbCh7IHBwOiBqJC5iYXNpY1ByZXR0eVByaW50ZXJfIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZXhwZWN0YXRpb25GYWN0b3J5ID0gZnVuY3Rpb24oYWN0dWFsLCBzcGVjKSB7XG4gICAgICByZXR1cm4gaiQuRXhwZWN0YXRpb24uZmFjdG9yeSh7XG4gICAgICAgIG1hdGNoZXJzVXRpbDogbWFrZU1hdGNoZXJzVXRpbCgpLFxuICAgICAgICBjdXN0b21NYXRjaGVyczogcnVubmFibGVSZXNvdXJjZXNbc3BlYy5pZF0uY3VzdG9tTWF0Y2hlcnMsXG4gICAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgICBhZGRFeHBlY3RhdGlvblJlc3VsdDogYWRkRXhwZWN0YXRpb25SZXN1bHRcbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBhZGRFeHBlY3RhdGlvblJlc3VsdChwYXNzZWQsIHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gc3BlYy5hZGRFeHBlY3RhdGlvblJlc3VsdChwYXNzZWQsIHJlc3VsdCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlY29yZExhdGVFcnJvcihlcnJvcikge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5KHtcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHBhc3NlZDogZmFsc2UsXG4gICAgICAgIG1hdGNoZXJOYW1lOiAnJyxcbiAgICAgICAgZXhwZWN0ZWQ6ICcnLFxuICAgICAgICBhY3R1YWw6ICcnXG4gICAgICB9KTtcbiAgICAgIHJlc3VsdC5nbG9iYWxFcnJvclR5cGUgPSAnbGF0ZUVycm9yJztcbiAgICAgIHRvcFN1aXRlLnJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMucHVzaChyZXN1bHQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlY29yZExhdGVFeHBlY3RhdGlvbihydW5hYmxlLCBydW5hYmxlVHlwZSwgcmVzdWx0KSB7XG4gICAgICB2YXIgZGVsYXllZEV4cGVjdGF0aW9uUmVzdWx0ID0ge307XG4gICAgICBPYmplY3Qua2V5cyhyZXN1bHQpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgICBkZWxheWVkRXhwZWN0YXRpb25SZXN1bHRba10gPSByZXN1bHRba107XG4gICAgICB9KTtcbiAgICAgIGRlbGF5ZWRFeHBlY3RhdGlvblJlc3VsdC5wYXNzZWQgPSBmYWxzZTtcbiAgICAgIGRlbGF5ZWRFeHBlY3RhdGlvblJlc3VsdC5nbG9iYWxFcnJvclR5cGUgPSAnbGF0ZUV4cGVjdGF0aW9uJztcbiAgICAgIGRlbGF5ZWRFeHBlY3RhdGlvblJlc3VsdC5tZXNzYWdlID1cbiAgICAgICAgcnVuYWJsZVR5cGUgK1xuICAgICAgICAnIFwiJyArXG4gICAgICAgIHJ1bmFibGUuZ2V0RnVsbE5hbWUoKSArXG4gICAgICAgICdcIiByYW4gYSBcIicgK1xuICAgICAgICByZXN1bHQubWF0Y2hlck5hbWUgK1xuICAgICAgICAnXCIgZXhwZWN0YXRpb24gYWZ0ZXIgaXQgZmluaXNoZWQuXFxuJztcblxuICAgICAgaWYgKHJlc3VsdC5tZXNzYWdlKSB7XG4gICAgICAgIGRlbGF5ZWRFeHBlY3RhdGlvblJlc3VsdC5tZXNzYWdlICs9XG4gICAgICAgICAgJ01lc3NhZ2U6IFwiJyArIHJlc3VsdC5tZXNzYWdlICsgJ1wiXFxuJztcbiAgICAgIH1cblxuICAgICAgZGVsYXllZEV4cGVjdGF0aW9uUmVzdWx0Lm1lc3NhZ2UgKz1cbiAgICAgICAgJzEuIERpZCB5b3UgZm9yZ2V0IHRvIHJldHVybiBvciBhd2FpdCB0aGUgcmVzdWx0IG9mIGV4cGVjdEFzeW5jP1xcbicgK1xuICAgICAgICAnMi4gV2FzIGRvbmUoKSBpbnZva2VkIGJlZm9yZSBhbiBhc3luYyBvcGVyYXRpb24gY29tcGxldGVkP1xcbicgK1xuICAgICAgICAnMy4gRGlkIGFuIGV4cGVjdGF0aW9uIGZvbGxvdyBhIGNhbGwgdG8gZG9uZSgpPyc7XG5cbiAgICAgIHRvcFN1aXRlLnJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMucHVzaChkZWxheWVkRXhwZWN0YXRpb25SZXN1bHQpO1xuICAgIH1cblxuICAgIHZhciBhc3luY0V4cGVjdGF0aW9uRmFjdG9yeSA9IGZ1bmN0aW9uKGFjdHVhbCwgc3BlYywgcnVuYWJsZVR5cGUpIHtcbiAgICAgIHJldHVybiBqJC5FeHBlY3RhdGlvbi5hc3luY0ZhY3Rvcnkoe1xuICAgICAgICBtYXRjaGVyc1V0aWw6IG1ha2VNYXRjaGVyc1V0aWwoKSxcbiAgICAgICAgY3VzdG9tQXN5bmNNYXRjaGVyczogcnVubmFibGVSZXNvdXJjZXNbc3BlYy5pZF0uY3VzdG9tQXN5bmNNYXRjaGVycyxcbiAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICAgIGFkZEV4cGVjdGF0aW9uUmVzdWx0OiBhZGRFeHBlY3RhdGlvblJlc3VsdFxuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIGFkZEV4cGVjdGF0aW9uUmVzdWx0KHBhc3NlZCwgcmVzdWx0KSB7XG4gICAgICAgIGlmIChjdXJyZW50UnVubmFibGUoKSAhPT0gc3BlYykge1xuICAgICAgICAgIHJlY29yZExhdGVFeHBlY3RhdGlvbihzcGVjLCBydW5hYmxlVHlwZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BlYy5hZGRFeHBlY3RhdGlvblJlc3VsdChwYXNzZWQsIHJlc3VsdCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgc3VpdGVBc3luY0V4cGVjdGF0aW9uRmFjdG9yeSA9IGZ1bmN0aW9uKGFjdHVhbCwgc3VpdGUpIHtcbiAgICAgIHJldHVybiBhc3luY0V4cGVjdGF0aW9uRmFjdG9yeShhY3R1YWwsIHN1aXRlLCAnU3VpdGUnKTtcbiAgICB9O1xuXG4gICAgdmFyIHNwZWNBc3luY0V4cGVjdGF0aW9uRmFjdG9yeSA9IGZ1bmN0aW9uKGFjdHVhbCwgc3VpdGUpIHtcbiAgICAgIHJldHVybiBhc3luY0V4cGVjdGF0aW9uRmFjdG9yeShhY3R1YWwsIHN1aXRlLCAnU3BlYycpO1xuICAgIH07XG5cbiAgICB2YXIgZGVmYXVsdFJlc291cmNlc0ZvclJ1bm5hYmxlID0gZnVuY3Rpb24oaWQsIHBhcmVudFJ1bm5hYmxlSWQpIHtcbiAgICAgIHZhciByZXNvdXJjZXMgPSB7XG4gICAgICAgIHNwaWVzOiBbXSxcbiAgICAgICAgY3VzdG9tRXF1YWxpdHlUZXN0ZXJzOiBbXSxcbiAgICAgICAgY3VzdG9tTWF0Y2hlcnM6IHt9LFxuICAgICAgICBjdXN0b21Bc3luY01hdGNoZXJzOiB7fSxcbiAgICAgICAgY3VzdG9tU3B5U3RyYXRlZ2llczoge30sXG4gICAgICAgIGRlZmF1bHRTdHJhdGVneUZuOiB1bmRlZmluZWQsXG4gICAgICAgIGN1c3RvbU9iamVjdEZvcm1hdHRlcnM6IFtdXG4gICAgICB9O1xuXG4gICAgICBpZiAocnVubmFibGVSZXNvdXJjZXNbcGFyZW50UnVubmFibGVJZF0pIHtcbiAgICAgICAgcmVzb3VyY2VzLmN1c3RvbUVxdWFsaXR5VGVzdGVycyA9IGokLnV0aWwuY2xvbmUoXG4gICAgICAgICAgcnVubmFibGVSZXNvdXJjZXNbcGFyZW50UnVubmFibGVJZF0uY3VzdG9tRXF1YWxpdHlUZXN0ZXJzXG4gICAgICAgICk7XG4gICAgICAgIHJlc291cmNlcy5jdXN0b21NYXRjaGVycyA9IGokLnV0aWwuY2xvbmUoXG4gICAgICAgICAgcnVubmFibGVSZXNvdXJjZXNbcGFyZW50UnVubmFibGVJZF0uY3VzdG9tTWF0Y2hlcnNcbiAgICAgICAgKTtcbiAgICAgICAgcmVzb3VyY2VzLmN1c3RvbUFzeW5jTWF0Y2hlcnMgPSBqJC51dGlsLmNsb25lKFxuICAgICAgICAgIHJ1bm5hYmxlUmVzb3VyY2VzW3BhcmVudFJ1bm5hYmxlSWRdLmN1c3RvbUFzeW5jTWF0Y2hlcnNcbiAgICAgICAgKTtcbiAgICAgICAgcmVzb3VyY2VzLmN1c3RvbU9iamVjdEZvcm1hdHRlcnMgPSBqJC51dGlsLmNsb25lKFxuICAgICAgICAgIHJ1bm5hYmxlUmVzb3VyY2VzW3BhcmVudFJ1bm5hYmxlSWRdLmN1c3RvbU9iamVjdEZvcm1hdHRlcnNcbiAgICAgICAgKTtcbiAgICAgICAgcmVzb3VyY2VzLmN1c3RvbVNweVN0cmF0ZWdpZXMgPSBqJC51dGlsLmNsb25lKFxuICAgICAgICAgIHJ1bm5hYmxlUmVzb3VyY2VzW3BhcmVudFJ1bm5hYmxlSWRdLmN1c3RvbVNweVN0cmF0ZWdpZXNcbiAgICAgICAgKTtcbiAgICAgICAgcmVzb3VyY2VzLmRlZmF1bHRTdHJhdGVneUZuID1cbiAgICAgICAgICBydW5uYWJsZVJlc291cmNlc1twYXJlbnRSdW5uYWJsZUlkXS5kZWZhdWx0U3RyYXRlZ3lGbjtcbiAgICAgIH1cblxuICAgICAgcnVubmFibGVSZXNvdXJjZXNbaWRdID0gcmVzb3VyY2VzO1xuICAgIH07XG5cbiAgICB2YXIgY2xlYXJSZXNvdXJjZXNGb3JSdW5uYWJsZSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICBzcHlSZWdpc3RyeS5jbGVhclNwaWVzKCk7XG4gICAgICBkZWxldGUgcnVubmFibGVSZXNvdXJjZXNbaWRdO1xuICAgIH07XG5cbiAgICB2YXIgYmVmb3JlQW5kQWZ0ZXJGbnMgPSBmdW5jdGlvbih0YXJnZXRTdWl0ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYmVmb3JlcyA9IFtdLFxuICAgICAgICAgIGFmdGVycyA9IFtdLFxuICAgICAgICAgIHN1aXRlID0gdGFyZ2V0U3VpdGU7XG5cbiAgICAgICAgd2hpbGUgKHN1aXRlKSB7XG4gICAgICAgICAgYmVmb3JlcyA9IGJlZm9yZXMuY29uY2F0KHN1aXRlLmJlZm9yZUZucyk7XG4gICAgICAgICAgYWZ0ZXJzID0gYWZ0ZXJzLmNvbmNhdChzdWl0ZS5hZnRlckZucyk7XG5cbiAgICAgICAgICBzdWl0ZSA9IHN1aXRlLnBhcmVudFN1aXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBiZWZvcmVzOiBiZWZvcmVzLnJldmVyc2UoKSxcbiAgICAgICAgICBhZnRlcnM6IGFmdGVyc1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGdldFNwZWNOYW1lID0gZnVuY3Rpb24oc3BlYywgc3VpdGUpIHtcbiAgICAgIHZhciBmdWxsTmFtZSA9IFtzcGVjLmRlc2NyaXB0aW9uXSxcbiAgICAgICAgc3VpdGVGdWxsTmFtZSA9IHN1aXRlLmdldEZ1bGxOYW1lKCk7XG5cbiAgICAgIGlmIChzdWl0ZUZ1bGxOYW1lICE9PSAnJykge1xuICAgICAgICBmdWxsTmFtZS51bnNoaWZ0KHN1aXRlRnVsbE5hbWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bGxOYW1lLmpvaW4oJyAnKTtcbiAgICB9O1xuXG4gICAgLy8gVE9ETzogd2UgbWF5IGp1c3QgYmUgYWJsZSB0byBwYXNzIGluIHRoZSBmbiBpbnN0ZWFkIG9mIHdyYXBwaW5nIGhlcmVcbiAgICB2YXIgYnVpbGRFeHBlY3RhdGlvblJlc3VsdCA9IGokLmJ1aWxkRXhwZWN0YXRpb25SZXN1bHQsXG4gICAgICBleGNlcHRpb25Gb3JtYXR0ZXIgPSBuZXcgaiQuRXhjZXB0aW9uRm9ybWF0dGVyKCksXG4gICAgICBleHBlY3RhdGlvblJlc3VsdEZhY3RvcnkgPSBmdW5jdGlvbihhdHRycykge1xuICAgICAgICBhdHRycy5tZXNzYWdlRm9ybWF0dGVyID0gZXhjZXB0aW9uRm9ybWF0dGVyLm1lc3NhZ2U7XG4gICAgICAgIGF0dHJzLnN0YWNrRm9ybWF0dGVyID0gZXhjZXB0aW9uRm9ybWF0dGVyLnN0YWNrO1xuXG4gICAgICAgIHJldHVybiBidWlsZEV4cGVjdGF0aW9uUmVzdWx0KGF0dHJzKTtcbiAgICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYXVzZXMgYSBkZXByZWNhdGlvbiB3YXJuaW5nIHRvIGJlIGxvZ2dlZCB0byB0aGUgY29uc29sZSBhbmQgcmVwb3J0ZWQgdG9cbiAgICAgKiByZXBvcnRlcnMuXG4gICAgICpcbiAgICAgKiBUaGUgb3B0aW9uYWwgc2Vjb25kIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBjYW4gaGF2ZSBlaXRoZXIgb2YgdGhlXG4gICAgICogZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICpcbiAgICAgKiBvbWl0U3RhY2tUcmFjZTogV2hldGhlciB0byBvbWl0IHRoZSBzdGFjayB0cmFjZS4gT3B0aW9uYWwuIERlZmF1bHRzIHRvXG4gICAgICogZmFsc2UuIFRoaXMgb3B0aW9uIGlzIGlnbm9yZWQgaWYgdGhlIGRlcHJlY2F0aW9uIGlzIGFuIEVycm9yLiBTZXQgdGhpc1xuICAgICAqIHdoZW4gdGhlIHN0YWNrIHRyYWNlIHdpbGwgbm90IGNvbnRhaW4gYW55dGhpbmcgdGhhdCBoZWxwcyB0aGUgdXNlciBmaW5kXG4gICAgICogdGhlIHNvdXJjZSBvZiB0aGUgZGVwcmVjYXRpb24uXG4gICAgICpcbiAgICAgKiBpZ25vcmVSdW5uYWJsZTogV2hldGhlciB0byBsb2cgdGhlIGRlcHJlY2F0aW9uIG9uIHRoZSByb290IHN1aXRlLCBpZ25vcmluZ1xuICAgICAqIHRoZSBzcGVjIG9yIHN1aXRlIHRoYXQncyBydW5uaW5nIHdoZW4gaXQgaGFwcGVucy4gT3B0aW9uYWwuIERlZmF1bHRzIHRvXG4gICAgICogZmFsc2UuXG4gICAgICpcbiAgICAgKiBAbmFtZSBFbnYjZGVwcmVjYXRlZFxuICAgICAqIEBzaW5jZSAyLjk5XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd8RXJyb3J9IGRlcHJlY2F0aW9uIFRoZSBkZXByZWNhdGlvbiBtZXNzYWdlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25hbCBleHRyYSBvcHRpb25zLCBhcyBkZXNjcmliZWQgYWJvdmVcbiAgICAgKi9cbiAgICB0aGlzLmRlcHJlY2F0ZWQgPSBmdW5jdGlvbihkZXByZWNhdGlvbiwgb3B0aW9ucykge1xuICAgICAgdmFyIHJ1bm5hYmxlID0gY3VycmVudFJ1bm5hYmxlKCkgfHwgdG9wU3VpdGU7XG4gICAgICBkZXByZWNhdG9yLmFkZERlcHJlY2F0aW9uV2FybmluZyhydW5uYWJsZSwgZGVwcmVjYXRpb24sIG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICB2YXIgcXVldWVSdW5uZXJGYWN0b3J5ID0gZnVuY3Rpb24ob3B0aW9ucywgYXJncykge1xuICAgICAgaWYgKG9wdGlvbnMuaXNMZWFmKSB7XG4gICAgICAgIC8vIEEgc3BlY1xuICAgICAgICBvcHRpb25zLlNraXBQb2xpY3kgPSBqJC5Db21wbGV0ZU9uRmlyc3RFcnJvclNraXBQb2xpY3k7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaXNSZXBvcnRlcikge1xuICAgICAgICAvLyBBIHJlcG9ydGVyIHF1ZXVlXG4gICAgICAgIG9wdGlvbnMuU2tpcFBvbGljeSA9IGokLk5ldmVyU2tpcFBvbGljeTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEEgc3VpdGVcbiAgICAgICAgaWYgKGNvbmZpZy5zdG9wT25TcGVjRmFpbHVyZSkge1xuICAgICAgICAgIG9wdGlvbnMuU2tpcFBvbGljeSA9IGokLkNvbXBsZXRlT25GaXJzdEVycm9yU2tpcFBvbGljeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zLlNraXBQb2xpY3kgPSBqJC5Ta2lwQWZ0ZXJCZWZvcmVBbGxFcnJvclBvbGljeTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvcHRpb25zLmNsZWFyU3RhY2sgPSBvcHRpb25zLmNsZWFyU3RhY2sgfHwgY2xlYXJTdGFjaztcbiAgICAgIG9wdGlvbnMudGltZW91dCA9IHtcbiAgICAgICAgc2V0VGltZW91dDogcmVhbFNldFRpbWVvdXQsXG4gICAgICAgIGNsZWFyVGltZW91dDogcmVhbENsZWFyVGltZW91dFxuICAgICAgfTtcbiAgICAgIG9wdGlvbnMuZmFpbCA9IHNlbGYuZmFpbDtcbiAgICAgIG9wdGlvbnMuZ2xvYmFsRXJyb3JzID0gZ2xvYmFsRXJyb3JzO1xuICAgICAgb3B0aW9ucy5vbkV4Y2VwdGlvbiA9XG4gICAgICAgIG9wdGlvbnMub25FeGNlcHRpb24gfHxcbiAgICAgICAgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIChjdXJyZW50UnVubmFibGUoKSB8fCB0b3BTdWl0ZSkub25FeGNlcHRpb24oZSk7XG4gICAgICAgIH07XG4gICAgICBvcHRpb25zLmRlcHJlY2F0ZWQgPSBzZWxmLmRlcHJlY2F0ZWQ7XG5cbiAgICAgIG5ldyBqJC5RdWV1ZVJ1bm5lcihvcHRpb25zKS5leGVjdXRlKGFyZ3MpO1xuICAgIH07XG5cbiAgICB2YXIgdG9wU3VpdGUgPSBuZXcgaiQuU3VpdGUoe1xuICAgICAgaWQ6IGdldE5leHRTdWl0ZUlkKCksXG4gICAgICBkZXNjcmlwdGlvbjogJ0phc21pbmVfX1RvcExldmVsX19TdWl0ZScsXG4gICAgICBleHBlY3RhdGlvbkZhY3Rvcnk6IGV4cGVjdGF0aW9uRmFjdG9yeSxcbiAgICAgIGFzeW5jRXhwZWN0YXRpb25GYWN0b3J5OiBzdWl0ZUFzeW5jRXhwZWN0YXRpb25GYWN0b3J5LFxuICAgICAgZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5OiBleHBlY3RhdGlvblJlc3VsdEZhY3RvcnksXG4gICAgICBhdXRvQ2xlYW5DbG9zdXJlczogY29uZmlnLmF1dG9DbGVhbkNsb3N1cmVzLFxuICAgICAgb25MYXRlRXJyb3I6IHJlY29yZExhdGVFcnJvclxuICAgIH0pO1xuICAgIHZhciBkZXByZWNhdG9yID0gbmV3IGokLkRlcHJlY2F0b3IodG9wU3VpdGUpO1xuICAgIGN1cnJlbnREZWNsYXJhdGlvblN1aXRlID0gdG9wU3VpdGU7XG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyB0aGUgcm9vdCBzdWl0ZSwgdGhyb3VnaCB3aGljaCBhbGwgc3VpdGVzIGFuZCBzcGVjcyBjYW4gYmVcbiAgICAgKiBhY2Nlc3NlZC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbmFtZSBFbnYjdG9wU3VpdGVcbiAgICAgKiBAcmV0dXJuIHtTdWl0ZX0gdGhlIHJvb3Qgc3VpdGVcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKi9cbiAgICB0aGlzLnRvcFN1aXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdG9wU3VpdGUubWV0YWRhdGE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgcmVwcmVzZW50cyB0aGUgYXZhaWxhYmxlIHJlcG9ydGVyIGNhbGxiYWNrIGZvciBhbiBvYmplY3QgcGFzc2VkIHRvIHtAbGluayBFbnYjYWRkUmVwb3J0ZXJ9LlxuICAgICAqIEBpbnRlcmZhY2UgUmVwb3J0ZXJcbiAgICAgKiBAc2VlIGN1c3RvbV9yZXBvcnRlclxuICAgICAqL1xuICAgIHZhciByZXBvcnRlciA9IG5ldyBqJC5SZXBvcnREaXNwYXRjaGVyKFxuICAgICAgW1xuICAgICAgICAvKipcbiAgICAgICAgICogYGphc21pbmVTdGFydGVkYCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIG9mIHRoZSBzcGVjcyBoYXZlIGJlZW4gbG9hZGVkLCBidXQganVzdCBiZWZvcmUgZXhlY3V0aW9uIHN0YXJ0cy5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBuYW1lIFJlcG9ydGVyI2phc21pbmVTdGFydGVkXG4gICAgICAgICAqIEBwYXJhbSB7SmFzbWluZVN0YXJ0ZWRJbmZvfSBzdWl0ZUluZm8gSW5mb3JtYXRpb24gYWJvdXQgdGhlIGZ1bGwgSmFzbWluZSBzdWl0ZSB0aGF0IGlzIGJlaW5nIHJ1blxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZG9uZV0gVXNlZCB0byBzcGVjaWZ5IHRvIEphc21pbmUgdGhhdCB0aGlzIGNhbGxiYWNrIGlzIGFzeW5jaHJvbm91cyBhbmQgSmFzbWluZSBzaG91bGQgd2FpdCB1bnRpbCBpdCBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlIG1vdmluZyBvbi5cbiAgICAgICAgICogQHJldHVybnMge30gT3B0aW9uYWxseSByZXR1cm4gYSBQcm9taXNlIGluc3RlYWQgb2YgdXNpbmcgYGRvbmVgIHRvIGNhdXNlIEphc21pbmUgdG8gd2FpdCBmb3IgY29tcGxldGlvbi5cbiAgICAgICAgICogQHNlZSBhc3luY1xuICAgICAgICAgKi9cbiAgICAgICAgJ2phc21pbmVTdGFydGVkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gdGhlIGVudGlyZSBzdWl0ZSBoYXMgZmluaXNoZWQgZXhlY3V0aW9uIGBqYXNtaW5lRG9uZWAgaXMgY2FsbGVkXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAbmFtZSBSZXBvcnRlciNqYXNtaW5lRG9uZVxuICAgICAgICAgKiBAcGFyYW0ge0phc21pbmVEb25lSW5mb30gc3VpdGVJbmZvIEluZm9ybWF0aW9uIGFib3V0IHRoZSBmdWxsIEphc21pbmUgc3VpdGUgdGhhdCBqdXN0IGZpbmlzaGVkIHJ1bm5pbmcuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtkb25lXSBVc2VkIHRvIHNwZWNpZnkgdG8gSmFzbWluZSB0aGF0IHRoaXMgY2FsbGJhY2sgaXMgYXN5bmNocm9ub3VzIGFuZCBKYXNtaW5lIHNob3VsZCB3YWl0IHVudGlsIGl0IGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUgbW92aW5nIG9uLlxuICAgICAgICAgKiBAcmV0dXJucyB7fSBPcHRpb25hbGx5IHJldHVybiBhIFByb21pc2UgaW5zdGVhZCBvZiB1c2luZyBgZG9uZWAgdG8gY2F1c2UgSmFzbWluZSB0byB3YWl0IGZvciBjb21wbGV0aW9uLlxuICAgICAgICAgKiBAc2VlIGFzeW5jXG4gICAgICAgICAqL1xuICAgICAgICAnamFzbWluZURvbmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogYHN1aXRlU3RhcnRlZGAgaXMgaW52b2tlZCB3aGVuIGEgYGRlc2NyaWJlYCBzdGFydHMgdG8gcnVuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAbmFtZSBSZXBvcnRlciNzdWl0ZVN0YXJ0ZWRcbiAgICAgICAgICogQHBhcmFtIHtTdWl0ZVJlc3VsdH0gcmVzdWx0IEluZm9ybWF0aW9uIGFib3V0IHRoZSBpbmRpdmlkdWFsIHtAbGluayBkZXNjcmliZX0gYmVpbmcgcnVuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtkb25lXSBVc2VkIHRvIHNwZWNpZnkgdG8gSmFzbWluZSB0aGF0IHRoaXMgY2FsbGJhY2sgaXMgYXN5bmNocm9ub3VzIGFuZCBKYXNtaW5lIHNob3VsZCB3YWl0IHVudGlsIGl0IGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUgbW92aW5nIG9uLlxuICAgICAgICAgKiBAcmV0dXJucyB7fSBPcHRpb25hbGx5IHJldHVybiBhIFByb21pc2UgaW5zdGVhZCBvZiB1c2luZyBgZG9uZWAgdG8gY2F1c2UgSmFzbWluZSB0byB3YWl0IGZvciBjb21wbGV0aW9uLlxuICAgICAgICAgKiBAc2VlIGFzeW5jXG4gICAgICAgICAqL1xuICAgICAgICAnc3VpdGVTdGFydGVkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGBzdWl0ZURvbmVgIGlzIGludm9rZWQgd2hlbiBhbGwgb2YgdGhlIGNoaWxkIHNwZWNzIGFuZCBzdWl0ZXMgZm9yIGEgZ2l2ZW4gc3VpdGUgaGF2ZSBiZWVuIHJ1blxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGlsZSBqYXNtaW5lIGRvZXNuJ3QgcmVxdWlyZSBhbnkgc3BlY2lmaWMgZnVuY3Rpb25zLCBub3QgZGVmaW5pbmcgYSBgc3VpdGVEb25lYCB3aWxsIG1ha2UgaXQgaW1wb3NzaWJsZSBmb3IgYSByZXBvcnRlciB0byBrbm93IHdoZW4gYSBzdWl0ZSBoYXMgZmFpbHVyZXMgaW4gYW4gYGFmdGVyQWxsYC5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBuYW1lIFJlcG9ydGVyI3N1aXRlRG9uZVxuICAgICAgICAgKiBAcGFyYW0ge1N1aXRlUmVzdWx0fSByZXN1bHRcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2RvbmVdIFVzZWQgdG8gc3BlY2lmeSB0byBKYXNtaW5lIHRoYXQgdGhpcyBjYWxsYmFjayBpcyBhc3luY2hyb25vdXMgYW5kIEphc21pbmUgc2hvdWxkIHdhaXQgdW50aWwgaXQgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSBtb3Zpbmcgb24uXG4gICAgICAgICAqIEByZXR1cm5zIHt9IE9wdGlvbmFsbHkgcmV0dXJuIGEgUHJvbWlzZSBpbnN0ZWFkIG9mIHVzaW5nIGBkb25lYCB0byBjYXVzZSBKYXNtaW5lIHRvIHdhaXQgZm9yIGNvbXBsZXRpb24uXG4gICAgICAgICAqIEBzZWUgYXN5bmNcbiAgICAgICAgICovXG4gICAgICAgICdzdWl0ZURvbmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogYHNwZWNTdGFydGVkYCBpcyBpbnZva2VkIHdoZW4gYW4gYGl0YCBzdGFydHMgdG8gcnVuIChpbmNsdWRpbmcgYXNzb2NpYXRlZCBgYmVmb3JlRWFjaGAgZnVuY3Rpb25zKVxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQG5hbWUgUmVwb3J0ZXIjc3BlY1N0YXJ0ZWRcbiAgICAgICAgICogQHBhcmFtIHtTcGVjUmVzdWx0fSByZXN1bHQgSW5mb3JtYXRpb24gYWJvdXQgdGhlIGluZGl2aWR1YWwge0BsaW5rIGl0fSBiZWluZyBydW5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2RvbmVdIFVzZWQgdG8gc3BlY2lmeSB0byBKYXNtaW5lIHRoYXQgdGhpcyBjYWxsYmFjayBpcyBhc3luY2hyb25vdXMgYW5kIEphc21pbmUgc2hvdWxkIHdhaXQgdW50aWwgaXQgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSBtb3Zpbmcgb24uXG4gICAgICAgICAqIEByZXR1cm5zIHt9IE9wdGlvbmFsbHkgcmV0dXJuIGEgUHJvbWlzZSBpbnN0ZWFkIG9mIHVzaW5nIGBkb25lYCB0byBjYXVzZSBKYXNtaW5lIHRvIHdhaXQgZm9yIGNvbXBsZXRpb24uXG4gICAgICAgICAqIEBzZWUgYXN5bmNcbiAgICAgICAgICovXG4gICAgICAgICdzcGVjU3RhcnRlZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgc3BlY0RvbmVgIGlzIGludm9rZWQgd2hlbiBhbiBgaXRgIGFuZCBpdHMgYXNzb2NpYXRlZCBgYmVmb3JlRWFjaGAgYW5kIGBhZnRlckVhY2hgIGZ1bmN0aW9ucyBoYXZlIGJlZW4gcnVuLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGlsZSBqYXNtaW5lIGRvZXNuJ3QgcmVxdWlyZSBhbnkgc3BlY2lmaWMgZnVuY3Rpb25zLCBub3QgZGVmaW5pbmcgYSBgc3BlY0RvbmVgIHdpbGwgbWFrZSBpdCBpbXBvc3NpYmxlIGZvciBhIHJlcG9ydGVyIHRvIGtub3cgd2hlbiBhIHNwZWMgaGFzIGZhaWxlZC5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBuYW1lIFJlcG9ydGVyI3NwZWNEb25lXG4gICAgICAgICAqIEBwYXJhbSB7U3BlY1Jlc3VsdH0gcmVzdWx0XG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtkb25lXSBVc2VkIHRvIHNwZWNpZnkgdG8gSmFzbWluZSB0aGF0IHRoaXMgY2FsbGJhY2sgaXMgYXN5bmNocm9ub3VzIGFuZCBKYXNtaW5lIHNob3VsZCB3YWl0IHVudGlsIGl0IGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUgbW92aW5nIG9uLlxuICAgICAgICAgKiBAcmV0dXJucyB7fSBPcHRpb25hbGx5IHJldHVybiBhIFByb21pc2UgaW5zdGVhZCBvZiB1c2luZyBgZG9uZWAgdG8gY2F1c2UgSmFzbWluZSB0byB3YWl0IGZvciBjb21wbGV0aW9uLlxuICAgICAgICAgKiBAc2VlIGFzeW5jXG4gICAgICAgICAqL1xuICAgICAgICAnc3BlY0RvbmUnXG4gICAgICBdLFxuICAgICAgcXVldWVSdW5uZXJGYWN0b3J5LFxuICAgICAgcmVjb3JkTGF0ZUVycm9yXG4gICAgKTtcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBzcGVjcy5cbiAgICAgKlxuICAgICAqIElmIGNhbGxlZCB3aXRoIG5vIHBhcmFtZXRlcnMgb3Igd2l0aCBhIGZhbHN5IHZhbHVlIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIsXG4gICAgICogYWxsIHNwZWNzIHdpbGwgYmUgZXhlY3V0ZWQgZXhjZXB0IHRob3NlIHRoYXQgYXJlIGV4Y2x1ZGVkIGJ5IGFcbiAgICAgKiBbc3BlYyBmaWx0ZXJde0BsaW5rIENvbmZpZ3VyYXRpb24jc3BlY0ZpbHRlcn0gb3Igb3RoZXIgbWVjaGFuaXNtLiBJZiB0aGVcbiAgICAgKiBmaXJzdCBwYXJhbWV0ZXIgaXMgYSBsaXN0IG9mIHNwZWMvc3VpdGUgSURzLCBvbmx5IHRob3NlIHNwZWNzL3N1aXRlcyB3aWxsXG4gICAgICogYmUgcnVuLlxuICAgICAqXG4gICAgICogQm90aCBwYXJhbWV0ZXJzIGFyZSBvcHRpb25hbCwgYnV0IGEgY29tcGxldGlvbiBjYWxsYmFjayBpcyBvbmx5IHZhbGlkIGFzXG4gICAgICogdGhlIHNlY29uZCBwYXJhbWV0ZXIuIFRvIHNwZWNpZnkgYSBjb21wbGV0aW9uIGNhbGxiYWNrIGJ1dCBub3QgYSBsaXN0IG9mXG4gICAgICogc3BlY3Mvc3VpdGVzIHRvIHJ1biwgcGFzcyBudWxsIG9yIHVuZGVmaW5lZCBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyLiBUaGVcbiAgICAgKiBjb21wbGV0aW9uIGNhbGxiYWNrIGlzIHN1cHBvcnRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS4gSW4gbW9zdFxuICAgICAqIGNhc2VzIGl0IHdpbGwgYmUgbW9yZSBjb252ZW5pZW50IHRvIHVzZSB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogZXhlY3V0ZSBzaG91bGQgbm90IGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZSB1bmxlc3MgdGhlIGVudiBoYXMgYmVlblxuICAgICAqIGNvbmZpZ3VyZWQgd2l0aCBge2F1dG9DbGVhbkNsb3N1cmVzOiBmYWxzZX1gLlxuICAgICAqXG4gICAgICogZXhlY3V0ZSByZXR1cm5zIGEgcHJvbWlzZS4gVGhlIHByb21pc2Ugd2lsbCBiZSByZXNvbHZlZCB0byB0aGUgc2FtZVxuICAgICAqIHtAbGluayBKYXNtaW5lRG9uZUluZm98b3ZlcmFsbCByZXN1bHR9IHRoYXQncyBwYXNzZWQgdG8gYSByZXBvcnRlcidzXG4gICAgICogYGphc21pbmVEb25lYCBtZXRob2QsIGV2ZW4gaWYgdGhlIHN1aXRlIGRpZCBub3QgcGFzcy4gVG8gZGV0ZXJtaW5lXG4gICAgICogd2hldGhlciB0aGUgc3VpdGUgcGFzc2VkLCBjaGVjayB0aGUgdmFsdWUgdGhhdCB0aGUgcHJvbWlzZSByZXNvbHZlcyB0b1xuICAgICAqIG9yIHVzZSBhIHtAbGluayBSZXBvcnRlcn0uXG4gICAgICpcbiAgICAgKiBAbmFtZSBFbnYjZXhlY3V0ZVxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7KHN0cmluZ1tdKT19IHJ1bm5hYmxlc1RvUnVuIElEcyBvZiBzdWl0ZXMgYW5kL29yIHNwZWNzIHRvIHJ1blxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkNvbXBsZXRlIEZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgYWxsIHNwZWNzIGhhdmUgcnVuXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxKYXNtaW5lRG9uZUluZm8+fVxuICAgICAqL1xuICAgIHRoaXMuZXhlY3V0ZSA9IGZ1bmN0aW9uKHJ1bm5hYmxlc1RvUnVuLCBvbkNvbXBsZXRlKSB7XG4gICAgICBpZiAodGhpcy5fZXhlY3V0ZWRCZWZvcmUpIHtcbiAgICAgICAgdG9wU3VpdGUucmVzZXQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2V4ZWN1dGVkQmVmb3JlID0gdHJ1ZTtcbiAgICAgIGRlZmF1bHRSZXNvdXJjZXNGb3JSdW5uYWJsZSh0b3BTdWl0ZS5pZCk7XG4gICAgICBpbnN0YWxsR2xvYmFsRXJyb3JzKCk7XG5cbiAgICAgIGlmICghcnVubmFibGVzVG9SdW4pIHtcbiAgICAgICAgaWYgKGZvY3VzZWRSdW5uYWJsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcnVubmFibGVzVG9SdW4gPSBmb2N1c2VkUnVubmFibGVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJ1bm5hYmxlc1RvUnVuID0gW3RvcFN1aXRlLmlkXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgb3JkZXIgPSBuZXcgaiQuT3JkZXIoe1xuICAgICAgICByYW5kb206IGNvbmZpZy5yYW5kb20sXG4gICAgICAgIHNlZWQ6IGNvbmZpZy5zZWVkXG4gICAgICB9KTtcblxuICAgICAgdmFyIHByb2Nlc3NvciA9IG5ldyBqJC5UcmVlUHJvY2Vzc29yKHtcbiAgICAgICAgdHJlZTogdG9wU3VpdGUsXG4gICAgICAgIHJ1bm5hYmxlSWRzOiBydW5uYWJsZXNUb1J1bixcbiAgICAgICAgcXVldWVSdW5uZXJGYWN0b3J5OiBxdWV1ZVJ1bm5lckZhY3RvcnksXG4gICAgICAgIGZhaWxTcGVjV2l0aE5vRXhwZWN0YXRpb25zOiBjb25maWcuZmFpbFNwZWNXaXRoTm9FeHBlY3RhdGlvbnMsXG4gICAgICAgIG5vZGVTdGFydDogZnVuY3Rpb24oc3VpdGUsIG5leHQpIHtcbiAgICAgICAgICBjdXJyZW50bHlFeGVjdXRpbmdTdWl0ZXMucHVzaChzdWl0ZSk7XG4gICAgICAgICAgZGVmYXVsdFJlc291cmNlc0ZvclJ1bm5hYmxlKHN1aXRlLmlkLCBzdWl0ZS5wYXJlbnRTdWl0ZS5pZCk7XG4gICAgICAgICAgcmVwb3J0ZXIuc3VpdGVTdGFydGVkKHN1aXRlLnJlc3VsdCwgbmV4dCk7XG4gICAgICAgICAgc3VpdGUuc3RhcnRUaW1lcigpO1xuICAgICAgICB9LFxuICAgICAgICBub2RlQ29tcGxldGU6IGZ1bmN0aW9uKHN1aXRlLCByZXN1bHQsIG5leHQpIHtcbiAgICAgICAgICBpZiAoc3VpdGUgIT09IGN1cnJlbnRTdWl0ZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyaWVkIHRvIGNvbXBsZXRlIHRoZSB3cm9uZyBzdWl0ZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNsZWFyUmVzb3VyY2VzRm9yUnVubmFibGUoc3VpdGUuaWQpO1xuICAgICAgICAgIGN1cnJlbnRseUV4ZWN1dGluZ1N1aXRlcy5wb3AoKTtcblxuICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZmFpbGVkJykge1xuICAgICAgICAgICAgaGFzRmFpbHVyZXMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdWl0ZS5lbmRUaW1lcigpO1xuXG4gICAgICAgICAgaWYgKHN1aXRlLmhhZEJlZm9yZUFsbEZhaWx1cmUpIHtcbiAgICAgICAgICAgIHJlcG9ydENoaWxkcmVuT2ZCZWZvcmVBbGxGYWlsdXJlKHN1aXRlKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXBvcnRlci5zdWl0ZURvbmUocmVzdWx0LCBuZXh0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXBvcnRlci5zdWl0ZURvbmUocmVzdWx0LCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9yZGVyQ2hpbGRyZW46IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gb3JkZXIuc29ydChub2RlLmNoaWxkcmVuKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXhjbHVkZU5vZGU6IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICAgICAgICByZXR1cm4gIWNvbmZpZy5zcGVjRmlsdGVyKHNwZWMpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFwcm9jZXNzb3IucHJvY2Vzc1RyZWUoKS52YWxpZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgb3JkZXI6IHdvdWxkIGNhdXNlIGEgYmVmb3JlQWxsIG9yIGFmdGVyQWxsIHRvIGJlIHJ1biBtdWx0aXBsZSB0aW1lcydcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGphc21pbmVUaW1lciA9IG5ldyBqJC5UaW1lcigpO1xuICAgICAgamFzbWluZVRpbWVyLnN0YXJ0KCk7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgIHJ1bkFsbChmdW5jdGlvbihqYXNtaW5lRG9uZUluZm8pIHtcbiAgICAgICAgICBpZiAob25Db21wbGV0ZSkge1xuICAgICAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc29sdmUoamFzbWluZURvbmVJbmZvKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gcnVuQWxsKGRvbmUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZm9ybWF0aW9uIHBhc3NlZCB0byB0aGUge0BsaW5rIFJlcG9ydGVyI2phc21pbmVTdGFydGVkfSBldmVudC5cbiAgICAgICAgICogQHR5cGVkZWYgSmFzbWluZVN0YXJ0ZWRJbmZvXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7SW50fSB0b3RhbFNwZWNzRGVmaW5lZCAtIFRoZSB0b3RhbCBudW1iZXIgb2Ygc3BlY3MgZGVmaW5lZCBpbiB0aGlzIHN1aXRlLlxuICAgICAgICAgKiBAcHJvcGVydHkge09yZGVyfSBvcmRlciAtIEluZm9ybWF0aW9uIGFib3V0IHRoZSBvcmRlcmluZyAocmFuZG9tIG9yIG5vdCkgb2YgdGhpcyBleGVjdXRpb24gb2YgdGhlIHN1aXRlLlxuICAgICAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgICAgICovXG4gICAgICAgIHJlcG9ydGVyLmphc21pbmVTdGFydGVkKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRvdGFsU3BlY3NEZWZpbmVkOiB0b3RhbFNwZWNzRGVmaW5lZCxcbiAgICAgICAgICAgIG9yZGVyOiBvcmRlclxuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjdXJyZW50bHlFeGVjdXRpbmdTdWl0ZXMucHVzaCh0b3BTdWl0ZSk7XG5cbiAgICAgICAgICAgIHByb2Nlc3Nvci5leGVjdXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAoYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvcFN1aXRlLmhhZEJlZm9yZUFsbEZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IHJlcG9ydENoaWxkcmVuT2ZCZWZvcmVBbGxGYWlsdXJlKHRvcFN1aXRlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjbGVhclJlc291cmNlc0ZvclJ1bm5hYmxlKHRvcFN1aXRlLmlkKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlFeGVjdXRpbmdTdWl0ZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgdmFyIG92ZXJhbGxTdGF0dXMsIGluY29tcGxldGVSZWFzb247XG5cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICBoYXNGYWlsdXJlcyB8fFxuICAgICAgICAgICAgICAgICAgdG9wU3VpdGUucmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9ucy5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBvdmVyYWxsU3RhdHVzID0gJ2ZhaWxlZCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmb2N1c2VkUnVubmFibGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIG92ZXJhbGxTdGF0dXMgPSAnaW5jb21wbGV0ZSc7XG4gICAgICAgICAgICAgICAgICBpbmNvbXBsZXRlUmVhc29uID0gJ2ZpdCgpIG9yIGZkZXNjcmliZSgpIHdhcyBmb3VuZCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b3RhbFNwZWNzRGVmaW5lZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgb3ZlcmFsbFN0YXR1cyA9ICdpbmNvbXBsZXRlJztcbiAgICAgICAgICAgICAgICAgIGluY29tcGxldGVSZWFzb24gPSAnTm8gc3BlY3MgZm91bmQnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBvdmVyYWxsU3RhdHVzID0gJ3Bhc3NlZCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSW5mb3JtYXRpb24gcGFzc2VkIHRvIHRoZSB7QGxpbmsgUmVwb3J0ZXIjamFzbWluZURvbmV9IGV2ZW50LlxuICAgICAgICAgICAgICAgICAqIEB0eXBlZGVmIEphc21pbmVEb25lSW5mb1xuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T3ZlcmFsbFN0YXR1c30gb3ZlcmFsbFN0YXR1cyAtIFRoZSBvdmVyYWxsIHJlc3VsdCBvZiB0aGUgc3VpdGU6ICdwYXNzZWQnLCAnZmFpbGVkJywgb3IgJ2luY29tcGxldGUnLlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7SW50fSB0b3RhbFRpbWUgLSBUaGUgdG90YWwgdGltZSAoaW4gbXMpIHRoYXQgaXQgdG9vayB0byBleGVjdXRlIHRoZSBzdWl0ZVxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7SW5jb21wbGV0ZVJlYXNvbn0gaW5jb21wbGV0ZVJlYXNvbiAtIEV4cGxhbmF0aW9uIG9mIHdoeSB0aGUgc3VpdGUgd2FzIGluY29tcGxldGUuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtPcmRlcn0gb3JkZXIgLSBJbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JkZXJpbmcgKHJhbmRvbSBvciBub3QpIG9mIHRoaXMgZXhlY3V0aW9uIG9mIHRoZSBzdWl0ZS5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0V4cGVjdGF0aW9uW119IGZhaWxlZEV4cGVjdGF0aW9ucyAtIExpc3Qgb2YgZXhwZWN0YXRpb25zIHRoYXQgZmFpbGVkIGluIGFuIHtAbGluayBhZnRlckFsbH0gYXQgdGhlIGdsb2JhbCBsZXZlbC5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0V4cGVjdGF0aW9uW119IGRlcHJlY2F0aW9uV2FybmluZ3MgLSBMaXN0IG9mIGRlcHJlY2F0aW9uIHdhcm5pbmdzIHRoYXQgb2NjdXJyZWQgYXQgdGhlIGdsb2JhbCBsZXZlbC5cbiAgICAgICAgICAgICAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjb25zdCBqYXNtaW5lRG9uZUluZm8gPSB7XG4gICAgICAgICAgICAgICAgICBvdmVyYWxsU3RhdHVzOiBvdmVyYWxsU3RhdHVzLFxuICAgICAgICAgICAgICAgICAgdG90YWxUaW1lOiBqYXNtaW5lVGltZXIuZWxhcHNlZCgpLFxuICAgICAgICAgICAgICAgICAgaW5jb21wbGV0ZVJlYXNvbjogaW5jb21wbGV0ZVJlYXNvbixcbiAgICAgICAgICAgICAgICAgIG9yZGVyOiBvcmRlcixcbiAgICAgICAgICAgICAgICAgIGZhaWxlZEV4cGVjdGF0aW9uczogdG9wU3VpdGUucmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9ucyxcbiAgICAgICAgICAgICAgICAgIGRlcHJlY2F0aW9uV2FybmluZ3M6IHRvcFN1aXRlLnJlc3VsdC5kZXByZWNhdGlvbldhcm5pbmdzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXBvcnRlci5qYXNtaW5lRG9uZShqYXNtaW5lRG9uZUluZm8sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgZG9uZShqYXNtaW5lRG9uZUluZm8pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBhc3luYyBmdW5jdGlvbiByZXBvcnRDaGlsZHJlbk9mQmVmb3JlQWxsRmFpbHVyZShzdWl0ZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHN1aXRlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgaiQuU3VpdGUpIHtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgcmVwb3J0ZXIuc3VpdGVTdGFydGVkKGNoaWxkLnJlc3VsdCwgcmVzb2x2ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJlcG9ydENoaWxkcmVuT2ZCZWZvcmVBbGxGYWlsdXJlKGNoaWxkKTtcblxuICAgICAgICAgICAgLy8gTWFya2luZyB0aGUgc3VpdGUgcGFzc2VkIGlzIGNvbnNpc3RlbnQgd2l0aCBob3cgc3VpdGVzIHRoYXRcbiAgICAgICAgICAgIC8vIGNvbnRhaW4gZmFpbGVkIHNwZWNzIGJ1dCBubyBzdWl0ZS1sZXZlbCBmYWlsdXJlcyBhcmUgcmVwb3J0ZWQuXG4gICAgICAgICAgICBjaGlsZC5yZXN1bHQuc3RhdHVzID0gJ3Bhc3NlZCc7XG5cbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgcmVwb3J0ZXIuc3VpdGVEb25lKGNoaWxkLnJlc3VsdCwgcmVzb2x2ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLyogYSBzcGVjICovXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICAgIHJlcG9ydGVyLnNwZWNTdGFydGVkKGNoaWxkLnJlc3VsdCwgcmVzb2x2ZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2hpbGQuYWRkRXhwZWN0YXRpb25SZXN1bHQoXG4gICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcGFzc2VkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgICAgICAgJ05vdCBydW4gYmVjYXVzZSBhIGJlZm9yZUFsbCBmdW5jdGlvbiBmYWlsZWQuIFRoZSAnICtcbiAgICAgICAgICAgICAgICAgICdiZWZvcmVBbGwgZmFpbHVyZSB3aWxsIGJlIHJlcG9ydGVkIG9uIHRoZSBzdWl0ZSB0aGF0ICcgK1xuICAgICAgICAgICAgICAgICAgJ2NhdXNlZCBpdC4nXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjaGlsZC5yZXN1bHQuc3RhdHVzID0gJ2ZhaWxlZCc7XG5cbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgcmVwb3J0ZXIuc3BlY0RvbmUoY2hpbGQucmVzdWx0LCByZXNvbHZlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBjdXN0b20gcmVwb3J0ZXIgdG8gdGhlIEphc21pbmUgZW52aXJvbm1lbnQuXG4gICAgICogQG5hbWUgRW52I2FkZFJlcG9ydGVyXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtSZXBvcnRlcn0gcmVwb3J0ZXJUb0FkZCBUaGUgcmVwb3J0ZXIgdG8gYmUgYWRkZWQuXG4gICAgICogQHNlZSBjdXN0b21fcmVwb3J0ZXJcbiAgICAgKi9cbiAgICB0aGlzLmFkZFJlcG9ydGVyID0gZnVuY3Rpb24ocmVwb3J0ZXJUb0FkZCkge1xuICAgICAgcmVwb3J0ZXIuYWRkUmVwb3J0ZXIocmVwb3J0ZXJUb0FkZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGUgYSBmYWxsYmFjayByZXBvcnRlciBpZiBubyBvdGhlciByZXBvcnRlcnMgaGF2ZSBiZWVuIHNwZWNpZmllZC5cbiAgICAgKiBAbmFtZSBFbnYjcHJvdmlkZUZhbGxiYWNrUmVwb3J0ZXJcbiAgICAgKiBAc2luY2UgMi41LjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1JlcG9ydGVyfSByZXBvcnRlclRvQWRkIFRoZSByZXBvcnRlclxuICAgICAqIEBzZWUgY3VzdG9tX3JlcG9ydGVyXG4gICAgICovXG4gICAgdGhpcy5wcm92aWRlRmFsbGJhY2tSZXBvcnRlciA9IGZ1bmN0aW9uKHJlcG9ydGVyVG9BZGQpIHtcbiAgICAgIHJlcG9ydGVyLnByb3ZpZGVGYWxsYmFja1JlcG9ydGVyKHJlcG9ydGVyVG9BZGQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgcmVnaXN0ZXJlZCByZXBvcnRlcnNcbiAgICAgKiBAbmFtZSBFbnYjY2xlYXJSZXBvcnRlcnNcbiAgICAgKiBAc2luY2UgMi41LjJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICB0aGlzLmNsZWFyUmVwb3J0ZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXBvcnRlci5jbGVhclJlcG9ydGVycygpO1xuICAgIH07XG5cbiAgICB2YXIgc3B5RmFjdG9yeSA9IG5ldyBqJC5TcHlGYWN0b3J5KFxuICAgICAgZnVuY3Rpb24gZ2V0Q3VzdG9tU3RyYXRlZ2llcygpIHtcbiAgICAgICAgdmFyIHJ1bm5hYmxlID0gY3VycmVudFJ1bm5hYmxlKCk7XG5cbiAgICAgICAgaWYgKHJ1bm5hYmxlKSB7XG4gICAgICAgICAgcmV0dXJuIHJ1bm5hYmxlUmVzb3VyY2VzW3J1bm5hYmxlLmlkXS5jdXN0b21TcHlTdHJhdGVnaWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uIGdldERlZmF1bHRTdHJhdGVneUZuKCkge1xuICAgICAgICB2YXIgcnVubmFibGUgPSBjdXJyZW50UnVubmFibGUoKTtcblxuICAgICAgICBpZiAocnVubmFibGUpIHtcbiAgICAgICAgICByZXR1cm4gcnVubmFibGVSZXNvdXJjZXNbcnVubmFibGUuaWRdLmRlZmF1bHRTdHJhdGVneUZuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0sXG4gICAgICBtYWtlTWF0Y2hlcnNVdGlsXG4gICAgKTtcblxuICAgIHZhciBzcHlSZWdpc3RyeSA9IG5ldyBqJC5TcHlSZWdpc3RyeSh7XG4gICAgICBjdXJyZW50U3BpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIWN1cnJlbnRSdW5uYWJsZSgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1NwaWVzIG11c3QgYmUgY3JlYXRlZCBpbiBhIGJlZm9yZSBmdW5jdGlvbiBvciBhIHNwZWMnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVubmFibGVSZXNvdXJjZXNbY3VycmVudFJ1bm5hYmxlKCkuaWRdLnNwaWVzO1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZVNweTogZnVuY3Rpb24obmFtZSwgb3JpZ2luYWxGbikge1xuICAgICAgICByZXR1cm4gc2VsZi5jcmVhdGVTcHkobmFtZSwgb3JpZ2luYWxGbik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIHdoZXRoZXIgSmFzbWluZSBzaG91bGQgYWxsb3cgdGhlIHNhbWUgZnVuY3Rpb24gdG8gYmUgc3BpZWQgb25cbiAgICAgKiBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGV4ZWN1dGlvbiBvZiBhIHNwZWMuIEJ5IGRlZmF1bHQsIHNweWluZyBvblxuICAgICAqIGEgZnVuY3Rpb24gdGhhdCBpcyBhbHJlYWR5IGEgc3B5IHdpbGwgY2F1c2UgYW4gZXJyb3IuXG4gICAgICogQG5hbWUgRW52I2FsbG93UmVzcHlcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAc2luY2UgMi41LjBcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFsbG93IFdoZXRoZXIgdG8gYWxsb3cgcmVzcHlpbmdcbiAgICAgKi9cbiAgICB0aGlzLmFsbG93UmVzcHkgPSBmdW5jdGlvbihhbGxvdykge1xuICAgICAgc3B5UmVnaXN0cnkuYWxsb3dSZXNweShhbGxvdyk7XG4gICAgfTtcblxuICAgIHRoaXMuc3B5T24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzcHlSZWdpc3RyeS5zcHlPbi5hcHBseShzcHlSZWdpc3RyeSwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zcHlPblByb3BlcnR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3B5UmVnaXN0cnkuc3B5T25Qcm9wZXJ0eS5hcHBseShzcHlSZWdpc3RyeSwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zcHlPbkFsbEZ1bmN0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNweVJlZ2lzdHJ5LnNweU9uQWxsRnVuY3Rpb25zLmFwcGx5KHNweVJlZ2lzdHJ5LCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICB0aGlzLmNyZWF0ZVNweSA9IGZ1bmN0aW9uKG5hbWUsIG9yaWdpbmFsRm4pIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIGokLmlzRnVuY3Rpb25fKG5hbWUpKSB7XG4gICAgICAgIG9yaWdpbmFsRm4gPSBuYW1lO1xuICAgICAgICBuYW1lID0gb3JpZ2luYWxGbi5uYW1lO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3B5RmFjdG9yeS5jcmVhdGVTcHkobmFtZSwgb3JpZ2luYWxGbik7XG4gICAgfTtcblxuICAgIHRoaXMuY3JlYXRlU3B5T2JqID0gZnVuY3Rpb24oYmFzZU5hbWUsIG1ldGhvZE5hbWVzLCBwcm9wZXJ0eU5hbWVzKSB7XG4gICAgICByZXR1cm4gc3B5RmFjdG9yeS5jcmVhdGVTcHlPYmooYmFzZU5hbWUsIG1ldGhvZE5hbWVzLCBwcm9wZXJ0eU5hbWVzKTtcbiAgICB9O1xuXG4gICAgdmFyIGVuc3VyZUlzRnVuY3Rpb24gPSBmdW5jdGlvbihmbiwgY2FsbGVyKSB7XG4gICAgICBpZiAoIWokLmlzRnVuY3Rpb25fKGZuKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgY2FsbGVyICsgJyBleHBlY3RzIGEgZnVuY3Rpb24gYXJndW1lbnQ7IHJlY2VpdmVkICcgKyBqJC5nZXRUeXBlXyhmbilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGVuc3VyZUlzRnVuY3Rpb25PckFzeW5jID0gZnVuY3Rpb24oZm4sIGNhbGxlcikge1xuICAgICAgaWYgKCFqJC5pc0Z1bmN0aW9uXyhmbikgJiYgIWokLmlzQXN5bmNGdW5jdGlvbl8oZm4pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBjYWxsZXIgKyAnIGV4cGVjdHMgYSBmdW5jdGlvbiBhcmd1bWVudDsgcmVjZWl2ZWQgJyArIGokLmdldFR5cGVfKGZuKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBlbnN1cmVJc05vdE5lc3RlZChtZXRob2QpIHtcbiAgICAgIHZhciBydW5uYWJsZSA9IGN1cnJlbnRSdW5uYWJsZSgpO1xuICAgICAgaWYgKHJ1bm5hYmxlICE9PSBudWxsICYmIHJ1bm5hYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiJ1wiICsgbWV0aG9kICsgXCInIHNob3VsZCBvbmx5IGJlIHVzZWQgaW4gJ2Rlc2NyaWJlJyBmdW5jdGlvblwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHN1aXRlRmFjdG9yeSA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgICB2YXIgc3VpdGUgPSBuZXcgaiQuU3VpdGUoe1xuICAgICAgICBpZDogZ2V0TmV4dFN1aXRlSWQoKSxcbiAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuICAgICAgICBwYXJlbnRTdWl0ZTogY3VycmVudERlY2xhcmF0aW9uU3VpdGUsXG4gICAgICAgIHRpbWVyOiBuZXcgaiQuVGltZXIoKSxcbiAgICAgICAgZXhwZWN0YXRpb25GYWN0b3J5OiBleHBlY3RhdGlvbkZhY3RvcnksXG4gICAgICAgIGFzeW5jRXhwZWN0YXRpb25GYWN0b3J5OiBzdWl0ZUFzeW5jRXhwZWN0YXRpb25GYWN0b3J5LFxuICAgICAgICBleHBlY3RhdGlvblJlc3VsdEZhY3Rvcnk6IGV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeSxcbiAgICAgICAgdGhyb3dPbkV4cGVjdGF0aW9uRmFpbHVyZTogY29uZmlnLnN0b3BTcGVjT25FeHBlY3RhdGlvbkZhaWx1cmUsXG4gICAgICAgIGF1dG9DbGVhbkNsb3N1cmVzOiBjb25maWcuYXV0b0NsZWFuQ2xvc3VyZXMsXG4gICAgICAgIG9uTGF0ZUVycm9yOiByZWNvcmRMYXRlRXJyb3JcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gc3VpdGU7XG4gICAgfTtcblxuICAgIHRoaXMuZGVzY3JpYmUgPSBmdW5jdGlvbihkZXNjcmlwdGlvbiwgc3BlY0RlZmluaXRpb25zKSB7XG4gICAgICBlbnN1cmVJc05vdE5lc3RlZCgnZGVzY3JpYmUnKTtcbiAgICAgIGVuc3VyZUlzRnVuY3Rpb24oc3BlY0RlZmluaXRpb25zLCAnZGVzY3JpYmUnKTtcbiAgICAgIHZhciBzdWl0ZSA9IHN1aXRlRmFjdG9yeShkZXNjcmlwdGlvbik7XG4gICAgICBpZiAoc3BlY0RlZmluaXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZXNjcmliZSBkb2VzIG5vdCBleHBlY3QgYW55IGFyZ3VtZW50cycpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnREZWNsYXJhdGlvblN1aXRlLm1hcmtlZEV4Y2x1ZGluZykge1xuICAgICAgICBzdWl0ZS5leGNsdWRlKCk7XG4gICAgICB9XG4gICAgICBhZGRTcGVjc1RvU3VpdGUoc3VpdGUsIHNwZWNEZWZpbml0aW9ucyk7XG4gICAgICBpZiAoc3VpdGUucGFyZW50U3VpdGUgJiYgIXN1aXRlLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rlc2NyaWJlIHdpdGggbm8gY2hpbGRyZW4gKGRlc2NyaWJlKCkgb3IgaXQoKSknKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdWl0ZS5tZXRhZGF0YTtcbiAgICB9O1xuXG4gICAgdGhpcy54ZGVzY3JpYmUgPSBmdW5jdGlvbihkZXNjcmlwdGlvbiwgc3BlY0RlZmluaXRpb25zKSB7XG4gICAgICBlbnN1cmVJc05vdE5lc3RlZCgneGRlc2NyaWJlJyk7XG4gICAgICBlbnN1cmVJc0Z1bmN0aW9uKHNwZWNEZWZpbml0aW9ucywgJ3hkZXNjcmliZScpO1xuICAgICAgdmFyIHN1aXRlID0gc3VpdGVGYWN0b3J5KGRlc2NyaXB0aW9uKTtcbiAgICAgIHN1aXRlLmV4Y2x1ZGUoKTtcbiAgICAgIGFkZFNwZWNzVG9TdWl0ZShzdWl0ZSwgc3BlY0RlZmluaXRpb25zKTtcbiAgICAgIHJldHVybiBzdWl0ZS5tZXRhZGF0YTtcbiAgICB9O1xuXG4gICAgdmFyIGZvY3VzZWRSdW5uYWJsZXMgPSBbXTtcblxuICAgIHRoaXMuZmRlc2NyaWJlID0gZnVuY3Rpb24oZGVzY3JpcHRpb24sIHNwZWNEZWZpbml0aW9ucykge1xuICAgICAgZW5zdXJlSXNOb3ROZXN0ZWQoJ2ZkZXNjcmliZScpO1xuICAgICAgZW5zdXJlSXNGdW5jdGlvbihzcGVjRGVmaW5pdGlvbnMsICdmZGVzY3JpYmUnKTtcbiAgICAgIHZhciBzdWl0ZSA9IHN1aXRlRmFjdG9yeShkZXNjcmlwdGlvbik7XG4gICAgICBzdWl0ZS5pc0ZvY3VzZWQgPSB0cnVlO1xuXG4gICAgICBmb2N1c2VkUnVubmFibGVzLnB1c2goc3VpdGUuaWQpO1xuICAgICAgdW5mb2N1c0FuY2VzdG9yKCk7XG4gICAgICBhZGRTcGVjc1RvU3VpdGUoc3VpdGUsIHNwZWNEZWZpbml0aW9ucyk7XG5cbiAgICAgIHJldHVybiBzdWl0ZS5tZXRhZGF0YTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gYWRkU3BlY3NUb1N1aXRlKHN1aXRlLCBzcGVjRGVmaW5pdGlvbnMpIHtcbiAgICAgIHZhciBwYXJlbnRTdWl0ZSA9IGN1cnJlbnREZWNsYXJhdGlvblN1aXRlO1xuICAgICAgcGFyZW50U3VpdGUuYWRkQ2hpbGQoc3VpdGUpO1xuICAgICAgY3VycmVudERlY2xhcmF0aW9uU3VpdGUgPSBzdWl0ZTtcblxuICAgICAgdmFyIGRlY2xhcmF0aW9uRXJyb3IgPSBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3BlY0RlZmluaXRpb25zKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGRlY2xhcmF0aW9uRXJyb3IgPSBlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVjbGFyYXRpb25FcnJvcikge1xuICAgICAgICBzdWl0ZS5vbkV4Y2VwdGlvbihkZWNsYXJhdGlvbkVycm9yKTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudERlY2xhcmF0aW9uU3VpdGUgPSBwYXJlbnRTdWl0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kRm9jdXNlZEFuY2VzdG9yKHN1aXRlKSB7XG4gICAgICB3aGlsZSAoc3VpdGUpIHtcbiAgICAgICAgaWYgKHN1aXRlLmlzRm9jdXNlZCkge1xuICAgICAgICAgIHJldHVybiBzdWl0ZS5pZDtcbiAgICAgICAgfVxuICAgICAgICBzdWl0ZSA9IHN1aXRlLnBhcmVudFN1aXRlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bmZvY3VzQW5jZXN0b3IoKSB7XG4gICAgICB2YXIgZm9jdXNlZEFuY2VzdG9yID0gZmluZEZvY3VzZWRBbmNlc3RvcihjdXJyZW50RGVjbGFyYXRpb25TdWl0ZSk7XG4gICAgICBpZiAoZm9jdXNlZEFuY2VzdG9yKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9jdXNlZFJ1bm5hYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChmb2N1c2VkUnVubmFibGVzW2ldID09PSBmb2N1c2VkQW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGZvY3VzZWRSdW5uYWJsZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNwZWNGYWN0b3J5ID0gZnVuY3Rpb24oZGVzY3JpcHRpb24sIGZuLCBzdWl0ZSwgdGltZW91dCkge1xuICAgICAgdG90YWxTcGVjc0RlZmluZWQrKztcbiAgICAgIHZhciBzcGVjID0gbmV3IGokLlNwZWMoe1xuICAgICAgICBpZDogZ2V0TmV4dFNwZWNJZCgpLFxuICAgICAgICBiZWZvcmVBbmRBZnRlckZuczogYmVmb3JlQW5kQWZ0ZXJGbnMoc3VpdGUpLFxuICAgICAgICBleHBlY3RhdGlvbkZhY3Rvcnk6IGV4cGVjdGF0aW9uRmFjdG9yeSxcbiAgICAgICAgYXN5bmNFeHBlY3RhdGlvbkZhY3Rvcnk6IHNwZWNBc3luY0V4cGVjdGF0aW9uRmFjdG9yeSxcbiAgICAgICAgb25MYXRlRXJyb3I6IHJlY29yZExhdGVFcnJvcixcbiAgICAgICAgcmVzdWx0Q2FsbGJhY2s6IHNwZWNSZXN1bHRDYWxsYmFjayxcbiAgICAgICAgZ2V0U3BlY05hbWU6IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0U3BlY05hbWUoc3BlYywgc3VpdGUpO1xuICAgICAgICB9LFxuICAgICAgICBvblN0YXJ0OiBzcGVjU3RhcnRlZCxcbiAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuICAgICAgICBleHBlY3RhdGlvblJlc3VsdEZhY3Rvcnk6IGV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeSxcbiAgICAgICAgcXVldWVSdW5uZXJGYWN0b3J5OiBxdWV1ZVJ1bm5lckZhY3RvcnksXG4gICAgICAgIHVzZXJDb250ZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gc3VpdGUuY2xvbmVkU2hhcmVkVXNlckNvbnRleHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcXVldWVhYmxlRm46IHtcbiAgICAgICAgICBmbjogZm4sXG4gICAgICAgICAgdGltZW91dDogdGltZW91dCB8fCAwXG4gICAgICAgIH0sXG4gICAgICAgIHRocm93T25FeHBlY3RhdGlvbkZhaWx1cmU6IGNvbmZpZy5zdG9wU3BlY09uRXhwZWN0YXRpb25GYWlsdXJlLFxuICAgICAgICBhdXRvQ2xlYW5DbG9zdXJlczogY29uZmlnLmF1dG9DbGVhbkNsb3N1cmVzLFxuICAgICAgICB0aW1lcjogbmV3IGokLlRpbWVyKClcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNwZWM7XG5cbiAgICAgIGZ1bmN0aW9uIHNwZWNSZXN1bHRDYWxsYmFjayhyZXN1bHQsIG5leHQpIHtcbiAgICAgICAgY2xlYXJSZXNvdXJjZXNGb3JSdW5uYWJsZShzcGVjLmlkKTtcbiAgICAgICAgY3VycmVudFNwZWMgPSBudWxsO1xuXG4gICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZmFpbGVkJykge1xuICAgICAgICAgIGhhc0ZhaWx1cmVzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcG9ydGVyLnNwZWNEb25lKHJlc3VsdCwgbmV4dCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNwZWNTdGFydGVkKHNwZWMsIG5leHQpIHtcbiAgICAgICAgY3VycmVudFNwZWMgPSBzcGVjO1xuICAgICAgICBkZWZhdWx0UmVzb3VyY2VzRm9yUnVubmFibGUoc3BlYy5pZCwgc3VpdGUuaWQpO1xuICAgICAgICByZXBvcnRlci5zcGVjU3RhcnRlZChzcGVjLnJlc3VsdCwgbmV4dCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuaXRfID0gZnVuY3Rpb24oZGVzY3JpcHRpb24sIGZuLCB0aW1lb3V0KSB7XG4gICAgICBlbnN1cmVJc05vdE5lc3RlZCgnaXQnKTtcbiAgICAgIC8vIGl0KCkgc29tZXRpbWVzIGRvZXNuJ3QgaGF2ZSBhIGZuIGFyZ3VtZW50LCBzbyBvbmx5IGNoZWNrIHRoZSB0eXBlIGlmXG4gICAgICAvLyBpdCdzIGdpdmVuLlxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBmbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZW5zdXJlSXNGdW5jdGlvbk9yQXN5bmMoZm4sICdpdCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGltZW91dCkge1xuICAgICAgICBqJC51dGlsLnZhbGlkYXRlVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNwZWMgPSBzcGVjRmFjdG9yeShkZXNjcmlwdGlvbiwgZm4sIGN1cnJlbnREZWNsYXJhdGlvblN1aXRlLCB0aW1lb3V0KTtcbiAgICAgIGlmIChjdXJyZW50RGVjbGFyYXRpb25TdWl0ZS5tYXJrZWRFeGNsdWRpbmcpIHtcbiAgICAgICAgc3BlYy5leGNsdWRlKCk7XG4gICAgICB9XG4gICAgICBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZS5hZGRDaGlsZChzcGVjKTtcblxuICAgICAgcmV0dXJuIHNwZWM7XG4gICAgfTtcblxuICAgIHRoaXMuaXQgPSBmdW5jdGlvbihkZXNjcmlwdGlvbiwgZm4sIHRpbWVvdXQpIHtcbiAgICAgIGNvbnN0IHNwZWMgPSB0aGlzLml0XyhkZXNjcmlwdGlvbiwgZm4sIHRpbWVvdXQpO1xuICAgICAgcmV0dXJuIHNwZWMubWV0YWRhdGE7XG4gICAgfTtcblxuICAgIHRoaXMueGl0ID0gZnVuY3Rpb24oZGVzY3JpcHRpb24sIGZuLCB0aW1lb3V0KSB7XG4gICAgICBlbnN1cmVJc05vdE5lc3RlZCgneGl0Jyk7XG4gICAgICAvLyB4aXQoKSwgbGlrZSBpdCgpLCBkb2Vzbid0IGFsd2F5cyBoYXZlIGEgZm4gYXJndW1lbnQsIHNvIG9ubHkgY2hlY2sgdGhlXG4gICAgICAvLyB0eXBlIHdoZW4gbmVlZGVkLlxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBmbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZW5zdXJlSXNGdW5jdGlvbk9yQXN5bmMoZm4sICd4aXQnKTtcbiAgICAgIH1cbiAgICAgIHZhciBzcGVjID0gdGhpcy5pdF8uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHNwZWMuZXhjbHVkZSgnVGVtcG9yYXJpbHkgZGlzYWJsZWQgd2l0aCB4aXQnKTtcbiAgICAgIHJldHVybiBzcGVjLm1ldGFkYXRhO1xuICAgIH07XG5cbiAgICB0aGlzLmZpdCA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uLCBmbiwgdGltZW91dCkge1xuICAgICAgZW5zdXJlSXNOb3ROZXN0ZWQoJ2ZpdCcpO1xuICAgICAgZW5zdXJlSXNGdW5jdGlvbk9yQXN5bmMoZm4sICdmaXQnKTtcblxuICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgaiQudXRpbC52YWxpZGF0ZVRpbWVvdXQodGltZW91dCk7XG4gICAgICB9XG4gICAgICB2YXIgc3BlYyA9IHNwZWNGYWN0b3J5KGRlc2NyaXB0aW9uLCBmbiwgY3VycmVudERlY2xhcmF0aW9uU3VpdGUsIHRpbWVvdXQpO1xuICAgICAgY3VycmVudERlY2xhcmF0aW9uU3VpdGUuYWRkQ2hpbGQoc3BlYyk7XG4gICAgICBmb2N1c2VkUnVubmFibGVzLnB1c2goc3BlYy5pZCk7XG4gICAgICB1bmZvY3VzQW5jZXN0b3IoKTtcbiAgICAgIHJldHVybiBzcGVjLm1ldGFkYXRhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgdXNlci1kZWZpbmVkIHByb3BlcnR5IHRoYXQgd2lsbCBiZSBwcm92aWRlZCB0byByZXBvcnRlcnMgYXMgcGFydCBvZiB0aGUgcHJvcGVydGllcyBmaWVsZCBvZiB7QGxpbmsgU3BlY1Jlc3VsdH1cbiAgICAgKiBAbmFtZSBFbnYjc2V0U3BlY1Byb3BlcnR5XG4gICAgICogQHNpbmNlIDMuNi4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKi9cbiAgICB0aGlzLnNldFNwZWNQcm9wZXJ0eSA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICghY3VycmVudFJ1bm5hYmxlKCkgfHwgY3VycmVudFJ1bm5hYmxlKCkgPT0gY3VycmVudFN1aXRlKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiJ3NldFNwZWNQcm9wZXJ0eScgd2FzIHVzZWQgd2hlbiB0aGVyZSB3YXMgbm8gY3VycmVudCBzcGVjXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRSdW5uYWJsZSgpLnNldFNwZWNQcm9wZXJ0eShrZXksIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIHVzZXItZGVmaW5lZCBwcm9wZXJ0eSB0aGF0IHdpbGwgYmUgcHJvdmlkZWQgdG8gcmVwb3J0ZXJzIGFzIHBhcnQgb2YgdGhlIHByb3BlcnRpZXMgZmllbGQgb2Yge0BsaW5rIFN1aXRlUmVzdWx0fVxuICAgICAqIEBuYW1lIEVudiNzZXRTdWl0ZVByb3BlcnR5XG4gICAgICogQHNpbmNlIDMuNi4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKi9cbiAgICB0aGlzLnNldFN1aXRlUHJvcGVydHkgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoIWN1cnJlbnRTdWl0ZSgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIidzZXRTdWl0ZVByb3BlcnR5JyB3YXMgdXNlZCB3aGVuIHRoZXJlIHdhcyBubyBjdXJyZW50IHN1aXRlXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRTdWl0ZSgpLnNldFN1aXRlUHJvcGVydHkoa2V5LCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIHRoaXMuZGVidWdMb2cgPSBmdW5jdGlvbihtc2cpIHtcbiAgICAgIHZhciBtYXliZVNwZWMgPSBjdXJyZW50UnVubmFibGUoKTtcblxuICAgICAgaWYgKCFtYXliZVNwZWMgfHwgIW1heWJlU3BlYy5kZWJ1Z0xvZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCInZGVidWdMb2cnIHdhcyBjYWxsZWQgd2hlbiB0aGVyZSB3YXMgbm8gY3VycmVudCBzcGVjXCIpO1xuICAgICAgfVxuXG4gICAgICBtYXliZVNwZWMuZGVidWdMb2cobXNnKTtcbiAgICB9O1xuXG4gICAgdGhpcy5leHBlY3QgPSBmdW5jdGlvbihhY3R1YWwpIHtcbiAgICAgIGlmICghY3VycmVudFJ1bm5hYmxlKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiJ2V4cGVjdCcgd2FzIHVzZWQgd2hlbiB0aGVyZSB3YXMgbm8gY3VycmVudCBzcGVjLCB0aGlzIGNvdWxkIGJlIGJlY2F1c2UgYW4gYXN5bmNocm9ub3VzIHRlc3QgdGltZWQgb3V0XCJcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN1cnJlbnRSdW5uYWJsZSgpLmV4cGVjdChhY3R1YWwpO1xuICAgIH07XG5cbiAgICB0aGlzLmV4cGVjdEFzeW5jID0gZnVuY3Rpb24oYWN0dWFsKSB7XG4gICAgICBpZiAoIWN1cnJlbnRSdW5uYWJsZSgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIidleHBlY3RBc3luYycgd2FzIHVzZWQgd2hlbiB0aGVyZSB3YXMgbm8gY3VycmVudCBzcGVjLCB0aGlzIGNvdWxkIGJlIGJlY2F1c2UgYW4gYXN5bmNocm9ub3VzIHRlc3QgdGltZWQgb3V0XCJcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN1cnJlbnRSdW5uYWJsZSgpLmV4cGVjdEFzeW5jKGFjdHVhbCk7XG4gICAgfTtcblxuICAgIHRoaXMuYmVmb3JlRWFjaCA9IGZ1bmN0aW9uKGJlZm9yZUVhY2hGdW5jdGlvbiwgdGltZW91dCkge1xuICAgICAgZW5zdXJlSXNOb3ROZXN0ZWQoJ2JlZm9yZUVhY2gnKTtcbiAgICAgIGVuc3VyZUlzRnVuY3Rpb25PckFzeW5jKGJlZm9yZUVhY2hGdW5jdGlvbiwgJ2JlZm9yZUVhY2gnKTtcblxuICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgaiQudXRpbC52YWxpZGF0ZVRpbWVvdXQodGltZW91dCk7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnREZWNsYXJhdGlvblN1aXRlLmJlZm9yZUVhY2goe1xuICAgICAgICBmbjogYmVmb3JlRWFjaEZ1bmN0aW9uLFxuICAgICAgICB0aW1lb3V0OiB0aW1lb3V0IHx8IDBcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLmJlZm9yZUFsbCA9IGZ1bmN0aW9uKGJlZm9yZUFsbEZ1bmN0aW9uLCB0aW1lb3V0KSB7XG4gICAgICBlbnN1cmVJc05vdE5lc3RlZCgnYmVmb3JlQWxsJyk7XG4gICAgICBlbnN1cmVJc0Z1bmN0aW9uT3JBc3luYyhiZWZvcmVBbGxGdW5jdGlvbiwgJ2JlZm9yZUFsbCcpO1xuXG4gICAgICBpZiAodGltZW91dCkge1xuICAgICAgICBqJC51dGlsLnZhbGlkYXRlVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudERlY2xhcmF0aW9uU3VpdGUuYmVmb3JlQWxsKHtcbiAgICAgICAgZm46IGJlZm9yZUFsbEZ1bmN0aW9uLFxuICAgICAgICB0aW1lb3V0OiB0aW1lb3V0IHx8IDBcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLmFmdGVyRWFjaCA9IGZ1bmN0aW9uKGFmdGVyRWFjaEZ1bmN0aW9uLCB0aW1lb3V0KSB7XG4gICAgICBlbnN1cmVJc05vdE5lc3RlZCgnYWZ0ZXJFYWNoJyk7XG4gICAgICBlbnN1cmVJc0Z1bmN0aW9uT3JBc3luYyhhZnRlckVhY2hGdW5jdGlvbiwgJ2FmdGVyRWFjaCcpO1xuXG4gICAgICBpZiAodGltZW91dCkge1xuICAgICAgICBqJC51dGlsLnZhbGlkYXRlVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIH1cblxuICAgICAgYWZ0ZXJFYWNoRnVuY3Rpb24uaXNDbGVhbnVwID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnREZWNsYXJhdGlvblN1aXRlLmFmdGVyRWFjaCh7XG4gICAgICAgIGZuOiBhZnRlckVhY2hGdW5jdGlvbixcbiAgICAgICAgdGltZW91dDogdGltZW91dCB8fCAwXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5hZnRlckFsbCA9IGZ1bmN0aW9uKGFmdGVyQWxsRnVuY3Rpb24sIHRpbWVvdXQpIHtcbiAgICAgIGVuc3VyZUlzTm90TmVzdGVkKCdhZnRlckFsbCcpO1xuICAgICAgZW5zdXJlSXNGdW5jdGlvbk9yQXN5bmMoYWZ0ZXJBbGxGdW5jdGlvbiwgJ2FmdGVyQWxsJyk7XG5cbiAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgIGokLnV0aWwudmFsaWRhdGVUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZS5hZnRlckFsbCh7XG4gICAgICAgIGZuOiBhZnRlckFsbEZ1bmN0aW9uLFxuICAgICAgICB0aW1lb3V0OiB0aW1lb3V0IHx8IDBcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLnBlbmRpbmcgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICB2YXIgZnVsbE1lc3NhZ2UgPSBqJC5TcGVjLnBlbmRpbmdTcGVjRXhjZXB0aW9uTWVzc2FnZTtcbiAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgIGZ1bGxNZXNzYWdlICs9IG1lc3NhZ2U7XG4gICAgICB9XG4gICAgICB0aHJvdyBmdWxsTWVzc2FnZTtcbiAgICB9O1xuXG4gICAgdGhpcy5mYWlsID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgIGlmICghY3VycmVudFJ1bm5hYmxlKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiJ2ZhaWwnIHdhcyB1c2VkIHdoZW4gdGhlcmUgd2FzIG5vIGN1cnJlbnQgc3BlYywgdGhpcyBjb3VsZCBiZSBiZWNhdXNlIGFuIGFzeW5jaHJvbm91cyB0ZXN0IHRpbWVkIG91dFwiXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtZXNzYWdlID0gJ0ZhaWxlZCc7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgbWVzc2FnZSArPSAnOiAnO1xuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSkge1xuICAgICAgICAgIG1lc3NhZ2UgKz0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgfSBlbHNlIGlmIChqJC5pc1N0cmluZ18oZXJyb3IpKSB7XG4gICAgICAgICAgbWVzc2FnZSArPSBlcnJvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBwcmV0dHkgcHJpbnQgYWxsIGtpbmQgb2Ygb2JqZWN0cy4gVGhpcyBpbmNsdWRlcyBhcnJheXMuXG4gICAgICAgICAgbWVzc2FnZSArPSBtYWtlUHJldHR5UHJpbnRlcigpKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjdXJyZW50UnVubmFibGUoKS5hZGRFeHBlY3RhdGlvblJlc3VsdChmYWxzZSwge1xuICAgICAgICBtYXRjaGVyTmFtZTogJycsXG4gICAgICAgIHBhc3NlZDogZmFsc2UsXG4gICAgICAgIGV4cGVjdGVkOiAnJyxcbiAgICAgICAgYWN0dWFsOiAnJyxcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgZXJyb3I6IGVycm9yICYmIGVycm9yLm1lc3NhZ2UgPyBlcnJvciA6IG51bGxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoY29uZmlnLnN0b3BTcGVjT25FeHBlY3RhdGlvbkZhaWx1cmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmNsZWFudXBfID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoZ2xvYmFsRXJyb3JzKSB7XG4gICAgICAgIGdsb2JhbEVycm9ycy51bmluc3RhbGwoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIEVudjtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuSnNBcGlSZXBvcnRlciA9IGZ1bmN0aW9uKGokKSB7XG4gIC8qKlxuICAgKiBAbmFtZSBqc0FwaVJlcG9ydGVyXG4gICAqIEBjbGFzc2Rlc2Mge0BsaW5rIFJlcG9ydGVyfSBhZGRlZCBieSBkZWZhdWx0IGluIGBib290LmpzYCB0byByZWNvcmQgcmVzdWx0cyBmb3IgcmV0cmlldmFsIGluIGphdmFzY3JpcHQgY29kZS4gQW4gaW5zdGFuY2UgaXMgbWFkZSBhdmFpbGFibGUgYXMgYGpzQXBpUmVwb3J0ZXJgIG9uIHRoZSBnbG9iYWwgb2JqZWN0LlxuICAgKiBAY2xhc3NcbiAgICogQGhpZGVjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gSnNBcGlSZXBvcnRlcihvcHRpb25zKSB7XG4gICAgdmFyIHRpbWVyID0gb3B0aW9ucy50aW1lciB8fCBuZXcgaiQuVGltZXIoKSxcbiAgICAgIHN0YXR1cyA9ICdsb2FkZWQnO1xuXG4gICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMucnVuRGV0YWlscyA9IHt9O1xuXG4gICAgdGhpcy5qYXNtaW5lU3RhcnRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgIHN0YXR1cyA9ICdzdGFydGVkJztcbiAgICAgIHRpbWVyLnN0YXJ0KCk7XG4gICAgfTtcblxuICAgIHZhciBleGVjdXRpb25UaW1lO1xuXG4gICAgdGhpcy5qYXNtaW5lRG9uZSA9IGZ1bmN0aW9uKHJ1bkRldGFpbHMpIHtcbiAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgdGhpcy5ydW5EZXRhaWxzID0gcnVuRGV0YWlscztcbiAgICAgIGV4ZWN1dGlvblRpbWUgPSB0aW1lci5lbGFwc2VkKCk7XG4gICAgICBzdGF0dXMgPSAnZG9uZSc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBzdGF0dXMgZm9yIHRoZSBKYXNtaW5lIGVudmlyb25tZW50LlxuICAgICAqIEBuYW1lIGpzQXBpUmVwb3J0ZXIjc3RhdHVzXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAtIE9uZSBvZiBgbG9hZGVkYCwgYHN0YXJ0ZWRgLCBvciBgZG9uZWBcbiAgICAgKi9cbiAgICB0aGlzLnN0YXR1cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9O1xuXG4gICAgdmFyIHN1aXRlcyA9IFtdLFxuICAgICAgc3VpdGVzX2hhc2ggPSB7fTtcblxuICAgIHRoaXMuc3VpdGVTdGFydGVkID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICBzdWl0ZXNfaGFzaFtyZXN1bHQuaWRdID0gcmVzdWx0O1xuICAgIH07XG5cbiAgICB0aGlzLnN1aXRlRG9uZSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgc3RvcmVTdWl0ZShyZXN1bHQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHJlc3VsdHMgZm9yIGEgc2V0IG9mIHN1aXRlcy5cbiAgICAgKlxuICAgICAqIFJldHJpZXZhYmxlIGluIHNsaWNlcyBmb3IgZWFzaWVyIHNlcmlhbGl6YXRpb24uXG4gICAgICogQG5hbWUganNBcGlSZXBvcnRlciNzdWl0ZVJlc3VsdHNcbiAgICAgKiBAc2luY2UgMi4xLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBUaGUgcG9zaXRpb24gaW4gdGhlIHN1aXRlcyBsaXN0IHRvIHN0YXJ0IGZyb20uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCAtIE1heGltdW0gbnVtYmVyIG9mIHN1aXRlIHJlc3VsdHMgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm4ge1N1aXRlUmVzdWx0W119XG4gICAgICovXG4gICAgdGhpcy5zdWl0ZVJlc3VsdHMgPSBmdW5jdGlvbihpbmRleCwgbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gc3VpdGVzLnNsaWNlKGluZGV4LCBpbmRleCArIGxlbmd0aCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHN0b3JlU3VpdGUocmVzdWx0KSB7XG4gICAgICBzdWl0ZXMucHVzaChyZXN1bHQpO1xuICAgICAgc3VpdGVzX2hhc2hbcmVzdWx0LmlkXSA9IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIG9mIHRoZSBzdWl0ZXMgaW4gYSBzaW5nbGUgb2JqZWN0LCB3aXRoIHRoZWlyIGBpZGAgYXMgdGhlIGtleS5cbiAgICAgKiBAbmFtZSBqc0FwaVJlcG9ydGVyI3N1aXRlc1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge09iamVjdH0gLSBNYXAgb2Ygc3VpdGUgaWQgdG8ge0BsaW5rIFN1aXRlUmVzdWx0fVxuICAgICAqL1xuICAgIHRoaXMuc3VpdGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3VpdGVzX2hhc2g7XG4gICAgfTtcblxuICAgIHZhciBzcGVjcyA9IFtdO1xuXG4gICAgdGhpcy5zcGVjRG9uZSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgc3BlY3MucHVzaChyZXN1bHQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHJlc3VsdHMgZm9yIGEgc2V0IG9mIHNwZWNzLlxuICAgICAqXG4gICAgICogUmV0cmlldmFibGUgaW4gc2xpY2VzIGZvciBlYXNpZXIgc2VyaWFsaXphdGlvbi5cbiAgICAgKiBAbmFtZSBqc0FwaVJlcG9ydGVyI3NwZWNSZXN1bHRzXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIHBvc2l0aW9uIGluIHRoZSBzcGVjcyBsaXN0IHRvIHN0YXJ0IGZyb20uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCAtIE1heGltdW0gbnVtYmVyIG9mIHNwZWNzIHJlc3VsdHMgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm4ge1NwZWNSZXN1bHRbXX1cbiAgICAgKi9cbiAgICB0aGlzLnNwZWNSZXN1bHRzID0gZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCkge1xuICAgICAgcmV0dXJuIHNwZWNzLnNsaWNlKGluZGV4LCBpbmRleCArIGxlbmd0aCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgc3BlYyByZXN1bHRzLlxuICAgICAqIEBuYW1lIGpzQXBpUmVwb3J0ZXIjc3BlY3NcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtTcGVjUmVzdWx0W119XG4gICAgICovXG4gICAgdGhpcy5zcGVjcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNwZWNzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGZ1bGwgSmFzbWluZSBzdWl0ZSB0byBydW4uXG4gICAgICogQG5hbWUganNBcGlSZXBvcnRlciNleGVjdXRpb25UaW1lXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZXhlY3V0aW9uVGltZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4ZWN1dGlvblRpbWU7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBKc0FwaVJlcG9ydGVyO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5BbnkgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBBbnkoZXhwZWN0ZWRPYmplY3QpIHtcbiAgICBpZiAodHlwZW9mIGV4cGVjdGVkT2JqZWN0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ2phc21pbmUuYW55KCkgZXhwZWN0cyB0byBiZSBwYXNzZWQgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbi4gJyArXG4gICAgICAgICAgJ1BsZWFzZSBwYXNzIG9uZSBvciB1c2UgamFzbWluZS5hbnl0aGluZygpIHRvIG1hdGNoIGFueSBvYmplY3QuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5leHBlY3RlZE9iamVjdCA9IGV4cGVjdGVkT2JqZWN0O1xuICB9XG5cbiAgQW55LnByb3RvdHlwZS5hc3ltbWV0cmljTWF0Y2ggPSBmdW5jdGlvbihvdGhlcikge1xuICAgIGlmICh0aGlzLmV4cGVjdGVkT2JqZWN0ID09IFN0cmluZykge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvdGhlciA9PSAnc3RyaW5nJyB8fCBvdGhlciBpbnN0YW5jZW9mIFN0cmluZztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5leHBlY3RlZE9iamVjdCA9PSBOdW1iZXIpIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb3RoZXIgPT0gJ251bWJlcicgfHwgb3RoZXIgaW5zdGFuY2VvZiBOdW1iZXI7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZXhwZWN0ZWRPYmplY3QgPT0gRnVuY3Rpb24pIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb3RoZXIgPT0gJ2Z1bmN0aW9uJyB8fCBvdGhlciBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmV4cGVjdGVkT2JqZWN0ID09IE9iamVjdCkge1xuICAgICAgcmV0dXJuIG90aGVyICE9PSBudWxsICYmIHR5cGVvZiBvdGhlciA9PSAnb2JqZWN0JztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5leHBlY3RlZE9iamVjdCA9PSBCb29sZWFuKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG90aGVyID09ICdib29sZWFuJztcbiAgICB9XG5cbiAgICAvKiBqc2hpbnQgLVcxMjIgKi9cbiAgICAvKiBnbG9iYWwgU3ltYm9sICovXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgIT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5leHBlY3RlZE9iamVjdCA9PSBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb3RoZXIgPT0gJ3N5bWJvbCc7XG4gICAgfVxuICAgIC8qIGpzaGludCArVzEyMiAqL1xuXG4gICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgdGhpcy5leHBlY3RlZE9iamVjdDtcbiAgfTtcblxuICBBbnkucHJvdG90eXBlLmphc21pbmVUb1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnPGphc21pbmUuYW55KCcgKyBqJC5mbk5hbWVGb3IodGhpcy5leHBlY3RlZE9iamVjdCkgKyAnKT4nO1xuICB9O1xuXG4gIHJldHVybiBBbnk7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkFueXRoaW5nID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gQW55dGhpbmcoKSB7fVxuXG4gIEFueXRoaW5nLnByb3RvdHlwZS5hc3ltbWV0cmljTWF0Y2ggPSBmdW5jdGlvbihvdGhlcikge1xuICAgIHJldHVybiAhaiQudXRpbC5pc1VuZGVmaW5lZChvdGhlcikgJiYgb3RoZXIgIT09IG51bGw7XG4gIH07XG5cbiAgQW55dGhpbmcucHJvdG90eXBlLmphc21pbmVUb1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnPGphc21pbmUuYW55dGhpbmc+JztcbiAgfTtcblxuICByZXR1cm4gQW55dGhpbmc7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkFycmF5Q29udGFpbmluZyA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIEFycmF5Q29udGFpbmluZyhzYW1wbGUpIHtcbiAgICB0aGlzLnNhbXBsZSA9IHNhbXBsZTtcbiAgfVxuXG4gIEFycmF5Q29udGFpbmluZy5wcm90b3R5cGUuYXN5bW1ldHJpY01hdGNoID0gZnVuY3Rpb24ob3RoZXIsIG1hdGNoZXJzVXRpbCkge1xuICAgIGlmICghaiQuaXNBcnJheV8odGhpcy5zYW1wbGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdZb3UgbXVzdCBwcm92aWRlIGFuIGFycmF5IHRvIGFycmF5Q29udGFpbmluZywgbm90ICcgK1xuICAgICAgICAgIGokLmJhc2ljUHJldHR5UHJpbnRlcl8odGhpcy5zYW1wbGUpICtcbiAgICAgICAgICAnLidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGFjdHVhbCBwYXJhbWV0ZXIgaXMgbm90IGFuIGFycmF5LCB3ZSBjYW4gZmFpbCBpbW1lZGlhdGVseSwgc2luY2UgaXQgY291bGRuJ3RcbiAgICAvLyBwb3NzaWJseSBiZSBhbiBcImFycmF5IGNvbnRhaW5pbmdcIiBhbnl0aGluZy4gSG93ZXZlciwgd2UgYWxzbyB3YW50IGFuIGVtcHR5IHNhbXBsZVxuICAgIC8vIGFycmF5IHRvIG1hdGNoIGFueXRoaW5nLCBzbyB3ZSBuZWVkIHRvIGRvdWJsZS1jaGVjayB3ZSBhcmVuJ3QgaW4gdGhhdCBjYXNlXG4gICAgaWYgKCFqJC5pc0FycmF5XyhvdGhlcikgJiYgdGhpcy5zYW1wbGUubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zYW1wbGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gdGhpcy5zYW1wbGVbaV07XG4gICAgICBpZiAoIW1hdGNoZXJzVXRpbC5jb250YWlucyhvdGhlciwgaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIEFycmF5Q29udGFpbmluZy5wcm90b3R5cGUuamFzbWluZVRvU3RyaW5nID0gZnVuY3Rpb24ocHApIHtcbiAgICByZXR1cm4gJzxqYXNtaW5lLmFycmF5Q29udGFpbmluZygnICsgcHAodGhpcy5zYW1wbGUpICsgJyk+JztcbiAgfTtcblxuICByZXR1cm4gQXJyYXlDb250YWluaW5nO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5BcnJheVdpdGhFeGFjdENvbnRlbnRzID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gQXJyYXlXaXRoRXhhY3RDb250ZW50cyhzYW1wbGUpIHtcbiAgICB0aGlzLnNhbXBsZSA9IHNhbXBsZTtcbiAgfVxuXG4gIEFycmF5V2l0aEV4YWN0Q29udGVudHMucHJvdG90eXBlLmFzeW1tZXRyaWNNYXRjaCA9IGZ1bmN0aW9uKFxuICAgIG90aGVyLFxuICAgIG1hdGNoZXJzVXRpbFxuICApIHtcbiAgICBpZiAoIWokLmlzQXJyYXlfKHRoaXMuc2FtcGxlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnWW91IG11c3QgcHJvdmlkZSBhbiBhcnJheSB0byBhcnJheVdpdGhFeGFjdENvbnRlbnRzLCBub3QgJyArXG4gICAgICAgICAgaiQuYmFzaWNQcmV0dHlQcmludGVyXyh0aGlzLnNhbXBsZSkgK1xuICAgICAgICAgICcuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zYW1wbGUubGVuZ3RoICE9PSBvdGhlci5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2FtcGxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IHRoaXMuc2FtcGxlW2ldO1xuICAgICAgaWYgKCFtYXRjaGVyc1V0aWwuY29udGFpbnMob3RoZXIsIGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBBcnJheVdpdGhFeGFjdENvbnRlbnRzLnByb3RvdHlwZS5qYXNtaW5lVG9TdHJpbmcgPSBmdW5jdGlvbihwcCkge1xuICAgIHJldHVybiAnPGphc21pbmUuYXJyYXlXaXRoRXhhY3RDb250ZW50cygnICsgcHAodGhpcy5zYW1wbGUpICsgJyk+JztcbiAgfTtcblxuICByZXR1cm4gQXJyYXlXaXRoRXhhY3RDb250ZW50cztcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuRW1wdHkgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBFbXB0eSgpIHt9XG5cbiAgRW1wdHkucHJvdG90eXBlLmFzeW1tZXRyaWNNYXRjaCA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgaWYgKGokLmlzU3RyaW5nXyhvdGhlcikgfHwgaiQuaXNBcnJheV8ob3RoZXIpIHx8IGokLmlzVHlwZWRBcnJheV8ob3RoZXIpKSB7XG4gICAgICByZXR1cm4gb3RoZXIubGVuZ3RoID09PSAwO1xuICAgIH1cblxuICAgIGlmIChqJC5pc01hcChvdGhlcikgfHwgaiQuaXNTZXQob3RoZXIpKSB7XG4gICAgICByZXR1cm4gb3RoZXIuc2l6ZSA9PT0gMDtcbiAgICB9XG5cbiAgICBpZiAoaiQuaXNPYmplY3RfKG90aGVyKSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG90aGVyKS5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBFbXB0eS5wcm90b3R5cGUuamFzbWluZVRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICc8amFzbWluZS5lbXB0eT4nO1xuICB9O1xuXG4gIHJldHVybiBFbXB0eTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuRmFsc3kgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBGYWxzeSgpIHt9XG5cbiAgRmFsc3kucHJvdG90eXBlLmFzeW1tZXRyaWNNYXRjaCA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgcmV0dXJuICFvdGhlcjtcbiAgfTtcblxuICBGYWxzeS5wcm90b3R5cGUuamFzbWluZVRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICc8amFzbWluZS5mYWxzeT4nO1xuICB9O1xuXG4gIHJldHVybiBGYWxzeTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuTWFwQ29udGFpbmluZyA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIE1hcENvbnRhaW5pbmcoc2FtcGxlKSB7XG4gICAgaWYgKCFqJC5pc01hcChzYW1wbGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdZb3UgbXVzdCBwcm92aWRlIGEgbWFwIHRvIGBtYXBDb250YWluaW5nYCwgbm90ICcgK1xuICAgICAgICAgIGokLmJhc2ljUHJldHR5UHJpbnRlcl8oc2FtcGxlKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLnNhbXBsZSA9IHNhbXBsZTtcbiAgfVxuXG4gIE1hcENvbnRhaW5pbmcucHJvdG90eXBlLmFzeW1tZXRyaWNNYXRjaCA9IGZ1bmN0aW9uKG90aGVyLCBtYXRjaGVyc1V0aWwpIHtcbiAgICBpZiAoIWokLmlzTWFwKG90aGVyKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5zYW1wbGUpIHtcbiAgICAgIC8vIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyIGluIGBzYW1wbGVgXG4gICAgICAvLyB0aGVyZSBzaG91bGQgYmUgYXQgbGVhc3Qgb25lIHBhaXIgaW4gYG90aGVyYCB3aG9zZSBrZXkgYW5kIHZhbHVlIGJvdGggbWF0Y2hcbiAgICAgIHZhciBoYXNNYXRjaCA9IGZhbHNlO1xuICAgICAgZm9yIChjb25zdCBbb0tleSwgb1ZhbHVlXSBvZiBvdGhlcikge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbWF0Y2hlcnNVdGlsLmVxdWFscyhvS2V5LCBrZXkpICYmXG4gICAgICAgICAgbWF0Y2hlcnNVdGlsLmVxdWFscyhvVmFsdWUsIHZhbHVlKVxuICAgICAgICApIHtcbiAgICAgICAgICBoYXNNYXRjaCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFoYXNNYXRjaCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgTWFwQ29udGFpbmluZy5wcm90b3R5cGUuamFzbWluZVRvU3RyaW5nID0gZnVuY3Rpb24ocHApIHtcbiAgICByZXR1cm4gJzxqYXNtaW5lLm1hcENvbnRhaW5pbmcoJyArIHBwKHRoaXMuc2FtcGxlKSArICcpPic7XG4gIH07XG5cbiAgcmV0dXJuIE1hcENvbnRhaW5pbmc7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLk5vdEVtcHR5ID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gTm90RW1wdHkoKSB7fVxuXG4gIE5vdEVtcHR5LnByb3RvdHlwZS5hc3ltbWV0cmljTWF0Y2ggPSBmdW5jdGlvbihvdGhlcikge1xuICAgIGlmIChqJC5pc1N0cmluZ18ob3RoZXIpIHx8IGokLmlzQXJyYXlfKG90aGVyKSB8fCBqJC5pc1R5cGVkQXJyYXlfKG90aGVyKSkge1xuICAgICAgcmV0dXJuIG90aGVyLmxlbmd0aCAhPT0gMDtcbiAgICB9XG5cbiAgICBpZiAoaiQuaXNNYXAob3RoZXIpIHx8IGokLmlzU2V0KG90aGVyKSkge1xuICAgICAgcmV0dXJuIG90aGVyLnNpemUgIT09IDA7XG4gICAgfVxuXG4gICAgaWYgKGokLmlzT2JqZWN0XyhvdGhlcikpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvdGhlcikubGVuZ3RoICE9PSAwO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBOb3RFbXB0eS5wcm90b3R5cGUuamFzbWluZVRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICc8amFzbWluZS5ub3RFbXB0eT4nO1xuICB9O1xuXG4gIHJldHVybiBOb3RFbXB0eTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuT2JqZWN0Q29udGFpbmluZyA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIE9iamVjdENvbnRhaW5pbmcoc2FtcGxlKSB7XG4gICAgdGhpcy5zYW1wbGUgPSBzYW1wbGU7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNQcm9wZXJ0eShvYmosIHByb3BlcnR5KSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcGVydHkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzUHJvcGVydHkoT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaiksIHByb3BlcnR5KTtcbiAgfVxuXG4gIE9iamVjdENvbnRhaW5pbmcucHJvdG90eXBlLmFzeW1tZXRyaWNNYXRjaCA9IGZ1bmN0aW9uKG90aGVyLCBtYXRjaGVyc1V0aWwpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuc2FtcGxlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIllvdSBtdXN0IHByb3ZpZGUgYW4gb2JqZWN0IHRvIG9iamVjdENvbnRhaW5pbmcsIG5vdCAnXCIgK1xuICAgICAgICAgIHRoaXMuc2FtcGxlICtcbiAgICAgICAgICBcIicuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3RoZXIgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcy5zYW1wbGUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIWhhc1Byb3BlcnR5KG90aGVyLCBwcm9wZXJ0eSkgfHxcbiAgICAgICAgIW1hdGNoZXJzVXRpbC5lcXVhbHModGhpcy5zYW1wbGVbcHJvcGVydHldLCBvdGhlcltwcm9wZXJ0eV0pXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIE9iamVjdENvbnRhaW5pbmcucHJvdG90eXBlLnZhbHVlc0ZvckRpZmZfID0gZnVuY3Rpb24ob3RoZXIsIHBwKSB7XG4gICAgaWYgKCFqJC5pc09iamVjdF8ob3RoZXIpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWxmOiB0aGlzLmphc21pbmVUb1N0cmluZyhwcCksXG4gICAgICAgIG90aGVyOiBvdGhlclxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZmlsdGVyZWRPdGhlciA9IHt9O1xuICAgIE9iamVjdC5rZXlzKHRoaXMuc2FtcGxlKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgIC8vIGVxIHNob3J0LWNpcmN1aXRzIGNvbXBhcmlzb24gb2Ygb2JqZWN0cyB0aGF0IGhhdmUgZGlmZmVyZW50IGtleSBzZXRzLFxuICAgICAgLy8gc28gaW5jbHVkZSBhbGwga2V5cyBldmVuIGlmIHVuZGVmaW5lZC5cbiAgICAgIGZpbHRlcmVkT3RoZXJba10gPSBvdGhlcltrXTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBzZWxmOiB0aGlzLnNhbXBsZSxcbiAgICAgIG90aGVyOiBmaWx0ZXJlZE90aGVyXG4gICAgfTtcbiAgfTtcblxuICBPYmplY3RDb250YWluaW5nLnByb3RvdHlwZS5qYXNtaW5lVG9TdHJpbmcgPSBmdW5jdGlvbihwcCkge1xuICAgIHJldHVybiAnPGphc21pbmUub2JqZWN0Q29udGFpbmluZygnICsgcHAodGhpcy5zYW1wbGUpICsgJyk+JztcbiAgfTtcblxuICByZXR1cm4gT2JqZWN0Q29udGFpbmluZztcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuU2V0Q29udGFpbmluZyA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIFNldENvbnRhaW5pbmcoc2FtcGxlKSB7XG4gICAgaWYgKCFqJC5pc1NldChzYW1wbGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdZb3UgbXVzdCBwcm92aWRlIGEgc2V0IHRvIGBzZXRDb250YWluaW5nYCwgbm90ICcgK1xuICAgICAgICAgIGokLmJhc2ljUHJldHR5UHJpbnRlcl8oc2FtcGxlKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLnNhbXBsZSA9IHNhbXBsZTtcbiAgfVxuXG4gIFNldENvbnRhaW5pbmcucHJvdG90eXBlLmFzeW1tZXRyaWNNYXRjaCA9IGZ1bmN0aW9uKG90aGVyLCBtYXRjaGVyc1V0aWwpIHtcbiAgICBpZiAoIWokLmlzU2V0KG90aGVyKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuc2FtcGxlKSB7XG4gICAgICAvLyBmb3IgZWFjaCBpdGVtIGluIGBzYW1wbGVgIHRoZXJlIHNob3VsZCBiZSBhdCBsZWFzdCBvbmUgbWF0Y2hpbmcgaXRlbSBpbiBgb3RoZXJgXG4gICAgICAvLyAobm90IHVzaW5nIGBtYXRjaGVyc1V0aWwuY29udGFpbnNgIGJlY2F1c2UgaXQgY29tcGFyZXMgc2V0IG1lbWJlcnMgYnkgcmVmZXJlbmNlLFxuICAgICAgLy8gbm90IGJ5IGRlZXAgdmFsdWUgZXF1YWxpdHkpXG4gICAgICB2YXIgaGFzTWF0Y2ggPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3Qgb0l0ZW0gb2Ygb3RoZXIpIHtcbiAgICAgICAgaWYgKG1hdGNoZXJzVXRpbC5lcXVhbHMob0l0ZW0sIGl0ZW0pKSB7XG4gICAgICAgICAgaGFzTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFzTWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIFNldENvbnRhaW5pbmcucHJvdG90eXBlLmphc21pbmVUb1N0cmluZyA9IGZ1bmN0aW9uKHBwKSB7XG4gICAgcmV0dXJuICc8amFzbWluZS5zZXRDb250YWluaW5nKCcgKyBwcCh0aGlzLnNhbXBsZSkgKyAnKT4nO1xuICB9O1xuXG4gIHJldHVybiBTZXRDb250YWluaW5nO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5TdHJpbmdDb250YWluaW5nID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gU3RyaW5nQ29udGFpbmluZyhleHBlY3RlZCkge1xuICAgIGlmICghaiQuaXNTdHJpbmdfKGV4cGVjdGVkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpcyBub3QgYSBTdHJpbmcnKTtcbiAgICB9XG5cbiAgICB0aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gIH1cblxuICBTdHJpbmdDb250YWluaW5nLnByb3RvdHlwZS5hc3ltbWV0cmljTWF0Y2ggPSBmdW5jdGlvbihvdGhlcikge1xuICAgIGlmICghaiQuaXNTdHJpbmdfKG90aGVyKSkge1xuICAgICAgLy8gQXJyYXlzLCBldGMuIGRvbid0IG1hdGNoIG5vIG1hdHRlciB3aGF0IHRoZWlyIGluZGV4T2YgcmV0dXJucy5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3RoZXIuaW5kZXhPZih0aGlzLmV4cGVjdGVkKSAhPT0gLTE7XG4gIH07XG5cbiAgU3RyaW5nQ29udGFpbmluZy5wcm90b3R5cGUuamFzbWluZVRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICc8amFzbWluZS5zdHJpbmdDb250YWluaW5nKFwiJyArIHRoaXMuZXhwZWN0ZWQgKyAnXCIpPic7XG4gIH07XG5cbiAgcmV0dXJuIFN0cmluZ0NvbnRhaW5pbmc7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlN0cmluZ01hdGNoaW5nID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gU3RyaW5nTWF0Y2hpbmcoZXhwZWN0ZWQpIHtcbiAgICBpZiAoIWokLmlzU3RyaW5nXyhleHBlY3RlZCkgJiYgIWokLmlzQV8oJ1JlZ0V4cCcsIGV4cGVjdGVkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpcyBub3QgYSBTdHJpbmcgb3IgYSBSZWdFeHAnKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlZ2V4cCA9IG5ldyBSZWdFeHAoZXhwZWN0ZWQpO1xuICB9XG5cbiAgU3RyaW5nTWF0Y2hpbmcucHJvdG90eXBlLmFzeW1tZXRyaWNNYXRjaCA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMucmVnZXhwLnRlc3Qob3RoZXIpO1xuICB9O1xuXG4gIFN0cmluZ01hdGNoaW5nLnByb3RvdHlwZS5qYXNtaW5lVG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJzxqYXNtaW5lLnN0cmluZ01hdGNoaW5nKCcgKyB0aGlzLnJlZ2V4cCArICcpPic7XG4gIH07XG5cbiAgcmV0dXJuIFN0cmluZ01hdGNoaW5nO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5UcnV0aHkgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBUcnV0aHkoKSB7fVxuXG4gIFRydXRoeS5wcm90b3R5cGUuYXN5bW1ldHJpY01hdGNoID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICByZXR1cm4gISFvdGhlcjtcbiAgfTtcblxuICBUcnV0aHkucHJvdG90eXBlLmphc21pbmVUb1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnPGphc21pbmUudHJ1dGh5Pic7XG4gIH07XG5cbiAgcmV0dXJuIFRydXRoeTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuQ2FsbFRyYWNrZXIgPSBmdW5jdGlvbihqJCkge1xuICAvKipcbiAgICogQG5hbWVzcGFjZSBTcHkjY2FsbHNcbiAgICogQHNpbmNlIDIuMC4wXG4gICAqL1xuICBmdW5jdGlvbiBDYWxsVHJhY2tlcigpIHtcbiAgICB2YXIgY2FsbHMgPSBbXTtcbiAgICB2YXIgb3B0cyA9IHt9O1xuXG4gICAgdGhpcy50cmFjayA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIGlmIChvcHRzLmNsb25lQXJncykge1xuICAgICAgICBjb250ZXh0LmFyZ3MgPSBqJC51dGlsLmNsb25lQXJncyhjb250ZXh0LmFyZ3MpO1xuICAgICAgfVxuICAgICAgY2FsbHMucHVzaChjb250ZXh0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGlzIHNweSBoYXMgYmVlbiBpbnZva2VkLlxuICAgICAqIEBuYW1lIFNweSNjYWxscyNhbnlcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuYW55ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gISFjYWxscy5sZW5ndGg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIGludm9jYXRpb25zIG9mIHRoaXMgc3B5LlxuICAgICAqIEBuYW1lIFNweSNjYWxscyNjb3VudFxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge0ludGVnZXJ9XG4gICAgICovXG4gICAgdGhpcy5jb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNhbGxzLmxlbmd0aDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBhcmd1bWVudHMgdGhhdCB3ZXJlIHBhc3NlZCB0byBhIHNwZWNpZmljIGludm9jYXRpb24gb2YgdGhpcyBzcHkuXG4gICAgICogQG5hbWUgU3B5I2NhbGxzI2FyZ3NGb3JcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGluZGV4IFRoZSAwLWJhc2VkIGludm9jYXRpb24gaW5kZXguXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5hcmdzRm9yID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIHZhciBjYWxsID0gY2FsbHNbaW5kZXhdO1xuICAgICAgcmV0dXJuIGNhbGwgPyBjYWxsLmFyZ3MgOiBbXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBcInRoaXNcIiBvYmplY3QgdGhhdCB3YXMgcGFzc2VkIHRvIGEgc3BlY2lmaWMgaW52b2NhdGlvbiBvZiB0aGlzIHNweS5cbiAgICAgKiBAbmFtZSBTcHkjY2FsbHMjdGhpc0ZvclxuICAgICAqIEBzaW5jZSAzLjguMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gaW5kZXggVGhlIDAtYmFzZWQgaW52b2NhdGlvbiBpbmRleC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3Q/fVxuICAgICAqL1xuICAgIHRoaXMudGhpc0ZvciA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICB2YXIgY2FsbCA9IGNhbGxzW2luZGV4XTtcbiAgICAgIHJldHVybiBjYWxsID8gY2FsbC5vYmplY3QgOiB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcmF3IGNhbGxzIGFycmF5IGZvciB0aGlzIHNweS5cbiAgICAgKiBAbmFtZSBTcHkjY2FsbHMjYWxsXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7U3B5LmNhbGxEYXRhW119XG4gICAgICovXG4gICAgdGhpcy5hbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjYWxscztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBvZiB0aGUgYXJndW1lbnRzIGZvciBlYWNoIGludm9jYXRpb24gb2YgdGhpcyBzcHkgaW4gdGhlIG9yZGVyIHRoZXkgd2VyZSByZWNlaXZlZC5cbiAgICAgKiBAbmFtZSBTcHkjY2FsbHMjYWxsQXJnc1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYWxsQXJncyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNhbGxBcmdzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxBcmdzLnB1c2goY2FsbHNbaV0uYXJncyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWxsQXJncztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBmaXJzdCBpbnZvY2F0aW9uIG9mIHRoaXMgc3B5LlxuICAgICAqIEBuYW1lIFNweSNjYWxscyNmaXJzdFxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge09iamVjU3B5LmNhbGxEYXRhfVxuICAgICAqL1xuICAgIHRoaXMuZmlyc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjYWxsc1swXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBtb3N0IHJlY2VudCBpbnZvY2F0aW9uIG9mIHRoaXMgc3B5LlxuICAgICAqIEBuYW1lIFNweSNjYWxscyNtb3N0UmVjZW50XG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7T2JqZWNTcHkuY2FsbERhdGF9XG4gICAgICovXG4gICAgdGhpcy5tb3N0UmVjZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY2FsbHNbY2FsbHMubGVuZ3RoIC0gMV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoaXMgc3B5IGFzIGlmIGl0IGhhcyBuZXZlciBiZWVuIGNhbGxlZC5cbiAgICAgKiBAbmFtZSBTcHkjY2FsbHMjcmVzZXRcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICB0aGlzLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBjYWxscyA9IFtdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhpcyBzcHkgdG8gZG8gYSBzaGFsbG93IGNsb25lIG9mIGFyZ3VtZW50cyBwYXNzZWQgdG8gZWFjaCBpbnZvY2F0aW9uLlxuICAgICAqIEBuYW1lIFNweSNjYWxscyNzYXZlQXJndW1lbnRzQnlWYWx1ZVxuICAgICAqIEBzaW5jZSAyLjUuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIHRoaXMuc2F2ZUFyZ3VtZW50c0J5VmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIG9wdHMuY2xvbmVBcmdzID0gdHJ1ZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIENhbGxUcmFja2VyO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5jbGVhclN0YWNrID0gZnVuY3Rpb24oaiQpIHtcbiAgdmFyIG1heElubGluZUNhbGxDb3VudCA9IDEwO1xuXG4gIGZ1bmN0aW9uIG1lc3NhZ2VDaGFubmVsSW1wbChnbG9iYWwsIHNldFRpbWVvdXQpIHtcbiAgICB2YXIgY2hhbm5lbCA9IG5ldyBnbG9iYWwuTWVzc2FnZUNoYW5uZWwoKSxcbiAgICAgIGhlYWQgPSB7fSxcbiAgICAgIHRhaWwgPSBoZWFkO1xuXG4gICAgdmFyIHRhc2tSdW5uaW5nID0gZmFsc2U7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB2YXIgdGFzayA9IGhlYWQudGFzaztcbiAgICAgIGRlbGV0ZSBoZWFkLnRhc2s7XG5cbiAgICAgIGlmICh0YXNrUnVubmluZykge1xuICAgICAgICBnbG9iYWwuc2V0VGltZW91dCh0YXNrLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGFza1J1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgIHRhc2soKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0YXNrUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjdXJyZW50Q2FsbENvdW50ID0gMDtcbiAgICByZXR1cm4gZnVuY3Rpb24gY2xlYXJTdGFjayhmbikge1xuICAgICAgY3VycmVudENhbGxDb3VudCsrO1xuXG4gICAgICBpZiAoY3VycmVudENhbGxDb3VudCA8IG1heElubGluZUNhbGxDb3VudCkge1xuICAgICAgICB0YWlsID0gdGFpbC5uZXh0ID0geyB0YXNrOiBmbiB9O1xuICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudENhbGxDb3VudCA9IDA7XG4gICAgICAgIHNldFRpbWVvdXQoZm4pO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDbGVhclN0YWNrKGdsb2JhbCkge1xuICAgIHZhciBjdXJyZW50Q2FsbENvdW50ID0gMDtcbiAgICB2YXIgcmVhbFNldFRpbWVvdXQgPSBnbG9iYWwuc2V0VGltZW91dDtcbiAgICB2YXIgc2V0VGltZW91dEltcGwgPSBmdW5jdGlvbiBjbGVhclN0YWNrKGZuKSB7XG4gICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkocmVhbFNldFRpbWVvdXQsIFtnbG9iYWwsIFtmbiwgMF1dKTtcbiAgICB9O1xuXG4gICAgaWYgKGokLmlzRnVuY3Rpb25fKGdsb2JhbC5zZXRJbW1lZGlhdGUpKSB7XG4gICAgICB2YXIgcmVhbFNldEltbWVkaWF0ZSA9IGdsb2JhbC5zZXRJbW1lZGlhdGU7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgY3VycmVudENhbGxDb3VudCsrO1xuXG4gICAgICAgIGlmIChjdXJyZW50Q2FsbENvdW50IDwgbWF4SW5saW5lQ2FsbENvdW50KSB7XG4gICAgICAgICAgcmVhbFNldEltbWVkaWF0ZShmbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudENhbGxDb3VudCA9IDA7XG5cbiAgICAgICAgICBzZXRUaW1lb3V0SW1wbChmbik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICghaiQudXRpbC5pc1VuZGVmaW5lZChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpKSB7XG4gICAgICByZXR1cm4gbWVzc2FnZUNoYW5uZWxJbXBsKGdsb2JhbCwgc2V0VGltZW91dEltcGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2V0VGltZW91dEltcGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdldENsZWFyU3RhY2s7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkNsb2NrID0gZnVuY3Rpb24oKSB7XG4gIC8qIGdsb2JhbCBwcm9jZXNzICovXG4gIHZhciBOT0RFX0pTID1cbiAgICB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBwcm9jZXNzLnZlcnNpb25zICYmXG4gICAgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSA9PT0gJ3N0cmluZyc7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBDbG9ja1xuICAgKiBAc2luY2UgMS4zLjBcbiAgICogQGNsYXNzZGVzYyBKYXNtaW5lJ3MgbW9jayBjbG9jayBpcyB1c2VkIHdoZW4gdGVzdGluZyB0aW1lIGRlcGVuZGVudCBjb2RlLjxicj5cbiAgICogX05vdGU6XyBEbyBub3QgY29uc3RydWN0IHRoaXMgZGlyZWN0bHkuIFlvdSBjYW4gZ2V0IHRoZSBjdXJyZW50IGNsb2NrIHdpdGhcbiAgICoge0BsaW5rIGphc21pbmUuY2xvY2t9LlxuICAgKiBAaGlkZWNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBDbG9jayhnbG9iYWwsIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlckZhY3RvcnksIG1vY2tEYXRlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgcmVhbFRpbWluZ0Z1bmN0aW9ucyA9IHtcbiAgICAgICAgc2V0VGltZW91dDogZ2xvYmFsLnNldFRpbWVvdXQsXG4gICAgICAgIGNsZWFyVGltZW91dDogZ2xvYmFsLmNsZWFyVGltZW91dCxcbiAgICAgICAgc2V0SW50ZXJ2YWw6IGdsb2JhbC5zZXRJbnRlcnZhbCxcbiAgICAgICAgY2xlYXJJbnRlcnZhbDogZ2xvYmFsLmNsZWFySW50ZXJ2YWxcbiAgICAgIH0sXG4gICAgICBmYWtlVGltaW5nRnVuY3Rpb25zID0ge1xuICAgICAgICBzZXRUaW1lb3V0OiBzZXRUaW1lb3V0LFxuICAgICAgICBjbGVhclRpbWVvdXQ6IGNsZWFyVGltZW91dCxcbiAgICAgICAgc2V0SW50ZXJ2YWw6IHNldEludGVydmFsLFxuICAgICAgICBjbGVhckludGVydmFsOiBjbGVhckludGVydmFsXG4gICAgICB9LFxuICAgICAgaW5zdGFsbGVkID0gZmFsc2UsXG4gICAgICBkZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIsXG4gICAgICB0aW1lcjtcblxuICAgIHNlbGYuRmFrZVRpbWVvdXQgPSBGYWtlVGltZW91dDtcblxuICAgIC8qKlxuICAgICAqIEluc3RhbGwgdGhlIG1vY2sgY2xvY2sgb3ZlciB0aGUgYnVpbHQtaW4gbWV0aG9kcy5cbiAgICAgKiBAbmFtZSBDbG9jayNpbnN0YWxsXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7Q2xvY2t9XG4gICAgICovXG4gICAgc2VsZi5pbnN0YWxsID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIW9yaWdpbmFsVGltaW5nRnVuY3Rpb25zSW50YWN0KCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdKYXNtaW5lIENsb2NrIHdhcyB1bmFibGUgdG8gaW5zdGFsbCBvdmVyIGN1c3RvbSBnbG9iYWwgdGltZXIgZnVuY3Rpb25zLiBJcyB0aGUgY2xvY2sgYWxyZWFkeSBpbnN0YWxsZWQ/J1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmVwbGFjZShnbG9iYWwsIGZha2VUaW1pbmdGdW5jdGlvbnMpO1xuICAgICAgdGltZXIgPSBmYWtlVGltaW5nRnVuY3Rpb25zO1xuICAgICAgZGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyID0gZGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyRmFjdG9yeSgpO1xuICAgICAgaW5zdGFsbGVkID0gdHJ1ZTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVuaW5zdGFsbCB0aGUgbW9jayBjbG9jaywgcmV0dXJuaW5nIHRoZSBidWlsdC1pbiBtZXRob2RzIHRvIHRoZWlyIHBsYWNlcy5cbiAgICAgKiBAbmFtZSBDbG9jayN1bmluc3RhbGxcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICBzZWxmLnVuaW5zdGFsbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyID0gbnVsbDtcbiAgICAgIG1vY2tEYXRlLnVuaW5zdGFsbCgpO1xuICAgICAgcmVwbGFjZShnbG9iYWwsIHJlYWxUaW1pbmdGdW5jdGlvbnMpO1xuXG4gICAgICB0aW1lciA9IHJlYWxUaW1pbmdGdW5jdGlvbnM7XG4gICAgICBpbnN0YWxsZWQgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSBhIGZ1bmN0aW9uIHdpdGggYSBtb2NrZWQgQ2xvY2tcbiAgICAgKlxuICAgICAqIFRoZSBjbG9jayB3aWxsIGJlIHtAbGluayBDbG9jayNpbnN0YWxsfGluc3RhbGx9ZWQgYmVmb3JlIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgYW5kIHtAbGluayBDbG9jayN1bmluc3RhbGx8dW5pbnN0YWxsfWVkIGluIGEgYGZpbmFsbHlgIGFmdGVyIHRoZSBmdW5jdGlvbiBjb21wbGV0ZXMuXG4gICAgICogQG5hbWUgQ2xvY2sjd2l0aE1vY2tcbiAgICAgKiBAc2luY2UgMi4zLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9zdXJlIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQuXG4gICAgICovXG4gICAgc2VsZi53aXRoTW9jayA9IGZ1bmN0aW9uKGNsb3N1cmUpIHtcbiAgICAgIHRoaXMuaW5zdGFsbCgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2xvc3VyZSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy51bmluc3RhbGwoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5zdHJ1Y3QgdGhlIGluc3RhbGxlZCBDbG9jayB0byBhbHNvIG1vY2sgdGhlIGRhdGUgcmV0dXJuZWQgYnkgYG5ldyBEYXRlKClgXG4gICAgICogQG5hbWUgQ2xvY2sjbW9ja0RhdGVcbiAgICAgKiBAc2luY2UgMi4xLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0RhdGV9IFtpbml0aWFsRGF0ZT1ub3ddIFRoZSBgRGF0ZWAgdG8gcHJvdmlkZS5cbiAgICAgKi9cbiAgICBzZWxmLm1vY2tEYXRlID0gZnVuY3Rpb24oaW5pdGlhbERhdGUpIHtcbiAgICAgIG1vY2tEYXRlLmluc3RhbGwoaW5pdGlhbERhdGUpO1xuICAgIH07XG5cbiAgICBzZWxmLnNldFRpbWVvdXQgPSBmdW5jdGlvbihmbiwgZGVsYXksIHBhcmFtcykge1xuICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseSh0aW1lci5zZXRUaW1lb3V0LCBbXG4gICAgICAgIGdsb2JhbCxcbiAgICAgICAgYXJndW1lbnRzXG4gICAgICBdKTtcbiAgICB9O1xuXG4gICAgc2VsZi5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKGZuLCBkZWxheSwgcGFyYW1zKSB7XG4gICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KHRpbWVyLnNldEludGVydmFsLCBbXG4gICAgICAgIGdsb2JhbCxcbiAgICAgICAgYXJndW1lbnRzXG4gICAgICBdKTtcbiAgICB9O1xuXG4gICAgc2VsZi5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbihpZCkge1xuICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLmFwcGx5KHRpbWVyLmNsZWFyVGltZW91dCwgW2dsb2JhbCwgaWRdKTtcbiAgICB9O1xuXG4gICAgc2VsZi5jbGVhckludGVydmFsID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbC5hcHBseSh0aW1lci5jbGVhckludGVydmFsLCBbZ2xvYmFsLCBpZF0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaWNrIHRoZSBDbG9jayBmb3J3YXJkLCBydW5uaW5nIGFueSBlbnF1ZXVlZCB0aW1lb3V0cyBhbG9uZyB0aGUgd2F5XG4gICAgICogQG5hbWUgQ2xvY2sjdGlja1xuICAgICAqIEBzaW5jZSAxLjMuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7aW50fSBtaWxsaXMgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGljay5cbiAgICAgKi9cbiAgICBzZWxmLnRpY2sgPSBmdW5jdGlvbihtaWxsaXMpIHtcbiAgICAgIGlmIChpbnN0YWxsZWQpIHtcbiAgICAgICAgZGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyLnRpY2sobWlsbGlzLCBmdW5jdGlvbihtaWxsaXMpIHtcbiAgICAgICAgICBtb2NrRGF0ZS50aWNrKG1pbGxpcyk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdNb2NrIGNsb2NrIGlzIG5vdCBpbnN0YWxsZWQsIHVzZSBqYXNtaW5lLmNsb2NrKCkuaW5zdGFsbCgpJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcblxuICAgIGZ1bmN0aW9uIG9yaWdpbmFsVGltaW5nRnVuY3Rpb25zSW50YWN0KCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgZ2xvYmFsLnNldFRpbWVvdXQgPT09IHJlYWxUaW1pbmdGdW5jdGlvbnMuc2V0VGltZW91dCAmJlxuICAgICAgICBnbG9iYWwuY2xlYXJUaW1lb3V0ID09PSByZWFsVGltaW5nRnVuY3Rpb25zLmNsZWFyVGltZW91dCAmJlxuICAgICAgICBnbG9iYWwuc2V0SW50ZXJ2YWwgPT09IHJlYWxUaW1pbmdGdW5jdGlvbnMuc2V0SW50ZXJ2YWwgJiZcbiAgICAgICAgZ2xvYmFsLmNsZWFySW50ZXJ2YWwgPT09IHJlYWxUaW1pbmdGdW5jdGlvbnMuY2xlYXJJbnRlcnZhbFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlKGRlc3QsIHNvdXJjZSkge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgZGVzdFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRUaW1lb3V0KGZuLCBkZWxheSkge1xuICAgICAgaWYgKCFOT0RFX0pTKSB7XG4gICAgICAgIHJldHVybiBkZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIuc2NoZWR1bGVGdW5jdGlvbihcbiAgICAgICAgICBmbixcbiAgICAgICAgICBkZWxheSxcbiAgICAgICAgICBhcmdTbGljZShhcmd1bWVudHMsIDIpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0aW1lb3V0ID0gbmV3IEZha2VUaW1lb3V0KCk7XG5cbiAgICAgIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlci5zY2hlZHVsZUZ1bmN0aW9uKFxuICAgICAgICBmbixcbiAgICAgICAgZGVsYXksXG4gICAgICAgIGFyZ1NsaWNlKGFyZ3VtZW50cywgMiksXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aW1lb3V0XG4gICAgICApO1xuXG4gICAgICByZXR1cm4gdGltZW91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhclRpbWVvdXQoaWQpIHtcbiAgICAgIHJldHVybiBkZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIucmVtb3ZlRnVuY3Rpb25XaXRoSWQoaWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEludGVydmFsKGZuLCBpbnRlcnZhbCkge1xuICAgICAgaWYgKCFOT0RFX0pTKSB7XG4gICAgICAgIHJldHVybiBkZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIuc2NoZWR1bGVGdW5jdGlvbihcbiAgICAgICAgICBmbixcbiAgICAgICAgICBpbnRlcnZhbCxcbiAgICAgICAgICBhcmdTbGljZShhcmd1bWVudHMsIDIpLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRpbWVvdXQgPSBuZXcgRmFrZVRpbWVvdXQoKTtcblxuICAgICAgZGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyLnNjaGVkdWxlRnVuY3Rpb24oXG4gICAgICAgIGZuLFxuICAgICAgICBpbnRlcnZhbCxcbiAgICAgICAgYXJnU2xpY2UoYXJndW1lbnRzLCAyKSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgdGltZW91dFxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHRpbWVvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbnRlcnZhbChpZCkge1xuICAgICAgcmV0dXJuIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlci5yZW1vdmVGdW5jdGlvbldpdGhJZChpZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXJnU2xpY2UoYXJnc09iaiwgbikge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3NPYmosIG4pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNb2NrcyBOb2RlLmpzIFRpbWVvdXQgY2xhc3NcbiAgICovXG4gIGZ1bmN0aW9uIEZha2VUaW1lb3V0KCkge31cblxuICBGYWtlVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRmFrZVRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIENsb2NrO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5Db21wbGV0ZU9uRmlyc3RFcnJvclNraXBQb2xpY3kgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBDb21wbGV0ZU9uRmlyc3RFcnJvclNraXBQb2xpY3kocXVldWVhYmxlRm5zKSB7XG4gICAgdGhpcy5xdWV1ZWFibGVGbnNfID0gcXVldWVhYmxlRm5zO1xuICAgIHRoaXMuZXJyb3JlZEZuSXhfID0gbnVsbDtcbiAgfVxuXG4gIENvbXBsZXRlT25GaXJzdEVycm9yU2tpcFBvbGljeS5wcm90b3R5cGUuc2tpcFRvID0gZnVuY3Rpb24obGFzdFJhbkZuSXgpIHtcbiAgICBsZXQgaTtcblxuICAgIGZvciAoXG4gICAgICBpID0gbGFzdFJhbkZuSXggKyAxO1xuICAgICAgaSA8IHRoaXMucXVldWVhYmxlRm5zXy5sZW5ndGggJiYgdGhpcy5zaG91bGRTa2lwXyhpKTtcbiAgICAgIGkrK1xuICAgICkge31cbiAgICByZXR1cm4gaTtcbiAgfTtcblxuICBDb21wbGV0ZU9uRmlyc3RFcnJvclNraXBQb2xpY3kucHJvdG90eXBlLmZuRXJyb3JlZCA9IGZ1bmN0aW9uKGZuSXgpIHtcbiAgICB0aGlzLmVycm9yZWRGbkl4XyA9IGZuSXg7XG4gIH07XG5cbiAgQ29tcGxldGVPbkZpcnN0RXJyb3JTa2lwUG9saWN5LnByb3RvdHlwZS5zaG91bGRTa2lwXyA9IGZ1bmN0aW9uKGZuSXgpIHtcbiAgICBpZiAodGhpcy5lcnJvcmVkRm5JeF8gPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBmbiA9IHRoaXMucXVldWVhYmxlRm5zX1tmbkl4XTtcbiAgICBjb25zdCBjYW5kaWRhdGVTdWl0ZSA9IGZuLnN1aXRlO1xuICAgIGNvbnN0IGVycm9yU3VpdGUgPSB0aGlzLnF1ZXVlYWJsZUZuc19bdGhpcy5lcnJvcmVkRm5JeF9dLnN1aXRlO1xuICAgIGNvbnN0IHdhc0NsZWFudXBGbiA9XG4gICAgICBmbi50eXBlID09PSAnYWZ0ZXJFYWNoJyB8fFxuICAgICAgZm4udHlwZSA9PT0gJ2FmdGVyQWxsJyB8fFxuICAgICAgZm4udHlwZSA9PT0gJ3NwZWNDbGVhbnVwJztcbiAgICByZXR1cm4gKFxuICAgICAgIXdhc0NsZWFudXBGbiB8fFxuICAgICAgKGNhbmRpZGF0ZVN1aXRlICYmIGlzRGVzY2VuZGVudChjYW5kaWRhdGVTdWl0ZSwgZXJyb3JTdWl0ZSkpXG4gICAgKTtcbiAgfTtcblxuICBmdW5jdGlvbiBpc0Rlc2NlbmRlbnQoY2FuZGlkYXRlLCBhbmNlc3Rvcikge1xuICAgIGlmICghY2FuZGlkYXRlLnBhcmVudFN1aXRlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChjYW5kaWRhdGUucGFyZW50U3VpdGUgPT09IGFuY2VzdG9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGlzRGVzY2VuZGVudChjYW5kaWRhdGUucGFyZW50U3VpdGUsIGFuY2VzdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gQ29tcGxldGVPbkZpcnN0RXJyb3JTa2lwUG9saWN5O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5EZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBEZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzY2hlZHVsZWRMb29rdXAgPSBbXTtcbiAgICB2YXIgc2NoZWR1bGVkRnVuY3Rpb25zID0ge307XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gMDtcbiAgICB2YXIgZGVsYXllZEZuQ291bnQgPSAwO1xuICAgIHZhciBkZWxldGVkS2V5cyA9IFtdO1xuXG4gICAgc2VsZi50aWNrID0gZnVuY3Rpb24obWlsbGlzLCB0aWNrRGF0ZSkge1xuICAgICAgbWlsbGlzID0gbWlsbGlzIHx8IDA7XG4gICAgICB2YXIgZW5kVGltZSA9IGN1cnJlbnRUaW1lICsgbWlsbGlzO1xuXG4gICAgICBydW5TY2hlZHVsZWRGdW5jdGlvbnMoZW5kVGltZSwgdGlja0RhdGUpO1xuICAgIH07XG5cbiAgICBzZWxmLnNjaGVkdWxlRnVuY3Rpb24gPSBmdW5jdGlvbihcbiAgICAgIGZ1bmNUb0NhbGwsXG4gICAgICBtaWxsaXMsXG4gICAgICBwYXJhbXMsXG4gICAgICByZWN1cnJpbmcsXG4gICAgICB0aW1lb3V0S2V5LFxuICAgICAgcnVuQXRNaWxsaXNcbiAgICApIHtcbiAgICAgIHZhciBmO1xuICAgICAgaWYgKHR5cGVvZiBmdW5jVG9DYWxsID09PSAnc3RyaW5nJykge1xuICAgICAgICAvKiBqc2hpbnQgZXZpbDogdHJ1ZSAqL1xuICAgICAgICBmID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGV2YWwoZnVuY1RvQ2FsbCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qIGpzaGludCBldmlsOiBmYWxzZSAqL1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZiA9IGZ1bmNUb0NhbGw7XG4gICAgICB9XG5cbiAgICAgIG1pbGxpcyA9IG1pbGxpcyB8fCAwO1xuICAgICAgdGltZW91dEtleSA9IHRpbWVvdXRLZXkgfHwgKytkZWxheWVkRm5Db3VudDtcbiAgICAgIHJ1bkF0TWlsbGlzID0gcnVuQXRNaWxsaXMgfHwgY3VycmVudFRpbWUgKyBtaWxsaXM7XG5cbiAgICAgIHZhciBmdW5jVG9TY2hlZHVsZSA9IHtcbiAgICAgICAgcnVuQXRNaWxsaXM6IHJ1bkF0TWlsbGlzLFxuICAgICAgICBmdW5jVG9DYWxsOiBmLFxuICAgICAgICByZWN1cnJpbmc6IHJlY3VycmluZyxcbiAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgIHRpbWVvdXRLZXk6IHRpbWVvdXRLZXksXG4gICAgICAgIG1pbGxpczogbWlsbGlzXG4gICAgICB9O1xuXG4gICAgICBpZiAocnVuQXRNaWxsaXMgaW4gc2NoZWR1bGVkRnVuY3Rpb25zKSB7XG4gICAgICAgIHNjaGVkdWxlZEZ1bmN0aW9uc1tydW5BdE1pbGxpc10ucHVzaChmdW5jVG9TY2hlZHVsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2hlZHVsZWRGdW5jdGlvbnNbcnVuQXRNaWxsaXNdID0gW2Z1bmNUb1NjaGVkdWxlXTtcbiAgICAgICAgc2NoZWR1bGVkTG9va3VwLnB1c2gocnVuQXRNaWxsaXMpO1xuICAgICAgICBzY2hlZHVsZWRMb29rdXAuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRpbWVvdXRLZXk7XG4gICAgfTtcblxuICAgIHNlbGYucmVtb3ZlRnVuY3Rpb25XaXRoSWQgPSBmdW5jdGlvbih0aW1lb3V0S2V5KSB7XG4gICAgICBkZWxldGVkS2V5cy5wdXNoKHRpbWVvdXRLZXkpO1xuXG4gICAgICBmb3IgKHZhciBydW5BdE1pbGxpcyBpbiBzY2hlZHVsZWRGdW5jdGlvbnMpIHtcbiAgICAgICAgdmFyIGZ1bmNzID0gc2NoZWR1bGVkRnVuY3Rpb25zW3J1bkF0TWlsbGlzXTtcbiAgICAgICAgdmFyIGkgPSBpbmRleE9mRmlyc3RUb1Bhc3MoZnVuY3MsIGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy50aW1lb3V0S2V5ID09PSB0aW1lb3V0S2V5O1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgaWYgKGZ1bmNzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgZGVsZXRlIHNjaGVkdWxlZEZ1bmN0aW9uc1tydW5BdE1pbGxpc107XG4gICAgICAgICAgICBkZWxldGVGcm9tTG9va3VwKHJ1bkF0TWlsbGlzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnVuY3Muc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGludGVydmFscyBnZXQgcmVzY2hlZHVsZWQgd2hlbiBleGVjdXRlZCwgc28gdGhlcmUncyBuZXZlciBtb3JlXG4gICAgICAgICAgLy8gdGhhbiBhIHNpbmdsZSBzY2hlZHVsZWQgZnVuY3Rpb24gd2l0aCBhIGdpdmVuIHRpbWVvdXRLZXlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcblxuICAgIGZ1bmN0aW9uIGluZGV4T2ZGaXJzdFRvUGFzcyhhcnJheSwgdGVzdEZuKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodGVzdEZuKGFycmF5W2ldKSkge1xuICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVsZXRlRnJvbUxvb2t1cChrZXkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IE51bWJlcihrZXkpO1xuICAgICAgdmFyIGkgPSBpbmRleE9mRmlyc3RUb1Bhc3Moc2NoZWR1bGVkTG9va3VwLCBmdW5jdGlvbihtaWxsaXMpIHtcbiAgICAgICAgcmV0dXJuIG1pbGxpcyA9PT0gdmFsdWU7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGkgPiAtMSkge1xuICAgICAgICBzY2hlZHVsZWRMb29rdXAuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2NoZWR1bGUoc2NoZWR1bGVkRm4pIHtcbiAgICAgIHNlbGYuc2NoZWR1bGVGdW5jdGlvbihcbiAgICAgICAgc2NoZWR1bGVkRm4uZnVuY1RvQ2FsbCxcbiAgICAgICAgc2NoZWR1bGVkRm4ubWlsbGlzLFxuICAgICAgICBzY2hlZHVsZWRGbi5wYXJhbXMsXG4gICAgICAgIHRydWUsXG4gICAgICAgIHNjaGVkdWxlZEZuLnRpbWVvdXRLZXksXG4gICAgICAgIHNjaGVkdWxlZEZuLnJ1bkF0TWlsbGlzICsgc2NoZWR1bGVkRm4ubWlsbGlzXG4gICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvckVhY2hGdW5jdGlvbihmdW5jc1RvUnVuLCBjYWxsYmFjaykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jc1RvUnVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNhbGxiYWNrKGZ1bmNzVG9SdW5baV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1blNjaGVkdWxlZEZ1bmN0aW9ucyhlbmRUaW1lLCB0aWNrRGF0ZSkge1xuICAgICAgdGlja0RhdGUgPSB0aWNrRGF0ZSB8fCBmdW5jdGlvbigpIHt9O1xuICAgICAgaWYgKHNjaGVkdWxlZExvb2t1cC5sZW5ndGggPT09IDAgfHwgc2NoZWR1bGVkTG9va3VwWzBdID4gZW5kVGltZSkge1xuICAgICAgICBpZiAoZW5kVGltZSA+PSBjdXJyZW50VGltZSkge1xuICAgICAgICAgIHRpY2tEYXRlKGVuZFRpbWUgLSBjdXJyZW50VGltZSk7XG4gICAgICAgICAgY3VycmVudFRpbWUgPSBlbmRUaW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZG8ge1xuICAgICAgICBkZWxldGVkS2V5cyA9IFtdO1xuICAgICAgICB2YXIgbmV3Q3VycmVudFRpbWUgPSBzY2hlZHVsZWRMb29rdXAuc2hpZnQoKTtcbiAgICAgICAgaWYgKG5ld0N1cnJlbnRUaW1lID49IGN1cnJlbnRUaW1lKSB7XG4gICAgICAgICAgdGlja0RhdGUobmV3Q3VycmVudFRpbWUgLSBjdXJyZW50VGltZSk7XG4gICAgICAgICAgY3VycmVudFRpbWUgPSBuZXdDdXJyZW50VGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmdW5jc1RvUnVuID0gc2NoZWR1bGVkRnVuY3Rpb25zW2N1cnJlbnRUaW1lXTtcblxuICAgICAgICBkZWxldGUgc2NoZWR1bGVkRnVuY3Rpb25zW2N1cnJlbnRUaW1lXTtcblxuICAgICAgICBmb3JFYWNoRnVuY3Rpb24oZnVuY3NUb1J1biwgZnVuY3Rpb24oZnVuY1RvUnVuKSB7XG4gICAgICAgICAgaWYgKGZ1bmNUb1J1bi5yZWN1cnJpbmcpIHtcbiAgICAgICAgICAgIHJlc2NoZWR1bGUoZnVuY1RvUnVuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvckVhY2hGdW5jdGlvbihmdW5jc1RvUnVuLCBmdW5jdGlvbihmdW5jVG9SdW4pIHtcbiAgICAgICAgICBpZiAoaiQudXRpbC5hcnJheUNvbnRhaW5zKGRlbGV0ZWRLZXlzLCBmdW5jVG9SdW4udGltZW91dEtleSkpIHtcbiAgICAgICAgICAgIC8vIHNraXAgYSB0aW1lb3V0S2V5IGRlbGV0ZWQgd2hpbHN0IHdlIHdlcmUgcnVubmluZ1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jVG9SdW4uZnVuY1RvQ2FsbC5hcHBseShudWxsLCBmdW5jVG9SdW4ucGFyYW1zIHx8IFtdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlbGV0ZWRLZXlzID0gW107XG4gICAgICB9IHdoaWxlIChcbiAgICAgICAgc2NoZWR1bGVkTG9va3VwLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgLy8gY2hlY2tpbmcgZmlyc3QgaWYgd2UncmUgb3V0IG9mIHRpbWUgcHJldmVudHMgc2V0VGltZW91dCgwKVxuICAgICAgICAvLyBzY2hlZHVsZWQgaW4gYSBmdW5jVG9SdW4gZnJvbSBmb3JjaW5nIGFuIGV4dHJhIGl0ZXJhdGlvblxuICAgICAgICBjdXJyZW50VGltZSAhPT0gZW5kVGltZSAmJlxuICAgICAgICBzY2hlZHVsZWRMb29rdXBbMF0gPD0gZW5kVGltZVxuICAgICAgKTtcblxuICAgICAgLy8gcmFuIG91dCBvZiBmdW5jdGlvbnMgdG8gY2FsbCwgYnV0IHN0aWxsIHRpbWUgbGVmdCBvbiB0aGUgY2xvY2tcbiAgICAgIGlmIChlbmRUaW1lID49IGN1cnJlbnRUaW1lKSB7XG4gICAgICAgIHRpY2tEYXRlKGVuZFRpbWUgLSBjdXJyZW50VGltZSk7XG4gICAgICAgIGN1cnJlbnRUaW1lID0gZW5kVGltZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gRGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5EZXByZWNhdG9yID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gRGVwcmVjYXRvcih0b3BTdWl0ZSkge1xuICAgIHRoaXMudG9wU3VpdGVfID0gdG9wU3VpdGU7XG4gICAgdGhpcy52ZXJib3NlXyA9IGZhbHNlO1xuICAgIHRoaXMudG9TdXBwcmVzc18gPSBbXTtcbiAgfVxuXG4gIHZhciB2ZXJib3NlTm90ZSA9XG4gICAgJ05vdGU6IFRoaXMgbWVzc2FnZSB3aWxsIGJlIHNob3duIG9ubHkgb25jZS4gU2V0IHRoZSB2ZXJib3NlRGVwcmVjYXRpb25zICcgK1xuICAgICdjb25maWcgcHJvcGVydHkgdG8gdHJ1ZSB0byBzZWUgZXZlcnkgb2NjdXJyZW5jZS4nO1xuXG4gIERlcHJlY2F0b3IucHJvdG90eXBlLnZlcmJvc2VEZXByZWNhdGlvbnMgPSBmdW5jdGlvbihlbmFibGVkKSB7XG4gICAgdGhpcy52ZXJib3NlXyA9IGVuYWJsZWQ7XG4gIH07XG5cbiAgLy8gcnVubmFibGUgaXMgYSBzcGVjIG9yIGEgc3VpdGUuXG4gIC8vIGRlcHJlY2F0aW9uIGlzIGEgc3RyaW5nIG9yIGFuIEVycm9yLlxuICAvLyBTZWUgRW52I2RlcHJlY2F0ZWQgZm9yIGEgZGVzY3JpcHRpb24gb2YgdGhlIG9wdGlvbnMgYXJndW1lbnQuXG4gIERlcHJlY2F0b3IucHJvdG90eXBlLmFkZERlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uKFxuICAgIHJ1bm5hYmxlLFxuICAgIGRlcHJlY2F0aW9uLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAoIXRoaXMudmVyYm9zZV8gJiYgIWokLmlzRXJyb3JfKGRlcHJlY2F0aW9uKSkge1xuICAgICAgaWYgKHRoaXMudG9TdXBwcmVzc18uaW5kZXhPZihkZXByZWNhdGlvbikgIT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMudG9TdXBwcmVzc18ucHVzaChkZXByZWNhdGlvbik7XG4gICAgfVxuXG4gICAgdGhpcy5sb2dfKHJ1bm5hYmxlLCBkZXByZWNhdGlvbiwgb3B0aW9ucyk7XG4gICAgdGhpcy5yZXBvcnRfKHJ1bm5hYmxlLCBkZXByZWNhdGlvbiwgb3B0aW9ucyk7XG4gIH07XG5cbiAgRGVwcmVjYXRvci5wcm90b3R5cGUubG9nXyA9IGZ1bmN0aW9uKHJ1bm5hYmxlLCBkZXByZWNhdGlvbiwgb3B0aW9ucykge1xuICAgIHZhciBjb250ZXh0O1xuXG4gICAgaWYgKGokLmlzRXJyb3JfKGRlcHJlY2F0aW9uKSkge1xuICAgICAgY29uc29sZS5lcnJvcihkZXByZWNhdGlvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHJ1bm5hYmxlID09PSB0aGlzLnRvcFN1aXRlXyB8fCBvcHRpb25zLmlnbm9yZVJ1bm5hYmxlKSB7XG4gICAgICBjb250ZXh0ID0gJyc7XG4gICAgfSBlbHNlIGlmIChydW5uYWJsZS5jaGlsZHJlbikge1xuICAgICAgY29udGV4dCA9ICcgKGluIHN1aXRlOiAnICsgcnVubmFibGUuZ2V0RnVsbE5hbWUoKSArICcpJztcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dCA9ICcgKGluIHNwZWM6ICcgKyBydW5uYWJsZS5nZXRGdWxsTmFtZSgpICsgJyknO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5vbWl0U3RhY2tUcmFjZSkge1xuICAgICAgY29udGV4dCArPSAnXFxuJyArIHRoaXMuc3RhY2tUcmFjZV8oKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMudmVyYm9zZV8pIHtcbiAgICAgIGNvbnRleHQgKz0gJ1xcbicgKyB2ZXJib3NlTm90ZTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmVycm9yKCdERVBSRUNBVElPTjogJyArIGRlcHJlY2F0aW9uICsgY29udGV4dCk7XG4gIH07XG5cbiAgRGVwcmVjYXRvci5wcm90b3R5cGUuc3RhY2tUcmFjZV8gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZm9ybWF0dGVyID0gbmV3IGokLkV4Y2VwdGlvbkZvcm1hdHRlcigpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIuc3RhY2soaiQudXRpbC5lcnJvcldpdGhTdGFjaygpKS5yZXBsYWNlKC9eRXJyb3JcXG4vbSwgJycpO1xuICB9O1xuXG4gIERlcHJlY2F0b3IucHJvdG90eXBlLnJlcG9ydF8gPSBmdW5jdGlvbihydW5uYWJsZSwgZGVwcmVjYXRpb24sIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5pZ25vcmVSdW5uYWJsZSkge1xuICAgICAgcnVubmFibGUgPSB0aGlzLnRvcFN1aXRlXztcbiAgICB9XG5cbiAgICBpZiAoaiQuaXNFcnJvcl8oZGVwcmVjYXRpb24pKSB7XG4gICAgICBydW5uYWJsZS5hZGREZXByZWNhdGlvbldhcm5pbmcoZGVwcmVjYXRpb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy52ZXJib3NlXykge1xuICAgICAgZGVwcmVjYXRpb24gKz0gJ1xcbicgKyB2ZXJib3NlTm90ZTtcbiAgICB9XG5cbiAgICBydW5uYWJsZS5hZGREZXByZWNhdGlvbldhcm5pbmcoe1xuICAgICAgbWVzc2FnZTogZGVwcmVjYXRpb24sXG4gICAgICBvbWl0U3RhY2tUcmFjZTogb3B0aW9ucy5vbWl0U3RhY2tUcmFjZSB8fCBmYWxzZVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBEZXByZWNhdG9yO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5lcnJvcnMgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gRXhwZWN0YXRpb25GYWlsZWQoKSB7fVxuXG4gIEV4cGVjdGF0aW9uRmFpbGVkLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuICBFeHBlY3RhdGlvbkZhaWxlZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFeHBlY3RhdGlvbkZhaWxlZDtcblxuICByZXR1cm4ge1xuICAgIEV4cGVjdGF0aW9uRmFpbGVkOiBFeHBlY3RhdGlvbkZhaWxlZFxuICB9O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5FeGNlcHRpb25Gb3JtYXR0ZXIgPSBmdW5jdGlvbihqJCkge1xuICB2YXIgaWdub3JlZFByb3BlcnRpZXMgPSBbXG4gICAgJ25hbWUnLFxuICAgICdtZXNzYWdlJyxcbiAgICAnc3RhY2snLFxuICAgICdmaWxlTmFtZScsXG4gICAgJ3NvdXJjZVVSTCcsXG4gICAgJ2xpbmUnLFxuICAgICdsaW5lTnVtYmVyJyxcbiAgICAnY29sdW1uJyxcbiAgICAnZGVzY3JpcHRpb24nLFxuICAgICdqYXNtaW5lTWVzc2FnZSdcbiAgXTtcblxuICBmdW5jdGlvbiBFeGNlcHRpb25Gb3JtYXR0ZXIob3B0aW9ucykge1xuICAgIHZhciBqYXNtaW5lRmlsZSA9IChvcHRpb25zICYmIG9wdGlvbnMuamFzbWluZUZpbGUpIHx8IGokLnV0aWwuamFzbWluZUZpbGUoKTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBmdW5jdGlvbihlcnJvcikge1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnJztcblxuICAgICAgaWYgKGVycm9yLmphc21pbmVNZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gZXJyb3IuamFzbWluZU1lc3NhZ2U7XG4gICAgICB9IGVsc2UgaWYgKGVycm9yLm5hbWUgJiYgZXJyb3IubWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlICs9IGVycm9yLm5hbWUgKyAnOiAnICsgZXJyb3IubWVzc2FnZTtcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3IubWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlICs9IGVycm9yLm1lc3NhZ2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlICs9IGVycm9yLnRvU3RyaW5nKCkgKyAnIHRocm93bic7XG4gICAgICB9XG5cbiAgICAgIGlmIChlcnJvci5maWxlTmFtZSB8fCBlcnJvci5zb3VyY2VVUkwpIHtcbiAgICAgICAgbWVzc2FnZSArPSAnIGluICcgKyAoZXJyb3IuZmlsZU5hbWUgfHwgZXJyb3Iuc291cmNlVVJMKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVycm9yLmxpbmUgfHwgZXJyb3IubGluZU51bWJlcikge1xuICAgICAgICBtZXNzYWdlICs9ICcgKGxpbmUgJyArIChlcnJvci5saW5lIHx8IGVycm9yLmxpbmVOdW1iZXIpICsgJyknO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuXG4gICAgdGhpcy5zdGFjayA9IGZ1bmN0aW9uKGVycm9yLCB7IG9taXRNZXNzYWdlIH0gPSB7fSkge1xuICAgICAgaWYgKCFlcnJvciB8fCAhZXJyb3Iuc3RhY2spIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFja1RyYWNlID0gbmV3IGokLlN0YWNrVHJhY2UoZXJyb3IpO1xuICAgICAgdmFyIGxpbmVzID0gZmlsdGVySmFzbWluZShzdGFja1RyYWNlKTtcbiAgICAgIHZhciByZXN1bHQgPSAnJztcblxuICAgICAgaWYgKHN0YWNrVHJhY2UubWVzc2FnZSAmJiAhb21pdE1lc3NhZ2UpIHtcbiAgICAgICAgbGluZXMudW5zaGlmdChzdGFja1RyYWNlLm1lc3NhZ2UpO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQgKz0gZm9ybWF0UHJvcGVydGllcyhlcnJvcik7XG4gICAgICByZXN1bHQgKz0gbGluZXMuam9pbignXFxuJyk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGZpbHRlckphc21pbmUoc3RhY2tUcmFjZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICBqYXNtaW5lTWFya2VyID1cbiAgICAgICAgICBzdGFja1RyYWNlLnN0eWxlID09PSAnd2Via2l0JyA/ICc8SmFzbWluZT4nIDogJyAgICBhdCA8SmFzbWluZT4nO1xuXG4gICAgICBzdGFja1RyYWNlLmZyYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKGZyYW1lKSB7XG4gICAgICAgIGlmIChmcmFtZS5maWxlICE9PSBqYXNtaW5lRmlsZSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYW1lLnJhdyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSAhPT0gamFzbWluZU1hcmtlcikge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGphc21pbmVNYXJrZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRQcm9wZXJ0aWVzKGVycm9yKSB7XG4gICAgICBpZiAoIShlcnJvciBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICB2YXIgZW1wdHkgPSB0cnVlO1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIGVycm9yKSB7XG4gICAgICAgIGlmIChqJC51dGlsLmFycmF5Q29udGFpbnMoaWdub3JlZFByb3BlcnRpZXMsIHByb3ApKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W3Byb3BdID0gZXJyb3JbcHJvcF07XG4gICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghZW1wdHkpIHtcbiAgICAgICAgcmV0dXJuICdlcnJvciBwcm9wZXJ0aWVzOiAnICsgaiQuYmFzaWNQcmV0dHlQcmludGVyXyhyZXN1bHQpICsgJ1xcbic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gRXhjZXB0aW9uRm9ybWF0dGVyO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5FeHBlY3RhdGlvbiA9IGZ1bmN0aW9uKGokKSB7XG4gIC8qKlxuICAgKiBNYXRjaGVycyB0aGF0IGNvbWUgd2l0aCBKYXNtaW5lIG91dCBvZiB0aGUgYm94LlxuICAgKiBAbmFtZXNwYWNlIG1hdGNoZXJzXG4gICAqL1xuICBmdW5jdGlvbiBFeHBlY3RhdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5leHBlY3RvciA9IG5ldyBqJC5FeHBlY3RvcihvcHRpb25zKTtcblxuICAgIHZhciBjdXN0b21NYXRjaGVycyA9IG9wdGlvbnMuY3VzdG9tTWF0Y2hlcnMgfHwge307XG4gICAgZm9yICh2YXIgbWF0Y2hlck5hbWUgaW4gY3VzdG9tTWF0Y2hlcnMpIHtcbiAgICAgIHRoaXNbbWF0Y2hlck5hbWVdID0gd3JhcFN5bmNDb21wYXJlKFxuICAgICAgICBtYXRjaGVyTmFtZSxcbiAgICAgICAgY3VzdG9tTWF0Y2hlcnNbbWF0Y2hlck5hbWVdXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgc29tZSBjb250ZXh0IGZvciBhbiB7QGxpbmsgZXhwZWN0fVxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjd2l0aENvbnRleHRcbiAgICogQHNpbmNlIDMuMy4wXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIC0gQWRkaXRpb25hbCBjb250ZXh0IHRvIHNob3cgd2hlbiB0aGUgbWF0Y2hlciBmYWlsc1xuICAgKiBAcmV0dXJuIHttYXRjaGVyc31cbiAgICovXG4gIEV4cGVjdGF0aW9uLnByb3RvdHlwZS53aXRoQ29udGV4dCA9IGZ1bmN0aW9uIHdpdGhDb250ZXh0KG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gYWRkRmlsdGVyKHRoaXMsIG5ldyBDb250ZXh0QWRkaW5nRmlsdGVyKG1lc3NhZ2UpKTtcbiAgfTtcblxuICAvKipcbiAgICogSW52ZXJ0IHRoZSBtYXRjaGVyIGZvbGxvd2luZyB0aGlzIHtAbGluayBleHBlY3R9XG4gICAqIEBtZW1iZXJcbiAgICogQG5hbWUgbWF0Y2hlcnMjbm90XG4gICAqIEBzaW5jZSAxLjMuMFxuICAgKiBAdHlwZSB7bWF0Y2hlcnN9XG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdChzb21ldGhpbmcpLm5vdC50b0JlKHRydWUpO1xuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV4cGVjdGF0aW9uLnByb3RvdHlwZSwgJ25vdCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFkZEZpbHRlcih0aGlzLCBzeW5jTmVnYXRpbmdGaWx0ZXIpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91cyBtYXRjaGVycyB0aGF0IG9wZXJhdGUgb24gYW4gYWN0dWFsIHZhbHVlIHdoaWNoIGlzIGEgcHJvbWlzZSxcbiAgICogYW5kIHJldHVybiBhIHByb21pc2UuXG4gICAqXG4gICAqIE1vc3QgYXN5bmMgbWF0Y2hlcnMgd2lsbCB3YWl0IGluZGVmaW5pdGVseSBmb3IgdGhlIHByb21pc2UgdG8gYmUgcmVzb2x2ZWRcbiAgICogb3IgcmVqZWN0ZWQsIHJlc3VsdGluZyBpbiBhIHNwZWMgdGltZW91dCBpZiB0aGF0IG5ldmVyIGhhcHBlbnMuIElmIHlvdVxuICAgKiBleHBlY3QgdGhhdCB0aGUgcHJvbWlzZSB3aWxsIGFscmVhZHkgYmUgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQgYXQgdGhlIHRpbWVcbiAgICogdGhlIG1hdGNoZXIgaXMgY2FsbGVkLCB5b3UgY2FuIHVzZSB0aGUge0BsaW5rIGFzeW5jLW1hdGNoZXJzI2FscmVhZHl9XG4gICAqIG1vZGlmaWVyIHRvIGdldCBhIGZhc3RlciBmYWlsdXJlIHdpdGggYSBtb3JlIGhlbHBmdWwgbWVzc2FnZS5cbiAgICpcbiAgICogTm90ZTogU3BlY3MgbXVzdCBhd2FpdCB0aGUgcmVzdWx0IG9mIGVhY2ggYXN5bmMgbWF0Y2hlciwgcmV0dXJuIHRoZVxuICAgKiBwcm9taXNlIHJldHVybmVkIGJ5IHRoZSBtYXRjaGVyLCBvciByZXR1cm4gYSBwcm9taXNlIHRoYXQncyBkZXJpdmVkIGZyb21cbiAgICogdGhlIG9uZSByZXR1cm5lZCBieSB0aGUgbWF0Y2hlci4gT3RoZXJ3aXNlIHRoZSBtYXRjaGVyIHdpbGwgbm90IGJlXG4gICAqIGV2YWx1YXRlZCBiZWZvcmUgdGhlIHNwZWMgY29tcGxldGVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBHb29kXG4gICAqIGF3YWl0IGV4cGVjdEFzeW5jKGFQcm9taXNlKS50b0JlUmVzb2x2ZWQoKTtcbiAgICogQGV4YW1wbGVcbiAgICogLy8gR29vZFxuICAgKiByZXR1cm4gZXhwZWN0QXN5bmMoYVByb21pc2UpLnRvQmVSZXNvbHZlZCgpO1xuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBHb29kXG4gICAqIHJldHVybiBleHBlY3RBc3luYyhhUHJvbWlzZSkudG9CZVJlc29sdmVkKClcbiAgICogIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgKiAgICAvLyBtb3JlIHNwZWMgY29kZVxuICAgKiAgfSk7XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEJhZFxuICAgKiBleHBlY3RBc3luYyhhUHJvbWlzZSkudG9CZVJlc29sdmVkKCk7XG4gICAqIEBuYW1lc3BhY2UgYXN5bmMtbWF0Y2hlcnNcbiAgICovXG4gIGZ1bmN0aW9uIEFzeW5jRXhwZWN0YXRpb24ob3B0aW9ucykge1xuICAgIHRoaXMuZXhwZWN0b3IgPSBuZXcgaiQuRXhwZWN0b3Iob3B0aW9ucyk7XG5cbiAgICB2YXIgY3VzdG9tQXN5bmNNYXRjaGVycyA9IG9wdGlvbnMuY3VzdG9tQXN5bmNNYXRjaGVycyB8fCB7fTtcbiAgICBmb3IgKHZhciBtYXRjaGVyTmFtZSBpbiBjdXN0b21Bc3luY01hdGNoZXJzKSB7XG4gICAgICB0aGlzW21hdGNoZXJOYW1lXSA9IHdyYXBBc3luY0NvbXBhcmUoXG4gICAgICAgIG1hdGNoZXJOYW1lLFxuICAgICAgICBjdXN0b21Bc3luY01hdGNoZXJzW21hdGNoZXJOYW1lXVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIHNvbWUgY29udGV4dCBmb3IgYW4ge0BsaW5rIGV4cGVjdEFzeW5jfVxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgYXN5bmMtbWF0Y2hlcnMjd2l0aENvbnRleHRcbiAgICogQHNpbmNlIDMuMy4wXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIC0gQWRkaXRpb25hbCBjb250ZXh0IHRvIHNob3cgd2hlbiB0aGUgYXN5bmMgbWF0Y2hlciBmYWlsc1xuICAgKiBAcmV0dXJuIHthc3luYy1tYXRjaGVyc31cbiAgICovXG4gIEFzeW5jRXhwZWN0YXRpb24ucHJvdG90eXBlLndpdGhDb250ZXh0ID0gZnVuY3Rpb24gd2l0aENvbnRleHQobWVzc2FnZSkge1xuICAgIHJldHVybiBhZGRGaWx0ZXIodGhpcywgbmV3IENvbnRleHRBZGRpbmdGaWx0ZXIobWVzc2FnZSkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnZlcnQgdGhlIG1hdGNoZXIgZm9sbG93aW5nIHRoaXMge0BsaW5rIGV4cGVjdEFzeW5jfVxuICAgKiBAbWVtYmVyXG4gICAqIEBuYW1lIGFzeW5jLW1hdGNoZXJzI25vdFxuICAgKiBAdHlwZSB7YXN5bmMtbWF0Y2hlcnN9XG4gICAqIEBleGFtcGxlXG4gICAqIGF3YWl0IGV4cGVjdEFzeW5jKG15UHJvbWlzZSkubm90LnRvQmVSZXNvbHZlZCgpO1xuICAgKiBAZXhhbXBsZVxuICAgKiByZXR1cm4gZXhwZWN0QXN5bmMobXlQcm9taXNlKS5ub3QudG9CZVJlc29sdmVkKCk7XG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXN5bmNFeHBlY3RhdGlvbi5wcm90b3R5cGUsICdub3QnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBhZGRGaWx0ZXIodGhpcywgYXN5bmNOZWdhdGluZ0ZpbHRlcik7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogRmFpbCBhcyBzb29uIGFzIHBvc3NpYmxlIGlmIHRoZSBhY3R1YWwgaXMgcGVuZGluZy5cbiAgICogT3RoZXJ3aXNlIGV2YWx1YXRlIHRoZSBtYXRjaGVyLlxuICAgKiBAbWVtYmVyXG4gICAqIEBuYW1lIGFzeW5jLW1hdGNoZXJzI2FscmVhZHlcbiAgICogQHNpbmNlIDMuOC4wXG4gICAqIEB0eXBlIHthc3luYy1tYXRjaGVyc31cbiAgICogQGV4YW1wbGVcbiAgICogYXdhaXQgZXhwZWN0QXN5bmMobXlQcm9taXNlKS5hbHJlYWR5LnRvQmVSZXNvbHZlZCgpO1xuICAgKiBAZXhhbXBsZVxuICAgKiByZXR1cm4gZXhwZWN0QXN5bmMobXlQcm9taXNlKS5hbHJlYWR5LnRvQmVSZXNvbHZlZCgpO1xuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFzeW5jRXhwZWN0YXRpb24ucHJvdG90eXBlLCAnYWxyZWFkeScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFkZEZpbHRlcih0aGlzLCBleHBlY3RTZXR0bGVkUHJvbWlzZUZpbHRlcik7XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiB3cmFwU3luY0NvbXBhcmUobmFtZSwgbWF0Y2hlckZhY3RvcnkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5leHBlY3Rvci5jb21wYXJlKG5hbWUsIG1hdGNoZXJGYWN0b3J5LCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy5leHBlY3Rvci5wcm9jZXNzUmVzdWx0KHJlc3VsdCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBBc3luY0NvbXBhcmUobmFtZSwgbWF0Y2hlckZhY3RvcnkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIENhcHR1cmUgdGhlIGNhbGwgc3RhY2sgaGVyZSwgYmVmb3JlIHdlIGdvIGFzeW5jLCBzbyB0aGF0IGl0IHdpbGwgY29udGFpblxuICAgICAgLy8gZnJhbWVzIHRoYXQgYXJlIHJlbGV2YW50IHRvIHRoZSB1c2VyIGluc3RlYWQgb2YganVzdCBwYXJ0cyBvZiBKYXNtaW5lLlxuICAgICAgdmFyIGVycm9yRm9yU3RhY2sgPSBqJC51dGlsLmVycm9yV2l0aFN0YWNrKCk7XG5cbiAgICAgIHJldHVybiB0aGlzLmV4cGVjdG9yXG4gICAgICAgIC5jb21wYXJlKG5hbWUsIG1hdGNoZXJGYWN0b3J5LCBhcmd1bWVudHMpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHNlbGYuZXhwZWN0b3IucHJvY2Vzc1Jlc3VsdChyZXN1bHQsIGVycm9yRm9yU3RhY2spO1xuICAgICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkQ29yZU1hdGNoZXJzKHByb3RvdHlwZSwgbWF0Y2hlcnMsIHdyYXBwZXIpIHtcbiAgICBmb3IgKHZhciBtYXRjaGVyTmFtZSBpbiBtYXRjaGVycykge1xuICAgICAgdmFyIG1hdGNoZXIgPSBtYXRjaGVyc1ttYXRjaGVyTmFtZV07XG4gICAgICBwcm90b3R5cGVbbWF0Y2hlck5hbWVdID0gd3JhcHBlcihtYXRjaGVyTmFtZSwgbWF0Y2hlcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkRmlsdGVyKHNvdXJjZSwgZmlsdGVyKSB7XG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUoc291cmNlKTtcbiAgICByZXN1bHQuZXhwZWN0b3IgPSBzb3VyY2UuZXhwZWN0b3IuYWRkRmlsdGVyKGZpbHRlcik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5lZ2F0ZWRGYWlsdXJlTWVzc2FnZShyZXN1bHQsIG1hdGNoZXJOYW1lLCBhcmdzLCBtYXRjaGVyc1V0aWwpIHtcbiAgICBpZiAocmVzdWx0Lm1lc3NhZ2UpIHtcbiAgICAgIGlmIChqJC5pc0Z1bmN0aW9uXyhyZXN1bHQubWVzc2FnZSkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5tZXNzYWdlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0Lm1lc3NhZ2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXJncyA9IGFyZ3Muc2xpY2UoKTtcbiAgICBhcmdzLnVuc2hpZnQodHJ1ZSk7XG4gICAgYXJncy51bnNoaWZ0KG1hdGNoZXJOYW1lKTtcbiAgICByZXR1cm4gbWF0Y2hlcnNVdGlsLmJ1aWxkRmFpbHVyZU1lc3NhZ2UuYXBwbHkobWF0Y2hlcnNVdGlsLCBhcmdzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5lZ2F0ZShyZXN1bHQpIHtcbiAgICByZXN1bHQucGFzcyA9ICFyZXN1bHQucGFzcztcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIHN5bmNOZWdhdGluZ0ZpbHRlciA9IHtcbiAgICBzZWxlY3RDb21wYXJpc29uRnVuYzogZnVuY3Rpb24obWF0Y2hlcikge1xuICAgICAgZnVuY3Rpb24gZGVmYXVsdE5lZ2F0aXZlQ29tcGFyZSgpIHtcbiAgICAgICAgcmV0dXJuIG5lZ2F0ZShtYXRjaGVyLmNvbXBhcmUuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXRjaGVyLm5lZ2F0aXZlQ29tcGFyZSB8fCBkZWZhdWx0TmVnYXRpdmVDb21wYXJlO1xuICAgIH0sXG4gICAgYnVpbGRGYWlsdXJlTWVzc2FnZTogbmVnYXRlZEZhaWx1cmVNZXNzYWdlXG4gIH07XG5cbiAgdmFyIGFzeW5jTmVnYXRpbmdGaWx0ZXIgPSB7XG4gICAgc2VsZWN0Q29tcGFyaXNvbkZ1bmM6IGZ1bmN0aW9uKG1hdGNoZXIpIHtcbiAgICAgIGZ1bmN0aW9uIGRlZmF1bHROZWdhdGl2ZUNvbXBhcmUoKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVyLmNvbXBhcmUuYXBwbHkodGhpcywgYXJndW1lbnRzKS50aGVuKG5lZ2F0ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXRjaGVyLm5lZ2F0aXZlQ29tcGFyZSB8fCBkZWZhdWx0TmVnYXRpdmVDb21wYXJlO1xuICAgIH0sXG4gICAgYnVpbGRGYWlsdXJlTWVzc2FnZTogbmVnYXRlZEZhaWx1cmVNZXNzYWdlXG4gIH07XG5cbiAgdmFyIGV4cGVjdFNldHRsZWRQcm9taXNlRmlsdGVyID0ge1xuICAgIHNlbGVjdENvbXBhcmlzb25GdW5jOiBmdW5jdGlvbihtYXRjaGVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYWN0dWFsKSB7XG4gICAgICAgIHZhciBtYXRjaGVyQXJncyA9IGFyZ3VtZW50cztcblxuICAgICAgICByZXR1cm4gaiQuaXNQZW5kaW5nXyhhY3R1YWwpLnRoZW4oZnVuY3Rpb24oaXNQZW5kaW5nKSB7XG4gICAgICAgICAgaWYgKGlzUGVuZGluZykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcGFzczogZmFsc2UsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAgICAgJ0V4cGVjdGVkIGEgcHJvbWlzZSB0byBiZSBzZXR0bGVkICh2aWEgJyArXG4gICAgICAgICAgICAgICAgJ2V4cGVjdEFzeW5jKC4uLikuYWxyZWFkeSkgYnV0IGl0IHdhcyBwZW5kaW5nLidcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVyLmNvbXBhcmUuYXBwbHkobnVsbCwgbWF0Y2hlckFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBDb250ZXh0QWRkaW5nRmlsdGVyKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9XG5cbiAgQ29udGV4dEFkZGluZ0ZpbHRlci5wcm90b3R5cGUubW9kaWZ5RmFpbHVyZU1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpIHtcbiAgICB2YXIgbmwgPSBtc2cuaW5kZXhPZignXFxuJyk7XG5cbiAgICBpZiAobmwgPT09IC0xKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXNzYWdlICsgJzogJyArIG1zZztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZSArICc6XFxuJyArIGluZGVudChtc2cpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBpbmRlbnQocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoL14vZ20sICcgICAgJyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgRXhwZWN0YXRpb24ob3B0aW9ucyB8fCB7fSk7XG4gICAgfSxcbiAgICBhZGRDb3JlTWF0Y2hlcnM6IGZ1bmN0aW9uKG1hdGNoZXJzKSB7XG4gICAgICBhZGRDb3JlTWF0Y2hlcnMoRXhwZWN0YXRpb24ucHJvdG90eXBlLCBtYXRjaGVycywgd3JhcFN5bmNDb21wYXJlKTtcbiAgICB9LFxuICAgIGFzeW5jRmFjdG9yeTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyBBc3luY0V4cGVjdGF0aW9uKG9wdGlvbnMgfHwge30pO1xuICAgIH0sXG4gICAgYWRkQXN5bmNDb3JlTWF0Y2hlcnM6IGZ1bmN0aW9uKG1hdGNoZXJzKSB7XG4gICAgICBhZGRDb3JlTWF0Y2hlcnMoQXN5bmNFeHBlY3RhdGlvbi5wcm90b3R5cGUsIG1hdGNoZXJzLCB3cmFwQXN5bmNDb21wYXJlKTtcbiAgICB9XG4gIH07XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkV4cGVjdGF0aW9uRmlsdGVyQ2hhaW4gPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gRXhwZWN0YXRpb25GaWx0ZXJDaGFpbihtYXliZUZpbHRlciwgcHJldikge1xuICAgIHRoaXMuZmlsdGVyXyA9IG1heWJlRmlsdGVyO1xuICAgIHRoaXMucHJldl8gPSBwcmV2O1xuICB9XG5cbiAgRXhwZWN0YXRpb25GaWx0ZXJDaGFpbi5wcm90b3R5cGUuYWRkRmlsdGVyID0gZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgcmV0dXJuIG5ldyBFeHBlY3RhdGlvbkZpbHRlckNoYWluKGZpbHRlciwgdGhpcyk7XG4gIH07XG5cbiAgRXhwZWN0YXRpb25GaWx0ZXJDaGFpbi5wcm90b3R5cGUuc2VsZWN0Q29tcGFyaXNvbkZ1bmMgPSBmdW5jdGlvbihtYXRjaGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FsbEZpcnN0Xygnc2VsZWN0Q29tcGFyaXNvbkZ1bmMnLCBhcmd1bWVudHMpLnJlc3VsdDtcbiAgfTtcblxuICBFeHBlY3RhdGlvbkZpbHRlckNoYWluLnByb3RvdHlwZS5idWlsZEZhaWx1cmVNZXNzYWdlID0gZnVuY3Rpb24oXG4gICAgcmVzdWx0LFxuICAgIG1hdGNoZXJOYW1lLFxuICAgIGFyZ3MsXG4gICAgbWF0Y2hlcnNVdGlsXG4gICkge1xuICAgIHJldHVybiB0aGlzLmNhbGxGaXJzdF8oJ2J1aWxkRmFpbHVyZU1lc3NhZ2UnLCBhcmd1bWVudHMpLnJlc3VsdDtcbiAgfTtcblxuICBFeHBlY3RhdGlvbkZpbHRlckNoYWluLnByb3RvdHlwZS5tb2RpZnlGYWlsdXJlTWVzc2FnZSA9IGZ1bmN0aW9uKG1zZykge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLmNhbGxGaXJzdF8oJ21vZGlmeUZhaWx1cmVNZXNzYWdlJywgYXJndW1lbnRzKS5yZXN1bHQ7XG4gICAgcmV0dXJuIHJlc3VsdCB8fCBtc2c7XG4gIH07XG5cbiAgRXhwZWN0YXRpb25GaWx0ZXJDaGFpbi5wcm90b3R5cGUuY2FsbEZpcnN0XyA9IGZ1bmN0aW9uKGZuYW1lLCBhcmdzKSB7XG4gICAgdmFyIHByZXZSZXN1bHQ7XG5cbiAgICBpZiAodGhpcy5wcmV2Xykge1xuICAgICAgcHJldlJlc3VsdCA9IHRoaXMucHJldl8uY2FsbEZpcnN0XyhmbmFtZSwgYXJncyk7XG5cbiAgICAgIGlmIChwcmV2UmVzdWx0LmZvdW5kKSB7XG4gICAgICAgIHJldHVybiBwcmV2UmVzdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmZpbHRlcl8gJiYgdGhpcy5maWx0ZXJfW2ZuYW1lXSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZm91bmQ6IHRydWUsXG4gICAgICAgIHJlc3VsdDogdGhpcy5maWx0ZXJfW2ZuYW1lXS5hcHBseSh0aGlzLmZpbHRlcl8sIGFyZ3MpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7IGZvdW5kOiBmYWxzZSB9O1xuICB9O1xuXG4gIHJldHVybiBFeHBlY3RhdGlvbkZpbHRlckNoYWluO1xufTtcblxuLy9UT0RPOiBleHBlY3RhdGlvbiByZXN1bHQgbWF5IG1ha2UgbW9yZSBzZW5zZSBhcyBhIHByZXNlbnRhdGlvbiBvZiBhbiBleHBlY3RhdGlvbi5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuYnVpbGRFeHBlY3RhdGlvblJlc3VsdCA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIGJ1aWxkRXhwZWN0YXRpb25SZXN1bHQob3B0aW9ucykge1xuICAgIHZhciBtZXNzYWdlRm9ybWF0dGVyID0gb3B0aW9ucy5tZXNzYWdlRm9ybWF0dGVyIHx8IGZ1bmN0aW9uKCkge30sXG4gICAgICBzdGFja0Zvcm1hdHRlciA9IG9wdGlvbnMuc3RhY2tGb3JtYXR0ZXIgfHwgZnVuY3Rpb24oKSB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIEV4cGVjdGF0aW9uXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IG1hdGNoZXJOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIG1hdGNoZXIgdGhhdCB3YXMgZXhlY3V0ZWQgZm9yIHRoaXMgZXhwZWN0YXRpb24uXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IG1lc3NhZ2UgLSBUaGUgZmFpbHVyZSBtZXNzYWdlIGZvciB0aGUgZXhwZWN0YXRpb24uXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IHN0YWNrIC0gVGhlIHN0YWNrIHRyYWNlIGZvciB0aGUgZmFpbHVyZSBpZiBhdmFpbGFibGUuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBwYXNzZWQgLSBXaGV0aGVyIHRoZSBleHBlY3RhdGlvbiBwYXNzZWQgb3IgZmFpbGVkLlxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBleHBlY3RlZCAtIElmIHRoZSBleHBlY3RhdGlvbiBmYWlsZWQsIHdoYXQgd2FzIHRoZSBleHBlY3RlZCB2YWx1ZS5cbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gYWN0dWFsIC0gSWYgdGhlIGV4cGVjdGF0aW9uIGZhaWxlZCwgd2hhdCBhY3R1YWwgdmFsdWUgd2FzIHByb2R1Y2VkLlxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfHVuZGVmaW5lZH0gZ2xvYmFsRXJyb3JUeXBlIC0gVGhlIHR5cGUgb2YgYW4gZXJyb3IgdGhhdFxuICAgICAqIGlzIHJlcG9ydGVkIG9uIHRoZSB0b3Agc3VpdGUuIFZhbGlkIHZhbHVlcyBhcmUgdW5kZWZpbmVkLCBcImFmdGVyQWxsXCIsXG4gICAgICogXCJsb2FkXCIsIFwibGF0ZUV4cGVjdGF0aW9uXCIsIGFuZCBcImxhdGVFcnJvclwiLlxuICAgICAqL1xuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICBtYXRjaGVyTmFtZTogb3B0aW9ucy5tYXRjaGVyTmFtZSxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UoKSxcbiAgICAgIHN0YWNrOiBvcHRpb25zLm9taXRTdGFja1RyYWNlID8gJycgOiBzdGFjaygpLFxuICAgICAgcGFzc2VkOiBvcHRpb25zLnBhc3NlZFxuICAgIH07XG5cbiAgICBpZiAoIXJlc3VsdC5wYXNzZWQpIHtcbiAgICAgIHJlc3VsdC5leHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gICAgICByZXN1bHQuYWN0dWFsID0gb3B0aW9ucy5hY3R1YWw7XG5cbiAgICAgIGlmIChvcHRpb25zLmVycm9yICYmICFqJC5pc1N0cmluZ18ob3B0aW9ucy5lcnJvcikpIHtcbiAgICAgICAgaWYgKCdjb2RlJyBpbiBvcHRpb25zLmVycm9yKSB7XG4gICAgICAgICAgcmVzdWx0LmNvZGUgPSBvcHRpb25zLmVycm9yLmNvZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgb3B0aW9ucy5lcnJvci5jb2RlID09PSAnRVJSX0FTU0VSVElPTicgJiZcbiAgICAgICAgICBvcHRpb25zLmV4cGVjdGVkID09PSAnJyAmJlxuICAgICAgICAgIG9wdGlvbnMuYWN0dWFsID09PSAnJ1xuICAgICAgICApIHtcbiAgICAgICAgICByZXN1bHQuZXhwZWN0ZWQgPSBvcHRpb25zLmVycm9yLmV4cGVjdGVkO1xuICAgICAgICAgIHJlc3VsdC5hY3R1YWwgPSBvcHRpb25zLmVycm9yLmFjdHVhbDtcbiAgICAgICAgICByZXN1bHQubWF0Y2hlck5hbWUgPSAnYXNzZXJ0ICcgKyBvcHRpb25zLmVycm9yLm9wZXJhdG9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGZ1bmN0aW9uIG1lc3NhZ2UoKSB7XG4gICAgICBpZiAob3B0aW9ucy5wYXNzZWQpIHtcbiAgICAgICAgcmV0dXJuICdQYXNzZWQuJztcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5tZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLm1lc3NhZ2U7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VGb3JtYXR0ZXIob3B0aW9ucy5lcnJvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhY2soKSB7XG4gICAgICBpZiAob3B0aW9ucy5wYXNzZWQpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXJyb3IgPSBvcHRpb25zLmVycm9yO1xuICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICBpZiAob3B0aW9ucy5lcnJvckZvclN0YWNrKSB7XG4gICAgICAgICAgZXJyb3IgPSBvcHRpb25zLmVycm9yRm9yU3RhY2s7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zdGFjaykge1xuICAgICAgICAgIGVycm9yID0gb3B0aW9ucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UoKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gT21pdCB0aGUgbWVzc2FnZSBmcm9tIHRoZSBzdGFjayB0cmFjZSBiZWNhdXNlIGl0IHdpbGwgYmVcbiAgICAgIC8vIGluY2x1ZGVkIGVsc2V3aGVyZS5cbiAgICAgIHJldHVybiBzdGFja0Zvcm1hdHRlcihlcnJvciwgeyBvbWl0TWVzc2FnZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVpbGRFeHBlY3RhdGlvblJlc3VsdDtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuRXhwZWN0b3IgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBFeHBlY3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5tYXRjaGVyc1V0aWwgPSBvcHRpb25zLm1hdGNoZXJzVXRpbCB8fCB7XG4gICAgICBidWlsZEZhaWx1cmVNZXNzYWdlOiBmdW5jdGlvbigpIHt9XG4gICAgfTtcbiAgICB0aGlzLmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xuICAgIHRoaXMuYWRkRXhwZWN0YXRpb25SZXN1bHQgPSBvcHRpb25zLmFkZEV4cGVjdGF0aW9uUmVzdWx0IHx8IGZ1bmN0aW9uKCkge307XG4gICAgdGhpcy5maWx0ZXJzID0gbmV3IGokLkV4cGVjdGF0aW9uRmlsdGVyQ2hhaW4oKTtcbiAgfVxuXG4gIEV4cGVjdG9yLnByb3RvdHlwZS5pbnN0YW50aWF0ZU1hdGNoZXIgPSBmdW5jdGlvbihcbiAgICBtYXRjaGVyTmFtZSxcbiAgICBtYXRjaGVyRmFjdG9yeSxcbiAgICBhcmdzXG4gICkge1xuICAgIHRoaXMubWF0Y2hlck5hbWUgPSBtYXRjaGVyTmFtZTtcbiAgICB0aGlzLmFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAwKTtcbiAgICB0aGlzLmV4cGVjdGVkID0gdGhpcy5hcmdzLnNsaWNlKDApO1xuXG4gICAgdGhpcy5hcmdzLnVuc2hpZnQodGhpcy5hY3R1YWwpO1xuXG4gICAgdmFyIG1hdGNoZXIgPSBtYXRjaGVyRmFjdG9yeSh0aGlzLm1hdGNoZXJzVXRpbCk7XG5cbiAgICB2YXIgY29tcGFyaXNvbkZ1bmMgPSB0aGlzLmZpbHRlcnMuc2VsZWN0Q29tcGFyaXNvbkZ1bmMobWF0Y2hlcik7XG4gICAgcmV0dXJuIGNvbXBhcmlzb25GdW5jIHx8IG1hdGNoZXIuY29tcGFyZTtcbiAgfTtcblxuICBFeHBlY3Rvci5wcm90b3R5cGUuYnVpbGRNZXNzYWdlID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHJlc3VsdC5wYXNzKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgdmFyIG1zZyA9IHRoaXMuZmlsdGVycy5idWlsZEZhaWx1cmVNZXNzYWdlKFxuICAgICAgcmVzdWx0LFxuICAgICAgdGhpcy5tYXRjaGVyTmFtZSxcbiAgICAgIHRoaXMuYXJncyxcbiAgICAgIHRoaXMubWF0Y2hlcnNVdGlsLFxuICAgICAgZGVmYXVsdE1lc3NhZ2VcbiAgICApO1xuICAgIHJldHVybiB0aGlzLmZpbHRlcnMubW9kaWZ5RmFpbHVyZU1lc3NhZ2UobXNnIHx8IGRlZmF1bHRNZXNzYWdlKCkpO1xuXG4gICAgZnVuY3Rpb24gZGVmYXVsdE1lc3NhZ2UoKSB7XG4gICAgICBpZiAoIXJlc3VsdC5tZXNzYWdlKSB7XG4gICAgICAgIHZhciBhcmdzID0gc2VsZi5hcmdzLnNsaWNlKCk7XG4gICAgICAgIGFyZ3MudW5zaGlmdChmYWxzZSk7XG4gICAgICAgIGFyZ3MudW5zaGlmdChzZWxmLm1hdGNoZXJOYW1lKTtcbiAgICAgICAgcmV0dXJuIHNlbGYubWF0Y2hlcnNVdGlsLmJ1aWxkRmFpbHVyZU1lc3NhZ2UuYXBwbHkoXG4gICAgICAgICAgc2VsZi5tYXRjaGVyc1V0aWwsXG4gICAgICAgICAgYXJnc1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChqJC5pc0Z1bmN0aW9uXyhyZXN1bHQubWVzc2FnZSkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5tZXNzYWdlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0Lm1lc3NhZ2U7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEV4cGVjdG9yLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24obWF0Y2hlck5hbWUsIG1hdGNoZXJGYWN0b3J5LCBhcmdzKSB7XG4gICAgdmFyIG1hdGNoZXJDb21wYXJlID0gdGhpcy5pbnN0YW50aWF0ZU1hdGNoZXIoXG4gICAgICBtYXRjaGVyTmFtZSxcbiAgICAgIG1hdGNoZXJGYWN0b3J5LFxuICAgICAgYXJnc1xuICAgICk7XG4gICAgcmV0dXJuIG1hdGNoZXJDb21wYXJlLmFwcGx5KG51bGwsIHRoaXMuYXJncyk7XG4gIH07XG5cbiAgRXhwZWN0b3IucHJvdG90eXBlLmFkZEZpbHRlciA9IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKHRoaXMpO1xuICAgIHJlc3VsdC5maWx0ZXJzID0gdGhpcy5maWx0ZXJzLmFkZEZpbHRlcihmaWx0ZXIpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgRXhwZWN0b3IucHJvdG90eXBlLnByb2Nlc3NSZXN1bHQgPSBmdW5jdGlvbihyZXN1bHQsIGVycm9yRm9yU3RhY2spIHtcbiAgICB2YXIgbWVzc2FnZSA9IHRoaXMuYnVpbGRNZXNzYWdlKHJlc3VsdCk7XG5cbiAgICBpZiAodGhpcy5leHBlY3RlZC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuZXhwZWN0ZWQgPSB0aGlzLmV4cGVjdGVkWzBdO1xuICAgIH1cblxuICAgIHRoaXMuYWRkRXhwZWN0YXRpb25SZXN1bHQocmVzdWx0LnBhc3MsIHtcbiAgICAgIG1hdGNoZXJOYW1lOiB0aGlzLm1hdGNoZXJOYW1lLFxuICAgICAgcGFzc2VkOiByZXN1bHQucGFzcyxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBlcnJvcjogZXJyb3JGb3JTdGFjayA/IHVuZGVmaW5lZCA6IHJlc3VsdC5lcnJvcixcbiAgICAgIGVycm9yRm9yU3RhY2s6IGVycm9yRm9yU3RhY2sgfHwgdW5kZWZpbmVkLFxuICAgICAgYWN0dWFsOiB0aGlzLmFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiB0aGlzLmV4cGVjdGVkIC8vIFRPRE86IHRoaXMgbWF5IG5lZWQgdG8gYmUgYXJyYXlpZmllZC9zbGljZWRcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gRXhwZWN0b3I7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLmZvcm1hdEVycm9yTXNnID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIGdlbmVyYXRlRXJyb3JNc2coZG9tYWluLCB1c2FnZSkge1xuICAgIHZhciB1c2FnZURlZmluaXRpb24gPSB1c2FnZSA/ICdcXG5Vc2FnZTogJyArIHVzYWdlIDogJyc7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gZXJyb3JNc2cobXNnKSB7XG4gICAgICByZXR1cm4gZG9tYWluICsgJyA6ICcgKyBtc2cgKyB1c2FnZURlZmluaXRpb247XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBnZW5lcmF0ZUVycm9yTXNnO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5HbG9iYWxFcnJvcnMgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBHbG9iYWxFcnJvcnMoZ2xvYmFsKSB7XG4gICAgdmFyIGhhbmRsZXJzID0gW107XG4gICAgZ2xvYmFsID0gZ2xvYmFsIHx8IGokLmdldEdsb2JhbCgpO1xuXG4gICAgdmFyIG9uZXJyb3IgPSBmdW5jdGlvbiBvbmVycm9yKCkge1xuICAgICAgdmFyIGhhbmRsZXIgPSBoYW5kbGVyc1toYW5kbGVycy5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgaGFuZGxlci5hcHBseShudWxsLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5vcmlnaW5hbEhhbmRsZXJzID0ge307XG4gICAgdGhpcy5qYXNtaW5lSGFuZGxlcnMgPSB7fTtcbiAgICB0aGlzLmluc3RhbGxPbmVfID0gZnVuY3Rpb24gaW5zdGFsbE9uZV8oZXJyb3JUeXBlLCBqYXNtaW5lTWVzc2FnZSkge1xuICAgICAgZnVuY3Rpb24gdGFnZ2VkT25FcnJvcihlcnJvcikge1xuICAgICAgICB2YXIgc3Vic3RpdHV0ZU1zZztcblxuICAgICAgICBpZiAoaiQuaXNFcnJvcl8oZXJyb3IpKSB7XG4gICAgICAgICAgZXJyb3IuamFzbWluZU1lc3NhZ2UgPSBqYXNtaW5lTWVzc2FnZSArICc6ICcgKyBlcnJvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHN1YnN0aXR1dGVNc2cgPSBqYXNtaW5lTWVzc2FnZSArICc6ICcgKyBlcnJvcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3Vic3RpdHV0ZU1zZyA9IGphc21pbmVNZXNzYWdlICsgJyB3aXRoIG5vIGVycm9yIG9yIG1lc3NhZ2UnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlcnJvclR5cGUgPT09ICd1bmhhbmRsZWRSZWplY3Rpb24nKSB7XG4gICAgICAgICAgICBzdWJzdGl0dXRlTXNnICs9XG4gICAgICAgICAgICAgICdcXG4nICtcbiAgICAgICAgICAgICAgJyhUaXA6IHRvIGdldCBhIHVzZWZ1bCBzdGFjayB0cmFjZSwgdXNlICcgK1xuICAgICAgICAgICAgICAnUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKC4uLikpIGluc3RlYWQgb2YgUHJvbWlzZS5yZWplY3QoJyArXG4gICAgICAgICAgICAgIChlcnJvciA/ICcuLi4nIDogJycpICtcbiAgICAgICAgICAgICAgJykuKSc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3Ioc3Vic3RpdHV0ZU1zZyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFuZGxlciA9IGhhbmRsZXJzW2hhbmRsZXJzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgaGFuZGxlcihlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5vcmlnaW5hbEhhbmRsZXJzW2Vycm9yVHlwZV0gPSBnbG9iYWwucHJvY2Vzcy5saXN0ZW5lcnMoZXJyb3JUeXBlKTtcbiAgICAgIHRoaXMuamFzbWluZUhhbmRsZXJzW2Vycm9yVHlwZV0gPSB0YWdnZWRPbkVycm9yO1xuXG4gICAgICBnbG9iYWwucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMoZXJyb3JUeXBlKTtcbiAgICAgIGdsb2JhbC5wcm9jZXNzLm9uKGVycm9yVHlwZSwgdGFnZ2VkT25FcnJvcik7XG5cbiAgICAgIHRoaXMudW5pbnN0YWxsID0gZnVuY3Rpb24gdW5pbnN0YWxsKCkge1xuICAgICAgICB2YXIgZXJyb3JUeXBlcyA9IE9iamVjdC5rZXlzKHRoaXMub3JpZ2luYWxIYW5kbGVycyk7XG4gICAgICAgIGZvciAodmFyIGlUeXBlID0gMDsgaVR5cGUgPCBlcnJvclR5cGVzLmxlbmd0aDsgaVR5cGUrKykge1xuICAgICAgICAgIHZhciBlcnJvclR5cGUgPSBlcnJvclR5cGVzW2lUeXBlXTtcbiAgICAgICAgICBnbG9iYWwucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lcihcbiAgICAgICAgICAgIGVycm9yVHlwZSxcbiAgICAgICAgICAgIHRoaXMuamFzbWluZUhhbmRsZXJzW2Vycm9yVHlwZV1cbiAgICAgICAgICApO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vcmlnaW5hbEhhbmRsZXJzW2Vycm9yVHlwZV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGdsb2JhbC5wcm9jZXNzLm9uKGVycm9yVHlwZSwgdGhpcy5vcmlnaW5hbEhhbmRsZXJzW2Vycm9yVHlwZV1baV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWxldGUgdGhpcy5vcmlnaW5hbEhhbmRsZXJzW2Vycm9yVHlwZV07XG4gICAgICAgICAgZGVsZXRlIHRoaXMuamFzbWluZUhhbmRsZXJzW2Vycm9yVHlwZV07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIHRoaXMuaW5zdGFsbCA9IGZ1bmN0aW9uIGluc3RhbGwoKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGdsb2JhbC5wcm9jZXNzICYmXG4gICAgICAgIGdsb2JhbC5wcm9jZXNzLmxpc3RlbmVycyAmJlxuICAgICAgICBqJC5pc0Z1bmN0aW9uXyhnbG9iYWwucHJvY2Vzcy5vbilcbiAgICAgICkge1xuICAgICAgICB0aGlzLmluc3RhbGxPbmVfKCd1bmNhdWdodEV4Y2VwdGlvbicsICdVbmNhdWdodCBleGNlcHRpb24nKTtcbiAgICAgICAgdGhpcy5pbnN0YWxsT25lXygndW5oYW5kbGVkUmVqZWN0aW9uJywgJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsSGFuZGxlciA9IGdsb2JhbC5vbmVycm9yO1xuICAgICAgICBnbG9iYWwub25lcnJvciA9IG9uZXJyb3I7XG5cbiAgICAgICAgdmFyIGJyb3dzZXJSZWplY3Rpb25IYW5kbGVyID0gZnVuY3Rpb24gYnJvd3NlclJlamVjdGlvbkhhbmRsZXIoZXZlbnQpIHtcbiAgICAgICAgICBpZiAoaiQuaXNFcnJvcl8oZXZlbnQucmVhc29uKSkge1xuICAgICAgICAgICAgZXZlbnQucmVhc29uLmphc21pbmVNZXNzYWdlID1cbiAgICAgICAgICAgICAgJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbjogJyArIGV2ZW50LnJlYXNvbjtcbiAgICAgICAgICAgIGdsb2JhbC5vbmVycm9yKGV2ZW50LnJlYXNvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5vbmVycm9yKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb246ICcgKyBldmVudC5yZWFzb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICd1bmhhbmRsZWRyZWplY3Rpb24nLFxuICAgICAgICAgICAgYnJvd3NlclJlamVjdGlvbkhhbmRsZXJcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51bmluc3RhbGwgPSBmdW5jdGlvbiB1bmluc3RhbGwoKSB7XG4gICAgICAgICAgZ2xvYmFsLm9uZXJyb3IgPSBvcmlnaW5hbEhhbmRsZXI7XG4gICAgICAgICAgaWYgKGdsb2JhbC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgJ3VuaGFuZGxlZHJlamVjdGlvbicsXG4gICAgICAgICAgICAgIGJyb3dzZXJSZWplY3Rpb25IYW5kbGVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5wdXNoTGlzdGVuZXIgPSBmdW5jdGlvbiBwdXNoTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgIGhhbmRsZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH07XG5cbiAgICB0aGlzLnBvcExpc3RlbmVyID0gZnVuY3Rpb24gcG9wTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgIGlmICghbGlzdGVuZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb3BMaXN0ZW5lciBleHBlY3RzIGEgbGlzdGVuZXInKTtcbiAgICAgIH1cblxuICAgICAgaGFuZGxlcnMucG9wKCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBHbG9iYWxFcnJvcnM7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVQZW5kaW5nID0gZnVuY3Rpb24oaiQpIHtcbiAgLyoqXG4gICAqIEV4cGVjdCBhIHByb21pc2UgdG8gYmUgcGVuZGluZywgaS5lLiB0aGUgcHJvbWlzZSBpcyBuZWl0aGVyIHJlc29sdmVkIG5vciByZWplY3RlZC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBhc3luY1xuICAgKiBAbmFtZSBhc3luYy1tYXRjaGVycyN0b0JlUGVuZGluZ1xuICAgKiBAc2luY2UgMy42XG4gICAqIEBleGFtcGxlXG4gICAqIGF3YWl0IGV4cGVjdEFzeW5jKGFQcm9taXNlKS50b0JlUGVuZGluZygpO1xuICAgKi9cbiAgcmV0dXJuIGZ1bmN0aW9uIHRvQmVQZW5kaW5nKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwpIHtcbiAgICAgICAgaWYgKCFqJC5pc1Byb21pc2VMaWtlKGFjdHVhbCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvQmVQZW5kaW5nIHRvIGJlIGNhbGxlZCBvbiBhIHByb21pc2UuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdhbnQgPSB7fTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbYWN0dWFsLCBQcm9taXNlLnJlc29sdmUod2FudCldKS50aGVuKFxuICAgICAgICAgIGZ1bmN0aW9uKGdvdCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcGFzczogd2FudCA9PT0gZ290IH07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHBhc3M6IGZhbHNlIH07XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVSZWplY3RlZCA9IGZ1bmN0aW9uKGokKSB7XG4gIC8qKlxuICAgKiBFeHBlY3QgYSBwcm9taXNlIHRvIGJlIHJlamVjdGVkLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQGFzeW5jXG4gICAqIEBuYW1lIGFzeW5jLW1hdGNoZXJzI3RvQmVSZWplY3RlZFxuICAgKiBAc2luY2UgMy4xLjBcbiAgICogQGV4YW1wbGVcbiAgICogYXdhaXQgZXhwZWN0QXN5bmMoYVByb21pc2UpLnRvQmVSZWplY3RlZCgpO1xuICAgKiBAZXhhbXBsZVxuICAgKiByZXR1cm4gZXhwZWN0QXN5bmMoYVByb21pc2UpLnRvQmVSZWplY3RlZCgpO1xuICAgKi9cbiAgcmV0dXJuIGZ1bmN0aW9uIHRvQmVSZWplY3RlZCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsKSB7XG4gICAgICAgIGlmICghaiQuaXNQcm9taXNlTGlrZShhY3R1YWwpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0b0JlUmVqZWN0ZWQgdG8gYmUgY2FsbGVkIG9uIGEgcHJvbWlzZS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0dWFsLnRoZW4oXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4geyBwYXNzOiBmYWxzZSB9O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4geyBwYXNzOiB0cnVlIH07XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVSZWplY3RlZFdpdGggPSBmdW5jdGlvbihqJCkge1xuICAvKipcbiAgICogRXhwZWN0IGEgcHJvbWlzZSB0byBiZSByZWplY3RlZCB3aXRoIGEgdmFsdWUgZXF1YWwgdG8gdGhlIGV4cGVjdGVkLCB1c2luZyBkZWVwIGVxdWFsaXR5IGNvbXBhcmlzb24uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAYXN5bmNcbiAgICogQG5hbWUgYXN5bmMtbWF0Y2hlcnMjdG9CZVJlamVjdGVkV2l0aFxuICAgKiBAc2luY2UgMy4zLjBcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4cGVjdGVkIC0gVmFsdWUgdGhhdCB0aGUgcHJvbWlzZSBpcyBleHBlY3RlZCB0byBiZSByZWplY3RlZCB3aXRoXG4gICAqIEBleGFtcGxlXG4gICAqIGF3YWl0IGV4cGVjdEFzeW5jKGFQcm9taXNlKS50b0JlUmVqZWN0ZWRXaXRoKHtwcm9wOiAndmFsdWUnfSk7XG4gICAqIEBleGFtcGxlXG4gICAqIHJldHVybiBleHBlY3RBc3luYyhhUHJvbWlzZSkudG9CZVJlamVjdGVkV2l0aCh7cHJvcDogJ3ZhbHVlJ30pO1xuICAgKi9cbiAgcmV0dXJuIGZ1bmN0aW9uIHRvQmVSZWplY3RlZFdpdGgobWF0Y2hlcnNVdGlsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbFByb21pc2UsIGV4cGVjdGVkVmFsdWUpIHtcbiAgICAgICAgaWYgKCFqJC5pc1Byb21pc2VMaWtlKGFjdHVhbFByb21pc2UpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0V4cGVjdGVkIHRvQmVSZWplY3RlZFdpdGggdG8gYmUgY2FsbGVkIG9uIGEgcHJvbWlzZS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHByZWZpeChwYXNzZWQpIHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgJ0V4cGVjdGVkIGEgcHJvbWlzZSAnICtcbiAgICAgICAgICAgIChwYXNzZWQgPyAnbm90ICcgOiAnJykgK1xuICAgICAgICAgICAgJ3RvIGJlIHJlamVjdGVkIHdpdGggJyArXG4gICAgICAgICAgICBtYXRjaGVyc1V0aWwucHAoZXhwZWN0ZWRWYWx1ZSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFjdHVhbFByb21pc2UudGhlbihcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHBhc3M6IGZhbHNlLFxuICAgICAgICAgICAgICBtZXNzYWdlOiBwcmVmaXgoZmFsc2UpICsgJyBidXQgaXQgd2FzIHJlc29sdmVkLidcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihhY3R1YWxWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKG1hdGNoZXJzVXRpbC5lcXVhbHMoYWN0dWFsVmFsdWUsIGV4cGVjdGVkVmFsdWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcGFzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBwcmVmaXgodHJ1ZSkgKyAnLidcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcGFzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgICAgIHByZWZpeChmYWxzZSkgK1xuICAgICAgICAgICAgICAgICAgJyBidXQgaXQgd2FzIHJlamVjdGVkIHdpdGggJyArXG4gICAgICAgICAgICAgICAgICBtYXRjaGVyc1V0aWwucHAoYWN0dWFsVmFsdWUpICtcbiAgICAgICAgICAgICAgICAgICcuJ1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlUmVqZWN0ZWRXaXRoRXJyb3IgPSBmdW5jdGlvbihqJCkge1xuICAvKipcbiAgICogRXhwZWN0IGEgcHJvbWlzZSB0byBiZSByZWplY3RlZCB3aXRoIGEgdmFsdWUgbWF0Y2hlZCB0byB0aGUgZXhwZWN0ZWRcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBhc3luY1xuICAgKiBAbmFtZSBhc3luYy1tYXRjaGVycyN0b0JlUmVqZWN0ZWRXaXRoRXJyb3JcbiAgICogQHNpbmNlIDMuNS4wXG4gICAqIEBwYXJhbSB7RXJyb3J9IFtleHBlY3RlZF0gLSBgRXJyb3JgIGNvbnN0cnVjdG9yIHRoZSBvYmplY3QgdGhhdCB3YXMgdGhyb3duIG5lZWRzIHRvIGJlIGFuIGluc3RhbmNlIG9mLiBJZiBub3QgcHJvdmlkZWQsIGBFcnJvcmAgd2lsbCBiZSB1c2VkLlxuICAgKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IFttZXNzYWdlXSAtIFRoZSBtZXNzYWdlIHRoYXQgc2hvdWxkIGJlIHNldCBvbiB0aGUgdGhyb3duIGBFcnJvcmBcbiAgICogQGV4YW1wbGVcbiAgICogYXdhaXQgZXhwZWN0QXN5bmMoYVByb21pc2UpLnRvQmVSZWplY3RlZFdpdGhFcnJvcihNeUN1c3RvbUVycm9yLCAnRXJyb3IgbWVzc2FnZScpO1xuICAgKiBhd2FpdCBleHBlY3RBc3luYyhhUHJvbWlzZSkudG9CZVJlamVjdGVkV2l0aEVycm9yKE15Q3VzdG9tRXJyb3IsIC9FcnJvciBtZXNzYWdlLyk7XG4gICAqIGF3YWl0IGV4cGVjdEFzeW5jKGFQcm9taXNlKS50b0JlUmVqZWN0ZWRXaXRoRXJyb3IoTXlDdXN0b21FcnJvcik7XG4gICAqIGF3YWl0IGV4cGVjdEFzeW5jKGFQcm9taXNlKS50b0JlUmVqZWN0ZWRXaXRoRXJyb3IoJ0Vycm9yIG1lc3NhZ2UnKTtcbiAgICogcmV0dXJuIGV4cGVjdEFzeW5jKGFQcm9taXNlKS50b0JlUmVqZWN0ZWRXaXRoRXJyb3IoL0Vycm9yIG1lc3NhZ2UvKTtcbiAgICovXG4gIHJldHVybiBmdW5jdGlvbiB0b0JlUmVqZWN0ZWRXaXRoRXJyb3IobWF0Y2hlcnNVdGlsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbFByb21pc2UsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgaWYgKCFqJC5pc1Byb21pc2VMaWtlKGFjdHVhbFByb21pc2UpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0V4cGVjdGVkIHRvQmVSZWplY3RlZFdpdGhFcnJvciB0byBiZSBjYWxsZWQgb24gYSBwcm9taXNlLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV4cGVjdGVkID0gZ2V0RXhwZWN0ZWRGcm9tQXJncyhhcmcxLCBhcmcyLCBtYXRjaGVyc1V0aWwpO1xuXG4gICAgICAgIHJldHVybiBhY3R1YWxQcm9taXNlLnRoZW4oXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBwYXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ0V4cGVjdGVkIGEgcHJvbWlzZSB0byBiZSByZWplY3RlZCBidXQgaXQgd2FzIHJlc29sdmVkLidcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihhY3R1YWxWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoRXJyb3IoYWN0dWFsVmFsdWUsIGV4cGVjdGVkLCBtYXRjaGVyc1V0aWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1hdGNoRXJyb3IoYWN0dWFsLCBleHBlY3RlZCwgbWF0Y2hlcnNVdGlsKSB7XG4gICAgaWYgKCFqJC5pc0Vycm9yXyhhY3R1YWwpKSB7XG4gICAgICByZXR1cm4gZmFpbChleHBlY3RlZCwgJ3JlamVjdGVkIHdpdGggJyArIG1hdGNoZXJzVXRpbC5wcChhY3R1YWwpKTtcbiAgICB9XG5cbiAgICBpZiAoIShhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZC5lcnJvcikpIHtcbiAgICAgIHJldHVybiBmYWlsKFxuICAgICAgICBleHBlY3RlZCxcbiAgICAgICAgJ3JlamVjdGVkIHdpdGggdHlwZSAnICsgaiQuZm5OYW1lRm9yKGFjdHVhbC5jb25zdHJ1Y3RvcilcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGFjdHVhbE1lc3NhZ2UgPSBhY3R1YWwubWVzc2FnZTtcblxuICAgIGlmIChcbiAgICAgIGFjdHVhbE1lc3NhZ2UgPT09IGV4cGVjdGVkLm1lc3NhZ2UgfHxcbiAgICAgIHR5cGVvZiBleHBlY3RlZC5tZXNzYWdlID09PSAndW5kZWZpbmVkJ1xuICAgICkge1xuICAgICAgcmV0dXJuIHBhc3MoZXhwZWN0ZWQpO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGV4cGVjdGVkLm1lc3NhZ2UgaW5zdGFuY2VvZiBSZWdFeHAgJiZcbiAgICAgIGV4cGVjdGVkLm1lc3NhZ2UudGVzdChhY3R1YWxNZXNzYWdlKVxuICAgICkge1xuICAgICAgcmV0dXJuIHBhc3MoZXhwZWN0ZWQpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWlsKGV4cGVjdGVkLCAncmVqZWN0ZWQgd2l0aCAnICsgbWF0Y2hlcnNVdGlsLnBwKGFjdHVhbCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFzcyhleHBlY3RlZCkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXNzOiB0cnVlLFxuICAgICAgbWVzc2FnZTpcbiAgICAgICAgJ0V4cGVjdGVkIGEgcHJvbWlzZSBub3QgdG8gYmUgcmVqZWN0ZWQgd2l0aCAnICtcbiAgICAgICAgZXhwZWN0ZWQucHJpbnRWYWx1ZSArXG4gICAgICAgICcsIGJ1dCBpdCB3YXMuJ1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBmYWlsKGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhc3M6IGZhbHNlLFxuICAgICAgbWVzc2FnZTpcbiAgICAgICAgJ0V4cGVjdGVkIGEgcHJvbWlzZSB0byBiZSByZWplY3RlZCB3aXRoICcgK1xuICAgICAgICBleHBlY3RlZC5wcmludFZhbHVlICtcbiAgICAgICAgJyBidXQgaXQgd2FzICcgK1xuICAgICAgICBtZXNzYWdlICtcbiAgICAgICAgJy4nXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEV4cGVjdGVkRnJvbUFyZ3MoYXJnMSwgYXJnMiwgbWF0Y2hlcnNVdGlsKSB7XG4gICAgdmFyIGVycm9yLCBtZXNzYWdlO1xuXG4gICAgaWYgKGlzRXJyb3JDb25zdHJ1Y3RvcihhcmcxKSkge1xuICAgICAgZXJyb3IgPSBhcmcxO1xuICAgICAgbWVzc2FnZSA9IGFyZzI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yID0gRXJyb3I7XG4gICAgICBtZXNzYWdlID0gYXJnMTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIHByaW50VmFsdWU6XG4gICAgICAgIGokLmZuTmFtZUZvcihlcnJvcikgK1xuICAgICAgICAodHlwZW9mIG1lc3NhZ2UgPT09ICd1bmRlZmluZWQnID8gJycgOiAnOiAnICsgbWF0Y2hlcnNVdGlsLnBwKG1lc3NhZ2UpKVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpc0Vycm9yQ29uc3RydWN0b3IodmFsdWUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAodmFsdWUgPT09IEVycm9yIHx8IGokLmlzRXJyb3JfKHZhbHVlLnByb3RvdHlwZSkpXG4gICAgKTtcbiAgfVxufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlUmVzb2x2ZWQgPSBmdW5jdGlvbihqJCkge1xuICAvKipcbiAgICogRXhwZWN0IGEgcHJvbWlzZSB0byBiZSByZXNvbHZlZC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBhc3luY1xuICAgKiBAbmFtZSBhc3luYy1tYXRjaGVycyN0b0JlUmVzb2x2ZWRcbiAgICogQHNpbmNlIDMuMS4wXG4gICAqIEBleGFtcGxlXG4gICAqIGF3YWl0IGV4cGVjdEFzeW5jKGFQcm9taXNlKS50b0JlUmVzb2x2ZWQoKTtcbiAgICogQGV4YW1wbGVcbiAgICogcmV0dXJuIGV4cGVjdEFzeW5jKGFQcm9taXNlKS50b0JlUmVzb2x2ZWQoKTtcbiAgICovXG4gIHJldHVybiBmdW5jdGlvbiB0b0JlUmVzb2x2ZWQobWF0Y2hlcnNVdGlsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCkge1xuICAgICAgICBpZiAoIWokLmlzUHJvbWlzZUxpa2UoYWN0dWFsKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG9CZVJlc29sdmVkIHRvIGJlIGNhbGxlZCBvbiBhIHByb21pc2UuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWN0dWFsLnRoZW4oXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4geyBwYXNzOiB0cnVlIH07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBwYXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgICAnRXhwZWN0ZWQgYSBwcm9taXNlIHRvIGJlIHJlc29sdmVkIGJ1dCBpdCB3YXMgJyArXG4gICAgICAgICAgICAgICAgJ3JlamVjdGVkIHdpdGggJyArXG4gICAgICAgICAgICAgICAgbWF0Y2hlcnNVdGlsLnBwKGUpICtcbiAgICAgICAgICAgICAgICAnLidcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVSZXNvbHZlZFRvID0gZnVuY3Rpb24oaiQpIHtcbiAgLyoqXG4gICAqIEV4cGVjdCBhIHByb21pc2UgdG8gYmUgcmVzb2x2ZWQgdG8gYSB2YWx1ZSBlcXVhbCB0byB0aGUgZXhwZWN0ZWQsIHVzaW5nIGRlZXAgZXF1YWxpdHkgY29tcGFyaXNvbi5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBhc3luY1xuICAgKiBAbmFtZSBhc3luYy1tYXRjaGVycyN0b0JlUmVzb2x2ZWRUb1xuICAgKiBAc2luY2UgMy4xLjBcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4cGVjdGVkIC0gVmFsdWUgdGhhdCB0aGUgcHJvbWlzZSBpcyBleHBlY3RlZCB0byByZXNvbHZlIHRvXG4gICAqIEBleGFtcGxlXG4gICAqIGF3YWl0IGV4cGVjdEFzeW5jKGFQcm9taXNlKS50b0JlUmVzb2x2ZWRUbyh7cHJvcDogJ3ZhbHVlJ30pO1xuICAgKiBAZXhhbXBsZVxuICAgKiByZXR1cm4gZXhwZWN0QXN5bmMoYVByb21pc2UpLnRvQmVSZXNvbHZlZFRvKHtwcm9wOiAndmFsdWUnfSk7XG4gICAqL1xuICByZXR1cm4gZnVuY3Rpb24gdG9CZVJlc29sdmVkVG8obWF0Y2hlcnNVdGlsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbFByb21pc2UsIGV4cGVjdGVkVmFsdWUpIHtcbiAgICAgICAgaWYgKCFqJC5pc1Byb21pc2VMaWtlKGFjdHVhbFByb21pc2UpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0b0JlUmVzb2x2ZWRUbyB0byBiZSBjYWxsZWQgb24gYSBwcm9taXNlLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcHJlZml4KHBhc3NlZCkge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAnRXhwZWN0ZWQgYSBwcm9taXNlICcgK1xuICAgICAgICAgICAgKHBhc3NlZCA/ICdub3QgJyA6ICcnKSArXG4gICAgICAgICAgICAndG8gYmUgcmVzb2x2ZWQgdG8gJyArXG4gICAgICAgICAgICBtYXRjaGVyc1V0aWwucHAoZXhwZWN0ZWRWYWx1ZSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFjdHVhbFByb21pc2UudGhlbihcbiAgICAgICAgICBmdW5jdGlvbihhY3R1YWxWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKG1hdGNoZXJzVXRpbC5lcXVhbHMoYWN0dWFsVmFsdWUsIGV4cGVjdGVkVmFsdWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcGFzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBwcmVmaXgodHJ1ZSkgKyAnLidcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcGFzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgICAgIHByZWZpeChmYWxzZSkgK1xuICAgICAgICAgICAgICAgICAgJyBidXQgaXQgd2FzIHJlc29sdmVkIHRvICcgK1xuICAgICAgICAgICAgICAgICAgbWF0Y2hlcnNVdGlsLnBwKGFjdHVhbFZhbHVlKSArXG4gICAgICAgICAgICAgICAgICAnLidcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHBhc3M6IGZhbHNlLFxuICAgICAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgICAgIHByZWZpeChmYWxzZSkgK1xuICAgICAgICAgICAgICAgICcgYnV0IGl0IHdhcyByZWplY3RlZCB3aXRoICcgK1xuICAgICAgICAgICAgICAgIG1hdGNoZXJzVXRpbC5wcChlKSArXG4gICAgICAgICAgICAgICAgJy4nXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5EaWZmQnVpbGRlciA9IGZ1bmN0aW9uKGokKSB7XG4gIHJldHVybiBmdW5jdGlvbiBEaWZmQnVpbGRlcihjb25maWcpIHtcbiAgICB2YXIgcHJldHR5UHJpbnRlciA9IChjb25maWcgfHwge30pLnByZXR0eVByaW50ZXIgfHwgaiQubWFrZVByZXR0eVByaW50ZXIoKSxcbiAgICAgIG1pc21hdGNoZXMgPSBuZXcgaiQuTWlzbWF0Y2hUcmVlKCksXG4gICAgICBwYXRoID0gbmV3IGokLk9iamVjdFBhdGgoKSxcbiAgICAgIGFjdHVhbFJvb3QgPSB1bmRlZmluZWQsXG4gICAgICBleHBlY3RlZFJvb3QgPSB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2V0Um9vdHM6IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgICAgICAgYWN0dWFsUm9vdCA9IGFjdHVhbDtcbiAgICAgICAgZXhwZWN0ZWRSb290ID0gZXhwZWN0ZWQ7XG4gICAgICB9LFxuXG4gICAgICByZWNvcmRNaXNtYXRjaDogZnVuY3Rpb24oZm9ybWF0dGVyKSB7XG4gICAgICAgIG1pc21hdGNoZXMuYWRkKHBhdGgsIGZvcm1hdHRlcik7XG4gICAgICB9LFxuXG4gICAgICBnZXRNZXNzYWdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2VzID0gW107XG5cbiAgICAgICAgbWlzbWF0Y2hlcy50cmF2ZXJzZShmdW5jdGlvbihwYXRoLCBpc0xlYWYsIGZvcm1hdHRlcikge1xuICAgICAgICAgIHZhciBhY3R1YWxDdXN0b20sXG4gICAgICAgICAgICBleHBlY3RlZEN1c3RvbSxcbiAgICAgICAgICAgIHVzZUN1c3RvbSxcbiAgICAgICAgICAgIGRlcmVmUmVzdWx0ID0gZGVyZWZlcmVuY2VQYXRoKFxuICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICBhY3R1YWxSb290LFxuICAgICAgICAgICAgICBleHBlY3RlZFJvb3QsXG4gICAgICAgICAgICAgIHByZXR0eVByaW50ZXJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBhY3R1YWwgPSBkZXJlZlJlc3VsdC5hY3R1YWwsXG4gICAgICAgICAgICBleHBlY3RlZCA9IGRlcmVmUmVzdWx0LmV4cGVjdGVkO1xuXG4gICAgICAgICAgaWYgKGZvcm1hdHRlcikge1xuICAgICAgICAgICAgbWVzc2FnZXMucHVzaChmb3JtYXR0ZXIoYWN0dWFsLCBleHBlY3RlZCwgcGF0aCwgcHJldHR5UHJpbnRlcikpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYWN0dWFsQ3VzdG9tID0gcHJldHR5UHJpbnRlci5jdXN0b21Gb3JtYXRfKGFjdHVhbCk7XG4gICAgICAgICAgZXhwZWN0ZWRDdXN0b20gPSBwcmV0dHlQcmludGVyLmN1c3RvbUZvcm1hdF8oZXhwZWN0ZWQpO1xuICAgICAgICAgIHVzZUN1c3RvbSA9ICEoXG4gICAgICAgICAgICBqJC51dGlsLmlzVW5kZWZpbmVkKGFjdHVhbEN1c3RvbSkgJiZcbiAgICAgICAgICAgIGokLnV0aWwuaXNVbmRlZmluZWQoZXhwZWN0ZWRDdXN0b20pXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmICh1c2VDdXN0b20pIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goXG4gICAgICAgICAgICAgIHdyYXBQcmV0dHlQcmludGVkKGFjdHVhbEN1c3RvbSwgZXhwZWN0ZWRDdXN0b20sIHBhdGgpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBkb24ndCByZWN1cnNlIGZ1cnRoZXJcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNMZWFmKSB7XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKFxuICAgICAgICAgICAgICBkZWZhdWx0Rm9ybWF0dGVyKGFjdHVhbCwgZXhwZWN0ZWQsIHBhdGgsIHByZXR0eVByaW50ZXIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbWVzc2FnZXMuam9pbignXFxuJyk7XG4gICAgICB9LFxuXG4gICAgICB3aXRoUGF0aDogZnVuY3Rpb24ocGF0aENvbXBvbmVudCwgYmxvY2spIHtcbiAgICAgICAgdmFyIG9sZFBhdGggPSBwYXRoO1xuICAgICAgICBwYXRoID0gcGF0aC5hZGQocGF0aENvbXBvbmVudCk7XG4gICAgICAgIGJsb2NrKCk7XG4gICAgICAgIHBhdGggPSBvbGRQYXRoO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0Rm9ybWF0dGVyKGFjdHVhbCwgZXhwZWN0ZWQsIHBhdGgsIHByZXR0eVByaW50ZXIpIHtcbiAgICAgIHJldHVybiB3cmFwUHJldHR5UHJpbnRlZChcbiAgICAgICAgcHJldHR5UHJpbnRlcihhY3R1YWwpLFxuICAgICAgICBwcmV0dHlQcmludGVyKGV4cGVjdGVkKSxcbiAgICAgICAgcGF0aFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3cmFwUHJldHR5UHJpbnRlZChhY3R1YWwsIGV4cGVjdGVkLCBwYXRoKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAnRXhwZWN0ZWQgJyArXG4gICAgICAgIHBhdGggK1xuICAgICAgICAocGF0aC5kZXB0aCgpID8gJyA9ICcgOiAnJykgK1xuICAgICAgICBhY3R1YWwgK1xuICAgICAgICAnIHRvIGVxdWFsICcgK1xuICAgICAgICBleHBlY3RlZCArXG4gICAgICAgICcuJ1xuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gZGVyZWZlcmVuY2VQYXRoKG9iamVjdFBhdGgsIGFjdHVhbCwgZXhwZWN0ZWQsIHBwKSB7XG4gICAgZnVuY3Rpb24gaGFuZGxlQXN5bW1ldHJpY0V4cGVjdGVkKCkge1xuICAgICAgaWYgKFxuICAgICAgICBqJC5pc0FzeW1tZXRyaWNFcXVhbGl0eVRlc3Rlcl8oZXhwZWN0ZWQpICYmXG4gICAgICAgIGokLmlzRnVuY3Rpb25fKGV4cGVjdGVkLnZhbHVlc0ZvckRpZmZfKVxuICAgICAgKSB7XG4gICAgICAgIHZhciBhc3ltbWV0cmljUmVzdWx0ID0gZXhwZWN0ZWQudmFsdWVzRm9yRGlmZl8oYWN0dWFsLCBwcCk7XG4gICAgICAgIGV4cGVjdGVkID0gYXN5bW1ldHJpY1Jlc3VsdC5zZWxmO1xuICAgICAgICBhY3R1YWwgPSBhc3ltbWV0cmljUmVzdWx0Lm90aGVyO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpO1xuICAgIGhhbmRsZUFzeW1tZXRyaWNFeHBlY3RlZCgpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG9iamVjdFBhdGguY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYWN0dWFsID0gYWN0dWFsW29iamVjdFBhdGguY29tcG9uZW50c1tpXV07XG4gICAgICBleHBlY3RlZCA9IGV4cGVjdGVkW29iamVjdFBhdGguY29tcG9uZW50c1tpXV07XG4gICAgICBoYW5kbGVBc3ltbWV0cmljRXhwZWN0ZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBhY3R1YWw6IGFjdHVhbCwgZXhwZWN0ZWQ6IGV4cGVjdGVkIH07XG4gIH1cbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuTWF0Y2hlcnNVdGlsID0gZnVuY3Rpb24oaiQpIHtcbiAgLyoqXG4gICAqIEBjbGFzcyBNYXRjaGVyc1V0aWxcbiAgICogQGNsYXNzZGVzYyBVdGlsaXRpZXMgZm9yIHVzZSBpbiBpbXBsZW1lbnRpbmcgbWF0Y2hlcnMuPGJyPlxuICAgKiBfTm90ZTpfIERvIG5vdCBjb25zdHJ1Y3QgdGhpcyBkaXJlY3RseS4gSmFzbWluZSB3aWxsIGNvbnN0cnVjdCBvbmUgYW5kXG4gICAqIHBhc3MgaXQgdG8gbWF0Y2hlcnMgYW5kIGFzeW1tZXRyaWMgZXF1YWxpdHkgdGVzdGVycy5cbiAgICogQGhpZGVjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gTWF0Y2hlcnNVdGlsKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLmN1c3RvbVRlc3RlcnNfID0gb3B0aW9ucy5jdXN0b21UZXN0ZXJzIHx8IFtdO1xuICAgIC8qKlxuICAgICAqIEZvcm1hdHMgYSB2YWx1ZSBmb3IgdXNlIGluIG1hdGNoZXIgZmFpbHVyZSBtZXNzYWdlcyBhbmQgc2ltaWxhciBjb250ZXh0cyxcbiAgICAgKiB0YWtpbmcgaW50byBhY2NvdW50IHRoZSBjdXJyZW50IHNldCBvZiBjdXN0b20gdmFsdWUgZm9ybWF0dGVycy5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbmFtZSBNYXRjaGVyc1V0aWwjcHBcbiAgICAgKiBAc2luY2UgMy42LjBcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcmV0dHktcHJpbnRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBwcmV0dHktcHJpbnRlZCB2YWx1ZVxuICAgICAqL1xuICAgIHRoaXMucHAgPSBvcHRpb25zLnBwIHx8IGZ1bmN0aW9uKCkge307XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGBoYXlzdGFja2AgY29udGFpbnMgYG5lZWRsZWAsIHVzaW5nIHRoZSBzYW1lIGNvbXBhcmlzb25cbiAgICogbG9naWMgYXMge0BsaW5rIE1hdGNoZXJzVXRpbCNlcXVhbHN9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgTWF0Y2hlcnNVdGlsI2NvbnRhaW5zXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKiBAcGFyYW0geyp9IGhheXN0YWNrIFRoZSBjb2xsZWN0aW9uIHRvIHNlYXJjaFxuICAgKiBAcGFyYW0geyp9IG5lZWRsZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBgbmVlZGxlYCB3YXMgZm91bmQgaW4gYGhheXN0YWNrYFxuICAgKi9cbiAgTWF0Y2hlcnNVdGlsLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKGhheXN0YWNrLCBuZWVkbGUpIHtcbiAgICBpZiAoIWhheXN0YWNrKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGokLmlzU2V0KGhheXN0YWNrKSkge1xuICAgICAgLy8gVHJ5IC5oYXMoKSBmaXJzdC4gSXQgc2hvdWxkIGJlIGZhc3RlciBpbiBjYXNlcyB3aGVyZVxuICAgICAgLy8gbmVlZGxlID09PSBzb21ldGhpbmcgaW4gaGF5c3RhY2suIEZhbGwgYmFjayB0byAuZXF1YWxzKCkgY29tcGFyaXNvblxuICAgICAgLy8gaWYgdGhhdCBmYWlscy5cbiAgICAgIGlmIChoYXlzdGFjay5oYXMobmVlZGxlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaiQuaXNJdGVyYWJsZV8oaGF5c3RhY2spICYmICFqJC5pc1N0cmluZ18oaGF5c3RhY2spKSB7XG4gICAgICAvLyBBcnJheXMsIFNldHMsIGV0Yy5cbiAgICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIGhheXN0YWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmVxdWFscyhjYW5kaWRhdGUsIG5lZWRsZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGhheXN0YWNrLmluZGV4T2YpIHtcbiAgICAgIC8vIE1haW5seSBzdHJpbmdzXG4gICAgICByZXR1cm4gaGF5c3RhY2suaW5kZXhPZihuZWVkbGUpID49IDA7XG4gICAgfVxuXG4gICAgaWYgKGokLmlzTnVtYmVyXyhoYXlzdGFjay5sZW5ndGgpKSB7XG4gICAgICAvLyBPYmplY3RzIHRoYXQgYXJlIHNoYXBlZCBsaWtlIGFycmF5cyBidXQgYXJlbid0IGl0ZXJhYmxlXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhheXN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLmVxdWFscyhoYXlzdGFja1tpXSwgbmVlZGxlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIE1hdGNoZXJzVXRpbC5wcm90b3R5cGUuYnVpbGRGYWlsdXJlTWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCksXG4gICAgICBtYXRjaGVyTmFtZSA9IGFyZ3NbMF0sXG4gICAgICBpc05vdCA9IGFyZ3NbMV0sXG4gICAgICBhY3R1YWwgPSBhcmdzWzJdLFxuICAgICAgZXhwZWN0ZWQgPSBhcmdzLnNsaWNlKDMpLFxuICAgICAgZW5nbGlzaHlQcmVkaWNhdGUgPSBtYXRjaGVyTmFtZS5yZXBsYWNlKC9bQS1aXS9nLCBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiAnICcgKyBzLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9KTtcblxuICAgIHZhciBtZXNzYWdlID1cbiAgICAgICdFeHBlY3RlZCAnICtcbiAgICAgIHNlbGYucHAoYWN0dWFsKSArXG4gICAgICAoaXNOb3QgPyAnIG5vdCAnIDogJyAnKSArXG4gICAgICBlbmdsaXNoeVByZWRpY2F0ZTtcblxuICAgIGlmIChleHBlY3RlZC5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIG1lc3NhZ2UgKz0gJywnO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UgKz0gJyAnICsgc2VsZi5wcChleHBlY3RlZFtpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lc3NhZ2UgKyAnLic7XG4gIH07XG5cbiAgTWF0Y2hlcnNVdGlsLnByb3RvdHlwZS5hc3ltbWV0cmljRGlmZl8gPSBmdW5jdGlvbihcbiAgICBhLFxuICAgIGIsXG4gICAgYVN0YWNrLFxuICAgIGJTdGFjayxcbiAgICBkaWZmQnVpbGRlclxuICApIHtcbiAgICBpZiAoaiQuaXNGdW5jdGlvbl8oYi52YWx1ZXNGb3JEaWZmXykpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBiLnZhbHVlc0ZvckRpZmZfKGEsIHRoaXMucHApO1xuICAgICAgdGhpcy5lcV8odmFsdWVzLm90aGVyLCB2YWx1ZXMuc2VsZiwgYVN0YWNrLCBiU3RhY2ssIGRpZmZCdWlsZGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkTWlzbWF0Y2goKTtcbiAgICB9XG4gIH07XG5cbiAgTWF0Y2hlcnNVdGlsLnByb3RvdHlwZS5hc3ltbWV0cmljTWF0Y2hfID0gZnVuY3Rpb24oXG4gICAgYSxcbiAgICBiLFxuICAgIGFTdGFjayxcbiAgICBiU3RhY2ssXG4gICAgZGlmZkJ1aWxkZXJcbiAgKSB7XG4gICAgdmFyIGFzeW1tZXRyaWNBID0gaiQuaXNBc3ltbWV0cmljRXF1YWxpdHlUZXN0ZXJfKGEpLFxuICAgICAgYXN5bW1ldHJpY0IgPSBqJC5pc0FzeW1tZXRyaWNFcXVhbGl0eVRlc3Rlcl8oYiksXG4gICAgICByZXN1bHQ7XG5cbiAgICBpZiAoYXN5bW1ldHJpY0EgPT09IGFzeW1tZXRyaWNCKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChhc3ltbWV0cmljQSkge1xuICAgICAgcmVzdWx0ID0gYS5hc3ltbWV0cmljTWF0Y2goYiwgdGhpcyk7XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICBkaWZmQnVpbGRlci5yZWNvcmRNaXNtYXRjaCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBpZiAoYXN5bW1ldHJpY0IpIHtcbiAgICAgIHJlc3VsdCA9IGIuYXN5bW1ldHJpY01hdGNoKGEsIHRoaXMpO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgdGhpcy5hc3ltbWV0cmljRGlmZl8oYSwgYiwgYVN0YWNrLCBiU3RhY2ssIGRpZmZCdWlsZGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdHdvIHZhbHVlcyBhcmUgZGVlcGx5IGVxdWFsIHRvIGVhY2ggb3RoZXIuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBNYXRjaGVyc1V0aWwjZXF1YWxzXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKiBAcGFyYW0geyp9IGEgVGhlIGZpcnN0IHZhbHVlIHRvIGNvbXBhcmVcbiAgICogQHBhcmFtIHsqfSBiIFRoZSBzZWNvbmQgdmFsdWUgdG8gY29tcGFyZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWVzIGFyZSBlcXVhbFxuICAgKi9cbiAgTWF0Y2hlcnNVdGlsLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihhLCBiLCBkaWZmQnVpbGRlcikge1xuICAgIGRpZmZCdWlsZGVyID0gZGlmZkJ1aWxkZXIgfHwgaiQuTnVsbERpZmZCdWlsZGVyKCk7XG4gICAgZGlmZkJ1aWxkZXIuc2V0Um9vdHMoYSwgYik7XG5cbiAgICByZXR1cm4gdGhpcy5lcV8oYSwgYiwgW10sIFtdLCBkaWZmQnVpbGRlcik7XG4gIH07XG5cbiAgLy8gRXF1YWxpdHkgZnVuY3Rpb24gbG92aW5nbHkgYWRhcHRlZCBmcm9tIGlzRXF1YWwgaW5cbiAgLy8gICBbVW5kZXJzY29yZV0oaHR0cDovL3VuZGVyc2NvcmVqcy5vcmcpXG4gIE1hdGNoZXJzVXRpbC5wcm90b3R5cGUuZXFfID0gZnVuY3Rpb24oYSwgYiwgYVN0YWNrLCBiU3RhY2ssIGRpZmZCdWlsZGVyKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWxmID0gdGhpcyxcbiAgICAgIGk7XG5cbiAgICB2YXIgYXN5bW1ldHJpY1Jlc3VsdCA9IHRoaXMuYXN5bW1ldHJpY01hdGNoXyhcbiAgICAgIGEsXG4gICAgICBiLFxuICAgICAgYVN0YWNrLFxuICAgICAgYlN0YWNrLFxuICAgICAgZGlmZkJ1aWxkZXJcbiAgICApO1xuICAgIGlmICghaiQudXRpbC5pc1VuZGVmaW5lZChhc3ltbWV0cmljUmVzdWx0KSkge1xuICAgICAgcmV0dXJuIGFzeW1tZXRyaWNSZXN1bHQ7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuY3VzdG9tVGVzdGVyc18ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjdXN0b21UZXN0ZXJSZXN1bHQgPSB0aGlzLmN1c3RvbVRlc3RlcnNfW2ldKGEsIGIpO1xuICAgICAgaWYgKCFqJC51dGlsLmlzVW5kZWZpbmVkKGN1c3RvbVRlc3RlclJlc3VsdCkpIHtcbiAgICAgICAgaWYgKCFjdXN0b21UZXN0ZXJSZXN1bHQpIHtcbiAgICAgICAgICBkaWZmQnVpbGRlci5yZWNvcmRNaXNtYXRjaCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXN0b21UZXN0ZXJSZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGEgaW5zdGFuY2VvZiBFcnJvciAmJiBiIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHJlc3VsdCA9IGEubWVzc2FnZSA9PSBiLm1lc3NhZ2U7XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICBkaWZmQnVpbGRlci5yZWNvcmRNaXNtYXRjaCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXG4gICAgLy8gU2VlIHRoZSBbSGFybW9ueSBgZWdhbGAgcHJvcG9zYWxdKGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbCkuXG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgIHJlc3VsdCA9IGEgIT09IDAgfHwgMSAvIGEgPT0gMSAvIGI7XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICBkaWZmQnVpbGRlci5yZWNvcmRNaXNtYXRjaCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxuICAgIGlmIChhID09PSBudWxsIHx8IGIgPT09IG51bGwpIHtcbiAgICAgIHJlc3VsdCA9IGEgPT09IGI7XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICBkaWZmQnVpbGRlci5yZWNvcmRNaXNtYXRjaCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdmFyIGNsYXNzTmFtZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChiKSkge1xuICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkTWlzbWF0Y2goKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzpcbiAgICAgICAgLy8gUHJpbWl0aXZlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBvYmplY3Qgd3JhcHBlcnMgYXJlIGVxdWl2YWxlbnQ7IHRodXMsIGBcIjVcImAgaXNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byBgbmV3IFN0cmluZyhcIjVcIilgLlxuICAgICAgICByZXN1bHQgPSBhID09IFN0cmluZyhiKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICBkaWZmQnVpbGRlci5yZWNvcmRNaXNtYXRjaCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxuICAgICAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLiBBbiBgZWdhbGAgY29tcGFyaXNvbiBpcyBwZXJmb3JtZWQgZm9yXG4gICAgICAgIC8vIG90aGVyIG51bWVyaWMgdmFsdWVzLlxuICAgICAgICByZXN1bHQgPVxuICAgICAgICAgIGEgIT0gK2EgPyBiICE9ICtiIDogYSA9PT0gMCAmJiBiID09PSAwID8gMSAvIGEgPT0gMSAvIGIgOiBhID09ICtiO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgIGRpZmZCdWlsZGVyLnJlY29yZE1pc21hdGNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxuICAgICAgY2FzZSAnW29iamVjdCBCb29sZWFuXSc6XG4gICAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcbiAgICAgICAgLy8gbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zLiBOb3RlIHRoYXQgaW52YWxpZCBkYXRlcyB3aXRoIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9uc1xuICAgICAgICAvLyBvZiBgTmFOYCBhcmUgbm90IGVxdWl2YWxlbnQuXG4gICAgICAgIHJlc3VsdCA9ICthID09ICtiO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgIGRpZmZCdWlsZGVyLnJlY29yZE1pc21hdGNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGNhc2UgJ1tvYmplY3QgQXJyYXlCdWZmZXJdJzpcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBpbnN0YW5jZSBvZiBBcnJheUJ1ZmZlciB0aGUgVWludDhBcnJheSBjdG9yXG4gICAgICAgIC8vIHdpbGwgYmUgZGVmaW5lZCBhcyB3ZWxsXG4gICAgICAgIHJldHVybiBzZWxmLmVxXyhcbiAgICAgICAgICBuZXcgVWludDhBcnJheShhKSxcbiAgICAgICAgICBuZXcgVWludDhBcnJheShiKSxcbiAgICAgICAgICBhU3RhY2ssXG4gICAgICAgICAgYlN0YWNrLFxuICAgICAgICAgIGRpZmZCdWlsZGVyXG4gICAgICAgICk7XG4gICAgICAvLyBSZWdFeHBzIGFyZSBjb21wYXJlZCBieSB0aGVpciBzb3VyY2UgcGF0dGVybnMgYW5kIGZsYWdzLlxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBhLnNvdXJjZSA9PSBiLnNvdXJjZSAmJlxuICAgICAgICAgIGEuZ2xvYmFsID09IGIuZ2xvYmFsICYmXG4gICAgICAgICAgYS5tdWx0aWxpbmUgPT0gYi5tdWx0aWxpbmUgJiZcbiAgICAgICAgICBhLmlnbm9yZUNhc2UgPT0gYi5pZ25vcmVDYXNlXG4gICAgICAgICk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0Jykge1xuICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkTWlzbWF0Y2goKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgYUlzRG9tTm9kZSA9IGokLmlzRG9tTm9kZShhKTtcbiAgICB2YXIgYklzRG9tTm9kZSA9IGokLmlzRG9tTm9kZShiKTtcbiAgICBpZiAoYUlzRG9tTm9kZSAmJiBiSXNEb21Ob2RlKSB7XG4gICAgICAvLyBBdCBmaXJzdCB0cnkgdG8gdXNlIERPTTMgbWV0aG9kIGlzRXF1YWxOb2RlXG4gICAgICByZXN1bHQgPSBhLmlzRXF1YWxOb2RlKGIpO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkTWlzbWF0Y2goKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmIChhSXNEb21Ob2RlIHx8IGJJc0RvbU5vZGUpIHtcbiAgICAgIGRpZmZCdWlsZGVyLnJlY29yZE1pc21hdGNoKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGFJc1Byb21pc2UgPSBqJC5pc1Byb21pc2UoYSk7XG4gICAgdmFyIGJJc1Byb21pc2UgPSBqJC5pc1Byb21pc2UoYik7XG4gICAgaWYgKGFJc1Byb21pc2UgJiYgYklzUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgfVxuXG4gICAgLy8gQXNzdW1lIGVxdWFsaXR5IGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhlIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGN5Y2xpY1xuICAgIC8vIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gLlxuICAgIHZhciBsZW5ndGggPSBhU3RhY2subGVuZ3RoO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgLy8gTGluZWFyIHNlYXJjaC4gUGVyZm9ybWFuY2UgaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mXG4gICAgICAvLyB1bmlxdWUgbmVzdGVkIHN0cnVjdHVyZXMuXG4gICAgICBpZiAoYVN0YWNrW2xlbmd0aF0gPT0gYSkge1xuICAgICAgICByZXR1cm4gYlN0YWNrW2xlbmd0aF0gPT0gYjtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQWRkIHRoZSBmaXJzdCBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wdXNoKGEpO1xuICAgIGJTdGFjay5wdXNoKGIpO1xuICAgIHZhciBzaXplID0gMDtcbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS5cbiAgICBpZiAoY2xhc3NOYW1lID09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHZhciBhTGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICB2YXIgYkxlbmd0aCA9IGIubGVuZ3RoO1xuXG4gICAgICBkaWZmQnVpbGRlci53aXRoUGF0aCgnbGVuZ3RoJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChhTGVuZ3RoICE9PSBiTGVuZ3RoKSB7XG4gICAgICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkTWlzbWF0Y2goKTtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhTGVuZ3RoIHx8IGkgPCBiTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGlmZkJ1aWxkZXIud2l0aFBhdGgoaSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGkgPj0gYkxlbmd0aCkge1xuICAgICAgICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkTWlzbWF0Y2goXG4gICAgICAgICAgICAgIGFjdHVhbEFycmF5SXNMb25nZXJGb3JtYXR0ZXIuYmluZChudWxsLCBzZWxmLnBwKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICBzZWxmLmVxXyhcbiAgICAgICAgICAgICAgICBpIDwgYUxlbmd0aCA/IGFbaV0gOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgaSA8IGJMZW5ndGggPyBiW2ldIDogdm9pZCAwLFxuICAgICAgICAgICAgICAgIGFTdGFjayxcbiAgICAgICAgICAgICAgICBiU3RhY2ssXG4gICAgICAgICAgICAgICAgZGlmZkJ1aWxkZXJcbiAgICAgICAgICAgICAgKSAmJiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGokLmlzTWFwKGEpICYmIGokLmlzTWFwKGIpKSB7XG4gICAgICBpZiAoYS5zaXplICE9IGIuc2l6ZSkge1xuICAgICAgICBkaWZmQnVpbGRlci5yZWNvcmRNaXNtYXRjaCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBrZXlzQSA9IFtdO1xuICAgICAgdmFyIGtleXNCID0gW107XG4gICAgICBhLmZvckVhY2goZnVuY3Rpb24odmFsdWVBLCBrZXlBKSB7XG4gICAgICAgIGtleXNBLnB1c2goa2V5QSk7XG4gICAgICB9KTtcbiAgICAgIGIuZm9yRWFjaChmdW5jdGlvbih2YWx1ZUIsIGtleUIpIHtcbiAgICAgICAga2V5c0IucHVzaChrZXlCKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBGb3IgYm90aCBzZXRzIG9mIGtleXMsIGNoZWNrIHRoZXkgbWFwIHRvIGVxdWFsIHZhbHVlcyBpbiBib3RoIG1hcHMuXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIGNvcnJlc3BvbmRpbmcga2V5cyAoaW4gaW5zZXJ0aW9uIG9yZGVyKSBpbiBvcmRlciB0byBoYW5kbGUgYXN5bW1ldHJpYyBvYmoga2V5cy5cbiAgICAgIHZhciBtYXBLZXlzID0gW2tleXNBLCBrZXlzQl07XG4gICAgICB2YXIgY21wS2V5cyA9IFtrZXlzQiwga2V5c0FdO1xuICAgICAgdmFyIG1hcEl0ZXIsIG1hcEtleSwgbWFwVmFsdWVBLCBtYXBWYWx1ZUI7XG4gICAgICB2YXIgY21wSXRlciwgY21wS2V5O1xuICAgICAgZm9yIChpID0gMDsgcmVzdWx0ICYmIGkgPCBtYXBLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1hcEl0ZXIgPSBtYXBLZXlzW2ldO1xuICAgICAgICBjbXBJdGVyID0gY21wS2V5c1tpXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgcmVzdWx0ICYmIGogPCBtYXBJdGVyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgbWFwS2V5ID0gbWFwSXRlcltqXTtcbiAgICAgICAgICBjbXBLZXkgPSBjbXBJdGVyW2pdO1xuICAgICAgICAgIG1hcFZhbHVlQSA9IGEuZ2V0KG1hcEtleSk7XG5cbiAgICAgICAgICAvLyBPbmx5IHVzZSB0aGUgY21wS2V5IHdoZW4gb25lIG9mIHRoZSBrZXlzIGlzIGFzeW1tZXRyaWMgYW5kIHRoZSBjb3JyZXNwb25kaW5nIGtleSBtYXRjaGVzLFxuICAgICAgICAgIC8vIG90aGVyd2lzZSBleHBsaWNpdGx5IGxvb2sgdXAgdGhlIG1hcEtleSBpbiB0aGUgb3RoZXIgTWFwIHNpbmNlIHdlIHdhbnQga2V5cyB3aXRoIHVuaXF1ZVxuICAgICAgICAgIC8vIG9iaiBpZGVudGl0eSAodGhhdCBhcmUgb3RoZXJ3aXNlIGVxdWFsKSB0byBub3QgbWF0Y2guXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgaiQuaXNBc3ltbWV0cmljRXF1YWxpdHlUZXN0ZXJfKG1hcEtleSkgfHxcbiAgICAgICAgICAgIChqJC5pc0FzeW1tZXRyaWNFcXVhbGl0eVRlc3Rlcl8oY21wS2V5KSAmJlxuICAgICAgICAgICAgICB0aGlzLmVxXyhtYXBLZXksIGNtcEtleSwgYVN0YWNrLCBiU3RhY2ssIGokLk51bGxEaWZmQnVpbGRlcigpKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIG1hcFZhbHVlQiA9IGIuZ2V0KGNtcEtleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hcFZhbHVlQiA9IGIuZ2V0KG1hcEtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZXFfKFxuICAgICAgICAgICAgbWFwVmFsdWVBLFxuICAgICAgICAgICAgbWFwVmFsdWVCLFxuICAgICAgICAgICAgYVN0YWNrLFxuICAgICAgICAgICAgYlN0YWNrLFxuICAgICAgICAgICAgaiQuTnVsbERpZmZCdWlsZGVyKClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIGRpZmZCdWlsZGVyLnJlY29yZE1pc21hdGNoKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGokLmlzU2V0KGEpICYmIGokLmlzU2V0KGIpKSB7XG4gICAgICBpZiAoYS5zaXplICE9IGIuc2l6ZSkge1xuICAgICAgICBkaWZmQnVpbGRlci5yZWNvcmRNaXNtYXRjaCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNBID0gW107XG4gICAgICBhLmZvckVhY2goZnVuY3Rpb24odmFsdWVBKSB7XG4gICAgICAgIHZhbHVlc0EucHVzaCh2YWx1ZUEpO1xuICAgICAgfSk7XG4gICAgICB2YXIgdmFsdWVzQiA9IFtdO1xuICAgICAgYi5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlQikge1xuICAgICAgICB2YWx1ZXNCLnB1c2godmFsdWVCKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBGb3IgYm90aCBzZXRzLCBjaGVjayB0aGV5IGFyZSBhbGwgY29udGFpbmVkIGluIHRoZSBvdGhlciBzZXRcbiAgICAgIHZhciBzZXRQYWlycyA9IFtbdmFsdWVzQSwgdmFsdWVzQl0sIFt2YWx1ZXNCLCB2YWx1ZXNBXV07XG4gICAgICB2YXIgc3RhY2tQYWlycyA9IFtbYVN0YWNrLCBiU3RhY2tdLCBbYlN0YWNrLCBhU3RhY2tdXTtcbiAgICAgIHZhciBiYXNlVmFsdWVzLCBiYXNlVmFsdWUsIGJhc2VTdGFjaztcbiAgICAgIHZhciBvdGhlclZhbHVlcywgb3RoZXJWYWx1ZSwgb3RoZXJTdGFjaztcbiAgICAgIHZhciBmb3VuZDtcbiAgICAgIHZhciBwcmV2U3RhY2tTaXplO1xuICAgICAgZm9yIChpID0gMDsgcmVzdWx0ICYmIGkgPCBzZXRQYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBiYXNlVmFsdWVzID0gc2V0UGFpcnNbaV1bMF07XG4gICAgICAgIG90aGVyVmFsdWVzID0gc2V0UGFpcnNbaV1bMV07XG4gICAgICAgIGJhc2VTdGFjayA9IHN0YWNrUGFpcnNbaV1bMF07XG4gICAgICAgIG90aGVyU3RhY2sgPSBzdGFja1BhaXJzW2ldWzFdO1xuICAgICAgICAvLyBGb3IgZWFjaCB2YWx1ZSBpbiB0aGUgYmFzZSBzZXQuLi5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IHJlc3VsdCAmJiBrIDwgYmFzZVZhbHVlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgIGJhc2VWYWx1ZSA9IGJhc2VWYWx1ZXNba107XG4gICAgICAgICAgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAvLyAuLi4gdGVzdCB0aGF0IGl0IGlzIHByZXNlbnQgaW4gdGhlIG90aGVyIHNldFxuICAgICAgICAgIGZvciAodmFyIGwgPSAwOyAhZm91bmQgJiYgbCA8IG90aGVyVmFsdWVzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICBvdGhlclZhbHVlID0gb3RoZXJWYWx1ZXNbbF07XG4gICAgICAgICAgICBwcmV2U3RhY2tTaXplID0gYmFzZVN0YWNrLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIGNvbXBhcmUgYnkgdmFsdWUgZXF1YWxpdHlcbiAgICAgICAgICAgIGZvdW5kID0gdGhpcy5lcV8oXG4gICAgICAgICAgICAgIGJhc2VWYWx1ZSxcbiAgICAgICAgICAgICAgb3RoZXJWYWx1ZSxcbiAgICAgICAgICAgICAgYmFzZVN0YWNrLFxuICAgICAgICAgICAgICBvdGhlclN0YWNrLFxuICAgICAgICAgICAgICBqJC5OdWxsRGlmZkJ1aWxkZXIoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghZm91bmQgJiYgcHJldlN0YWNrU2l6ZSAhPT0gYmFzZVN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgICBiYXNlU3RhY2suc3BsaWNlKHByZXZTdGFja1NpemUpO1xuICAgICAgICAgICAgICBvdGhlclN0YWNrLnNwbGljZShwcmV2U3RhY2tTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICYmIGZvdW5kO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIGRpZmZCdWlsZGVyLnJlY29yZE1pc21hdGNoKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGokLmlzVVJMKGEpICYmIGokLmlzVVJMKGIpKSB7XG4gICAgICAvLyBVUkxzIGhhdmUgbm8gZW51bXJhYmxlIHByb3BlcnRpZXMsIHNvIHRoZSBkZWZhdWx0IG9iamVjdCBjb21wYXJpc29uXG4gICAgICAvLyB3b3VsZCBjb25zaWRlciBhbnkgdHdvIFVSTHMgdG8gYmUgZXF1YWwuXG4gICAgICByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9iamVjdHMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1aXZhbGVudCwgYnV0IGBPYmplY3Rgc1xuICAgICAgLy8gb3IgYEFycmF5YHMgZnJvbSBkaWZmZXJlbnQgZnJhbWVzIGFyZS5cbiAgICAgIHZhciBhQ3RvciA9IGEuY29uc3RydWN0b3IsXG4gICAgICAgIGJDdG9yID0gYi5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmIChcbiAgICAgICAgYUN0b3IgIT09IGJDdG9yICYmXG4gICAgICAgIGlzRnVuY3Rpb24oYUN0b3IpICYmXG4gICAgICAgIGlzRnVuY3Rpb24oYkN0b3IpICYmXG4gICAgICAgIGEgaW5zdGFuY2VvZiBhQ3RvciAmJlxuICAgICAgICBiIGluc3RhbmNlb2YgYkN0b3IgJiZcbiAgICAgICAgIShhQ3RvciBpbnN0YW5jZW9mIGFDdG9yICYmIGJDdG9yIGluc3RhbmNlb2YgYkN0b3IpXG4gICAgICApIHtcbiAgICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkTWlzbWF0Y2goXG4gICAgICAgICAgY29uc3RydWN0b3JzQXJlRGlmZmVyZW50Rm9ybWF0dGVyLmJpbmQobnVsbCwgdGhpcy5wcClcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlZXAgY29tcGFyZSBvYmplY3RzLlxuICAgIHZhciBhS2V5cyA9IGtleXMoYSwgY2xhc3NOYW1lID09ICdbb2JqZWN0IEFycmF5XScpLFxuICAgICAga2V5O1xuICAgIHNpemUgPSBhS2V5cy5sZW5ndGg7XG5cbiAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG4gICAgaWYgKGtleXMoYiwgY2xhc3NOYW1lID09ICdbb2JqZWN0IEFycmF5XScpLmxlbmd0aCAhPT0gc2l6ZSkge1xuICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkTWlzbWF0Y2goXG4gICAgICAgIG9iamVjdEtleXNBcmVEaWZmZXJlbnRGb3JtYXR0ZXIuYmluZChudWxsLCB0aGlzLnBwKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICBrZXkgPSBhS2V5c1tpXTtcbiAgICAgIC8vIERlZXAgY29tcGFyZSBlYWNoIG1lbWJlclxuICAgICAgaWYgKCFqJC51dGlsLmhhcyhiLCBrZXkpKSB7XG4gICAgICAgIGRpZmZCdWlsZGVyLnJlY29yZE1pc21hdGNoKFxuICAgICAgICAgIG9iamVjdEtleXNBcmVEaWZmZXJlbnRGb3JtYXR0ZXIuYmluZChudWxsLCB0aGlzLnBwKVxuICAgICAgICApO1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGRpZmZCdWlsZGVyLndpdGhQYXRoKGtleSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghc2VsZi5lcV8oYVtrZXldLCBiW2tleV0sIGFTdGFjaywgYlN0YWNrLCBkaWZmQnVpbGRlcikpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucG9wKCk7XG4gICAgYlN0YWNrLnBvcCgpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBmdW5jdGlvbiBrZXlzKG9iaiwgaXNBcnJheSkge1xuICAgIHZhciBhbGxLZXlzID0gT2JqZWN0LmtleXNcbiAgICAgID8gT2JqZWN0LmtleXMob2JqKVxuICAgICAgOiAoZnVuY3Rpb24obykge1xuICAgICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIG8pIHtcbiAgICAgICAgICAgIGlmIChqJC51dGlsLmhhcyhvLCBrZXkpKSB7XG4gICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgICAgfSkob2JqKTtcblxuICAgIGlmICghaXNBcnJheSkge1xuICAgICAgcmV0dXJuIGFsbEtleXM7XG4gICAgfVxuXG4gICAgaWYgKGFsbEtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYWxsS2V5cztcbiAgICB9XG5cbiAgICB2YXIgZXh0cmFLZXlzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIS9eWzAtOV0rJC8udGVzdChhbGxLZXlzW2ldKSkge1xuICAgICAgICBleHRyYUtleXMucHVzaChhbGxLZXlzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXh0cmFLZXlzO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGZ1bmN0aW9uIG9iamVjdEtleXNBcmVEaWZmZXJlbnRGb3JtYXR0ZXIocHAsIGFjdHVhbCwgZXhwZWN0ZWQsIHBhdGgpIHtcbiAgICB2YXIgbWlzc2luZ1Byb3BlcnRpZXMgPSBqJC51dGlsLm9iamVjdERpZmZlcmVuY2UoZXhwZWN0ZWQsIGFjdHVhbCksXG4gICAgICBleHRyYVByb3BlcnRpZXMgPSBqJC51dGlsLm9iamVjdERpZmZlcmVuY2UoYWN0dWFsLCBleHBlY3RlZCksXG4gICAgICBtaXNzaW5nUHJvcGVydGllc01lc3NhZ2UgPSBmb3JtYXRLZXlWYWx1ZVBhaXJzKHBwLCBtaXNzaW5nUHJvcGVydGllcyksXG4gICAgICBleHRyYVByb3BlcnRpZXNNZXNzYWdlID0gZm9ybWF0S2V5VmFsdWVQYWlycyhwcCwgZXh0cmFQcm9wZXJ0aWVzKSxcbiAgICAgIG1lc3NhZ2VzID0gW107XG5cbiAgICBpZiAoIXBhdGguZGVwdGgoKSkge1xuICAgICAgcGF0aCA9ICdvYmplY3QnO1xuICAgIH1cblxuICAgIGlmIChtaXNzaW5nUHJvcGVydGllc01lc3NhZ2UubGVuZ3RoKSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKFxuICAgICAgICAnRXhwZWN0ZWQgJyArIHBhdGggKyAnIHRvIGhhdmUgcHJvcGVydGllcycgKyBtaXNzaW5nUHJvcGVydGllc01lc3NhZ2VcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGV4dHJhUHJvcGVydGllc01lc3NhZ2UubGVuZ3RoKSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKFxuICAgICAgICAnRXhwZWN0ZWQgJyArIHBhdGggKyAnIG5vdCB0byBoYXZlIHByb3BlcnRpZXMnICsgZXh0cmFQcm9wZXJ0aWVzTWVzc2FnZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVzc2FnZXMuam9pbignXFxuJyk7XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdHJ1Y3RvcnNBcmVEaWZmZXJlbnRGb3JtYXR0ZXIocHAsIGFjdHVhbCwgZXhwZWN0ZWQsIHBhdGgpIHtcbiAgICBpZiAoIXBhdGguZGVwdGgoKSkge1xuICAgICAgcGF0aCA9ICdvYmplY3QnO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAnRXhwZWN0ZWQgJyArXG4gICAgICBwYXRoICtcbiAgICAgICcgdG8gYmUgYSBraW5kIG9mICcgK1xuICAgICAgaiQuZm5OYW1lRm9yKGV4cGVjdGVkLmNvbnN0cnVjdG9yKSArXG4gICAgICAnLCBidXQgd2FzICcgK1xuICAgICAgcHAoYWN0dWFsKSArXG4gICAgICAnLidcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gYWN0dWFsQXJyYXlJc0xvbmdlckZvcm1hdHRlcihwcCwgYWN0dWFsLCBleHBlY3RlZCwgcGF0aCkge1xuICAgIHJldHVybiAoXG4gICAgICAnVW5leHBlY3RlZCAnICtcbiAgICAgIHBhdGggK1xuICAgICAgKHBhdGguZGVwdGgoKSA/ICcgPSAnIDogJycpICtcbiAgICAgIHBwKGFjdHVhbCkgK1xuICAgICAgJyBpbiBhcnJheS4nXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdEtleVZhbHVlUGFpcnMocHAsIG9iaikge1xuICAgIHZhciBmb3JtYXR0ZWQgPSAnJztcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBmb3JtYXR0ZWQgKz0gJ1xcbiAgICAnICsga2V5ICsgJzogJyArIHBwKG9ialtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdHRlZDtcbiAgfVxuXG4gIHJldHVybiBNYXRjaGVyc1V0aWw7XG59O1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgQXN5bW1ldHJpY0VxdWFsaXR5VGVzdGVyXG4gKiBAY2xhc3NkZXNjIEFuIGFzeW1tZXRyaWMgZXF1YWxpdHkgdGVzdGVyIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBtYXRjaCBtdWx0aXBsZVxuICogb2JqZWN0cy4gRXhhbXBsZXMgaW5jbHVkZSBqYXNtaW5lLmFueSgpIGFuZCBqYXNtaW5lLnN0cmluZ01hdGNoaW5nKCkuIEphc21pbmVcbiAqIGluY2x1ZGVzIGEgbnVtYmVyIG9mIGJ1aWx0LWluIGFzeW1tZXRyaWMgZXF1YWxpdHkgdGVzdGVycywgc3VjaCBhc1xuICoge0BsaW5rIGphc21pbmUub2JqZWN0Q29udGFpbmluZ30uIFVzZXItZGVmaW5lZCBhc3ltbWV0cmljIGVxdWFsaXR5IHRlc3RlcnMgYXJlXG4gKiBhbHNvIHN1cHBvcnRlZC5cbiAqXG4gKiBBc3ltbWV0cmljIGVxdWFsaXR5IHRlc3RlcnMgd29yayB3aXRoIGFueSBtYXRjaGVyLCBpbmNsdWRpbmcgdXNlci1kZWZpbmVkXG4gKiBjdXN0b20gbWF0Y2hlcnMsIHRoYXQgdXNlcyB7QGxpbmsgTWF0Y2hlcnNVdGlsI2VxdWFsc30gb3JcbiAqIHtAbGluayBNYXRjaGVyc1V0aWwjY29udGFpbnN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBmdW5jdGlvbiBudW1iZXJEaXZpc2libGVCeShkaXZpc29yKSB7XG4gKiAgIHJldHVybiB7XG4gKiAgICAgYXN5bW1ldHJpY01hdGNoOiBmdW5jdGlvbihuKSB7XG4gKiAgICAgICByZXR1cm4gdHlwZW9mIG4gPT09ICdudW1iZXInICYmIG4gJSBkaXZpc29yID09PSAwO1xuICogICAgIH0sXG4gKiAgICAgamFzbWluZVRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJldHVybiBgPGEgbnVtYmVyIGRpdmlzaWJsZSBieSAke2Rpdmlzb3J9PmA7XG4gKiAgICAgfVxuICogICB9O1xuICogfVxuICpcbiAqIHZhciBhY3R1YWwgPSB7XG4gKiAgIG46IDIsXG4gKiAgIG90aGVyRmllbGRzOiBcImRvbid0IGNhcmVcIlxuICogfTtcbiAqXG4gKiBleHBlY3QoYWN0dWFsKS50b0VxdWFsKGphc21pbmUub2JqZWN0Q29udGFpbmluZyh7bjogbnVtYmVyRGl2aXNpYmxlQnkoMil9KSk7XG4gKiBAc2VlIGN1c3RvbV9hc3ltbWV0cmljX2VxdWFsaXR5X3Rlc3RlcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIHZhbHVlIG1hdGNoZXMgdGhpcyB0ZXN0ZXJcbiAqIEBmdW5jdGlvblxuICogQG5hbWUgQXN5bW1ldHJpY0VxdWFsaXR5VGVzdGVyI2FzeW1tZXRyaWNNYXRjaFxuICogQHBhcmFtIHZhbHVlIHthbnl9IFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcGFyYW0gbWF0Y2hlcnNVdGlsIHtNYXRjaGVyc1V0aWx9IHV0aWxpdGllcyBmb3IgdGVzdGluZyBlcXVhbGl0eSwgZXRjXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0ZXN0ZXIgdG8gdXNlIGluIG1hdGNoZXIgZmFpbHVyZSBtZXNzYWdlc1xuICogQGZ1bmN0aW9uXG4gKiBAbmFtZSBBc3ltbWV0cmljRXF1YWxpdHlUZXN0ZXIjamFzbWluZVRvU3RyaW5nXG4gKiBAcGFyYW0gcHAge2Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IHRha2VzIGEgdmFsdWUgYW5kIHJldHVybnMgYSBwcmV0dHktcHJpbnRlZCByZXByZXNlbnRhdGlvblxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuTWlzbWF0Y2hUcmVlID0gZnVuY3Rpb24oaiQpIHtcbiAgLypcbiAgICBUbyBiZSBhYmxlIHRvIGFwcGx5IGN1c3RvbSBvYmplY3QgZm9ybWF0dGVycyBhdCBhbGwgcG9zc2libGUgbGV2ZWxzIG9mIGFuXG4gICAgb2JqZWN0IGdyYXBoLCBEaWZmQnVpbGRlciBuZWVkcyB0byBiZSBhYmxlIHRvIGtub3cgbm90IGp1c3Qgd2hlcmUgdGhlXG4gICAgbWlzbWF0Y2ggb2NjdXJyZWQgYnV0IGFsc28gYWxsIGFuY2VzdG9ycyBvZiB0aGUgbWlzbWF0Y2hlZCB2YWx1ZSBpbiBib3RoXG4gICAgdGhlIGV4cGVjdGVkIGFuZCBhY3R1YWwgb2JqZWN0IGdyYXBocy4gTWlzbWF0Y2hUcmVlIG1haW50YWlucyB0aGF0IGNvbnRleHRcbiAgICBhbmQgcHJvdmlkZXMgaXQgdmlhIHRoZSB0cmF2ZXJzZSBtZXRob2QuXG4gICAqL1xuICBmdW5jdGlvbiBNaXNtYXRjaFRyZWUocGF0aCkge1xuICAgIHRoaXMucGF0aCA9IHBhdGggfHwgbmV3IGokLk9iamVjdFBhdGgoW10pO1xuICAgIHRoaXMuZm9ybWF0dGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLmlzTWlzbWF0Y2ggPSBmYWxzZTtcbiAgfVxuXG4gIE1pc21hdGNoVHJlZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ocGF0aCwgZm9ybWF0dGVyKSB7XG4gICAgdmFyIGtleSwgY2hpbGQ7XG5cbiAgICBpZiAocGF0aC5kZXB0aCgpID09PSAwKSB7XG4gICAgICB0aGlzLmZvcm1hdHRlciA9IGZvcm1hdHRlcjtcbiAgICAgIHRoaXMuaXNNaXNtYXRjaCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IHBhdGguY29tcG9uZW50c1swXTtcbiAgICAgIHBhdGggPSBwYXRoLnNoaWZ0KCk7XG4gICAgICBjaGlsZCA9IHRoaXMuY2hpbGQoa2V5KTtcblxuICAgICAgaWYgKCFjaGlsZCkge1xuICAgICAgICBjaGlsZCA9IG5ldyBNaXNtYXRjaFRyZWUodGhpcy5wYXRoLmFkZChrZXkpKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQuYWRkKHBhdGgsIGZvcm1hdHRlcik7XG4gICAgfVxuICB9O1xuXG4gIE1pc21hdGNoVHJlZS5wcm90b3R5cGUudHJhdmVyc2UgPSBmdW5jdGlvbih2aXNpdCkge1xuICAgIHZhciBpLFxuICAgICAgaGFzQ2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDA7XG5cbiAgICBpZiAodGhpcy5pc01pc21hdGNoIHx8IGhhc0NoaWxkcmVuKSB7XG4gICAgICBpZiAodmlzaXQodGhpcy5wYXRoLCAhaGFzQ2hpbGRyZW4sIHRoaXMuZm9ybWF0dGVyKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0udHJhdmVyc2UodmlzaXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIE1pc21hdGNoVHJlZS5wcm90b3R5cGUuY2hpbGQgPSBmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgaSwgcGF0aEVscztcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwYXRoRWxzID0gdGhpcy5jaGlsZHJlbltpXS5wYXRoLmNvbXBvbmVudHM7XG4gICAgICBpZiAocGF0aEVsc1twYXRoRWxzLmxlbmd0aCAtIDFdID09PSBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5baV07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBNaXNtYXRjaFRyZWU7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLm5vdGhpbmcgPSBmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IG5vdGhpbmcgZXhwbGljaXRseS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI25vdGhpbmdcbiAgICogQHNpbmNlIDIuOC4wXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdCgpLm5vdGhpbmcoKTtcbiAgICovXG4gIGZ1bmN0aW9uIG5vdGhpbmcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhc3M6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG5vdGhpbmc7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLk51bGxEaWZmQnVpbGRlciA9IGZ1bmN0aW9uKGokKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2l0aFBhdGg6IGZ1bmN0aW9uKF8sIGJsb2NrKSB7XG4gICAgICAgIGJsb2NrKCk7XG4gICAgICB9LFxuICAgICAgc2V0Um9vdHM6IGZ1bmN0aW9uKCkge30sXG4gICAgICByZWNvcmRNaXNtYXRjaDogZnVuY3Rpb24oKSB7fVxuICAgIH07XG4gIH07XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLk9iamVjdFBhdGggPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBPYmplY3RQYXRoKGNvbXBvbmVudHMpIHtcbiAgICB0aGlzLmNvbXBvbmVudHMgPSBjb21wb25lbnRzIHx8IFtdO1xuICB9XG5cbiAgT2JqZWN0UGF0aC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5jb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuICckJyArIG1hcCh0aGlzLmNvbXBvbmVudHMsIGZvcm1hdFByb3BlcnR5QWNjZXNzKS5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfTtcblxuICBPYmplY3RQYXRoLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICByZXR1cm4gbmV3IE9iamVjdFBhdGgodGhpcy5jb21wb25lbnRzLmNvbmNhdChbY29tcG9uZW50XSkpO1xuICB9O1xuXG4gIE9iamVjdFBhdGgucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBPYmplY3RQYXRoKHRoaXMuY29tcG9uZW50cy5zbGljZSgxKSk7XG4gIH07XG5cbiAgT2JqZWN0UGF0aC5wcm90b3R5cGUuZGVwdGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb25lbnRzLmxlbmd0aDtcbiAgfTtcblxuICBmdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eUFjY2Vzcyhwcm9wKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuICdbJyArIHByb3AgKyAnXSc7XG4gICAgfVxuXG4gICAgaWYgKGlzVmFsaWRJZGVudGlmaWVyKHByb3ApKSB7XG4gICAgICByZXR1cm4gJy4nICsgcHJvcDtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJbJ1wiICsgcHJvcCArIFwiJ11cIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdHMucHVzaChmbihhcnJheVtpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVmFsaWRJZGVudGlmaWVyKHN0cmluZykge1xuICAgIHJldHVybiAvXltBLVphLXpcXCRfXVtBLVphLXowLTlcXCRfXSokLy50ZXN0KHN0cmluZyk7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0UGF0aDtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkucmVxdWlyZUFzeW5jTWF0Y2hlcnMgPSBmdW5jdGlvbihqUmVxdWlyZSwgaiQpIHtcbiAgdmFyIGF2YWlsYWJsZU1hdGNoZXJzID0gW1xuICAgICAgJ3RvQmVQZW5kaW5nJyxcbiAgICAgICd0b0JlUmVzb2x2ZWQnLFxuICAgICAgJ3RvQmVSZWplY3RlZCcsXG4gICAgICAndG9CZVJlc29sdmVkVG8nLFxuICAgICAgJ3RvQmVSZWplY3RlZFdpdGgnLFxuICAgICAgJ3RvQmVSZWplY3RlZFdpdGhFcnJvcidcbiAgICBdLFxuICAgIG1hdGNoZXJzID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdmFpbGFibGVNYXRjaGVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuYW1lID0gYXZhaWxhYmxlTWF0Y2hlcnNbaV07XG4gICAgbWF0Y2hlcnNbbmFtZV0gPSBqUmVxdWlyZVtuYW1lXShqJCk7XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcnM7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmUgPSBmdW5jdGlvbihqJCkge1xuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCB2YWx1ZSB0byBiZSBgPT09YCB0byB0aGUgZXhwZWN0ZWQgdmFsdWUuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0JlXG4gICAqIEBzaW5jZSAxLjMuMFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXhwZWN0ZWQgLSBUaGUgZXhwZWN0ZWQgdmFsdWUgdG8gY29tcGFyZSBhZ2FpbnN0LlxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QodGhpbmcpLnRvQmUocmVhbFRoaW5nKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvQmUobWF0Y2hlcnNVdGlsKSB7XG4gICAgdmFyIHRpcCA9XG4gICAgICAnIFRpcDogVG8gY2hlY2sgZm9yIGRlZXAgZXF1YWxpdHksIHVzZSAudG9FcXVhbCgpIGluc3RlYWQgb2YgLnRvQmUoKS4nO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICBwYXNzOiBhY3R1YWwgPT09IGV4cGVjdGVkXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9XG4gICAgICAgICAgICBtYXRjaGVyc1V0aWwuYnVpbGRGYWlsdXJlTWVzc2FnZShcbiAgICAgICAgICAgICAgJ3RvQmUnLFxuICAgICAgICAgICAgICByZXN1bHQucGFzcyxcbiAgICAgICAgICAgICAgYWN0dWFsLFxuICAgICAgICAgICAgICBleHBlY3RlZFxuICAgICAgICAgICAgKSArIHRpcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0JlO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlQ2xvc2VUbyA9IGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCB2YWx1ZSB0byBiZSB3aXRoaW4gYSBzcGVjaWZpZWQgcHJlY2lzaW9uIG9mIHRoZSBleHBlY3RlZCB2YWx1ZS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvQmVDbG9zZVRvXG4gICAqIEBzaW5jZSAxLjMuMFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXhwZWN0ZWQgLSBUaGUgZXhwZWN0ZWQgdmFsdWUgdG8gY29tcGFyZSBhZ2FpbnN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3ByZWNpc2lvbj0yXSAtIFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwb2ludHMgdG8gY2hlY2suXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdChudW1iZXIpLnRvQmVDbG9zZVRvKDQyLjIsIDMpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9CZUNsb3NlVG8oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQsIHByZWNpc2lvbikge1xuICAgICAgICBpZiAocHJlY2lzaW9uICE9PSAwKSB7XG4gICAgICAgICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXhwZWN0ZWQgPT09IG51bGwgfHwgYWN0dWFsID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0Nhbm5vdCB1c2UgdG9CZUNsb3NlVG8gd2l0aCBudWxsLiBBcmd1bWVudHMgZXZhbHVhdGVkIHRvOiAnICtcbiAgICAgICAgICAgICAgJ2V4cGVjdCgnICtcbiAgICAgICAgICAgICAgYWN0dWFsICtcbiAgICAgICAgICAgICAgJykudG9CZUNsb3NlVG8oJyArXG4gICAgICAgICAgICAgIGV4cGVjdGVkICtcbiAgICAgICAgICAgICAgJykuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG93ID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbiArIDEpO1xuICAgICAgICB2YXIgZGVsdGEgPSBNYXRoLmFicyhleHBlY3RlZCAtIGFjdHVhbCk7XG4gICAgICAgIHZhciBtYXhEZWx0YSA9IE1hdGgucG93KDEwLCAtcHJlY2lzaW9uKSAvIDI7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXNzOiBNYXRoLnJvdW5kKGRlbHRhICogcG93KSA8PSBtYXhEZWx0YSAqIHBvd1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9CZUNsb3NlVG87XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVEZWZpbmVkID0gZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIHZhbHVlIHRvIGJlIGRlZmluZWQuIChOb3QgYHVuZGVmaW5lZGApXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0JlRGVmaW5lZFxuICAgKiBAc2luY2UgMS4zLjBcbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KHJlc3VsdCkudG9CZURlZmluZWQoKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvQmVEZWZpbmVkKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXNzOiB2b2lkIDAgIT09IGFjdHVhbFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9CZURlZmluZWQ7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVGYWxzZSA9IGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCB2YWx1ZSB0byBiZSBgZmFsc2VgLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9CZUZhbHNlXG4gICAqIEBzaW5jZSAzLjUuMFxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QocmVzdWx0KS50b0JlRmFsc2UoKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvQmVGYWxzZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFzczogYWN0dWFsID09PSBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9CZUZhbHNlO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlRmFsc3kgPSBmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgdmFsdWUgdG8gYmUgZmFsc3lcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvQmVGYWxzeVxuICAgKiBAc2luY2UgMi4wLjBcbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KHJlc3VsdCkudG9CZUZhbHN5KCk7XG4gICAqL1xuICBmdW5jdGlvbiB0b0JlRmFsc3koKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhc3M6ICFhY3R1YWxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvQmVGYWxzeTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZUdyZWF0ZXJUaGFuID0gZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIHZhbHVlIHRvIGJlIGdyZWF0ZXIgdGhhbiB0aGUgZXhwZWN0ZWQgdmFsdWUuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0JlR3JlYXRlclRoYW5cbiAgICogQHNpbmNlIDIuMC4wXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBleHBlY3RlZCAtIFRoZSB2YWx1ZSB0byBjb21wYXJlIGFnYWluc3QuXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdChyZXN1bHQpLnRvQmVHcmVhdGVyVGhhbigzKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvQmVHcmVhdGVyVGhhbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhc3M6IGFjdHVhbCA+IGV4cGVjdGVkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0JlR3JlYXRlclRoYW47XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwgPSBmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgdmFsdWUgdG8gYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBleHBlY3RlZCB2YWx1ZS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvQmVHcmVhdGVyVGhhbk9yRXF1YWxcbiAgICogQHNpbmNlIDIuMC4wXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBleHBlY3RlZCAtIFRoZSBleHBlY3RlZCB2YWx1ZSB0byBjb21wYXJlIGFnYWluc3QuXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdChyZXN1bHQpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMjUpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhc3M6IGFjdHVhbCA+PSBleHBlY3RlZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9CZUdyZWF0ZXJUaGFuT3JFcXVhbDtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZUluc3RhbmNlT2YgPSBmdW5jdGlvbihqJCkge1xuICB2YXIgdXNhZ2VFcnJvciA9IGokLmZvcm1hdEVycm9yTXNnKFxuICAgICc8dG9CZUluc3RhbmNlT2Y+JyxcbiAgICAnZXhwZWN0KHZhbHVlKS50b0JlSW5zdGFuY2VPZig8Q29uc3RydWN0b3JGdW5jdGlvbj4pJ1xuICApO1xuXG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIHRvIGJlIGFuIGluc3RhbmNlIG9mIHRoZSBleHBlY3RlZCBjbGFzc1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9CZUluc3RhbmNlT2ZcbiAgICogQHNpbmNlIDMuNS4wXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHBlY3RlZCAtIFRoZSBjbGFzcyBvciBjb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBjaGVjayBmb3JcbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KCdmb28nKS50b0JlSW5zdGFuY2VPZihTdHJpbmcpO1xuICAgKiBleHBlY3QoMykudG9CZUluc3RhbmNlT2YoTnVtYmVyKTtcbiAgICogZXhwZWN0KG5ldyBFcnJvcigpKS50b0JlSW5zdGFuY2VPZihFcnJvcik7XG4gICAqL1xuICBmdW5jdGlvbiB0b0JlSW5zdGFuY2VPZihtYXRjaGVyc1V0aWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICAgICAgICB2YXIgYWN0dWFsVHlwZSA9XG4gICAgICAgICAgICBhY3R1YWwgJiYgYWN0dWFsLmNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgID8gaiQuZm5OYW1lRm9yKGFjdHVhbC5jb25zdHJ1Y3RvcilcbiAgICAgICAgICAgICAgOiBtYXRjaGVyc1V0aWwucHAoYWN0dWFsKSxcbiAgICAgICAgICBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFxuICAgICAgICAgICAgPyBqJC5mbk5hbWVGb3IoZXhwZWN0ZWQpXG4gICAgICAgICAgICA6IG1hdGNoZXJzVXRpbC5wcChleHBlY3RlZCksXG4gICAgICAgICAgZXhwZWN0ZWRNYXRjaGVyLFxuICAgICAgICAgIHBhc3M7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBleHBlY3RlZE1hdGNoZXIgPSBuZXcgaiQuQW55KGV4cGVjdGVkKTtcbiAgICAgICAgICBwYXNzID0gZXhwZWN0ZWRNYXRjaGVyLmFzeW1tZXRyaWNNYXRjaChhY3R1YWwpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIHVzYWdlRXJyb3IoJ0V4cGVjdGVkIHZhbHVlIGlzIG5vdCBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhc3MpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGFzczogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAgICdFeHBlY3RlZCBpbnN0YW5jZSBvZiAnICtcbiAgICAgICAgICAgICAgYWN0dWFsVHlwZSArXG4gICAgICAgICAgICAgICcgbm90IHRvIGJlIGFuIGluc3RhbmNlIG9mICcgK1xuICAgICAgICAgICAgICBleHBlY3RlZFR5cGVcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXNzOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAgICdFeHBlY3RlZCBpbnN0YW5jZSBvZiAnICtcbiAgICAgICAgICAgICAgYWN0dWFsVHlwZSArXG4gICAgICAgICAgICAgICcgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgJyArXG4gICAgICAgICAgICAgIGV4cGVjdGVkVHlwZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvQmVJbnN0YW5jZU9mO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlTGVzc1RoYW4gPSBmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgdmFsdWUgdG8gYmUgbGVzcyB0aGFuIHRoZSBleHBlY3RlZCB2YWx1ZS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvQmVMZXNzVGhhblxuICAgKiBAc2luY2UgMi4wLjBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV4cGVjdGVkIC0gVGhlIGV4cGVjdGVkIHZhbHVlIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KHJlc3VsdCkudG9CZUxlc3NUaGFuKDApO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9CZUxlc3NUaGFuKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFzczogYWN0dWFsIDwgZXhwZWN0ZWRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvQmVMZXNzVGhhbjtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZUxlc3NUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCB2YWx1ZSB0byBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGV4cGVjdGVkIHZhbHVlLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9CZUxlc3NUaGFuT3JFcXVhbFxuICAgKiBAc2luY2UgMi4wLjBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV4cGVjdGVkIC0gVGhlIGV4cGVjdGVkIHZhbHVlIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KHJlc3VsdCkudG9CZUxlc3NUaGFuT3JFcXVhbCgxMjMpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9CZUxlc3NUaGFuT3JFcXVhbCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhc3M6IGFjdHVhbCA8PSBleHBlY3RlZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9CZUxlc3NUaGFuT3JFcXVhbDtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZU5hTiA9IGZ1bmN0aW9uKGokKSB7XG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIHZhbHVlIHRvIGJlIGBOYU5gIChOb3QgYSBOdW1iZXIpLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9CZU5hTlxuICAgKiBAc2luY2UgMS4zLjBcbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KHRoaW5nKS50b0JlTmFOKCk7XG4gICAqL1xuICBmdW5jdGlvbiB0b0JlTmFOKG1hdGNoZXJzVXRpbCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICBwYXNzOiBhY3R1YWwgIT09IGFjdHVhbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChyZXN1bHQucGFzcykge1xuICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID0gJ0V4cGVjdGVkIGFjdHVhbCBub3QgdG8gYmUgTmFOLic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAnRXhwZWN0ZWQgJyArIG1hdGNoZXJzVXRpbC5wcChhY3R1YWwpICsgJyB0byBiZSBOYU4uJztcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvQmVOYU47XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVOZWdhdGl2ZUluZmluaXR5ID0gZnVuY3Rpb24oaiQpIHtcbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgdmFsdWUgdG8gYmUgYC1JbmZpbml0eWAgKC1pbmZpbml0eSkuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0JlTmVnYXRpdmVJbmZpbml0eVxuICAgKiBAc2luY2UgMi42LjBcbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KHRoaW5nKS50b0JlTmVnYXRpdmVJbmZpbml0eSgpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9CZU5lZ2F0aXZlSW5maW5pdHkobWF0Y2hlcnNVdGlsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgIHBhc3M6IGFjdHVhbCA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHJlc3VsdC5wYXNzKSB7XG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSAnRXhwZWN0ZWQgYWN0dWFsIG5vdCB0byBiZSAtSW5maW5pdHkuJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICdFeHBlY3RlZCAnICsgbWF0Y2hlcnNVdGlsLnBwKGFjdHVhbCkgKyAnIHRvIGJlIC1JbmZpbml0eS4nO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9CZU5lZ2F0aXZlSW5maW5pdHk7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVOdWxsID0gZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIHZhbHVlIHRvIGJlIGBudWxsYC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvQmVOdWxsXG4gICAqIEBzaW5jZSAxLjMuMFxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9CZU51bGwoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhc3M6IGFjdHVhbCA9PT0gbnVsbFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9CZU51bGw7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVQb3NpdGl2ZUluZmluaXR5ID0gZnVuY3Rpb24oaiQpIHtcbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgdmFsdWUgdG8gYmUgYEluZmluaXR5YCAoaW5maW5pdHkpLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9CZVBvc2l0aXZlSW5maW5pdHlcbiAgICogQHNpbmNlIDIuNi4wXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdCh0aGluZykudG9CZVBvc2l0aXZlSW5maW5pdHkoKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvQmVQb3NpdGl2ZUluZmluaXR5KG1hdGNoZXJzVXRpbCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICBwYXNzOiBhY3R1YWwgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChyZXN1bHQucGFzcykge1xuICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID0gJ0V4cGVjdGVkIGFjdHVhbCBub3QgdG8gYmUgSW5maW5pdHkuJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICdFeHBlY3RlZCAnICsgbWF0Y2hlcnNVdGlsLnBwKGFjdHVhbCkgKyAnIHRvIGJlIEluZmluaXR5Lic7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0JlUG9zaXRpdmVJbmZpbml0eTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZVRydWUgPSBmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgdmFsdWUgdG8gYmUgYHRydWVgLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9CZVRydWVcbiAgICogQHNpbmNlIDMuNS4wXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdChyZXN1bHQpLnRvQmVUcnVlKCk7XG4gICAqL1xuICBmdW5jdGlvbiB0b0JlVHJ1ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFzczogYWN0dWFsID09PSB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0JlVHJ1ZTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZVRydXRoeSA9IGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCB2YWx1ZSB0byBiZSB0cnV0aHkuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0JlVHJ1dGh5XG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QodGhpbmcpLnRvQmVUcnV0aHkoKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvQmVUcnV0aHkoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhc3M6ICEhYWN0dWFsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0JlVHJ1dGh5O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlVW5kZWZpbmVkID0gZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIHZhbHVlIHRvIGJlIGB1bmRlZmluZWRgLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9CZVVuZGVmaW5lZFxuICAgKiBAc2luY2UgMS4zLjBcbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KHJlc3VsdCkudG9CZVVuZGVmaW5lZCgpOlxuICAgKi9cbiAgZnVuY3Rpb24gdG9CZVVuZGVmaW5lZCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFzczogdm9pZCAwID09PSBhY3R1YWxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvQmVVbmRlZmluZWQ7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQ29udGFpbiA9IGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCB2YWx1ZSB0byBjb250YWluIGEgc3BlY2lmaWMgdmFsdWUuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0NvbnRhaW5cbiAgICogQHNpbmNlIDIuMC4wXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHBlY3RlZCAtIFRoZSB2YWx1ZSB0byBsb29rIGZvci5cbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KGFycmF5KS50b0NvbnRhaW4oYW5FbGVtZW50KTtcbiAgICogZXhwZWN0KHN0cmluZykudG9Db250YWluKHN1YnN0cmluZyk7XG4gICAqL1xuICBmdW5jdGlvbiB0b0NvbnRhaW4obWF0Y2hlcnNVdGlsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXNzOiBtYXRjaGVyc1V0aWwuY29udGFpbnMoYWN0dWFsLCBleHBlY3RlZClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvQ29udGFpbjtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9FcXVhbCA9IGZ1bmN0aW9uKGokKSB7XG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIHZhbHVlIHRvIGJlIGVxdWFsIHRvIHRoZSBleHBlY3RlZCwgdXNpbmcgZGVlcCBlcXVhbGl0eSBjb21wYXJpc29uLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9FcXVhbFxuICAgKiBAc2luY2UgMS4zLjBcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4cGVjdGVkIC0gRXhwZWN0ZWQgdmFsdWVcbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KGJpZ09iamVjdCkudG9FcXVhbCh7XCJmb29cIjogWydiYXInLCAnYmF6J119KTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvRXF1YWwobWF0Y2hlcnNVdGlsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHBhc3M6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkaWZmQnVpbGRlciA9IGokLkRpZmZCdWlsZGVyKHsgcHJldHR5UHJpbnRlcjogbWF0Y2hlcnNVdGlsLnBwIH0pO1xuXG4gICAgICAgIHJlc3VsdC5wYXNzID0gbWF0Y2hlcnNVdGlsLmVxdWFscyhhY3R1YWwsIGV4cGVjdGVkLCBkaWZmQnVpbGRlcik7XG5cbiAgICAgICAgLy8gVE9ETzogb25seSBzZXQgZXJyb3IgbWVzc2FnZSBpZiB0ZXN0IGZhaWxzXG4gICAgICAgIHJlc3VsdC5tZXNzYWdlID0gZGlmZkJ1aWxkZXIuZ2V0TWVzc2FnZSgpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0VxdWFsO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0hhdmVCZWVuQ2FsbGVkID0gZnVuY3Rpb24oaiQpIHtcbiAgdmFyIGdldEVycm9yTXNnID0gaiQuZm9ybWF0RXJyb3JNc2coXG4gICAgJzx0b0hhdmVCZWVuQ2FsbGVkPicsXG4gICAgJ2V4cGVjdCg8c3B5T2JqPikudG9IYXZlQmVlbkNhbGxlZCgpJ1xuICApO1xuXG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIChhIHtAbGluayBTcHl9KSB0byBoYXZlIGJlZW4gY2FsbGVkLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9IYXZlQmVlbkNhbGxlZFxuICAgKiBAc2luY2UgMS4zLjBcbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KG15U3B5KS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAqIGV4cGVjdChteVNweSkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvSGF2ZUJlZW5DYWxsZWQobWF0Y2hlcnNVdGlsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICAgICAgaWYgKCFqJC5pc1NweShhY3R1YWwpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgZ2V0RXJyb3JNc2coXG4gICAgICAgICAgICAgICdFeHBlY3RlZCBhIHNweSwgYnV0IGdvdCAnICsgbWF0Y2hlcnNVdGlsLnBwKGFjdHVhbCkgKyAnLidcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgZ2V0RXJyb3JNc2coJ0RvZXMgbm90IHRha2UgYXJndW1lbnRzLCB1c2UgdG9IYXZlQmVlbkNhbGxlZFdpdGgnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQucGFzcyA9IGFjdHVhbC5jYWxscy5hbnkoKTtcblxuICAgICAgICByZXN1bHQubWVzc2FnZSA9IHJlc3VsdC5wYXNzXG4gICAgICAgICAgPyAnRXhwZWN0ZWQgc3B5ICcgKyBhY3R1YWwuYW5kLmlkZW50aXR5ICsgJyBub3QgdG8gaGF2ZSBiZWVuIGNhbGxlZC4nXG4gICAgICAgICAgOiAnRXhwZWN0ZWQgc3B5ICcgKyBhY3R1YWwuYW5kLmlkZW50aXR5ICsgJyB0byBoYXZlIGJlZW4gY2FsbGVkLic7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvSGF2ZUJlZW5DYWxsZWQ7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvSGF2ZUJlZW5DYWxsZWRCZWZvcmUgPSBmdW5jdGlvbihqJCkge1xuICB2YXIgZ2V0RXJyb3JNc2cgPSBqJC5mb3JtYXRFcnJvck1zZyhcbiAgICAnPHRvSGF2ZUJlZW5DYWxsZWRCZWZvcmU+JyxcbiAgICAnZXhwZWN0KDxzcHlPYmo+KS50b0hhdmVCZWVuQ2FsbGVkQmVmb3JlKDxzcHlPYmo+KSdcbiAgKTtcblxuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCB2YWx1ZSAoYSB7QGxpbmsgU3B5fSkgdG8gaGF2ZSBiZWVuIGNhbGxlZCBiZWZvcmUgYW5vdGhlciB7QGxpbmsgU3B5fS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvSGF2ZUJlZW5DYWxsZWRCZWZvcmVcbiAgICogQHNpbmNlIDIuNi4wXG4gICAqIEBwYXJhbSB7U3B5fSBleHBlY3RlZCAtIHtAbGluayBTcHl9IHRoYXQgc2hvdWxkIGhhdmUgYmVlbiBjYWxsZWQgYWZ0ZXIgdGhlIGBhY3R1YWxgIHtAbGluayBTcHl9LlxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QobXlTcHkpLnRvSGF2ZUJlZW5DYWxsZWRCZWZvcmUob3RoZXJTcHkpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9IYXZlQmVlbkNhbGxlZEJlZm9yZShtYXRjaGVyc1V0aWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oZmlyc3RTcHksIGxhdHRlclNweSkge1xuICAgICAgICBpZiAoIWokLmlzU3B5KGZpcnN0U3B5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGdldEVycm9yTXNnKFxuICAgICAgICAgICAgICAnRXhwZWN0ZWQgYSBzcHksIGJ1dCBnb3QgJyArIG1hdGNoZXJzVXRpbC5wcChmaXJzdFNweSkgKyAnLidcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaiQuaXNTcHkobGF0dGVyU3B5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGdldEVycm9yTXNnKFxuICAgICAgICAgICAgICAnRXhwZWN0ZWQgYSBzcHksIGJ1dCBnb3QgJyArIG1hdGNoZXJzVXRpbC5wcChsYXR0ZXJTcHkpICsgJy4nXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSB7IHBhc3M6IGZhbHNlIH07XG5cbiAgICAgICAgaWYgKCFmaXJzdFNweS5jYWxscy5jb3VudCgpKSB7XG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPVxuICAgICAgICAgICAgJ0V4cGVjdGVkIHNweSAnICsgZmlyc3RTcHkuYW5kLmlkZW50aXR5ICsgJyB0byBoYXZlIGJlZW4gY2FsbGVkLic7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxhdHRlclNweS5jYWxscy5jb3VudCgpKSB7XG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPVxuICAgICAgICAgICAgJ0V4cGVjdGVkIHNweSAnICsgbGF0dGVyU3B5LmFuZC5pZGVudGl0eSArICcgdG8gaGF2ZSBiZWVuIGNhbGxlZC4nO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGF0ZXN0MXN0U3B5Q2FsbCA9IGZpcnN0U3B5LmNhbGxzLm1vc3RSZWNlbnQoKS5pbnZvY2F0aW9uT3JkZXI7XG4gICAgICAgIHZhciBmaXJzdDJuZFNweUNhbGwgPSBsYXR0ZXJTcHkuY2FsbHMuZmlyc3QoKS5pbnZvY2F0aW9uT3JkZXI7XG5cbiAgICAgICAgcmVzdWx0LnBhc3MgPSBsYXRlc3Qxc3RTcHlDYWxsIDwgZmlyc3QybmRTcHlDYWxsO1xuXG4gICAgICAgIGlmIChyZXN1bHQucGFzcykge1xuICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID1cbiAgICAgICAgICAgICdFeHBlY3RlZCBzcHkgJyArXG4gICAgICAgICAgICBmaXJzdFNweS5hbmQuaWRlbnRpdHkgK1xuICAgICAgICAgICAgJyB0byBub3QgaGF2ZSBiZWVuIGNhbGxlZCBiZWZvcmUgc3B5ICcgK1xuICAgICAgICAgICAgbGF0dGVyU3B5LmFuZC5pZGVudGl0eSArXG4gICAgICAgICAgICAnLCBidXQgaXQgd2FzJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZmlyc3Qxc3RTcHlDYWxsID0gZmlyc3RTcHkuY2FsbHMuZmlyc3QoKS5pbnZvY2F0aW9uT3JkZXI7XG4gICAgICAgICAgdmFyIGxhdGVzdDJuZFNweUNhbGwgPSBsYXR0ZXJTcHkuY2FsbHMubW9zdFJlY2VudCgpLmludm9jYXRpb25PcmRlcjtcblxuICAgICAgICAgIGlmIChmaXJzdDFzdFNweUNhbGwgPCBmaXJzdDJuZFNweUNhbGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID1cbiAgICAgICAgICAgICAgJ0V4cGVjdGVkIGxhdGVzdCBjYWxsIHRvIHNweSAnICtcbiAgICAgICAgICAgICAgZmlyc3RTcHkuYW5kLmlkZW50aXR5ICtcbiAgICAgICAgICAgICAgJyB0byBoYXZlIGJlZW4gY2FsbGVkIGJlZm9yZSBmaXJzdCBjYWxsIHRvIHNweSAnICtcbiAgICAgICAgICAgICAgbGF0dGVyU3B5LmFuZC5pZGVudGl0eSArXG4gICAgICAgICAgICAgICcgKG5vIGludGVybGVhdmVkIGNhbGxzKSc7XG4gICAgICAgICAgfSBlbHNlIGlmIChsYXRlc3QybmRTcHlDYWxsID4gbGF0ZXN0MXN0U3B5Q2FsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPVxuICAgICAgICAgICAgICAnRXhwZWN0ZWQgZmlyc3QgY2FsbCB0byBzcHkgJyArXG4gICAgICAgICAgICAgIGxhdHRlclNweS5hbmQuaWRlbnRpdHkgK1xuICAgICAgICAgICAgICAnIHRvIGhhdmUgYmVlbiBjYWxsZWQgYWZ0ZXIgbGF0ZXN0IGNhbGwgdG8gc3B5ICcgK1xuICAgICAgICAgICAgICBmaXJzdFNweS5hbmQuaWRlbnRpdHkgK1xuICAgICAgICAgICAgICAnIChubyBpbnRlcmxlYXZlZCBjYWxscyknO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQubWVzc2FnZSA9XG4gICAgICAgICAgICAgICdFeHBlY3RlZCBzcHkgJyArXG4gICAgICAgICAgICAgIGZpcnN0U3B5LmFuZC5pZGVudGl0eSArXG4gICAgICAgICAgICAgICcgdG8gaGF2ZSBiZWVuIGNhbGxlZCBiZWZvcmUgc3B5ICcgK1xuICAgICAgICAgICAgICBsYXR0ZXJTcHkuYW5kLmlkZW50aXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0hhdmVCZWVuQ2FsbGVkQmVmb3JlO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0hhdmVCZWVuQ2FsbGVkT25jZVdpdGggPSBmdW5jdGlvbihqJCkge1xuICB2YXIgZ2V0RXJyb3JNc2cgPSBqJC5mb3JtYXRFcnJvck1zZyhcbiAgICAnPHRvSGF2ZUJlZW5DYWxsZWRPbmNlV2l0aD4nLFxuICAgICdleHBlY3QoPHNweU9iaj4pLnRvSGF2ZUJlZW5DYWxsZWRPbmNlV2l0aCguLi5hcmd1bWVudHMpJ1xuICApO1xuXG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIChhIHtAbGluayBTcHl9KSB0byBoYXZlIGJlZW4gY2FsbGVkIGV4YWN0bHkgb25jZSwgYW5kIGV4YWN0bHkgd2l0aCB0aGUgcGFydGljdWxhciBhcmd1bWVudHMuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0hhdmVCZWVuQ2FsbGVkT25jZVdpdGhcbiAgICogQHNpbmNlIDMuNi4wXG4gICAqIEBwYXJhbSB7Li4uT2JqZWN0fSAtIFRoZSBhcmd1bWVudHMgdG8gbG9vayBmb3JcbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KG15U3B5KS50b0hhdmVCZWVuQ2FsbGVkT25jZVdpdGgoJ2ZvbycsICdiYXInLCAyKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvSGF2ZUJlZW5DYWxsZWRPbmNlV2l0aCh1dGlsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCksXG4gICAgICAgICAgYWN0dWFsID0gYXJnc1swXSxcbiAgICAgICAgICBleHBlY3RlZEFyZ3MgPSBhcmdzLnNsaWNlKDEpO1xuXG4gICAgICAgIGlmICghaiQuaXNTcHkoYWN0dWFsKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGdldEVycm9yTXNnKCdFeHBlY3RlZCBhIHNweSwgYnV0IGdvdCAnICsgdXRpbC5wcChhY3R1YWwpICsgJy4nKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJldHR5UHJpbnRlZENhbGxzID0gYWN0dWFsLmNhbGxzXG4gICAgICAgICAgLmFsbEFyZ3MoKVxuICAgICAgICAgIC5tYXAoZnVuY3Rpb24oYXJnc0ZvckNhbGwpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgdXRpbC5wcChhcmdzRm9yQ2FsbCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIGFjdHVhbC5jYWxscy5jb3VudCgpID09PSAxICYmXG4gICAgICAgICAgdXRpbC5jb250YWlucyhhY3R1YWwuY2FsbHMuYWxsQXJncygpLCBleHBlY3RlZEFyZ3MpXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXNzOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgJ0V4cGVjdGVkIHNweSAnICtcbiAgICAgICAgICAgICAgYWN0dWFsLmFuZC5pZGVudGl0eSArXG4gICAgICAgICAgICAgICcgdG8gaGF2ZSBiZWVuIGNhbGxlZCAwIHRpbWVzLCBtdWx0aXBsZSB0aW1lcywgb3Igb25jZSwgYnV0IHdpdGggYXJndW1lbnRzIGRpZmZlcmVudCBmcm9tOlxcbicgK1xuICAgICAgICAgICAgICAnICAnICtcbiAgICAgICAgICAgICAgdXRpbC5wcChleHBlY3RlZEFyZ3MpICtcbiAgICAgICAgICAgICAgJ1xcbicgK1xuICAgICAgICAgICAgICAnQnV0IHRoZSBhY3R1YWwgY2FsbCB3YXM6XFxuJyArXG4gICAgICAgICAgICAgIHByZXR0eVByaW50ZWRDYWxscy5qb2luKCcsXFxuJykgK1xuICAgICAgICAgICAgICAnLlxcblxcbidcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0RGlmZnMoKSB7XG4gICAgICAgICAgcmV0dXJuIGFjdHVhbC5jYWxscy5hbGxBcmdzKCkubWFwKGZ1bmN0aW9uKGFyZ3NGb3JDYWxsLCBjYWxsSXgpIHtcbiAgICAgICAgICAgIHZhciBkaWZmQnVpbGRlciA9IG5ldyBqJC5EaWZmQnVpbGRlcigpO1xuICAgICAgICAgICAgdXRpbC5lcXVhbHMoYXJnc0ZvckNhbGwsIGV4cGVjdGVkQXJncywgZGlmZkJ1aWxkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGRpZmZCdWlsZGVyLmdldE1lc3NhZ2UoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGJ1dFN0cmluZygpIHtcbiAgICAgICAgICBzd2l0Y2ggKGFjdHVhbC5jYWxscy5jb3VudCgpKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHJldHVybiAnQnV0IGl0IHdhcyBuZXZlciBjYWxsZWQuXFxuXFxuJztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAnQnV0IHRoZSBhY3R1YWwgY2FsbCB3YXM6XFxuJyArXG4gICAgICAgICAgICAgICAgcHJldHR5UHJpbnRlZENhbGxzLmpvaW4oJyxcXG4nKSArXG4gICAgICAgICAgICAgICAgJy5cXG4nICtcbiAgICAgICAgICAgICAgICBnZXREaWZmcygpLmpvaW4oJ1xcbicpICtcbiAgICAgICAgICAgICAgICAnXFxuXFxuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAnQnV0IHRoZSBhY3R1YWwgY2FsbHMgd2VyZTpcXG4nICtcbiAgICAgICAgICAgICAgICBwcmV0dHlQcmludGVkQ2FsbHMuam9pbignLFxcbicpICtcbiAgICAgICAgICAgICAgICAnLlxcblxcbidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhc3M6IGZhbHNlLFxuICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAnRXhwZWN0ZWQgc3B5ICcgK1xuICAgICAgICAgICAgYWN0dWFsLmFuZC5pZGVudGl0eSArXG4gICAgICAgICAgICAnIHRvIGhhdmUgYmVlbiBjYWxsZWQgb25seSBvbmNlLCBhbmQgd2l0aCBnaXZlbiBhcmdzOlxcbicgK1xuICAgICAgICAgICAgJyAgJyArXG4gICAgICAgICAgICB1dGlsLnBwKGV4cGVjdGVkQXJncykgK1xuICAgICAgICAgICAgJ1xcbicgK1xuICAgICAgICAgICAgYnV0U3RyaW5nKClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvSGF2ZUJlZW5DYWxsZWRPbmNlV2l0aDtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzID0gZnVuY3Rpb24oaiQpIHtcbiAgdmFyIGdldEVycm9yTXNnID0gaiQuZm9ybWF0RXJyb3JNc2coXG4gICAgJzx0b0hhdmVCZWVuQ2FsbGVkVGltZXM+JyxcbiAgICAnZXhwZWN0KDxzcHlPYmo+KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoPE51bWJlcj4pJ1xuICApO1xuXG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIChhIHtAbGluayBTcHl9KSB0byBoYXZlIGJlZW4gY2FsbGVkIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHRpbWVzLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9IYXZlQmVlbkNhbGxlZFRpbWVzXG4gICAqIEBzaW5jZSAyLjQuMFxuICAgKiBAcGFyYW0ge051bWJlcn0gZXhwZWN0ZWQgLSBUaGUgbnVtYmVyIG9mIGludm9jYXRpb25zIHRvIGxvb2sgZm9yLlxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QobXlTcHkpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygzKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvSGF2ZUJlZW5DYWxsZWRUaW1lcyhtYXRjaGVyc1V0aWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICAgICAgICBpZiAoIWokLmlzU3B5KGFjdHVhbCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBnZXRFcnJvck1zZyhcbiAgICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3B5LCBidXQgZ290ICcgKyBtYXRjaGVyc1V0aWwucHAoYWN0dWFsKSArICcuJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCksXG4gICAgICAgICAgcmVzdWx0ID0geyBwYXNzOiBmYWxzZSB9O1xuXG4gICAgICAgIGlmICghaiQuaXNOdW1iZXJfKGV4cGVjdGVkKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGdldEVycm9yTXNnKFxuICAgICAgICAgICAgICAnVGhlIGV4cGVjdGVkIHRpbWVzIGZhaWxlZCBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50IGFuZCBtdXN0IGJlIGEgbnVtYmVyLidcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgYWN0dWFsID0gYXJnc1swXTtcbiAgICAgICAgdmFyIGNhbGxzID0gYWN0dWFsLmNhbGxzLmNvdW50KCk7XG4gICAgICAgIHZhciB0aW1lc01lc3NhZ2UgPSBleHBlY3RlZCA9PT0gMSA/ICdvbmNlJyA6IGV4cGVjdGVkICsgJyB0aW1lcyc7XG4gICAgICAgIHJlc3VsdC5wYXNzID0gY2FsbHMgPT09IGV4cGVjdGVkO1xuICAgICAgICByZXN1bHQubWVzc2FnZSA9IHJlc3VsdC5wYXNzXG4gICAgICAgICAgPyAnRXhwZWN0ZWQgc3B5ICcgK1xuICAgICAgICAgICAgYWN0dWFsLmFuZC5pZGVudGl0eSArXG4gICAgICAgICAgICAnIG5vdCB0byBoYXZlIGJlZW4gY2FsbGVkICcgK1xuICAgICAgICAgICAgdGltZXNNZXNzYWdlICtcbiAgICAgICAgICAgICcuIEl0IHdhcyBjYWxsZWQgJyArXG4gICAgICAgICAgICBjYWxscyArXG4gICAgICAgICAgICAnIHRpbWVzLidcbiAgICAgICAgICA6ICdFeHBlY3RlZCBzcHkgJyArXG4gICAgICAgICAgICBhY3R1YWwuYW5kLmlkZW50aXR5ICtcbiAgICAgICAgICAgICcgdG8gaGF2ZSBiZWVuIGNhbGxlZCAnICtcbiAgICAgICAgICAgIHRpbWVzTWVzc2FnZSArXG4gICAgICAgICAgICAnLiBJdCB3YXMgY2FsbGVkICcgK1xuICAgICAgICAgICAgY2FsbHMgK1xuICAgICAgICAgICAgJyB0aW1lcy4nO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9IYXZlQmVlbkNhbGxlZFRpbWVzO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCA9IGZ1bmN0aW9uKGokKSB7XG4gIHZhciBnZXRFcnJvck1zZyA9IGokLmZvcm1hdEVycm9yTXNnKFxuICAgICc8dG9IYXZlQmVlbkNhbGxlZFdpdGg+JyxcbiAgICAnZXhwZWN0KDxzcHlPYmo+KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCguLi5hcmd1bWVudHMpJ1xuICApO1xuXG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIChhIHtAbGluayBTcHl9KSB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggcGFydGljdWxhciBhcmd1bWVudHMgYXQgbGVhc3Qgb25jZS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvSGF2ZUJlZW5DYWxsZWRXaXRoXG4gICAqIEBzaW5jZSAxLjMuMFxuICAgKiBAcGFyYW0gey4uLk9iamVjdH0gLSBUaGUgYXJndW1lbnRzIHRvIGxvb2sgZm9yXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdChteVNweSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2ZvbycsICdiYXInLCAyKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvSGF2ZUJlZW5DYWxsZWRXaXRoKG1hdGNoZXJzVXRpbCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApLFxuICAgICAgICAgIGFjdHVhbCA9IGFyZ3NbMF0sXG4gICAgICAgICAgZXhwZWN0ZWRBcmdzID0gYXJncy5zbGljZSgxKSxcbiAgICAgICAgICByZXN1bHQgPSB7IHBhc3M6IGZhbHNlIH07XG5cbiAgICAgICAgaWYgKCFqJC5pc1NweShhY3R1YWwpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgZ2V0RXJyb3JNc2coXG4gICAgICAgICAgICAgICdFeHBlY3RlZCBhIHNweSwgYnV0IGdvdCAnICsgbWF0Y2hlcnNVdGlsLnBwKGFjdHVhbCkgKyAnLidcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhY3R1YWwuY2FsbHMuYW55KCkpIHtcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgJ0V4cGVjdGVkIHNweSAnICtcbiAgICAgICAgICAgICAgYWN0dWFsLmFuZC5pZGVudGl0eSArXG4gICAgICAgICAgICAgICcgdG8gaGF2ZSBiZWVuIGNhbGxlZCB3aXRoOlxcbicgK1xuICAgICAgICAgICAgICAnICAnICtcbiAgICAgICAgICAgICAgbWF0Y2hlcnNVdGlsLnBwKGV4cGVjdGVkQXJncykgK1xuICAgICAgICAgICAgICAnXFxuYnV0IGl0IHdhcyBuZXZlciBjYWxsZWQuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2hlcnNVdGlsLmNvbnRhaW5zKGFjdHVhbC5jYWxscy5hbGxBcmdzKCksIGV4cGVjdGVkQXJncykpIHtcbiAgICAgICAgICByZXN1bHQucGFzcyA9IHRydWU7XG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICdFeHBlY3RlZCBzcHkgJyArXG4gICAgICAgICAgICAgIGFjdHVhbC5hbmQuaWRlbnRpdHkgK1xuICAgICAgICAgICAgICAnIG5vdCB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGg6XFxuJyArXG4gICAgICAgICAgICAgICcgICcgK1xuICAgICAgICAgICAgICBtYXRjaGVyc1V0aWwucHAoZXhwZWN0ZWRBcmdzKSArXG4gICAgICAgICAgICAgICdcXG5idXQgaXQgd2FzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHByZXR0eVByaW50ZWRDYWxscyA9IGFjdHVhbC5jYWxsc1xuICAgICAgICAgICAgICAuYWxsQXJncygpXG4gICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oYXJnc0ZvckNhbGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyAgJyArIG1hdGNoZXJzVXRpbC5wcChhcmdzRm9yQ2FsbCk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgZGlmZnMgPSBhY3R1YWwuY2FsbHNcbiAgICAgICAgICAgICAgLmFsbEFyZ3MoKVxuICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGFyZ3NGb3JDYWxsLCBjYWxsSXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlmZkJ1aWxkZXIgPSBuZXcgaiQuRGlmZkJ1aWxkZXIoKTtcbiAgICAgICAgICAgICAgICBtYXRjaGVyc1V0aWwuZXF1YWxzKGFyZ3NGb3JDYWxsLCBleHBlY3RlZEFyZ3MsIGRpZmZCdWlsZGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgJ0NhbGwgJyArXG4gICAgICAgICAgICAgICAgICBjYWxsSXggK1xuICAgICAgICAgICAgICAgICAgJzpcXG4nICtcbiAgICAgICAgICAgICAgICAgIGRpZmZCdWlsZGVyLmdldE1lc3NhZ2UoKS5yZXBsYWNlKC9eL2dtLCAnICAnKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAnRXhwZWN0ZWQgc3B5ICcgK1xuICAgICAgICAgICAgICBhY3R1YWwuYW5kLmlkZW50aXR5ICtcbiAgICAgICAgICAgICAgJyB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGg6XFxuJyArXG4gICAgICAgICAgICAgICcgICcgK1xuICAgICAgICAgICAgICBtYXRjaGVyc1V0aWwucHAoZXhwZWN0ZWRBcmdzKSArXG4gICAgICAgICAgICAgICdcXG4nICtcbiAgICAgICAgICAgICAgJycgK1xuICAgICAgICAgICAgICAnYnV0IGFjdHVhbCBjYWxscyB3ZXJlOlxcbicgK1xuICAgICAgICAgICAgICBwcmV0dHlQcmludGVkQ2FsbHMuam9pbignLFxcbicpICtcbiAgICAgICAgICAgICAgJy5cXG5cXG4nICtcbiAgICAgICAgICAgICAgZGlmZnMuam9pbignXFxuJylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0hhdmVCZWVuQ2FsbGVkV2l0aDtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9IYXZlQ2xhc3MgPSBmdW5jdGlvbihqJCkge1xuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCB2YWx1ZSB0byBiZSBhIERPTSBlbGVtZW50IHRoYXQgaGFzIHRoZSBleHBlY3RlZCBjbGFzc1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9IYXZlQ2xhc3NcbiAgICogQHNpbmNlIDMuMC4wXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHBlY3RlZCAtIFRoZSBjbGFzcyBuYW1lIHRvIHRlc3QgZm9yXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgKiBlbC5jbGFzc05hbWUgPSAnZm9vIGJhciBiYXonO1xuICAgKiBleHBlY3QoZWwpLnRvSGF2ZUNsYXNzKCdiYXInKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvSGF2ZUNsYXNzKG1hdGNoZXJzVXRpbCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gICAgICAgIGlmICghaXNFbGVtZW50KGFjdHVhbCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWF0Y2hlcnNVdGlsLnBwKGFjdHVhbCkgKyAnIGlzIG5vdCBhIERPTSBlbGVtZW50Jyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhc3M6IGFjdHVhbC5jbGFzc0xpc3QuY29udGFpbnMoZXhwZWN0ZWQpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRWxlbWVudChtYXliZUVsKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIG1heWJlRWwgJiYgbWF5YmVFbC5jbGFzc0xpc3QgJiYgaiQuaXNGdW5jdGlvbl8obWF5YmVFbC5jbGFzc0xpc3QuY29udGFpbnMpXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB0b0hhdmVDbGFzcztcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9IYXZlU2l6ZSA9IGZ1bmN0aW9uKGokKSB7XG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIHNpemUgdG8gYmUgZXF1YWwgdG8gdGhlIGV4cGVjdGVkLCB1c2luZyBhcnJheS1saWtlIGxlbmd0aCBvciBvYmplY3Qga2V5cyBzaXplLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9IYXZlU2l6ZVxuICAgKiBAc2luY2UgMy42LjBcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4cGVjdGVkIC0gRXhwZWN0ZWQgc2l6ZVxuICAgKiBAZXhhbXBsZVxuICAgKiBhcnJheSA9IFsxLDJdO1xuICAgKiBleHBlY3QoYXJyYXkpLnRvSGF2ZVNpemUoMik7XG4gICAqL1xuICBmdW5jdGlvbiB0b0hhdmVTaXplKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgcGFzczogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgaiQuaXNBXygnV2Vha1NldCcsIGFjdHVhbCkgfHxcbiAgICAgICAgICBqJC5pc1dlYWtNYXAoYWN0dWFsKSB8fFxuICAgICAgICAgIGokLmlzRGF0YVZpZXcoYWN0dWFsKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBnZXQgc2l6ZSBvZiAnICsgYWN0dWFsICsgJy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqJC5pc1NldChhY3R1YWwpIHx8IGokLmlzTWFwKGFjdHVhbCkpIHtcbiAgICAgICAgICByZXN1bHQucGFzcyA9IGFjdHVhbC5zaXplID09PSBleHBlY3RlZDtcbiAgICAgICAgfSBlbHNlIGlmIChpc0xlbmd0aChhY3R1YWwubGVuZ3RoKSkge1xuICAgICAgICAgIHJlc3VsdC5wYXNzID0gYWN0dWFsLmxlbmd0aCA9PT0gZXhwZWN0ZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnBhc3MgPSBPYmplY3Qua2V5cyhhY3R1YWwpLmxlbmd0aCA9PT0gZXhwZWN0ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgTUFYX1NBRkVfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IDkwMDcxOTkyNTQ3NDA5OTE7XG4gIGZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgICAgdmFsdWUgPiAtMSAmJlxuICAgICAgdmFsdWUgJSAxID09PSAwICYmXG4gICAgICB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB0b0hhdmVTaXplO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b01hdGNoID0gZnVuY3Rpb24oaiQpIHtcbiAgdmFyIGdldEVycm9yTXNnID0gaiQuZm9ybWF0RXJyb3JNc2coXG4gICAgJzx0b01hdGNoPicsXG4gICAgJ2V4cGVjdCg8ZXhwZWN0YXRpb24+KS50b01hdGNoKDxzdHJpbmc+IHx8IDxyZWdleHA+KSdcbiAgKTtcblxuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCB2YWx1ZSB0byBtYXRjaCBhIHJlZ3VsYXIgZXhwcmVzc2lvblxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9NYXRjaFxuICAgKiBAc2luY2UgMS4zLjBcbiAgICogQHBhcmFtIHtSZWdFeHB8U3RyaW5nfSBleHBlY3RlZCAtIFZhbHVlIHRvIGxvb2sgZm9yIGluIHRoZSBzdHJpbmcuXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdChcIm15IHN0cmluZ1wiKS50b01hdGNoKC9zdHJpbmckLyk7XG4gICAqIGV4cGVjdChcIm90aGVyIHN0cmluZ1wiKS50b01hdGNoKFwiaGVyXCIpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9NYXRjaCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICAgICAgICBpZiAoIWokLmlzU3RyaW5nXyhleHBlY3RlZCkgJiYgIWokLmlzQV8oJ1JlZ0V4cCcsIGV4cGVjdGVkKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihnZXRFcnJvck1zZygnRXhwZWN0ZWQgaXMgbm90IGEgU3RyaW5nIG9yIGEgUmVnRXhwJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAoZXhwZWN0ZWQpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFzczogcmVnZXhwLnRlc3QoYWN0dWFsKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9NYXRjaDtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9UaHJvdyA9IGZ1bmN0aW9uKGokKSB7XG4gIHZhciBnZXRFcnJvck1zZyA9IGokLmZvcm1hdEVycm9yTXNnKFxuICAgICc8dG9UaHJvdz4nLFxuICAgICdleHBlY3QoZnVuY3Rpb24oKSB7PGV4cGVjdGF0aW9uPn0pLnRvVGhyb3coKSdcbiAgKTtcblxuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gYSBmdW5jdGlvbiB0byBgdGhyb3dgIHNvbWV0aGluZy5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvVGhyb3dcbiAgICogQHNpbmNlIDIuMC4wXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZXhwZWN0ZWRdIC0gVmFsdWUgdGhhdCBzaG91bGQgYmUgdGhyb3duLiBJZiBub3QgcHJvdmlkZWQsIHNpbXBseSB0aGUgZmFjdCB0aGF0IHNvbWV0aGluZyB3YXMgdGhyb3duIHdpbGwgYmUgY2hlY2tlZC5cbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KGZ1bmN0aW9uKCkgeyByZXR1cm4gJ3RoaW5ncyc7IH0pLnRvVGhyb3coJ2ZvbycpO1xuICAgKiBleHBlY3QoZnVuY3Rpb24oKSB7IHJldHVybiAnc3R1ZmYnOyB9KS50b1Rocm93KCk7XG4gICAqL1xuICBmdW5jdGlvbiB0b1Rocm93KG1hdGNoZXJzVXRpbCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7IHBhc3M6IGZhbHNlIH0sXG4gICAgICAgICAgdGhyZXcgPSBmYWxzZSxcbiAgICAgICAgICB0aHJvd247XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhY3R1YWwgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihnZXRFcnJvck1zZygnQWN0dWFsIGlzIG5vdCBhIEZ1bmN0aW9uJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhY3R1YWwoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocmV3ID0gdHJ1ZTtcbiAgICAgICAgICB0aHJvd24gPSBlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aHJldykge1xuICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID0gJ0V4cGVjdGVkIGZ1bmN0aW9uIHRvIHRocm93IGFuIGV4Y2VwdGlvbi4nO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgcmVzdWx0LnBhc3MgPSB0cnVlO1xuICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAnRXhwZWN0ZWQgZnVuY3Rpb24gbm90IHRvIHRocm93LCBidXQgaXQgdGhyZXcgJyArXG4gICAgICAgICAgICAgIG1hdGNoZXJzVXRpbC5wcCh0aHJvd24pICtcbiAgICAgICAgICAgICAgJy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoZXJzVXRpbC5lcXVhbHModGhyb3duLCBleHBlY3RlZCkpIHtcbiAgICAgICAgICByZXN1bHQucGFzcyA9IHRydWU7XG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICdFeHBlY3RlZCBmdW5jdGlvbiBub3QgdG8gdGhyb3cgJyArXG4gICAgICAgICAgICAgIG1hdGNoZXJzVXRpbC5wcChleHBlY3RlZCkgK1xuICAgICAgICAgICAgICAnLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgJ0V4cGVjdGVkIGZ1bmN0aW9uIHRvIHRocm93ICcgK1xuICAgICAgICAgICAgICBtYXRjaGVyc1V0aWwucHAoZXhwZWN0ZWQpICtcbiAgICAgICAgICAgICAgJywgYnV0IGl0IHRocmV3ICcgK1xuICAgICAgICAgICAgICBtYXRjaGVyc1V0aWwucHAodGhyb3duKSArXG4gICAgICAgICAgICAgICcuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvVGhyb3c7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvVGhyb3dFcnJvciA9IGZ1bmN0aW9uKGokKSB7XG4gIHZhciBnZXRFcnJvck1zZyA9IGokLmZvcm1hdEVycm9yTXNnKFxuICAgICc8dG9UaHJvd0Vycm9yPicsXG4gICAgJ2V4cGVjdChmdW5jdGlvbigpIHs8ZXhwZWN0YXRpb24+fSkudG9UaHJvd0Vycm9yKDxFcnJvckNvbnN0cnVjdG9yPiwgPG1lc3NhZ2U+KSdcbiAgKTtcblxuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gYSBmdW5jdGlvbiB0byBgdGhyb3dgIGFuIGBFcnJvcmAuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b1Rocm93RXJyb3JcbiAgICogQHNpbmNlIDIuMC4wXG4gICAqIEBwYXJhbSB7RXJyb3J9IFtleHBlY3RlZF0gLSBgRXJyb3JgIGNvbnN0cnVjdG9yIHRoZSBvYmplY3QgdGhhdCB3YXMgdGhyb3duIG5lZWRzIHRvIGJlIGFuIGluc3RhbmNlIG9mLiBJZiBub3QgcHJvdmlkZWQsIGBFcnJvcmAgd2lsbCBiZSB1c2VkLlxuICAgKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IFttZXNzYWdlXSAtIFRoZSBtZXNzYWdlIHRoYXQgc2hvdWxkIGJlIHNldCBvbiB0aGUgdGhyb3duIGBFcnJvcmBcbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KGZ1bmN0aW9uKCkgeyByZXR1cm4gJ3RoaW5ncyc7IH0pLnRvVGhyb3dFcnJvcihNeUN1c3RvbUVycm9yLCAnbWVzc2FnZScpO1xuICAgKiBleHBlY3QoZnVuY3Rpb24oKSB7IHJldHVybiAndGhpbmdzJzsgfSkudG9UaHJvd0Vycm9yKE15Q3VzdG9tRXJyb3IsIC9iYXIvKTtcbiAgICogZXhwZWN0KGZ1bmN0aW9uKCkgeyByZXR1cm4gJ3N0dWZmJzsgfSkudG9UaHJvd0Vycm9yKE15Q3VzdG9tRXJyb3IpO1xuICAgKiBleHBlY3QoZnVuY3Rpb24oKSB7IHJldHVybiAnb3RoZXInOyB9KS50b1Rocm93RXJyb3IoL2Zvby8pO1xuICAgKiBleHBlY3QoZnVuY3Rpb24oKSB7IHJldHVybiAnb3RoZXInOyB9KS50b1Rocm93RXJyb3IoKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvVGhyb3dFcnJvcihtYXRjaGVyc1V0aWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsKSB7XG4gICAgICAgIHZhciBlcnJvck1hdGNoZXIgPSBnZXRNYXRjaGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyksXG4gICAgICAgICAgdGhyb3duO1xuXG4gICAgICAgIGlmICh0eXBlb2YgYWN0dWFsICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0RXJyb3JNc2coJ0FjdHVhbCBpcyBub3QgYSBGdW5jdGlvbicpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYWN0dWFsKCk7XG4gICAgICAgICAgcmV0dXJuIGZhaWwoJ0V4cGVjdGVkIGZ1bmN0aW9uIHRvIHRocm93IGFuIEVycm9yLicpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3duID0gZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaiQuaXNFcnJvcl8odGhyb3duKSkge1xuICAgICAgICAgIHJldHVybiBmYWlsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgJ0V4cGVjdGVkIGZ1bmN0aW9uIHRvIHRocm93IGFuIEVycm9yLCBidXQgaXQgdGhyZXcgJyArXG4gICAgICAgICAgICAgIG1hdGNoZXJzVXRpbC5wcCh0aHJvd24pICtcbiAgICAgICAgICAgICAgJy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVycm9yTWF0Y2hlci5tYXRjaCh0aHJvd24pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXRNYXRjaGVyKCkge1xuICAgICAgdmFyIGV4cGVjdGVkLCBlcnJvclR5cGU7XG5cbiAgICAgIGlmIChhcmd1bWVudHNbMl0pIHtcbiAgICAgICAgZXJyb3JUeXBlID0gYXJndW1lbnRzWzFdO1xuICAgICAgICBleHBlY3RlZCA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgaWYgKCFpc0FuRXJyb3JUeXBlKGVycm9yVHlwZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0RXJyb3JNc2coJ0V4cGVjdGVkIGVycm9yIHR5cGUgaXMgbm90IGFuIEVycm9yLicpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleGFjdE1hdGNoZXIoZXhwZWN0ZWQsIGVycm9yVHlwZSk7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1sxXSkge1xuICAgICAgICBleHBlY3RlZCA9IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICBpZiAoaXNBbkVycm9yVHlwZShhcmd1bWVudHNbMV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGV4YWN0TWF0Y2hlcihudWxsLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBleGFjdE1hdGNoZXIoYXJndW1lbnRzWzFdLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFueU1hdGNoZXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhbnlNYXRjaGVyKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHBhc3MoXG4gICAgICAgICAgICAnRXhwZWN0ZWQgZnVuY3Rpb24gbm90IHRvIHRocm93IGFuIEVycm9yLCBidXQgaXQgdGhyZXcgJyArXG4gICAgICAgICAgICAgIGokLmZuTmFtZUZvcihlcnJvcikgK1xuICAgICAgICAgICAgICAnLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4YWN0TWF0Y2hlcihleHBlY3RlZCwgZXJyb3JUeXBlKSB7XG4gICAgICBpZiAoZXhwZWN0ZWQgJiYgIWlzU3RyaW5nT3JSZWdFeHAoZXhwZWN0ZWQpKSB7XG4gICAgICAgIGlmIChlcnJvclR5cGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBnZXRFcnJvck1zZygnRXhwZWN0ZWQgZXJyb3IgbWVzc2FnZSBpcyBub3QgYSBzdHJpbmcgb3IgUmVnRXhwLicpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBnZXRFcnJvck1zZygnRXhwZWN0ZWQgaXMgbm90IGFuIEVycm9yLCBzdHJpbmcsIG9yIFJlZ0V4cC4nKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbWVzc2FnZU1hdGNoKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBleHBlY3RlZCA9PSBtZXNzYWdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBleHBlY3RlZC50ZXN0KG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBlcnJvclR5cGVEZXNjcmlwdGlvbiA9IGVycm9yVHlwZVxuICAgICAgICA/IGokLmZuTmFtZUZvcihlcnJvclR5cGUpXG4gICAgICAgIDogJ2FuIGV4Y2VwdGlvbic7XG5cbiAgICAgIGZ1bmN0aW9uIHRocm93bkRlc2NyaXB0aW9uKHRocm93bikge1xuICAgICAgICB2YXIgdGhyb3duTmFtZSA9IGVycm9yVHlwZVxuICAgICAgICAgICAgPyBqJC5mbk5hbWVGb3IodGhyb3duLmNvbnN0cnVjdG9yKVxuICAgICAgICAgICAgOiAnYW4gZXhjZXB0aW9uJyxcbiAgICAgICAgICB0aHJvd25NZXNzYWdlID0gJyc7XG5cbiAgICAgICAgaWYgKGV4cGVjdGVkKSB7XG4gICAgICAgICAgdGhyb3duTWVzc2FnZSA9ICcgd2l0aCBtZXNzYWdlICcgKyBtYXRjaGVyc1V0aWwucHAodGhyb3duLm1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRocm93bk5hbWUgKyB0aHJvd25NZXNzYWdlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtZXNzYWdlRGVzY3JpcHRpb24oKSB7XG4gICAgICAgIGlmIChleHBlY3RlZCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSBlbHNlIGlmIChleHBlY3RlZCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgIHJldHVybiAnIHdpdGggYSBtZXNzYWdlIG1hdGNoaW5nICcgKyBtYXRjaGVyc1V0aWwucHAoZXhwZWN0ZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAnIHdpdGggbWVzc2FnZSAnICsgbWF0Y2hlcnNVdGlsLnBwKGV4cGVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtYXRjaGVzKGVycm9yKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKGVycm9yVHlwZSA9PT0gbnVsbCB8fCBlcnJvciBpbnN0YW5jZW9mIGVycm9yVHlwZSkgJiZcbiAgICAgICAgICAoZXhwZWN0ZWQgPT09IG51bGwgfHwgbWVzc2FnZU1hdGNoKGVycm9yLm1lc3NhZ2UpKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXRjaDogZnVuY3Rpb24odGhyb3duKSB7XG4gICAgICAgICAgaWYgKG1hdGNoZXModGhyb3duKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhc3MoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgJ0V4cGVjdGVkIGZ1bmN0aW9uIG5vdCB0byB0aHJvdyAnICtcbiAgICAgICAgICAgICAgICBlcnJvclR5cGVEZXNjcmlwdGlvbiArXG4gICAgICAgICAgICAgICAgbWVzc2FnZURlc2NyaXB0aW9uKCkgK1xuICAgICAgICAgICAgICAgICcuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWlsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICdFeHBlY3RlZCBmdW5jdGlvbiB0byB0aHJvdyAnICtcbiAgICAgICAgICAgICAgICBlcnJvclR5cGVEZXNjcmlwdGlvbiArXG4gICAgICAgICAgICAgICAgbWVzc2FnZURlc2NyaXB0aW9uKCkgK1xuICAgICAgICAgICAgICAgICcsIGJ1dCBpdCB0aHJldyAnICtcbiAgICAgICAgICAgICAgICB0aHJvd25EZXNjcmlwdGlvbih0aHJvd24pICtcbiAgICAgICAgICAgICAgICAnLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1N0cmluZ09yUmVnRXhwKHBvdGVudGlhbCkge1xuICAgICAgcmV0dXJuIHBvdGVudGlhbCBpbnN0YW5jZW9mIFJlZ0V4cCB8fCB0eXBlb2YgcG90ZW50aWFsID09ICdzdHJpbmcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQW5FcnJvclR5cGUodHlwZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIFN1cnJvZ2F0ZSA9IGZ1bmN0aW9uKCkge307XG4gICAgICBTdXJyb2dhdGUucHJvdG90eXBlID0gdHlwZS5wcm90b3R5cGU7XG4gICAgICByZXR1cm4gaiQuaXNFcnJvcl8obmV3IFN1cnJvZ2F0ZSgpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXNzKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGFzczogdHJ1ZSxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZmFpbChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhc3M6IGZhbHNlLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9UaHJvd0Vycm9yO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b1Rocm93TWF0Y2hpbmcgPSBmdW5jdGlvbihqJCkge1xuICB2YXIgdXNhZ2VFcnJvciA9IGokLmZvcm1hdEVycm9yTXNnKFxuICAgICc8dG9UaHJvd01hdGNoaW5nPicsXG4gICAgJ2V4cGVjdChmdW5jdGlvbigpIHs8ZXhwZWN0YXRpb24+fSkudG9UaHJvd01hdGNoaW5nKDxQcmVkaWNhdGU+KSdcbiAgKTtcblxuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gYSBmdW5jdGlvbiB0byBgdGhyb3dgIHNvbWV0aGluZyBtYXRjaGluZyBhIHByZWRpY2F0ZS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvVGhyb3dNYXRjaGluZ1xuICAgKiBAc2luY2UgMy4wLjBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIC0gQSBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSB0aHJvd24gZXhjZXB0aW9uIGFzIGl0cyBwYXJhbWV0ZXIgYW5kIHJldHVybnMgdHJ1ZSBpZiBpdCBtYXRjaGVzLlxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QoZnVuY3Rpb24oKSB7IHRocm93IG5ldyBFcnJvcignbm9wZScpOyB9KS50b1Rocm93TWF0Y2hpbmcoZnVuY3Rpb24odGhyb3duKSB7IHJldHVybiB0aHJvd24ubWVzc2FnZSA9PT0gJ25vcGUnOyB9KTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvVGhyb3dNYXRjaGluZyhtYXRjaGVyc1V0aWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgdmFyIHRocm93bjtcblxuICAgICAgICBpZiAodHlwZW9mIGFjdHVhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcih1c2FnZUVycm9yKCdBY3R1YWwgaXMgbm90IGEgRnVuY3Rpb24nKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcih1c2FnZUVycm9yKCdQcmVkaWNhdGUgaXMgbm90IGEgRnVuY3Rpb24nKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGFjdHVhbCgpO1xuICAgICAgICAgIHJldHVybiBmYWlsKCdFeHBlY3RlZCBmdW5jdGlvbiB0byB0aHJvdyBhbiBleGNlcHRpb24uJyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvd24gPSBlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZWRpY2F0ZSh0aHJvd24pKSB7XG4gICAgICAgICAgcmV0dXJuIHBhc3MoXG4gICAgICAgICAgICAnRXhwZWN0ZWQgZnVuY3Rpb24gbm90IHRvIHRocm93IGFuIGV4Y2VwdGlvbiBtYXRjaGluZyBhIHByZWRpY2F0ZS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFpbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICdFeHBlY3RlZCBmdW5jdGlvbiB0byB0aHJvdyBhbiBleGNlcHRpb24gbWF0Y2hpbmcgYSBwcmVkaWNhdGUsICcgK1xuICAgICAgICAgICAgICAnYnV0IGl0IHRocmV3ICcgK1xuICAgICAgICAgICAgICB0aHJvd25EZXNjcmlwdGlvbih0aHJvd24pICtcbiAgICAgICAgICAgICAgJy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHRocm93bkRlc2NyaXB0aW9uKHRocm93bikge1xuICAgICAgaWYgKHRocm93biAmJiB0aHJvd24uY29uc3RydWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBqJC5mbk5hbWVGb3IodGhyb3duLmNvbnN0cnVjdG9yKSArXG4gICAgICAgICAgJyB3aXRoIG1lc3NhZ2UgJyArXG4gICAgICAgICAgbWF0Y2hlcnNVdGlsLnBwKHRocm93bi5tZXNzYWdlKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXJzVXRpbC5wcCh0aHJvd24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhc3MobWVzc2FnZSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXNzOiB0cnVlLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBmYWlsKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGFzczogZmFsc2UsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b1Rocm93TWF0Y2hpbmc7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLk1vY2tEYXRlID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gTW9ja0RhdGUoZ2xvYmFsKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjdXJyZW50VGltZSA9IDA7XG5cbiAgICBpZiAoIWdsb2JhbCB8fCAhZ2xvYmFsLkRhdGUpIHtcbiAgICAgIHNlbGYuaW5zdGFsbCA9IGZ1bmN0aW9uKCkge307XG4gICAgICBzZWxmLnRpY2sgPSBmdW5jdGlvbigpIHt9O1xuICAgICAgc2VsZi51bmluc3RhbGwgPSBmdW5jdGlvbigpIHt9O1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgdmFyIEdsb2JhbERhdGUgPSBnbG9iYWwuRGF0ZTtcblxuICAgIHNlbGYuaW5zdGFsbCA9IGZ1bmN0aW9uKG1vY2tEYXRlKSB7XG4gICAgICBpZiAobW9ja0RhdGUgaW5zdGFuY2VvZiBHbG9iYWxEYXRlKSB7XG4gICAgICAgIGN1cnJlbnRUaW1lID0gbW9ja0RhdGUuZ2V0VGltZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFqJC51dGlsLmlzVW5kZWZpbmVkKG1vY2tEYXRlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdUaGUgYXJndW1lbnQgdG8gamFzbWluZS5jbG9jaygpLm1vY2tEYXRlKCksIGlmIHNwZWNpZmllZCwgJyArXG4gICAgICAgICAgICAgICdzaG91bGQgYmUgYSBEYXRlIGluc3RhbmNlLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudFRpbWUgPSBuZXcgR2xvYmFsRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIH1cblxuICAgICAgZ2xvYmFsLkRhdGUgPSBGYWtlRGF0ZTtcbiAgICB9O1xuXG4gICAgc2VsZi50aWNrID0gZnVuY3Rpb24obWlsbGlzKSB7XG4gICAgICBtaWxsaXMgPSBtaWxsaXMgfHwgMDtcbiAgICAgIGN1cnJlbnRUaW1lID0gY3VycmVudFRpbWUgKyBtaWxsaXM7XG4gICAgfTtcblxuICAgIHNlbGYudW5pbnN0YWxsID0gZnVuY3Rpb24oKSB7XG4gICAgICBjdXJyZW50VGltZSA9IDA7XG4gICAgICBnbG9iYWwuRGF0ZSA9IEdsb2JhbERhdGU7XG4gICAgfTtcblxuICAgIGNyZWF0ZURhdGVQcm9wZXJ0aWVzKCk7XG5cbiAgICByZXR1cm4gc2VsZjtcblxuICAgIGZ1bmN0aW9uIEZha2VEYXRlKCkge1xuICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gbmV3IEdsb2JhbERhdGUoY3VycmVudFRpbWUpO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIG5ldyBHbG9iYWxEYXRlKGFyZ3VtZW50c1swXSk7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gbmV3IEdsb2JhbERhdGUoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcmV0dXJuIG5ldyBHbG9iYWxEYXRlKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIG5ldyBHbG9iYWxEYXRlKFxuICAgICAgICAgICAgYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgYXJndW1lbnRzWzJdLFxuICAgICAgICAgICAgYXJndW1lbnRzWzNdXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiBuZXcgR2xvYmFsRGF0ZShcbiAgICAgICAgICAgIGFyZ3VtZW50c1swXSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1syXSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1szXSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1s0XVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICByZXR1cm4gbmV3IEdsb2JhbERhdGUoXG4gICAgICAgICAgICBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgICBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICBhcmd1bWVudHNbMl0sXG4gICAgICAgICAgICBhcmd1bWVudHNbM10sXG4gICAgICAgICAgICBhcmd1bWVudHNbNF0sXG4gICAgICAgICAgICBhcmd1bWVudHNbNV1cbiAgICAgICAgICApO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBuZXcgR2xvYmFsRGF0ZShcbiAgICAgICAgICAgIGFyZ3VtZW50c1swXSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1syXSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1szXSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1s0XSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1s1XSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1s2XVxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRGF0ZVByb3BlcnRpZXMoKSB7XG4gICAgICBGYWtlRGF0ZS5wcm90b3R5cGUgPSBHbG9iYWxEYXRlLnByb3RvdHlwZTtcblxuICAgICAgRmFrZURhdGUubm93ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50VGltZTtcbiAgICAgIH07XG5cbiAgICAgIEZha2VEYXRlLnRvU291cmNlID0gR2xvYmFsRGF0ZS50b1NvdXJjZTtcbiAgICAgIEZha2VEYXRlLnRvU3RyaW5nID0gR2xvYmFsRGF0ZS50b1N0cmluZztcbiAgICAgIEZha2VEYXRlLnBhcnNlID0gR2xvYmFsRGF0ZS5wYXJzZTtcbiAgICAgIEZha2VEYXRlLlVUQyA9IEdsb2JhbERhdGUuVVRDO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBNb2NrRGF0ZTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuTmV2ZXJTa2lwUG9saWN5ID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gTmV2ZXJTa2lwUG9saWN5KHF1ZXVlYWJsZUZucykge31cblxuICBOZXZlclNraXBQb2xpY3kucHJvdG90eXBlLnNraXBUbyA9IGZ1bmN0aW9uKGxhc3RSYW5Gbkl4KSB7XG4gICAgcmV0dXJuIGxhc3RSYW5Gbkl4ICsgMTtcbiAgfTtcblxuICBOZXZlclNraXBQb2xpY3kucHJvdG90eXBlLmZuRXJyb3JlZCA9IGZ1bmN0aW9uKGZuSXgpIHt9O1xuXG4gIHJldHVybiBOZXZlclNraXBQb2xpY3k7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLm1ha2VQcmV0dHlQcmludGVyID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gU2luZ2xlUHJldHR5UHJpbnRSdW4oY3VzdG9tT2JqZWN0Rm9ybWF0dGVycywgcHApIHtcbiAgICB0aGlzLmN1c3RvbU9iamVjdEZvcm1hdHRlcnNfID0gY3VzdG9tT2JqZWN0Rm9ybWF0dGVycztcbiAgICB0aGlzLnBwTmVzdExldmVsXyA9IDA7XG4gICAgdGhpcy5zZWVuID0gW107XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuc3RyaW5nUGFydHMgPSBbXTtcbiAgICB0aGlzLnBwXyA9IHBwO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzQ3VzdG9tVG9TdHJpbmcodmFsdWUpIHtcbiAgICAvLyB2YWx1ZS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyBpZiB2YWx1ZSBoYXMgbm8gY3VzdG9tIHRvU3RyaW5nIGJ1dCBpcyBmcm9tIGFub3RoZXIgY29udGV4dCAoZS5nLlxuICAgIC8vIGlmcmFtZSwgd2ViIHdvcmtlcilcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgaiQuaXNGdW5jdGlvbl8odmFsdWUudG9TdHJpbmcpICYmXG4gICAgICAgIHZhbHVlLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nICYmXG4gICAgICAgIHZhbHVlLnRvU3RyaW5nKCkgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSlcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gVGhlIGN1c3RvbSB0b1N0cmluZygpIHRocmV3LlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgU2luZ2xlUHJldHR5UHJpbnRSdW4ucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5wcE5lc3RMZXZlbF8rKztcbiAgICB0cnkge1xuICAgICAgdmFyIGN1c3RvbUZvcm1hdFJlc3VsdCA9IHRoaXMuYXBwbHlDdXN0b21Gb3JtYXR0ZXJzXyh2YWx1ZSk7XG5cbiAgICAgIGlmIChjdXN0b21Gb3JtYXRSZXN1bHQpIHtcbiAgICAgICAgdGhpcy5lbWl0U2NhbGFyKGN1c3RvbUZvcm1hdFJlc3VsdCk7XG4gICAgICB9IGVsc2UgaWYgKGokLnV0aWwuaXNVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgICAgIHRoaXMuZW1pdFNjYWxhcigndW5kZWZpbmVkJyk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuZW1pdFNjYWxhcignbnVsbCcpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPT09IC1JbmZpbml0eSkge1xuICAgICAgICB0aGlzLmVtaXRTY2FsYXIoJy0wJyk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBqJC5nZXRHbG9iYWwoKSkge1xuICAgICAgICB0aGlzLmVtaXRTY2FsYXIoJzxnbG9iYWw+Jyk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlLmphc21pbmVUb1N0cmluZykge1xuICAgICAgICB0aGlzLmVtaXRTY2FsYXIodmFsdWUuamFzbWluZVRvU3RyaW5nKHRoaXMucHBfKSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5lbWl0U3RyaW5nKHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaiQuaXNTcHkodmFsdWUpKSB7XG4gICAgICAgIHRoaXMuZW1pdFNjYWxhcignc3B5IG9uICcgKyB2YWx1ZS5hbmQuaWRlbnRpdHkpO1xuICAgICAgfSBlbHNlIGlmIChqJC5pc1NweSh2YWx1ZS50b1N0cmluZykpIHtcbiAgICAgICAgdGhpcy5lbWl0U2NhbGFyKCdzcHkgb24gJyArIHZhbHVlLnRvU3RyaW5nLmFuZC5pZGVudGl0eSk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHRoaXMuZW1pdFNjYWxhcih2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuZW1pdFNjYWxhcignRnVuY3Rpb24nKTtcbiAgICAgIH0gZWxzZSBpZiAoaiQuaXNEb21Ob2RlKHZhbHVlKSkge1xuICAgICAgICBpZiAodmFsdWUudGFnTmFtZSkge1xuICAgICAgICAgIHRoaXMuZW1pdERvbUVsZW1lbnQodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZW1pdFNjYWxhcignSFRNTE5vZGUnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgdGhpcy5lbWl0U2NhbGFyKCdEYXRlKCcgKyB2YWx1ZSArICcpJyk7XG4gICAgICB9IGVsc2UgaWYgKGokLmlzU2V0KHZhbHVlKSkge1xuICAgICAgICB0aGlzLmVtaXRTZXQodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChqJC5pc01hcCh2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5lbWl0TWFwKHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaiQuaXNUeXBlZEFycmF5Xyh2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5lbWl0VHlwZWRBcnJheSh2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICB2YWx1ZS50b1N0cmluZyAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICFqJC5pc0FycmF5Xyh2YWx1ZSkgJiZcbiAgICAgICAgaGFzQ3VzdG9tVG9TdHJpbmcodmFsdWUpXG4gICAgICApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmVtaXRTY2FsYXIodmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLmVtaXRTY2FsYXIoJ2hhcy1pbnZhbGlkLXRvU3RyaW5nLW1ldGhvZCcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGokLnV0aWwuYXJyYXlDb250YWlucyh0aGlzLnNlZW4sIHZhbHVlKSkge1xuICAgICAgICB0aGlzLmVtaXRTY2FsYXIoXG4gICAgICAgICAgJzxjaXJjdWxhciByZWZlcmVuY2U6ICcgK1xuICAgICAgICAgICAgKGokLmlzQXJyYXlfKHZhbHVlKSA/ICdBcnJheScgOiAnT2JqZWN0JykgK1xuICAgICAgICAgICAgJz4nXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGokLmlzQXJyYXlfKHZhbHVlKSB8fCBqJC5pc0FfKCdPYmplY3QnLCB2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5zZWVuLnB1c2godmFsdWUpO1xuICAgICAgICBpZiAoaiQuaXNBcnJheV8odmFsdWUpKSB7XG4gICAgICAgICAgdGhpcy5lbWl0QXJyYXkodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZW1pdE9iamVjdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWVuLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbWl0U2NhbGFyKHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICh0aGlzLnBwTmVzdExldmVsXyA+IDEgfHwgIShlIGluc3RhbmNlb2YgTWF4Q2hhcnNSZWFjaGVkRXJyb3IpKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMucHBOZXN0TGV2ZWxfLS07XG4gICAgfVxuICB9O1xuXG4gIFNpbmdsZVByZXR0eVByaW50UnVuLnByb3RvdHlwZS5hcHBseUN1c3RvbUZvcm1hdHRlcnNfID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gY3VzdG9tRm9ybWF0KHZhbHVlLCB0aGlzLmN1c3RvbU9iamVjdEZvcm1hdHRlcnNfKTtcbiAgfTtcblxuICBTaW5nbGVQcmV0dHlQcmludFJ1bi5wcm90b3R5cGUuaXRlcmF0ZU9iamVjdCA9IGZ1bmN0aW9uKG9iaiwgZm4pIHtcbiAgICB2YXIgb2JqS2V5cyA9IGtleXMob2JqLCBqJC5pc0FycmF5XyhvYmopKTtcbiAgICB2YXIgaXNHZXR0ZXIgPSBmdW5jdGlvbiBpc0dldHRlcihwcm9wKSB7fTtcblxuICAgIGlmIChvYmouX19sb29rdXBHZXR0ZXJfXykge1xuICAgICAgaXNHZXR0ZXIgPSBmdW5jdGlvbiBpc0dldHRlcihwcm9wKSB7XG4gICAgICAgIHZhciBnZXR0ZXIgPSBvYmouX19sb29rdXBHZXR0ZXJfXyhwcm9wKTtcbiAgICAgICAgcmV0dXJuICFqJC51dGlsLmlzVW5kZWZpbmVkKGdldHRlcikgJiYgZ2V0dGVyICE9PSBudWxsO1xuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWluKG9iaktleXMubGVuZ3RoLCBqJC5NQVhfUFJFVFRZX1BSSU5UX0FSUkFZX0xFTkdUSCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3BlcnR5ID0gb2JqS2V5c1tpXTtcbiAgICAgIGZuKHByb3BlcnR5LCBpc0dldHRlcihwcm9wZXJ0eSkpO1xuICAgIH1cblxuICAgIHJldHVybiBvYmpLZXlzLmxlbmd0aCA+IGxlbmd0aDtcbiAgfTtcblxuICBTaW5nbGVQcmV0dHlQcmludFJ1bi5wcm90b3R5cGUuZW1pdFNjYWxhciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5hcHBlbmQodmFsdWUpO1xuICB9O1xuXG4gIFNpbmdsZVByZXR0eVByaW50UnVuLnByb3RvdHlwZS5lbWl0U3RyaW5nID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB0aGlzLmFwcGVuZChcIidcIiArIHZhbHVlICsgXCInXCIpO1xuICB9O1xuXG4gIFNpbmdsZVByZXR0eVByaW50UnVuLnByb3RvdHlwZS5lbWl0QXJyYXkgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIGlmICh0aGlzLnBwTmVzdExldmVsXyA+IGokLk1BWF9QUkVUVFlfUFJJTlRfREVQVEgpIHtcbiAgICAgIHRoaXMuYXBwZW5kKCdBcnJheScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oYXJyYXkubGVuZ3RoLCBqJC5NQVhfUFJFVFRZX1BSSU5UX0FSUkFZX0xFTkdUSCk7XG4gICAgdGhpcy5hcHBlbmQoJ1sgJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKCcsICcpO1xuICAgICAgfVxuICAgICAgdGhpcy5mb3JtYXQoYXJyYXlbaV0pO1xuICAgIH1cbiAgICBpZiAoYXJyYXkubGVuZ3RoID4gbGVuZ3RoKSB7XG4gICAgICB0aGlzLmFwcGVuZCgnLCAuLi4nKTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGZpcnN0ID0gYXJyYXkubGVuZ3RoID09PSAwO1xuICAgIHZhciB0cnVuY2F0ZWQgPSB0aGlzLml0ZXJhdGVPYmplY3QoYXJyYXksIGZ1bmN0aW9uKHByb3BlcnR5LCBpc0dldHRlcikge1xuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmFwcGVuZCgnLCAnKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5mb3JtYXRQcm9wZXJ0eShhcnJheSwgcHJvcGVydHksIGlzR2V0dGVyKTtcbiAgICB9KTtcblxuICAgIGlmICh0cnVuY2F0ZWQpIHtcbiAgICAgIHRoaXMuYXBwZW5kKCcsIC4uLicpO1xuICAgIH1cblxuICAgIHRoaXMuYXBwZW5kKCcgXScpO1xuICB9O1xuXG4gIFNpbmdsZVByZXR0eVByaW50UnVuLnByb3RvdHlwZS5lbWl0U2V0ID0gZnVuY3Rpb24oc2V0KSB7XG4gICAgaWYgKHRoaXMucHBOZXN0TGV2ZWxfID4gaiQuTUFYX1BSRVRUWV9QUklOVF9ERVBUSCkge1xuICAgICAgdGhpcy5hcHBlbmQoJ1NldCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmFwcGVuZCgnU2V0KCAnKTtcbiAgICB2YXIgc2l6ZSA9IE1hdGgubWluKHNldC5zaXplLCBqJC5NQVhfUFJFVFRZX1BSSU5UX0FSUkFZX0xFTkdUSCk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmIChpID49IHNpemUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKCcsICcpO1xuICAgICAgfVxuICAgICAgdGhpcy5mb3JtYXQodmFsdWUpO1xuXG4gICAgICBpKys7XG4gICAgfSwgdGhpcyk7XG4gICAgaWYgKHNldC5zaXplID4gc2l6ZSkge1xuICAgICAgdGhpcy5hcHBlbmQoJywgLi4uJyk7XG4gICAgfVxuICAgIHRoaXMuYXBwZW5kKCcgKScpO1xuICB9O1xuXG4gIFNpbmdsZVByZXR0eVByaW50UnVuLnByb3RvdHlwZS5lbWl0TWFwID0gZnVuY3Rpb24obWFwKSB7XG4gICAgaWYgKHRoaXMucHBOZXN0TGV2ZWxfID4gaiQuTUFYX1BSRVRUWV9QUklOVF9ERVBUSCkge1xuICAgICAgdGhpcy5hcHBlbmQoJ01hcCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmFwcGVuZCgnTWFwKCAnKTtcbiAgICB2YXIgc2l6ZSA9IE1hdGgubWluKG1hcC5zaXplLCBqJC5NQVhfUFJFVFRZX1BSSU5UX0FSUkFZX0xFTkdUSCk7XG4gICAgdmFyIGkgPSAwO1xuICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmIChpID49IHNpemUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKCcsICcpO1xuICAgICAgfVxuICAgICAgdGhpcy5mb3JtYXQoW2tleSwgdmFsdWVdKTtcblxuICAgICAgaSsrO1xuICAgIH0sIHRoaXMpO1xuICAgIGlmIChtYXAuc2l6ZSA+IHNpemUpIHtcbiAgICAgIHRoaXMuYXBwZW5kKCcsIC4uLicpO1xuICAgIH1cbiAgICB0aGlzLmFwcGVuZCgnICknKTtcbiAgfTtcblxuICBTaW5nbGVQcmV0dHlQcmludFJ1bi5wcm90b3R5cGUuZW1pdE9iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBjdG9yID0gb2JqLmNvbnN0cnVjdG9yLFxuICAgICAgY29uc3RydWN0b3JOYW1lO1xuXG4gICAgY29uc3RydWN0b3JOYW1lID1cbiAgICAgIHR5cGVvZiBjdG9yID09PSAnZnVuY3Rpb24nICYmIG9iaiBpbnN0YW5jZW9mIGN0b3JcbiAgICAgICAgPyBqJC5mbk5hbWVGb3Iob2JqLmNvbnN0cnVjdG9yKVxuICAgICAgICA6ICdudWxsJztcblxuICAgIHRoaXMuYXBwZW5kKGNvbnN0cnVjdG9yTmFtZSk7XG5cbiAgICBpZiAodGhpcy5wcE5lc3RMZXZlbF8gPiBqJC5NQVhfUFJFVFRZX1BSSU5UX0RFUFRIKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuYXBwZW5kKCcoeyAnKTtcbiAgICB2YXIgZmlyc3QgPSB0cnVlO1xuXG4gICAgdmFyIHRydW5jYXRlZCA9IHRoaXMuaXRlcmF0ZU9iamVjdChvYmosIGZ1bmN0aW9uKHByb3BlcnR5LCBpc0dldHRlcikge1xuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmFwcGVuZCgnLCAnKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5mb3JtYXRQcm9wZXJ0eShvYmosIHByb3BlcnR5LCBpc0dldHRlcik7XG4gICAgfSk7XG5cbiAgICBpZiAodHJ1bmNhdGVkKSB7XG4gICAgICB0aGlzLmFwcGVuZCgnLCAuLi4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmFwcGVuZCgnIH0pJyk7XG4gIH07XG5cbiAgU2luZ2xlUHJldHR5UHJpbnRSdW4ucHJvdG90eXBlLmVtaXRUeXBlZEFycmF5ID0gZnVuY3Rpb24oYXJyKSB7XG4gICAgdmFyIGNvbnN0cnVjdG9yTmFtZSA9IGokLmZuTmFtZUZvcihhcnIuY29uc3RydWN0b3IpLFxuICAgICAgbGltaXRlZEFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoXG4gICAgICAgIGFycixcbiAgICAgICAgMCxcbiAgICAgICAgaiQuTUFYX1BSRVRUWV9QUklOVF9BUlJBWV9MRU5HVEhcbiAgICAgICksXG4gICAgICBpdGVtc1N0cmluZyA9IEFycmF5LnByb3RvdHlwZS5qb2luLmNhbGwobGltaXRlZEFycmF5LCAnLCAnKTtcblxuICAgIGlmIChsaW1pdGVkQXJyYXkubGVuZ3RoICE9PSBhcnIubGVuZ3RoKSB7XG4gICAgICBpdGVtc1N0cmluZyArPSAnLCAuLi4nO1xuICAgIH1cblxuICAgIHRoaXMuYXBwZW5kKGNvbnN0cnVjdG9yTmFtZSArICcgWyAnICsgaXRlbXNTdHJpbmcgKyAnIF0nKTtcbiAgfTtcblxuICBTaW5nbGVQcmV0dHlQcmludFJ1bi5wcm90b3R5cGUuZW1pdERvbUVsZW1lbnQgPSBmdW5jdGlvbihlbCkge1xuICAgIHZhciB0YWdOYW1lID0gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgYXR0cnMgPSBlbC5hdHRyaWJ1dGVzLFxuICAgICAgaSxcbiAgICAgIGxlbiA9IGF0dHJzLmxlbmd0aCxcbiAgICAgIG91dCA9ICc8JyArIHRhZ05hbWUsXG4gICAgICBhdHRyO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhdHRyID0gYXR0cnNbaV07XG4gICAgICBvdXQgKz0gJyAnICsgYXR0ci5uYW1lO1xuXG4gICAgICBpZiAoYXR0ci52YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgb3V0ICs9ICc9XCInICsgYXR0ci52YWx1ZSArICdcIic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgb3V0ICs9ICc+JztcblxuICAgIGlmIChlbC5jaGlsZEVsZW1lbnRDb3VudCAhPT0gMCB8fCBlbC50ZXh0Q29udGVudCAhPT0gJycpIHtcbiAgICAgIG91dCArPSAnLi4uPC8nICsgdGFnTmFtZSArICc+JztcbiAgICB9XG5cbiAgICB0aGlzLmFwcGVuZChvdXQpO1xuICB9O1xuXG4gIFNpbmdsZVByZXR0eVByaW50UnVuLnByb3RvdHlwZS5mb3JtYXRQcm9wZXJ0eSA9IGZ1bmN0aW9uKFxuICAgIG9iaixcbiAgICBwcm9wZXJ0eSxcbiAgICBpc0dldHRlclxuICApIHtcbiAgICB0aGlzLmFwcGVuZChwcm9wZXJ0eSk7XG4gICAgdGhpcy5hcHBlbmQoJzogJyk7XG4gICAgaWYgKGlzR2V0dGVyKSB7XG4gICAgICB0aGlzLmFwcGVuZCgnPGdldHRlcj4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mb3JtYXQob2JqW3Byb3BlcnR5XSk7XG4gICAgfVxuICB9O1xuXG4gIFNpbmdsZVByZXR0eVByaW50UnVuLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIC8vIFRoaXMgY2hlY2sgcHJvdGVjdHMgdXMgZnJvbSB0aGUgcmFyZSBjYXNlIHdoZXJlIGFuIG9iamVjdCBoYXMgb3ZlcnJpZGVuXG4gICAgLy8gYHRvU3RyaW5nKClgIHdpdGggYW4gaW52YWxpZCBpbXBsZW1lbnRhdGlvbiAocmV0dXJuaW5nIGEgbm9uLXN0cmluZykuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gdHJ1bmNhdGUodmFsdWUsIGokLk1BWF9QUkVUVFlfUFJJTlRfQ0hBUlMgLSB0aGlzLmxlbmd0aCk7XG4gICAgdGhpcy5sZW5ndGggKz0gcmVzdWx0LnZhbHVlLmxlbmd0aDtcbiAgICB0aGlzLnN0cmluZ1BhcnRzLnB1c2gocmVzdWx0LnZhbHVlKTtcblxuICAgIGlmIChyZXN1bHQudHJ1bmNhdGVkKSB7XG4gICAgICB0aHJvdyBuZXcgTWF4Q2hhcnNSZWFjaGVkRXJyb3IoKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gdHJ1bmNhdGUocywgbWF4bGVuKSB7XG4gICAgaWYgKHMubGVuZ3RoIDw9IG1heGxlbikge1xuICAgICAgcmV0dXJuIHsgdmFsdWU6IHMsIHRydW5jYXRlZDogZmFsc2UgfTtcbiAgICB9XG5cbiAgICBzID0gcy5zdWJzdHJpbmcoMCwgbWF4bGVuIC0gNCkgKyAnIC4uLic7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHMsIHRydW5jYXRlZDogdHJ1ZSB9O1xuICB9XG5cbiAgZnVuY3Rpb24gTWF4Q2hhcnNSZWFjaGVkRXJyb3IoKSB7XG4gICAgdGhpcy5tZXNzYWdlID1cbiAgICAgICdFeGNlZWRlZCAnICtcbiAgICAgIGokLk1BWF9QUkVUVFlfUFJJTlRfQ0hBUlMgK1xuICAgICAgJyBjaGFyYWN0ZXJzIHdoaWxlIHByZXR0eS1wcmludGluZyBhIHZhbHVlJztcbiAgfVxuXG4gIE1heENoYXJzUmVhY2hlZEVycm9yLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuXG4gIGZ1bmN0aW9uIGtleXMob2JqLCBpc0FycmF5KSB7XG4gICAgdmFyIGFsbEtleXMgPSBPYmplY3Qua2V5c1xuICAgICAgPyBPYmplY3Qua2V5cyhvYmopXG4gICAgICA6IChmdW5jdGlvbihvKSB7XG4gICAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gbykge1xuICAgICAgICAgICAgaWYgKGokLnV0aWwuaGFzKG8sIGtleSkpIHtcbiAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgICB9KShvYmopO1xuXG4gICAgaWYgKCFpc0FycmF5KSB7XG4gICAgICByZXR1cm4gYWxsS2V5cztcbiAgICB9XG5cbiAgICBpZiAoYWxsS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBhbGxLZXlzO1xuICAgIH1cblxuICAgIHZhciBleHRyYUtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghL15bMC05XSskLy50ZXN0KGFsbEtleXNbaV0pKSB7XG4gICAgICAgIGV4dHJhS2V5cy5wdXNoKGFsbEtleXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBleHRyYUtleXM7XG4gIH1cblxuICBmdW5jdGlvbiBjdXN0b21Gb3JtYXQodmFsdWUsIGN1c3RvbU9iamVjdEZvcm1hdHRlcnMpIHtcbiAgICB2YXIgaSwgcmVzdWx0O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGN1c3RvbU9iamVjdEZvcm1hdHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdCA9IGN1c3RvbU9iamVjdEZvcm1hdHRlcnNbaV0odmFsdWUpO1xuXG4gICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oY3VzdG9tT2JqZWN0Rm9ybWF0dGVycykge1xuICAgIGN1c3RvbU9iamVjdEZvcm1hdHRlcnMgPSBjdXN0b21PYmplY3RGb3JtYXR0ZXJzIHx8IFtdO1xuXG4gICAgdmFyIHBwID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBwcmV0dHlQcmludGVyID0gbmV3IFNpbmdsZVByZXR0eVByaW50UnVuKGN1c3RvbU9iamVjdEZvcm1hdHRlcnMsIHBwKTtcbiAgICAgIHByZXR0eVByaW50ZXIuZm9ybWF0KHZhbHVlKTtcbiAgICAgIHJldHVybiBwcmV0dHlQcmludGVyLnN0cmluZ1BhcnRzLmpvaW4oJycpO1xuICAgIH07XG5cbiAgICBwcC5jdXN0b21Gb3JtYXRfID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBjdXN0b21Gb3JtYXQodmFsdWUsIGN1c3RvbU9iamVjdEZvcm1hdHRlcnMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gcHA7XG4gIH07XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlF1ZXVlUnVubmVyID0gZnVuY3Rpb24oaiQpIHtcbiAgdmFyIG5leHRpZCA9IDE7XG5cbiAgZnVuY3Rpb24gU3RvcEV4ZWN1dGlvbkVycm9yKCkge31cbiAgU3RvcEV4ZWN1dGlvbkVycm9yLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuICBqJC5TdG9wRXhlY3V0aW9uRXJyb3IgPSBTdG9wRXhlY3V0aW9uRXJyb3I7XG5cbiAgZnVuY3Rpb24gb25jZShmbiwgb25Ud2ljZSkge1xuICAgIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgICBpZiAoY2FsbGVkKSB7XG4gICAgICAgIGlmIChvblR3aWNlKSB7XG4gICAgICAgICAgb25Ud2ljZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAvLyBEaXJlY3QgY2FsbCB1c2luZyBzaW5nbGUgcGFyYW1ldGVyLCBiZWNhdXNlIGNsZWFudXAvbmV4dCBkb2VzIG5vdCBuZWVkIG1vcmVcbiAgICAgICAgZm4oYXJnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBmYWxsYmFja09uTXVsdGlwbGVEb25lKCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBuZXcgRXJyb3IoXG4gICAgICAgIFwiQW4gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIGNhbGxlZCBpdHMgJ2RvbmUnIFwiICtcbiAgICAgICAgICAnY2FsbGJhY2sgbW9yZSB0aGFuIG9uY2UsIGluIGEgUXVldWVSdW5uZXIgd2l0aG91dCBhIG9uTXVsdGlwbGVEb25lICcgK1xuICAgICAgICAgICdoYW5kbGVyLidcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlGbigpIHt9XG5cbiAgZnVuY3Rpb24gUXVldWVSdW5uZXIoYXR0cnMpIHtcbiAgICB0aGlzLmlkXyA9IG5leHRpZCsrO1xuICAgIHRoaXMucXVldWVhYmxlRm5zID0gYXR0cnMucXVldWVhYmxlRm5zIHx8IFtdO1xuICAgIHRoaXMub25Db21wbGV0ZSA9IGF0dHJzLm9uQ29tcGxldGUgfHwgZW1wdHlGbjtcbiAgICB0aGlzLmNsZWFyU3RhY2sgPVxuICAgICAgYXR0cnMuY2xlYXJTdGFjayB8fFxuICAgICAgZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH07XG4gICAgdGhpcy5vbkV4Y2VwdGlvbiA9IGF0dHJzLm9uRXhjZXB0aW9uIHx8IGVtcHR5Rm47XG4gICAgdGhpcy5vbk11bHRpcGxlRG9uZSA9IGF0dHJzLm9uTXVsdGlwbGVEb25lIHx8IGZhbGxiYWNrT25NdWx0aXBsZURvbmU7XG4gICAgdGhpcy51c2VyQ29udGV4dCA9IGF0dHJzLnVzZXJDb250ZXh0IHx8IG5ldyBqJC5Vc2VyQ29udGV4dCgpO1xuICAgIHRoaXMudGltZW91dCA9IGF0dHJzLnRpbWVvdXQgfHwge1xuICAgICAgc2V0VGltZW91dDogc2V0VGltZW91dCxcbiAgICAgIGNsZWFyVGltZW91dDogY2xlYXJUaW1lb3V0XG4gICAgfTtcbiAgICB0aGlzLmZhaWwgPSBhdHRycy5mYWlsIHx8IGVtcHR5Rm47XG4gICAgdGhpcy5nbG9iYWxFcnJvcnMgPSBhdHRycy5nbG9iYWxFcnJvcnMgfHwge1xuICAgICAgcHVzaExpc3RlbmVyOiBlbXB0eUZuLFxuICAgICAgcG9wTGlzdGVuZXI6IGVtcHR5Rm5cbiAgICB9O1xuXG4gICAgY29uc3QgU2tpcFBvbGljeSA9IGF0dHJzLlNraXBQb2xpY3kgfHwgaiQuTmV2ZXJTa2lwUG9saWN5O1xuICAgIHRoaXMuc2tpcFBvbGljeV8gPSBuZXcgU2tpcFBvbGljeSh0aGlzLnF1ZXVlYWJsZUZucyk7XG4gICAgdGhpcy5lcnJvcmVkXyA9IGZhbHNlO1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLm9uQ29tcGxldGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBvbkNvbXBsZXRlICcgKyBKU09OLnN0cmluZ2lmeSh0aGlzLm9uQ29tcGxldGUpKTtcbiAgICB9XG4gICAgdGhpcy5kZXByZWNhdGVkID0gYXR0cnMuZGVwcmVjYXRlZDtcbiAgfVxuXG4gIFF1ZXVlUnVubmVyLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuaGFuZGxlRmluYWxFcnJvciA9IGZ1bmN0aW9uKG1lc3NhZ2UsIHNvdXJjZSwgbGluZW5vLCBjb2xubywgZXJyb3IpIHtcbiAgICAgIC8vIE9sZGVyIGJyb3dzZXJzIHdvdWxkIHNlbmQgdGhlIGVycm9yIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIuIEhUTUw1XG4gICAgICAvLyBzcGVjaWZpZXMgdGhlIHRoZSBmaXZlIHBhcmFtZXRlcnMgYWJvdmUuIFRoZSBlcnJvciBpbnN0YW5jZSBzaG91bGRcbiAgICAgIC8vIGJlIHByZWZmZXJlZCwgb3RoZXJ3aXNlIHRoZSBjYWxsIHN0YWNrIHdvdWxkIGdldCBsb3N0LlxuICAgICAgc2VsZi5vbkV4Y2VwdGlvbihlcnJvciB8fCBtZXNzYWdlKTtcbiAgICB9O1xuICAgIHRoaXMuZ2xvYmFsRXJyb3JzLnB1c2hMaXN0ZW5lcih0aGlzLmhhbmRsZUZpbmFsRXJyb3IpO1xuICAgIHRoaXMucnVuKDApO1xuICB9O1xuXG4gIFF1ZXVlUnVubmVyLnByb3RvdHlwZS5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbih0aW1lb3V0SWQpIHtcbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkodGhpcy50aW1lb3V0LmNsZWFyVGltZW91dCwgW1xuICAgICAgaiQuZ2V0R2xvYmFsKCksXG4gICAgICBbdGltZW91dElkXVxuICAgIF0pO1xuICB9O1xuXG4gIFF1ZXVlUnVubmVyLnByb3RvdHlwZS5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oZm4sIHRpbWVvdXQpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KHRoaXMudGltZW91dC5zZXRUaW1lb3V0LCBbXG4gICAgICBqJC5nZXRHbG9iYWwoKSxcbiAgICAgIFtmbiwgdGltZW91dF1cbiAgICBdKTtcbiAgfTtcblxuICBRdWV1ZVJ1bm5lci5wcm90b3R5cGUuYXR0ZW1wdCA9IGZ1bmN0aW9uIGF0dGVtcHQoaXRlcmF0aXZlSW5kZXgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICBjb21wbGV0ZWRTeW5jaHJvbm91c2x5ID0gdHJ1ZSxcbiAgICAgIGhhbmRsZUVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgLy8gVE9ETyBwcm9iYWJseSBzaG91bGRuJ3QgbmV4dCgpIHJpZ2h0IGF3YXkgaGVyZS5cbiAgICAgICAgLy8gVGhhdCBtYWtlcyBkZWJ1Z2dpbmcgYXN5bmMgZmFpbHVyZXMgbXVjaCBtb3JlIGNvbmZ1c2luZy5cbiAgICAgICAgb25FeGNlcHRpb24oZXJyb3IpO1xuICAgICAgfSxcbiAgICAgIGNsZWFudXAgPSBvbmNlKGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICAgIGlmICh0aW1lb3V0SWQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5nbG9iYWxFcnJvcnMucG9wTGlzdGVuZXIoaGFuZGxlRXJyb3IpO1xuICAgICAgfSksXG4gICAgICBuZXh0ID0gb25jZShcbiAgICAgICAgZnVuY3Rpb24gbmV4dChlcnIpIHtcbiAgICAgICAgICBjbGVhbnVwKCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGVyciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIFN0b3BFeGVjdXRpb25FcnJvcikgJiYgIWVyci5qYXNtaW5lTWVzc2FnZSkge1xuICAgICAgICAgICAgICBzZWxmLmZhaWwoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYucmVjb3JkRXJyb3JfKGl0ZXJhdGl2ZUluZGV4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBydW5OZXh0KCkge1xuICAgICAgICAgICAgc2VsZi5ydW4oc2VsZi5uZXh0Rm5JeF8oaXRlcmF0aXZlSW5kZXgpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29tcGxldGVkU3luY2hyb25vdXNseSkge1xuICAgICAgICAgICAgc2VsZi5zZXRUaW1lb3V0KHJ1bk5leHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBydW5OZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCF0aW1lZE91dCkge1xuICAgICAgICAgICAgICBzZWxmLm9uTXVsdGlwbGVEb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIEFueSBlcnJvciB3ZSBjYXRjaCBoZXJlIGlzIHByb2JhYmx5IGR1ZSB0byBhIGJ1ZyBpbiBKYXNtaW5lLFxuICAgICAgICAgICAgLy8gYW5kIGl0J3Mgbm90IGxpa2VseSB0byBlbmQgdXAgYW55d2hlcmUgdXNlZnVsIGlmIHdlIGxldCBpdFxuICAgICAgICAgICAgLy8gcHJvcGFnYXRlLiBMb2cgaXQgc28gaXQgY2FuIGF0IGxlYXN0IHNob3cgdXAgd2hlbiBkZWJ1Z2dpbmcuXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB0aW1lZE91dCA9IGZhbHNlLFxuICAgICAgcXVldWVhYmxlRm4gPSBzZWxmLnF1ZXVlYWJsZUZuc1tpdGVyYXRpdmVJbmRleF0sXG4gICAgICB0aW1lb3V0SWQsXG4gICAgICBtYXliZVRoZW5hYmxlO1xuXG4gICAgbmV4dC5mYWlsID0gZnVuY3Rpb24gbmV4dEZhaWwoKSB7XG4gICAgICBzZWxmLmZhaWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIHNlbGYucmVjb3JkRXJyb3JfKGl0ZXJhdGl2ZUluZGV4KTtcbiAgICAgIG5leHQoKTtcbiAgICB9O1xuXG4gICAgc2VsZi5nbG9iYWxFcnJvcnMucHVzaExpc3RlbmVyKGhhbmRsZUVycm9yKTtcblxuICAgIGlmIChxdWV1ZWFibGVGbi50aW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciB0aW1lb3V0SW50ZXJ2YWwgPSBxdWV1ZWFibGVGbi50aW1lb3V0IHx8IGokLkRFRkFVTFRfVElNRU9VVF9JTlRFUlZBTDtcbiAgICAgIHRpbWVvdXRJZCA9IHNlbGYuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgdGltZWRPdXQgPSB0cnVlO1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1RpbWVvdXQgLSBBc3luYyBmdW5jdGlvbiBkaWQgbm90IGNvbXBsZXRlIHdpdGhpbiAnICtcbiAgICAgICAgICAgIHRpbWVvdXRJbnRlcnZhbCArXG4gICAgICAgICAgICAnbXMgJyArXG4gICAgICAgICAgICAocXVldWVhYmxlRm4udGltZW91dFxuICAgICAgICAgICAgICA/ICcoY3VzdG9tIHRpbWVvdXQpJ1xuICAgICAgICAgICAgICA6ICcoc2V0IGJ5IGphc21pbmUuREVGQVVMVF9USU1FT1VUX0lOVEVSVkFMKScpXG4gICAgICAgICk7XG4gICAgICAgIC8vIFRPRE8gTmVlZCB0byBkZWNpZGUgd2hhdCB0byBkbyBhYm91dCBhIHN1Y2Nlc3NmdWwgY29tcGxldGlvbiBhZnRlciBhXG4gICAgICAgIC8vICAgdGltZW91dC4gVGhhdCBzaG91bGQgcHJvYmFibHkgbm90IGJlIGEgZGVwcmVjYXRpb24sIGFuZCBtYXliZSBub3RcbiAgICAgICAgLy8gICBhbiBlcnJvciBpbiA0LjAuIChCdXQgYSBkaWFnbm9zdGljIG9mIHNvbWUgc29ydCBtaWdodCBiZSBoZWxwZnVsLilcbiAgICAgICAgb25FeGNlcHRpb24oZXJyb3IpO1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9LCB0aW1lb3V0SW50ZXJ2YWwpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpZiAocXVldWVhYmxlRm4uZm4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG1heWJlVGhlbmFibGUgPSBxdWV1ZWFibGVGbi5mbi5jYWxsKHNlbGYudXNlckNvbnRleHQpO1xuXG4gICAgICAgIGlmIChtYXliZVRoZW5hYmxlICYmIGokLmlzRnVuY3Rpb25fKG1heWJlVGhlbmFibGUudGhlbikpIHtcbiAgICAgICAgICBtYXliZVRoZW5hYmxlLnRoZW4oXG4gICAgICAgICAgICB3cmFwSW5Qcm9taXNlUmVzb2x1dGlvbkhhbmRsZXIobmV4dCksXG4gICAgICAgICAgICBvblByb21pc2VSZWplY3Rpb25cbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbXBsZXRlZFN5bmNocm9ub3VzbHkgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4geyBjb21wbGV0ZWRTeW5jaHJvbm91c2x5OiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXliZVRoZW5hYmxlID0gcXVldWVhYmxlRm4uZm4uY2FsbChzZWxmLnVzZXJDb250ZXh0LCBuZXh0KTtcbiAgICAgICAgdGhpcy5kaWFnbm9zZUNvbmZsaWN0aW5nQXN5bmNfKHF1ZXVlYWJsZUZuLmZuLCBtYXliZVRoZW5hYmxlKTtcbiAgICAgICAgY29tcGxldGVkU3luY2hyb25vdXNseSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4geyBjb21wbGV0ZWRTeW5jaHJvbm91c2x5OiBmYWxzZSB9O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG9uRXhjZXB0aW9uKGUpO1xuICAgICAgc2VsZi5yZWNvcmRFcnJvcl8oaXRlcmF0aXZlSW5kZXgpO1xuICAgIH1cblxuICAgIGNsZWFudXAoKTtcbiAgICByZXR1cm4geyBjb21wbGV0ZWRTeW5jaHJvbm91c2x5OiB0cnVlIH07XG5cbiAgICBmdW5jdGlvbiBvbkV4Y2VwdGlvbihlKSB7XG4gICAgICBzZWxmLm9uRXhjZXB0aW9uKGUpO1xuICAgICAgc2VsZi5yZWNvcmRFcnJvcl8oaXRlcmF0aXZlSW5kZXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uUHJvbWlzZVJlamVjdGlvbihlKSB7XG4gICAgICBvbkV4Y2VwdGlvbihlKTtcbiAgICAgIG5leHQoKTtcbiAgICB9XG4gIH07XG5cbiAgUXVldWVSdW5uZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKHJlY3Vyc2l2ZUluZGV4KSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMucXVldWVhYmxlRm5zLmxlbmd0aCxcbiAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgaXRlcmF0aXZlSW5kZXg7XG5cbiAgICBmb3IgKFxuICAgICAgaXRlcmF0aXZlSW5kZXggPSByZWN1cnNpdmVJbmRleDtcbiAgICAgIGl0ZXJhdGl2ZUluZGV4IDwgbGVuZ3RoO1xuICAgICAgaXRlcmF0aXZlSW5kZXggPSB0aGlzLm5leHRGbkl4XyhpdGVyYXRpdmVJbmRleClcbiAgICApIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmF0dGVtcHQoaXRlcmF0aXZlSW5kZXgpO1xuXG4gICAgICBpZiAoIXJlc3VsdC5jb21wbGV0ZWRTeW5jaHJvbm91c2x5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyU3RhY2soZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmdsb2JhbEVycm9ycy5wb3BMaXN0ZW5lcihzZWxmLmhhbmRsZUZpbmFsRXJyb3IpO1xuXG4gICAgICBpZiAoc2VsZi5lcnJvcmVkXykge1xuICAgICAgICBzZWxmLm9uQ29tcGxldGUobmV3IFN0b3BFeGVjdXRpb25FcnJvcigpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYub25Db21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIFF1ZXVlUnVubmVyLnByb3RvdHlwZS5uZXh0Rm5JeF8gPSBmdW5jdGlvbihjdXJyZW50Rm5JeCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc2tpcFBvbGljeV8uc2tpcFRvKGN1cnJlbnRGbkl4KTtcblxuICAgIGlmIChyZXN1bHQgPT09IGN1cnJlbnRGbkl4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBza2lwIHRvIHRoZSBzYW1lIHF1ZXVlYWJsZSBmbiB0aGF0IGp1c3QgZmluaXNoZWRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBRdWV1ZVJ1bm5lci5wcm90b3R5cGUucmVjb3JkRXJyb3JfID0gZnVuY3Rpb24oY3VycmVudEZuSXgpIHtcbiAgICB0aGlzLmVycm9yZWRfID0gdHJ1ZTtcbiAgICB0aGlzLnNraXBQb2xpY3lfLmZuRXJyb3JlZChjdXJyZW50Rm5JeCk7XG4gIH07XG5cbiAgUXVldWVSdW5uZXIucHJvdG90eXBlLmRpYWdub3NlQ29uZmxpY3RpbmdBc3luY18gPSBmdW5jdGlvbihmbiwgcmV0dmFsKSB7XG4gICAgdmFyIG1zZztcblxuICAgIGlmIChyZXR2YWwgJiYgaiQuaXNGdW5jdGlvbl8ocmV0dmFsLnRoZW4pKSB7XG4gICAgICAvLyBJc3N1ZSBhIHdhcm5pbmcgdGhhdCBtYXRjaGVzIHRoZSB1c2VyJ3MgY29kZS5cbiAgICAgIC8vIE9taXQgdGhlIHN0YWNrIHRyYWNlIGJlY2F1c2UgdGhlcmUncyBhbG1vc3QgY2VydGFpbmx5IG5vIHVzZXIgY29kZVxuICAgICAgLy8gb24gdGhlIHN0YWNrIGF0IHRoaXMgcG9pbnQuXG4gICAgICBpZiAoaiQuaXNBc3luY0Z1bmN0aW9uXyhmbikpIHtcbiAgICAgICAgdGhpcy5vbkV4Y2VwdGlvbihcbiAgICAgICAgICAnQW4gYXN5bmNocm9ub3VzIGJlZm9yZS9pdC9hZnRlciAnICtcbiAgICAgICAgICAgICdmdW5jdGlvbiB3YXMgZGVmaW5lZCB3aXRoIHRoZSBhc3luYyBrZXl3b3JkIGJ1dCBhbHNvIHRvb2sgYSAnICtcbiAgICAgICAgICAgICdkb25lIGNhbGxiYWNrLiBFaXRoZXIgcmVtb3ZlIHRoZSBkb25lIGNhbGxiYWNrIChyZWNvbW1lbmRlZCkgb3IgJyArXG4gICAgICAgICAgICAncmVtb3ZlIHRoZSBhc3luYyBrZXl3b3JkLidcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub25FeGNlcHRpb24oXG4gICAgICAgICAgJ0FuIGFzeW5jaHJvbm91cyBiZWZvcmUvaXQvYWZ0ZXIgJyArXG4gICAgICAgICAgICAnZnVuY3Rpb24gdG9vayBhIGRvbmUgY2FsbGJhY2sgYnV0IGFsc28gcmV0dXJuZWQgYSBwcm9taXNlLiAnICtcbiAgICAgICAgICAgICdFaXRoZXIgcmVtb3ZlIHRoZSBkb25lIGNhbGxiYWNrIChyZWNvbW1lbmRlZCkgb3IgY2hhbmdlIHRoZSAnICtcbiAgICAgICAgICAgICdmdW5jdGlvbiB0byBub3QgcmV0dXJuIGEgcHJvbWlzZS4nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGVwcmVjYXRlZChtc2csIHsgb21pdFN0YWNrVHJhY2U6IHRydWUgfSk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHdyYXBJblByb21pc2VSZXNvbHV0aW9uSGFuZGxlcihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbihtYXliZUFyZykge1xuICAgICAgaWYgKGokLmlzRXJyb3JfKG1heWJlQXJnKSkge1xuICAgICAgICBmbihtYXliZUFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbigpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gUXVldWVSdW5uZXI7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlJlcG9ydERpc3BhdGNoZXIgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBSZXBvcnREaXNwYXRjaGVyKG1ldGhvZHMsIHF1ZXVlUnVubmVyRmFjdG9yeSwgb25MYXRlRXJyb3IpIHtcbiAgICB2YXIgZGlzcGF0Y2hlZE1ldGhvZHMgPSBtZXRob2RzIHx8IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaGVkTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG1ldGhvZCA9IGRpc3BhdGNoZWRNZXRob2RzW2ldO1xuICAgICAgdGhpc1ttZXRob2RdID0gKGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGRpc3BhdGNoKG0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KShtZXRob2QpO1xuICAgIH1cblxuICAgIHZhciByZXBvcnRlcnMgPSBbXTtcbiAgICB2YXIgZmFsbGJhY2tSZXBvcnRlciA9IG51bGw7XG5cbiAgICB0aGlzLmFkZFJlcG9ydGVyID0gZnVuY3Rpb24ocmVwb3J0ZXIpIHtcbiAgICAgIHJlcG9ydGVycy5wdXNoKHJlcG9ydGVyKTtcbiAgICB9O1xuXG4gICAgdGhpcy5wcm92aWRlRmFsbGJhY2tSZXBvcnRlciA9IGZ1bmN0aW9uKHJlcG9ydGVyKSB7XG4gICAgICBmYWxsYmFja1JlcG9ydGVyID0gcmVwb3J0ZXI7XG4gICAgfTtcblxuICAgIHRoaXMuY2xlYXJSZXBvcnRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJlcG9ydGVycyA9IFtdO1xuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcztcblxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoKG1ldGhvZCwgYXJncykge1xuICAgICAgaWYgKHJlcG9ydGVycy5sZW5ndGggPT09IDAgJiYgZmFsbGJhY2tSZXBvcnRlciAhPT0gbnVsbCkge1xuICAgICAgICByZXBvcnRlcnMucHVzaChmYWxsYmFja1JlcG9ydGVyKTtcbiAgICAgIH1cbiAgICAgIHZhciBvbkNvbXBsZXRlID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgYXJncyA9IGokLnV0aWwuYXJnc1RvQXJyYXkoYXJncykuc3BsaWNlKDAsIGFyZ3MubGVuZ3RoIC0gMSk7XG4gICAgICB2YXIgZm5zID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcG9ydGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmVwb3J0ZXIgPSByZXBvcnRlcnNbaV07XG4gICAgICAgIGFkZEZuKGZucywgcmVwb3J0ZXIsIG1ldGhvZCwgYXJncyk7XG4gICAgICB9XG5cbiAgICAgIHF1ZXVlUnVubmVyRmFjdG9yeSh7XG4gICAgICAgIHF1ZXVlYWJsZUZuczogZm5zLFxuICAgICAgICBvbkNvbXBsZXRlOiBvbkNvbXBsZXRlLFxuICAgICAgICBpc1JlcG9ydGVyOiB0cnVlLFxuICAgICAgICBvbk11bHRpcGxlRG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgb25MYXRlRXJyb3IoXG4gICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIFwiQW4gYXN5bmNocm9ub3VzIHJlcG9ydGVyIGNhbGxiYWNrIGNhbGxlZCBpdHMgJ2RvbmUnIGNhbGxiYWNrIFwiICtcbiAgICAgICAgICAgICAgICAnbW9yZSB0aGFuIG9uY2UuJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEZuKGZucywgcmVwb3J0ZXIsIG1ldGhvZCwgYXJncykge1xuICAgICAgdmFyIGZuID0gcmVwb3J0ZXJbbWV0aG9kXTtcbiAgICAgIGlmICghZm4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGhpc0FyZ3MgPSBqJC51dGlsLmNsb25lQXJncyhhcmdzKTtcbiAgICAgIGlmIChmbi5sZW5ndGggPD0gMSkge1xuICAgICAgICBmbnMucHVzaCh7XG4gICAgICAgICAgZm46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHJlcG9ydGVyLCB0aGlzQXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZucy5wdXNoKHtcbiAgICAgICAgICBmbjogZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHJlcG9ydGVyLCB0aGlzQXJncy5jb25jYXQoW2RvbmVdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gUmVwb3J0RGlzcGF0Y2hlcjtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuaW50ZXJmYWNlID0gZnVuY3Rpb24oamFzbWluZSwgZW52KSB7XG4gIHZhciBqYXNtaW5lSW50ZXJmYWNlID0ge1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHBhc3NlZCB0byBwYXJ0cyBvZiB0aGUgSmFzbWluZSBiYXNlIGludGVyZmFjZS5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQgSmFzbWluZSBhc3N1bWVzIHRoaXMgZnVuY3Rpb24gY29tcGxldGVzIHN5bmNocm9ub3VzbHkuXG4gICAgICogSWYgeW91IGhhdmUgY29kZSB0aGF0IHlvdSBuZWVkIHRvIHRlc3QgYXN5bmNocm9ub3VzbHksIHlvdSBjYW4gZGVjbGFyZSB0aGF0IHlvdSByZWNlaXZlIGEgYGRvbmVgIGNhbGxiYWNrLCByZXR1cm4gYSBQcm9taXNlLCBvciB1c2UgdGhlIGBhc3luY2Aga2V5d29yZCBpZiBpdCBpcyBzdXBwb3J0ZWQgaW4geW91ciBlbnZpcm9ubWVudC5cbiAgICAgKiBAY2FsbGJhY2sgaW1wbGVtZW50YXRpb25DYWxsYmFja1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtkb25lXSBVc2VkIHRvIHNwZWNpZnkgdG8gSmFzbWluZSB0aGF0IHRoaXMgY2FsbGJhY2sgaXMgYXN5bmNocm9ub3VzIGFuZCBKYXNtaW5lIHNob3VsZCB3YWl0IHVudGlsIGl0IGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUgbW92aW5nIG9uLlxuICAgICAqIEByZXR1cm5zIHt9IE9wdGlvbmFsbHkgcmV0dXJuIGEgUHJvbWlzZSBpbnN0ZWFkIG9mIHVzaW5nIGBkb25lYCB0byBjYXVzZSBKYXNtaW5lIHRvIHdhaXQgZm9yIGNvbXBsZXRpb24uXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBncm91cCBvZiBzcGVjcyAob2Z0ZW4gY2FsbGVkIGEgc3VpdGUpLlxuICAgICAqXG4gICAgICogQ2FsbHMgdG8gYGRlc2NyaWJlYCBjYW4gYmUgbmVzdGVkIHdpdGhpbiBvdGhlciBjYWxscyB0byBjb21wb3NlIHlvdXIgc3VpdGUgYXMgYSB0cmVlLlxuICAgICAqIEBuYW1lIGRlc2NyaWJlXG4gICAgICogQHNpbmNlIDEuMy4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGdsb2JhbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkZXNjcmlwdGlvbiBUZXh0dWFsIGRlc2NyaXB0aW9uIG9mIHRoZSBncm91cFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNwZWNEZWZpbml0aW9ucyBGdW5jdGlvbiBmb3IgSmFzbWluZSB0byBpbnZva2UgdGhhdCB3aWxsIGRlZmluZSBpbm5lciBzdWl0ZXMgYW5kIHNwZWNzXG4gICAgICovXG4gICAgZGVzY3JpYmU6IGZ1bmN0aW9uKGRlc2NyaXB0aW9uLCBzcGVjRGVmaW5pdGlvbnMpIHtcbiAgICAgIHJldHVybiBlbnYuZGVzY3JpYmUoZGVzY3JpcHRpb24sIHNwZWNEZWZpbml0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdGVtcG9yYXJpbHkgZGlzYWJsZWQgW2BkZXNjcmliZWBde0BsaW5rIGRlc2NyaWJlfVxuICAgICAqXG4gICAgICogU3BlY3Mgd2l0aGluIGFuIGB4ZGVzY3JpYmVgIHdpbGwgYmUgbWFya2VkIHBlbmRpbmcgYW5kIG5vdCBleGVjdXRlZFxuICAgICAqIEBuYW1lIHhkZXNjcmliZVxuICAgICAqIEBzaW5jZSAxLjMuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBnbG9iYWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVzY3JpcHRpb24gVGV4dHVhbCBkZXNjcmlwdGlvbiBvZiB0aGUgZ3JvdXBcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzcGVjRGVmaW5pdGlvbnMgRnVuY3Rpb24gZm9yIEphc21pbmUgdG8gaW52b2tlIHRoYXQgd2lsbCBkZWZpbmUgaW5uZXIgc3VpdGVzIGFuZCBzcGVjc1xuICAgICAqL1xuICAgIHhkZXNjcmliZTogZnVuY3Rpb24oZGVzY3JpcHRpb24sIHNwZWNEZWZpbml0aW9ucykge1xuICAgICAgcmV0dXJuIGVudi54ZGVzY3JpYmUoZGVzY3JpcHRpb24sIHNwZWNEZWZpbml0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgZm9jdXNlZCBbYGRlc2NyaWJlYF17QGxpbmsgZGVzY3JpYmV9XG4gICAgICpcbiAgICAgKiBJZiBzdWl0ZXMgb3Igc3BlY3MgYXJlIGZvY3VzZWQsIG9ubHkgdGhvc2UgdGhhdCBhcmUgZm9jdXNlZCB3aWxsIGJlIGV4ZWN1dGVkXG4gICAgICogQHNlZSBmaXRcbiAgICAgKiBAbmFtZSBmZGVzY3JpYmVcbiAgICAgKiBAc2luY2UgMi4xLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZ2xvYmFsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlc2NyaXB0aW9uIFRleHR1YWwgZGVzY3JpcHRpb24gb2YgdGhlIGdyb3VwXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3BlY0RlZmluaXRpb25zIEZ1bmN0aW9uIGZvciBKYXNtaW5lIHRvIGludm9rZSB0aGF0IHdpbGwgZGVmaW5lIGlubmVyIHN1aXRlcyBhbmQgc3BlY3NcbiAgICAgKi9cbiAgICBmZGVzY3JpYmU6IGZ1bmN0aW9uKGRlc2NyaXB0aW9uLCBzcGVjRGVmaW5pdGlvbnMpIHtcbiAgICAgIHJldHVybiBlbnYuZmRlc2NyaWJlKGRlc2NyaXB0aW9uLCBzcGVjRGVmaW5pdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmUgYSBzaW5nbGUgc3BlYy4gQSBzcGVjIHNob3VsZCBjb250YWluIG9uZSBvciBtb3JlIHtAbGluayBleHBlY3R8ZXhwZWN0YXRpb25zfSB0aGF0IHRlc3QgdGhlIHN0YXRlIG9mIHRoZSBjb2RlLlxuICAgICAqXG4gICAgICogQSBzcGVjIHdob3NlIGV4cGVjdGF0aW9ucyBhbGwgc3VjY2VlZCB3aWxsIGJlIHBhc3NpbmcgYW5kIGEgc3BlYyB3aXRoIGFueSBmYWlsdXJlcyB3aWxsIGZhaWwuXG4gICAgICogVGhlIG5hbWUgYGl0YCBpcyBhIHByb25vdW4gZm9yIHRoZSB0ZXN0IHRhcmdldCwgbm90IGFuIGFiYnJldmlhdGlvbiBvZiBhbnl0aGluZy4gSXQgbWFrZXMgdGhlXG4gICAgICogc3BlYyBtb3JlIHJlYWRhYmxlIGJ5IGNvbm5lY3RpbmcgdGhlIGZ1bmN0aW9uIG5hbWUgYGl0YCBhbmQgdGhlIGFyZ3VtZW50IGBkZXNjcmlwdGlvbmAgYXMgYVxuICAgICAqIGNvbXBsZXRlIHNlbnRlbmNlLlxuICAgICAqIEBuYW1lIGl0XG4gICAgICogQHNpbmNlIDEuMy4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGdsb2JhbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkZXNjcmlwdGlvbiBUZXh0dWFsIGRlc2NyaXB0aW9uIG9mIHdoYXQgdGhpcyBzcGVjIGlzIGNoZWNraW5nXG4gICAgICogQHBhcmFtIHtpbXBsZW1lbnRhdGlvbkNhbGxiYWNrfSBbdGVzdEZ1bmN0aW9uXSBGdW5jdGlvbiB0aGF0IGNvbnRhaW5zIHRoZSBjb2RlIG9mIHlvdXIgdGVzdC4gSWYgbm90IHByb3ZpZGVkIHRoZSB0ZXN0IHdpbGwgYmUgYHBlbmRpbmdgLlxuICAgICAqIEBwYXJhbSB7SW50fSBbdGltZW91dD17QGxpbmsgamFzbWluZS5ERUZBVUxUX1RJTUVPVVRfSU5URVJWQUx9XSBDdXN0b20gdGltZW91dCBmb3IgYW4gYXN5bmMgc3BlYy5cbiAgICAgKiBAc2VlIGFzeW5jXG4gICAgICovXG4gICAgaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGVudi5pdC5hcHBseShlbnYsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdGVtcG9yYXJpbHkgZGlzYWJsZWQgW2BpdGBde0BsaW5rIGl0fVxuICAgICAqXG4gICAgICogVGhlIHNwZWMgd2lsbCByZXBvcnQgYXMgYHBlbmRpbmdgIGFuZCB3aWxsIG5vdCBiZSBleGVjdXRlZC5cbiAgICAgKiBAbmFtZSB4aXRcbiAgICAgKiBAc2luY2UgMS4zLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZ2xvYmFsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlc2NyaXB0aW9uIFRleHR1YWwgZGVzY3JpcHRpb24gb2Ygd2hhdCB0aGlzIHNwZWMgaXMgY2hlY2tpbmcuXG4gICAgICogQHBhcmFtIHtpbXBsZW1lbnRhdGlvbkNhbGxiYWNrfSBbdGVzdEZ1bmN0aW9uXSBGdW5jdGlvbiB0aGF0IGNvbnRhaW5zIHRoZSBjb2RlIG9mIHlvdXIgdGVzdC4gV2lsbCBub3QgYmUgZXhlY3V0ZWQuXG4gICAgICovXG4gICAgeGl0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBlbnYueGl0LmFwcGx5KGVudiwgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSBmb2N1c2VkIFtgaXRgXXtAbGluayBpdH1cbiAgICAgKlxuICAgICAqIElmIHN1aXRlcyBvciBzcGVjcyBhcmUgZm9jdXNlZCwgb25seSB0aG9zZSB0aGF0IGFyZSBmb2N1c2VkIHdpbGwgYmUgZXhlY3V0ZWQuXG4gICAgICogQG5hbWUgZml0XG4gICAgICogQHNpbmNlIDIuMS4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGdsb2JhbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkZXNjcmlwdGlvbiBUZXh0dWFsIGRlc2NyaXB0aW9uIG9mIHdoYXQgdGhpcyBzcGVjIGlzIGNoZWNraW5nLlxuICAgICAqIEBwYXJhbSB7aW1wbGVtZW50YXRpb25DYWxsYmFja30gdGVzdEZ1bmN0aW9uIEZ1bmN0aW9uIHRoYXQgY29udGFpbnMgdGhlIGNvZGUgb2YgeW91ciB0ZXN0LlxuICAgICAqIEBwYXJhbSB7SW50fSBbdGltZW91dD17QGxpbmsgamFzbWluZS5ERUZBVUxUX1RJTUVPVVRfSU5URVJWQUx9XSBDdXN0b20gdGltZW91dCBmb3IgYW4gYXN5bmMgc3BlYy5cbiAgICAgKiBAc2VlIGFzeW5jXG4gICAgICovXG4gICAgZml0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBlbnYuZml0LmFwcGx5KGVudiwgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUnVuIHNvbWUgc2hhcmVkIHNldHVwIGJlZm9yZSBlYWNoIG9mIHRoZSBzcGVjcyBpbiB0aGUge0BsaW5rIGRlc2NyaWJlfSBpbiB3aGljaCBpdCBpcyBjYWxsZWQuXG4gICAgICogQG5hbWUgYmVmb3JlRWFjaFxuICAgICAqIEBzaW5jZSAxLjMuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBnbG9iYWxcbiAgICAgKiBAcGFyYW0ge2ltcGxlbWVudGF0aW9uQ2FsbGJhY2t9IFtmdW5jdGlvbl0gRnVuY3Rpb24gdGhhdCBjb250YWlucyB0aGUgY29kZSB0byBzZXR1cCB5b3VyIHNwZWNzLlxuICAgICAqIEBwYXJhbSB7SW50fSBbdGltZW91dD17QGxpbmsgamFzbWluZS5ERUZBVUxUX1RJTUVPVVRfSU5URVJWQUx9XSBDdXN0b20gdGltZW91dCBmb3IgYW4gYXN5bmMgYmVmb3JlRWFjaC5cbiAgICAgKiBAc2VlIGFzeW5jXG4gICAgICovXG4gICAgYmVmb3JlRWFjaDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZW52LmJlZm9yZUVhY2guYXBwbHkoZW52LCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSdW4gc29tZSBzaGFyZWQgdGVhcmRvd24gYWZ0ZXIgZWFjaCBvZiB0aGUgc3BlY3MgaW4gdGhlIHtAbGluayBkZXNjcmliZX0gaW4gd2hpY2ggaXQgaXMgY2FsbGVkLlxuICAgICAqIEBuYW1lIGFmdGVyRWFjaFxuICAgICAqIEBzaW5jZSAxLjMuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBnbG9iYWxcbiAgICAgKiBAcGFyYW0ge2ltcGxlbWVudGF0aW9uQ2FsbGJhY2t9IFtmdW5jdGlvbl0gRnVuY3Rpb24gdGhhdCBjb250YWlucyB0aGUgY29kZSB0byB0ZWFyZG93biB5b3VyIHNwZWNzLlxuICAgICAqIEBwYXJhbSB7SW50fSBbdGltZW91dD17QGxpbmsgamFzbWluZS5ERUZBVUxUX1RJTUVPVVRfSU5URVJWQUx9XSBDdXN0b20gdGltZW91dCBmb3IgYW4gYXN5bmMgYWZ0ZXJFYWNoLlxuICAgICAqIEBzZWUgYXN5bmNcbiAgICAgKi9cbiAgICBhZnRlckVhY2g6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGVudi5hZnRlckVhY2guYXBwbHkoZW52LCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSdW4gc29tZSBzaGFyZWQgc2V0dXAgb25jZSBiZWZvcmUgYWxsIG9mIHRoZSBzcGVjcyBpbiB0aGUge0BsaW5rIGRlc2NyaWJlfSBhcmUgcnVuLlxuICAgICAqXG4gICAgICogX05vdGU6XyBCZSBjYXJlZnVsLCBzaGFyaW5nIHRoZSBzZXR1cCBmcm9tIGEgYmVmb3JlQWxsIG1ha2VzIGl0IGVhc3kgdG8gYWNjaWRlbnRhbGx5IGxlYWsgc3RhdGUgYmV0d2VlbiB5b3VyIHNwZWNzIHNvIHRoYXQgdGhleSBlcnJvbmVvdXNseSBwYXNzIG9yIGZhaWwuXG4gICAgICogQG5hbWUgYmVmb3JlQWxsXG4gICAgICogQHNpbmNlIDIuMS4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGdsb2JhbFxuICAgICAqIEBwYXJhbSB7aW1wbGVtZW50YXRpb25DYWxsYmFja30gW2Z1bmN0aW9uXSBGdW5jdGlvbiB0aGF0IGNvbnRhaW5zIHRoZSBjb2RlIHRvIHNldHVwIHlvdXIgc3BlY3MuXG4gICAgICogQHBhcmFtIHtJbnR9IFt0aW1lb3V0PXtAbGluayBqYXNtaW5lLkRFRkFVTFRfVElNRU9VVF9JTlRFUlZBTH1dIEN1c3RvbSB0aW1lb3V0IGZvciBhbiBhc3luYyBiZWZvcmVBbGwuXG4gICAgICogQHNlZSBhc3luY1xuICAgICAqL1xuICAgIGJlZm9yZUFsbDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZW52LmJlZm9yZUFsbC5hcHBseShlbnYsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJ1biBzb21lIHNoYXJlZCB0ZWFyZG93biBvbmNlIGFmdGVyIGFsbCBvZiB0aGUgc3BlY3MgaW4gdGhlIHtAbGluayBkZXNjcmliZX0gYXJlIHJ1bi5cbiAgICAgKlxuICAgICAqIF9Ob3RlOl8gQmUgY2FyZWZ1bCwgc2hhcmluZyB0aGUgdGVhcmRvd24gZnJvbSBhIGFmdGVyQWxsIG1ha2VzIGl0IGVhc3kgdG8gYWNjaWRlbnRhbGx5IGxlYWsgc3RhdGUgYmV0d2VlbiB5b3VyIHNwZWNzIHNvIHRoYXQgdGhleSBlcnJvbmVvdXNseSBwYXNzIG9yIGZhaWwuXG4gICAgICogQG5hbWUgYWZ0ZXJBbGxcbiAgICAgKiBAc2luY2UgMi4xLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZ2xvYmFsXG4gICAgICogQHBhcmFtIHtpbXBsZW1lbnRhdGlvbkNhbGxiYWNrfSBbZnVuY3Rpb25dIEZ1bmN0aW9uIHRoYXQgY29udGFpbnMgdGhlIGNvZGUgdG8gdGVhcmRvd24geW91ciBzcGVjcy5cbiAgICAgKiBAcGFyYW0ge0ludH0gW3RpbWVvdXQ9e0BsaW5rIGphc21pbmUuREVGQVVMVF9USU1FT1VUX0lOVEVSVkFMfV0gQ3VzdG9tIHRpbWVvdXQgZm9yIGFuIGFzeW5jIGFmdGVyQWxsLlxuICAgICAqIEBzZWUgYXN5bmNcbiAgICAgKi9cbiAgICBhZnRlckFsbDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZW52LmFmdGVyQWxsLmFwcGx5KGVudiwgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIHVzZXItZGVmaW5lZCBwcm9wZXJ0eSB0aGF0IHdpbGwgYmUgcHJvdmlkZWQgdG8gcmVwb3J0ZXJzIGFzIHBhcnQgb2YgdGhlIHByb3BlcnRpZXMgZmllbGQgb2Yge0BsaW5rIFNwZWNSZXN1bHR9XG4gICAgICogQG5hbWUgc2V0U3BlY1Byb3BlcnR5XG4gICAgICogQHNpbmNlIDMuNi4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKi9cbiAgICBzZXRTcGVjUHJvcGVydHk6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBlbnYuc2V0U3BlY1Byb3BlcnR5KGtleSwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgdXNlci1kZWZpbmVkIHByb3BlcnR5IHRoYXQgd2lsbCBiZSBwcm92aWRlZCB0byByZXBvcnRlcnMgYXMgcGFydCBvZiB0aGUgcHJvcGVydGllcyBmaWVsZCBvZiB7QGxpbmsgU3VpdGVSZXN1bHR9XG4gICAgICogQG5hbWUgc2V0U3VpdGVQcm9wZXJ0eVxuICAgICAqIEBzaW5jZSAzLjYuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICovXG4gICAgc2V0U3VpdGVQcm9wZXJ0eTogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGVudi5zZXRTdWl0ZVByb3BlcnR5KGtleSwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gZXhwZWN0YXRpb24gZm9yIGEgc3BlYy5cbiAgICAgKiBAbmFtZSBleHBlY3RcbiAgICAgKiBAc2luY2UgMS4zLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZ2xvYmFsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFjdHVhbCAtIEFjdHVhbCBjb21wdXRlZCB2YWx1ZSB0byB0ZXN0IGV4cGVjdGF0aW9ucyBhZ2FpbnN0LlxuICAgICAqIEByZXR1cm4ge21hdGNoZXJzfVxuICAgICAqL1xuICAgIGV4cGVjdDogZnVuY3Rpb24oYWN0dWFsKSB7XG4gICAgICByZXR1cm4gZW52LmV4cGVjdChhY3R1YWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gYXN5bmNocm9ub3VzIGV4cGVjdGF0aW9uIGZvciBhIHNwZWMuIE5vdGUgdGhhdCB0aGUgbWF0Y2hlcnNcbiAgICAgKiB0aGF0IGFyZSBwcm92aWRlZCBieSBhbiBhc3luY2hyb25vdXMgZXhwZWN0YXRpb24gYWxsIHJldHVybiBwcm9taXNlc1xuICAgICAqIHdoaWNoIG11c3QgYmUgZWl0aGVyIHJldHVybmVkIGZyb20gdGhlIHNwZWMgb3Igd2FpdGVkIGZvciB1c2luZyBgYXdhaXRgXG4gICAgICogaW4gb3JkZXIgZm9yIEphc21pbmUgdG8gYXNzb2NpYXRlIHRoZW0gd2l0aCB0aGUgY29ycmVjdCBzcGVjLlxuICAgICAqIEBuYW1lIGV4cGVjdEFzeW5jXG4gICAgICogQHNpbmNlIDMuMy4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGdsb2JhbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY3R1YWwgLSBBY3R1YWwgY29tcHV0ZWQgdmFsdWUgdG8gdGVzdCBleHBlY3RhdGlvbnMgYWdhaW5zdC5cbiAgICAgKiBAcmV0dXJuIHthc3luYy1tYXRjaGVyc31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGF3YWl0IGV4cGVjdEFzeW5jKHNvbWVQcm9taXNlKS50b0JlUmVzb2x2ZWQoKTtcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHJldHVybiBleHBlY3RBc3luYyhzb21lUHJvbWlzZSkudG9CZVJlc29sdmVkKCk7XG4gICAgICovXG4gICAgZXhwZWN0QXN5bmM6IGZ1bmN0aW9uKGFjdHVhbCkge1xuICAgICAgcmV0dXJuIGVudi5leHBlY3RBc3luYyhhY3R1YWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYXJrIGEgc3BlYyBhcyBwZW5kaW5nLCBleHBlY3RhdGlvbiByZXN1bHRzIHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKiBAbmFtZSBwZW5kaW5nXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGdsb2JhbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gLSBSZWFzb24gdGhlIHNwZWMgaXMgcGVuZGluZy5cbiAgICAgKi9cbiAgICBwZW5kaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBlbnYucGVuZGluZy5hcHBseShlbnYsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4cGxpY2l0bHkgbWFyayBhIHNwZWMgYXMgZmFpbGVkLlxuICAgICAqIEBuYW1lIGZhaWxcbiAgICAgKiBAc2luY2UgMi4xLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZ2xvYmFsXG4gICAgICogQHBhcmFtIHtTdHJpbmd8RXJyb3J9IFtlcnJvcl0gLSBSZWFzb24gZm9yIHRoZSBmYWlsdXJlLlxuICAgICAqL1xuICAgIGZhaWw6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGVudi5mYWlsLmFwcGx5KGVudiwgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5zdGFsbCBhIHNweSBvbnRvIGFuIGV4aXN0aW5nIG9iamVjdC5cbiAgICAgKiBAbmFtZSBzcHlPblxuICAgICAqIEBzaW5jZSAxLjMuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBnbG9iYWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gVGhlIG9iamVjdCB1cG9uIHdoaWNoIHRvIGluc3RhbGwgdGhlIHtAbGluayBTcHl9LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2ROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byByZXBsYWNlIHdpdGggYSB7QGxpbmsgU3B5fS5cbiAgICAgKiBAcmV0dXJucyB7U3B5fVxuICAgICAqL1xuICAgIHNweU9uOiBmdW5jdGlvbihvYmosIG1ldGhvZE5hbWUpIHtcbiAgICAgIHJldHVybiBlbnYuc3B5T24ob2JqLCBtZXRob2ROYW1lKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5zdGFsbCBhIHNweSBvbiBhIHByb3BlcnR5IGluc3RhbGxlZCB3aXRoIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG9udG8gYW4gZXhpc3Rpbmcgb2JqZWN0LlxuICAgICAqIEBuYW1lIHNweU9uUHJvcGVydHlcbiAgICAgKiBAc2luY2UgMi42LjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZ2xvYmFsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIFRoZSBvYmplY3QgdXBvbiB3aGljaCB0byBpbnN0YWxsIHRoZSB7QGxpbmsgU3B5fVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gcmVwbGFjZSB3aXRoIGEge0BsaW5rIFNweX0uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFthY2Nlc3NUeXBlPWdldF0gLSBUaGUgYWNjZXNzIHR5cGUgKGdldHxzZXQpIG9mIHRoZSBwcm9wZXJ0eSB0byB7QGxpbmsgU3B5fSBvbi5cbiAgICAgKiBAcmV0dXJucyB7U3B5fVxuICAgICAqL1xuICAgIHNweU9uUHJvcGVydHk6IGZ1bmN0aW9uKG9iaiwgbWV0aG9kTmFtZSwgYWNjZXNzVHlwZSkge1xuICAgICAgcmV0dXJuIGVudi5zcHlPblByb3BlcnR5KG9iaiwgbWV0aG9kTmFtZSwgYWNjZXNzVHlwZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc3RhbGxzIHNwaWVzIG9uIGFsbCB3cml0YWJsZSBhbmQgY29uZmlndXJhYmxlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0LlxuICAgICAqIEBuYW1lIHNweU9uQWxsRnVuY3Rpb25zXG4gICAgICogQHNpbmNlIDMuMi4xXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGdsb2JhbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBUaGUgb2JqZWN0IHVwb24gd2hpY2ggdG8gaW5zdGFsbCB0aGUge0BsaW5rIFNweX1zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpbmNsdWRlTm9uRW51bWVyYWJsZSAtIFdoZXRoZXIgb3Igbm90IHRvIGFkZCBzcGllcyB0byBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzXG4gICAgICogQHJldHVybnMge09iamVjdH0gdGhlIHNwaWVkIG9iamVjdFxuICAgICAqL1xuICAgIHNweU9uQWxsRnVuY3Rpb25zOiBmdW5jdGlvbihvYmosIGluY2x1ZGVOb25FbnVtZXJhYmxlKSB7XG4gICAgICByZXR1cm4gZW52LnNweU9uQWxsRnVuY3Rpb25zKG9iaiwgaW5jbHVkZU5vbkVudW1lcmFibGUpO1xuICAgIH0sXG5cbiAgICBqc0FwaVJlcG9ydGVyOiBuZXcgamFzbWluZS5Kc0FwaVJlcG9ydGVyKHtcbiAgICAgIHRpbWVyOiBuZXcgamFzbWluZS5UaW1lcigpXG4gICAgfSksXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlIGphc21pbmVcbiAgICAgKi9cbiAgICBqYXNtaW5lOiBqYXNtaW5lXG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIGN1c3RvbSBlcXVhbGl0eSB0ZXN0ZXIgZm9yIHRoZSBjdXJyZW50IHNjb3BlIG9mIHNwZWNzLlxuICAgKlxuICAgKiBfTm90ZTpfIFRoaXMgaXMgb25seSBjYWxsYWJsZSBmcm9tIHdpdGhpbiBhIHtAbGluayBiZWZvcmVFYWNofSwge0BsaW5rIGl0fSwgb3Ige0BsaW5rIGJlZm9yZUFsbH0uXG4gICAqIEBuYW1lIGphc21pbmUuYWRkQ3VzdG9tRXF1YWxpdHlUZXN0ZXJcbiAgICogQHNpbmNlIDIuMC4wXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0ZXN0ZXIgLSBBIGZ1bmN0aW9uIHdoaWNoIHRha2VzIHR3byBhcmd1bWVudHMgdG8gY29tcGFyZSBhbmQgcmV0dXJucyBhIGB0cnVlYCBvciBgZmFsc2VgIGNvbXBhcmlzb24gcmVzdWx0IGlmIGl0IGtub3dzIGhvdyB0byBjb21wYXJlIHRoZW0sIGFuZCBgdW5kZWZpbmVkYCBvdGhlcndpc2UuXG4gICAqIEBzZWUgY3VzdG9tX2VxdWFsaXR5XG4gICAqL1xuICBqYXNtaW5lLmFkZEN1c3RvbUVxdWFsaXR5VGVzdGVyID0gZnVuY3Rpb24odGVzdGVyKSB7XG4gICAgZW52LmFkZEN1c3RvbUVxdWFsaXR5VGVzdGVyKHRlc3Rlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBjdXN0b20gbWF0Y2hlcnMgZm9yIHRoZSBjdXJyZW50IHNjb3BlIG9mIHNwZWNzLlxuICAgKlxuICAgKiBfTm90ZTpfIFRoaXMgaXMgb25seSBjYWxsYWJsZSBmcm9tIHdpdGhpbiBhIHtAbGluayBiZWZvcmVFYWNofSwge0BsaW5rIGl0fSwgb3Ige0BsaW5rIGJlZm9yZUFsbH0uXG4gICAqIEBuYW1lIGphc21pbmUuYWRkTWF0Y2hlcnNcbiAgICogQHNpbmNlIDIuMC4wXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gbWF0Y2hlcnMgLSBLZXlzIGZyb20gdGhpcyBvYmplY3Qgd2lsbCBiZSB0aGUgbmV3IG1hdGNoZXIgbmFtZXMuXG4gICAqIEBzZWUgY3VzdG9tX21hdGNoZXJcbiAgICovXG4gIGphc21pbmUuYWRkTWF0Y2hlcnMgPSBmdW5jdGlvbihtYXRjaGVycykge1xuICAgIHJldHVybiBlbnYuYWRkTWF0Y2hlcnMobWF0Y2hlcnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgY3VzdG9tIGFzeW5jIG1hdGNoZXJzIGZvciB0aGUgY3VycmVudCBzY29wZSBvZiBzcGVjcy5cbiAgICpcbiAgICogX05vdGU6XyBUaGlzIGlzIG9ubHkgY2FsbGFibGUgZnJvbSB3aXRoaW4gYSB7QGxpbmsgYmVmb3JlRWFjaH0sIHtAbGluayBpdH0sIG9yIHtAbGluayBiZWZvcmVBbGx9LlxuICAgKiBAbmFtZSBqYXNtaW5lLmFkZEFzeW5jTWF0Y2hlcnNcbiAgICogQHNpbmNlIDMuNS4wXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gbWF0Y2hlcnMgLSBLZXlzIGZyb20gdGhpcyBvYmplY3Qgd2lsbCBiZSB0aGUgbmV3IGFzeW5jIG1hdGNoZXIgbmFtZXMuXG4gICAqIEBzZWUgY3VzdG9tX21hdGNoZXJcbiAgICovXG4gIGphc21pbmUuYWRkQXN5bmNNYXRjaGVycyA9IGZ1bmN0aW9uKG1hdGNoZXJzKSB7XG4gICAgcmV0dXJuIGVudi5hZGRBc3luY01hdGNoZXJzKG1hdGNoZXJzKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgY3VzdG9tIG9iamVjdCBmb3JtYXR0ZXIgZm9yIHRoZSBjdXJyZW50IHNjb3BlIG9mIHNwZWNzLlxuICAgKlxuICAgKiBfTm90ZTpfIFRoaXMgaXMgb25seSBjYWxsYWJsZSBmcm9tIHdpdGhpbiBhIHtAbGluayBiZWZvcmVFYWNofSwge0BsaW5rIGl0fSwgb3Ige0BsaW5rIGJlZm9yZUFsbH0uXG4gICAqIEBuYW1lIGphc21pbmUuYWRkQ3VzdG9tT2JqZWN0Rm9ybWF0dGVyXG4gICAqIEBzaW5jZSAzLjYuMFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm9ybWF0dGVyIC0gQSBmdW5jdGlvbiB3aGljaCB0YWtlcyBhIHZhbHVlIHRvIGZvcm1hdCBhbmQgcmV0dXJucyBhIHN0cmluZyBpZiBpdCBrbm93cyBob3cgdG8gZm9ybWF0IGl0LCBhbmQgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlLlxuICAgKiBAc2VlIGN1c3RvbV9vYmplY3RfZm9ybWF0dGVyc1xuICAgKi9cbiAgamFzbWluZS5hZGRDdXN0b21PYmplY3RGb3JtYXR0ZXIgPSBmdW5jdGlvbihmb3JtYXR0ZXIpIHtcbiAgICByZXR1cm4gZW52LmFkZEN1c3RvbU9iamVjdEZvcm1hdHRlcihmb3JtYXR0ZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnRseSBib290ZWQgbW9jayB7Q2xvY2t9IGZvciB0aGlzIEphc21pbmUgZW52aXJvbm1lbnQuXG4gICAqIEBuYW1lIGphc21pbmUuY2xvY2tcbiAgICogQHNpbmNlIDIuMC4wXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7Q2xvY2t9XG4gICAqL1xuICBqYXNtaW5lLmNsb2NrID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGVudi5jbG9jaztcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgYmFyZSB7QGxpbmsgU3B5fSBvYmplY3QuIFRoaXMgd29uJ3QgYmUgaW5zdGFsbGVkIGFueXdoZXJlIGFuZCB3aWxsIG5vdCBoYXZlIGFueSBpbXBsZW1lbnRhdGlvbiBiZWhpbmQgaXQuXG4gICAqIEBuYW1lIGphc21pbmUuY3JlYXRlU3B5XG4gICAqIEBzaW5jZSAxLjMuMFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lXSAtIE5hbWUgdG8gZ2l2ZSB0aGUgc3B5LiBUaGlzIHdpbGwgYmUgZGlzcGxheWVkIGluIGZhaWx1cmUgbWVzc2FnZXMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcmlnaW5hbEZuXSAtIEZ1bmN0aW9uIHRvIGFjdCBhcyB0aGUgcmVhbCBpbXBsZW1lbnRhdGlvbi5cbiAgICogQHJldHVybiB7U3B5fVxuICAgKi9cbiAgamFzbWluZS5jcmVhdGVTcHkgPSBmdW5jdGlvbihuYW1lLCBvcmlnaW5hbEZuKSB7XG4gICAgcmV0dXJuIGVudi5jcmVhdGVTcHkobmFtZSwgb3JpZ2luYWxGbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBvYmplY3Qgd2l0aCBtdWx0aXBsZSB7QGxpbmsgU3B5fXMgYXMgaXRzIG1lbWJlcnMuXG4gICAqIEBuYW1lIGphc21pbmUuY3JlYXRlU3B5T2JqXG4gICAqIEBzaW5jZSAxLjMuMFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtiYXNlTmFtZV0gLSBCYXNlIG5hbWUgZm9yIHRoZSBzcGllcyBpbiB0aGUgb2JqZWN0LlxuICAgKiBAcGFyYW0ge1N0cmluZ1tdfE9iamVjdH0gbWV0aG9kTmFtZXMgLSBBcnJheSBvZiBtZXRob2QgbmFtZXMgdG8gY3JlYXRlIHNwaWVzIGZvciwgb3IgT2JqZWN0IHdob3NlIGtleXMgd2lsbCBiZSBtZXRob2QgbmFtZXMgYW5kIHZhbHVlcyB0aGUge0BsaW5rIFNweSNhbmQjcmV0dXJuVmFsdWV8cmV0dXJuVmFsdWV9LlxuICAgKiBAcGFyYW0ge1N0cmluZ1tdfE9iamVjdH0gW3Byb3BlcnR5TmFtZXNdIC0gQXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgdG8gY3JlYXRlIHNwaWVzIGZvciwgb3IgT2JqZWN0IHdob3NlIGtleXMgd2lsbCBiZSBwcm9wZXJ0eW5hbWVzIGFuZCB2YWx1ZXMgdGhlIHtAbGluayBTcHkjYW5kI3JldHVyblZhbHVlfHJldHVyblZhbHVlfS5cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgamFzbWluZS5jcmVhdGVTcHlPYmogPSBmdW5jdGlvbihiYXNlTmFtZSwgbWV0aG9kTmFtZXMsIHByb3BlcnR5TmFtZXMpIHtcbiAgICByZXR1cm4gZW52LmNyZWF0ZVNweU9iaihiYXNlTmFtZSwgbWV0aG9kTmFtZXMsIHByb3BlcnR5TmFtZXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBjdXN0b20gc3B5IHN0cmF0ZWd5IGZvciB0aGUgY3VycmVudCBzY29wZSBvZiBzcGVjcy5cbiAgICpcbiAgICogX05vdGU6XyBUaGlzIGlzIG9ubHkgY2FsbGFibGUgZnJvbSB3aXRoaW4gYSB7QGxpbmsgYmVmb3JlRWFjaH0sIHtAbGluayBpdH0sIG9yIHtAbGluayBiZWZvcmVBbGx9LlxuICAgKiBAbmFtZSBqYXNtaW5lLmFkZFNweVN0cmF0ZWd5XG4gICAqIEBzaW5jZSAzLjUuMFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgc3RyYXRlZ3kgKGkuZS4gd2hhdCB5b3UgY2FsbCBmcm9tIGBhbmRgKVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmYWN0b3J5IC0gRmFjdG9yeSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHBsYW4gdG8gYmUgZXhlY3V0ZWQuXG4gICAqL1xuICBqYXNtaW5lLmFkZFNweVN0cmF0ZWd5ID0gZnVuY3Rpb24obmFtZSwgZmFjdG9yeSkge1xuICAgIHJldHVybiBlbnYuYWRkU3B5U3RyYXRlZ3kobmFtZSwgZmFjdG9yeSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZGVmYXVsdCBzcHkgc3RyYXRlZ3kgZm9yIHRoZSBjdXJyZW50IHNjb3BlIG9mIHNwZWNzLlxuICAgKlxuICAgKiBfTm90ZTpfIFRoaXMgaXMgb25seSBjYWxsYWJsZSBmcm9tIHdpdGhpbiBhIHtAbGluayBiZWZvcmVFYWNofSwge0BsaW5rIGl0fSwgb3Ige0BsaW5rIGJlZm9yZUFsbH0uXG4gICAqIEBuYW1lIGphc21pbmUuc2V0RGVmYXVsdFNweVN0cmF0ZWd5XG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkZWZhdWx0U3RyYXRlZ3lGbiAtIGEgZnVuY3Rpb24gdGhhdCBhc3NpZ25zIGEgc3RyYXRlZ3lcbiAgICogQGV4YW1wbGVcbiAgICogYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICogICBqYXNtaW5lLnNldERlZmF1bHRTcHlTdHJhdGVneShhbmQgPT4gYW5kLnJldHVyblZhbHVlKHRydWUpKTtcbiAgICogfSk7XG4gICAqL1xuICBqYXNtaW5lLnNldERlZmF1bHRTcHlTdHJhdGVneSA9IGZ1bmN0aW9uKGRlZmF1bHRTdHJhdGVneUZuKSB7XG4gICAgcmV0dXJuIGVudi5zZXREZWZhdWx0U3B5U3RyYXRlZ3koZGVmYXVsdFN0cmF0ZWd5Rm4pO1xuICB9O1xuXG4gIHJldHVybiBqYXNtaW5lSW50ZXJmYWNlO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5Ta2lwQWZ0ZXJCZWZvcmVBbGxFcnJvclBvbGljeSA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIFNraXBBZnRlckJlZm9yZUFsbEVycm9yUG9saWN5KHF1ZXVlYWJsZUZucykge1xuICAgIHRoaXMucXVldWVhYmxlRm5zXyA9IHF1ZXVlYWJsZUZucztcbiAgICB0aGlzLnNraXBwaW5nXyA9IGZhbHNlO1xuICB9XG5cbiAgU2tpcEFmdGVyQmVmb3JlQWxsRXJyb3JQb2xpY3kucHJvdG90eXBlLnNraXBUbyA9IGZ1bmN0aW9uKGxhc3RSYW5Gbkl4KSB7XG4gICAgaWYgKHRoaXMuc2tpcHBpbmdfKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0QWZ0ZXJBbGxBZnRlcl8obGFzdFJhbkZuSXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbGFzdFJhbkZuSXggKyAxO1xuICAgIH1cbiAgfTtcblxuICBTa2lwQWZ0ZXJCZWZvcmVBbGxFcnJvclBvbGljeS5wcm90b3R5cGUubmV4dEFmdGVyQWxsQWZ0ZXJfID0gZnVuY3Rpb24oaSkge1xuICAgIGZvciAoXG4gICAgICBpKys7XG4gICAgICBpIDwgdGhpcy5xdWV1ZWFibGVGbnNfLmxlbmd0aCAmJlxuICAgICAgdGhpcy5xdWV1ZWFibGVGbnNfW2ldLnR5cGUgIT09ICdhZnRlckFsbCc7XG4gICAgICBpKytcbiAgICApIHt9XG4gICAgcmV0dXJuIGk7XG4gIH07XG5cbiAgU2tpcEFmdGVyQmVmb3JlQWxsRXJyb3JQb2xpY3kucHJvdG90eXBlLmZuRXJyb3JlZCA9IGZ1bmN0aW9uKGZuSXgpIHtcbiAgICBpZiAodGhpcy5xdWV1ZWFibGVGbnNfW2ZuSXhdLnR5cGUgPT09ICdiZWZvcmVBbGwnKSB7XG4gICAgICB0aGlzLnNraXBwaW5nXyA9IHRydWU7XG4gICAgICAvLyBGYWlsdXJlcyBuZWVkIHRvIGJlIHJlcG9ydGVkIGZvciBlYWNoIGNvbnRhaW5lZCBzcGVjLiBCdXQgd2UgY2FuJ3QgZG9cbiAgICAgIC8vIHRoYXQgZnJvbSBoZXJlIGJlY2F1c2UgcmVwb3J0aW5nIGlzIGFzeW5jLiBUaGlzIGZ1bmN0aW9uIGlzbid0IGFzeW5jXG4gICAgICAvLyAoYW5kIGNhbid0IGJlIHdpdGhvdXQgZ3JlYXRseSBjb21wbGljYXRpbmcgUXVldWVSdW5uZXIpLiBNYXJrIHRoZVxuICAgICAgLy8gZmFpbHVyZSBzbyB0aGF0IHRoZSBjb2RlIHRoYXQgcmVwb3J0cyB0aGUgc3VpdGUgcmVzdWx0ICh3aGljaCBpc1xuICAgICAgLy8gYWxyZWFkeSBhc3luYykgY2FuIGRldGVjdCB0aGUgZmFpbHVyZSBhbmQgcmVwb3J0IHRoZSBzcGVjcy5cbiAgICAgIHRoaXMucXVldWVhYmxlRm5zX1tmbkl4XS5zdWl0ZS5oYWRCZWZvcmVBbGxGYWlsdXJlID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFNraXBBZnRlckJlZm9yZUFsbEVycm9yUG9saWN5O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5TcHkgPSBmdW5jdGlvbihqJCkge1xuICB2YXIgbmV4dE9yZGVyID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBvcmRlciA9IDA7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gb3JkZXIrKztcbiAgICB9O1xuICB9KSgpO1xuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjIF9Ob3RlOl8gRG8gbm90IGNvbnN0cnVjdCB0aGlzIGRpcmVjdGx5LiBVc2Uge0BsaW5rIHNweU9ufSxcbiAgICoge0BsaW5rIHNweU9uUHJvcGVydHl9LCB7QGxpbmsgamFzbWluZS5jcmVhdGVTcHl9LCBvclxuICAgKiB7QGxpbmsgamFzbWluZS5jcmVhdGVTcHlPYmp9IGluc3RlYWQuXG4gICAqIEBjbGFzcyBTcHlcbiAgICogQGhpZGVjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gU3B5KG5hbWUsIG1hdGNoZXJzVXRpbCwgb3B0aW9uYWxzKSB7XG4gICAgY29uc3QgeyBvcmlnaW5hbEZuLCBjdXN0b21TdHJhdGVnaWVzLCBkZWZhdWx0U3RyYXRlZ3lGbiB9ID0gb3B0aW9uYWxzIHx8IHt9O1xuXG4gICAgdmFyIG51bUFyZ3MgPSB0eXBlb2Ygb3JpZ2luYWxGbiA9PT0gJ2Z1bmN0aW9uJyA/IG9yaWdpbmFsRm4ubGVuZ3RoIDogMCxcbiAgICAgIHdyYXBwZXIgPSBtYWtlRnVuYyhudW1BcmdzLCBmdW5jdGlvbihjb250ZXh0LCBhcmdzLCBpbnZva2VOZXcpIHtcbiAgICAgICAgcmV0dXJuIHNweShjb250ZXh0LCBhcmdzLCBpbnZva2VOZXcpO1xuICAgICAgfSksXG4gICAgICBzdHJhdGVneURpc3BhdGNoZXIgPSBuZXcgU3B5U3RyYXRlZ3lEaXNwYXRjaGVyKFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICBmbjogb3JpZ2luYWxGbixcbiAgICAgICAgICBnZXRTcHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjdXN0b21TdHJhdGVnaWVzOiBjdXN0b21TdHJhdGVnaWVzXG4gICAgICAgIH0sXG4gICAgICAgIG1hdGNoZXJzVXRpbFxuICAgICAgKSxcbiAgICAgIGNhbGxUcmFja2VyID0gbmV3IGokLkNhbGxUcmFja2VyKCksXG4gICAgICBzcHkgPSBmdW5jdGlvbihjb250ZXh0LCBhcmdzLCBpbnZva2VOZXcpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIFNweS5jYWxsRGF0YVxuICAgICAgICAgKiBAcHJvcGVydHkge29iamVjdH0gb2JqZWN0IC0gYHRoaXNgIGNvbnRleHQgZm9yIHRoZSBpbnZvY2F0aW9uLlxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaW52b2NhdGlvbk9yZGVyIC0gT3JkZXIgb2YgdGhlIGludm9jYXRpb24uXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGFyZ3MgLSBUaGUgYXJndW1lbnRzIHBhc3NlZCBmb3IgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICAgKiBAcHJvcGVydHkgcmV0dXJuVmFsdWUgLSBUaGUgdmFsdWUgdGhhdCB3YXMgcmV0dXJuZWQgZnJvbSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgY2FsbERhdGEgPSB7XG4gICAgICAgICAgb2JqZWN0OiBjb250ZXh0LFxuICAgICAgICAgIGludm9jYXRpb25PcmRlcjogbmV4dE9yZGVyKCksXG4gICAgICAgICAgYXJnczogQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3MpXG4gICAgICAgIH07XG5cbiAgICAgICAgY2FsbFRyYWNrZXIudHJhY2soY2FsbERhdGEpO1xuICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBzdHJhdGVneURpc3BhdGNoZXIuZXhlYyhjb250ZXh0LCBhcmdzLCBpbnZva2VOZXcpO1xuICAgICAgICBjYWxsRGF0YS5yZXR1cm5WYWx1ZSA9IHJldHVyblZhbHVlO1xuXG4gICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgIH07XG5cbiAgICBmdW5jdGlvbiBtYWtlRnVuYyhsZW5ndGgsIGZuKSB7XG4gICAgICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAxKGEpIHtcbiAgICAgICAgICAgIHJldHVybiBmbih0aGlzLCBhcmd1bWVudHMsIHRoaXMgaW5zdGFuY2VvZiB3cmFwMSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiB3cmFwMihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4odGhpcywgYXJndW1lbnRzLCB0aGlzIGluc3RhbmNlb2Ygd3JhcDIpO1xuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gd3JhcDMoYSwgYiwgYykge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHRoaXMsIGFyZ3VtZW50cywgdGhpcyBpbnN0YW5jZW9mIHdyYXAzKTtcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHdyYXA0KGEsIGIsIGMsIGQpIHtcbiAgICAgICAgICAgIHJldHVybiBmbih0aGlzLCBhcmd1bWVudHMsIHRoaXMgaW5zdGFuY2VvZiB3cmFwNCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiB3cmFwNShhLCBiLCBjLCBkLCBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4odGhpcywgYXJndW1lbnRzLCB0aGlzIGluc3RhbmNlb2Ygd3JhcDUpO1xuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gd3JhcDYoYSwgYiwgYywgZCwgZSwgZikge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHRoaXMsIGFyZ3VtZW50cywgdGhpcyBpbnN0YW5jZW9mIHdyYXA2KTtcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHdyYXA3KGEsIGIsIGMsIGQsIGUsIGYsIGcpIHtcbiAgICAgICAgICAgIHJldHVybiBmbih0aGlzLCBhcmd1bWVudHMsIHRoaXMgaW5zdGFuY2VvZiB3cmFwNyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiB3cmFwOChhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4odGhpcywgYXJndW1lbnRzLCB0aGlzIGluc3RhbmNlb2Ygd3JhcDgpO1xuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gd3JhcDkoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHRoaXMsIGFyZ3VtZW50cywgdGhpcyBpbnN0YW5jZW9mIHdyYXA5KTtcbiAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiB3cmFwKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHRoaXMsIGFyZ3VtZW50cywgdGhpcyBpbnN0YW5jZW9mIHdyYXApO1xuICAgICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcHJvcCBpbiBvcmlnaW5hbEZuKSB7XG4gICAgICBpZiAocHJvcCA9PT0gJ2FuZCcgfHwgcHJvcCA9PT0gJ2NhbGxzJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJKYXNtaW5lIHNwaWVzIHdvdWxkIG92ZXJ3cml0ZSB0aGUgJ2FuZCcgYW5kICdjYWxscycgcHJvcGVydGllcyBvbiB0aGUgb2JqZWN0IGJlaW5nIHNwaWVkIHVwb25cIlxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB3cmFwcGVyW3Byb3BdID0gb3JpZ2luYWxGbltwcm9wXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtTcHlTdHJhdGVneX0gLSBBY2Nlc3NlcyB0aGUgZGVmYXVsdCBzdHJhdGVneSBmb3IgdGhlIHNweS4gVGhpcyBzdHJhdGVneSB3aWxsIGJlIHVzZWRcbiAgICAgKiB3aGVuZXZlciB0aGUgc3B5IGlzIGNhbGxlZCB3aXRoIGFyZ3VtZW50cyB0aGF0IGRvbid0IG1hdGNoIGFueSBzdHJhdGVneVxuICAgICAqIGNyZWF0ZWQgd2l0aCB7QGxpbmsgU3B5I3dpdGhBcmdzfS5cbiAgICAgKiBAbmFtZSBTcHkjYW5kXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBzcHlPbihzb21lT2JqLCAnZnVuYycpLmFuZC5yZXR1cm5WYWx1ZSg0Mik7XG4gICAgICovXG4gICAgd3JhcHBlci5hbmQgPSBzdHJhdGVneURpc3BhdGNoZXIuYW5kO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyBhIHN0cmF0ZWd5IHRvIGJlIHVzZWQgZm9yIGNhbGxzIHRvIHRoZSBzcHkgdGhhdCBoYXZlIHRoZVxuICAgICAqIHNwZWNpZmllZCBhcmd1bWVudHMuXG4gICAgICogQG5hbWUgU3B5I3dpdGhBcmdzXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsuLi4qfSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB0byBtYXRjaFxuICAgICAqIEB0eXBlIHtTcHlTdHJhdGVneX1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHNweU9uKHNvbWVPYmosICdmdW5jJykud2l0aEFyZ3MoMSwgMiwgMykuYW5kLnJldHVyblZhbHVlKDQyKTtcbiAgICAgKiBzb21lT2JqLmZ1bmMoMSwgMiwgMyk7IC8vIHJldHVybnMgNDJcbiAgICAgKi9cbiAgICB3cmFwcGVyLndpdGhBcmdzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3RyYXRlZ3lEaXNwYXRjaGVyLndpdGhBcmdzLmFwcGx5KHN0cmF0ZWd5RGlzcGF0Y2hlciwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIHdyYXBwZXIuY2FsbHMgPSBjYWxsVHJhY2tlcjtcblxuICAgIGlmIChkZWZhdWx0U3RyYXRlZ3lGbikge1xuICAgICAgZGVmYXVsdFN0cmF0ZWd5Rm4od3JhcHBlci5hbmQpO1xuICAgIH1cblxuICAgIHJldHVybiB3cmFwcGVyO1xuICB9XG5cbiAgZnVuY3Rpb24gU3B5U3RyYXRlZ3lEaXNwYXRjaGVyKHN0cmF0ZWd5QXJncywgbWF0Y2hlcnNVdGlsKSB7XG4gICAgdmFyIGJhc2VTdHJhdGVneSA9IG5ldyBqJC5TcHlTdHJhdGVneShzdHJhdGVneUFyZ3MpO1xuICAgIHZhciBhcmdzU3RyYXRlZ2llcyA9IG5ldyBTdHJhdGVneURpY3QoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IGokLlNweVN0cmF0ZWd5KHN0cmF0ZWd5QXJncyk7XG4gICAgfSwgbWF0Y2hlcnNVdGlsKTtcblxuICAgIHRoaXMuYW5kID0gYmFzZVN0cmF0ZWd5O1xuXG4gICAgdGhpcy5leGVjID0gZnVuY3Rpb24oc3B5LCBhcmdzLCBpbnZva2VOZXcpIHtcbiAgICAgIHZhciBzdHJhdGVneSA9IGFyZ3NTdHJhdGVnaWVzLmdldChhcmdzKTtcblxuICAgICAgaWYgKCFzdHJhdGVneSkge1xuICAgICAgICBpZiAoYXJnc1N0cmF0ZWdpZXMuYW55KCkgJiYgIWJhc2VTdHJhdGVneS5pc0NvbmZpZ3VyZWQoKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiU3B5ICdcIiArXG4gICAgICAgICAgICAgIHN0cmF0ZWd5QXJncy5uYW1lICtcbiAgICAgICAgICAgICAgXCInIHJlY2VpdmVkIGEgY2FsbCB3aXRoIGFyZ3VtZW50cyBcIiArXG4gICAgICAgICAgICAgIGokLmJhc2ljUHJldHR5UHJpbnRlcl8oQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykpICtcbiAgICAgICAgICAgICAgJyBidXQgYWxsIGNvbmZpZ3VyZWQgc3RyYXRlZ2llcyBzcGVjaWZ5IG90aGVyIGFyZ3VtZW50cy4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJhdGVneSA9IGJhc2VTdHJhdGVneTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyYXRlZ3kuZXhlYyhzcHksIGFyZ3MsIGludm9rZU5ldyk7XG4gICAgfTtcblxuICAgIHRoaXMud2l0aEFyZ3MgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7IGFuZDogYXJnc1N0cmF0ZWdpZXMuZ2V0T3JDcmVhdGUoYXJndW1lbnRzKSB9O1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBTdHJhdGVneURpY3Qoc3RyYXRlZ3lGYWN0b3J5LCBtYXRjaGVyc1V0aWwpIHtcbiAgICB0aGlzLnN0cmF0ZWdpZXMgPSBbXTtcbiAgICB0aGlzLnN0cmF0ZWd5RmFjdG9yeSA9IHN0cmF0ZWd5RmFjdG9yeTtcbiAgICB0aGlzLm1hdGNoZXJzVXRpbCA9IG1hdGNoZXJzVXRpbDtcbiAgfVxuXG4gIFN0cmF0ZWd5RGljdC5wcm90b3R5cGUuYW55ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyYXRlZ2llcy5sZW5ndGggPiAwO1xuICB9O1xuXG4gIFN0cmF0ZWd5RGljdC5wcm90b3R5cGUuZ2V0T3JDcmVhdGUgPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgdmFyIHN0cmF0ZWd5ID0gdGhpcy5nZXQoYXJncyk7XG5cbiAgICBpZiAoIXN0cmF0ZWd5KSB7XG4gICAgICBzdHJhdGVneSA9IHRoaXMuc3RyYXRlZ3lGYWN0b3J5KCk7XG4gICAgICB0aGlzLnN0cmF0ZWdpZXMucHVzaCh7XG4gICAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICAgIHN0cmF0ZWd5OiBzdHJhdGVneVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmF0ZWd5O1xuICB9O1xuXG4gIFN0cmF0ZWd5RGljdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oYXJncykge1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuc3RyYXRlZ2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMubWF0Y2hlcnNVdGlsLmVxdWFscyhhcmdzLCB0aGlzLnN0cmF0ZWdpZXNbaV0uYXJncykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyYXRlZ2llc1tpXS5zdHJhdGVneTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFNweTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuU3B5RmFjdG9yeSA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIFNweUZhY3RvcnkoXG4gICAgZ2V0Q3VzdG9tU3RyYXRlZ2llcyxcbiAgICBnZXREZWZhdWx0U3RyYXRlZ3lGbixcbiAgICBnZXRNYXRjaGVyc1V0aWxcbiAgKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5jcmVhdGVTcHkgPSBmdW5jdGlvbihuYW1lLCBvcmlnaW5hbEZuKSB7XG4gICAgICByZXR1cm4gaiQuU3B5KG5hbWUsIGdldE1hdGNoZXJzVXRpbCgpLCB7XG4gICAgICAgIG9yaWdpbmFsRm4sXG4gICAgICAgIGN1c3RvbVN0cmF0ZWdpZXM6IGdldEN1c3RvbVN0cmF0ZWdpZXMoKSxcbiAgICAgICAgZGVmYXVsdFN0cmF0ZWd5Rm46IGdldERlZmF1bHRTdHJhdGVneUZuKClcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLmNyZWF0ZVNweU9iaiA9IGZ1bmN0aW9uKGJhc2VOYW1lLCBtZXRob2ROYW1lcywgcHJvcGVydHlOYW1lcykge1xuICAgICAgdmFyIGJhc2VOYW1lSXNDb2xsZWN0aW9uID1cbiAgICAgICAgaiQuaXNPYmplY3RfKGJhc2VOYW1lKSB8fCBqJC5pc0FycmF5XyhiYXNlTmFtZSk7XG5cbiAgICAgIGlmIChiYXNlTmFtZUlzQ29sbGVjdGlvbikge1xuICAgICAgICBwcm9wZXJ0eU5hbWVzID0gbWV0aG9kTmFtZXM7XG4gICAgICAgIG1ldGhvZE5hbWVzID0gYmFzZU5hbWU7XG4gICAgICAgIGJhc2VOYW1lID0gJ3Vua25vd24nO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2JqID0ge307XG4gICAgICB2YXIgc3B5LCBkZXNjcmlwdG9yO1xuXG4gICAgICB2YXIgbWV0aG9kcyA9IG5vcm1hbGl6ZUtleVZhbHVlcyhtZXRob2ROYW1lcyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3B5ID0gb2JqW21ldGhvZHNbaV1bMF1dID0gc2VsZi5jcmVhdGVTcHkoXG4gICAgICAgICAgYmFzZU5hbWUgKyAnLicgKyBtZXRob2RzW2ldWzBdXG4gICAgICAgICk7XG4gICAgICAgIGlmIChtZXRob2RzW2ldLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBzcHkuYW5kLnJldHVyblZhbHVlKG1ldGhvZHNbaV1bMV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gbm9ybWFsaXplS2V5VmFsdWVzKHByb3BlcnR5TmFtZXMpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IHNlbGYuY3JlYXRlU3B5KGJhc2VOYW1lICsgJy4nICsgcHJvcGVydGllc1tpXVswXSArICcuZ2V0JyksXG4gICAgICAgICAgc2V0OiBzZWxmLmNyZWF0ZVNweShiYXNlTmFtZSArICcuJyArIHByb3BlcnRpZXNbaV1bMF0gKyAnLnNldCcpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzW2ldLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBkZXNjcmlwdG9yLmdldC5hbmQucmV0dXJuVmFsdWUocHJvcGVydGllc1tpXVsxXSk7XG4gICAgICAgICAgZGVzY3JpcHRvci5zZXQuYW5kLnJldHVyblZhbHVlKHByb3BlcnRpZXNbaV1bMV0pO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3BlcnRpZXNbaV1bMF0sIGRlc2NyaXB0b3IpO1xuICAgICAgfVxuXG4gICAgICBpZiAobWV0aG9kcy5sZW5ndGggPT09IDAgJiYgcHJvcGVydGllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgJ2NyZWF0ZVNweU9iaiByZXF1aXJlcyBhIG5vbi1lbXB0eSBhcnJheSBvciBvYmplY3Qgb2YgbWV0aG9kIG5hbWVzIHRvIGNyZWF0ZSBzcGllcyBmb3InO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVLZXlWYWx1ZXMob2JqZWN0KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGlmIChqJC5pc0FycmF5XyhvYmplY3QpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChbb2JqZWN0W2ldXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChqJC5pc09iamVjdF8ob2JqZWN0KSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChba2V5LCBvYmplY3Rba2V5XV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gU3B5RmFjdG9yeTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuU3B5UmVnaXN0cnkgPSBmdW5jdGlvbihqJCkge1xuICB2YXIgc3B5T25Nc2cgPSBqJC5mb3JtYXRFcnJvck1zZygnPHNweU9uPicsICdzcHlPbig8b2JqZWN0PiwgPG1ldGhvZE5hbWU+KScpO1xuICB2YXIgc3B5T25Qcm9wZXJ0eU1zZyA9IGokLmZvcm1hdEVycm9yTXNnKFxuICAgICc8c3B5T25Qcm9wZXJ0eT4nLFxuICAgICdzcHlPblByb3BlcnR5KDxvYmplY3Q+LCA8cHJvcE5hbWU+LCBbYWNjZXNzVHlwZV0pJ1xuICApO1xuXG4gIGZ1bmN0aW9uIFNweVJlZ2lzdHJ5KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgZ2xvYmFsID0gb3B0aW9ucy5nbG9iYWwgfHwgaiQuZ2V0R2xvYmFsKCk7XG4gICAgdmFyIGNyZWF0ZVNweSA9IG9wdGlvbnMuY3JlYXRlU3B5O1xuICAgIHZhciBjdXJyZW50U3BpZXMgPVxuICAgICAgb3B0aW9ucy5jdXJyZW50U3BpZXMgfHxcbiAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9O1xuXG4gICAgdGhpcy5hbGxvd1Jlc3B5ID0gZnVuY3Rpb24oYWxsb3cpIHtcbiAgICAgIHRoaXMucmVzcHkgPSBhbGxvdztcbiAgICB9O1xuXG4gICAgdGhpcy5zcHlPbiA9IGZ1bmN0aW9uKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGdldEVycm9yTXNnID0gc3B5T25Nc2c7XG5cbiAgICAgIGlmIChqJC51dGlsLmlzVW5kZWZpbmVkKG9iaikgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBnZXRFcnJvck1zZyhcbiAgICAgICAgICAgICdjb3VsZCBub3QgZmluZCBhbiBvYmplY3QgdG8gc3B5IHVwb24gZm9yICcgKyBtZXRob2ROYW1lICsgJygpJ1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGokLnV0aWwuaXNVbmRlZmluZWQobWV0aG9kTmFtZSkgfHwgbWV0aG9kTmFtZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0RXJyb3JNc2coJ05vIG1ldGhvZCBuYW1lIHN1cHBsaWVkJykpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaiQudXRpbC5pc1VuZGVmaW5lZChvYmpbbWV0aG9kTmFtZV0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihnZXRFcnJvck1zZyhtZXRob2ROYW1lICsgJygpIG1ldGhvZCBkb2VzIG5vdCBleGlzdCcpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9ialttZXRob2ROYW1lXSAmJiBqJC5pc1NweShvYmpbbWV0aG9kTmFtZV0pKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc3B5KSB7XG4gICAgICAgICAgcmV0dXJuIG9ialttZXRob2ROYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBnZXRFcnJvck1zZyhtZXRob2ROYW1lICsgJyBoYXMgYWxyZWFkeSBiZWVuIHNwaWVkIHVwb24nKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgbWV0aG9kTmFtZSk7XG5cbiAgICAgIGlmIChkZXNjcmlwdG9yICYmICEoZGVzY3JpcHRvci53cml0YWJsZSB8fCBkZXNjcmlwdG9yLnNldCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGdldEVycm9yTXNnKG1ldGhvZE5hbWUgKyAnIGlzIG5vdCBkZWNsYXJlZCB3cml0YWJsZSBvciBoYXMgbm8gc2V0dGVyJylcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9yaWdpbmFsTWV0aG9kID0gb2JqW21ldGhvZE5hbWVdLFxuICAgICAgICBzcGllZE1ldGhvZCA9IGNyZWF0ZVNweShtZXRob2ROYW1lLCBvcmlnaW5hbE1ldGhvZCksXG4gICAgICAgIHJlc3RvcmVTdHJhdGVneTtcblxuICAgICAgaWYgKFxuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBtZXRob2ROYW1lKSB8fFxuICAgICAgICAob2JqID09PSBnbG9iYWwgJiYgbWV0aG9kTmFtZSA9PT0gJ29uZXJyb3InKVxuICAgICAgKSB7XG4gICAgICAgIHJlc3RvcmVTdHJhdGVneSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG9ialttZXRob2ROYW1lXSA9IG9yaWdpbmFsTWV0aG9kO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdG9yZVN0cmF0ZWd5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCFkZWxldGUgb2JqW21ldGhvZE5hbWVdKSB7XG4gICAgICAgICAgICBvYmpbbWV0aG9kTmFtZV0gPSBvcmlnaW5hbE1ldGhvZDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRTcGllcygpLnB1c2goe1xuICAgICAgICByZXN0b3JlT2JqZWN0VG9PcmlnaW5hbFN0YXRlOiByZXN0b3JlU3RyYXRlZ3lcbiAgICAgIH0pO1xuXG4gICAgICBvYmpbbWV0aG9kTmFtZV0gPSBzcGllZE1ldGhvZDtcblxuICAgICAgcmV0dXJuIHNwaWVkTWV0aG9kO1xuICAgIH07XG5cbiAgICB0aGlzLnNweU9uUHJvcGVydHkgPSBmdW5jdGlvbihvYmosIHByb3BlcnR5TmFtZSwgYWNjZXNzVHlwZSkge1xuICAgICAgdmFyIGdldEVycm9yTXNnID0gc3B5T25Qcm9wZXJ0eU1zZztcblxuICAgICAgYWNjZXNzVHlwZSA9IGFjY2Vzc1R5cGUgfHwgJ2dldCc7XG5cbiAgICAgIGlmIChqJC51dGlsLmlzVW5kZWZpbmVkKG9iaikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGdldEVycm9yTXNnKFxuICAgICAgICAgICAgJ3NweU9uIGNvdWxkIG5vdCBmaW5kIGFuIG9iamVjdCB0byBzcHkgdXBvbiBmb3IgJyArXG4gICAgICAgICAgICAgIHByb3BlcnR5TmFtZSArXG4gICAgICAgICAgICAgICcnXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoaiQudXRpbC5pc1VuZGVmaW5lZChwcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihnZXRFcnJvck1zZygnTm8gcHJvcGVydHkgbmFtZSBzdXBwbGllZCcpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBqJC51dGlsLmdldFByb3BlcnR5RGVzY3JpcHRvcihvYmosIHByb3BlcnR5TmFtZSk7XG5cbiAgICAgIGlmICghZGVzY3JpcHRvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0RXJyb3JNc2cocHJvcGVydHlOYW1lICsgJyBwcm9wZXJ0eSBkb2VzIG5vdCBleGlzdCcpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgZ2V0RXJyb3JNc2cocHJvcGVydHlOYW1lICsgJyBpcyBub3QgZGVjbGFyZWQgY29uZmlndXJhYmxlJylcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkZXNjcmlwdG9yW2FjY2Vzc1R5cGVdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBnZXRFcnJvck1zZyhcbiAgICAgICAgICAgICdQcm9wZXJ0eSAnICtcbiAgICAgICAgICAgICAgcHJvcGVydHlOYW1lICtcbiAgICAgICAgICAgICAgJyBkb2VzIG5vdCBoYXZlIGFjY2VzcyB0eXBlICcgK1xuICAgICAgICAgICAgICBhY2Nlc3NUeXBlXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoaiQuaXNTcHkoZGVzY3JpcHRvclthY2Nlc3NUeXBlXSkpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzcHkpIHtcbiAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvclthY2Nlc3NUeXBlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBnZXRFcnJvck1zZyhcbiAgICAgICAgICAgICAgcHJvcGVydHlOYW1lICsgJyMnICsgYWNjZXNzVHlwZSArICcgaGFzIGFscmVhZHkgYmVlbiBzcGllZCB1cG9uJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG9yaWdpbmFsRGVzY3JpcHRvciA9IGokLnV0aWwuY2xvbmUoZGVzY3JpcHRvciksXG4gICAgICAgIHNweSA9IGNyZWF0ZVNweShwcm9wZXJ0eU5hbWUsIGRlc2NyaXB0b3JbYWNjZXNzVHlwZV0pLFxuICAgICAgICByZXN0b3JlU3RyYXRlZ3k7XG5cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgIHJlc3RvcmVTdHJhdGVneSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3BlcnR5TmFtZSwgb3JpZ2luYWxEZXNjcmlwdG9yKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3RvcmVTdHJhdGVneSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGRlbGV0ZSBvYmpbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudFNwaWVzKCkucHVzaCh7XG4gICAgICAgIHJlc3RvcmVPYmplY3RUb09yaWdpbmFsU3RhdGU6IHJlc3RvcmVTdHJhdGVneVxuICAgICAgfSk7XG5cbiAgICAgIGRlc2NyaXB0b3JbYWNjZXNzVHlwZV0gPSBzcHk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3BlcnR5TmFtZSwgZGVzY3JpcHRvcik7XG5cbiAgICAgIHJldHVybiBzcHk7XG4gICAgfTtcblxuICAgIHRoaXMuc3B5T25BbGxGdW5jdGlvbnMgPSBmdW5jdGlvbihvYmosIGluY2x1ZGVOb25FbnVtZXJhYmxlKSB7XG4gICAgICBpZiAoaiQudXRpbC5pc1VuZGVmaW5lZChvYmopKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnc3B5T25BbGxGdW5jdGlvbnMgY291bGQgbm90IGZpbmQgYW4gb2JqZWN0IHRvIHNweSB1cG9uJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9pbnRlciA9IG9iaixcbiAgICAgICAgcHJvcHNUb1NweU9uID0gW10sXG4gICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgIHByb3BlcnRpZXNUb1NraXAgPSBbXTtcblxuICAgICAgd2hpbGUgKFxuICAgICAgICBwb2ludGVyICYmXG4gICAgICAgICghaW5jbHVkZU5vbkVudW1lcmFibGUgfHwgcG9pbnRlciAhPT0gT2JqZWN0LnByb3RvdHlwZSlcbiAgICAgICkge1xuICAgICAgICBwcm9wZXJ0aWVzID0gZ2V0UHJvcHMocG9pbnRlciwgaW5jbHVkZU5vbkVudW1lcmFibGUpO1xuICAgICAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcy5maWx0ZXIoZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgIHJldHVybiBwcm9wZXJ0aWVzVG9Ta2lwLmluZGV4T2YocHJvcCkgPT09IC0xO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJvcGVydGllc1RvU2tpcCA9IHByb3BlcnRpZXNUb1NraXAuY29uY2F0KHByb3BlcnRpZXMpO1xuICAgICAgICBwcm9wc1RvU3B5T24gPSBwcm9wc1RvU3B5T24uY29uY2F0KFxuICAgICAgICAgIGdldFNweWFibGVGdW5jdGlvblByb3BzKHBvaW50ZXIsIHByb3BlcnRpZXMpXG4gICAgICAgICk7XG4gICAgICAgIHBvaW50ZXIgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocG9pbnRlcik7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHNUb1NweU9uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuc3B5T24ob2JqLCBwcm9wc1RvU3B5T25baV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG5cbiAgICB0aGlzLmNsZWFyU3BpZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzcGllcyA9IGN1cnJlbnRTcGllcygpO1xuICAgICAgZm9yICh2YXIgaSA9IHNwaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBzcHlFbnRyeSA9IHNwaWVzW2ldO1xuICAgICAgICBzcHlFbnRyeS5yZXN0b3JlT2JqZWN0VG9PcmlnaW5hbFN0YXRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFByb3BzKG9iaiwgaW5jbHVkZU5vbkVudW1lcmFibGUpIHtcbiAgICB2YXIgZW51bWVyYWJsZVByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhvYmopO1xuXG4gICAgaWYgKCFpbmNsdWRlTm9uRW51bWVyYWJsZSkge1xuICAgICAgcmV0dXJuIGVudW1lcmFibGVQcm9wZXJ0aWVzO1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmZpbHRlcihmdW5jdGlvbihwcm9wKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBwcm9wICE9PSAnY29uc3RydWN0b3InIHx8XG4gICAgICAgIGVudW1lcmFibGVQcm9wZXJ0aWVzLmluZGV4T2YoJ2NvbnN0cnVjdG9yJykgPiAtMVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNweWFibGVGdW5jdGlvblByb3BzKG9iaiwgcHJvcGVydGllc1RvQ2hlY2spIHtcbiAgICB2YXIgcHJvcHMgPSBbXSxcbiAgICAgIHByb3A7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzVG9DaGVjay5sZW5ndGg7IGkrKykge1xuICAgICAgcHJvcCA9IHByb3BlcnRpZXNUb0NoZWNrW2ldO1xuICAgICAgaWYgKFxuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSAmJlxuICAgICAgICBpc1NweWFibGVQcm9wKG9iaiwgcHJvcClcbiAgICAgICkge1xuICAgICAgICBwcm9wcy5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBpc1NweWFibGVQcm9wKG9iaiwgcHJvcCkge1xuICAgIHZhciB2YWx1ZSwgZGVzY3JpcHRvcjtcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSBvYmpbcHJvcF07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBwcm9wKTtcbiAgICAgIHJldHVybiAoZGVzY3JpcHRvci53cml0YWJsZSB8fCBkZXNjcmlwdG9yLnNldCkgJiYgZGVzY3JpcHRvci5jb25maWd1cmFibGU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBTcHlSZWdpc3RyeTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuU3B5U3RyYXRlZ3kgPSBmdW5jdGlvbihqJCkge1xuICAvKipcbiAgICogQGludGVyZmFjZSBTcHlTdHJhdGVneVxuICAgKi9cbiAgZnVuY3Rpb24gU3B5U3RyYXRlZ3kob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpZGVudGlmeWluZyBpbmZvcm1hdGlvbiBmb3IgdGhlIHNweS5cbiAgICAgKiBAbmFtZSBTcHlTdHJhdGVneSNpZGVudGl0eVxuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBtZW1iZXJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuaWRlbnRpdHkgPSBvcHRpb25zLm5hbWUgfHwgJ3Vua25vd24nO1xuICAgIHRoaXMub3JpZ2luYWxGbiA9IG9wdGlvbnMuZm4gfHwgZnVuY3Rpb24oKSB7fTtcbiAgICB0aGlzLmdldFNweSA9IG9wdGlvbnMuZ2V0U3B5IHx8IGZ1bmN0aW9uKCkge307XG4gICAgdGhpcy5wbGFuID0gdGhpcy5fZGVmYXVsdFBsYW4gPSBmdW5jdGlvbigpIHt9O1xuXG4gICAgdmFyIGssXG4gICAgICBjcyA9IG9wdGlvbnMuY3VzdG9tU3RyYXRlZ2llcyB8fCB7fTtcbiAgICBmb3IgKGsgaW4gY3MpIHtcbiAgICAgIGlmIChqJC51dGlsLmhhcyhjcywgaykgJiYgIXRoaXNba10pIHtcbiAgICAgICAgdGhpc1trXSA9IGNyZWF0ZUN1c3RvbVBsYW4oY3Nba10pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlbGwgdGhlIHNweSB0byByZXR1cm4gYSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgc3BlY2lmaWVkIHZhbHVlIHdoZW4gaW52b2tlZC5cbiAgICAgKiBAbmFtZSBTcHlTdHJhdGVneSNyZXNvbHZlVG9cbiAgICAgKiBAc2luY2UgMy41LjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4uXG4gICAgICovXG4gICAgdGhpcy5yZXNvbHZlVG8gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgc2VsZi5wbGFuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBzZWxmLmdldFNweSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZWxsIHRoZSBzcHkgdG8gcmV0dXJuIGEgcHJvbWlzZSByZWplY3Rpbmcgd2l0aCB0aGUgc3BlY2lmaWVkIHZhbHVlIHdoZW4gaW52b2tlZC5cbiAgICAgKiBAbmFtZSBTcHlTdHJhdGVneSNyZWplY3RXaXRoXG4gICAgICogQHNpbmNlIDMuNS4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuLlxuICAgICAqL1xuICAgIHRoaXMucmVqZWN0V2l0aCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBzZWxmLnBsYW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHZhbHVlKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gc2VsZi5nZXRTcHkoKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ3VzdG9tUGxhbihmYWN0b3J5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBsYW4gPSBmYWN0b3J5LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cbiAgICAgIGlmICghaiQuaXNGdW5jdGlvbl8ocGxhbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTcHkgc3RyYXRlZ3kgbXVzdCByZXR1cm4gYSBmdW5jdGlvbicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBsYW4gPSBwbGFuO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0U3B5KCk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIHRoZSBjdXJyZW50IHNweSBzdHJhdGVneS5cbiAgICogQG5hbWUgU3B5U3RyYXRlZ3kjZXhlY1xuICAgKiBAc2luY2UgMi4wLjBcbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBTcHlTdHJhdGVneS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MsIGludm9rZU5ldykge1xuICAgIHZhciBjb250ZXh0QXJncyA9IFtjb250ZXh0XS5jb25jYXQoXG4gICAgICBhcmdzID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykgOiBbXVxuICAgICk7XG4gICAgdmFyIHRhcmdldCA9IHRoaXMucGxhbi5iaW5kLmFwcGx5KHRoaXMucGxhbiwgY29udGV4dEFyZ3MpO1xuXG4gICAgcmV0dXJuIGludm9rZU5ldyA/IG5ldyB0YXJnZXQoKSA6IHRhcmdldCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZWxsIHRoZSBzcHkgdG8gY2FsbCB0aHJvdWdoIHRvIHRoZSByZWFsIGltcGxlbWVudGF0aW9uIHdoZW4gaW52b2tlZC5cbiAgICogQG5hbWUgU3B5U3RyYXRlZ3kjY2FsbFRocm91Z2hcbiAgICogQHNpbmNlIDIuMC4wXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgU3B5U3RyYXRlZ3kucHJvdG90eXBlLmNhbGxUaHJvdWdoID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5wbGFuID0gdGhpcy5vcmlnaW5hbEZuO1xuICAgIHJldHVybiB0aGlzLmdldFNweSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZWxsIHRoZSBzcHkgdG8gcmV0dXJuIHRoZSB2YWx1ZSB3aGVuIGludm9rZWQuXG4gICAqIEBuYW1lIFNweVN0cmF0ZWd5I3JldHVyblZhbHVlXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuLlxuICAgKi9cbiAgU3B5U3RyYXRlZ3kucHJvdG90eXBlLnJldHVyblZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB0aGlzLnBsYW4gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmdldFNweSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZWxsIHRoZSBzcHkgdG8gcmV0dXJuIG9uZSBvZiB0aGUgc3BlY2lmaWVkIHZhbHVlcyAoc2VxdWVudGlhbGx5KSBlYWNoIHRpbWUgdGhlIHNweSBpcyBpbnZva2VkLlxuICAgKiBAbmFtZSBTcHlTdHJhdGVneSNyZXR1cm5WYWx1ZXNcbiAgICogQHNpbmNlIDIuMS4wXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0gey4uLip9IHZhbHVlcyAtIFZhbHVlcyB0byBiZSByZXR1cm5lZCBvbiBzdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSBzcHkuXG4gICAqL1xuICBTcHlTdHJhdGVneS5wcm90b3R5cGUucmV0dXJuVmFsdWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdGhpcy5wbGFuID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWVzLnNoaWZ0KCk7XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5nZXRTcHkoKTtcbiAgfTtcblxuICAvKipcbiAgICogVGVsbCB0aGUgc3B5IHRvIHRocm93IGFuIGVycm9yIHdoZW4gaW52b2tlZC5cbiAgICogQG5hbWUgU3B5U3RyYXRlZ3kjdGhyb3dFcnJvclxuICAgKiBAc2luY2UgMi4wLjBcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RXJyb3J8T2JqZWN0fFN0cmluZ30gc29tZXRoaW5nIFRoaW5nIHRvIHRocm93XG4gICAqL1xuICBTcHlTdHJhdGVneS5wcm90b3R5cGUudGhyb3dFcnJvciA9IGZ1bmN0aW9uKHNvbWV0aGluZykge1xuICAgIHZhciBlcnJvciA9IGokLmlzU3RyaW5nXyhzb21ldGhpbmcpID8gbmV3IEVycm9yKHNvbWV0aGluZykgOiBzb21ldGhpbmc7XG4gICAgdGhpcy5wbGFuID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmdldFNweSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZWxsIHRoZSBzcHkgdG8gY2FsbCBhIGZha2UgaW1wbGVtZW50YXRpb24gd2hlbiBpbnZva2VkLlxuICAgKiBAbmFtZSBTcHlTdHJhdGVneSNjYWxsRmFrZVxuICAgKiBAc2luY2UgMi4wLjBcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBpbnZva2Ugd2l0aCB0aGUgcGFzc2VkIHBhcmFtZXRlcnMuXG4gICAqL1xuICBTcHlTdHJhdGVneS5wcm90b3R5cGUuY2FsbEZha2UgPSBmdW5jdGlvbihmbikge1xuICAgIGlmIChcbiAgICAgICEoXG4gICAgICAgIGokLmlzRnVuY3Rpb25fKGZuKSB8fFxuICAgICAgICBqJC5pc0FzeW5jRnVuY3Rpb25fKGZuKSB8fFxuICAgICAgICBqJC5pc0dlbmVyYXRvckZ1bmN0aW9uXyhmbilcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0FyZ3VtZW50IHBhc3NlZCB0byBjYWxsRmFrZSBzaG91bGQgYmUgYSBmdW5jdGlvbiwgZ290ICcgKyBmblxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5wbGFuID0gZm47XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3B5KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRlbGwgdGhlIHNweSB0byBkbyBub3RoaW5nIHdoZW4gaW52b2tlZC4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cbiAgICogQG5hbWUgU3B5U3RyYXRlZ3kjc3R1YlxuICAgKiBAc2luY2UgMi4wLjBcbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBTcHlTdHJhdGVneS5wcm90b3R5cGUuc3R1YiA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgdGhpcy5wbGFuID0gZnVuY3Rpb24oKSB7fTtcbiAgICByZXR1cm4gdGhpcy5nZXRTcHkoKTtcbiAgfTtcblxuICBTcHlTdHJhdGVneS5wcm90b3R5cGUuaXNDb25maWd1cmVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGxhbiAhPT0gdGhpcy5fZGVmYXVsdFBsYW47XG4gIH07XG5cbiAgcmV0dXJuIFNweVN0cmF0ZWd5O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5TdGFja1RyYWNlID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gU3RhY2tUcmFjZShlcnJvcikge1xuICAgIHZhciBsaW5lcyA9IGVycm9yLnN0YWNrLnNwbGl0KCdcXG4nKS5maWx0ZXIoZnVuY3Rpb24obGluZSkge1xuICAgICAgcmV0dXJuIGxpbmUgIT09ICcnO1xuICAgIH0pO1xuXG4gICAgdmFyIGV4dHJhY3RSZXN1bHQgPSBleHRyYWN0TWVzc2FnZShlcnJvci5tZXNzYWdlLCBsaW5lcyk7XG5cbiAgICBpZiAoZXh0cmFjdFJlc3VsdCkge1xuICAgICAgdGhpcy5tZXNzYWdlID0gZXh0cmFjdFJlc3VsdC5tZXNzYWdlO1xuICAgICAgbGluZXMgPSBleHRyYWN0UmVzdWx0LnJlbWFpbmRlcjtcbiAgICB9XG5cbiAgICB2YXIgcGFyc2VSZXN1bHQgPSB0cnlQYXJzZUZyYW1lcyhsaW5lcyk7XG4gICAgdGhpcy5mcmFtZXMgPSBwYXJzZVJlc3VsdC5mcmFtZXM7XG4gICAgdGhpcy5zdHlsZSA9IHBhcnNlUmVzdWx0LnN0eWxlO1xuICB9XG5cbiAgdmFyIGZyYW1lUGF0dGVybnMgPSBbXG4gICAgLy8gTm9kZSwgQ2hyb21lLCBFZGdlXG4gICAgLy8gZS5nLiBcIiAgIGF0IFF1ZXVlUnVubmVyLnJ1biAoaHR0cDovL2xvY2FsaG9zdDo4ODg4L19famFzbWluZV9fL2phc21pbmUuanM6NDMyMDoyMClcIlxuICAgIC8vIE5vdGUgdGhhdCB0aGUgXCJmdW5jdGlvbiBuYW1lXCIgY2FuIGluY2x1ZGUgYSBzdXJwcmlzaW5nbHkgbGFyZ2Ugc2V0IG9mXG4gICAgLy8gY2hhcmFjdGVycywgaW5jbHVkaW5nIGFuZ2xlIGJyYWNrZXRzIGFuZCBzcXVhcmUgYnJhY2tldHMuXG4gICAge1xuICAgICAgcmU6IC9eXFxzKmF0IChbXlxcKV0rKSBcXCgoW15cXCldKylcXCkkLyxcbiAgICAgIGZuSXg6IDEsXG4gICAgICBmaWxlTGluZUNvbEl4OiAyLFxuICAgICAgc3R5bGU6ICd2OCdcbiAgICB9LFxuXG4gICAgLy8gTm9kZUpTIGFsdGVybmF0ZSBmb3JtLCBvZnRlbiBtaXhlZCBpbiB3aXRoIHRoZSBDaHJvbWUgc3R5bGVcbiAgICAvLyBlLmcuIFwiICBhdCAvc29tZS9wYXRoOjQzMjA6MjBcbiAgICB7IHJlOiAvXFxzKmF0ICguKykkLywgZmlsZUxpbmVDb2xJeDogMSwgc3R5bGU6ICd2OCcgfSxcblxuICAgIC8vIFBoYW50b21KUyBvbiBPUyBYLCBTYWZhcmksIEZpcmVmb3hcbiAgICAvLyBlLmcuIFwicnVuQGh0dHA6Ly9sb2NhbGhvc3Q6ODg4OC9fX2phc21pbmVfXy9qYXNtaW5lLmpzOjQzMjA6MjdcIlxuICAgIC8vIG9yIFwiaHR0cDovL2xvY2FsaG9zdDo4ODg4L19famFzbWluZV9fL2phc21pbmUuanM6NDMyMDoyN1wiXG4gICAge1xuICAgICAgcmU6IC9eKD86KChbXkBcXHNdKylAKXxAKT8oW15cXHNdKykkLyxcbiAgICAgIGZuSXg6IDIsXG4gICAgICBmaWxlTGluZUNvbEl4OiAzLFxuICAgICAgc3R5bGU6ICd3ZWJraXQnXG4gICAgfVxuICBdO1xuXG4gIC8vIHJlZ2V4ZXMgc2hvdWxkIGNhcHR1cmUgdGhlIGZ1bmN0aW9uIG5hbWUgKGlmIGFueSkgYXMgZ3JvdXAgMVxuICAvLyBhbmQgdGhlIGZpbGUsIGxpbmUsIGFuZCBjb2x1bW4gYXMgZ3JvdXAgMi5cbiAgZnVuY3Rpb24gdHJ5UGFyc2VGcmFtZXMobGluZXMpIHtcbiAgICB2YXIgc3R5bGUgPSBudWxsO1xuICAgIHZhciBmcmFtZXMgPSBsaW5lcy5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIGNvbnZlcnRlZExpbmUgPSBmaXJzdChmcmFtZVBhdHRlcm5zLCBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gICAgICAgIHZhciBvdmVyYWxsTWF0Y2ggPSBsaW5lLm1hdGNoKHBhdHRlcm4ucmUpLFxuICAgICAgICAgIGZpbGVMaW5lQ29sTWF0Y2g7XG4gICAgICAgIGlmICghb3ZlcmFsbE1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmaWxlTGluZUNvbE1hdGNoID0gb3ZlcmFsbE1hdGNoW3BhdHRlcm4uZmlsZUxpbmVDb2xJeF0ubWF0Y2goXG4gICAgICAgICAgL14oLiopOihcXGQrKTpcXGQrJC9cbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFmaWxlTGluZUNvbE1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBzdHlsZSA9IHN0eWxlIHx8IHBhdHRlcm4uc3R5bGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmF3OiBsaW5lLFxuICAgICAgICAgIGZpbGU6IGZpbGVMaW5lQ29sTWF0Y2hbMV0sXG4gICAgICAgICAgbGluZTogcGFyc2VJbnQoZmlsZUxpbmVDb2xNYXRjaFsyXSwgMTApLFxuICAgICAgICAgIGZ1bmM6IG92ZXJhbGxNYXRjaFtwYXR0ZXJuLmZuSXhdXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGNvbnZlcnRlZExpbmUgfHwgeyByYXc6IGxpbmUgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBzdHlsZTogc3R5bGUsXG4gICAgICBmcmFtZXM6IGZyYW1lc1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBmaXJzdChpdGVtcywgZm4pIHtcbiAgICB2YXIgaSwgcmVzdWx0O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHQgPSBmbihpdGVtc1tpXSk7XG5cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0TWVzc2FnZShtZXNzYWdlLCBzdGFja0xpbmVzKSB7XG4gICAgdmFyIGxlbiA9IG1lc3NhZ2VQcmVmaXhMZW5ndGgobWVzc2FnZSwgc3RhY2tMaW5lcyk7XG5cbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWVzc2FnZTogc3RhY2tMaW5lcy5zbGljZSgwLCBsZW4pLmpvaW4oJ1xcbicpLFxuICAgICAgICByZW1haW5kZXI6IHN0YWNrTGluZXMuc2xpY2UobGVuKVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtZXNzYWdlUHJlZml4TGVuZ3RoKG1lc3NhZ2UsIHN0YWNrTGluZXMpIHtcbiAgICBpZiAoIXN0YWNrTGluZXNbMF0ubWF0Y2goL15cXHcqRXJyb3IvKSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIG1lc3NhZ2VMaW5lcyA9IG1lc3NhZ2Uuc3BsaXQoJ1xcbicpO1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMTsgaSA8IG1lc3NhZ2VMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG1lc3NhZ2VMaW5lc1tpXSAhPT0gc3RhY2tMaW5lc1tpXSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWVzc2FnZUxpbmVzLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBTdGFja1RyYWNlO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5TdWl0ZSA9IGZ1bmN0aW9uKGokKSB7XG4gIC8qKlxuICAgKiBAaW50ZXJmYWNlIFN1aXRlXG4gICAqIEBzZWUgRW52I3RvcFN1aXRlXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKi9cbiAgZnVuY3Rpb24gU3VpdGUoYXR0cnMpIHtcbiAgICB0aGlzLmVudiA9IGF0dHJzLmVudjtcbiAgICAvKipcbiAgICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoaXMgc3VpdGUuXG4gICAgICogQG5hbWUgU3VpdGUjaWRcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBhdHRycy5pZDtcbiAgICB0aGlzLnBhcmVudFN1aXRlID0gYXR0cnMucGFyZW50U3VpdGU7XG4gICAgLyoqXG4gICAgICogVGhlIGRlc2NyaXB0aW9uIHBhc3NlZCB0byB0aGUge0BsaW5rIGRlc2NyaWJlfSB0aGF0IGNyZWF0ZWQgdGhpcyBzdWl0ZS5cbiAgICAgKiBAbmFtZSBTdWl0ZSNkZXNjcmlwdGlvblxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICovXG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IGF0dHJzLmRlc2NyaXB0aW9uO1xuICAgIHRoaXMuZXhwZWN0YXRpb25GYWN0b3J5ID0gYXR0cnMuZXhwZWN0YXRpb25GYWN0b3J5O1xuICAgIHRoaXMuYXN5bmNFeHBlY3RhdGlvbkZhY3RvcnkgPSBhdHRycy5hc3luY0V4cGVjdGF0aW9uRmFjdG9yeTtcbiAgICB0aGlzLmV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeSA9IGF0dHJzLmV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeTtcbiAgICB0aGlzLnRocm93T25FeHBlY3RhdGlvbkZhaWx1cmUgPSAhIWF0dHJzLnRocm93T25FeHBlY3RhdGlvbkZhaWx1cmU7XG4gICAgdGhpcy5hdXRvQ2xlYW5DbG9zdXJlcyA9XG4gICAgICBhdHRycy5hdXRvQ2xlYW5DbG9zdXJlcyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICEhYXR0cnMuYXV0b0NsZWFuQ2xvc3VyZXM7XG4gICAgdGhpcy5vbkxhdGVFcnJvciA9IGF0dHJzLm9uTGF0ZUVycm9yO1xuXG4gICAgdGhpcy5iZWZvcmVGbnMgPSBbXTtcbiAgICB0aGlzLmFmdGVyRm5zID0gW107XG4gICAgdGhpcy5iZWZvcmVBbGxGbnMgPSBbXTtcbiAgICB0aGlzLmFmdGVyQWxsRm5zID0gW107XG4gICAgdGhpcy50aW1lciA9IGF0dHJzLnRpbWVyIHx8IG5ldyBqJC5UaW1lcigpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHN1aXRlJ3MgY2hpbGRyZW4uXG4gICAgICogQG5hbWUgU3VpdGUjY2hpbGRyZW5cbiAgICAgKiBAdHlwZSB7QXJyYXkuPChTcGVjfFN1aXRlKT59XG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICovXG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuXG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG5cbiAgU3VpdGUucHJvdG90eXBlLnNldFN1aXRlUHJvcGVydHkgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5yZXN1bHQucHJvcGVydGllcyA9IHRoaXMucmVzdWx0LnByb3BlcnRpZXMgfHwge307XG4gICAgdGhpcy5yZXN1bHQucHJvcGVydGllc1trZXldID0gdmFsdWU7XG4gIH07XG5cbiAgU3VpdGUucHJvdG90eXBlLmV4cGVjdCA9IGZ1bmN0aW9uKGFjdHVhbCkge1xuICAgIHJldHVybiB0aGlzLmV4cGVjdGF0aW9uRmFjdG9yeShhY3R1YWwsIHRoaXMpO1xuICB9O1xuXG4gIFN1aXRlLnByb3RvdHlwZS5leHBlY3RBc3luYyA9IGZ1bmN0aW9uKGFjdHVhbCkge1xuICAgIHJldHVybiB0aGlzLmFzeW5jRXhwZWN0YXRpb25GYWN0b3J5KGFjdHVhbCwgdGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBmdWxsIGRlc2NyaXB0aW9uIGluY2x1ZGluZyBhbGwgYW5jZXN0b3JzIG9mIHRoaXMgc3VpdGUuXG4gICAqIEBuYW1lIFN1aXRlI2dldEZ1bGxOYW1lXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAc2luY2UgMi4wLjBcbiAgICovXG4gIFN1aXRlLnByb3RvdHlwZS5nZXRGdWxsTmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmdWxsTmFtZSA9IFtdO1xuICAgIGZvciAoXG4gICAgICB2YXIgcGFyZW50U3VpdGUgPSB0aGlzO1xuICAgICAgcGFyZW50U3VpdGU7XG4gICAgICBwYXJlbnRTdWl0ZSA9IHBhcmVudFN1aXRlLnBhcmVudFN1aXRlXG4gICAgKSB7XG4gICAgICBpZiAocGFyZW50U3VpdGUucGFyZW50U3VpdGUpIHtcbiAgICAgICAgZnVsbE5hbWUudW5zaGlmdChwYXJlbnRTdWl0ZS5kZXNjcmlwdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmdWxsTmFtZS5qb2luKCcgJyk7XG4gIH07XG5cbiAgLypcbiAgICogTWFyayB0aGUgc3VpdGUgd2l0aCBcInBlbmRpbmdcIiBzdGF0dXNcbiAgICovXG4gIFN1aXRlLnByb3RvdHlwZS5wZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tYXJrZWRQZW5kaW5nID0gdHJ1ZTtcbiAgfTtcblxuICAvKlxuICAgKiBMaWtlIHtAbGluayBTdWl0ZSNwZW5kfSwgYnV0IHBlbmRpbmcgc3RhdGUgd2lsbCBzdXJ2aXZlIHtAbGluayBTcGVjI3Jlc2V0fVxuICAgKiBVc2VmdWwgZm9yIGZkZXNjcmliZSwgeGRlc2NyaWJlLCB3aGVyZSBwZW5kaW5nIHN0YXRlIHNob3VsZCByZW1haW4uXG4gICAqL1xuICBTdWl0ZS5wcm90b3R5cGUuZXhjbHVkZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucGVuZCgpO1xuICAgIHRoaXMubWFya2VkRXhjbHVkaW5nID0gdHJ1ZTtcbiAgfTtcblxuICBTdWl0ZS5wcm90b3R5cGUuYmVmb3JlRWFjaCA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgdGhpcy5iZWZvcmVGbnMudW5zaGlmdCh7IC4uLmZuLCBzdWl0ZTogdGhpcyB9KTtcbiAgfTtcblxuICBTdWl0ZS5wcm90b3R5cGUuYmVmb3JlQWxsID0gZnVuY3Rpb24oZm4pIHtcbiAgICB0aGlzLmJlZm9yZUFsbEZucy5wdXNoKHsgLi4uZm4sIHR5cGU6ICdiZWZvcmVBbGwnLCBzdWl0ZTogdGhpcyB9KTtcbiAgfTtcblxuICBTdWl0ZS5wcm90b3R5cGUuYWZ0ZXJFYWNoID0gZnVuY3Rpb24oZm4pIHtcbiAgICB0aGlzLmFmdGVyRm5zLnVuc2hpZnQoeyAuLi5mbiwgc3VpdGU6IHRoaXMsIHR5cGU6ICdhZnRlckVhY2gnIH0pO1xuICB9O1xuXG4gIFN1aXRlLnByb3RvdHlwZS5hZnRlckFsbCA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgdGhpcy5hZnRlckFsbEZucy51bnNoaWZ0KHsgLi4uZm4sIHR5cGU6ICdhZnRlckFsbCcgfSk7XG4gIH07XG5cbiAgU3VpdGUucHJvdG90eXBlLnN0YXJ0VGltZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRpbWVyLnN0YXJ0KCk7XG4gIH07XG5cbiAgU3VpdGUucHJvdG90eXBlLmVuZFRpbWVyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZXN1bHQuZHVyYXRpb24gPSB0aGlzLnRpbWVyLmVsYXBzZWQoKTtcbiAgfTtcblxuICBmdW5jdGlvbiByZW1vdmVGbnMocXVldWVhYmxlRm5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZWFibGVGbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHF1ZXVlYWJsZUZuc1tpXS5mbiA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgU3VpdGUucHJvdG90eXBlLmNsZWFudXBCZWZvcmVBZnRlciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmF1dG9DbGVhbkNsb3N1cmVzKSB7XG4gICAgICByZW1vdmVGbnModGhpcy5iZWZvcmVBbGxGbnMpO1xuICAgICAgcmVtb3ZlRm5zKHRoaXMuYWZ0ZXJBbGxGbnMpO1xuICAgICAgcmVtb3ZlRm5zKHRoaXMuYmVmb3JlRm5zKTtcbiAgICAgIHJlbW92ZUZucyh0aGlzLmFmdGVyRm5zKTtcbiAgICB9XG4gIH07XG5cbiAgU3VpdGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYgU3VpdGVSZXN1bHRcbiAgICAgKiBAcHJvcGVydHkge0ludH0gaWQgLSBUaGUgdW5pcXVlIGlkIG9mIHRoaXMgc3VpdGUuXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IGRlc2NyaXB0aW9uIC0gVGhlIGRlc2NyaXB0aW9uIHRleHQgcGFzc2VkIHRvIHRoZSB7QGxpbmsgZGVzY3JpYmV9IHRoYXQgbWFkZSB0aGlzIHN1aXRlLlxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBmdWxsTmFtZSAtIFRoZSBmdWxsIGRlc2NyaXB0aW9uIGluY2x1ZGluZyBhbGwgYW5jZXN0b3JzIG9mIHRoaXMgc3VpdGUuXG4gICAgICogQHByb3BlcnR5IHtFeHBlY3RhdGlvbltdfSBmYWlsZWRFeHBlY3RhdGlvbnMgLSBUaGUgbGlzdCBvZiBleHBlY3RhdGlvbnMgdGhhdCBmYWlsZWQgaW4gYW4ge0BsaW5rIGFmdGVyQWxsfSBmb3IgdGhpcyBzdWl0ZS5cbiAgICAgKiBAcHJvcGVydHkge0V4cGVjdGF0aW9uW119IGRlcHJlY2F0aW9uV2FybmluZ3MgLSBUaGUgbGlzdCBvZiBkZXByZWNhdGlvbiB3YXJuaW5ncyB0aGF0IG9jY3VycmVkIG9uIHRoaXMgc3VpdGUuXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IHN0YXR1cyAtIE9uY2UgdGhlIHN1aXRlIGhhcyBjb21wbGV0ZWQsIHRoaXMgc3RyaW5nIHJlcHJlc2VudHMgdGhlIHBhc3MvZmFpbCBzdGF0dXMgb2YgdGhpcyBzdWl0ZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZHVyYXRpb24gLSBUaGUgdGltZSBpbiBtcyBmb3IgU3VpdGUgZXhlY3V0aW9uLCBpbmNsdWRpbmcgYW55IGJlZm9yZS9hZnRlckFsbCwgYmVmb3JlL2FmdGVyRWFjaC5cbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gcHJvcGVydGllcyAtIFVzZXItc3VwcGxpZWQgcHJvcGVydGllcywgaWYgYW55LCB0aGF0IHdlcmUgc2V0IHVzaW5nIHtAbGluayBFbnYjc2V0U3VpdGVQcm9wZXJ0eX1cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKi9cbiAgICB0aGlzLnJlc3VsdCA9IHtcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICBmdWxsTmFtZTogdGhpcy5nZXRGdWxsTmFtZSgpLFxuICAgICAgZmFpbGVkRXhwZWN0YXRpb25zOiBbXSxcbiAgICAgIGRlcHJlY2F0aW9uV2FybmluZ3M6IFtdLFxuICAgICAgZHVyYXRpb246IG51bGwsXG4gICAgICBwcm9wZXJ0aWVzOiBudWxsXG4gICAgfTtcbiAgICB0aGlzLm1hcmtlZFBlbmRpbmcgPSB0aGlzLm1hcmtlZEV4Y2x1ZGluZztcbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIGNoaWxkLnJlc2V0KCk7XG4gICAgfSk7XG4gIH07XG5cbiAgU3VpdGUucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24oY2hpbGQpIHtcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICB9O1xuXG4gIFN1aXRlLnByb3RvdHlwZS5zdGF0dXMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5tYXJrZWRQZW5kaW5nKSB7XG4gICAgICByZXR1cm4gJ3BlbmRpbmcnO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuICdmYWlsZWQnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ3Bhc3NlZCc7XG4gICAgfVxuICB9O1xuXG4gIFN1aXRlLnByb3RvdHlwZS5jYW5CZVJlZW50ZXJlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmJlZm9yZUFsbEZucy5sZW5ndGggPT09IDAgJiYgdGhpcy5hZnRlckFsbEZucy5sZW5ndGggPT09IDA7XG4gIH07XG5cbiAgU3VpdGUucHJvdG90eXBlLmdldFJlc3VsdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVzdWx0LnN0YXR1cyA9IHRoaXMuc3RhdHVzKCk7XG4gICAgcmV0dXJuIHRoaXMucmVzdWx0O1xuICB9O1xuXG4gIFN1aXRlLnByb3RvdHlwZS5zaGFyZWRVc2VyQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5zaGFyZWRDb250ZXh0KSB7XG4gICAgICB0aGlzLnNoYXJlZENvbnRleHQgPSB0aGlzLnBhcmVudFN1aXRlXG4gICAgICAgID8gdGhpcy5wYXJlbnRTdWl0ZS5jbG9uZWRTaGFyZWRVc2VyQ29udGV4dCgpXG4gICAgICAgIDogbmV3IGokLlVzZXJDb250ZXh0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2hhcmVkQ29udGV4dDtcbiAgfTtcblxuICBTdWl0ZS5wcm90b3R5cGUuY2xvbmVkU2hhcmVkVXNlckNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaiQuVXNlckNvbnRleHQuZnJvbUV4aXN0aW5nKHRoaXMuc2hhcmVkVXNlckNvbnRleHQoKSk7XG4gIH07XG5cbiAgU3VpdGUucHJvdG90eXBlLm9uRXhjZXB0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIGokLmVycm9ycy5FeHBlY3RhdGlvbkZhaWxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0ge1xuICAgICAgbWF0Y2hlck5hbWU6ICcnLFxuICAgICAgcGFzc2VkOiBmYWxzZSxcbiAgICAgIGV4cGVjdGVkOiAnJyxcbiAgICAgIGFjdHVhbDogJycsXG4gICAgICBlcnJvcjogYXJndW1lbnRzWzBdXG4gICAgfTtcbiAgICB2YXIgZmFpbGVkRXhwZWN0YXRpb24gPSB0aGlzLmV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeShkYXRhKTtcblxuICAgIGlmICghdGhpcy5wYXJlbnRTdWl0ZSkge1xuICAgICAgZmFpbGVkRXhwZWN0YXRpb24uZ2xvYmFsRXJyb3JUeXBlID0gJ2FmdGVyQWxsJztcbiAgICB9XG5cbiAgICB0aGlzLnJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMucHVzaChmYWlsZWRFeHBlY3RhdGlvbik7XG4gIH07XG5cbiAgU3VpdGUucHJvdG90eXBlLm9uTXVsdGlwbGVEb25lID0gZnVuY3Rpb24oKSB7XG4gICAgbGV0IG1zZztcblxuICAgIC8vIElzc3VlIGEgZGVwcmVjYXRpb24uIEluY2x1ZGUgdGhlIGNvbnRleHQgb3Vyc2VsdmVzIGFuZCBwYXNzXG4gICAgLy8gaWdub3JlUnVubmFibGU6IHRydWUsIHNpbmNlIGdldHRpbmcgaGVyZSBhbHdheXMgbWVhbnMgdGhhdCB3ZSd2ZSBhbHJlYWR5XG4gICAgLy8gbW92ZWQgb24gYW5kIHRoZSBjdXJyZW50IHJ1bm5hYmxlIGlzbid0IHRoZSBvbmUgdGhhdCBjYXVzZWQgdGhlIHByb2JsZW0uXG4gICAgaWYgKHRoaXMucGFyZW50U3VpdGUpIHtcbiAgICAgIG1zZyA9XG4gICAgICAgIFwiQW4gYXN5bmNocm9ub3VzIGJlZm9yZUFsbCBvciBhZnRlckFsbCBmdW5jdGlvbiBjYWxsZWQgaXRzICdkb25lJyBcIiArXG4gICAgICAgICdjYWxsYmFjayBtb3JlIHRoYW4gb25jZS5cXG4nICtcbiAgICAgICAgJyhpbiBzdWl0ZTogJyArXG4gICAgICAgIHRoaXMuZ2V0RnVsbE5hbWUoKSArXG4gICAgICAgICcpJztcbiAgICB9IGVsc2Uge1xuICAgICAgbXNnID1cbiAgICAgICAgJ0EgdG9wLWxldmVsIGJlZm9yZUFsbCBvciBhZnRlckFsbCBmdW5jdGlvbiBjYWxsZWQgaXRzICcgK1xuICAgICAgICBcIidkb25lJyBjYWxsYmFjayBtb3JlIHRoYW4gb25jZS5cIjtcbiAgICB9XG5cbiAgICB0aGlzLm9uTGF0ZUVycm9yKG5ldyBFcnJvcihtc2cpKTtcbiAgfTtcblxuICBTdWl0ZS5wcm90b3R5cGUuYWRkRXhwZWN0YXRpb25SZXN1bHQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoaXNGYWlsdXJlKGFyZ3VtZW50cykpIHtcbiAgICAgIHZhciBkYXRhID0gYXJndW1lbnRzWzFdO1xuICAgICAgdGhpcy5yZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zLnB1c2godGhpcy5leHBlY3RhdGlvblJlc3VsdEZhY3RvcnkoZGF0YSkpO1xuICAgICAgaWYgKHRoaXMudGhyb3dPbkV4cGVjdGF0aW9uRmFpbHVyZSkge1xuICAgICAgICB0aHJvdyBuZXcgaiQuZXJyb3JzLkV4cGVjdGF0aW9uRmFpbGVkKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFN1aXRlLnByb3RvdHlwZS5hZGREZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbihkZXByZWNhdGlvbikge1xuICAgIGlmICh0eXBlb2YgZGVwcmVjYXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICBkZXByZWNhdGlvbiA9IHsgbWVzc2FnZTogZGVwcmVjYXRpb24gfTtcbiAgICB9XG4gICAgdGhpcy5yZXN1bHQuZGVwcmVjYXRpb25XYXJuaW5ncy5wdXNoKFxuICAgICAgdGhpcy5leHBlY3RhdGlvblJlc3VsdEZhY3RvcnkoZGVwcmVjYXRpb24pXG4gICAgKTtcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3VpdGUucHJvdG90eXBlLCAnbWV0YWRhdGEnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5tZXRhZGF0YV8pIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YV8gPSBuZXcgU3VpdGVNZXRhZGF0YSh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMubWV0YWRhdGFfO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEBpbnRlcmZhY2UgU3VpdGVcbiAgICogQHNlZSBFbnYjdG9wU3VpdGVcbiAgICovXG4gIGZ1bmN0aW9uIFN1aXRlTWV0YWRhdGEoc3VpdGUpIHtcbiAgICB0aGlzLnN1aXRlXyA9IHN1aXRlO1xuICAgIC8qKlxuICAgICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhpcyBzdWl0ZS5cbiAgICAgKiBAbmFtZSBTdWl0ZSNpZFxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5pZCA9IHN1aXRlLmlkO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBhcmVudCBvZiB0aGlzIHN1aXRlLCBvciBudWxsIGlmIHRoaXMgaXMgdGhlIHRvcCBzdWl0ZS5cbiAgICAgKiBAbmFtZSBTdWl0ZSNwYXJlbnRTdWl0ZVxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtTdWl0ZX1cbiAgICAgKi9cbiAgICB0aGlzLnBhcmVudFN1aXRlID0gc3VpdGUucGFyZW50U3VpdGUgPyBzdWl0ZS5wYXJlbnRTdWl0ZS5tZXRhZGF0YSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVzY3JpcHRpb24gcGFzc2VkIHRvIHRoZSB7QGxpbmsgZGVzY3JpYmV9IHRoYXQgY3JlYXRlZCB0aGlzIHN1aXRlLlxuICAgICAqIEBuYW1lIFN1aXRlI2Rlc2NyaXB0aW9uXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gc3VpdGUuZGVzY3JpcHRpb247XG4gIH1cblxuICAvKipcbiAgICogVGhlIGZ1bGwgZGVzY3JpcHRpb24gaW5jbHVkaW5nIGFsbCBhbmNlc3RvcnMgb2YgdGhpcyBzdWl0ZS5cbiAgICogQG5hbWUgU3VpdGUjZ2V0RnVsbE5hbWVcbiAgICogQGZ1bmN0aW9uXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBTdWl0ZU1ldGFkYXRhLnByb3RvdHlwZS5nZXRGdWxsTmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnN1aXRlXy5nZXRGdWxsTmFtZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgc3VpdGUncyBjaGlsZHJlbi5cbiAgICogQG5hbWUgU3VpdGUjY2hpbGRyZW5cbiAgICogQHR5cGUge0FycmF5LjwoU3BlY3xTdWl0ZSk+fVxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN1aXRlTWV0YWRhdGEucHJvdG90eXBlLCAnY2hpbGRyZW4nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnN1aXRlXy5jaGlsZHJlbi5tYXAoY2hpbGQgPT4gY2hpbGQubWV0YWRhdGEpO1xuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gaXNGYWlsdXJlKGFyZ3MpIHtcbiAgICByZXR1cm4gIWFyZ3NbMF07XG4gIH1cblxuICByZXR1cm4gU3VpdGU7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlRpbWVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkZWZhdWx0Tm93ID0gKGZ1bmN0aW9uKERhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfTtcbiAgfSkoRGF0ZSk7XG5cbiAgZnVuY3Rpb24gVGltZXIob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIG5vdyA9IG9wdGlvbnMubm93IHx8IGRlZmF1bHROb3csXG4gICAgICBzdGFydFRpbWU7XG5cbiAgICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBzdGFydFRpbWUgPSBub3coKTtcbiAgICB9O1xuXG4gICAgdGhpcy5lbGFwc2VkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbm93KCkgLSBzdGFydFRpbWU7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBUaW1lcjtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuVHJlZVByb2Nlc3NvciA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBUcmVlUHJvY2Vzc29yKGF0dHJzKSB7XG4gICAgdmFyIHRyZWUgPSBhdHRycy50cmVlLFxuICAgICAgcnVubmFibGVJZHMgPSBhdHRycy5ydW5uYWJsZUlkcyxcbiAgICAgIHF1ZXVlUnVubmVyRmFjdG9yeSA9IGF0dHJzLnF1ZXVlUnVubmVyRmFjdG9yeSxcbiAgICAgIG5vZGVTdGFydCA9IGF0dHJzLm5vZGVTdGFydCB8fCBmdW5jdGlvbigpIHt9LFxuICAgICAgbm9kZUNvbXBsZXRlID0gYXR0cnMubm9kZUNvbXBsZXRlIHx8IGZ1bmN0aW9uKCkge30sXG4gICAgICBmYWlsU3BlY1dpdGhOb0V4cGVjdGF0aW9ucyA9ICEhYXR0cnMuZmFpbFNwZWNXaXRoTm9FeHBlY3RhdGlvbnMsXG4gICAgICBvcmRlckNoaWxkcmVuID1cbiAgICAgICAgYXR0cnMub3JkZXJDaGlsZHJlbiB8fFxuICAgICAgICBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW47XG4gICAgICAgIH0sXG4gICAgICBleGNsdWRlTm9kZSA9XG4gICAgICAgIGF0dHJzLmV4Y2x1ZGVOb2RlIHx8XG4gICAgICAgIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICBzdGF0cyA9IHsgdmFsaWQ6IHRydWUgfSxcbiAgICAgIHByb2Nlc3NlZCA9IGZhbHNlLFxuICAgICAgZGVmYXVsdE1pbiA9IEluZmluaXR5LFxuICAgICAgZGVmYXVsdE1heCA9IDEgLSBJbmZpbml0eTtcblxuICAgIHRoaXMucHJvY2Vzc1RyZWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHByb2Nlc3NOb2RlKHRyZWUsIHRydWUpO1xuICAgICAgcHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBzdGF0cztcbiAgICB9O1xuXG4gICAgdGhpcy5leGVjdXRlID0gZnVuY3Rpb24oZG9uZSkge1xuICAgICAgaWYgKCFwcm9jZXNzZWQpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzVHJlZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXN0YXRzLnZhbGlkKSB7XG4gICAgICAgIHRocm93ICdpbnZhbGlkIG9yZGVyJztcbiAgICAgIH1cblxuICAgICAgdmFyIGNoaWxkRm5zID0gd3JhcENoaWxkcmVuKHRyZWUsIDApO1xuXG4gICAgICBxdWV1ZVJ1bm5lckZhY3Rvcnkoe1xuICAgICAgICBxdWV1ZWFibGVGbnM6IGNoaWxkRm5zLFxuICAgICAgICB1c2VyQ29udGV4dDogdHJlZS5zaGFyZWRVc2VyQ29udGV4dCgpLFxuICAgICAgICBvbkV4Y2VwdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdHJlZS5vbkV4Y2VwdGlvbi5hcHBseSh0cmVlLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuICAgICAgICBvbkNvbXBsZXRlOiBkb25lLFxuICAgICAgICBvbk11bHRpcGxlRG9uZTogdHJlZS5vbk11bHRpcGxlRG9uZVxuICAgICAgICAgID8gdHJlZS5vbk11bHRpcGxlRG9uZS5iaW5kKHRyZWUpXG4gICAgICAgICAgOiBudWxsXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcnVubmFibGVJbmRleChpZCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydW5uYWJsZUlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocnVubmFibGVJZHNbaV0gPT09IGlkKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzTm9kZShub2RlLCBwYXJlbnRFeGNsdWRlZCkge1xuICAgICAgdmFyIGV4ZWN1dGFibGVJbmRleCA9IHJ1bm5hYmxlSW5kZXgobm9kZS5pZCk7XG5cbiAgICAgIGlmIChleGVjdXRhYmxlSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJlbnRFeGNsdWRlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGV4Y2x1ZGVkID0gcGFyZW50RXhjbHVkZWQgfHwgZXhjbHVkZU5vZGUobm9kZSk7XG4gICAgICAgIHN0YXRzW25vZGUuaWRdID0ge1xuICAgICAgICAgIGV4Y2x1ZGVkOiBleGNsdWRlZCxcbiAgICAgICAgICB3aWxsRXhlY3V0ZTogIWV4Y2x1ZGVkICYmICFub2RlLm1hcmtlZFBlbmRpbmcsXG4gICAgICAgICAgc2VnbWVudHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgICAgICAgIG93bmVyOiBub2RlLFxuICAgICAgICAgICAgICBub2RlczogW25vZGVdLFxuICAgICAgICAgICAgICBtaW46IHN0YXJ0aW5nTWluKGV4ZWN1dGFibGVJbmRleCksXG4gICAgICAgICAgICAgIG1heDogc3RhcnRpbmdNYXgoZXhlY3V0YWJsZUluZGV4KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBoYXNFeGVjdXRhYmxlQ2hpbGQgPSBmYWxzZTtcblxuICAgICAgICB2YXIgb3JkZXJlZENoaWxkcmVuID0gb3JkZXJDaGlsZHJlbihub2RlKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyZWRDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBjaGlsZCA9IG9yZGVyZWRDaGlsZHJlbltpXTtcblxuICAgICAgICAgIHByb2Nlc3NOb2RlKGNoaWxkLCBwYXJlbnRFeGNsdWRlZCk7XG5cbiAgICAgICAgICBpZiAoIXN0YXRzLnZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGNoaWxkU3RhdHMgPSBzdGF0c1tjaGlsZC5pZF07XG5cbiAgICAgICAgICBoYXNFeGVjdXRhYmxlQ2hpbGQgPSBoYXNFeGVjdXRhYmxlQ2hpbGQgfHwgY2hpbGRTdGF0cy53aWxsRXhlY3V0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRzW25vZGUuaWRdID0ge1xuICAgICAgICAgIGV4Y2x1ZGVkOiBwYXJlbnRFeGNsdWRlZCxcbiAgICAgICAgICB3aWxsRXhlY3V0ZTogaGFzRXhlY3V0YWJsZUNoaWxkXG4gICAgICAgIH07XG5cbiAgICAgICAgc2VnbWVudENoaWxkcmVuKG5vZGUsIG9yZGVyZWRDaGlsZHJlbiwgc3RhdHNbbm9kZS5pZF0sIGV4ZWN1dGFibGVJbmRleCk7XG5cbiAgICAgICAgaWYgKCFub2RlLmNhbkJlUmVlbnRlcmVkKCkgJiYgc3RhdHNbbm9kZS5pZF0uc2VnbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHN0YXRzID0geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0aW5nTWluKGV4ZWN1dGFibGVJbmRleCkge1xuICAgICAgcmV0dXJuIGV4ZWN1dGFibGVJbmRleCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdE1pbiA6IGV4ZWN1dGFibGVJbmRleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydGluZ01heChleGVjdXRhYmxlSW5kZXgpIHtcbiAgICAgIHJldHVybiBleGVjdXRhYmxlSW5kZXggPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRNYXggOiBleGVjdXRhYmxlSW5kZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VnbWVudENoaWxkcmVuKFxuICAgICAgbm9kZSxcbiAgICAgIG9yZGVyZWRDaGlsZHJlbixcbiAgICAgIG5vZGVTdGF0cyxcbiAgICAgIGV4ZWN1dGFibGVJbmRleFxuICAgICkge1xuICAgICAgdmFyIGN1cnJlbnRTZWdtZW50ID0ge1xuICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgIG93bmVyOiBub2RlLFxuICAgICAgICAgIG5vZGVzOiBbXSxcbiAgICAgICAgICBtaW46IHN0YXJ0aW5nTWluKGV4ZWN1dGFibGVJbmRleCksXG4gICAgICAgICAgbWF4OiBzdGFydGluZ01heChleGVjdXRhYmxlSW5kZXgpXG4gICAgICAgIH0sXG4gICAgICAgIHJlc3VsdCA9IFtjdXJyZW50U2VnbWVudF0sXG4gICAgICAgIGxhc3RNYXggPSBkZWZhdWx0TWF4LFxuICAgICAgICBvcmRlcmVkQ2hpbGRTZWdtZW50cyA9IG9yZGVyQ2hpbGRTZWdtZW50cyhvcmRlcmVkQ2hpbGRyZW4pO1xuXG4gICAgICBmdW5jdGlvbiBpc1NlZ21lbnRCb3VuZGFyeShtaW5JbmRleCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGxhc3RNYXggIT09IGRlZmF1bHRNYXggJiZcbiAgICAgICAgICBtaW5JbmRleCAhPT0gZGVmYXVsdE1pbiAmJlxuICAgICAgICAgIGxhc3RNYXggPCBtaW5JbmRleCAtIDFcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlcmVkQ2hpbGRTZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGRTZWdtZW50ID0gb3JkZXJlZENoaWxkU2VnbWVudHNbaV0sXG4gICAgICAgICAgbWF4SW5kZXggPSBjaGlsZFNlZ21lbnQubWF4LFxuICAgICAgICAgIG1pbkluZGV4ID0gY2hpbGRTZWdtZW50Lm1pbjtcblxuICAgICAgICBpZiAoaXNTZWdtZW50Qm91bmRhcnkobWluSW5kZXgpKSB7XG4gICAgICAgICAgY3VycmVudFNlZ21lbnQgPSB7XG4gICAgICAgICAgICBpbmRleDogcmVzdWx0Lmxlbmd0aCxcbiAgICAgICAgICAgIG93bmVyOiBub2RlLFxuICAgICAgICAgICAgbm9kZXM6IFtdLFxuICAgICAgICAgICAgbWluOiBkZWZhdWx0TWluLFxuICAgICAgICAgICAgbWF4OiBkZWZhdWx0TWF4XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXN1bHQucHVzaChjdXJyZW50U2VnbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50U2VnbWVudC5ub2Rlcy5wdXNoKGNoaWxkU2VnbWVudCk7XG4gICAgICAgIGN1cnJlbnRTZWdtZW50Lm1pbiA9IE1hdGgubWluKGN1cnJlbnRTZWdtZW50Lm1pbiwgbWluSW5kZXgpO1xuICAgICAgICBjdXJyZW50U2VnbWVudC5tYXggPSBNYXRoLm1heChjdXJyZW50U2VnbWVudC5tYXgsIG1heEluZGV4KTtcbiAgICAgICAgbGFzdE1heCA9IG1heEluZGV4O1xuICAgICAgfVxuXG4gICAgICBub2RlU3RhdHMuc2VnbWVudHMgPSByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb3JkZXJDaGlsZFNlZ21lbnRzKGNoaWxkcmVuKSB7XG4gICAgICB2YXIgc3BlY2lmaWVkT3JkZXIgPSBbXSxcbiAgICAgICAgdW5zcGVjaWZpZWRPcmRlciA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldLFxuICAgICAgICAgIHNlZ21lbnRzID0gc3RhdHNbY2hpbGQuaWRdLnNlZ21lbnRzO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VnbWVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgc2VnID0gc2VnbWVudHNbal07XG5cbiAgICAgICAgICBpZiAoc2VnLm1pbiA9PT0gZGVmYXVsdE1pbikge1xuICAgICAgICAgICAgdW5zcGVjaWZpZWRPcmRlci5wdXNoKHNlZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNwZWNpZmllZE9yZGVyLnB1c2goc2VnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3BlY2lmaWVkT3JkZXIuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLm1pbiAtIGIubWluO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBzcGVjaWZpZWRPcmRlci5jb25jYXQodW5zcGVjaWZpZWRPcmRlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhlY3V0ZU5vZGUobm9kZSwgc2VnbWVudE51bWJlcikge1xuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmbjogZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgdmFyIG9uU3RhcnQgPSB7XG4gICAgICAgICAgICAgIGZuOiBmdW5jdGlvbihuZXh0KSB7XG4gICAgICAgICAgICAgICAgbm9kZVN0YXJ0KG5vZGUsIG5leHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBxdWV1ZVJ1bm5lckZhY3Rvcnkoe1xuICAgICAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgWzBdKTtcbiAgICAgICAgICAgICAgICBub2RlLmNsZWFudXBCZWZvcmVBZnRlcigpO1xuICAgICAgICAgICAgICAgIG5vZGVDb21wbGV0ZShub2RlLCBub2RlLmdldFJlc3VsdCgpLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIGRvbmUuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcXVldWVhYmxlRm5zOiBbb25TdGFydF0uY29uY2F0KHdyYXBDaGlsZHJlbihub2RlLCBzZWdtZW50TnVtYmVyKSksXG4gICAgICAgICAgICAgIHVzZXJDb250ZXh0OiBub2RlLnNoYXJlZFVzZXJDb250ZXh0KCksXG4gICAgICAgICAgICAgIG9uRXhjZXB0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBub2RlLm9uRXhjZXB0aW9uLmFwcGx5KG5vZGUsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG9uTXVsdGlwbGVEb25lOiBub2RlLm9uTXVsdGlwbGVEb25lXG4gICAgICAgICAgICAgICAgPyBub2RlLm9uTXVsdGlwbGVEb25lLmJpbmQobm9kZSlcbiAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZm46IGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIG5vZGUuZXhlY3V0ZShcbiAgICAgICAgICAgICAgZG9uZSxcbiAgICAgICAgICAgICAgc3RhdHNbbm9kZS5pZF0uZXhjbHVkZWQsXG4gICAgICAgICAgICAgIGZhaWxTcGVjV2l0aE5vRXhwZWN0YXRpb25zXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3cmFwQ2hpbGRyZW4obm9kZSwgc2VnbWVudE51bWJlcikge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICBzZWdtZW50Q2hpbGRyZW4gPSBzdGF0c1tub2RlLmlkXS5zZWdtZW50c1tzZWdtZW50TnVtYmVyXS5ub2RlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgZXhlY3V0ZU5vZGUoc2VnbWVudENoaWxkcmVuW2ldLm93bmVyLCBzZWdtZW50Q2hpbGRyZW5baV0uaW5kZXgpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICghc3RhdHNbbm9kZS5pZF0ud2lsbEV4ZWN1dGUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGUuYmVmb3JlQWxsRm5zLmNvbmNhdChyZXN1bHQpLmNvbmNhdChub2RlLmFmdGVyQWxsRm5zKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gVHJlZVByb2Nlc3Nvcjtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuVXNlckNvbnRleHQgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBVc2VyQ29udGV4dCgpIHt9XG5cbiAgVXNlckNvbnRleHQuZnJvbUV4aXN0aW5nID0gZnVuY3Rpb24ob2xkQ29udGV4dCkge1xuICAgIHZhciBjb250ZXh0ID0gbmV3IFVzZXJDb250ZXh0KCk7XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIG9sZENvbnRleHQpIHtcbiAgICAgIGlmIChvbGRDb250ZXh0Lmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIGNvbnRleHRbcHJvcF0gPSBvbGRDb250ZXh0W3Byb3BdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBVc2VyQ29udGV4dDtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudmVyc2lvbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJzQuMC4xJztcbn07XG4iLCJleHBvcnQgZGVmYXVsdCBcInN0cnVjdCBQZXJtdXRhdGlvbnMge1xcbiAgUGVybSA6IGFycmF5PGkzMiwgNTEyPixcXG59O1xcblxcbkBiaW5kaW5nKDApIEBncm91cCgwKVxcbnZhcjxzdG9yYWdlLCByZWFkPiBwZXJtIDogUGVybXV0YXRpb25zO1xcblxcbnN0cnVjdCBDb3JuZXJNYXRlcmlhbHMge1xcbiAgY29ybmVyTWF0ZXJpYWxzIDogYXJyYXk8dTMyPixcXG59O1xcblxcbkBiaW5kaW5nKDEpIEBncm91cCgwKVxcbnZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBjb3JuZXJNYXRlcmlhbHM6IENvcm5lck1hdGVyaWFscztcXG5cXG5zdHJ1Y3QgVm94ZWxNYXRlcmlhbHMge1xcbiAgdm94ZWxNYXRlcmlhbHMgOiBhcnJheTx1MzI+LFxcbn07XFxuXFxuQGJpbmRpbmcoMikgQGdyb3VwKDApXFxudmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IHZveGVsTWF0ZXJpYWxzOiBWb3hlbE1hdGVyaWFscztcXG5cXG5zdHJ1Y3QgQ29ybmVySW5kZXgge1xcbiAgY29ybmVyQ291bnQgOiB1MzIsXFxuICBjb3JuZXJJbmRleGVzIDogYXJyYXk8dTMyPlxcbn07XFxuXFxuQGJpbmRpbmcoMykgQGdyb3VwKDApXFxudmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IGNvcm5lckluZGV4OiBDb3JuZXJJbmRleDtcXG5cXG5zdHJ1Y3QgR1BVVk9YXFxue1xcblxcdHZveE1pbjogdmVjMzxmMzI+LFxcblxcdGNvcm5lcnM6IGYzMixcXG5cXHR2ZXJ0UG9pbnQ6IHZlYzM8ZjMyPixcXG5cXHRhdmdOb3JtYWw6IHZlYzM8ZjMyPixcXG5cXHRudW1Qb2ludHM6IGYzMlxcbn07XFxuc3RydWN0IEdQVVZPWFMge1xcbiAgdm94ZWxzIDogYXJyYXk8R1BVVk9YPixcXG59O1xcblxcbkBiaW5kaW5nKDQpIEBncm91cCgwKVxcbnZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiB2b3hlbHM6IEdQVVZPWFM7XFxuXFxuc3RydWN0IFVuaWZvcm1CdWZmZXJPYmplY3Qge1xcbiAgY2h1bmtQb3NpdGlvbiA6IHZlYzM8ZjMyPixcXG4gIHN0cmlkZSA6IGYzMixcXG5cXHR3aWR0aDogdTMyXFxufTtcXG5cXG5AYmluZGluZyg1KSBAZ3JvdXAoMClcXG52YXI8dW5pZm9ybT4gdW5pZm9ybXMgOiBVbmlmb3JtQnVmZmVyT2JqZWN0O1xcblxcbnN0cnVjdCBBY3RvciB7XFxuICBwb3NpdGlvbjogdmVjMzxmMzI+LFxcbiAgdmVsb2NpdHk6IHZlYzM8ZjMyPlxcbn07XFxuXFxuXFxuc3RydWN0IFBoeXNpY3Mge1xcbiAgYWN0b3JzOiBhcnJheTxBY3Rvcj5cXG59O1xcblxcbkBiaW5kaW5nKDYpIEBncm91cCgwKVxcbnZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBwaHlzaWNzIDogUGh5c2ljcztcXG5cXG5cXG5sZXQgQ0hJTERfTUlOX09GRlNFVFM6IGFycmF5PHZlYzM8dTMyPiwgOD4gPSBhcnJheTx2ZWMzPHUzMj4sIDg+XFxuKFxcbiAgdmVjMzx1MzI+KDB1LCAwdSwgMHUpLFxcbiAgdmVjMzx1MzI+KDB1LCAwdSwgMXUpLFxcbiAgdmVjMzx1MzI+KDB1LCAxdSwgMHUpLFxcbiAgdmVjMzx1MzI+KDB1LCAxdSwgMXUpLFxcbiAgdmVjMzx1MzI+KDF1LCAwdSwgMHUpLFxcbiAgdmVjMzx1MzI+KDF1LCAwdSwgMXUpLFxcbiAgdmVjMzx1MzI+KDF1LCAxdSwgMHUpLFxcbiAgdmVjMzx1MzI+KDF1LCAxdSwgMXUpXFxuKTtcXG5cXG5sZXQgZWRnZXZtYXA6IGFycmF5PHZlYzI8aTMyPiwgMTI+ID0gYXJyYXk8dmVjMjxpMzI+LCAxMj5cXG4oXFxuXFx0dmVjMjxpMzI+KDAsNCksIHZlYzI8aTMyPigxLDUpLCB2ZWMyPGkzMj4oMiw2KSwgdmVjMjxpMzI+KDMsNyksXFxuXFx0dmVjMjxpMzI+KDAsMiksIHZlYzI8aTMyPigxLDMpLCB2ZWMyPGkzMj4oNCw2KSwgdmVjMjxpMzI+KDUsNyksXFxuXFx0dmVjMjxpMzI+KDAsMSksIHZlYzI8aTMyPigyLDMpLCB2ZWMyPGkzMj4oNCw1KSwgdmVjMjxpMzI+KDYsNylcXG4pO1xcblxcbmZuIHJhbmRvbShpOiB2ZWMyPGYzMj4pIC0+IGYzMiB7XFxuICByZXR1cm4gZnJhY3Qoc2luKGRvdChpLHZlYzIoMTIuOTg5OCw3OC4yMzMpKSkqNDM3NTguNTQ1MzEyMyk7XFxufVxcblxcbmZuIFZlYzNEb3QoYTogdmVjMzxmMzI+LCBiOiB2ZWMzPGYzMj4pIC0+IGYzMlxcbntcXG5cXHRyZXR1cm4gKGEueCAqIGIueCkgKyAoYS55ICogYi55KSArIChhLnogKiBiLnopO1xcbn1cXG5cXG5sZXQgR3JhZDM6IGFycmF5PHZlYzM8ZjMyPiwgMTI+ID0gYXJyYXk8dmVjMzxmMzI+LCAxMj4oXFxuXFx0dmVjMzxmMzI+KDEuMCwxLjAsMC4wKSwgdmVjMzxmMzI+KC0xLjAsMS4wLDAuMCksIHZlYzM8ZjMyPigxLjAsLTEuMCwwLjApLCB2ZWMzPGYzMj4oLTEuMCwtMS4wLDAuMCksXFxuXFx0dmVjMzxmMzI+KDEuMCwwLjAsMS4wKSwgdmVjMzxmMzI+KC0xLjAsMC4wLDEuMCksIHZlYzM8ZjMyPigxLjAsMC4wLC0xLjApLCB2ZWMzPGYzMj4oLTEuMCwwLjAsLTEuMCksXFxuXFx0dmVjMzxmMzI+KDAuMCwxLjAsMS4wKSwgdmVjMzxmMzI+KDAuMCwtMS4wLDEuMCksIHZlYzM8ZjMyPigwLjAsMS4wLC0xLjApLCB2ZWMzPGYzMj4oMC4wLC0xLjAsLTEuMClcXG4pO1xcblxcbmZuIFBlcmxpbih4MTogZjMyLCB5MTogZjMyLCB6MTogZjMyKSAtPiBmMzJcXG57XFxuXFx0dmFyIFg6IGkzMiA9IDA7XFxuXFx0aWYgKHgxID4gMC4wKSB7XFxuXFx0XFx0WCA9IGkzMih4MSk7XFxuXFx0fSBlbHNlIHtcXG5cXHRcXHRYID0gaTMyKHgxKSAtIDE7XFxuXFx0fVxcblxcblxcdHZhciBZOiBpMzIgPSAwO1xcblxcdGlmICh5MSA+IDAuMCkge1xcblxcdFxcdFkgPSBpMzIoeTEpO1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0WSA9IGkzMih5MSkgLSAxO1xcblxcdH1cXG5cXG5cXHR2YXIgWjogaTMyID0gMDtcXG5cXHRpZiAoejEgPiAwLjApIHtcXG5cXHRcXHRaID0gaTMyKHoxKTtcXG5cXHR9IGVsc2Uge1xcblxcdFxcdFogPSBpMzIoejEpIC0gMTtcXG5cXHR9XFxuXFx0XFxuXFx0bGV0IHg6IGYzMiA9IHgxIC0gZjMyKFgpO1xcblxcdGxldCB5OiBmMzIgPSB5MSAtIGYzMihZKTtcXG5cXHRsZXQgejogZjMyID0gejEgLSBmMzIoWik7XFxuXFx0XFxuXFx0WCA9IFggJiAyNTU7XFxuXFx0WSA9IFkgJiAyNTU7XFxuXFx0WiA9IFogJiAyNTU7XFxuXFx0XFxuXFx0bGV0IGdpMDAwOiBpMzIgPSAocGVybS5QZXJtW1ggKyBwZXJtLlBlcm1bWSArIHBlcm0uUGVybVtaXSBdIF0gJSAxMik7XFxuXFx0bGV0IGdpMDAxOiBpMzIgPSAocGVybS5QZXJtW1ggKyBwZXJtLlBlcm1bWSArIHBlcm0uUGVybVtaICsgMV0gXSBdICUgMTIpO1xcblxcdGxldCBnaTAxMDogaTMyID0gKHBlcm0uUGVybVtYICsgcGVybS5QZXJtW1kgKyAxICsgcGVybS5QZXJtW1pdIF0gXSAlIDEyKTtcXG5cXHRsZXQgZ2kwMTE6IGkzMiA9IChwZXJtLlBlcm1bWCArIHBlcm0uUGVybVtZICsgMSArIHBlcm0uUGVybVtaICsgMV0gXSBdICUgMTIpO1xcblxcdGxldCBnaTEwMDogaTMyID0gKHBlcm0uUGVybVtYICsgMSArIHBlcm0uUGVybVtZICsgcGVybS5QZXJtW1pdIF0gXSAlIDEyKTtcXG5cXHRsZXQgZ2kxMDE6IGkzMiA9IChwZXJtLlBlcm1bWCArIDEgKyBwZXJtLlBlcm1bWSArIHBlcm0uUGVybVtaICsgMV0gXSBdICUgMTIpO1xcblxcdGxldCBnaTExMDogaTMyID0gKHBlcm0uUGVybVtYICsgMSArIHBlcm0uUGVybVtZICsgMSArIHBlcm0uUGVybVtaXSBdIF0gJSAxMik7XFxuXFx0bGV0IGdpMTExOiBpMzIgPSAocGVybS5QZXJtW1ggKyAxICsgcGVybS5QZXJtW1kgKyAxICsgcGVybS5QZXJtW1ogKyAxXSBdIF0gJSAxMik7XFxuXFxuXFx0bGV0IG4wMDA6IGYzMiA9IGRvdChHcmFkM1tnaTAwMF0sIHZlYzM8ZjMyPih4LCB5LCB6KSk7XFxuXFx0bGV0IG4xMDA6IGYzMiA9IGRvdChHcmFkM1tnaTEwMF0sIHZlYzM8ZjMyPih4IC0gMS4wLCB5LCB6KSk7XFxuXFx0bGV0IG4wMTA6IGYzMiA9IGRvdChHcmFkM1tnaTAxMF0sIHZlYzM8ZjMyPih4LCB5IC0gMS4wLCB6KSk7XFxuXFx0bGV0IG4xMTA6IGYzMiA9IGRvdChHcmFkM1tnaTExMF0sIHZlYzM8ZjMyPih4IC0gMS4wLCB5IC0gMS4wLCB6KSk7XFxuXFx0bGV0IG4wMDE6IGYzMiA9IGRvdChHcmFkM1tnaTAwMV0sIHZlYzM8ZjMyPih4LCB5LCB6IC0gMS4wKSk7XFxuXFx0bGV0IG4xMDE6IGYzMiA9IGRvdChHcmFkM1tnaTEwMV0sIHZlYzM8ZjMyPih4IC0gMS4wLCB5LCB6IC0gMS4wKSk7XFxuXFx0bGV0IG4wMTE6IGYzMiA9IGRvdChHcmFkM1tnaTAxMV0sIHZlYzM8ZjMyPih4LCB5IC0gMS4wLCB6IC0gMS4wKSk7XFxuXFx0bGV0IG4xMTE6IGYzMiA9IGRvdChHcmFkM1tnaTExMV0sIHZlYzM8ZjMyPih4IC0gMS4wLCB5IC0gMS4wLCB6IC0gMS4wKSk7XFxuXFx0XFxuXFx0bGV0IHU6IGYzMiA9IGYzMih4ICogeCAqIHggKiAoeCAqICh4ICogNi4wIC0gMTUuMCkgKyAxMC4wKSk7XFxuXFx0bGV0IHY6IGYzMiA9IGYzMih5ICogeSAqIHkgKiAoeSAqICh5ICogNi4wIC0gMTUuMCkgKyAxMC4wKSk7XFxuXFx0bGV0IHc6IGYzMiA9IGYzMih6ICogeiAqIHogKiAoeiAqICh6ICogNi4wIC0gMTUuMCkgKyAxMC4wKSk7XFxuXFx0bGV0IG54MDA6IGYzMiA9IG1peChuMDAwLCBuMTAwLCB1KTtcXG5cXHRsZXQgbngwMTogZjMyID0gbWl4KG4wMDEsIG4xMDEsIHUpO1xcblxcdGxldCBueDEwOiBmMzIgPSBtaXgobjAxMCwgbjExMCwgdSk7XFxuXFx0bGV0IG54MTE6IGYzMiA9IG1peChuMDExLCBuMTExLCB1KTtcXG5cXHRsZXQgbnh5MDogZjMyID0gbWl4KG54MDAsIG54MTAsIHYpO1xcblxcdGxldCBueHkxOiBmMzIgPSBtaXgobngwMSwgbngxMSwgdik7XFxuXFx0bGV0IG54eXo6IGYzMiA9IG1peChueHkwLCBueHkxLCB3KTtcXG5cXHRcXG5cXHRyZXR1cm4gbnh5ejtcXG59XFxuXFxuZm4gRnJhY3RhbE5vaXNlKG9jdGF2ZXM6IGkzMiwgZnJlcXVlbmN5OiBmMzIsIGxhY3VuYXJpdHk6IGYzMiwgcGVyc2lzdGVuY2U6IGYzMiwgcG9zaXRpb246IHZlYzM8ZjMyPikgLT4gZjMyXFxue1xcblxcdGxldCBTQ0FMRTogZjMyID0gMS4wIC8gMTI4LjA7XFxuXFx0dmFyIHA6IHZlYzM8ZjMyPiA9IHBvc2l0aW9uICogU0NBTEU7XFxuXFx0dmFyIG5vaXM6IGYzMiA9IDAuMDtcXG5cXG5cXHR2YXIgYW1wbGl0dWRlOiBmMzIgPSAxLjA7XFxuXFx0cCA9IHAgKiBmcmVxdWVuY3k7XFxuXFxuXFx0dmFyIGk6IGkzMiA9IDA7XFxuXFx0bG9vcCB7XFxuXFx0XFx0aWYgKGkgPj0gb2N0YXZlcykgeyBicmVhazsgfVxcblxcblxcdFxcdG5vaXMgPSBub2lzICsgUGVybGluKHAueCwgcC55LCBwLnopICogYW1wbGl0dWRlO1xcblxcdFxcdHAgPSBwICogbGFjdW5hcml0eTtcXG5cXHRcXHRhbXBsaXR1ZGUgPSBhbXBsaXR1ZGUgKiBwZXJzaXN0ZW5jZTtcXG5cXG5cXHRcXHRjb250aW51aW5nIHtcXG5cXHRcXHRcXHRpID0gaSArIDE7XFxuXFx0XFx0fVxcblxcdH1cXG5cXHRcXG5cXHRyZXR1cm4gbm9pcztcXG59XFxuXFxuZm4gRnJhY3RhbE5vaXNlMShmcmVxdWVuY3k6IGYzMiwgbGFjdW5hcml0eTogZjMyLCBwZXJzaXN0ZW5jZTogZjMyLCBwb3NpdGlvbjogdmVjMzxmMzI+KSAtPiBmMzJcXG57XFxuXFx0bGV0IFNDQUxFOiBmMzIgPSAxLjAgLyAxMjguMDtcXG5cXHR2YXIgcDogdmVjMzxmMzI+ID0gcG9zaXRpb24gKiBTQ0FMRTtcXG5cXHR2YXIgbm9pczogZjMyID0gMC4wO1xcblxcblxcdHZhciBhbXBsaXR1ZGU6IGYzMiA9IDEuMDtcXG5cXHRwID0gcCAqIGZyZXF1ZW5jeTtcXG5cXHRcXG5cXHRub2lzID0gbm9pcyArIFBlcmxpbihwLngsIHAueSwgcC56KSAqIGFtcGxpdHVkZTtcXG5cXHRwID0gcCAqIGxhY3VuYXJpdHk7XFxuXFx0YW1wbGl0dWRlID0gYW1wbGl0dWRlICogcGVyc2lzdGVuY2U7XFxuXFx0XFxuXFx0cmV0dXJuIG5vaXM7XFxufVxcblxcbmZuIENhbGN1bGF0ZU5vaXNlVmFsdWUocG9zOiB2ZWMzPGYzMj4sIHNjYWxlOiBmMzIpIC0+IGYzMlxcbntcXG5cXHRyZXR1cm4gRnJhY3RhbE5vaXNlKDQsIDAuNTM0MywgMi4yMzI0LCAwLjY4MzI0LCBwb3MgKiBzY2FsZSk7XFxufVxcblxcbmZuIENMZXJwKGE6IGYzMiwgYjogZjMyLCB0OiBmMzIpIC0+IGYzMlxcbntcXG5cXHRyZXR1cm4gKDEuMCAtIHQpICogYSArIHQgKiBiO1xcbn1cXG5cXG4vLyBTVkRcXG5cXG5sZXQgU1ZEX05VTV9TV0VFUFM6IGkzMiA9IDQ7XFxubGV0IFBTVUVET19JTlZFUlNFX1RIUkVTSE9MRDogZjMyID0gMC4wMDAwMDAwMTtcXG5cXG5mbiBzdmRfbXVsX21hdHJpeF92ZWMobTogbWF0M3gzPGYzMj4sIGI6IHZlYzQ8ZjMyPikgLT4gdmVjNDxmMzI+XFxue1xcblxcdHZhciBhOiBtYXQzeDM8ZjMyPiA9IG07XFxuXFx0XFxuXFx0cmV0dXJuIHZlYzQ8ZjMyPihcXG5cXHRcXHRkb3QodmVjNDxmMzI+KGFbMF1bMF0sIGFbMF1bMV0sIGFbMF1bMl0sIDAuMCksIGIpLFxcblxcdFxcdGRvdCh2ZWM0PGYzMj4oYVsxXVswXSwgYVsxXVsxXSwgYVsxXVsyXSwgMC4wKSwgYiksXFxuXFx0XFx0ZG90KHZlYzQ8ZjMyPihhWzJdWzBdLCBhWzJdWzFdLCBhWzJdWzJdLCAwLjApLCBiKSxcXG5cXHRcXHQwLjBcXG5cXHQpO1xcbn1cXG5cXG5mbiBnaXZlbnNfY29lZmZzX3N5bShhX3BwOiBmMzIsIGFfcHE6IGYzMiwgYV9xcTogZjMyKSAtPiB2ZWMyPGYzMj5cXG57XFxuXFx0aWYgKGFfcHEgPT0gMC4wKSB7XFxuXFx0XFx0cmV0dXJuIHZlYzI8ZjMyPigxLjAsIDAuMCk7XFxuXFx0fVxcblxcdFxcblxcdGxldCB0YXU6IGYzMiA9IChhX3FxIC0gYV9wcCkgLyAoMi4wICogYV9wcSk7XFxuXFx0bGV0IHN0dDogZjMyID0gc3FydCgxLjAgKyB0YXUgKiB0YXUpO1xcblxcdHZhciB0YW46IGYzMjtcXG5cXHRpZiAoKHRhdSA+PSAwLjApKSB7XFxuXFx0XFx0dGFuID0gKHRhdSArIHN0dCk7XFxuXFx0fSBlbHNlIHtcXG5cXHRcXHR0YW4gPSAodGF1IC0gc3R0KTtcXG5cXHR9XFxuXFx0dGFuID0gMS4wIC8gdGFuO1xcblxcblxcdGxldCBjOiBmMzIgPSBpbnZlcnNlU3FydCgxLjAgKyB0YW4gKiB0YW4pO1xcblxcdGxldCBzOiBmMzIgPSB0YW4gKiBjO1xcblxcblxcdHJldHVybiB2ZWMyPGYzMj4oYywgcyk7XFxufVxcblxcbmZuIHN2ZF9yb3RhdGVfeHkoeDogZjMyLCB5OiBmMzIsIGM6IGYzMiwgczogZjMyKSAtPiB2ZWMyPGYzMj5cXG57XFxuXFx0cmV0dXJuIHZlYzI8ZjMyPihjICogeCAtIHMgKiB5LCBzICogeCArIGMgKiB5KTtcXG59XFxuXFxuZm4gc3ZkX3JvdGF0ZXFfeHkoeDogZjMyLCB5OiBmMzIsIHo6IGYzMiwgYzogZjMyLCBzOiBmMzIpIC0+IHZlYzI8ZjMyPlxcbntcXG5cXHRsZXQgY2M6IGYzMiA9IGMgKiBjO1xcblxcdGxldCBzczogZjMyID0gcyAqIHM7XFxuXFx0bGV0IG14OiBmMzIgPSAyLjAgKiBjICogcyAqIHo7XFxuXFxuXFx0cmV0dXJuIHZlYzI8ZjMyPihcXG5cXHRcXHRjYyAqIHggLSBteCArIHNzICogeSxcXG5cXHRcXHRzcyAqIHggKyBteCArIGNjICogelxcblxcdCk7XFxufVxcblxcbnZhcjxwcml2YXRlPiB2dGF2OiBtYXQzeDM8ZjMyPjtcXG52YXI8cHJpdmF0ZT4gdjogbWF0M3gzPGYzMj47XFxudmFyPHByaXZhdGU+IEFUQTogYXJyYXk8ZjMyLCA2PjtcXG52YXI8cHJpdmF0ZT4gQXRiOiB2ZWM0PGYzMj47XFxudmFyPHByaXZhdGU+IHBvaW50YWNjdW06IHZlYzQ8ZjMyPjtcXG52YXI8cHJpdmF0ZT4gYnRiOiBmMzI7XFxuXFxuZm4gc3ZkX3JvdGF0ZShhOiBpMzIsIGI6IGkzMilcXG57XFxuXFx0aWYgKHZ0YXZbYV1bYl0gPT0gMC4wKSB7IHJldHVybjsgfVxcblxcblxcblxcdFxcblxcdGxldCBjb2VmZnM6IHZlYzI8ZjMyPiA9IGdpdmVuc19jb2VmZnNfc3ltKHZ0YXZbYV1bYV0sIHZ0YXZbYV1bYl0sIHZ0YXZbYl1bYl0pO1xcblxcdGxldCBjOiBmMzIgPSBjb2VmZnMueDtcXG5cXHRsZXQgczogZjMyID0gY29lZmZzLnk7XFxuXFx0XFxuXFx0bGV0IHJvdDE6IHZlYzI8ZjMyPiA9IHN2ZF9yb3RhdGVxX3h5KHZ0YXZbYV1bYV0sIHZ0YXZbYl1bYl0sIHZ0YXZbYV1bYl0sIGMsIHMpO1xcblxcdHZ0YXZbYV1bYV0gPSByb3QxLng7XFxuXFx0dnRhdltiXVtiXSA9IHJvdDEueTtcXG5cXHRcXG5cXHRsZXQgcm90MjogdmVjMjxmMzI+ID0gc3ZkX3JvdGF0ZV94eSh2dGF2WzBdWzMtYl0sIHZ0YXZbMS1hXVsyXSwgYywgcyk7XFxuXFx0dnRhdlswXVszLWJdID0gcm90Mi54OyBcXG5cXHR2dGF2WzEtYV1bMl0gPSByb3QyLnk7XFxuXFx0XFxuXFx0dnRhdlthXVtiXSA9IDAuMDtcXG5cXHRcXG5cXHRsZXQgcm90MzogdmVjMjxmMzI+ID0gc3ZkX3JvdGF0ZV94eSh2WzBdW2FdLCB2WzBdW2JdLCBjLCBzKTtcXG5cXHR2WzBdW2FdID0gcm90My54OyB2WzBdW2JdID0gcm90My55O1xcblxcdFxcblxcdGxldCByb3Q0OiB2ZWMyPGYzMj4gPSBzdmRfcm90YXRlX3h5KHZbMV1bYV0sIHZbMV1bYl0sIGMsIHMpO1xcblxcdHZbMV1bYV0gPSByb3Q0Lng7IHZbMV1bYl0gPSByb3Q0Lnk7XFxuXFx0XFxuXFx0bGV0IHJvdDU6IHZlYzI8ZjMyPiA9IHN2ZF9yb3RhdGVfeHkodlsyXVthXSwgdlsyXVtiXSwgYywgcyk7XFxuXFx0dlsyXVthXSA9IHJvdDUueDsgdlsyXVtiXSA9IHJvdDUueTtcXG59XFxuXFxuZm4gc3ZkX3NvbHZlX3N5bShiOiBhcnJheTxmMzIsIDY+KSAtPiB2ZWM0PGYzMj5cXG57XFxuXFx0dmFyIGE6IGFycmF5PGYzMiwgNj4gPSBiO1xcblxcdFxcblxcdHZ0YXYgPSBtYXQzeDM8ZjMyPiggXFxuXFx0XFx0dmVjMzxmMzI+KGFbMF0sIGFbMV0sIGFbMl0pLCBcXG5cXHRcXHR2ZWMzPGYzMj4oMC4wLCBhWzNdLCBhWzRdKSwgXFxuXFx0XFx0dmVjMzxmMzI+KDAuMCwgMC4wLCBhWzVdKVxcblxcdCk7XFxuXFxuXFx0dmFyIGk6IGkzMjtcXG5cXHRsb29wIHtcXG5cXHRcXHRpZiAoaSA+PSBTVkRfTlVNX1NXRUVQUykgeyBicmVhazsgfVxcblxcblxcdFxcdHN2ZF9yb3RhdGUoMCwgMSk7XFxuXFx0XFx0c3ZkX3JvdGF0ZSgwLCAyKTtcXG5cXHRcXHRzdmRfcm90YXRlKDEsIDIpO1xcblxcblxcdFxcdGNvbnRpbnVpbmcge1xcblxcdFxcdFxcdGkgPSBpICsgMTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdHZhciBjb3B5OiBtYXQzeDM8ZjMyPiA9IHZ0YXY7XFxuXFx0cmV0dXJuIHZlYzQ8ZjMyPihjb3B5WzBdWzBdLCBjb3B5WzFdWzFdLCBjb3B5WzJdWzJdLCAwLjApO1xcbn1cXG5cXG5cXG5mbiBzdmRfaW52ZGV0KHg6IGYzMiwgdG9sOiBmMzIpIC0+IGYzMlxcbntcXG5cXHRpZiAoYWJzKHgpIDwgdG9sIHx8IGFicygxLjAgLyB4KSA8IHRvbCkge1xcblxcdFxcdHJldHVybiAwLjA7XFxuXFx0fVxcblxcdHJldHVybiAoMS4wIC8geCk7XFxufVxcblxcbmZuIHN2ZF9wc2V1ZG9pbnZlcnNlKHNpZ21hOiB2ZWM0PGYzMj4sIGM6IG1hdDN4MzxmMzI+KSAtPiBtYXQzeDM8ZjMyPlxcbntcXG5cXHRsZXQgZDA6IGYzMiA9IHN2ZF9pbnZkZXQoc2lnbWEueCwgUFNVRURPX0lOVkVSU0VfVEhSRVNIT0xEKTtcXG5cXHRsZXQgZDE6IGYzMiA9IHN2ZF9pbnZkZXQoc2lnbWEueSwgUFNVRURPX0lOVkVSU0VfVEhSRVNIT0xEKTtcXG5cXHRsZXQgZDI6IGYzMiA9IHN2ZF9pbnZkZXQoc2lnbWEueiwgUFNVRURPX0lOVkVSU0VfVEhSRVNIT0xEKTtcXG5cXG5cXHR2YXIgY29weTogbWF0M3gzPGYzMj4gPSBjO1xcblxcblxcdHJldHVybiBtYXQzeDM8ZjMyPiAoXFxuXFx0XFx0dmVjMzxmMzI+KFxcblxcdFxcdFxcdGNvcHlbMF1bMF0gKiBkMCAqIGNvcHlbMF1bMF0gKyBjb3B5WzBdWzFdICogZDEgKiBjb3B5WzBdWzFdICsgY29weVswXVsyXSAqIGQyICogY29weVswXVsyXSxcXG5cXHRcXHRcXHRjb3B5WzBdWzBdICogZDAgKiBjb3B5WzFdWzBdICsgY29weVswXVsxXSAqIGQxICogY29weVsxXVsxXSArIGNvcHlbMF1bMl0gKiBkMiAqIGNvcHlbMV1bMl0sXFxuXFx0XFx0XFx0Y29weVswXVswXSAqIGQwICogY29weVsyXVswXSArIGNvcHlbMF1bMV0gKiBkMSAqIGNvcHlbMl1bMV0gKyBjb3B5WzBdWzJdICogZDIgKiBjb3B5WzJdWzJdXFxuXFx0XFx0KSxcXG5cXHRcXHR2ZWMzPGYzMj4oXFxuXFx0XFx0XFx0Y29weVsxXVswXSAqIGQwICogY29weVswXVswXSArIGNvcHlbMV1bMV0gKiBkMSAqIGNvcHlbMF1bMV0gKyBjb3B5WzFdWzJdICogZDIgKiBjb3B5WzBdWzJdLFxcblxcdFxcdFxcdGNvcHlbMV1bMF0gKiBkMCAqIGNvcHlbMV1bMF0gKyBjb3B5WzFdWzFdICogZDEgKiBjb3B5WzFdWzFdICsgY29weVsxXVsyXSAqIGQyICogY29weVsxXVsyXSxcXG5cXHRcXHRcXHRjb3B5WzFdWzBdICogZDAgKiBjb3B5WzJdWzBdICsgY29weVsxXVsxXSAqIGQxICogY29weVsyXVsxXSArIGNvcHlbMV1bMl0gKiBkMiAqIGNvcHlbMl1bMl1cXG5cXHRcXHQpLFxcblxcdFxcdHZlYzM8ZjMyPihcXG5cXHRcXHRcXHRjb3B5WzJdWzBdICogZDAgKiBjb3B5WzBdWzBdICsgY29weVsyXVsxXSAqIGQxICogY29weVswXVsxXSArIGNvcHlbMl1bMl0gKiBkMiAqIGNvcHlbMF1bMl0sXFxuXFx0XFx0XFx0Y29weVsyXVswXSAqIGQwICogY29weVsxXVswXSArIGNvcHlbMl1bMV0gKiBkMSAqIGNvcHlbMV1bMV0gKyBjb3B5WzJdWzJdICogZDIgKiBjb3B5WzFdWzJdLFxcblxcdFxcdFxcdGNvcHlbMl1bMF0gKiBkMCAqIGNvcHlbMl1bMF0gKyBjb3B5WzJdWzFdICogZDEgKiBjb3B5WzJdWzFdICsgY29weVsyXVsyXSAqIGQyICogY29weVsyXVsyXVxcblxcdFxcdCksXFxuXFx0KTtcXG59XFxuXFxuZm4gc3ZkX3NvbHZlX0FUQV9BdGIoYTogdmVjNDxmMzI+KSAtPiB2ZWM0PGYzMj5cXG57XFxuXFx0diA9IG1hdDN4MzxmMzI+KHZlYzM8ZjMyPigxLjAsIDAuMCwgMC4wKSwgdmVjMzxmMzI+KDAuMCwgMS4wLCAwLjApLCB2ZWMzPGYzMj4oMC4wLCAwLjAsIDEuMCkpO1xcblxcdFxcblxcdGxldCBzaWdtYTogdmVjNDxmMzI+ID0gc3ZkX3NvbHZlX3N5bShBVEEpO1xcblxcdFxcblxcdGxldCBWaW52OiBtYXQzeDM8ZjMyPiA9IHN2ZF9wc2V1ZG9pbnZlcnNlKHNpZ21hLCB2KTtcXG5cXHRyZXR1cm4gc3ZkX211bF9tYXRyaXhfdmVjKFZpbnYsIGEpO1xcbn1cXG5cXG5mbiBzdmRfdm11bF9zeW0odjogdmVjNDxmMzI+KSAtPiB2ZWM0PGYzMj5cXG57XFxuXFx0bGV0IEFfcm93X3g6IHZlYzQ8ZjMyPiA9IHZlYzQ8ZjMyPihBVEFbMF0sIEFUQVsxXSwgQVRBWzJdLCAwLjApO1xcblxcdHJldHVybiB2ZWM0PGYzMj4gKFxcblxcdFxcdGRvdChBX3Jvd194LCB2KSxcXG5cXHRcXHRBVEFbMV0gKiB2LnggKyBBVEFbM10gKiB2LnkgKyBBVEFbNF0gKiB2LnosXFxuXFx0XFx0QVRBWzJdICogdi54ICsgQVRBWzRdICogdi55ICsgQVRBWzVdICogdi56LFxcblxcdFxcdDAuMFxcblxcdCk7XFxufVxcblxcblxcbi8vIC8vIFFFRlxcblxcbmZuIHFlZl9hZGQobjogdmVjNDxmMzI+LCBwOiB2ZWM0PGYzMj4pXFxue1xcblxcdEFUQVswXSA9IEFUQVswXSArIG4ueCAqIG4ueDtcXG5cXHRBVEFbMV0gPSBBVEFbMV0gKyBuLnggKiBuLnk7XFxuXFx0QVRBWzJdID0gQVRBWzJdICsgbi54ICogbi56O1xcblxcdEFUQVszXSA9IEFUQVszXSArIG4ueSAqIG4ueTtcXG5cXHRBVEFbNF0gPSBBVEFbNF0gKyBuLnkgKiBuLno7XFxuXFx0QVRBWzVdID0gQVRBWzVdICsgbi56ICogbi56O1xcblxcdFxcblxcdGxldCBiOiBmMzIgPSBkb3QocCwgbik7XFxuXFx0QXRiLnggPSBBdGIueCArbi54ICogYjtcXG5cXHRBdGIueSA9IEF0Yi55ICtuLnkgKiBiO1xcblxcdEF0Yi56ID0gQXRiLnogK24ueiAqIGI7XFxuXFx0YnRiID0gYnRiICsgYiAqIGI7XFxuXFx0XFxuXFx0cG9pbnRhY2N1bS54ID0gcG9pbnRhY2N1bS54ICtwLng7XFxuXFx0cG9pbnRhY2N1bS55ID0gcG9pbnRhY2N1bS55ICtwLnk7XFxuXFx0cG9pbnRhY2N1bS56ID0gcG9pbnRhY2N1bS56ICtwLno7XFxuXFx0cG9pbnRhY2N1bS53ID0gcG9pbnRhY2N1bS53ICsxLjA7XFxufVxcblxcbmZuIHFlZl9jYWxjX2Vycm9yKHg6IHZlYzQ8ZjMyPikgLT4gZjMyXFxue1xcblxcdHZhciB0bXA6IHZlYzQ8ZjMyPiA9IHN2ZF92bXVsX3N5bSh4KTtcXG5cXHR0bXAgPSBBdGIgLSB0bXA7XFxuXFx0XFxuXFx0cmV0dXJuIGRvdCh0bXAsIHRtcCk7XFxufVxcblxcbmZuIHFlZl9zb2x2ZSgpIC0+IHZlYzQ8ZjMyPlxcbntcXG5cXHRsZXQgbWFzc3BvaW50OiB2ZWM0PGYzMj4gPSB2ZWM0PGYzMj4ocG9pbnRhY2N1bS54IC8gcG9pbnRhY2N1bS53LCBwb2ludGFjY3VtLnkgLyBwb2ludGFjY3VtLncsIHBvaW50YWNjdW0ueiAvIHBvaW50YWNjdW0udywgcG9pbnRhY2N1bS53IC8gcG9pbnRhY2N1bS53KTtcXG5cXHRcXG5cXHR2YXIgQV9tcDogdmVjNDxmMzI+ID0gc3ZkX3ZtdWxfc3ltKG1hc3Nwb2ludCk7XFxuXFx0QV9tcCA9IEF0YiAtIEFfbXA7XFxuXFx0XFxuXFx0bGV0IHg6IHZlYzQ8ZjMyPiA9IHN2ZF9zb2x2ZV9BVEFfQXRiKEFfbXApO1xcblxcdFxcblxcdGxldCBlcnJvcjogZjMyID0gcWVmX2NhbGNfZXJyb3IoeCk7XFxuXFx0bGV0IHI6IHZlYzQ8ZjMyPiA9IHggKyBtYXNzcG9pbnQ7XFxuXFx0XFxuXFx0cmV0dXJuIHZlYzQ8ZjMyPihyLngsIHIueSwgci56LCBlcnJvcik7XFxufVxcblxcbiNpbXBvcnQgZGVuc2l0eVxcblxcbmZuIEFwcHJveGltYXRlWmVyb0Nyb3NzaW5nUG9zaXRpb24ocDA6IHZlYzM8ZjMyPiwgcDE6IHZlYzM8ZjMyPikgLT4gdmVjMzxmMzI+XFxue1xcblxcdHZhciBtaW5WYWx1ZTogZjMyID0gMTAwMDAwLjA7XFxuXFx0dmFyIHQ6IGYzMiA9IDAuMDtcXG5cXHR2YXIgY3VycmVudFQ6IGYzMiA9IDAuMDtcXG5cXHRsZXQgc3RlcHM6IGYzMiA9IDguMDtcXG5cXHRsZXQgaW5jcmVtZW50OiBmMzIgPSAxLjAgLyBzdGVwcztcXG5cXHRsb29wIHtcXG5cXHRcXHRpZiAoY3VycmVudFQgPiAxLjApIHsgYnJlYWs7IH1cXG5cXG5cXHRcXHRsZXQgcDogdmVjMzxmMzI+ID0gcDAgKyAoKHAxIC0gcDApICogY3VycmVudFQpO1xcblxcdFxcdGxldCBkZW5zaXR5OiBmMzIgPSBhYnMoZ2V0RGVuc2l0eShwKSk7XFxuXFx0XFx0aWYgKGRlbnNpdHkgPCBtaW5WYWx1ZSlcXG5cXHRcXHR7XFxuXFx0XFx0XFx0bWluVmFsdWUgPSBkZW5zaXR5O1xcblxcdFxcdFxcdHQgPSBjdXJyZW50VDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Y29udGludWluZyB7XFxuXFx0XFx0XFx0Y3VycmVudFQgPSBjdXJyZW50VCArIGluY3JlbWVudDtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdHJldHVybiBwMCArICgocDEgLSBwMCkgKiB0KTtcXG59XFxuXFxuZm4gQ2FsY3VsYXRlU3VyZmFjZU5vcm1hbChwOiB2ZWMzPGYzMj4pIC0+IHZlYzM8ZjMyPlxcbntcXG5cXHRsZXQgSDogZjMyID0gdW5pZm9ybXMuc3RyaWRlOyAvLyBUaGlzIG5lZWRzIHRvIHNjYWxlIGJhc2VkIG9uIHNvbWV0aGluZy4uLlxcblxcdGxldCBkeDogZjMyID0gZ2V0RGVuc2l0eShwICsgdmVjMzxmMzI+KEgsIDAuMCwgMC4wKSkgLSBnZXREZW5zaXR5KHAgLSB2ZWMzPGYzMj4oSCwgMC4wLCAwLjApKTtcXG5cXHRsZXQgZHk6IGYzMiA9IGdldERlbnNpdHkocCArIHZlYzM8ZjMyPigwLjAsIEgsIDAuMCkpIC0gZ2V0RGVuc2l0eShwIC0gdmVjMzxmMzI+KDAuMCwgSCwgMC4wKSk7XFxuXFx0bGV0IGR6OiBmMzIgPSBnZXREZW5zaXR5KHAgKyB2ZWMzPGYzMj4oMC4wLCAwLjAsIEgpKSAtIGdldERlbnNpdHkocCAtIHZlYzM8ZjMyPigwLjAsIDAuMCwgSCkpO1xcblxcblxcdHJldHVybiBub3JtYWxpemUodmVjMzxmMzI+KGR4LCBkeSwgZHopKTtcXG59XFxuXFxuQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKDEyOClcXG5mbiBtYWluKEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBHbG9iYWxJbnZvY2F0aW9uSUQgOiB2ZWMzPHUzMj4pIHtcXG5cXHRsZXQgdHJ1ZUluZGV4OiB1MzIgPSBHbG9iYWxJbnZvY2F0aW9uSUQueDtcXG5cXG5cXHRpZiAodHJ1ZUluZGV4IDwgY29ybmVySW5kZXguY29ybmVyQ291bnQpXFxuXFx0e1xcblxcdFxcdGxldCB1cmVzOiB1MzIgPSAzMnU7XFxuXFxuXFx0XFx0bGV0IG5vZGVTaXplOiB1MzIgPSB1MzIodW5pZm9ybXMuc3RyaWRlKTtcXG5cXG5cXHRcXHRsZXQgdm94ZWxJbmRleDogdTMyID0gY29ybmVySW5kZXguY29ybmVySW5kZXhlc1t0cnVlSW5kZXhdO1xcblxcdFxcdGxldCB6OiB1MzIgPSB2b3hlbEluZGV4IC8gKHVyZXMgKiB1cmVzKTtcXG5cXHRcXHRsZXQgeTogdTMyID0gKHZveGVsSW5kZXggLSAoeiAqIHVyZXMgKiB1cmVzKSkgLyB1cmVzO1xcblxcdFxcdGxldCB4OiB1MzIgPSB2b3hlbEluZGV4IC0gKHogKiB1cmVzICogdXJlcykgLSAoeSAqIHVyZXMpO1xcblxcblxcdFxcdGxldCBjb3JuZXJzOiB1MzIgPSB2b3hlbE1hdGVyaWFscy52b3hlbE1hdGVyaWFsc1t2b3hlbEluZGV4XTtcXG5cXG5cXHRcXHRsZXQgbm9kZVBvczogdmVjMzxmMzI+ID0gKHZlYzM8ZjMyPihmMzIoeCksIGYzMih5KSwgZjMyICh6KSkgKiB1bmlmb3Jtcy5zdHJpZGUpICsgdW5pZm9ybXMuY2h1bmtQb3NpdGlvbjtcXG5cXHRcXHR2b3hlbHMudm94ZWxzW3RydWVJbmRleF0udm94TWluID0gbm9kZVBvcztcXG5cXHRcXHRsZXQgTUFYX0NST1NTSU5HUzogaTMyID0gNjtcXG5cXHRcXHR2YXIgZWRnZUNvdW50OiBpMzIgPSAwO1xcblxcblxcdFxcdHBvaW50YWNjdW0gPSB2ZWM0PGYzMj4oMC4wLCAwLjAsIDAuMCwgMC4wKTtcXG5cXHRcXHRBVEEgPSBhcnJheTxmMzIsIDY+KDAuMCwgMC4wLCAwLjAsIDAuMCwgMC4wLCAwLjApO1xcblxcdFxcdEF0YiA9IHZlYzQ8ZjMyPigwLjAsIDAuMCwgMC4wLCAwLjApO1xcblxcdFxcdHZhciBhdmVyYWdlTm9ybWFsOiB2ZWMzPGYzMj4gPSB2ZWMzPGYzMj4oMC4wLCAwLjAsIDAuMCk7XFxuXFx0XFx0YnRiID0gMC4wO1xcblxcblxcdFxcdHZhciBqOiBpMzIgPSAwO1xcblxcdFxcdGxvb3Age1xcblxcdFxcdFxcdGlmICghKGogPCAxMiAmJiBlZGdlQ291bnQgPD0gTUFYX0NST1NTSU5HUykpIHtcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0bGV0IGMxOiBpMzIgPSBlZGdldm1hcFtqXS54O1xcblxcdFxcdFxcdGxldCBjMjogaTMyID0gZWRnZXZtYXBbal0ueTtcXG5cXG5cXHRcXHRcXHRsZXQgbTE6IHUzMiA9IChjb3JuZXJzID4+IHUzMihjMSkpICYgMXU7XFxuXFx0XFx0XFx0bGV0IG0yOiB1MzIgPSAoY29ybmVycyA+PiB1MzIoYzIpKSAmIDF1O1xcblxcblxcdFxcdFxcdGlmICghKChtMSA9PSAwdSAmJiBtMiA9PSAwdSkgfHwgKG0xID09IDF1ICYmIG0yID09IDF1KSkpXFxuXFx0XFx0XFx0e1xcblxcdFxcdFxcdFxcdGxldCBwMTogdmVjMzxmMzI+ID0gbm9kZVBvcyArIHZlYzM8ZjMyPihmMzIoQ0hJTERfTUlOX09GRlNFVFNbYzFdLnggKiBub2RlU2l6ZSksIGYzMihDSElMRF9NSU5fT0ZGU0VUU1tjMV0ueSAqIG5vZGVTaXplKSwgZjMyKENISUxEX01JTl9PRkZTRVRTW2MxXS56ICogbm9kZVNpemUpKTtcXG5cXHRcXHRcXHRcXHRsZXQgcDI6IHZlYzM8ZjMyPiA9IG5vZGVQb3MgKyB2ZWMzPGYzMj4oZjMyKENISUxEX01JTl9PRkZTRVRTW2MyXS54ICogbm9kZVNpemUpLCBmMzIoQ0hJTERfTUlOX09GRlNFVFNbYzJdLnkgKiBub2RlU2l6ZSksIGYzMihDSElMRF9NSU5fT0ZGU0VUU1tjMl0ueiAqIG5vZGVTaXplKSk7XFxuXFx0XFx0XFx0XFx0bGV0IHA6IHZlYzM8ZjMyPiA9IEFwcHJveGltYXRlWmVyb0Nyb3NzaW5nUG9zaXRpb24ocDEsIHAyKTtcXG5cXHRcXHRcXHRcXHRsZXQgbjogdmVjMzxmMzI+ID0gQ2FsY3VsYXRlU3VyZmFjZU5vcm1hbChwKTtcXG5cXG5cXHRcXHRcXHRcXHRxZWZfYWRkKHZlYzQ8ZjMyPihuLngsIG4ueSwgbi56LCAwLjApLCB2ZWM0PGYzMj4ocC54LCBwLnksIHAueiwgMC4wKSk7XFxuXFxuXFx0XFx0XFx0XFx0YXZlcmFnZU5vcm1hbCA9IGF2ZXJhZ2VOb3JtYWwgKyBuO1xcblxcblxcdFxcdFxcdFxcdGVkZ2VDb3VudCA9IGVkZ2VDb3VudCArIDE7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGNvbnRpbnVpbmcge1xcblxcdFxcdFxcdFxcdGogPSBqICsgMTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcblxcdFxcdGF2ZXJhZ2VOb3JtYWwgPSBub3JtYWxpemUoYXZlcmFnZU5vcm1hbCAvIHZlYzM8ZjMyPihmMzIoZWRnZUNvdW50KSwgZjMyKGVkZ2VDb3VudCksIGYzMihlZGdlQ291bnQpKSk7XFxuXFxuXFx0XFx0bGV0IGNvbTogdmVjMzxmMzI+ID0gdmVjMzxmMzI+KHBvaW50YWNjdW0ueCAvIHBvaW50YWNjdW0udywgcG9pbnRhY2N1bS55IC8gcG9pbnRhY2N1bS53LCBwb2ludGFjY3VtLnogLyBwb2ludGFjY3VtLncpO1xcblxcblxcdFxcdGxldCByZXN1bHQ6IHZlYzQ8ZjMyPiA9IHFlZl9zb2x2ZSgpO1xcblxcdFxcdHZhciBzb2x2ZWRfcG9zaXRpb246IHZlYzM8ZjMyPiA9IHJlc3VsdC54eXo7XFxuXFx0XFx0bGV0IGVycm9yOiBmMzIgPSByZXN1bHQudztcXG5cXG5cXG5cXHRcXHRsZXQgTWluOiB2ZWMzPGYzMj4gPSBub2RlUG9zO1xcblxcdFxcdGxldCBNYXg6IHZlYzM8ZjMyPiA9IG5vZGVQb3MgKyB2ZWMzPGYzMj4oMS4wLCAxLjAsIDEuMCk7XFxuXFx0XFx0aWYgKHNvbHZlZF9wb3NpdGlvbi54IDwgTWluLnggfHwgc29sdmVkX3Bvc2l0aW9uLnggPiBNYXgueCB8fFxcblxcdFxcdFxcdFxcdHNvbHZlZF9wb3NpdGlvbi55IDwgTWluLnkgfHwgc29sdmVkX3Bvc2l0aW9uLnkgPiBNYXgueSB8fFxcblxcdFxcdFxcdFxcdHNvbHZlZF9wb3NpdGlvbi56IDwgTWluLnogfHwgc29sdmVkX3Bvc2l0aW9uLnogPiBNYXgueilcXG5cXHRcXHR7XFxuXFx0XFx0XFx0c29sdmVkX3Bvc2l0aW9uID0gY29tO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR2b3hlbHMudm94ZWxzW3RydWVJbmRleF0udmVydFBvaW50ID0gc29sdmVkX3Bvc2l0aW9uO1xcblxcdFxcdHZveGVscy52b3hlbHNbdHJ1ZUluZGV4XS5hdmdOb3JtYWwgPSBhdmVyYWdlTm9ybWFsO1xcblxcdFxcdHZveGVscy52b3hlbHNbdHJ1ZUluZGV4XS5udW1Qb2ludHMgPSBmMzIoZWRnZUNvdW50KTtcXG5cXHRcXHR2b3hlbHMudm94ZWxzW3RydWVJbmRleF0uY29ybmVycyA9IGYzMih2b3hlbE1hdGVyaWFscy52b3hlbE1hdGVyaWFsc1t2b3hlbEluZGV4XSk7XFxuXFx0fVxcbn1cXG5cXG5AY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoMSlcXG5mbiBjb21wdXRlTWF0ZXJpYWxzKEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBHbG9iYWxJbnZvY2F0aW9uSUQgOiB2ZWMzPHUzMj4pIHtcXG5cXHRcXHRsZXQgd2lkdGggPSB1bmlmb3Jtcy53aWR0aDtcXG4gICAgbGV0IGluZGV4OiB1MzIgPSBHbG9iYWxJbnZvY2F0aW9uSUQueiAqIHdpZHRoICogd2lkdGggKyBHbG9iYWxJbnZvY2F0aW9uSUQueSAqIHdpZHRoICsgR2xvYmFsSW52b2NhdGlvbklELng7XFxuICAgIGxldCBjb3JuZXJQb3M6IHZlYzM8ZjMyPiA9IHZlYzM8ZjMyPihmMzIoR2xvYmFsSW52b2NhdGlvbklELngpICogdW5pZm9ybXMuc3RyaWRlLCBmMzIoR2xvYmFsSW52b2NhdGlvbklELnkpICogdW5pZm9ybXMuc3RyaWRlLCBmMzIoR2xvYmFsSW52b2NhdGlvbklELnopICogdW5pZm9ybXMuc3RyaWRlKTtcXG5cXG4gICAgbGV0IGRlbnNpdHk6IGYzMiA9IGdldERlbnNpdHkoY29ybmVyUG9zICsgdW5pZm9ybXMuY2h1bmtQb3NpdGlvbik7XFxuXFxuXFx0XFx0aWYgKGRlbnNpdHkgPCAwLjApIHtcXG5cXHRcXHRcXHRpZiAobGVuZ3RoKGNvcm5lclBvcyArIHVuaWZvcm1zLmNodW5rUG9zaXRpb24pIDwgMjAwMC4wKSB7XFxuICAgICAgICAvL2Nvcm5lck1hdGVyaWFscy5jb3JuZXJNYXRlcmlhbHNbaW5kZXhdID0gdTMyKHJhbmRvbSh2ZWMyKGYzMihpbmRleCkpKSAqIDI1NS4wKSArIDE7XFxuXFx0XFx0XFx0ICBjb3JuZXJNYXRlcmlhbHMuY29ybmVyTWF0ZXJpYWxzW2luZGV4XSA9IDI1NnU7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG4gICAgICAgIGNvcm5lck1hdGVyaWFscy5jb3JuZXJNYXRlcmlhbHNbaW5kZXhdID0gdTMyKGxlbmd0aChjb3JuZXJQb3MpIC8gdW5pZm9ybXMuc3RyaWRlICogMjU2LjApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGNvcm5lck1hdGVyaWFscy5jb3JuZXJNYXRlcmlhbHNbaW5kZXhdID0gMHU7XFxuXFx0XFx0fVxcbn1cXG5cXG5AY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoMSlcXG5mbiBjb21wdXRlUGh5c2ljcyhAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgR2xvYmFsSW52b2NhdGlvbklEIDogdmVjMzx1MzI+KSB7XFxuICBsZXQgYWN0b3I6IHUzMiA9IEdsb2JhbEludm9jYXRpb25JRC54O1xcblxcbiAgaWYgKGdldERlbnNpdHkocGh5c2ljcy5hY3RvcnNbYWN0b3JdLnBvc2l0aW9uKSA8IDAuMCkge1xcbiAgICBwaHlzaWNzLmFjdG9yc1thY3Rvcl0ucG9zaXRpb24gPSBwaHlzaWNzLmFjdG9yc1thY3Rvcl0ucG9zaXRpb24gKyB2ZWMzPGYzMj4oMTAuMCwgMC4wLCAwLjApO1xcbiAgfVxcblxcbiAgbGV0IGRpcmVjdGlvbiA9IG5vcm1hbGl6ZShwaHlzaWNzLmFjdG9yc1thY3Rvcl0udmVsb2NpdHkpO1xcbiAgbGV0IHBvcyA9IHBoeXNpY3MuYWN0b3JzW2FjdG9yXS5wb3NpdGlvbiArIHBoeXNpY3MuYWN0b3JzW2FjdG9yXS52ZWxvY2l0eTtcXG5cXG4gIGlmIChnZXREZW5zaXR5KHBvcyArIChkaXJlY3Rpb24gKiA1MC4wKSkgPj0gMC4wKSB7XFxuICAgIHBoeXNpY3MuYWN0b3JzW2FjdG9yXS5wb3NpdGlvbiA9IHBvcztcXG4gIH1cXG59XCI7IiwiLy8gQSBsaWJyYXJ5IG9mIHNlZWRhYmxlIFJOR3MgaW1wbGVtZW50ZWQgaW4gSmF2YXNjcmlwdC5cbi8vXG4vLyBVc2FnZTpcbi8vXG4vLyB2YXIgc2VlZHJhbmRvbSA9IHJlcXVpcmUoJ3NlZWRyYW5kb20nKTtcbi8vIHZhciByYW5kb20gPSBzZWVkcmFuZG9tKDEpOyAvLyBvciBhbnkgc2VlZC5cbi8vIHZhciB4ID0gcmFuZG9tKCk7ICAgICAgIC8vIDAgPD0geCA8IDEuICBFdmVyeSBiaXQgaXMgcmFuZG9tLlxuLy8gdmFyIHggPSByYW5kb20ucXVpY2soKTsgLy8gMCA8PSB4IDwgMS4gIDMyIGJpdHMgb2YgcmFuZG9tbmVzcy5cblxuLy8gYWxlYSwgYSA1My1iaXQgbXVsdGlwbHktd2l0aC1jYXJyeSBnZW5lcmF0b3IgYnkgSm9oYW5uZXMgQmFhZ8O4ZS5cbi8vIFBlcmlvZDogfjJeMTE2XG4vLyBSZXBvcnRlZCB0byBwYXNzIGFsbCBCaWdDcnVzaCB0ZXN0cy5cbnZhciBhbGVhID0gcmVxdWlyZSgnLi9saWIvYWxlYScpO1xuXG4vLyB4b3IxMjgsIGEgcHVyZSB4b3Itc2hpZnQgZ2VuZXJhdG9yIGJ5IEdlb3JnZSBNYXJzYWdsaWEuXG4vLyBQZXJpb2Q6IDJeMTI4LTEuXG4vLyBSZXBvcnRlZCB0byBmYWlsOiBNYXRyaXhSYW5rIGFuZCBMaW5lYXJDb21wLlxudmFyIHhvcjEyOCA9IHJlcXVpcmUoJy4vbGliL3hvcjEyOCcpO1xuXG4vLyB4b3J3b3csIEdlb3JnZSBNYXJzYWdsaWEncyAxNjAtYml0IHhvci1zaGlmdCBjb21iaW5lZCBwbHVzIHdleWwuXG4vLyBQZXJpb2Q6IDJeMTkyLTJeMzJcbi8vIFJlcG9ydGVkIHRvIGZhaWw6IENvbGxpc2lvbk92ZXIsIFNpbXBQb2tlciwgYW5kIExpbmVhckNvbXAuXG52YXIgeG9yd293ID0gcmVxdWlyZSgnLi9saWIveG9yd293Jyk7XG5cbi8vIHhvcnNoaWZ0NywgYnkgRnJhbsOnb2lzIFBhbm5ldG9uIGFuZCBQaWVycmUgTCdlY3V5ZXIsIHRha2VzXG4vLyBhIGRpZmZlcmVudCBhcHByb2FjaDogaXQgYWRkcyByb2J1c3RuZXNzIGJ5IGFsbG93aW5nIG1vcmUgc2hpZnRzXG4vLyB0aGFuIE1hcnNhZ2xpYSdzIG9yaWdpbmFsIHRocmVlLiAgSXQgaXMgYSA3LXNoaWZ0IGdlbmVyYXRvclxuLy8gd2l0aCAyNTYgYml0cywgdGhhdCBwYXNzZXMgQmlnQ3J1c2ggd2l0aCBubyBzeXN0bWF0aWMgZmFpbHVyZXMuXG4vLyBQZXJpb2QgMl4yNTYtMS5cbi8vIE5vIHN5c3RlbWF0aWMgQmlnQ3J1c2ggZmFpbHVyZXMgcmVwb3J0ZWQuXG52YXIgeG9yc2hpZnQ3ID0gcmVxdWlyZSgnLi9saWIveG9yc2hpZnQ3Jyk7XG5cbi8vIHhvcjQwOTYsIGJ5IFJpY2hhcmQgQnJlbnQsIGlzIGEgNDA5Ni1iaXQgeG9yLXNoaWZ0IHdpdGggYVxuLy8gdmVyeSBsb25nIHBlcmlvZCB0aGF0IGFsc28gYWRkcyBhIFdleWwgZ2VuZXJhdG9yLiBJdCBhbHNvIHBhc3Nlc1xuLy8gQmlnQ3J1c2ggd2l0aCBubyBzeXN0ZW1hdGljIGZhaWx1cmVzLiAgSXRzIGxvbmcgcGVyaW9kIG1heVxuLy8gYmUgdXNlZnVsIGlmIHlvdSBoYXZlIG1hbnkgZ2VuZXJhdG9ycyBhbmQgbmVlZCB0byBhdm9pZFxuLy8gY29sbGlzaW9ucy5cbi8vIFBlcmlvZDogMl40MTI4LTJeMzIuXG4vLyBObyBzeXN0ZW1hdGljIEJpZ0NydXNoIGZhaWx1cmVzIHJlcG9ydGVkLlxudmFyIHhvcjQwOTYgPSByZXF1aXJlKCcuL2xpYi94b3I0MDk2Jyk7XG5cbi8vIFR5Y2hlLWksIGJ5IFNhbXVlbCBOZXZlcyBhbmQgRmlsaXBlIEFyYXVqbywgaXMgYSBiaXQtc2hpZnRpbmcgcmFuZG9tXG4vLyBudW1iZXIgZ2VuZXJhdG9yIGRlcml2ZWQgZnJvbSBDaGFDaGEsIGEgbW9kZXJuIHN0cmVhbSBjaXBoZXIuXG4vLyBodHRwczovL2VkZW4uZGVpLnVjLnB0L35zbmV2ZXMvcHVicy8yMDExLXNuZmEyLnBkZlxuLy8gUGVyaW9kOiB+Ml4xMjdcbi8vIE5vIHN5c3RlbWF0aWMgQmlnQ3J1c2ggZmFpbHVyZXMgcmVwb3J0ZWQuXG52YXIgdHljaGVpID0gcmVxdWlyZSgnLi9saWIvdHljaGVpJyk7XG5cbi8vIFRoZSBvcmlnaW5hbCBBUkM0LWJhc2VkIHBybmcgaW5jbHVkZWQgaW4gdGhpcyBsaWJyYXJ5LlxuLy8gUGVyaW9kOiB+Ml4xNjAwXG52YXIgc3IgPSByZXF1aXJlKCcuL3NlZWRyYW5kb20nKTtcblxuc3IuYWxlYSA9IGFsZWE7XG5zci54b3IxMjggPSB4b3IxMjg7XG5zci54b3J3b3cgPSB4b3J3b3c7XG5zci54b3JzaGlmdDcgPSB4b3JzaGlmdDc7XG5zci54b3I0MDk2ID0geG9yNDA5NjtcbnNyLnR5Y2hlaSA9IHR5Y2hlaTtcblxubW9kdWxlLmV4cG9ydHMgPSBzcjtcbiIsIi8vIEEgcG9ydCBvZiBhbiBhbGdvcml0aG0gYnkgSm9oYW5uZXMgQmFhZ8O4ZSA8YmFhZ29lQGJhYWdvZS5jb20+LCAyMDEwXG4vLyBodHRwOi8vYmFhZ29lLmNvbS9lbi9SYW5kb21NdXNpbmdzL2phdmFzY3JpcHQvXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbnF1aW5sYW4vYmV0dGVyLXJhbmRvbS1udW1iZXJzLWZvci1qYXZhc2NyaXB0LW1pcnJvclxuLy8gT3JpZ2luYWwgd29yayBpcyB1bmRlciBNSVQgbGljZW5zZSAtXG5cbi8vIENvcHlyaWdodCAoQykgMjAxMCBieSBKb2hhbm5lcyBCYWFnw7hlIDxiYWFnb2VAYmFhZ29lLm9yZz5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5cblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gQWxlYShzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXMsIG1hc2ggPSBNYXNoKCk7XG5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gMjA5MTYzOSAqIG1lLnMwICsgbWUuYyAqIDIuMzI4MzA2NDM2NTM4Njk2M2UtMTA7IC8vIDJeLTMyXG4gICAgbWUuczAgPSBtZS5zMTtcbiAgICBtZS5zMSA9IG1lLnMyO1xuICAgIHJldHVybiBtZS5zMiA9IHQgLSAobWUuYyA9IHQgfCAwKTtcbiAgfTtcblxuICAvLyBBcHBseSB0aGUgc2VlZGluZyBhbGdvcml0aG0gZnJvbSBCYWFnb2UuXG4gIG1lLmMgPSAxO1xuICBtZS5zMCA9IG1hc2goJyAnKTtcbiAgbWUuczEgPSBtYXNoKCcgJyk7XG4gIG1lLnMyID0gbWFzaCgnICcpO1xuICBtZS5zMCAtPSBtYXNoKHNlZWQpO1xuICBpZiAobWUuczAgPCAwKSB7IG1lLnMwICs9IDE7IH1cbiAgbWUuczEgLT0gbWFzaChzZWVkKTtcbiAgaWYgKG1lLnMxIDwgMCkgeyBtZS5zMSArPSAxOyB9XG4gIG1lLnMyIC09IG1hc2goc2VlZCk7XG4gIGlmIChtZS5zMiA8IDApIHsgbWUuczIgKz0gMTsgfVxuICBtYXNoID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuYyA9IGYuYztcbiAgdC5zMCA9IGYuczA7XG4gIHQuczEgPSBmLnMxO1xuICB0LnMyID0gZi5zMjtcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICB2YXIgeGcgPSBuZXcgQWxlYShzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IHhnLm5leHQ7XG4gIHBybmcuaW50MzIgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgKiAweDEwMDAwMDAwMCkgfCAwOyB9XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHBybmcoKSArIChwcm5nKCkgKiAweDIwMDAwMCB8IDApICogMS4xMTAyMjMwMjQ2MjUxNTY1ZS0xNjsgLy8gMl4tNTNcbiAgfTtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmICh0eXBlb2Yoc3RhdGUpID09ICdvYmplY3QnKSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmZ1bmN0aW9uIE1hc2goKSB7XG4gIHZhciBuID0gMHhlZmM4MjQ5ZDtcblxuICB2YXIgbWFzaCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBkYXRhID0gU3RyaW5nKGRhdGEpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgbiArPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgICB2YXIgaCA9IDAuMDI1MTk2MDMyODI0MTY5MzggKiBuO1xuICAgICAgbiA9IGggPj4+IDA7XG4gICAgICBoIC09IG47XG4gICAgICBoICo9IG47XG4gICAgICBuID0gaCA+Pj4gMDtcbiAgICAgIGggLT0gbjtcbiAgICAgIG4gKz0gaCAqIDB4MTAwMDAwMDAwOyAvLyAyXjMyXG4gICAgfVxuICAgIHJldHVybiAobiA+Pj4gMCkgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxuICB9O1xuXG4gIHJldHVybiBtYXNoO1xufVxuXG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMuYWxlYSA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cblxuIiwiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgdGhlIFwiVHljaGUtaVwiIHBybmcgYWxnb3JpdGhtIGJ5XG4vLyBTYW11ZWwgTmV2ZXMgYW5kIEZpbGlwZSBBcmF1am8uXG4vLyBTZWUgaHR0cHM6Ly9lZGVuLmRlaS51Yy5wdC9+c25ldmVzL3B1YnMvMjAxMS1zbmZhMi5wZGZcblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gWG9yR2VuKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcywgc3Ryc2VlZCA9ICcnO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYiA9IG1lLmIsIGMgPSBtZS5jLCBkID0gbWUuZCwgYSA9IG1lLmE7XG4gICAgYiA9IChiIDw8IDI1KSBeIChiID4+PiA3KSBeIGM7XG4gICAgYyA9IChjIC0gZCkgfCAwO1xuICAgIGQgPSAoZCA8PCAyNCkgXiAoZCA+Pj4gOCkgXiBhO1xuICAgIGEgPSAoYSAtIGIpIHwgMDtcbiAgICBtZS5iID0gYiA9IChiIDw8IDIwKSBeIChiID4+PiAxMikgXiBjO1xuICAgIG1lLmMgPSBjID0gKGMgLSBkKSB8IDA7XG4gICAgbWUuZCA9IChkIDw8IDE2KSBeIChjID4+PiAxNikgXiBhO1xuICAgIHJldHVybiBtZS5hID0gKGEgLSBiKSB8IDA7XG4gIH07XG5cbiAgLyogVGhlIGZvbGxvd2luZyBpcyBub24taW52ZXJ0ZWQgdHljaGUsIHdoaWNoIGhhcyBiZXR0ZXIgaW50ZXJuYWxcbiAgICogYml0IGRpZmZ1c2lvbiwgYnV0IHdoaWNoIGlzIGFib3V0IDI1JSBzbG93ZXIgdGhhbiB0eWNoZS1pIGluIEpTLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGEgPSBtZS5hLCBiID0gbWUuYiwgYyA9IG1lLmMsIGQgPSBtZS5kO1xuICAgIGEgPSAobWUuYSArIG1lLmIgfCAwKSA+Pj4gMDtcbiAgICBkID0gbWUuZCBeIGE7IGQgPSBkIDw8IDE2IF4gZCA+Pj4gMTY7XG4gICAgYyA9IG1lLmMgKyBkIHwgMDtcbiAgICBiID0gbWUuYiBeIGM7IGIgPSBiIDw8IDEyIF4gZCA+Pj4gMjA7XG4gICAgbWUuYSA9IGEgPSBhICsgYiB8IDA7XG4gICAgZCA9IGQgXiBhOyBtZS5kID0gZCA9IGQgPDwgOCBeIGQgPj4+IDI0O1xuICAgIG1lLmMgPSBjID0gYyArIGQgfCAwO1xuICAgIGIgPSBiIF4gYztcbiAgICByZXR1cm4gbWUuYiA9IChiIDw8IDcgXiBiID4+PiAyNSk7XG4gIH1cbiAgKi9cblxuICBtZS5hID0gMDtcbiAgbWUuYiA9IDA7XG4gIG1lLmMgPSAyNjU0NDM1NzY5IHwgMDtcbiAgbWUuZCA9IDEzNjcxMzA1NTE7XG5cbiAgaWYgKHNlZWQgPT09IE1hdGguZmxvb3Ioc2VlZCkpIHtcbiAgICAvLyBJbnRlZ2VyIHNlZWQuXG4gICAgbWUuYSA9IChzZWVkIC8gMHgxMDAwMDAwMDApIHwgMDtcbiAgICBtZS5iID0gc2VlZCB8IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RyaW5nIHNlZWQuXG4gICAgc3Ryc2VlZCArPSBzZWVkO1xuICB9XG5cbiAgLy8gTWl4IGluIHN0cmluZyBzZWVkLCB0aGVuIGRpc2NhcmQgYW4gaW5pdGlhbCBiYXRjaCBvZiA2NCB2YWx1ZXMuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgc3Ryc2VlZC5sZW5ndGggKyAyMDsgaysrKSB7XG4gICAgbWUuYiBePSBzdHJzZWVkLmNoYXJDb2RlQXQoaykgfCAwO1xuICAgIG1lLm5leHQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC5hID0gZi5hO1xuICB0LmIgPSBmLmI7XG4gIHQuYyA9IGYuYztcbiAgdC5kID0gZi5kO1xuICByZXR1cm4gdDtcbn07XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICB2YXIgeGcgPSBuZXcgWG9yR2VuKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwOyB9O1xuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvIHtcbiAgICAgIHZhciB0b3AgPSB4Zy5uZXh0KCkgPj4+IDExLFxuICAgICAgICAgIGJvdCA9ICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDAsXG4gICAgICAgICAgcmVzdWx0ID0gKHRvcCArIGJvdCkgLyAoMSA8PCAyMSk7XG4gICAgfSB3aGlsZSAocmVzdWx0ID09PSAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm5nLmludDMyID0geGcubmV4dDtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmICh0eXBlb2Yoc3RhdGUpID09ICdvYmplY3QnKSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMudHljaGVpID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcblxuXG4iLCIvLyBBIEphdmFzY3JpcHQgaW1wbGVtZW50YWlvbiBvZiB0aGUgXCJ4b3IxMjhcIiBwcm5nIGFsZ29yaXRobSBieVxuLy8gR2VvcmdlIE1hcnNhZ2xpYS4gIFNlZSBodHRwOi8vd3d3LmpzdGF0c29mdC5vcmcvdjA4L2kxNC9wYXBlclxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBYb3JHZW4oc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzLCBzdHJzZWVkID0gJyc7XG5cbiAgbWUueCA9IDA7XG4gIG1lLnkgPSAwO1xuICBtZS56ID0gMDtcbiAgbWUudyA9IDA7XG5cbiAgLy8gU2V0IHVwIGdlbmVyYXRvciBmdW5jdGlvbi5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gbWUueCBeIChtZS54IDw8IDExKTtcbiAgICBtZS54ID0gbWUueTtcbiAgICBtZS55ID0gbWUuejtcbiAgICBtZS56ID0gbWUudztcbiAgICByZXR1cm4gbWUudyBePSAobWUudyA+Pj4gMTkpIF4gdCBeICh0ID4+PiA4KTtcbiAgfTtcblxuICBpZiAoc2VlZCA9PT0gKHNlZWQgfCAwKSkge1xuICAgIC8vIEludGVnZXIgc2VlZC5cbiAgICBtZS54ID0gc2VlZDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdHJpbmcgc2VlZC5cbiAgICBzdHJzZWVkICs9IHNlZWQ7XG4gIH1cblxuICAvLyBNaXggaW4gc3RyaW5nIHNlZWQsIHRoZW4gZGlzY2FyZCBhbiBpbml0aWFsIGJhdGNoIG9mIDY0IHZhbHVlcy5cbiAgZm9yICh2YXIgayA9IDA7IGsgPCBzdHJzZWVkLmxlbmd0aCArIDY0OyBrKyspIHtcbiAgICBtZS54IF49IHN0cnNlZWQuY2hhckNvZGVBdChrKSB8IDA7XG4gICAgbWUubmV4dCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LnggPSBmLng7XG4gIHQueSA9IGYueTtcbiAgdC56ID0gZi56O1xuICB0LncgPSBmLnc7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnhvcjEyOCA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cblxuIiwiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgUmljaGFyZCBCcmVudCdzIFhvcmdlbnMgeG9yNDA5NiBhbGdvcml0aG0uXG4vL1xuLy8gVGhpcyBmYXN0IG5vbi1jcnlwdG9ncmFwaGljIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIGlzIGRlc2lnbmVkIGZvclxuLy8gdXNlIGluIE1vbnRlLUNhcmxvIGFsZ29yaXRobXMuIEl0IGNvbWJpbmVzIGEgbG9uZy1wZXJpb2QgeG9yc2hpZnRcbi8vIGdlbmVyYXRvciB3aXRoIGEgV2V5bCBnZW5lcmF0b3IsIGFuZCBpdCBwYXNzZXMgYWxsIGNvbW1vbiBiYXR0ZXJpZXNcbi8vIG9mIHN0YXN0aWNpYWwgdGVzdHMgZm9yIHJhbmRvbW5lc3Mgd2hpbGUgY29uc3VtaW5nIG9ubHkgYSBmZXcgbmFub3NlY29uZHNcbi8vIGZvciBlYWNoIHBybmcgZ2VuZXJhdGVkLiAgRm9yIGJhY2tncm91bmQgb24gdGhlIGdlbmVyYXRvciwgc2VlIEJyZW50J3Ncbi8vIHBhcGVyOiBcIlNvbWUgbG9uZy1wZXJpb2QgcmFuZG9tIG51bWJlciBnZW5lcmF0b3JzIHVzaW5nIHNoaWZ0cyBhbmQgeG9ycy5cIlxuLy8gaHR0cDovL2FyeGl2Lm9yZy9wZGYvMTAwNC4zMTE1djEucGRmXG4vL1xuLy8gVXNhZ2U6XG4vL1xuLy8gdmFyIHhvcjQwOTYgPSByZXF1aXJlKCd4b3I0MDk2Jyk7XG4vLyByYW5kb20gPSB4b3I0MDk2KDEpOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZWQgd2l0aCBpbnQzMiBvciBzdHJpbmcuXG4vLyBhc3NlcnQuZXF1YWwocmFuZG9tKCksIDAuMTUyMDQzNjQ1MDUzODU0Nyk7IC8vICgwLCAxKSByYW5nZSwgNTMgYml0cy5cbi8vIGFzc2VydC5lcXVhbChyYW5kb20uaW50MzIoKSwgMTgwNjUzNDg5Nyk7ICAgLy8gc2lnbmVkIGludDMyLCAzMiBiaXRzLlxuLy9cbi8vIEZvciBub256ZXJvIG51bWVyaWMga2V5cywgdGhpcyBpbXBlbGVtZW50YXRpb24gcHJvdmlkZXMgYSBzZXF1ZW5jZVxuLy8gaWRlbnRpY2FsIHRvIHRoYXQgYnkgQnJlbnQncyB4b3JnZW5zIDMgaW1wbGVtZW50YWlvbiBpbiBDLiAgVGhpc1xuLy8gaW1wbGVtZW50YXRpb24gYWxzbyBwcm92aWRlcyBmb3IgaW5pdGFsaXppbmcgdGhlIGdlbmVyYXRvciB3aXRoXG4vLyBzdHJpbmcgc2VlZHMsIG9yIGZvciBzYXZpbmcgYW5kIHJlc3RvcmluZyB0aGUgc3RhdGUgb2YgdGhlIGdlbmVyYXRvci5cbi8vXG4vLyBPbiBDaHJvbWUsIHRoaXMgcHJuZyBiZW5jaG1hcmtzIGFib3V0IDIuMSB0aW1lcyBzbG93ZXIgdGhhblxuLy8gSmF2YXNjcmlwdCdzIGJ1aWx0LWluIE1hdGgucmFuZG9tKCkuXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXM7XG5cbiAgLy8gU2V0IHVwIGdlbmVyYXRvciBmdW5jdGlvbi5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB3ID0gbWUudyxcbiAgICAgICAgWCA9IG1lLlgsIGkgPSBtZS5pLCB0LCB2O1xuICAgIC8vIFVwZGF0ZSBXZXlsIGdlbmVyYXRvci5cbiAgICBtZS53ID0gdyA9ICh3ICsgMHg2MWM4ODY0NykgfCAwO1xuICAgIC8vIFVwZGF0ZSB4b3IgZ2VuZXJhdG9yLlxuICAgIHYgPSBYWyhpICsgMzQpICYgMTI3XTtcbiAgICB0ID0gWFtpID0gKChpICsgMSkgJiAxMjcpXTtcbiAgICB2IF49IHYgPDwgMTM7XG4gICAgdCBePSB0IDw8IDE3O1xuICAgIHYgXj0gdiA+Pj4gMTU7XG4gICAgdCBePSB0ID4+PiAxMjtcbiAgICAvLyBVcGRhdGUgWG9yIGdlbmVyYXRvciBhcnJheSBzdGF0ZS5cbiAgICB2ID0gWFtpXSA9IHYgXiB0O1xuICAgIG1lLmkgPSBpO1xuICAgIC8vIFJlc3VsdCBpcyB0aGUgY29tYmluYXRpb24uXG4gICAgcmV0dXJuICh2ICsgKHcgXiAodyA+Pj4gMTYpKSkgfCAwO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGluaXQobWUsIHNlZWQpIHtcbiAgICB2YXIgdCwgdiwgaSwgaiwgdywgWCA9IFtdLCBsaW1pdCA9IDEyODtcbiAgICBpZiAoc2VlZCA9PT0gKHNlZWQgfCAwKSkge1xuICAgICAgLy8gTnVtZXJpYyBzZWVkcyBpbml0aWFsaXplIHYsIHdoaWNoIGlzIHVzZWQgdG8gZ2VuZXJhdGVzIFguXG4gICAgICB2ID0gc2VlZDtcbiAgICAgIHNlZWQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdHJpbmcgc2VlZHMgYXJlIG1peGVkIGludG8gdiBhbmQgWCBvbmUgY2hhcmFjdGVyIGF0IGEgdGltZS5cbiAgICAgIHNlZWQgPSBzZWVkICsgJ1xcMCc7XG4gICAgICB2ID0gMDtcbiAgICAgIGxpbWl0ID0gTWF0aC5tYXgobGltaXQsIHNlZWQubGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gSW5pdGlhbGl6ZSBjaXJjdWxhciBhcnJheSBhbmQgd2V5bCB2YWx1ZS5cbiAgICBmb3IgKGkgPSAwLCBqID0gLTMyOyBqIDwgbGltaXQ7ICsraikge1xuICAgICAgLy8gUHV0IHRoZSB1bmljb2RlIGNoYXJhY3RlcnMgaW50byB0aGUgYXJyYXksIGFuZCBzaHVmZmxlIHRoZW0uXG4gICAgICBpZiAoc2VlZCkgdiBePSBzZWVkLmNoYXJDb2RlQXQoKGogKyAzMikgJSBzZWVkLmxlbmd0aCk7XG4gICAgICAvLyBBZnRlciAzMiBzaHVmZmxlcywgdGFrZSB2IGFzIHRoZSBzdGFydGluZyB3IHZhbHVlLlxuICAgICAgaWYgKGogPT09IDApIHcgPSB2O1xuICAgICAgdiBePSB2IDw8IDEwO1xuICAgICAgdiBePSB2ID4+PiAxNTtcbiAgICAgIHYgXj0gdiA8PCA0O1xuICAgICAgdiBePSB2ID4+PiAxMztcbiAgICAgIGlmIChqID49IDApIHtcbiAgICAgICAgdyA9ICh3ICsgMHg2MWM4ODY0NykgfCAwOyAgICAgLy8gV2V5bC5cbiAgICAgICAgdCA9IChYW2ogJiAxMjddIF49ICh2ICsgdykpOyAgLy8gQ29tYmluZSB4b3IgYW5kIHdleWwgdG8gaW5pdCBhcnJheS5cbiAgICAgICAgaSA9ICgwID09IHQpID8gaSArIDEgOiAwOyAgICAgLy8gQ291bnQgemVyb2VzLlxuICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSBoYXZlIGRldGVjdGVkIGFsbCB6ZXJvZXM7IG1ha2UgdGhlIGtleSBub256ZXJvLlxuICAgIGlmIChpID49IDEyOCkge1xuICAgICAgWFsoc2VlZCAmJiBzZWVkLmxlbmd0aCB8fCAwKSAmIDEyN10gPSAtMTtcbiAgICB9XG4gICAgLy8gUnVuIHRoZSBnZW5lcmF0b3IgNTEyIHRpbWVzIHRvIGZ1cnRoZXIgbWl4IHRoZSBzdGF0ZSBiZWZvcmUgdXNpbmcgaXQuXG4gICAgLy8gRmFjdG9yaW5nIHRoaXMgYXMgYSBmdW5jdGlvbiBzbG93cyB0aGUgbWFpbiBnZW5lcmF0b3IsIHNvIGl0IGlzIGp1c3RcbiAgICAvLyB1bnJvbGxlZCBoZXJlLiAgVGhlIHdleWwgZ2VuZXJhdG9yIGlzIG5vdCBhZHZhbmNlZCB3aGlsZSB3YXJtaW5nIHVwLlxuICAgIGkgPSAxMjc7XG4gICAgZm9yIChqID0gNCAqIDEyODsgaiA+IDA7IC0taikge1xuICAgICAgdiA9IFhbKGkgKyAzNCkgJiAxMjddO1xuICAgICAgdCA9IFhbaSA9ICgoaSArIDEpICYgMTI3KV07XG4gICAgICB2IF49IHYgPDwgMTM7XG4gICAgICB0IF49IHQgPDwgMTc7XG4gICAgICB2IF49IHYgPj4+IDE1O1xuICAgICAgdCBePSB0ID4+PiAxMjtcbiAgICAgIFhbaV0gPSB2IF4gdDtcbiAgICB9XG4gICAgLy8gU3RvcmluZyBzdGF0ZSBhcyBvYmplY3QgbWVtYmVycyBpcyBmYXN0ZXIgdGhhbiB1c2luZyBjbG9zdXJlIHZhcmlhYmxlcy5cbiAgICBtZS53ID0gdztcbiAgICBtZS5YID0gWDtcbiAgICBtZS5pID0gaTtcbiAgfVxuXG4gIGluaXQobWUsIHNlZWQpO1xufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC5pID0gZi5pO1xuICB0LncgPSBmLnc7XG4gIHQuWCA9IGYuWC5zbGljZSgpO1xuICByZXR1cm4gdDtcbn07XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICBpZiAoc2VlZCA9PSBudWxsKSBzZWVkID0gKyhuZXcgRGF0ZSk7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLlgpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy54b3I0MDk2ID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbmRvdyBvYmplY3Qgb3IgZ2xvYmFsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcbiIsIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIHRoZSBcInhvcnNoaWZ0N1wiIGFsZ29yaXRobSBieVxuLy8gRnJhbsOnb2lzIFBhbm5ldG9uIGFuZCBQaWVycmUgTCdlY3V5ZXI6XG4vLyBcIk9uIHRoZSBYb3Jnc2hpZnQgUmFuZG9tIE51bWJlciBHZW5lcmF0b3JzXCJcbi8vIGh0dHA6Ly9zYWx1Yy5lbmdyLnVjb25uLmVkdS9yZWZzL2NyeXB0by9ybmcvcGFubmV0b24wNW9udGhleG9yc2hpZnQucGRmXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXM7XG5cbiAgLy8gU2V0IHVwIGdlbmVyYXRvciBmdW5jdGlvbi5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFVwZGF0ZSB4b3IgZ2VuZXJhdG9yLlxuICAgIHZhciBYID0gbWUueCwgaSA9IG1lLmksIHQsIHYsIHc7XG4gICAgdCA9IFhbaV07IHQgXj0gKHQgPj4+IDcpOyB2ID0gdCBeICh0IDw8IDI0KTtcbiAgICB0ID0gWFsoaSArIDEpICYgN107IHYgXj0gdCBeICh0ID4+PiAxMCk7XG4gICAgdCA9IFhbKGkgKyAzKSAmIDddOyB2IF49IHQgXiAodCA+Pj4gMyk7XG4gICAgdCA9IFhbKGkgKyA0KSAmIDddOyB2IF49IHQgXiAodCA8PCA3KTtcbiAgICB0ID0gWFsoaSArIDcpICYgN107IHQgPSB0IF4gKHQgPDwgMTMpOyB2IF49IHQgXiAodCA8PCA5KTtcbiAgICBYW2ldID0gdjtcbiAgICBtZS5pID0gKGkgKyAxKSAmIDc7XG4gICAgcmV0dXJuIHY7XG4gIH07XG5cbiAgZnVuY3Rpb24gaW5pdChtZSwgc2VlZCkge1xuICAgIHZhciBqLCB3LCBYID0gW107XG5cbiAgICBpZiAoc2VlZCA9PT0gKHNlZWQgfCAwKSkge1xuICAgICAgLy8gU2VlZCBzdGF0ZSBhcnJheSB1c2luZyBhIDMyLWJpdCBpbnRlZ2VyLlxuICAgICAgdyA9IFhbMF0gPSBzZWVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZWVkIHN0YXRlIHVzaW5nIGEgc3RyaW5nLlxuICAgICAgc2VlZCA9ICcnICsgc2VlZDtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBzZWVkLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIFhbaiAmIDddID0gKFhbaiAmIDddIDw8IDE1KSBeXG4gICAgICAgICAgICAoc2VlZC5jaGFyQ29kZUF0KGopICsgWFsoaiArIDEpICYgN10gPDwgMTMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBFbmZvcmNlIGFuIGFycmF5IGxlbmd0aCBvZiA4LCBub3QgYWxsIHplcm9lcy5cbiAgICB3aGlsZSAoWC5sZW5ndGggPCA4KSBYLnB1c2goMCk7XG4gICAgZm9yIChqID0gMDsgaiA8IDggJiYgWFtqXSA9PT0gMDsgKytqKTtcbiAgICBpZiAoaiA9PSA4KSB3ID0gWFs3XSA9IC0xOyBlbHNlIHcgPSBYW2pdO1xuXG4gICAgbWUueCA9IFg7XG4gICAgbWUuaSA9IDA7XG5cbiAgICAvLyBEaXNjYXJkIGFuIGluaXRpYWwgMjU2IHZhbHVlcy5cbiAgICBmb3IgKGogPSAyNTY7IGogPiAwOyAtLWopIHtcbiAgICAgIG1lLm5leHQoKTtcbiAgICB9XG4gIH1cblxuICBpbml0KG1lLCBzZWVkKTtcbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQueCA9IGYueC5zbGljZSgpO1xuICB0LmkgPSBmLmk7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgaWYgKHNlZWQgPT0gbnVsbCkgc2VlZCA9ICsobmV3IERhdGUpO1xuICB2YXIgeGcgPSBuZXcgWG9yR2VuKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwOyB9O1xuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvIHtcbiAgICAgIHZhciB0b3AgPSB4Zy5uZXh0KCkgPj4+IDExLFxuICAgICAgICAgIGJvdCA9ICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDAsXG4gICAgICAgICAgcmVzdWx0ID0gKHRvcCArIGJvdCkgLyAoMSA8PCAyMSk7XG4gICAgfSB3aGlsZSAocmVzdWx0ID09PSAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm5nLmludDMyID0geGcubmV4dDtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS54KSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMueG9yc2hpZnQ3ID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcblxuIiwiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgdGhlIFwieG9yd293XCIgcHJuZyBhbGdvcml0aG0gYnlcbi8vIEdlb3JnZSBNYXJzYWdsaWEuICBTZWUgaHR0cDovL3d3dy5qc3RhdHNvZnQub3JnL3YwOC9pMTQvcGFwZXJcblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gWG9yR2VuKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcywgc3Ryc2VlZCA9ICcnO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IChtZS54IF4gKG1lLnggPj4+IDIpKTtcbiAgICBtZS54ID0gbWUueTsgbWUueSA9IG1lLno7IG1lLnogPSBtZS53OyBtZS53ID0gbWUudjtcbiAgICByZXR1cm4gKG1lLmQgPSAobWUuZCArIDM2MjQzNyB8IDApKSArXG4gICAgICAgKG1lLnYgPSAobWUudiBeIChtZS52IDw8IDQpKSBeICh0IF4gKHQgPDwgMSkpKSB8IDA7XG4gIH07XG5cbiAgbWUueCA9IDA7XG4gIG1lLnkgPSAwO1xuICBtZS56ID0gMDtcbiAgbWUudyA9IDA7XG4gIG1lLnYgPSAwO1xuXG4gIGlmIChzZWVkID09PSAoc2VlZCB8IDApKSB7XG4gICAgLy8gSW50ZWdlciBzZWVkLlxuICAgIG1lLnggPSBzZWVkO1xuICB9IGVsc2Uge1xuICAgIC8vIFN0cmluZyBzZWVkLlxuICAgIHN0cnNlZWQgKz0gc2VlZDtcbiAgfVxuXG4gIC8vIE1peCBpbiBzdHJpbmcgc2VlZCwgdGhlbiBkaXNjYXJkIGFuIGluaXRpYWwgYmF0Y2ggb2YgNjQgdmFsdWVzLlxuICBmb3IgKHZhciBrID0gMDsgayA8IHN0cnNlZWQubGVuZ3RoICsgNjQ7IGsrKykge1xuICAgIG1lLnggXj0gc3Ryc2VlZC5jaGFyQ29kZUF0KGspIHwgMDtcbiAgICBpZiAoayA9PSBzdHJzZWVkLmxlbmd0aCkge1xuICAgICAgbWUuZCA9IG1lLnggPDwgMTAgXiBtZS54ID4+PiA0O1xuICAgIH1cbiAgICBtZS5uZXh0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQueCA9IGYueDtcbiAgdC55ID0gZi55O1xuICB0LnogPSBmLno7XG4gIHQudyA9IGYudztcbiAgdC52ID0gZi52O1xuICB0LmQgPSBmLmQ7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnhvcndvdyA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cblxuIiwiLypcbkNvcHlyaWdodCAyMDE5IERhdmlkIEJhdS5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG5hIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcblwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xud2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG5wZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbnRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG5NRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuXG5JTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWVxuQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCxcblRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFXG5TT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIHBvb2wsIG1hdGgpIHtcbi8vXG4vLyBUaGUgZm9sbG93aW5nIGNvbnN0YW50cyBhcmUgcmVsYXRlZCB0byBJRUVFIDc1NCBsaW1pdHMuXG4vL1xuXG52YXIgd2lkdGggPSAyNTYsICAgICAgICAvLyBlYWNoIFJDNCBvdXRwdXQgaXMgMCA8PSB4IDwgMjU2XG4gICAgY2h1bmtzID0gNiwgICAgICAgICAvLyBhdCBsZWFzdCBzaXggUkM0IG91dHB1dHMgZm9yIGVhY2ggZG91YmxlXG4gICAgZGlnaXRzID0gNTIsICAgICAgICAvLyB0aGVyZSBhcmUgNTIgc2lnbmlmaWNhbnQgZGlnaXRzIGluIGEgZG91YmxlXG4gICAgcm5nbmFtZSA9ICdyYW5kb20nLCAvLyBybmduYW1lOiBuYW1lIGZvciBNYXRoLnJhbmRvbSBhbmQgTWF0aC5zZWVkcmFuZG9tXG4gICAgc3RhcnRkZW5vbSA9IG1hdGgucG93KHdpZHRoLCBjaHVua3MpLFxuICAgIHNpZ25pZmljYW5jZSA9IG1hdGgucG93KDIsIGRpZ2l0cyksXG4gICAgb3ZlcmZsb3cgPSBzaWduaWZpY2FuY2UgKiAyLFxuICAgIG1hc2sgPSB3aWR0aCAtIDEsXG4gICAgbm9kZWNyeXB0bzsgICAgICAgICAvLyBub2RlLmpzIGNyeXB0byBtb2R1bGUsIGluaXRpYWxpemVkIGF0IHRoZSBib3R0b20uXG5cbi8vXG4vLyBzZWVkcmFuZG9tKClcbi8vIFRoaXMgaXMgdGhlIHNlZWRyYW5kb20gZnVuY3Rpb24gZGVzY3JpYmVkIGFib3ZlLlxuLy9cbmZ1bmN0aW9uIHNlZWRyYW5kb20oc2VlZCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIGtleSA9IFtdO1xuICBvcHRpb25zID0gKG9wdGlvbnMgPT0gdHJ1ZSkgPyB7IGVudHJvcHk6IHRydWUgfSA6IChvcHRpb25zIHx8IHt9KTtcblxuICAvLyBGbGF0dGVuIHRoZSBzZWVkIHN0cmluZyBvciBidWlsZCBvbmUgZnJvbSBsb2NhbCBlbnRyb3B5IGlmIG5lZWRlZC5cbiAgdmFyIHNob3J0c2VlZCA9IG1peGtleShmbGF0dGVuKFxuICAgIG9wdGlvbnMuZW50cm9weSA/IFtzZWVkLCB0b3N0cmluZyhwb29sKV0gOlxuICAgIChzZWVkID09IG51bGwpID8gYXV0b3NlZWQoKSA6IHNlZWQsIDMpLCBrZXkpO1xuXG4gIC8vIFVzZSB0aGUgc2VlZCB0byBpbml0aWFsaXplIGFuIEFSQzQgZ2VuZXJhdG9yLlxuICB2YXIgYXJjNCA9IG5ldyBBUkM0KGtleSk7XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgcmFuZG9tIGRvdWJsZSBpbiBbMCwgMSkgdGhhdCBjb250YWluc1xuICAvLyByYW5kb21uZXNzIGluIGV2ZXJ5IGJpdCBvZiB0aGUgbWFudGlzc2Egb2YgdGhlIElFRUUgNzU0IHZhbHVlLlxuICB2YXIgcHJuZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuID0gYXJjNC5nKGNodW5rcyksICAgICAgICAgICAgIC8vIFN0YXJ0IHdpdGggYSBudW1lcmF0b3IgbiA8IDIgXiA0OFxuICAgICAgICBkID0gc3RhcnRkZW5vbSwgICAgICAgICAgICAgICAgIC8vICAgYW5kIGRlbm9taW5hdG9yIGQgPSAyIF4gNDguXG4gICAgICAgIHggPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBhbmQgbm8gJ2V4dHJhIGxhc3QgYnl0ZScuXG4gICAgd2hpbGUgKG4gPCBzaWduaWZpY2FuY2UpIHsgICAgICAgICAgLy8gRmlsbCB1cCBhbGwgc2lnbmlmaWNhbnQgZGlnaXRzIGJ5XG4gICAgICBuID0gKG4gKyB4KSAqIHdpZHRoOyAgICAgICAgICAgICAgLy8gICBzaGlmdGluZyBudW1lcmF0b3IgYW5kXG4gICAgICBkICo9IHdpZHRoOyAgICAgICAgICAgICAgICAgICAgICAgLy8gICBkZW5vbWluYXRvciBhbmQgZ2VuZXJhdGluZyBhXG4gICAgICB4ID0gYXJjNC5nKDEpOyAgICAgICAgICAgICAgICAgICAgLy8gICBuZXcgbGVhc3Qtc2lnbmlmaWNhbnQtYnl0ZS5cbiAgICB9XG4gICAgd2hpbGUgKG4gPj0gb3ZlcmZsb3cpIHsgICAgICAgICAgICAgLy8gVG8gYXZvaWQgcm91bmRpbmcgdXAsIGJlZm9yZSBhZGRpbmdcbiAgICAgIG4gLz0gMjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGxhc3QgYnl0ZSwgc2hpZnQgZXZlcnl0aGluZ1xuICAgICAgZCAvPSAyOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgcmlnaHQgdXNpbmcgaW50ZWdlciBtYXRoIHVudGlsXG4gICAgICB4ID4+Pj0gMTsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICB3ZSBoYXZlIGV4YWN0bHkgdGhlIGRlc2lyZWQgYml0cy5cbiAgICB9XG4gICAgcmV0dXJuIChuICsgeCkgLyBkOyAgICAgICAgICAgICAgICAgLy8gRm9ybSB0aGUgbnVtYmVyIHdpdGhpbiBbMCwgMSkuXG4gIH07XG5cbiAgcHJuZy5pbnQzMiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJjNC5nKDQpIHwgMDsgfVxuICBwcm5nLnF1aWNrID0gZnVuY3Rpb24oKSB7IHJldHVybiBhcmM0LmcoNCkgLyAweDEwMDAwMDAwMDsgfVxuICBwcm5nLmRvdWJsZSA9IHBybmc7XG5cbiAgLy8gTWl4IHRoZSByYW5kb21uZXNzIGludG8gYWNjdW11bGF0ZWQgZW50cm9weS5cbiAgbWl4a2V5KHRvc3RyaW5nKGFyYzQuUyksIHBvb2wpO1xuXG4gIC8vIENhbGxpbmcgY29udmVudGlvbjogd2hhdCB0byByZXR1cm4gYXMgYSBmdW5jdGlvbiBvZiBwcm5nLCBzZWVkLCBpc19tYXRoLlxuICByZXR1cm4gKG9wdGlvbnMucGFzcyB8fCBjYWxsYmFjayB8fFxuICAgICAgZnVuY3Rpb24ocHJuZywgc2VlZCwgaXNfbWF0aF9jYWxsLCBzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAvLyBMb2FkIHRoZSBhcmM0IHN0YXRlIGZyb20gdGhlIGdpdmVuIHN0YXRlIGlmIGl0IGhhcyBhbiBTIGFycmF5LlxuICAgICAgICAgIGlmIChzdGF0ZS5TKSB7IGNvcHkoc3RhdGUsIGFyYzQpOyB9XG4gICAgICAgICAgLy8gT25seSBwcm92aWRlIHRoZSAuc3RhdGUgbWV0aG9kIGlmIHJlcXVlc3RlZCB2aWEgb3B0aW9ucy5zdGF0ZS5cbiAgICAgICAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KGFyYzQsIHt9KTsgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgY2FsbGVkIGFzIGEgbWV0aG9kIG9mIE1hdGggKE1hdGguc2VlZHJhbmRvbSgpKSwgbXV0YXRlXG4gICAgICAgIC8vIE1hdGgucmFuZG9tIGJlY2F1c2UgdGhhdCBpcyBob3cgc2VlZHJhbmRvbS5qcyBoYXMgd29ya2VkIHNpbmNlIHYxLjAuXG4gICAgICAgIGlmIChpc19tYXRoX2NhbGwpIHsgbWF0aFtybmduYW1lXSA9IHBybmc7IHJldHVybiBzZWVkOyB9XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdCBpcyBhIG5ld2VyIGNhbGxpbmcgY29udmVudGlvbiwgc28gcmV0dXJuIHRoZVxuICAgICAgICAvLyBwcm5nIGRpcmVjdGx5LlxuICAgICAgICBlbHNlIHJldHVybiBwcm5nO1xuICAgICAgfSkoXG4gIHBybmcsXG4gIHNob3J0c2VlZCxcbiAgJ2dsb2JhbCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMuZ2xvYmFsIDogKHRoaXMgPT0gbWF0aCksXG4gIG9wdGlvbnMuc3RhdGUpO1xufVxuXG4vL1xuLy8gQVJDNFxuLy9cbi8vIEFuIEFSQzQgaW1wbGVtZW50YXRpb24uICBUaGUgY29uc3RydWN0b3IgdGFrZXMgYSBrZXkgaW4gdGhlIGZvcm0gb2Zcbi8vIGFuIGFycmF5IG9mIGF0IG1vc3QgKHdpZHRoKSBpbnRlZ2VycyB0aGF0IHNob3VsZCBiZSAwIDw9IHggPCAod2lkdGgpLlxuLy9cbi8vIFRoZSBnKGNvdW50KSBtZXRob2QgcmV0dXJucyBhIHBzZXVkb3JhbmRvbSBpbnRlZ2VyIHRoYXQgY29uY2F0ZW5hdGVzXG4vLyB0aGUgbmV4dCAoY291bnQpIG91dHB1dHMgZnJvbSBBUkM0LiAgSXRzIHJldHVybiB2YWx1ZSBpcyBhIG51bWJlciB4XG4vLyB0aGF0IGlzIGluIHRoZSByYW5nZSAwIDw9IHggPCAod2lkdGggXiBjb3VudCkuXG4vL1xuZnVuY3Rpb24gQVJDNChrZXkpIHtcbiAgdmFyIHQsIGtleWxlbiA9IGtleS5sZW5ndGgsXG4gICAgICBtZSA9IHRoaXMsIGkgPSAwLCBqID0gbWUuaSA9IG1lLmogPSAwLCBzID0gbWUuUyA9IFtdO1xuXG4gIC8vIFRoZSBlbXB0eSBrZXkgW10gaXMgdHJlYXRlZCBhcyBbMF0uXG4gIGlmICgha2V5bGVuKSB7IGtleSA9IFtrZXlsZW4rK107IH1cblxuICAvLyBTZXQgdXAgUyB1c2luZyB0aGUgc3RhbmRhcmQga2V5IHNjaGVkdWxpbmcgYWxnb3JpdGhtLlxuICB3aGlsZSAoaSA8IHdpZHRoKSB7XG4gICAgc1tpXSA9IGkrKztcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgIHNbaV0gPSBzW2ogPSBtYXNrICYgKGogKyBrZXlbaSAlIGtleWxlbl0gKyAodCA9IHNbaV0pKV07XG4gICAgc1tqXSA9IHQ7XG4gIH1cblxuICAvLyBUaGUgXCJnXCIgbWV0aG9kIHJldHVybnMgdGhlIG5leHQgKGNvdW50KSBvdXRwdXRzIGFzIG9uZSBudW1iZXIuXG4gIChtZS5nID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICAvLyBVc2luZyBpbnN0YW5jZSBtZW1iZXJzIGluc3RlYWQgb2YgY2xvc3VyZSBzdGF0ZSBuZWFybHkgZG91YmxlcyBzcGVlZC5cbiAgICB2YXIgdCwgciA9IDAsXG4gICAgICAgIGkgPSBtZS5pLCBqID0gbWUuaiwgcyA9IG1lLlM7XG4gICAgd2hpbGUgKGNvdW50LS0pIHtcbiAgICAgIHQgPSBzW2kgPSBtYXNrICYgKGkgKyAxKV07XG4gICAgICByID0gciAqIHdpZHRoICsgc1ttYXNrICYgKChzW2ldID0gc1tqID0gbWFzayAmIChqICsgdCldKSArIChzW2pdID0gdCkpXTtcbiAgICB9XG4gICAgbWUuaSA9IGk7IG1lLmogPSBqO1xuICAgIHJldHVybiByO1xuICAgIC8vIEZvciByb2J1c3QgdW5wcmVkaWN0YWJpbGl0eSwgdGhlIGZ1bmN0aW9uIGNhbGwgYmVsb3cgYXV0b21hdGljYWxseVxuICAgIC8vIGRpc2NhcmRzIGFuIGluaXRpYWwgYmF0Y2ggb2YgdmFsdWVzLiAgVGhpcyBpcyBjYWxsZWQgUkM0LWRyb3BbMjU2XS5cbiAgICAvLyBTZWUgaHR0cDovL2dvb2dsZS5jb20vc2VhcmNoP3E9cnNhK2ZsdWhyZXIrcmVzcG9uc2UmYnRuSVxuICB9KSh3aWR0aCk7XG59XG5cbi8vXG4vLyBjb3B5KClcbi8vIENvcGllcyBpbnRlcm5hbCBzdGF0ZSBvZiBBUkM0IHRvIG9yIGZyb20gYSBwbGFpbiBvYmplY3QuXG4vL1xuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuaSA9IGYuaTtcbiAgdC5qID0gZi5qO1xuICB0LlMgPSBmLlMuc2xpY2UoKTtcbiAgcmV0dXJuIHQ7XG59O1xuXG4vL1xuLy8gZmxhdHRlbigpXG4vLyBDb252ZXJ0cyBhbiBvYmplY3QgdHJlZSB0byBuZXN0ZWQgYXJyYXlzIG9mIHN0cmluZ3MuXG4vL1xuZnVuY3Rpb24gZmxhdHRlbihvYmosIGRlcHRoKSB7XG4gIHZhciByZXN1bHQgPSBbXSwgdHlwID0gKHR5cGVvZiBvYmopLCBwcm9wO1xuICBpZiAoZGVwdGggJiYgdHlwID09ICdvYmplY3QnKSB7XG4gICAgZm9yIChwcm9wIGluIG9iaikge1xuICAgICAgdHJ5IHsgcmVzdWx0LnB1c2goZmxhdHRlbihvYmpbcHJvcF0sIGRlcHRoIC0gMSkpOyB9IGNhdGNoIChlKSB7fVxuICAgIH1cbiAgfVxuICByZXR1cm4gKHJlc3VsdC5sZW5ndGggPyByZXN1bHQgOiB0eXAgPT0gJ3N0cmluZycgPyBvYmogOiBvYmogKyAnXFwwJyk7XG59XG5cbi8vXG4vLyBtaXhrZXkoKVxuLy8gTWl4ZXMgYSBzdHJpbmcgc2VlZCBpbnRvIGEga2V5IHRoYXQgaXMgYW4gYXJyYXkgb2YgaW50ZWdlcnMsIGFuZFxuLy8gcmV0dXJucyBhIHNob3J0ZW5lZCBzdHJpbmcgc2VlZCB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gdGhlIHJlc3VsdCBrZXkuXG4vL1xuZnVuY3Rpb24gbWl4a2V5KHNlZWQsIGtleSkge1xuICB2YXIgc3RyaW5nc2VlZCA9IHNlZWQgKyAnJywgc21lYXIsIGogPSAwO1xuICB3aGlsZSAoaiA8IHN0cmluZ3NlZWQubGVuZ3RoKSB7XG4gICAga2V5W21hc2sgJiBqXSA9XG4gICAgICBtYXNrICYgKChzbWVhciBePSBrZXlbbWFzayAmIGpdICogMTkpICsgc3RyaW5nc2VlZC5jaGFyQ29kZUF0KGorKykpO1xuICB9XG4gIHJldHVybiB0b3N0cmluZyhrZXkpO1xufVxuXG4vL1xuLy8gYXV0b3NlZWQoKVxuLy8gUmV0dXJucyBhbiBvYmplY3QgZm9yIGF1dG9zZWVkaW5nLCB1c2luZyB3aW5kb3cuY3J5cHRvIGFuZCBOb2RlIGNyeXB0b1xuLy8gbW9kdWxlIGlmIGF2YWlsYWJsZS5cbi8vXG5mdW5jdGlvbiBhdXRvc2VlZCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3V0O1xuICAgIGlmIChub2RlY3J5cHRvICYmIChvdXQgPSBub2RlY3J5cHRvLnJhbmRvbUJ5dGVzKSkge1xuICAgICAgLy8gVGhlIHVzZSBvZiAnb3V0JyB0byByZW1lbWJlciByYW5kb21CeXRlcyBtYWtlcyB0aWdodCBtaW5pZmllZCBjb2RlLlxuICAgICAgb3V0ID0gb3V0KHdpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkod2lkdGgpO1xuICAgICAgKGdsb2JhbC5jcnlwdG8gfHwgZ2xvYmFsLm1zQ3J5cHRvKS5nZXRSYW5kb21WYWx1ZXMob3V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvc3RyaW5nKG91dCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIgYnJvd3NlciA9IGdsb2JhbC5uYXZpZ2F0b3IsXG4gICAgICAgIHBsdWdpbnMgPSBicm93c2VyICYmIGJyb3dzZXIucGx1Z2lucztcbiAgICByZXR1cm4gWytuZXcgRGF0ZSwgZ2xvYmFsLCBwbHVnaW5zLCBnbG9iYWwuc2NyZWVuLCB0b3N0cmluZyhwb29sKV07XG4gIH1cbn1cblxuLy9cbi8vIHRvc3RyaW5nKClcbi8vIENvbnZlcnRzIGFuIGFycmF5IG9mIGNoYXJjb2RlcyB0byBhIHN0cmluZ1xuLy9cbmZ1bmN0aW9uIHRvc3RyaW5nKGEpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoMCwgYSk7XG59XG5cbi8vXG4vLyBXaGVuIHNlZWRyYW5kb20uanMgaXMgbG9hZGVkLCB3ZSBpbW1lZGlhdGVseSBtaXggYSBmZXcgYml0c1xuLy8gZnJvbSB0aGUgYnVpbHQtaW4gUk5HIGludG8gdGhlIGVudHJvcHkgcG9vbC4gIEJlY2F1c2Ugd2UgZG9cbi8vIG5vdCB3YW50IHRvIGludGVyZmVyZSB3aXRoIGRldGVybWluaXN0aWMgUFJORyBzdGF0ZSBsYXRlcixcbi8vIHNlZWRyYW5kb20gd2lsbCBub3QgY2FsbCBtYXRoLnJhbmRvbSBvbiBpdHMgb3duIGFnYWluIGFmdGVyXG4vLyBpbml0aWFsaXphdGlvbi5cbi8vXG5taXhrZXkobWF0aC5yYW5kb20oKSwgcG9vbCk7XG5cbi8vXG4vLyBOb2RlanMgYW5kIEFNRCBzdXBwb3J0OiBleHBvcnQgdGhlIGltcGxlbWVudGF0aW9uIGFzIGEgbW9kdWxlIHVzaW5nXG4vLyBlaXRoZXIgY29udmVudGlvbi5cbi8vXG5pZiAoKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gc2VlZHJhbmRvbTtcbiAgLy8gV2hlbiBpbiBub2RlLmpzLCB0cnkgdXNpbmcgY3J5cHRvIHBhY2thZ2UgZm9yIGF1dG9zZWVkaW5nLlxuICB0cnkge1xuICAgIG5vZGVjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbiAgfSBjYXRjaCAoZXgpIHt9XG59IGVsc2UgaWYgKCh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VlZHJhbmRvbTsgfSk7XG59IGVsc2Uge1xuICAvLyBXaGVuIGluY2x1ZGVkIGFzIGEgcGxhaW4gc2NyaXB0LCBzZXQgdXAgTWF0aC5zZWVkcmFuZG9tIGdsb2JhbC5cbiAgbWF0aFsnc2VlZCcgKyBybmduYW1lXSA9IHNlZWRyYW5kb207XG59XG5cblxuLy8gRW5kIGFub255bW91cyBzY29wZSwgYW5kIHBhc3MgaW5pdGlhbCB2YWx1ZXMuXG59KShcbiAgLy8gZ2xvYmFsOiBgc2VsZmAgaW4gYnJvd3NlcnMgKGluY2x1ZGluZyBzdHJpY3QgbW9kZSBhbmQgd2ViIHdvcmtlcnMpLFxuICAvLyBvdGhlcndpc2UgYHRoaXNgIGluIE5vZGUgYW5kIG90aGVyIGVudmlyb25tZW50c1xuICAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSA/IHNlbGYgOiB0aGlzLFxuICBbXSwgICAgIC8vIHBvb2w6IGVudHJvcHkgcG9vbCBzdGFydHMgZW1wdHlcbiAgTWF0aCAgICAvLyBtYXRoOiBwYWNrYWdlIGNvbnRhaW5pbmcgcmFuZG9tLCBwb3csIGFuZCBzZWVkcmFuZG9tXG4pO1xuIiwiXG4gICAgICBpbXBvcnQgQVBJIGZyb20gXCIhLi4vLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgIGltcG9ydCBkb21BUEkgZnJvbSBcIiEuLi8uLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0Rm4gZnJvbSBcIiEuLi8uLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanNcIjtcbiAgICAgIGltcG9ydCBzZXRBdHRyaWJ1dGVzIGZyb20gXCIhLi4vLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRTdHlsZUVsZW1lbnQgZnJvbSBcIiEuLi8uLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qc1wiO1xuICAgICAgaW1wb3J0IHN0eWxlVGFnVHJhbnNmb3JtRm4gZnJvbSBcIiEuLi8uLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzXCI7XG4gICAgICBpbXBvcnQgY29udGVudCwgKiBhcyBuYW1lZEV4cG9ydCBmcm9tIFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vamFzbWluZS5jc3NcIjtcbiAgICAgIFxuICAgICAgXG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0gPSBzdHlsZVRhZ1RyYW5zZm9ybUZuO1xub3B0aW9ucy5zZXRBdHRyaWJ1dGVzID0gc2V0QXR0cmlidXRlcztcblxuICAgICAgb3B0aW9ucy5pbnNlcnQgPSBpbnNlcnRGbi5iaW5kKG51bGwsIFwiaGVhZFwiKTtcbiAgICBcbm9wdGlvbnMuZG9tQVBJID0gZG9tQVBJO1xub3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7XG5cbnZhciB1cGRhdGUgPSBBUEkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgKiBmcm9tIFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vamFzbWluZS5jc3NcIjtcbiAgICAgICBleHBvcnQgZGVmYXVsdCBjb250ZW50ICYmIGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB1bmRlZmluZWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHN0eWxlc0luRE9NID0gW107XG5cbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5ET00ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5ET01baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleEJ5SWRlbnRpZmllciA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXSxcbiAgICAgIHN1cHBvcnRzOiBpdGVtWzRdLFxuICAgICAgbGF5ZXI6IGl0ZW1bNV1cbiAgICB9O1xuXG4gICAgaWYgKGluZGV4QnlJZGVudGlmaWVyICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB1cGRhdGVyID0gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLmJ5SW5kZXggPSBpO1xuICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKGksIDAsIHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgdXBkYXRlcjogdXBkYXRlcixcbiAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfVxuXG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cblxuZnVuY3Rpb24gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgYXBpID0gb3B0aW9ucy5kb21BUEkob3B0aW9ucyk7XG4gIGFwaS51cGRhdGUob2JqKTtcblxuICB2YXIgdXBkYXRlciA9IGZ1bmN0aW9uIHVwZGF0ZXIobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCAmJiBuZXdPYmouc3VwcG9ydHMgPT09IG9iai5zdXBwb3J0cyAmJiBuZXdPYmoubGF5ZXIgPT09IG9iai5sYXllcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGFwaS51cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbW92ZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdXBkYXRlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cblxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcblxuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcblxuICAgICAgaWYgKHN0eWxlc0luRE9NW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRPTVtfaW5kZXhdLnVwZGF0ZXIoKTtcblxuICAgICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgbWVtbyA9IHt9O1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cbmZ1bmN0aW9uIGdldFRhcmdldCh0YXJnZXQpIHtcbiAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7IC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cbiAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gIH1cblxuICByZXR1cm4gbWVtb1t0YXJnZXRdO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxuZnVuY3Rpb24gaW5zZXJ0QnlTZWxlY3RvcihpbnNlcnQsIHN0eWxlKSB7XG4gIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQoaW5zZXJ0KTtcblxuICBpZiAoIXRhcmdldCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gIH1cblxuICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydEJ5U2VsZWN0b3I7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIG9wdGlvbnMuc2V0QXR0cmlidXRlcyhlbGVtZW50LCBvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICBvcHRpb25zLmluc2VydChlbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xuICByZXR1cm4gZWxlbWVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzKHN0eWxlRWxlbWVudCkge1xuICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG5cbiAgaWYgKG5vbmNlKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlczsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gXCJcIjtcblxuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQob2JqLnN1cHBvcnRzLCBcIikge1wiKTtcbiAgfVxuXG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKTtcbiAgfVxuXG4gIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2Ygb2JqLmxheWVyICE9PSBcInVuZGVmaW5lZFwiO1xuXG4gIGlmIChuZWVkTGF5ZXIpIHtcbiAgICBjc3MgKz0gXCJAbGF5ZXJcIi5jb25jYXQob2JqLmxheWVyLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQob2JqLmxheWVyKSA6IFwiXCIsIFwiIHtcIik7XG4gIH1cblxuICBjc3MgKz0gb2JqLmNzcztcblxuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG5cbiAgaWYgKG9iai5tZWRpYSkge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuXG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cblxuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIG9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZUVsZW1lbnQucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG5mdW5jdGlvbiBkb21BUEkob3B0aW9ucykge1xuICB2YXIgc3R5bGVFbGVtZW50ID0gb3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUob2JqKSB7XG4gICAgICBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaik7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkb21BUEk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQpIHtcbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5bGVUYWdUcmFuc2Zvcm07IiwiaW1wb3J0IENvbXB1dGVWb3hlbHMgZnJvbSAnISFyYXctbG9hZGVyIS4vY29tcHV0ZS12b3hlbHMud2dzbCc7XG5pbXBvcnQgUmFuZG9tIGZyb20gJ3NlZWRyYW5kb20nO1xuXG5kZXNjcmliZSgnY29tcHV0ZS12b3hlbHMnLCAoKSA9PiB7XG4gIGRlc2NyaWJlKCdjb21wdXRlTWF0ZXJpYWxzJywgKCkgPT4ge1xuICAgIGxldCBtYXRlcmlhbHM6IFVpbnQzMkFycmF5O1xuXG4gICAgYmVmb3JlQWxsKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGFkYXB0ZXIgPSBhd2FpdCBuYXZpZ2F0b3IuZ3B1LnJlcXVlc3RBZGFwdGVyKCk7XG4gICAgICBjb25zdCBkZXZpY2UgPSBhd2FpdCBhZGFwdGVyLnJlcXVlc3REZXZpY2UoKTtcblxuICAgICAgY29uc3QgZGVuc2l0eSA9IGBmbiBnZXREZW5zaXR5KHdvcmxkUG9zaXRpb246IHZlYzM8ZjMyPikgLT4gZjMyIHsgXG4gICAgICAgIGlmICh3b3JsZFBvc2l0aW9uLnkgPCAzLjApIHtcbiAgICAgICAgICByZXR1cm4gLTEuMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gMS4wO1xuICAgICAgICB9XG4gICAgICAgfWA7XG5cbiAgICAgIGNvbnN0IGNvbXB1dGVWb3hlbHMgPSBDb21wdXRlVm94ZWxzLnJlcGxhY2UoXCIjaW1wb3J0IGRlbnNpdHlcIiwgZGVuc2l0eSlcbiAgICAgIGNvbnN0IGNvbXB1dGVQaXBlbGluZSA9IGF3YWl0IGRldmljZS5jcmVhdGVDb21wdXRlUGlwZWxpbmVBc3luYyh7XG4gICAgICAgIGxheW91dDogJ2F1dG8nLFxuICAgICAgICBjb21wdXRlOiB7XG4gICAgICAgICAgbW9kdWxlOiBkZXZpY2UuY3JlYXRlU2hhZGVyTW9kdWxlKHtcbiAgICAgICAgICAgIGNvZGU6IGNvbXB1dGVWb3hlbHMsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgZW50cnlQb2ludDogJ2NvbXB1dGVNYXRlcmlhbHMnLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHBlcm11dGF0aW9ucyA9IG5ldyBJbnQzMkFycmF5KDUxMik7XG5cbiAgICAgIGNvbnN0IHJhbmRvbSA9IG5ldyBSYW5kb20oNjQ1Mik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKVxuICAgICAgICBwZXJtdXRhdGlvbnNbaV0gPSAoMjU2ICogKHJhbmRvbSgpKSk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAyNTY7IGkgPCA1MTI7IGkrKylcbiAgICAgICAgcGVybXV0YXRpb25zW2ldID0gcGVybXV0YXRpb25zW2kgLSAyNTZdO1xuXG4gICAgICBjb25zdCBwZXJtdXRhdGlvbnNCdWZmZXIgPSBkZXZpY2UuY3JlYXRlQnVmZmVyKHtcbiAgICAgICAgc2l6ZTogcGVybXV0YXRpb25zLmJ5dGVMZW5ndGgsXG4gICAgICAgIHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5TVE9SQUdFIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QsXG4gICAgICAgIG1hcHBlZEF0Q3JlYXRpb246IHRydWUsXG4gICAgICB9KTtcblxuICAgICAgbmV3IEludDMyQXJyYXkocGVybXV0YXRpb25zQnVmZmVyLmdldE1hcHBlZFJhbmdlKCkpLnNldChcbiAgICAgICAgcGVybXV0YXRpb25zXG4gICAgICApO1xuICAgICAgcGVybXV0YXRpb25zQnVmZmVyLnVubWFwKCk7XG5cbiAgICAgIGNvbnN0IGNvcm5lck1hdGVyaWFscyA9IGRldmljZS5jcmVhdGVCdWZmZXIoe1xuICAgICAgICBzaXplOiBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCAqIDUgKiA1ICogNSxcbiAgICAgICAgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UgfCBHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQyxcbiAgICAgICAgbWFwcGVkQXRDcmVhdGlvbjogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgY29ybmVyTWF0ZXJpYWxzUmVhZCA9IGRldmljZS5jcmVhdGVCdWZmZXIoe1xuICAgICAgICBzaXplOiBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCAqIDUgKiA1ICogNSxcbiAgICAgICAgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUIHwgR1BVQnVmZmVyVXNhZ2UuTUFQX1JFQUQsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdW5pZm9ybUJ1ZmZlclNpemUgPSA0ICogNTtcbiAgICAgIGNvbnN0IHVuaWZvcm1CdWZmZXIgPSBkZXZpY2UuY3JlYXRlQnVmZmVyKHtcbiAgICAgICAgc2l6ZTogdW5pZm9ybUJ1ZmZlclNpemUsXG4gICAgICAgIHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5VTklGT1JNIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgY29tcHV0ZUJpbmRHcm91cCA9IGRldmljZS5jcmVhdGVCaW5kR3JvdXAoe1xuICAgICAgICBsYXlvdXQ6IGNvbXB1dGVQaXBlbGluZS5nZXRCaW5kR3JvdXBMYXlvdXQoMCksXG4gICAgICAgIGVudHJpZXM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBiaW5kaW5nOiAxLFxuICAgICAgICAgICAgcmVzb3VyY2U6IHtcbiAgICAgICAgICAgICAgYnVmZmVyOiBjb3JuZXJNYXRlcmlhbHNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmluZGluZzogNSxcbiAgICAgICAgICAgIHJlc291cmNlOiB7XG4gICAgICAgICAgICAgIGJ1ZmZlcjogdW5pZm9ybUJ1ZmZlclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBjb21wdXRlRW5jb2RlciA9IGRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlcigpO1xuICAgICAgY29uc3QgY29tcHV0ZVBhc3NFbmNvZGVyID0gY29tcHV0ZUVuY29kZXIuYmVnaW5Db21wdXRlUGFzcygpO1xuICAgICAgY29tcHV0ZVBhc3NFbmNvZGVyLnNldFBpcGVsaW5lKGNvbXB1dGVQaXBlbGluZSk7XG4gICAgICBjb21wdXRlUGFzc0VuY29kZXIuc2V0QmluZEdyb3VwKDAsIGNvbXB1dGVCaW5kR3JvdXApO1xuICAgICAgY29tcHV0ZVBhc3NFbmNvZGVyLmRpc3BhdGNoV29ya2dyb3Vwcyg1LCA1LCA1KTtcbiAgICAgIGNvbXB1dGVQYXNzRW5jb2Rlci5lbmQoKTtcblxuICAgICAgY29uc3QgY29weUVuY29kZXIgPSBkZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoKTtcbiAgICAgIGNvcHlFbmNvZGVyLmNvcHlCdWZmZXJUb0J1ZmZlcihcbiAgICAgICAgY29ybmVyTWF0ZXJpYWxzLFxuICAgICAgICAwLFxuICAgICAgICBjb3JuZXJNYXRlcmlhbHNSZWFkLFxuICAgICAgICAwLFxuICAgICAgICBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCAqIDUgKiA1ICogNVxuICAgICAgKTtcblxuICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcig0ICogNSk7XG4gICAgICBjb25zdCB1bmlmb3JtID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIsIDAsIDQpO1xuICAgICAgdW5pZm9ybVszXSA9IDE7XG5cbiAgICAgIG5ldyBVaW50MzJBcnJheShidWZmZXIsIDE2LCAxKVswXSA9IDU7XG5cbiAgICAgIGRldmljZS5xdWV1ZS53cml0ZUJ1ZmZlcihcbiAgICAgICAgICB1bmlmb3JtQnVmZmVyLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgYnVmZmVyLmJ5dGVMZW5ndGhcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHF1ZXVlID0gZGV2aWNlLnF1ZXVlLm9uU3VibWl0dGVkV29ya0RvbmUoKTtcblxuICAgICAgZGV2aWNlLnF1ZXVlLnN1Ym1pdChbY29tcHV0ZUVuY29kZXIuZmluaXNoKCksIGNvcHlFbmNvZGVyLmZpbmlzaCgpXSk7XG5cbiAgICAgIGF3YWl0IHF1ZXVlO1xuXG4gICAgICBhd2FpdCBjb3JuZXJNYXRlcmlhbHNSZWFkLm1hcEFzeW5jKEdQVU1hcE1vZGUuUkVBRClcbiAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gY29ybmVyTWF0ZXJpYWxzUmVhZC5nZXRNYXBwZWRSYW5nZSgpO1xuICAgICAgbWF0ZXJpYWxzID0gbmV3IFVpbnQzMkFycmF5KGFycmF5QnVmZmVyKS5zbGljZSgpO1xuICAgICAgY29ybmVyTWF0ZXJpYWxzUmVhZC51bm1hcCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3RoZW4gbWF0ZXJpYWxzIGlzIG5vdCBudWxsJywgKCkgPT4ge1xuICAgICAgY29uc3QgZXhwZWN0ZWRSZXN1bHQgPSBuZXcgVWludDMyQXJyYXkoNSo1KjUpO1xuXG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDU7IHgrKylcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTsgeSsrKVxuICAgICAgZm9yIChsZXQgeiA9IDA7IHogPCA1OyB6KyspIHtcbiAgICAgICAgZXhwZWN0ZWRSZXN1bHRbeiAqIDUgKiA1ICsgeSAqIDUgKyB4XSA9IHkgPCAzID8gMSA6IDA7XG4gICAgICB9XG5cbiAgICAgIGV4cGVjdChtYXRlcmlhbHMpLnRvRXF1YWwoZXhwZWN0ZWRSZXN1bHQpO1xuICAgIH0pO1xuICB9KTtcbn0pOyIsImltcG9ydCBSZW5kZXJlciBmcm9tIFwiLi9yZW5kZXJlclwiO1xuXG5kZXNjcmliZSgnUmVuZGVyZXInLCAoKSA9PiB7XG4gIGxldCBjYW52YXM7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbnZhcycpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIG5vdCB0aHJvdyB3aGVuIGluaXRpYWxpemVkJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKCk7XG4gICAgYXdhaXQgZXhwZWN0QXN5bmMgKHJlbmRlcmVyLmluaXQoY2FudmFzKSkudG9CZVJlc29sdmVkKCk7XG4gICAgZXhwZWN0KCgpID0+IHJlbmRlcmVyLmNvbmZpZ3VyZShjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpKS5ub3QudG9UaHJvdygpO1xuICAgIGV4cGVjdCgoKSA9PiByZW5kZXJlci5yZW5kZXIoKCkgPT4ge30pKS5ub3QudG9UaHJvdygpO1xuICB9KTtcbn0pOyIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmVyIHtcbiAgcHJpdmF0ZSBjb250ZXh0OiBHUFVDYW52YXNDb250ZXh0O1xuICBkZXZpY2U6IEdQVURldmljZTtcbiAgcHJpdmF0ZSBwcmVzZW50YXRpb25Gb3JtYXQ6IEdQVVRleHR1cmVGb3JtYXRcbiAgcHJpdmF0ZSBkZXB0aFRleHR1cmU6IEdQVVRleHR1cmVcblxuICBhc3luYyBpbml0KGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gYXdhaXQgbmF2aWdhdG9yLmdwdS5yZXF1ZXN0QWRhcHRlcigpO1xuICAgIHRoaXMuZGV2aWNlID0gYXdhaXQgYWRhcHRlci5yZXF1ZXN0RGV2aWNlKCk7XG5cbiAgICB0aGlzLmNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ3B1Jyk7XG4gICAgdGhpcy5wcmVzZW50YXRpb25Gb3JtYXQgPSAgbmF2aWdhdG9yLmdwdS5nZXRQcmVmZXJyZWRDYW52YXNGb3JtYXQoKTtcbiAgfVxuXG4gIGNvbmZpZ3VyZSh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikge1xuICAgIHRoaXMuY29udGV4dC5jb25maWd1cmUoe1xuICAgICAgZGV2aWNlOiB0aGlzLmRldmljZSxcbiAgICAgIGZvcm1hdDogdGhpcy5wcmVzZW50YXRpb25Gb3JtYXQsXG4gICAgICBhbHBoYU1vZGU6ICdvcGFxdWUnXG4gICAgfSk7XG5cbiAgICB0aGlzLmRlcHRoVGV4dHVyZSA9IHRoaXMuZGV2aWNlLmNyZWF0ZVRleHR1cmUoe1xuICAgICAgc2l6ZTogeyB3aWR0aCwgaGVpZ2h0IH0sXG4gICAgICBmb3JtYXQ6ICdkZXB0aDI0cGx1cy1zdGVuY2lsOCcsXG4gICAgICB1c2FnZTogR1BVVGV4dHVyZVVzYWdlLlJFTkRFUl9BVFRBQ0hNRU5ULFxuICAgIH0pO1xuICB9XG5cbiAgcmVuZGVyKGNhbGxiYWNrOiAoR1BVUmVuZGVyUGFzc0Rlc2NyaXB0b3IpID0+IHZvaWQpIHtcbiAgICBjb25zdCBjb21tYW5kRW5jb2RlciA9IHRoaXMuZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCk7XG4gICAgY29uc3QgdGV4dHVyZVZpZXcgPSB0aGlzLmNvbnRleHQuZ2V0Q3VycmVudFRleHR1cmUoKS5jcmVhdGVWaWV3KCk7XG5cbiAgICBjb25zdCByZW5kZXJQYXNzRGVzY3JpcHRvcjogR1BVUmVuZGVyUGFzc0Rlc2NyaXB0b3IgPSB7XG4gICAgICBjb2xvckF0dGFjaG1lbnRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICB2aWV3OiB0ZXh0dXJlVmlldyxcbiAgICAgICAgICBjbGVhclZhbHVlOiB7cjogMC4wLCBnOiAwLjAsIGI6IDAuMCwgYTogMS4wfSxcbiAgICAgICAgICBsb2FkT3A6ICdjbGVhcicgYXMgY29uc3QsXG4gICAgICAgICAgc3RvcmVPcDogJ3N0b3JlJyBhcyBjb25zdFxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgZGVwdGhTdGVuY2lsQXR0YWNobWVudDoge1xuICAgICAgICB2aWV3OiB0aGlzLmRlcHRoVGV4dHVyZS5jcmVhdGVWaWV3KCksXG5cbiAgICAgICAgZGVwdGhDbGVhclZhbHVlOiAxLjAsXG4gICAgICAgIGRlcHRoTG9hZE9wOiAnY2xlYXInLFxuICAgICAgICBkZXB0aFN0b3JlT3A6ICdzdG9yZScsXG5cbiAgICAgICAgc3RlbmNpbENsZWFyVmFsdWU6IDAsXG4gICAgICAgIHN0ZW5jaWxMb2FkT3A6ICdjbGVhcicsXG4gICAgICAgIHN0ZW5jaWxTdG9yZU9wOiAnc3RvcmUnLFxuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBwYXNzRW5jb2RlciA9IGNvbW1hbmRFbmNvZGVyLmJlZ2luUmVuZGVyUGFzcyhyZW5kZXJQYXNzRGVzY3JpcHRvcik7XG4gICAgY2FsbGJhY2socGFzc0VuY29kZXIpO1xuICAgIHBhc3NFbmNvZGVyLmVuZCgpO1xuXG4gICAgdGhpcy5kZXZpY2UucXVldWUuc3VibWl0KFtjb21tYW5kRW5jb2Rlci5maW5pc2goKV0pO1xuICB9XG59XG4iLCJpbXBvcnQgJ2phc21pbmUtY29yZS9saWIvamFzbWluZS1jb3JlL2phc21pbmUuY3NzJ1xuXG5pbXBvcnQgJ2phc21pbmUtY29yZS9saWIvamFzbWluZS1jb3JlL2phc21pbmUtaHRtbC5qcydcbmltcG9ydCAnamFzbWluZS1jb3JlL2xpYi9qYXNtaW5lLWNvcmUvYm9vdDAuanMnXG5pbXBvcnQgJ2phc21pbmUtY29yZS9saWIvamFzbWluZS1jb3JlL2Jvb3QxLmpzJ1xuXG4vLyBAdHMtaWdub3JlXG5jb25zdCB0ZXN0cyA9IHJlcXVpcmUuY29udGV4dChcbiAgICBcIi4vXCIsIC8vIGNvbnRleHQgZm9sZGVyXG4gICAgdHJ1ZSwgLy8gaW5jbHVkZSBzdWJkaXJlY3Rvcmllc1xuICAgIC8udGVzdC4oanx0KXMkLyAvLyBSZWdFeHBcbik7XG5cbmNvbnN0IHRlc3RGaWxlcyA9IHRlc3RzLmtleXMoKTtcbmZvciAobGV0IHRlc3QgaW4gdGVzdEZpbGVzKSB7XG4gICAgdGVzdHModGVzdEZpbGVzW3Rlc3RdKTtcbn1cbiIsImltcG9ydCBXb3JsZEdlbmVyYXRvciwge2dlbmVyYXRlUG9pbnRzfSBmcm9tICcuL3dvcmxkLWdlbmVyYXRvcic7XG5cbmRlc2NyaWJlKCdXb3JsZCBHZW5lcmF0b3InLCAoKSA9PiB7XG4gIGxldCB3b3JsZEdlbmVyYXRvcjogV29ybGRHZW5lcmF0b3I7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgd29ybGRHZW5lcmF0b3IgPSBuZXcgV29ybGRHZW5lcmF0b3IoOCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCd3aGVuIGluaXQgaXMgY2FsbGVkJywgKCkgPT4ge1xuICAgIGxldCBpbmZvO1xuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgaW5mbyA9IHdvcmxkR2VuZXJhdG9yLmluaXQoMywgMjAsIDQzKTtcbiAgICB9KTtcblxuICAgIGl0KCdwb3NpdGlvbiBpcyByb3VuZGVkIHRvIG5lYXJlc3Qgc3RyaWRlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgZXhwZWN0KGluZm8ueCkudG9FcXVhbCgwKTtcbiAgICAgIGV4cGVjdChpbmZvLnkpLnRvRXF1YWwoMjQpO1xuICAgICAgZXhwZWN0KGluZm8ueikudG9FcXVhbCg0MCk7XG4gICAgfSk7XG5cbiAgICBpdCgnY3VycmVudCBzdHJpZGUgZGVmYXVsdHMgdG8gbWluaW11bSBzdHJpZGUnLCAoKSA9PiB7XG4gICAgICBleHBlY3QoaW5mby5zdHJpZGUpLnRvRXF1YWwoOCk7XG4gICAgfSk7XG5cbiAgICBpdCgncHJldmlvdXNPZmZzZXQgaXMgY29ycmVjdCcsICgpID0+IHtcbiAgICAgIGV4cGVjdChpbmZvLnByZXZpb3VzT2Zmc2V0KS50b0VxdWFsKC00KTtcbiAgICB9KTtcblxuICAgIGl0KCdsYXllciBpcyBjb3JyZWN0JywgKCkgPT4ge1xuICAgICAgZXhwZWN0KGluZm8ubGF5ZXIpLnRvRXF1YWwoMSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCd3aGVuIG5leHQgaXMgY2FsbGVkJywgKCkgPT4ge1xuICAgIGl0KCdyZXR1cm5zIG9yaWdpbiBwb3NpdGlvbicsICgpID0+IHtcbiAgICAgIGxldCBbcmVzdWx0LCBpbmZvXSA9IHdvcmxkR2VuZXJhdG9yLm5leHQoe1xuICAgICAgICB4OiAwLCB5OiAwLCB6OiAwLCBzdHJpZGU6IDgsIGl0ZXJhdGlvbjogMCwgbGF5ZXI6IDEsIHByZXZpb3VzT2Zmc2V0OiAtNFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgICB4OiAtNCwgeTogLTQsIHo6IC00LCBzdHJpZGU6IDhcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoaW5mbykudG9FcXVhbCh7XG4gICAgICAgIHg6IDAsIHk6IDAsIHo6IDAsIHN0cmlkZTogOCwgaXRlcmF0aW9uOiAxLCBsYXllcjogMSwgcHJldmlvdXNPZmZzZXQ6IC00XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdyZXR1cm5zIG9yaWdpbiBwb3NpdGlvbiBmb3IgaXRlcmF0aW9uIDEnLCAoKSA9PiB7XG4gICAgICBsZXQgW3Jlc3VsdCwgaW5mb10gPSB3b3JsZEdlbmVyYXRvci5uZXh0KHtcbiAgICAgICAgeDogMCwgeTogMCwgejogMCwgc3RyaWRlOiA4LCBpdGVyYXRpb246IDEsIGxheWVyOiAxLCBwcmV2aW91c09mZnNldDogLTRcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHtcbiAgICAgICAgeDogLTQsIHk6IC00LCB6OiA0LCBzdHJpZGU6IDhcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoaW5mbykudG9FcXVhbCh7XG4gICAgICAgIHg6IDAsIHk6IDAsIHo6IDAsIHN0cmlkZTogOCwgaXRlcmF0aW9uOiAyLCBsYXllcjogMSwgcHJldmlvdXNPZmZzZXQ6IC00XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdyZXR1cm5zIG9yaWdpbiBwb3NpdGlvbiBmb3Igc2Vjb25kIGxheWVyJywgKCkgPT4ge1xuICAgICAgbGV0IFtyZXN1bHQsIGluZm9dID0gd29ybGRHZW5lcmF0b3IubmV4dCh7XG4gICAgICAgIHg6IDAsIHk6IDAsIHo6IDAsIHN0cmlkZTogOCwgaXRlcmF0aW9uOiAwLCBsYXllcjogMiwgcHJldmlvdXNPZmZzZXQ6IC00XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7XG4gICAgICAgIHg6IC0xMiwgeTogLTEyLCB6OiAtMTIsIHN0cmlkZTogOFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChpbmZvKS50b0VxdWFsKHtcbiAgICAgICAgeDogMCwgeTogMCwgejogMCwgc3RyaWRlOiA4LCBpdGVyYXRpb246IDEsIGxheWVyOiAyLCBwcmV2aW91c09mZnNldDogLTRcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3JldHVybnMgb3JpZ2luIHBvc2l0aW9uIGZvciBzZWNvbmQgbGF5ZXIgc2Vjb25kIGl0ZXJhdGlvbicsICgpID0+IHtcbiAgICAgIGxldCBbcmVzdWx0LCBpbmZvXSA9IHdvcmxkR2VuZXJhdG9yLm5leHQoe1xuICAgICAgICB4OiAwLCB5OiAwLCB6OiAwLCBzdHJpZGU6IDgsIGl0ZXJhdGlvbjogNiwgbGF5ZXI6IDIsIHByZXZpb3VzT2Zmc2V0OiAtNFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgICB4OiAtMTIsIHk6IC00LCB6OiA0LCBzdHJpZGU6IDhcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoaW5mbykudG9FcXVhbCh7XG4gICAgICAgIHg6IDAsIHk6IDAsIHo6IDAsIHN0cmlkZTogOCwgaXRlcmF0aW9uOiA3LCBsYXllcjogMiwgcHJldmlvdXNPZmZzZXQ6IC00XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdvZmZzZXRzIHBvc2l0aW9uIGJ5IHJvb3QnLCAoKSA9PiB7XG4gICAgICBsZXQgW3Jlc3VsdCwgaW5mb10gPSB3b3JsZEdlbmVyYXRvci5uZXh0KHtcbiAgICAgICAgeDogNDAsIHk6IDI0LCB6OiAzMiwgc3RyaWRlOiA4LCBpdGVyYXRpb246IDAsIGxheWVyOiAxLCBwcmV2aW91c09mZnNldDogLTRcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHtcbiAgICAgICAgeDogMzYsIHk6IDIwLCB6OiAyOCwgc3RyaWRlOiA4XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KGluZm8pLnRvRXF1YWwoe1xuICAgICAgICB4OiA0MCwgeTogMjQsIHo6IDMyLCBzdHJpZGU6IDgsIGl0ZXJhdGlvbjogMSwgbGF5ZXI6IDEsIHByZXZpb3VzT2Zmc2V0OiAtNFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnb2Zmc2V0cyBwb3NpdGlvbiBieSBpdGVyYXRpb24nLCAoKSA9PiB7XG4gICAgICBsZXQgW3Jlc3VsdCwgaW5mb10gPSB3b3JsZEdlbmVyYXRvci5uZXh0KHtcbiAgICAgICAgeDogNDAsIHk6IDI0LCB6OiAzMiwgc3RyaWRlOiA4LCBpdGVyYXRpb246IDEsIGxheWVyOiAxLCBwcmV2aW91c09mZnNldDogLTRcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHtcbiAgICAgICAgeDogMzYsIHk6IDIwLCB6OiAzNiwgc3RyaWRlOiA4XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KGluZm8pLnRvRXF1YWwoe1xuICAgICAgICB4OiA0MCwgeTogMjQsIHo6IDMyLCBzdHJpZGU6IDgsIGl0ZXJhdGlvbjogMiwgbGF5ZXI6IDEsIHByZXZpb3VzT2Zmc2V0OiAtNFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnb2Zmc2V0cyBwb3NpdGlvbiBieSBsYXN0IGl0ZXJhdGlvbicsICgpID0+IHtcbiAgICAgIGxldCBbcmVzdWx0LCBpbmZvXSA9IHdvcmxkR2VuZXJhdG9yLm5leHQoe1xuICAgICAgICB4OiA0MCwgeTogMjQsIHo6IDMyLCBzdHJpZGU6IDgsIGl0ZXJhdGlvbjogNywgbGF5ZXI6IDEsIHByZXZpb3VzT2Zmc2V0OiAtNFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgICB4OiA0NCwgeTogMjgsIHo6IDM2LCBzdHJpZGU6IDhcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoaW5mbykudG9FcXVhbCh7XG4gICAgICAgIHg6IDQwLCB5OiAyNCwgejogMzIsIHN0cmlkZTogOCwgaXRlcmF0aW9uOiAwLCBsYXllcjogMiwgcHJldmlvdXNPZmZzZXQ6IC00XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdvZmZzZXRzIHBvc2l0aW9uIGJ5IGxhc3QgbGF5ZXInLCAoKSA9PiB7XG4gICAgICBsZXQgW3Jlc3VsdCwgaW5mb10gPSB3b3JsZEdlbmVyYXRvci5uZXh0KHtcbiAgICAgICAgeDogNDAsIHk6IDI0LCB6OiAzMiwgc3RyaWRlOiA4LCBpdGVyYXRpb246IDU1LCBsYXllcjogMiwgcHJldmlvdXNPZmZzZXQ6IC00XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7XG4gICAgICAgIHg6IDUyLCB5OiAzNiwgejogNDQsIHN0cmlkZTogOFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChpbmZvKS50b0VxdWFsKHtcbiAgICAgICAgeDogNDAsIHk6IDI0LCB6OiAzMiwgc3RyaWRlOiAxNiwgaXRlcmF0aW9uOiAwLCBsYXllcjogMSwgcHJldmlvdXNPZmZzZXQ6IDhcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3JldHVybnMgY29ycmVjdCBwb3NpdGlvbiBmb3IgbmV4dCBzdHJpZGUnLCAoKSA9PiB7XG4gICAgICBsZXQgW3Jlc3VsdCwgaW5mb10gPSB3b3JsZEdlbmVyYXRvci5uZXh0KHtcbiAgICAgICAgeDogMCwgeTogMCwgejogMCwgc3RyaWRlOiAxNiwgaXRlcmF0aW9uOiAwLCBsYXllcjogMSwgcHJldmlvdXNPZmZzZXQ6IDhcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHtcbiAgICAgICAgeDogLTI0LCB5OiAtMjQsIHo6IC0yNCwgc3RyaWRlOiAxNlxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChpbmZvKS50b0VxdWFsKHtcbiAgICAgICAgeDogMCwgeTogMCwgejogMCwgc3RyaWRlOiAxNiwgaXRlcmF0aW9uOiAxLCBsYXllcjogMSwgcHJldmlvdXNPZmZzZXQ6IDhcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3JldHVybnMgY29ycmVjdCBwb3NpdGlvbiAzMi8wLzEnLCAoKSA9PiB7XG4gICAgICBsZXQgW3Jlc3VsdCwgaW5mb10gPSB3b3JsZEdlbmVyYXRvci5uZXh0KHtcbiAgICAgICAgeDogMCwgeTogMCwgejogMCwgc3RyaWRlOiAzMiwgaXRlcmF0aW9uOiAwLCBsYXllcjogMSwgcHJldmlvdXNPZmZzZXQ6IDQ4XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7XG4gICAgICAgIHg6IC04MCwgeTogLTgwLCB6OiAtODAsIHN0cmlkZTogMzJcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoaW5mbykudG9FcXVhbCh7XG4gICAgICAgIHg6IDAsIHk6IDAsIHo6IDAsIHN0cmlkZTogMzIsIGl0ZXJhdGlvbjogMSwgbGF5ZXI6IDEsIHByZXZpb3VzT2Zmc2V0OiA0OFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCd3aGVuIHJhZGl1cyBpcyBjYWxsZWQnLCAoKSA9PiB7XG4gICAgbGV0IGV4cGVjdGVkUmVzdWx0cyA9IFtcbiAgICAgIHsgbGF5ZXI6IDEsIHN0cmlkZTogOCwgcHJldmlvdXNPZmZzZXQ6IC00LCByZXN1bHQ6IDR9LFxuICAgICAgeyBsYXllcjogMiwgc3RyaWRlOiA4LCBwcmV2aW91c09mZnNldDogLTQsIHJlc3VsdDogMTJ9LFxuICAgICAgeyBsYXllcjogMSwgc3RyaWRlOiAxNiwgcHJldmlvdXNPZmZzZXQ6IDgsIHJlc3VsdDogMjR9LFxuICAgICAgeyBsYXllcjogMiwgc3RyaWRlOiAxNiwgcHJldmlvdXNPZmZzZXQ6IDgsIHJlc3VsdDogNDB9LFxuICAgICAgeyBsYXllcjogLTIsIHN0cmlkZTogMTYsIHByZXZpb3VzT2Zmc2V0OiA4LCByZXN1bHQ6IC00MH0sXG4gICAgXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwZWN0ZWRSZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB7bGF5ZXIsIHN0cmlkZSwgcHJldmlvdXNPZmZzZXQsIHJlc3VsdH0gPSBleHBlY3RlZFJlc3VsdHNbaV07XG4gICAgICBpdChgdGhlbiByaW5nICR7aSsxfSBpcyBjb3JyZWN0YCwgKCkgPT4ge1xuICAgICAgICBleHBlY3Qod29ybGRHZW5lcmF0b3IucmFkaXVzKGxheWVyLCBzdHJpZGUsIHByZXZpb3VzT2Zmc2V0KSkudG9FcXVhbChyZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICBkZXNjcmliZSgnd2hlbiBsYXllclJhZGl1cyBpcyBjYWxsZWQnLCAoKSA9PiB7XG4gICAgbGV0IGV4cGVjdGVkUmVzdWx0cyA9IFtcbiAgICAgIHsgbGF5ZXI6IDEsIHN0cmlkZTogOCwgcmVzdWx0OiAxfSxcbiAgICAgIHsgbGF5ZXI6IDIsIHN0cmlkZTogOCwgcmVzdWx0OiAyfSxcbiAgICAgIHsgbGF5ZXI6IDEsIHN0cmlkZTogMTYsIHJlc3VsdDogMn0sXG4gICAgICB7IGxheWVyOiAyLCBzdHJpZGU6IDE2LCByZXN1bHQ6IDN9LFxuICAgICAgeyBsYXllcjogMywgc3RyaWRlOiAxNiwgcmVzdWx0OiA0fSxcbiAgICAgIHsgbGF5ZXI6IDEsIHN0cmlkZTogMzIsIHJlc3VsdDogM30sXG4gICAgICB7IGxheWVyOiAyLCBzdHJpZGU6IDMyLCByZXN1bHQ6IDR9LFxuICAgIF07XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cGVjdGVkUmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qge2xheWVyLCBzdHJpZGUsIHJlc3VsdH0gPSBleHBlY3RlZFJlc3VsdHNbaV07XG4gICAgICBpdChgdGhlbiByaW5nICR7aSsxfSBpcyBjb3JyZWN0YCwgKCkgPT4ge1xuICAgICAgICBleHBlY3Qod29ybGRHZW5lcmF0b3IubGF5ZXJSYWRpdXMobGF5ZXIsIHN0cmlkZSkpLnRvRXF1YWwocmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3doZW4gbGF5ZXJDb3VudCBpcyBjYWxsZWQnLCAoKSA9PiB7XG4gICAgaXQoJ3JldHVybnMgMiBmb3IgZmlyc3Qgc3RyaWRlJywgKCkgPT4ge1xuICAgICAgZXhwZWN0KHdvcmxkR2VuZXJhdG9yLmxheWVyQ291bnQoOCkpLnRvRXF1YWwoMik7XG4gICAgfSk7XG5cbiAgICBpdCgncmV0dXJucyAzIGZvciBzZWNvbmQgc3RyaWRlJywgKCkgPT4ge1xuICAgICAgZXhwZWN0KHdvcmxkR2VuZXJhdG9yLmxheWVyQ291bnQoMTYpKS50b0VxdWFsKDMpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3JldHVybnMgMiBmb3Igc3Vic2VxdWVudCBzdHJpZGVzJywgKCkgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDMyOyBpIDwgMTAyNDsgaSs9aSkge1xuICAgICAgICBleHBlY3Qod29ybGRHZW5lcmF0b3IubGF5ZXJDb3VudChpKSkudG9FcXVhbCgyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dlbmVyYXRlIHBvaW50cycsICgpID0+IHtcbiAgICBpdCgncmV0dXJucyB0aGUgY29ycmVjdCB2YWx1ZXMnLCAoKSA9PiB7XG4gICAgICBleHBlY3QoZ2VuZXJhdGVQb2ludHMoMSkpLnRvRXF1YWwoW1xuICAgICAgICB7IHg6IC0xLCB5OiAtMSwgejogLTEgfSxcbiAgICAgICAgeyB4OiAtMSwgeTogLTEsIHo6IDEgfSxcbiAgICAgICAgeyB4OiAtMSwgeTogMSwgejogLTEgfSxcbiAgICAgICAgeyB4OiAtMSwgeTogMSwgejogMSB9LFxuICAgICAgICB7IHg6IDEsIHk6IC0xLCB6OiAtMSB9LFxuICAgICAgICB7IHg6IDEsIHk6IC0xLCB6OiAxIH0sXG4gICAgICAgIHsgeDogMSwgeTogMSwgejogLTEgfSxcbiAgICAgICAgeyB4OiAxLCB5OiAxLCB6OiAxIH0sXG4gICAgICBdKTtcbiAgICB9KTtcblxuICAgIGl0KCdyZXR1cm5zIHRoZSBjb3JyZWN0IHZhbHVlcyAyJywgKCkgPT4ge1xuICAgICAgZXhwZWN0KGdlbmVyYXRlUG9pbnRzKDIpLmxlbmd0aCkudG9FcXVhbCg1Nik7XG4gICAgfSk7XG4gIH0pXG59KTsiLCJleHBvcnQgaW50ZXJmYWNlIFdvcmxkR2VuZXJhdG9ySW5mbyB7XG4gIHg6IG51bWJlcjtcbiAgeTogbnVtYmVyO1xuICB6OiBudW1iZXI7XG4gIHN0cmlkZTogbnVtYmVyO1xuICBpdGVyYXRpb246IG51bWJlcjtcbiAgbGF5ZXI6IG51bWJlcjtcbiAgcHJldmlvdXNPZmZzZXQ6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFdvcmxkUG9zaXRpb24ge1xuICB4OiBudW1iZXI7XG4gIHk6IG51bWJlcjtcbiAgejogbnVtYmVyO1xuICBzdHJpZGU6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFBvaW50IHtcbiAgeDogbnVtYmVyO1xuICB5OiBudW1iZXI7XG4gIHo6IG51bWJlcjtcbn1cblxuZnVuY3Rpb24gZml4UG9pbnQoaTogbnVtYmVyKTogbnVtYmVyIHtcbiAgaWYgKGkgPj0gMCkgcmV0dXJuIGkgKyAxO1xuICByZXR1cm4gaTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUG9pbnRzKHJhZGl1czogbnVtYmVyKTogUG9pbnRbXSB7XG4gIGxldCBwb2ludHM6IFBvaW50W10gPSBbXTtcblxuICBsZXQgZGlhbWV0ZXIgPSByYWRpdXMgKiAyO1xuXG4gIGZvciAobGV0IHggPSAwOyB4IDwgZGlhbWV0ZXI7IHgrKylcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGRpYW1ldGVyOyB5KyspXG4gICAgICBmb3IgKGxldCB6ID0gMDsgeiA8IGRpYW1ldGVyOyB6KyspIHtcbiAgICAgICAgaWYgKCEoeCA9PT0gMCB8fCB4ID09PSBkaWFtZXRlciAtIDEgfHwgeSA9PT0gMCB8fCB5ID09PSBkaWFtZXRlciAtIDEgfHwgeiA9PT0gMCB8fCB6ID09PSBkaWFtZXRlciAtIDEpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBvaW50ID0ge1xuICAgICAgICAgIHg6IGZpeFBvaW50KHggLSByYWRpdXMpLFxuICAgICAgICAgIHk6IGZpeFBvaW50KHkgLSByYWRpdXMpLFxuICAgICAgICAgIHo6IGZpeFBvaW50KHogLSByYWRpdXMpXG4gICAgICAgIH07XG5cbiAgICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgfVxuXG4gIHJldHVybiBwb2ludHM7XG59XG5cbmNvbnN0IHBvaW50cyA9IFtdO1xuXG5mb3IgKGxldCBpID0gMDsgaSA8PSA2OyBpKyspIHtcbiAgcG9pbnRzW2ldID0gZ2VuZXJhdGVQb2ludHMoaSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdvcmxkR2VuZXJhdG9yIHtcbiAgcHJpdmF0ZSByZWFkb25seSBtaW5TdHJpZGU6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihtaW5TdHJpZGU6IG51bWJlcikge1xuICAgIHRoaXMubWluU3RyaWRlID0gbWluU3RyaWRlO1xuICB9XG5cbiAgaW5pdCh4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyKTogV29ybGRHZW5lcmF0b3JJbmZvIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogTWF0aC5yb3VuZCh4IC8gdGhpcy5taW5TdHJpZGUpICogdGhpcy5taW5TdHJpZGUsXG4gICAgICB5OiBNYXRoLnJvdW5kKHkgLyB0aGlzLm1pblN0cmlkZSkgKiB0aGlzLm1pblN0cmlkZSxcbiAgICAgIHo6IE1hdGgucm91bmQoeiAvIHRoaXMubWluU3RyaWRlKSAqIHRoaXMubWluU3RyaWRlLFxuICAgICAgc3RyaWRlOiB0aGlzLm1pblN0cmlkZSxcbiAgICAgIGl0ZXJhdGlvbjogMCxcbiAgICAgIGxheWVyOiAxLFxuICAgICAgcHJldmlvdXNPZmZzZXQ6IC0xICogdGhpcy5taW5TdHJpZGUgLyAyXG4gICAgfTtcbiAgfVxuXG4gIGxheWVyUmFkaXVzKGxheWVyOiBudW1iZXIsIHN0cmlkZTogbnVtYmVyKSB7XG4gICAgaWYgKHN0cmlkZSA9PT0gdGhpcy5taW5TdHJpZGUpIHtcbiAgICAgIHJldHVybiBsYXllcjtcbiAgICB9XG4gICAgaWYgKHN0cmlkZSA9PT0gdGhpcy5taW5TdHJpZGUgKiAyKSB7XG4gICAgICByZXR1cm4gbGF5ZXIgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gbGF5ZXIgKyAyO1xuICB9XG5cbiAgcmFkaXVzKGxheWVyOiBudW1iZXIsIHN0cmlkZTogbnVtYmVyLCBwcmV2aW91c09mZnNldDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5zaWduKGxheWVyKSAqIChwcmV2aW91c09mZnNldCArIChNYXRoLmFicyhsYXllcikgKiBzdHJpZGUpKTtcbiAgfVxuXG4gIGxheWVyQ291bnQoc3RyaWRlOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChzdHJpZGUgPT0gdGhpcy5taW5TdHJpZGUgKiAyKVxuICAgICAgcmV0dXJuIDM7XG4gICAgcmV0dXJuIDI7XG4gIH1cblxuICBuZXh0KGluZm86IFdvcmxkR2VuZXJhdG9ySW5mbyk6IFtXb3JsZFBvc2l0aW9uLCBXb3JsZEdlbmVyYXRvckluZm9dIHtcbiAgICBjb25zdCBvZmZzZXRzID0gcG9pbnRzW3RoaXMubGF5ZXJSYWRpdXMoaW5mby5sYXllciwgaW5mby5zdHJpZGUpXTtcblxuICAgIGNvbnN0IG9mZnNldCA9IG9mZnNldHNbaW5mby5pdGVyYXRpb25dO1xuICAgIGNvbnN0IGhhbGZTdHJpZGUgPSBpbmZvLnN0cmlkZSAvIDI7XG5cbiAgICBsZXQgaXRlcmF0aW9uID0gaW5mby5pdGVyYXRpb24gKyAxO1xuICAgIGxldCBsYXllciA9IGluZm8ubGF5ZXI7XG4gICAgbGV0IHN0cmlkZSA9IGluZm8uc3RyaWRlO1xuICAgIGxldCBwcmV2aW91c09mZnNldCA9IGluZm8ucHJldmlvdXNPZmZzZXQ7XG5cbiAgICBpZiAoaXRlcmF0aW9uID49IG9mZnNldHMubGVuZ3RoKSB7XG4gICAgICBpdGVyYXRpb24gPSAwO1xuICAgICAgbGF5ZXIrKztcblxuICAgICAgY29uc3QgbGF5ZXJDb3VudCA9IHRoaXMubGF5ZXJDb3VudChpbmZvLnN0cmlkZSk7XG4gICAgICBpZiAobGF5ZXIgPiBsYXllckNvdW50KSB7XG4gICAgICAgIGxheWVyID0gMTtcbiAgICAgICAgc3RyaWRlICo9IDI7XG4gICAgICAgIHByZXZpb3VzT2Zmc2V0ID0gdGhpcy5yYWRpdXMoaW5mby5sYXllciwgaW5mby5zdHJpZGUsIGluZm8ucHJldmlvdXNPZmZzZXQpIC0gaW5mby5zdHJpZGUgLyAyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB4OiBpbmZvLnN0cmlkZSAqIG9mZnNldC54ICsgaW5mby54IC0gTWF0aC5zaWduKG9mZnNldC54KSAqIGhhbGZTdHJpZGUsXG4gICAgICAgIHk6IGluZm8uc3RyaWRlICogb2Zmc2V0LnkgKyBpbmZvLnkgLSBNYXRoLnNpZ24ob2Zmc2V0LnkpICogaGFsZlN0cmlkZSxcbiAgICAgICAgejogaW5mby5zdHJpZGUgKiBvZmZzZXQueiArIGluZm8ueiAtIE1hdGguc2lnbihvZmZzZXQueikgKiBoYWxmU3RyaWRlLFxuICAgICAgICBzdHJpZGU6IGluZm8uc3RyaWRlXG4gICAgICB9LFxuICAgICAgeyAuLi5pbmZvLCBpdGVyYXRpb24sIGxheWVyLCBzdHJpZGUsIHByZXZpb3VzT2Zmc2V0IH1cbiAgICBdO1xuICB9XG59IiwidmFyIG1hcCA9IHtcblx0XCIuL2NvbXB1dGUtdm94ZWxzLnRlc3QudHNcIjogXCIuL3NyYy9jb21wdXRlLXZveGVscy50ZXN0LnRzXCIsXG5cdFwiLi9yZW5kZXJlci50ZXN0LnRzXCI6IFwiLi9zcmMvcmVuZGVyZXIudGVzdC50c1wiLFxuXHRcIi4vd29ybGQtZ2VuZXJhdG9yLnRlc3QudHNcIjogXCIuL3NyYy93b3JsZC1nZW5lcmF0b3IudGVzdC50c1wiXG59O1xuXG5cbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0KHJlcSkge1xuXHR2YXIgaWQgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKTtcblx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oaWQpO1xufVxuZnVuY3Rpb24gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkge1xuXHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKG1hcCwgcmVxKSkge1xuXHRcdHZhciBlID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJ1wiKTtcblx0XHRlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG5cdFx0dGhyb3cgZTtcblx0fVxuXHRyZXR1cm4gbWFwW3JlcV07XG59XG53ZWJwYWNrQ29udGV4dC5rZXlzID0gZnVuY3Rpb24gd2VicGFja0NvbnRleHRLZXlzKCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMobWFwKTtcbn07XG53ZWJwYWNrQ29udGV4dC5yZXNvbHZlID0gd2VicGFja0NvbnRleHRSZXNvbHZlO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrQ29udGV4dDtcbndlYnBhY2tDb250ZXh0LmlkID0gXCIuL3NyYyBzeW5jIHJlY3Vyc2l2ZSAudGVzdC4oanx0KXMkXCI7IiwiLyogKGlnbm9yZWQpICovIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0aWYoX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSkge1xuXHRcdHJldHVybiBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0aWQ6IG1vZHVsZUlkLFxuXHRcdGxvYWRlZDogZmFsc2UsXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuXHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIl9fd2VicGFja19yZXF1aXJlX18uYW1kRCA9IGZ1bmN0aW9uICgpIHtcblx0dGhyb3cgbmV3IEVycm9yKCdkZWZpbmUgY2Fubm90IGJlIHVzZWQgaW5kaXJlY3QnKTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5hbWRPID0ge307IiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm5tZCA9IChtb2R1bGUpID0+IHtcblx0bW9kdWxlLnBhdGhzID0gW107XG5cdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0cmV0dXJuIG1vZHVsZTtcbn07IiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGVcbl9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy90ZXN0cy50c1wiKTtcbi8vIFRoaXMgZW50cnkgbW9kdWxlIHVzZWQgJ2V4cG9ydHMnIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbiJdLCJzb3VyY2VSb290IjoiIn0=