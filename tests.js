/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/jasmine-core/lib/jasmine-core/jasmine.css":
/*!******************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/jasmine-core/lib/jasmine-core/jasmine.css ***!
  \******************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "@charset \"UTF-8\";\nbody {\n  overflow-y: scroll;\n}\n\n.jasmine_html-reporter {\n  width: 100%;\n  background-color: #eee;\n  padding: 5px;\n  margin: -8px;\n  font-size: 11px;\n  font-family: Monaco, \"Lucida Console\", monospace;\n  line-height: 14px;\n  color: #333;\n}\n.jasmine_html-reporter a {\n  text-decoration: none;\n}\n.jasmine_html-reporter a:hover {\n  text-decoration: underline;\n}\n.jasmine_html-reporter p, .jasmine_html-reporter h1, .jasmine_html-reporter h2, .jasmine_html-reporter h3, .jasmine_html-reporter h4, .jasmine_html-reporter h5, .jasmine_html-reporter h6 {\n  margin: 0;\n  line-height: 14px;\n}\n.jasmine_html-reporter .jasmine-banner,\n.jasmine_html-reporter .jasmine-symbol-summary,\n.jasmine_html-reporter .jasmine-summary,\n.jasmine_html-reporter .jasmine-result-message,\n.jasmine_html-reporter .jasmine-spec .jasmine-description,\n.jasmine_html-reporter .jasmine-spec-detail .jasmine-description,\n.jasmine_html-reporter .jasmine-alert .jasmine-bar,\n.jasmine_html-reporter .jasmine-stack-trace {\n  padding-left: 9px;\n  padding-right: 9px;\n}\n.jasmine_html-reporter .jasmine-banner {\n  position: relative;\n}\n.jasmine_html-reporter .jasmine-banner .jasmine-title {\n  background: url(\"data:image/png;base64,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\") no-repeat;\n  background: url(\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgdmVyc2lvbj0iMS4xIgogICB3aWR0aD0iNjgxLjk2MjUyIgogICBoZWlnaHQ9IjE4Ny41IgogICBpZD0ic3ZnMiIKICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhOCI+PHJkZjpSREY+PGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPjxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PjxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz48L2NjOldvcms+PC9yZGY6UkRGPjwvbWV0YWRhdGE+PGRlZnMKICAgICBpZD0iZGVmczYiPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMTgiPjxwYXRoCiAgICAgICAgIGQ9Ik0gMCwxNTAwIDAsMCBsIDU0NTUuNzQsMCAwLDE1MDAgTCAwLDE1MDAgeiIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgaWQ9InBhdGgyMCIgLz48L2NsaXBQYXRoPjwvZGVmcz48ZwogICAgIHRyYW5zZm9ybT0ibWF0cml4KDEuMjUsMCwwLC0xLjI1LDAsMTg3LjUpIgogICAgIGlkPSJnMTAiPjxnCiAgICAgICB0cmFuc2Zvcm09InNjYWxlKDAuMSwwLjEpIgogICAgICAgaWQ9ImcxMiI+PGcKICAgICAgICAgaWQ9ImcxNCI+PGcKICAgICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGgxOCkiCiAgICAgICAgICAgaWQ9ImcxNiI+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMTU0NCw1OTkuNDM0IGMgMC45MiwtNDAuMzUyIDI1LjY4LC04MS42MDIgNzEuNTMsLTgxLjYwMiAyNy41MSwwIDQ3LjY4LDEyLjgzMiA2MS40NCwzNS43NTQgMTIuODMsMjIuOTMgMTIuODMsNTYuODUyIDEyLjgzLDgyLjUyNyBsIDAsMzI5LjE4NCAtNzEuNTIsMCAwLDEwNC41NDMgMjY2LjgzLDAgMCwtMTA0LjU0MyAtNzAuNiwwIDAsLTM0NC43NyBjIDAsLTU4LjY5MSAtMy42OCwtMTA0LjUzMSAtNDQuOTMsLTE1Mi4yMTggLTM2LjY4LC00Mi4xOCAtOTYuMjgsLTY2LjAyIC0xNTMuMTQsLTY2LjAyIC0xMTcuMzcsMCAtMjA3LjI0LDc3Ljk0MSAtMjAyLjY0LDE5Ny4xNDUgbCAxMzAuMiwwIgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMjIiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDIzMDEuNCw2NjIuNjk1IGMgMCw4MC43MDMgLTY2Ljk0LDE0NS44MTMgLTE0Ny42MywxNDUuODEzIC04My40NCwwIC0xNDcuNjMsLTY4Ljc4MSAtMTQ3LjYzLC0xNTEuMzAxIDAsLTc5Ljc4NSA2Ni45NCwtMTQ1LjgwMSAxNDUuOCwtMTQ1LjgwMSA4NC4zNSwwIDE0OS40Niw2Ny44NTIgMTQ5LjQ2LDE1MS4yODkgeiBtIC0xLjgzLC0xODEuNTQ3IGMgLTM1Ljc3LC01NC4wOTcgLTkzLjUzLC03OC44NTkgLTE1Ny43MiwtNzguODU5IC0xNDAuMywwIC0yNTEuMjQsMTE2LjQ0OSAtMjUxLjI0LDI1NC45MTggMCwxNDIuMTI5IDExMy43LDI2MC40MSAyNTYuNzQsMjYwLjQxIDYzLjI3LDAgMTE4LjI5LC0yOS4zMzYgMTUyLjIyLC04Mi41MjMgbCAwLDY5LjY4NyAxNzUuMTQsMCAwLC0xMDQuNTI3IC02MS40NCwwIDAsLTI4MC41OTggNjEuNDQsMCAwLC0xMDQuNTI3IC0xNzUuMTQsMCAwLDY2LjAxOSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDI0IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSAyNjIyLjMzLDU1Ny4yNTggYyAzLjY3LC00NC4wMTYgMzMuMDEsLTczLjM0OCA3OC44NiwtNzMuMzQ4IDMzLjkzLDAgNjYuOTMsMjMuODI0IDY2LjkzLDYwLjUwNCAwLDQ4LjYwNiAtNDUuODQsNTYuODU2IC04My40NCw2Ni45NDEgLTg1LjI4LDIyLjAwNCAtMTc4LjgxLDQ4LjYwNiAtMTc4LjgxLDE1NS44NzkgMCw5My41MzYgNzguODYsMTQ3LjYzMyAxNjUuOTgsMTQ3LjYzMyA0NCwwIDgzLjQzLC05LjE3NiAxMTAuOTQsLTQ0LjAwOCBsIDAsMzMuOTIyIDgyLjUzLDAgMCwtMTMyLjk2NSAtMTA4LjIxLDAgYyAtMS44MywzNC44NTYgLTI4LjQyLDU3Ljc3NCAtNjMuMjYsNTcuNzc0IC0zMC4yNiwwIC02Mi4zNSwtMTcuNDIyIC02Mi4zNSwtNTEuMzQ4IDAsLTQ1Ljg0NyA0NC45MywtNTUuOTMgODAuNjksLTY0LjE4IDg4LjAyLC0yMC4xNzUgMTgyLjQ3LC00Ny42OTUgMTgyLjQ3LC0xNTcuNzM0IDAsLTk5LjAyNyAtODMuNDQsLTE1NC4wMzkgLTE3NS4xMywtMTU0LjAzOSAtNDkuNTMsMCAtOTQuNDYsMTUuNTgyIC0xMjYuNTUsNTMuMTggbCAwLC00MC4zNCAtODUuMjcsMCAwLDE0Mi4xMjkgMTE0LjYyLDAiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGgyNiIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMjk4OC4xOCw4MDAuMjU0IC02My4yNiwwIDAsMTA0LjUyNyAxNjUuMDUsMCAwLC03My4zNTUgYyAzMS4xOCw1MS4zNDcgNzguODYsODUuMjc3IDE0MS4yMSw4NS4yNzcgNjcuODUsMCAxMjQuNzEsLTQxLjI1OCAxNTIuMjEsLTEwMi42OTkgMjYuNiw2Mi4zNTEgOTIuNjIsMTAyLjY5OSAxNjAuNDcsMTAyLjY5OSA1My4xOSwwIDEwNS40NiwtMjIgMTQxLjIxLC02Mi4zNTEgMzguNTIsLTQ0LjkzOCAzOC41MiwtOTMuNTMyIDM4LjUyLC0xNDkuNDU3IGwgMCwtMTg1LjIzOSA2My4yNywwIDAsLTEwNC41MjcgLTIzOC40MiwwIDAsMTA0LjUyNyA2My4yOCwwIDAsMTU3LjcxNSBjIDAsMzIuMTAyIDAsNjAuNTI3IC0xNC42Nyw4OC45NTcgLTE4LjM0LDI2LjU4MiAtNDguNjEsNDAuMzQ0IC03OS43Nyw0MC4zNDQgLTMwLjI2LDAgLTYzLjI4LC0xMi44NDQgLTgyLjUzLC0zNi42NzIgLTIyLjkzLC0yOS4zNTUgLTIyLjkzLC01Ni44NjMgLTIyLjkzLC05Mi42MjkgbCAwLC0xNTcuNzE1IDYzLjI3LDAgMCwtMTA0LjUyNyAtMjM4LjQxLDAgMCwxMDQuNTI3IDYzLjI4LDAgMCwxNTAuMzgzIGMgMCwyOS4zNDggMCw2Ni4wMjMgLTE0LjY3LDkxLjY5OSAtMTUuNTksMjkuMzM2IC00Ny42OSw0NC45MzQgLTgwLjcsNDQuOTM0IC0zMS4xOCwwIC01Ny43NywtMTEuMDA4IC03Ny45NCwtMzUuNzc0IC0yNC43NywtMzAuMjUzIC0yNi42LC02Mi4zNDMgLTI2LjYsLTk5Ljk0MSBsIDAsLTE1MS4zMDEgNjMuMjcsMCAwLC0xMDQuNTI3IC0yMzguNCwwIDAsMTA0LjUyNyA2My4yNiwwIDAsMjgwLjU5OCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDI4IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSAzOTk4LjY2LDk1MS41NDcgLTExMS44NywwIDAsMTE4LjI5MyAxMTEuODcsMCAwLC0xMTguMjkzIHogbSAwLC00MzEuODkxIDYzLjI3LDAgMCwtMTA0LjUyNyAtMjM5LjMzLDAgMCwxMDQuNTI3IDY0LjE5LDAgMCwyODAuNTk4IC02My4yNywwIDAsMTA0LjUyNyAxNzUuMTQsMCAwLC0zODUuMTI1IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzAiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDQxNTkuMTIsODAwLjI1NCAtNjMuMjcsMCAwLDEwNC41MjcgMTc1LjE0LDAgMCwtNjkuNjg3IGMgMjkuMzUsNTQuMTAxIDg0LjM2LDgwLjY5OSAxNDQuODcsODAuNjk5IDUzLjE5LDAgMTA1LjQ1LC0yMi4wMTYgMTQxLjIyLC02MC41MjcgNDAuMzQsLTQ0LjkzNCA0MS4yNiwtODguMDMyIDQxLjI2LC0xNDMuOTU3IGwgMCwtMTkxLjY1MyA2My4yNywwIDAsLTEwNC41MjcgLTIzOC40LDAgMCwxMDQuNTI3IDYzLjI2LDAgMCwxNTguNjM3IGMgMCwzMC4yNjIgMCw2MS40MzQgLTE5LjI2LDg4LjAzNSAtMjAuMTcsMjYuNTgyIC01My4xOCwzOS40MTQgLTg2LjE5LDM5LjQxNCAtMzMuOTMsMCAtNjguNzcsLTEzLjc1IC04OC45NCwtNDEuMjUgLTIxLjA5LC0yNy41IC0yMS4wOSwtNjkuNjg3IC0yMS4wOSwtMTAyLjcwNyBsIDAsLTE0Mi4xMjkgNjMuMjYsMCAwLC0xMDQuNTI3IC0yMzguNCwwIDAsMTA0LjUyNyA2My4yNywwIDAsMjgwLjU5OCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDMyIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA1MDgyLjQ4LDcwMy45NjUgYyAtMTkuMjQsNzAuNjA1IC04MS42LDExNS41NDcgLTE1NC4wNCwxMTUuNTQ3IC02Ni4wNCwwIC0xMjkuMywtNTEuMzQ4IC0xNDMuMDUsLTExNS41NDcgbCAyOTcuMDksMCB6IG0gODUuMjcsLTE0NC44ODMgYyAtMzguNTEsLTkzLjUyMyAtMTI5LjI3LC0xNTYuNzkzIC0yMzEuMDUsLTE1Ni43OTMgLTE0My4wNywwIC0yNTcuNjgsMTExLjg3MSAtMjU3LjY4LDI1NS44MzYgMCwxNDQuODgzIDEwOS4xMiwyNjEuMzI4IDI1NC45MSwyNjEuMzI4IDY3Ljg3LDAgMTM1LjcyLC0zMC4yNTggMTgzLjM5LC03OC44NjMgNDguNjIsLTUxLjM0NCA2OC43OSwtMTEzLjY5NSA2OC43OSwtMTgzLjM4MyBsIC0zLjY3LC0zOS40MzQgLTM5Ni4xMywwIGMgMTQuNjcsLTY3Ljg2MyA3Ny4wMywtMTE3LjM2MyAxNDYuNzIsLTExNy4zNjMgNDguNTksMCA5MC43NiwxOC4zMjggMTE4LjI4LDU4LjY3MiBsIDExNi40NCwwIgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzQiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDY5MC44OTUsODUwLjcwMyA5MC43NSwwIDIyLjU0MywzMS4wMzUgMCwyNDMuMTIyIC0xMzUuODI5LDAgMCwtMjQzLjE0MSAyMi41MzYsLTMxLjAxNiIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDM2IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA2MzIuMzk1LDc0Mi4yNTggMjguMDM5LDg2LjMwNCAtMjIuNTUxLDMxLjA0IC0yMzEuMjIzLDc1LjEyOCAtNDEuOTc2LC0xMjkuMTgzIDIzMS4yNTcsLTc1LjEzNyAzNi40NTQsMTEuODQ4IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzgiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDcxNy40NDksNjUzLjEwNSAtNzMuNDEsNTMuMzYgLTM2LjQ4OCwtMTEuODc1IC0xNDIuOTAzLC0xOTYuNjkyIDEwOS44ODMsLTc5LjgyOCAxNDIuOTE4LDE5Ni43MDMgMCwzOC4zMzIiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGg0MCIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gODI4LjUyLDcwNi40NjUgLTczLjQyNiwtNTMuMzQgMC4wMTEsLTM4LjM1OSBMIDg5OC4wMDQsNDE4LjA3IDEwMDcuOSw0OTcuODk4IDg2NC45NzMsNjk0LjYwOSA4MjguNTIsNzA2LjQ2NSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDQyIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA4MTIuMDg2LDgyOC41ODYgMjguMDU1LC04Ni4zMiAzNi40ODQsLTExLjgzNiAyMzEuMjI1LDc1LjExNyAtNDEuOTcsMTI5LjE4MyAtMjMxLjIzOSwtNzUuMTQgLTIyLjU1NSwtMzEuMDA0IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNDQiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDczNi4zMDEsMTMzNS44OCBjIC0zMjMuMDQ3LDAgLTU4NS44NzUsLTI2Mi43OCAtNTg1Ljg3NSwtNTg1Ljc4MiAwLC0zMjMuMTE4IDI2Mi44MjgsLTU4NS45NzcgNTg1Ljg3NSwtNTg1Ljk3NyAzMjMuMDE5LDAgNTg1LjgwOSwyNjIuODU5IDU4NS44MDksNTg1Ljk3NyAwLDMyMy4wMDIgLTI2Mi43OSw1ODUuNzgyIC01ODUuODA5LDU4NS43ODIgbCAwLDAgeiBtIDAsLTExOC42MSBjIDI1Ny45NzIsMCA0NjcuMTg5LC0yMDkuMTMgNDY3LjE4OSwtNDY3LjE3MiAwLC0yNTguMTI5IC0yMDkuMjE3LC00NjcuMzQ4IC00NjcuMTg5LC00NjcuMzQ4IC0yNTguMDc0LDAgLTQ2Ny4yNTQsMjA5LjIxOSAtNDY3LjI1NCw0NjcuMzQ4IDAsMjU4LjA0MiAyMDkuMTgsNDY3LjE3MiA0NjcuMjU0LDQ2Ny4xNzIiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGg0NiIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMTA5MS4xMyw2MTkuODgzIC0xNzUuNzcxLDU3LjEyMSAxMS42MjksMzUuODA4IDE3NS43NjIsLTU3LjEyMSAtMTEuNjIsLTM1LjgwOCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDQ4IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0iTSA4NjYuOTU3LDkwMi4wNzQgODM2LjUsOTI0LjE5OSA5NDUuMTIxLDEwNzMuNzMgOTc1LjU4NiwxMDUxLjYxIDg2Ni45NTcsOTAyLjA3NCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDUwIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0iTSA2MDcuNDY1LDkwMy40NDUgNDk4Ljg1NSwxMDUyLjk3IDUyOS4zMiwxMDc1LjEgNjM3LjkzLDkyNS41NjYgNjA3LjQ2NSw5MDMuNDQ1IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNTIiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDM4MC42ODgsNjIyLjEyOSAtMTEuNjI2LDM1LjgwMSAxNzUuNzU4LDU3LjA5IDExLjYyMSwtMzUuODAxIC0xNzUuNzUzLC01Ny4wOSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDU0IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA3MTYuMjg5LDM3Ni41OSAzNy42NDA2LDAgMCwxODQuODE2IC0zNy42NDA2LDAgMCwtMTg0LjgxNiB6IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNTYiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjwvZz48L2c+PC9nPjwvZz48L3N2Zz4=\") no-repeat, none;\n  -moz-background-size: 100%;\n  -o-background-size: 100%;\n  -webkit-background-size: 100%;\n  background-size: 100%;\n  display: block;\n  float: left;\n  width: 90px;\n  height: 25px;\n}\n.jasmine_html-reporter .jasmine-banner .jasmine-version {\n  margin-left: 14px;\n  position: relative;\n  top: 6px;\n}\n.jasmine_html-reporter #jasmine_content {\n  position: fixed;\n  right: 100%;\n}\n.jasmine_html-reporter .jasmine-version {\n  color: #aaa;\n}\n.jasmine_html-reporter .jasmine-banner {\n  margin-top: 14px;\n}\n.jasmine_html-reporter .jasmine-duration {\n  color: #fff;\n  float: right;\n  line-height: 28px;\n  padding-right: 9px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary {\n  overflow: hidden;\n  margin: 14px 0;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li {\n  display: inline-block;\n  height: 10px;\n  width: 14px;\n  font-size: 16px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-passed {\n  font-size: 14px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-passed:before {\n  color: #007069;\n  content: \"•\";\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-failed {\n  line-height: 9px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-failed:before {\n  color: #ca3a11;\n  content: \"×\";\n  font-weight: bold;\n  margin-left: -1px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-excluded {\n  font-size: 14px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-excluded:before {\n  color: #bababa;\n  content: \"•\";\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-excluded-no-display {\n  font-size: 14px;\n  display: none;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-pending {\n  line-height: 17px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-pending:before {\n  color: #ba9d37;\n  content: \"*\";\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-empty {\n  font-size: 14px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-empty:before {\n  color: #ba9d37;\n  content: \"•\";\n}\n.jasmine_html-reporter .jasmine-run-options {\n  float: right;\n  margin-right: 5px;\n  border: 1px solid #8a4182;\n  color: #8a4182;\n  position: relative;\n  line-height: 20px;\n}\n.jasmine_html-reporter .jasmine-run-options .jasmine-trigger {\n  cursor: pointer;\n  padding: 8px 16px;\n}\n.jasmine_html-reporter .jasmine-run-options .jasmine-payload {\n  position: absolute;\n  display: none;\n  right: -1px;\n  border: 1px solid #8a4182;\n  background-color: #eee;\n  white-space: nowrap;\n  padding: 4px 8px;\n}\n.jasmine_html-reporter .jasmine-run-options .jasmine-payload.jasmine-open {\n  display: block;\n}\n.jasmine_html-reporter .jasmine-bar {\n  line-height: 28px;\n  font-size: 14px;\n  display: block;\n  color: #eee;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-failed, .jasmine_html-reporter .jasmine-bar.jasmine-errored {\n  background-color: #ca3a11;\n  border-bottom: 1px solid #eee;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-passed {\n  background-color: #007069;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-incomplete {\n  background-color: #bababa;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-skipped {\n  background-color: #bababa;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-warning {\n  margin-top: 14px;\n  margin-bottom: 14px;\n  background-color: #ba9d37;\n  color: #333;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-menu {\n  background-color: #fff;\n  color: #aaa;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-menu a {\n  color: #333;\n}\n.jasmine_html-reporter .jasmine-bar a {\n  color: white;\n}\n.jasmine_html-reporter.jasmine-spec-list .jasmine-bar.jasmine-menu.jasmine-failure-list,\n.jasmine_html-reporter.jasmine-spec-list .jasmine-results .jasmine-failures {\n  display: none;\n}\n.jasmine_html-reporter.jasmine-failure-list .jasmine-bar.jasmine-menu.jasmine-spec-list,\n.jasmine_html-reporter.jasmine-failure-list .jasmine-summary {\n  display: none;\n}\n.jasmine_html-reporter .jasmine-results {\n  margin-top: 14px;\n}\n.jasmine_html-reporter .jasmine-summary {\n  margin-top: 14px;\n}\n.jasmine_html-reporter .jasmine-summary ul {\n  list-style-type: none;\n  margin-left: 14px;\n  padding-top: 0;\n  padding-left: 0;\n}\n.jasmine_html-reporter .jasmine-summary ul.jasmine-suite {\n  margin-top: 7px;\n  margin-bottom: 7px;\n}\n.jasmine_html-reporter .jasmine-summary li.jasmine-passed a {\n  color: #007069;\n}\n.jasmine_html-reporter .jasmine-summary li.jasmine-failed a {\n  color: #ca3a11;\n}\n.jasmine_html-reporter .jasmine-summary li.jasmine-empty a {\n  color: #ba9d37;\n}\n.jasmine_html-reporter .jasmine-summary li.jasmine-pending a {\n  color: #ba9d37;\n}\n.jasmine_html-reporter .jasmine-summary li.jasmine-excluded a {\n  color: #bababa;\n}\n.jasmine_html-reporter .jasmine-specs li.jasmine-passed a:before {\n  content: \"• \";\n}\n.jasmine_html-reporter .jasmine-specs li.jasmine-failed a:before {\n  content: \"× \";\n}\n.jasmine_html-reporter .jasmine-specs li.jasmine-empty a:before {\n  content: \"* \";\n}\n.jasmine_html-reporter .jasmine-specs li.jasmine-pending a:before {\n  content: \"• \";\n}\n.jasmine_html-reporter .jasmine-specs li.jasmine-excluded a:before {\n  content: \"• \";\n}\n.jasmine_html-reporter .jasmine-description + .jasmine-suite {\n  margin-top: 0;\n}\n.jasmine_html-reporter .jasmine-suite {\n  margin-top: 14px;\n}\n.jasmine_html-reporter .jasmine-suite a {\n  color: #333;\n}\n.jasmine_html-reporter .jasmine-failures .jasmine-spec-detail {\n  margin-bottom: 28px;\n}\n.jasmine_html-reporter .jasmine-failures .jasmine-spec-detail .jasmine-description {\n  background-color: #ca3a11;\n  color: white;\n}\n.jasmine_html-reporter .jasmine-failures .jasmine-spec-detail .jasmine-description a {\n  color: white;\n}\n.jasmine_html-reporter .jasmine-result-message {\n  padding-top: 14px;\n  color: #333;\n  white-space: pre-wrap;\n}\n.jasmine_html-reporter .jasmine-result-message span.jasmine-result {\n  display: block;\n}\n.jasmine_html-reporter .jasmine-stack-trace {\n  margin: 5px 0 0 0;\n  max-height: 224px;\n  overflow: auto;\n  line-height: 18px;\n  color: #666;\n  border: 1px solid #ddd;\n  background: white;\n  white-space: pre;\n}\n.jasmine_html-reporter .jasmine-expander a {\n  display: block;\n  margin-left: 14px;\n  color: blue;\n  text-decoration: underline;\n}\n.jasmine_html-reporter .jasmine-expander-contents {\n  display: none;\n}\n.jasmine_html-reporter .jasmine-expanded {\n  padding-bottom: 10px;\n}\n.jasmine_html-reporter .jasmine-expanded .jasmine-expander-contents {\n  display: block;\n  margin-left: 14px;\n  padding: 5px;\n}\n.jasmine_html-reporter .jasmine-debug-log {\n  margin: 5px 0 0 0;\n  padding: 5px;\n  color: #666;\n  border: 1px solid #ddd;\n  background: white;\n}\n.jasmine_html-reporter .jasmine-debug-log table {\n  border-spacing: 0;\n}\n.jasmine_html-reporter .jasmine-debug-log table, .jasmine_html-reporter .jasmine-debug-log th, .jasmine_html-reporter .jasmine-debug-log td {\n  border: 1px solid #ddd;\n}", "",{"version":3,"sources":["webpack://./node_modules/jasmine-core/lib/jasmine-core/jasmine.css"],"names":[],"mappings":"AAAA,gBAAgB;AAChB;EACE,kBAAkB;AACpB;;AAEA;EACE,WAAW;EACX,sBAAsB;EACtB,YAAY;EACZ,YAAY;EACZ,eAAe;EACf,gDAAgD;EAChD,iBAAiB;EACjB,WAAW;AACb;AACA;EACE,qBAAqB;AACvB;AACA;EACE,0BAA0B;AAC5B;AACA;EACE,SAAS;EACT,iBAAiB;AACnB;AACA;;;;;;;;EAQE,iBAAiB;EACjB,kBAAkB;AACpB;AACA;EACE,kBAAkB;AACpB;AACA;EACE,myEAAmyE;EACnyE,ikXAAikX;EACjkX,0BAA0B;EAC1B,wBAAwB;EACxB,6BAA6B;EAC7B,qBAAqB;EACrB,cAAc;EACd,WAAW;EACX,WAAW;EACX,YAAY;AACd;AACA;EACE,iBAAiB;EACjB,kBAAkB;EAClB,QAAQ;AACV;AACA;EACE,eAAe;EACf,WAAW;AACb;AACA;EACE,WAAW;AACb;AACA;EACE,gBAAgB;AAClB;AACA;EACE,WAAW;EACX,YAAY;EACZ,iBAAiB;EACjB,kBAAkB;AACpB;AACA;EACE,gBAAgB;EAChB,cAAc;AAChB;AACA;EACE,qBAAqB;EACrB,YAAY;EACZ,WAAW;EACX,eAAe;AACjB;AACA;EACE,eAAe;AACjB;AACA;EACE,cAAc;EACd,YAAY;AACd;AACA;EACE,gBAAgB;AAClB;AACA;EACE,cAAc;EACd,YAAY;EACZ,iBAAiB;EACjB,iBAAiB;AACnB;AACA;EACE,eAAe;AACjB;AACA;EACE,cAAc;EACd,YAAY;AACd;AACA;EACE,eAAe;EACf,aAAa;AACf;AACA;EACE,iBAAiB;AACnB;AACA;EACE,cAAc;EACd,YAAY;AACd;AACA;EACE,eAAe;AACjB;AACA;EACE,cAAc;EACd,YAAY;AACd;AACA;EACE,YAAY;EACZ,iBAAiB;EACjB,yBAAyB;EACzB,cAAc;EACd,kBAAkB;EAClB,iBAAiB;AACnB;AACA;EACE,eAAe;EACf,iBAAiB;AACnB;AACA;EACE,kBAAkB;EAClB,aAAa;EACb,WAAW;EACX,yBAAyB;EACzB,sBAAsB;EACtB,mBAAmB;EACnB,gBAAgB;AAClB;AACA;EACE,cAAc;AAChB;AACA;EACE,iBAAiB;EACjB,eAAe;EACf,cAAc;EACd,WAAW;AACb;AACA;EACE,yBAAyB;EACzB,6BAA6B;AAC/B;AACA;EACE,yBAAyB;AAC3B;AACA;EACE,yBAAyB;AAC3B;AACA;EACE,yBAAyB;AAC3B;AACA;EACE,gBAAgB;EAChB,mBAAmB;EACnB,yBAAyB;EACzB,WAAW;AACb;AACA;EACE,sBAAsB;EACtB,WAAW;AACb;AACA;EACE,WAAW;AACb;AACA;EACE,YAAY;AACd;AACA;;EAEE,aAAa;AACf;AACA;;EAEE,aAAa;AACf;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,qBAAqB;EACrB,iBAAiB;EACjB,cAAc;EACd,eAAe;AACjB;AACA;EACE,eAAe;EACf,kBAAkB;AACpB;AACA;EACE,cAAc;AAChB;AACA;EACE,cAAc;AAChB;AACA;EACE,cAAc;AAChB;AACA;EACE,cAAc;AAChB;AACA;EACE,cAAc;AAChB;AACA;EACE,aAAa;AACf;AACA;EACE,aAAa;AACf;AACA;EACE,aAAa;AACf;AACA;EACE,aAAa;AACf;AACA;EACE,aAAa;AACf;AACA;EACE,aAAa;AACf;AACA;EACE,gBAAgB;AAClB;AACA;EACE,WAAW;AACb;AACA;EACE,mBAAmB;AACrB;AACA;EACE,yBAAyB;EACzB,YAAY;AACd;AACA;EACE,YAAY;AACd;AACA;EACE,iBAAiB;EACjB,WAAW;EACX,qBAAqB;AACvB;AACA;EACE,cAAc;AAChB;AACA;EACE,iBAAiB;EACjB,iBAAiB;EACjB,cAAc;EACd,iBAAiB;EACjB,WAAW;EACX,sBAAsB;EACtB,iBAAiB;EACjB,gBAAgB;AAClB;AACA;EACE,cAAc;EACd,iBAAiB;EACjB,WAAW;EACX,0BAA0B;AAC5B;AACA;EACE,aAAa;AACf;AACA;EACE,oBAAoB;AACtB;AACA;EACE,cAAc;EACd,iBAAiB;EACjB,YAAY;AACd;AACA;EACE,iBAAiB;EACjB,YAAY;EACZ,WAAW;EACX,sBAAsB;EACtB,iBAAiB;AACnB;AACA;EACE,iBAAiB;AACnB;AACA;EACE,sBAAsB;AACxB","sourcesContent":["@charset \"UTF-8\";\nbody {\n  overflow-y: scroll;\n}\n\n.jasmine_html-reporter {\n  width: 100%;\n  background-color: #eee;\n  padding: 5px;\n  margin: -8px;\n  font-size: 11px;\n  font-family: Monaco, \"Lucida Console\", monospace;\n  line-height: 14px;\n  color: #333;\n}\n.jasmine_html-reporter a {\n  text-decoration: none;\n}\n.jasmine_html-reporter a:hover {\n  text-decoration: underline;\n}\n.jasmine_html-reporter p, .jasmine_html-reporter h1, .jasmine_html-reporter h2, .jasmine_html-reporter h3, .jasmine_html-reporter h4, .jasmine_html-reporter h5, .jasmine_html-reporter h6 {\n  margin: 0;\n  line-height: 14px;\n}\n.jasmine_html-reporter .jasmine-banner,\n.jasmine_html-reporter .jasmine-symbol-summary,\n.jasmine_html-reporter .jasmine-summary,\n.jasmine_html-reporter .jasmine-result-message,\n.jasmine_html-reporter .jasmine-spec .jasmine-description,\n.jasmine_html-reporter .jasmine-spec-detail .jasmine-description,\n.jasmine_html-reporter .jasmine-alert .jasmine-bar,\n.jasmine_html-reporter .jasmine-stack-trace {\n  padding-left: 9px;\n  padding-right: 9px;\n}\n.jasmine_html-reporter .jasmine-banner {\n  position: relative;\n}\n.jasmine_html-reporter .jasmine-banner .jasmine-title {\n  background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAAAZCAMAAACGusnyAAACdlBMVEX/////AP+AgICqVaqAQICZM5mAVYCSSZKAQICOOY6ATYCLRouAQICJO4mSSYCIRIiPQICHPIeOR4CGQ4aMQICGPYaLRoCFQ4WKQICPPYWJRYCOQoSJQICNPoSIRICMQoSHQICHRICKQoOHQICKPoOJO4OJQYOMQICMQ4CIQYKLQICIPoKLQ4CKQICNPoKJQISMQ4KJQoSLQYKJQISLQ4KIQoSKQYKIQICIQISMQoSKQYKLQIOLQoOJQYGLQIOKQIOMQoGKQYOLQYGKQIOLQoGJQYOJQIOKQYGJQIOKQoGKQIGLQIKLQ4KKQoGLQYKJQIGKQYKJQIGKQIKJQoGKQYKLQIGKQYKLQIOJQoKKQoOJQYKKQIOJQoKKQoOKQIOLQoKKQYOLQYKJQIOKQoKKQYKKQoKJQYOKQYKLQIOKQoKLQYOKQYKLQIOJQoGKQYKJQYGJQoGKQYKLQoGLQYGKQoGJQYKKQYGJQIKKQoGJQYKLQIKKQYGLQYKKQYGKQYGKQYKJQYOKQoKJQYOKQYKLQYOLQYOKQYKLQYOKQoKKQYKKQYOKQYOJQYKKQYKLQYKKQIKKQoKKQYKKQYKKQoKJQIKKQYKLQYKKQYKKQIKKQYKKQYKKQYKKQIKKQYKJQYGLQYGKQYKKQYKKQYGKQIKKQYGKQYOJQoKKQYOLQYKKQYOKQoKKQYKKQoKKQYKKQYKJQYKLQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKJQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKLQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKmIDpEAAAA0XRSTlMAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAiIyQlJycoKissLS4wMTQ1Njc4OTo7PDw+P0BCQ0RISUpLTE1OUFNUVVdYWFlaW15fYGFiY2ZnaGlqa2xtb3BxcnN0dnh5ent8fX5/gIGChIWIioyNjo+QkZOUlZaYmZqbnJ2eoKGio6WmqKmsra6vsLGztre4ubq7vL2+wMHDxMjJysvNzs/Q0dLU1tfY2dvc3t/g4eLj5ebn6Onq6+zt7u/w8vP09fb3+Pn6+/z9/vkVQXAAAAMaSURBVHhe5dXxV1N1GMfxz2ABbDgIAm5VDJOyVDIJLUMaVpBWUZUaGbmqoGpZRSiGiRWp6KoZ5AB0ZY50RImZQIlahKkMYXv/R90dBvET/rJfOr3Ouc8v99zPec59zvf56j+vYKlViSf7250X4Mr3O29Tgq08BdGB4DhcekEJ5YkQKFsgWZdtj9JpV+I8xPjLFqkrsEIqO8PHSpis36jWazcqjEsfJjkvRssVU37SdIOu4XCf5vEJPsnwJpnRNU9JmxhMk8l1gehIrq7hTFjzOD+Vf88629qKMJVNltInFeRexRQyJlNeqd1iGDlSzrIUIyXbyFfm3RYprcQRe7lqtWyGYbfc6dT0R2vmdOOkX3u55C1rP37ftiH+tDby4r/RBT0w8TyEkr+epB9XgPDmSYYWbrhCuFYaIyw3fDQAXTnSkh+ANofiHmWf9l+FY1I90FdQTetstO00o23novzVsJ7uB3/C5TkbjRwZ5JerwV4iRWq9HFbFMaK/d0TYqayRiQPuIxxS3Bu8JWU90/60tKi7vkhaznez0a/TbVOKj5CaOZh6fWG6/Lyv9B/ZLR1gw/S/fpbeVD3MCW1li6SvWDOn65tr99/uvWtBS0XDm4s1t+sOHpG0kpBKx/l77wOSnxLpcx6TXmXLTPQOKYOf9Q1dfr8/SJ2mFdCvl1Yl93DiHUZvXeLJbGSzYu5gVJ2slbSakOR8dxCq5adQ2oFLqsE9Ex3L4qQO0eOPeU5x56bypXp4onSEb5OkICX6lDat55TeoztNKQcJaakrz9KCb95oD69IKq+yKW4XPjknaS52V0TZqE2cTtXjcHSCRmUO88e+85hj3EP74i9p8pylw7lxgMDyyl6OV7ZejnjNMfatu87LxRbH0IS35gt2a4ZjmGpVBdKK3Wr6INk8jWWSGqbA55CKgjBRC6E9w78ydTg3ABS3AFV1QN0Y4Aa2pgEjWnQURj9L0ayK6R2ysEqxHUKzYnLvvyU+i9KM2JHJzE4vyZOyDcOwOsySajeLPc8sNvPJkFlyJd20wpqAzZeAfZ3oWybxd+P/3j+SG3uSBdf2VQAAAABJRU5ErkJggg==\") no-repeat;\n  background: url(\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgdmVyc2lvbj0iMS4xIgogICB3aWR0aD0iNjgxLjk2MjUyIgogICBoZWlnaHQ9IjE4Ny41IgogICBpZD0ic3ZnMiIKICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhOCI+PHJkZjpSREY+PGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPjxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PjxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz48L2NjOldvcms+PC9yZGY6UkRGPjwvbWV0YWRhdGE+PGRlZnMKICAgICBpZD0iZGVmczYiPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMTgiPjxwYXRoCiAgICAgICAgIGQ9Ik0gMCwxNTAwIDAsMCBsIDU0NTUuNzQsMCAwLDE1MDAgTCAwLDE1MDAgeiIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgaWQ9InBhdGgyMCIgLz48L2NsaXBQYXRoPjwvZGVmcz48ZwogICAgIHRyYW5zZm9ybT0ibWF0cml4KDEuMjUsMCwwLC0xLjI1LDAsMTg3LjUpIgogICAgIGlkPSJnMTAiPjxnCiAgICAgICB0cmFuc2Zvcm09InNjYWxlKDAuMSwwLjEpIgogICAgICAgaWQ9ImcxMiI+PGcKICAgICAgICAgaWQ9ImcxNCI+PGcKICAgICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGgxOCkiCiAgICAgICAgICAgaWQ9ImcxNiI+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMTU0NCw1OTkuNDM0IGMgMC45MiwtNDAuMzUyIDI1LjY4LC04MS42MDIgNzEuNTMsLTgxLjYwMiAyNy41MSwwIDQ3LjY4LDEyLjgzMiA2MS40NCwzNS43NTQgMTIuODMsMjIuOTMgMTIuODMsNTYuODUyIDEyLjgzLDgyLjUyNyBsIDAsMzI5LjE4NCAtNzEuNTIsMCAwLDEwNC41NDMgMjY2LjgzLDAgMCwtMTA0LjU0MyAtNzAuNiwwIDAsLTM0NC43NyBjIDAsLTU4LjY5MSAtMy42OCwtMTA0LjUzMSAtNDQuOTMsLTE1Mi4yMTggLTM2LjY4LC00Mi4xOCAtOTYuMjgsLTY2LjAyIC0xNTMuMTQsLTY2LjAyIC0xMTcuMzcsMCAtMjA3LjI0LDc3Ljk0MSAtMjAyLjY0LDE5Ny4xNDUgbCAxMzAuMiwwIgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMjIiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDIzMDEuNCw2NjIuNjk1IGMgMCw4MC43MDMgLTY2Ljk0LDE0NS44MTMgLTE0Ny42MywxNDUuODEzIC04My40NCwwIC0xNDcuNjMsLTY4Ljc4MSAtMTQ3LjYzLC0xNTEuMzAxIDAsLTc5Ljc4NSA2Ni45NCwtMTQ1LjgwMSAxNDUuOCwtMTQ1LjgwMSA4NC4zNSwwIDE0OS40Niw2Ny44NTIgMTQ5LjQ2LDE1MS4yODkgeiBtIC0xLjgzLC0xODEuNTQ3IGMgLTM1Ljc3LC01NC4wOTcgLTkzLjUzLC03OC44NTkgLTE1Ny43MiwtNzguODU5IC0xNDAuMywwIC0yNTEuMjQsMTE2LjQ0OSAtMjUxLjI0LDI1NC45MTggMCwxNDIuMTI5IDExMy43LDI2MC40MSAyNTYuNzQsMjYwLjQxIDYzLjI3LDAgMTE4LjI5LC0yOS4zMzYgMTUyLjIyLC04Mi41MjMgbCAwLDY5LjY4NyAxNzUuMTQsMCAwLC0xMDQuNTI3IC02MS40NCwwIDAsLTI4MC41OTggNjEuNDQsMCAwLC0xMDQuNTI3IC0xNzUuMTQsMCAwLDY2LjAxOSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDI0IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSAyNjIyLjMzLDU1Ny4yNTggYyAzLjY3LC00NC4wMTYgMzMuMDEsLTczLjM0OCA3OC44NiwtNzMuMzQ4IDMzLjkzLDAgNjYuOTMsMjMuODI0IDY2LjkzLDYwLjUwNCAwLDQ4LjYwNiAtNDUuODQsNTYuODU2IC04My40NCw2Ni45NDEgLTg1LjI4LDIyLjAwNCAtMTc4LjgxLDQ4LjYwNiAtMTc4LjgxLDE1NS44NzkgMCw5My41MzYgNzguODYsMTQ3LjYzMyAxNjUuOTgsMTQ3LjYzMyA0NCwwIDgzLjQzLC05LjE3NiAxMTAuOTQsLTQ0LjAwOCBsIDAsMzMuOTIyIDgyLjUzLDAgMCwtMTMyLjk2NSAtMTA4LjIxLDAgYyAtMS44MywzNC44NTYgLTI4LjQyLDU3Ljc3NCAtNjMuMjYsNTcuNzc0IC0zMC4yNiwwIC02Mi4zNSwtMTcuNDIyIC02Mi4zNSwtNTEuMzQ4IDAsLTQ1Ljg0NyA0NC45MywtNTUuOTMgODAuNjksLTY0LjE4IDg4LjAyLC0yMC4xNzUgMTgyLjQ3LC00Ny42OTUgMTgyLjQ3LC0xNTcuNzM0IDAsLTk5LjAyNyAtODMuNDQsLTE1NC4wMzkgLTE3NS4xMywtMTU0LjAzOSAtNDkuNTMsMCAtOTQuNDYsMTUuNTgyIC0xMjYuNTUsNTMuMTggbCAwLC00MC4zNCAtODUuMjcsMCAwLDE0Mi4xMjkgMTE0LjYyLDAiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGgyNiIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMjk4OC4xOCw4MDAuMjU0IC02My4yNiwwIDAsMTA0LjUyNyAxNjUuMDUsMCAwLC03My4zNTUgYyAzMS4xOCw1MS4zNDcgNzguODYsODUuMjc3IDE0MS4yMSw4NS4yNzcgNjcuODUsMCAxMjQuNzEsLTQxLjI1OCAxNTIuMjEsLTEwMi42OTkgMjYuNiw2Mi4zNTEgOTIuNjIsMTAyLjY5OSAxNjAuNDcsMTAyLjY5OSA1My4xOSwwIDEwNS40NiwtMjIgMTQxLjIxLC02Mi4zNTEgMzguNTIsLTQ0LjkzOCAzOC41MiwtOTMuNTMyIDM4LjUyLC0xNDkuNDU3IGwgMCwtMTg1LjIzOSA2My4yNywwIDAsLTEwNC41MjcgLTIzOC40MiwwIDAsMTA0LjUyNyA2My4yOCwwIDAsMTU3LjcxNSBjIDAsMzIuMTAyIDAsNjAuNTI3IC0xNC42Nyw4OC45NTcgLTE4LjM0LDI2LjU4MiAtNDguNjEsNDAuMzQ0IC03OS43Nyw0MC4zNDQgLTMwLjI2LDAgLTYzLjI4LC0xMi44NDQgLTgyLjUzLC0zNi42NzIgLTIyLjkzLC0yOS4zNTUgLTIyLjkzLC01Ni44NjMgLTIyLjkzLC05Mi42MjkgbCAwLC0xNTcuNzE1IDYzLjI3LDAgMCwtMTA0LjUyNyAtMjM4LjQxLDAgMCwxMDQuNTI3IDYzLjI4LDAgMCwxNTAuMzgzIGMgMCwyOS4zNDggMCw2Ni4wMjMgLTE0LjY3LDkxLjY5OSAtMTUuNTksMjkuMzM2IC00Ny42OSw0NC45MzQgLTgwLjcsNDQuOTM0IC0zMS4xOCwwIC01Ny43NywtMTEuMDA4IC03Ny45NCwtMzUuNzc0IC0yNC43NywtMzAuMjUzIC0yNi42LC02Mi4zNDMgLTI2LjYsLTk5Ljk0MSBsIDAsLTE1MS4zMDEgNjMuMjcsMCAwLC0xMDQuNTI3IC0yMzguNCwwIDAsMTA0LjUyNyA2My4yNiwwIDAsMjgwLjU5OCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDI4IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSAzOTk4LjY2LDk1MS41NDcgLTExMS44NywwIDAsMTE4LjI5MyAxMTEuODcsMCAwLC0xMTguMjkzIHogbSAwLC00MzEuODkxIDYzLjI3LDAgMCwtMTA0LjUyNyAtMjM5LjMzLDAgMCwxMDQuNTI3IDY0LjE5LDAgMCwyODAuNTk4IC02My4yNywwIDAsMTA0LjUyNyAxNzUuMTQsMCAwLC0zODUuMTI1IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzAiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDQxNTkuMTIsODAwLjI1NCAtNjMuMjcsMCAwLDEwNC41MjcgMTc1LjE0LDAgMCwtNjkuNjg3IGMgMjkuMzUsNTQuMTAxIDg0LjM2LDgwLjY5OSAxNDQuODcsODAuNjk5IDUzLjE5LDAgMTA1LjQ1LC0yMi4wMTYgMTQxLjIyLC02MC41MjcgNDAuMzQsLTQ0LjkzNCA0MS4yNiwtODguMDMyIDQxLjI2LC0xNDMuOTU3IGwgMCwtMTkxLjY1MyA2My4yNywwIDAsLTEwNC41MjcgLTIzOC40LDAgMCwxMDQuNTI3IDYzLjI2LDAgMCwxNTguNjM3IGMgMCwzMC4yNjIgMCw2MS40MzQgLTE5LjI2LDg4LjAzNSAtMjAuMTcsMjYuNTgyIC01My4xOCwzOS40MTQgLTg2LjE5LDM5LjQxNCAtMzMuOTMsMCAtNjguNzcsLTEzLjc1IC04OC45NCwtNDEuMjUgLTIxLjA5LC0yNy41IC0yMS4wOSwtNjkuNjg3IC0yMS4wOSwtMTAyLjcwNyBsIDAsLTE0Mi4xMjkgNjMuMjYsMCAwLC0xMDQuNTI3IC0yMzguNCwwIDAsMTA0LjUyNyA2My4yNywwIDAsMjgwLjU5OCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDMyIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA1MDgyLjQ4LDcwMy45NjUgYyAtMTkuMjQsNzAuNjA1IC04MS42LDExNS41NDcgLTE1NC4wNCwxMTUuNTQ3IC02Ni4wNCwwIC0xMjkuMywtNTEuMzQ4IC0xNDMuMDUsLTExNS41NDcgbCAyOTcuMDksMCB6IG0gODUuMjcsLTE0NC44ODMgYyAtMzguNTEsLTkzLjUyMyAtMTI5LjI3LC0xNTYuNzkzIC0yMzEuMDUsLTE1Ni43OTMgLTE0My4wNywwIC0yNTcuNjgsMTExLjg3MSAtMjU3LjY4LDI1NS44MzYgMCwxNDQuODgzIDEwOS4xMiwyNjEuMzI4IDI1NC45MSwyNjEuMzI4IDY3Ljg3LDAgMTM1LjcyLC0zMC4yNTggMTgzLjM5LC03OC44NjMgNDguNjIsLTUxLjM0NCA2OC43OSwtMTEzLjY5NSA2OC43OSwtMTgzLjM4MyBsIC0zLjY3LC0zOS40MzQgLTM5Ni4xMywwIGMgMTQuNjcsLTY3Ljg2MyA3Ny4wMywtMTE3LjM2MyAxNDYuNzIsLTExNy4zNjMgNDguNTksMCA5MC43NiwxOC4zMjggMTE4LjI4LDU4LjY3MiBsIDExNi40NCwwIgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzQiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDY5MC44OTUsODUwLjcwMyA5MC43NSwwIDIyLjU0MywzMS4wMzUgMCwyNDMuMTIyIC0xMzUuODI5LDAgMCwtMjQzLjE0MSAyMi41MzYsLTMxLjAxNiIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDM2IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA2MzIuMzk1LDc0Mi4yNTggMjguMDM5LDg2LjMwNCAtMjIuNTUxLDMxLjA0IC0yMzEuMjIzLDc1LjEyOCAtNDEuOTc2LC0xMjkuMTgzIDIzMS4yNTcsLTc1LjEzNyAzNi40NTQsMTEuODQ4IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzgiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDcxNy40NDksNjUzLjEwNSAtNzMuNDEsNTMuMzYgLTM2LjQ4OCwtMTEuODc1IC0xNDIuOTAzLC0xOTYuNjkyIDEwOS44ODMsLTc5LjgyOCAxNDIuOTE4LDE5Ni43MDMgMCwzOC4zMzIiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGg0MCIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gODI4LjUyLDcwNi40NjUgLTczLjQyNiwtNTMuMzQgMC4wMTEsLTM4LjM1OSBMIDg5OC4wMDQsNDE4LjA3IDEwMDcuOSw0OTcuODk4IDg2NC45NzMsNjk0LjYwOSA4MjguNTIsNzA2LjQ2NSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDQyIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA4MTIuMDg2LDgyOC41ODYgMjguMDU1LC04Ni4zMiAzNi40ODQsLTExLjgzNiAyMzEuMjI1LDc1LjExNyAtNDEuOTcsMTI5LjE4MyAtMjMxLjIzOSwtNzUuMTQgLTIyLjU1NSwtMzEuMDA0IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNDQiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDczNi4zMDEsMTMzNS44OCBjIC0zMjMuMDQ3LDAgLTU4NS44NzUsLTI2Mi43OCAtNTg1Ljg3NSwtNTg1Ljc4MiAwLC0zMjMuMTE4IDI2Mi44MjgsLTU4NS45NzcgNTg1Ljg3NSwtNTg1Ljk3NyAzMjMuMDE5LDAgNTg1LjgwOSwyNjIuODU5IDU4NS44MDksNTg1Ljk3NyAwLDMyMy4wMDIgLTI2Mi43OSw1ODUuNzgyIC01ODUuODA5LDU4NS43ODIgbCAwLDAgeiBtIDAsLTExOC42MSBjIDI1Ny45NzIsMCA0NjcuMTg5LC0yMDkuMTMgNDY3LjE4OSwtNDY3LjE3MiAwLC0yNTguMTI5IC0yMDkuMjE3LC00NjcuMzQ4IC00NjcuMTg5LC00NjcuMzQ4IC0yNTguMDc0LDAgLTQ2Ny4yNTQsMjA5LjIxOSAtNDY3LjI1NCw0NjcuMzQ4IDAsMjU4LjA0MiAyMDkuMTgsNDY3LjE3MiA0NjcuMjU0LDQ2Ny4xNzIiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGg0NiIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMTA5MS4xMyw2MTkuODgzIC0xNzUuNzcxLDU3LjEyMSAxMS42MjksMzUuODA4IDE3NS43NjIsLTU3LjEyMSAtMTEuNjIsLTM1LjgwOCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDQ4IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0iTSA4NjYuOTU3LDkwMi4wNzQgODM2LjUsOTI0LjE5OSA5NDUuMTIxLDEwNzMuNzMgOTc1LjU4NiwxMDUxLjYxIDg2Ni45NTcsOTAyLjA3NCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDUwIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0iTSA2MDcuNDY1LDkwMy40NDUgNDk4Ljg1NSwxMDUyLjk3IDUyOS4zMiwxMDc1LjEgNjM3LjkzLDkyNS41NjYgNjA3LjQ2NSw5MDMuNDQ1IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNTIiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDM4MC42ODgsNjIyLjEyOSAtMTEuNjI2LDM1LjgwMSAxNzUuNzU4LDU3LjA5IDExLjYyMSwtMzUuODAxIC0xNzUuNzUzLC01Ny4wOSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDU0IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA3MTYuMjg5LDM3Ni41OSAzNy42NDA2LDAgMCwxODQuODE2IC0zNy42NDA2LDAgMCwtMTg0LjgxNiB6IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNTYiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjwvZz48L2c+PC9nPjwvZz48L3N2Zz4=\") no-repeat, none;\n  -moz-background-size: 100%;\n  -o-background-size: 100%;\n  -webkit-background-size: 100%;\n  background-size: 100%;\n  display: block;\n  float: left;\n  width: 90px;\n  height: 25px;\n}\n.jasmine_html-reporter .jasmine-banner .jasmine-version {\n  margin-left: 14px;\n  position: relative;\n  top: 6px;\n}\n.jasmine_html-reporter #jasmine_content {\n  position: fixed;\n  right: 100%;\n}\n.jasmine_html-reporter .jasmine-version {\n  color: #aaa;\n}\n.jasmine_html-reporter .jasmine-banner {\n  margin-top: 14px;\n}\n.jasmine_html-reporter .jasmine-duration {\n  color: #fff;\n  float: right;\n  line-height: 28px;\n  padding-right: 9px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary {\n  overflow: hidden;\n  margin: 14px 0;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li {\n  display: inline-block;\n  height: 10px;\n  width: 14px;\n  font-size: 16px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-passed {\n  font-size: 14px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-passed:before {\n  color: #007069;\n  content: \"•\";\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-failed {\n  line-height: 9px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-failed:before {\n  color: #ca3a11;\n  content: \"×\";\n  font-weight: bold;\n  margin-left: -1px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-excluded {\n  font-size: 14px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-excluded:before {\n  color: #bababa;\n  content: \"•\";\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-excluded-no-display {\n  font-size: 14px;\n  display: none;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-pending {\n  line-height: 17px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-pending:before {\n  color: #ba9d37;\n  content: \"*\";\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-empty {\n  font-size: 14px;\n}\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-empty:before {\n  color: #ba9d37;\n  content: \"•\";\n}\n.jasmine_html-reporter .jasmine-run-options {\n  float: right;\n  margin-right: 5px;\n  border: 1px solid #8a4182;\n  color: #8a4182;\n  position: relative;\n  line-height: 20px;\n}\n.jasmine_html-reporter .jasmine-run-options .jasmine-trigger {\n  cursor: pointer;\n  padding: 8px 16px;\n}\n.jasmine_html-reporter .jasmine-run-options .jasmine-payload {\n  position: absolute;\n  display: none;\n  right: -1px;\n  border: 1px solid #8a4182;\n  background-color: #eee;\n  white-space: nowrap;\n  padding: 4px 8px;\n}\n.jasmine_html-reporter .jasmine-run-options .jasmine-payload.jasmine-open {\n  display: block;\n}\n.jasmine_html-reporter .jasmine-bar {\n  line-height: 28px;\n  font-size: 14px;\n  display: block;\n  color: #eee;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-failed, .jasmine_html-reporter .jasmine-bar.jasmine-errored {\n  background-color: #ca3a11;\n  border-bottom: 1px solid #eee;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-passed {\n  background-color: #007069;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-incomplete {\n  background-color: #bababa;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-skipped {\n  background-color: #bababa;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-warning {\n  margin-top: 14px;\n  margin-bottom: 14px;\n  background-color: #ba9d37;\n  color: #333;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-menu {\n  background-color: #fff;\n  color: #aaa;\n}\n.jasmine_html-reporter .jasmine-bar.jasmine-menu a {\n  color: #333;\n}\n.jasmine_html-reporter .jasmine-bar a {\n  color: white;\n}\n.jasmine_html-reporter.jasmine-spec-list .jasmine-bar.jasmine-menu.jasmine-failure-list,\n.jasmine_html-reporter.jasmine-spec-list .jasmine-results .jasmine-failures {\n  display: none;\n}\n.jasmine_html-reporter.jasmine-failure-list .jasmine-bar.jasmine-menu.jasmine-spec-list,\n.jasmine_html-reporter.jasmine-failure-list .jasmine-summary {\n  display: none;\n}\n.jasmine_html-reporter .jasmine-results {\n  margin-top: 14px;\n}\n.jasmine_html-reporter .jasmine-summary {\n  margin-top: 14px;\n}\n.jasmine_html-reporter .jasmine-summary ul {\n  list-style-type: none;\n  margin-left: 14px;\n  padding-top: 0;\n  padding-left: 0;\n}\n.jasmine_html-reporter .jasmine-summary ul.jasmine-suite {\n  margin-top: 7px;\n  margin-bottom: 7px;\n}\n.jasmine_html-reporter .jasmine-summary li.jasmine-passed a {\n  color: #007069;\n}\n.jasmine_html-reporter .jasmine-summary li.jasmine-failed a {\n  color: #ca3a11;\n}\n.jasmine_html-reporter .jasmine-summary li.jasmine-empty a {\n  color: #ba9d37;\n}\n.jasmine_html-reporter .jasmine-summary li.jasmine-pending a {\n  color: #ba9d37;\n}\n.jasmine_html-reporter .jasmine-summary li.jasmine-excluded a {\n  color: #bababa;\n}\n.jasmine_html-reporter .jasmine-specs li.jasmine-passed a:before {\n  content: \"• \";\n}\n.jasmine_html-reporter .jasmine-specs li.jasmine-failed a:before {\n  content: \"× \";\n}\n.jasmine_html-reporter .jasmine-specs li.jasmine-empty a:before {\n  content: \"* \";\n}\n.jasmine_html-reporter .jasmine-specs li.jasmine-pending a:before {\n  content: \"• \";\n}\n.jasmine_html-reporter .jasmine-specs li.jasmine-excluded a:before {\n  content: \"• \";\n}\n.jasmine_html-reporter .jasmine-description + .jasmine-suite {\n  margin-top: 0;\n}\n.jasmine_html-reporter .jasmine-suite {\n  margin-top: 14px;\n}\n.jasmine_html-reporter .jasmine-suite a {\n  color: #333;\n}\n.jasmine_html-reporter .jasmine-failures .jasmine-spec-detail {\n  margin-bottom: 28px;\n}\n.jasmine_html-reporter .jasmine-failures .jasmine-spec-detail .jasmine-description {\n  background-color: #ca3a11;\n  color: white;\n}\n.jasmine_html-reporter .jasmine-failures .jasmine-spec-detail .jasmine-description a {\n  color: white;\n}\n.jasmine_html-reporter .jasmine-result-message {\n  padding-top: 14px;\n  color: #333;\n  white-space: pre-wrap;\n}\n.jasmine_html-reporter .jasmine-result-message span.jasmine-result {\n  display: block;\n}\n.jasmine_html-reporter .jasmine-stack-trace {\n  margin: 5px 0 0 0;\n  max-height: 224px;\n  overflow: auto;\n  line-height: 18px;\n  color: #666;\n  border: 1px solid #ddd;\n  background: white;\n  white-space: pre;\n}\n.jasmine_html-reporter .jasmine-expander a {\n  display: block;\n  margin-left: 14px;\n  color: blue;\n  text-decoration: underline;\n}\n.jasmine_html-reporter .jasmine-expander-contents {\n  display: none;\n}\n.jasmine_html-reporter .jasmine-expanded {\n  padding-bottom: 10px;\n}\n.jasmine_html-reporter .jasmine-expanded .jasmine-expander-contents {\n  display: block;\n  margin-left: 14px;\n  padding: 5px;\n}\n.jasmine_html-reporter .jasmine-debug-log {\n  margin: 5px 0 0 0;\n  padding: 5px;\n  color: #666;\n  border: 1px solid #ddd;\n  background: white;\n}\n.jasmine_html-reporter .jasmine-debug-log table {\n  border-spacing: 0;\n}\n.jasmine_html-reporter .jasmine-debug-log table, .jasmine_html-reporter .jasmine-debug-log th, .jasmine_html-reporter .jasmine-debug-log td {\n  border: 1px solid #ddd;\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";

      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }

      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }

      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }

      content += cssWithMappingToString(item);

      if (needLayer) {
        content += "}";
      }

      if (item[2]) {
        content += "}";
      }

      if (item[4]) {
        content += "}";
      }

      return content;
    }).join("");
  }; // import a list of modules into the list


  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }

      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }

      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }

      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/jasmine-core/lib/jasmine-core/boot0.js":
/*!*************************************************************!*\
  !*** ./node_modules/jasmine-core/lib/jasmine-core/boot0.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/*
Copyright (c) 2008-2022 Pivotal Labs

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
/**
 This file starts the process of "booting" Jasmine. It initializes Jasmine,
 makes its globals available, and creates the env. This file should be loaded
 after `jasmine.js` and `jasmine_html.js`, but before `boot1.js` or any project
 source files or spec files are loaded.
 */
(function() {
  var jasmineRequire = window.jasmineRequire || __webpack_require__(/*! ./jasmine.js */ "./node_modules/jasmine-core/lib/jasmine-core/jasmine.js");

  /**
   * ## Require &amp; Instantiate
   *
   * Require Jasmine's core files. Specifically, this requires and attaches all of Jasmine's code to the `jasmine` reference.
   */
  var jasmine = jasmineRequire.core(jasmineRequire),
    global = jasmine.getGlobal();
  global.jasmine = jasmine;

  /**
   * Since this is being run in a browser and the results should populate to an HTML page, require the HTML-specific Jasmine code, injecting the same reference.
   */
  jasmineRequire.html(jasmine);

  /**
   * Create the Jasmine environment. This is used to run all specs in a project.
   */
  var env = jasmine.getEnv();

  /**
   * ## The Global Interface
   *
   * Build up the functions that will be exposed as the Jasmine public interface. A project can customize, rename or alias any of these functions as desired, provided the implementation remains unchanged.
   */
  var jasmineInterface = jasmineRequire.interface(jasmine, env);

  /**
   * Add all of the Jasmine global/public interface to the global scope, so a project can use the public interface directly. For example, calling `describe` in specs instead of `jasmine.getEnv().describe`.
   */
  for (var property in jasmineInterface) {
    global[property] = jasmineInterface[property];
  }
})();


/***/ }),

/***/ "./node_modules/jasmine-core/lib/jasmine-core/boot1.js":
/*!*************************************************************!*\
  !*** ./node_modules/jasmine-core/lib/jasmine-core/boot1.js ***!
  \*************************************************************/
/***/ (() => {

/*
Copyright (c) 2008-2022 Pivotal Labs

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
/**
 This file finishes 'booting' Jasmine, performing all of the necessary
 initialization before executing the loaded environment and all of a project's
 specs. This file should be loaded after `boot0.js` but before any project
 source files or spec files are loaded. Thus this file can also be used to
 customize Jasmine for a project.

 If a project is using Jasmine via the standalone distribution, this file can
 be customized directly. If you only wish to configure the Jasmine env, you
 can load another file that calls `jasmine.getEnv().configure({...})`
 after `boot0.js` is loaded and before this file is loaded.
 */

(function() {
  var env = jasmine.getEnv();

  /**
   * ## Runner Parameters
   *
   * More browser specific code - wrap the query string in an object and to allow for getting/setting parameters from the runner user interface.
   */

  var queryString = new jasmine.QueryString({
    getWindowLocation: function() {
      return window.location;
    }
  });

  var filterSpecs = !!queryString.getParam('spec');

  var config = {
    stopOnSpecFailure: queryString.getParam('stopOnSpecFailure'),
    stopSpecOnExpectationFailure: queryString.getParam(
      'stopSpecOnExpectationFailure'
    ),
    hideDisabled: queryString.getParam('hideDisabled')
  };

  var random = queryString.getParam('random');

  if (random !== undefined && random !== '') {
    config.random = random;
  }

  var seed = queryString.getParam('seed');
  if (seed) {
    config.seed = seed;
  }

  /**
   * ## Reporters
   * The `HtmlReporter` builds all of the HTML UI for the runner page. This reporter paints the dots, stars, and x's for specs, as well as all spec names and all failures (if any).
   */
  var htmlReporter = new jasmine.HtmlReporter({
    env: env,
    navigateWithNewParam: function(key, value) {
      return queryString.navigateWithNewParam(key, value);
    },
    addToExistingQueryString: function(key, value) {
      return queryString.fullStringWithNewParam(key, value);
    },
    getContainer: function() {
      return document.body;
    },
    createElement: function() {
      return document.createElement.apply(document, arguments);
    },
    createTextNode: function() {
      return document.createTextNode.apply(document, arguments);
    },
    timer: new jasmine.Timer(),
    filterSpecs: filterSpecs
  });

  /**
   * The `jsApiReporter` also receives spec results, and is used by any environment that needs to extract the results  from JavaScript.
   */
  env.addReporter(jsApiReporter);
  env.addReporter(htmlReporter);

  /**
   * Filter which specs will be run by matching the start of the full name against the `spec` query param.
   */
  var specFilter = new jasmine.HtmlSpecFilter({
    filterString: function() {
      return queryString.getParam('spec');
    }
  });

  config.specFilter = function(spec) {
    return specFilter.matches(spec.getFullName());
  };

  env.configure(config);

  /**
   * ## Execution
   *
   * Replace the browser window's `onload`, ensure it's called, and then run all of the loaded specs. This includes initializing the `HtmlReporter` instance and then executing the loaded Jasmine environment. All of this will happen after all of the specs are loaded.
   */
  var currentWindowOnload = window.onload;

  window.onload = function() {
    if (currentWindowOnload) {
      currentWindowOnload();
    }
    htmlReporter.initialize();
    env.execute();
  };
})();


/***/ }),

/***/ "./node_modules/jasmine-core/lib/jasmine-core/jasmine-html.js":
/*!********************************************************************!*\
  !*** ./node_modules/jasmine-core/lib/jasmine-core/jasmine-html.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/*
Copyright (c) 2008-2022 Pivotal Labs

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
var jasmineRequire = window.jasmineRequire || __webpack_require__(/*! ./jasmine.js */ "./node_modules/jasmine-core/lib/jasmine-core/jasmine.js");

jasmineRequire.html = function(j$) {
  j$.ResultsNode = jasmineRequire.ResultsNode();
  j$.HtmlReporter = jasmineRequire.HtmlReporter(j$);
  j$.QueryString = jasmineRequire.QueryString();
  j$.HtmlSpecFilter = jasmineRequire.HtmlSpecFilter();
};

jasmineRequire.HtmlReporter = function(j$) {
  function ResultsStateBuilder() {
    this.topResults = new j$.ResultsNode({}, '', null);
    this.currentParent = this.topResults;
    this.specsExecuted = 0;
    this.failureCount = 0;
    this.pendingSpecCount = 0;
  }

  ResultsStateBuilder.prototype.suiteStarted = function(result) {
    this.currentParent.addChild(result, 'suite');
    this.currentParent = this.currentParent.last();
  };

  ResultsStateBuilder.prototype.suiteDone = function(result) {
    this.currentParent.updateResult(result);
    if (this.currentParent !== this.topResults) {
      this.currentParent = this.currentParent.parent;
    }

    if (result.status === 'failed') {
      this.failureCount++;
    }
  };

  ResultsStateBuilder.prototype.specStarted = function(result) {};

  ResultsStateBuilder.prototype.specDone = function(result) {
    this.currentParent.addChild(result, 'spec');

    if (result.status !== 'excluded') {
      this.specsExecuted++;
    }

    if (result.status === 'failed') {
      this.failureCount++;
    }

    if (result.status == 'pending') {
      this.pendingSpecCount++;
    }
  };

  ResultsStateBuilder.prototype.jasmineDone = function(result) {
    if (result.failedExpectations) {
      this.failureCount += result.failedExpectations.length;
    }
  };

  function HtmlReporter(options) {
    var config = function() {
        return (options.env && options.env.configuration()) || {};
      },
      getContainer = options.getContainer,
      createElement = options.createElement,
      createTextNode = options.createTextNode,
      navigateWithNewParam = options.navigateWithNewParam || function() {},
      addToExistingQueryString =
        options.addToExistingQueryString || defaultQueryString,
      filterSpecs = options.filterSpecs,
      htmlReporterMain,
      symbols,
      deprecationWarnings = [];

    this.initialize = function() {
      clearPrior();
      htmlReporterMain = createDom(
        'div',
        { className: 'jasmine_html-reporter' },
        createDom(
          'div',
          { className: 'jasmine-banner' },
          createDom('a', {
            className: 'jasmine-title',
            href: 'http://jasmine.github.io/',
            target: '_blank'
          }),
          createDom('span', { className: 'jasmine-version' }, j$.version)
        ),
        createDom('ul', { className: 'jasmine-symbol-summary' }),
        createDom('div', { className: 'jasmine-alert' }),
        createDom(
          'div',
          { className: 'jasmine-results' },
          createDom('div', { className: 'jasmine-failures' })
        )
      );
      getContainer().appendChild(htmlReporterMain);
    };

    var totalSpecsDefined;
    this.jasmineStarted = function(options) {
      totalSpecsDefined = options.totalSpecsDefined || 0;
    };

    var summary = createDom('div', { className: 'jasmine-summary' });

    var stateBuilder = new ResultsStateBuilder();

    this.suiteStarted = function(result) {
      stateBuilder.suiteStarted(result);
    };

    this.suiteDone = function(result) {
      stateBuilder.suiteDone(result);

      if (result.status === 'failed') {
        failures.push(failureDom(result));
      }
      addDeprecationWarnings(result, 'suite');
    };

    this.specStarted = function(result) {
      stateBuilder.specStarted(result);
    };

    var failures = [];
    this.specDone = function(result) {
      stateBuilder.specDone(result);

      if (noExpectations(result)) {
        var noSpecMsg = "Spec '" + result.fullName + "' has no expectations.";
        if (result.status === 'failed') {
          console.error(noSpecMsg);
        } else {
          console.warn(noSpecMsg);
        }
      }

      if (!symbols) {
        symbols = find('.jasmine-symbol-summary');
      }

      symbols.appendChild(
        createDom('li', {
          className: this.displaySpecInCorrectFormat(result),
          id: 'spec_' + result.id,
          title: result.fullName
        })
      );

      if (result.status === 'failed') {
        failures.push(failureDom(result));
      }

      addDeprecationWarnings(result, 'spec');
    };

    this.displaySpecInCorrectFormat = function(result) {
      return noExpectations(result) && result.status === 'passed'
        ? 'jasmine-empty'
        : this.resultStatus(result.status);
    };

    this.resultStatus = function(status) {
      if (status === 'excluded') {
        return config().hideDisabled
          ? 'jasmine-excluded-no-display'
          : 'jasmine-excluded';
      }
      return 'jasmine-' + status;
    };

    this.jasmineDone = function(doneResult) {
      stateBuilder.jasmineDone(doneResult);
      var banner = find('.jasmine-banner');
      var alert = find('.jasmine-alert');
      var order = doneResult && doneResult.order;
      var i;
      alert.appendChild(
        createDom(
          'span',
          { className: 'jasmine-duration' },
          'finished in ' + doneResult.totalTime / 1000 + 's'
        )
      );

      banner.appendChild(optionsMenu(config()));

      if (stateBuilder.specsExecuted < totalSpecsDefined) {
        var skippedMessage =
          'Ran ' +
          stateBuilder.specsExecuted +
          ' of ' +
          totalSpecsDefined +
          ' specs - run all';
        // include window.location.pathname to fix issue with karma-jasmine-html-reporter in angular: see https://github.com/jasmine/jasmine/issues/1906
        var skippedLink =
          (window.location.pathname || '') +
          addToExistingQueryString('spec', '');
        alert.appendChild(
          createDom(
            'span',
            { className: 'jasmine-bar jasmine-skipped' },
            createDom(
              'a',
              { href: skippedLink, title: 'Run all specs' },
              skippedMessage
            )
          )
        );
      }
      var statusBarMessage = '';
      var statusBarClassName = 'jasmine-overall-result jasmine-bar ';
      var globalFailures = (doneResult && doneResult.failedExpectations) || [];
      var failed = stateBuilder.failureCount + globalFailures.length > 0;

      if (totalSpecsDefined > 0 || failed) {
        statusBarMessage +=
          pluralize('spec', stateBuilder.specsExecuted) +
          ', ' +
          pluralize('failure', stateBuilder.failureCount);
        if (stateBuilder.pendingSpecCount) {
          statusBarMessage +=
            ', ' + pluralize('pending spec', stateBuilder.pendingSpecCount);
        }
      }

      if (doneResult.overallStatus === 'passed') {
        statusBarClassName += ' jasmine-passed ';
      } else if (doneResult.overallStatus === 'incomplete') {
        statusBarClassName += ' jasmine-incomplete ';
        statusBarMessage =
          'Incomplete: ' +
          doneResult.incompleteReason +
          ', ' +
          statusBarMessage;
      } else {
        statusBarClassName += ' jasmine-failed ';
      }

      var seedBar;
      if (order && order.random) {
        seedBar = createDom(
          'span',
          { className: 'jasmine-seed-bar' },
          ', randomized with seed ',
          createDom(
            'a',
            {
              title: 'randomized with seed ' + order.seed,
              href: seedHref(order.seed)
            },
            order.seed
          )
        );
      }

      alert.appendChild(
        createDom(
          'span',
          { className: statusBarClassName },
          statusBarMessage,
          seedBar
        )
      );

      var errorBarClassName = 'jasmine-bar jasmine-errored';
      var afterAllMessagePrefix = 'AfterAll ';

      for (i = 0; i < globalFailures.length; i++) {
        alert.appendChild(
          createDom(
            'span',
            { className: errorBarClassName },
            globalFailureMessage(globalFailures[i])
          )
        );
      }

      function globalFailureMessage(failure) {
        if (failure.globalErrorType === 'load') {
          var prefix = 'Error during loading: ' + failure.message;

          if (failure.filename) {
            return (
              prefix + ' in ' + failure.filename + ' line ' + failure.lineno
            );
          } else {
            return prefix;
          }
        } else if (failure.globalErrorType === 'afterAll') {
          return afterAllMessagePrefix + failure.message;
        } else {
          return failure.message;
        }
      }

      addDeprecationWarnings(doneResult);

      for (i = 0; i < deprecationWarnings.length; i++) {
        var children = [],
          context;

        switch (deprecationWarnings[i].runnableType) {
          case 'spec':
            context = '(in spec: ' + deprecationWarnings[i].runnableName + ')';
            break;
          case 'suite':
            context = '(in suite: ' + deprecationWarnings[i].runnableName + ')';
            break;
          default:
            context = '';
        }

        deprecationWarnings[i].message.split('\n').forEach(function(line) {
          children.push(line);
          children.push(createDom('br'));
        });

        children[0] = 'DEPRECATION: ' + children[0];
        children.push(context);

        if (deprecationWarnings[i].stack) {
          children.push(createExpander(deprecationWarnings[i].stack));
        }

        alert.appendChild(
          createDom(
            'span',
            { className: 'jasmine-bar jasmine-warning' },
            children
          )
        );
      }

      var results = find('.jasmine-results');
      results.appendChild(summary);

      summaryList(stateBuilder.topResults, summary);

      if (failures.length) {
        alert.appendChild(
          createDom(
            'span',
            { className: 'jasmine-menu jasmine-bar jasmine-spec-list' },
            createDom('span', {}, 'Spec List | '),
            createDom(
              'a',
              { className: 'jasmine-failures-menu', href: '#' },
              'Failures'
            )
          )
        );
        alert.appendChild(
          createDom(
            'span',
            { className: 'jasmine-menu jasmine-bar jasmine-failure-list' },
            createDom(
              'a',
              { className: 'jasmine-spec-list-menu', href: '#' },
              'Spec List'
            ),
            createDom('span', {}, ' | Failures ')
          )
        );

        find('.jasmine-failures-menu').onclick = function() {
          setMenuModeTo('jasmine-failure-list');
          return false;
        };
        find('.jasmine-spec-list-menu').onclick = function() {
          setMenuModeTo('jasmine-spec-list');
          return false;
        };

        setMenuModeTo('jasmine-failure-list');

        var failureNode = find('.jasmine-failures');
        for (i = 0; i < failures.length; i++) {
          failureNode.appendChild(failures[i]);
        }
      }
    };

    return this;

    function failureDom(result) {
      var failure = createDom(
        'div',
        { className: 'jasmine-spec-detail jasmine-failed' },
        failureDescription(result, stateBuilder.currentParent),
        createDom('div', { className: 'jasmine-messages' })
      );
      var messages = failure.childNodes[1];

      for (var i = 0; i < result.failedExpectations.length; i++) {
        var expectation = result.failedExpectations[i];
        messages.appendChild(
          createDom(
            'div',
            { className: 'jasmine-result-message' },
            expectation.message
          )
        );
        messages.appendChild(
          createDom(
            'div',
            { className: 'jasmine-stack-trace' },
            expectation.stack
          )
        );
      }

      if (result.failedExpectations.length === 0) {
        messages.appendChild(
          createDom(
            'div',
            { className: 'jasmine-result-message' },
            'Spec has no expectations'
          )
        );
      }

      if (result.debugLogs) {
        messages.appendChild(debugLogTable(result.debugLogs));
      }

      return failure;
    }

    function debugLogTable(debugLogs) {
      var tbody = createDom('tbody');

      debugLogs.forEach(function(entry) {
        tbody.appendChild(
          createDom(
            'tr',
            {},
            createDom('td', {}, entry.timestamp.toString()),
            createDom('td', {}, entry.message)
          )
        );
      });

      return createDom(
        'div',
        { className: 'jasmine-debug-log' },
        createDom(
          'div',
          { className: 'jasmine-debug-log-header' },
          'Debug logs'
        ),
        createDom(
          'table',
          {},
          createDom(
            'thead',
            {},
            createDom(
              'tr',
              {},
              createDom('th', {}, 'Time (ms)'),
              createDom('th', {}, 'Message')
            )
          ),
          tbody
        )
      );
    }

    function summaryList(resultsTree, domParent) {
      var specListNode;
      for (var i = 0; i < resultsTree.children.length; i++) {
        var resultNode = resultsTree.children[i];
        if (filterSpecs && !hasActiveSpec(resultNode)) {
          continue;
        }
        if (resultNode.type === 'suite') {
          var suiteListNode = createDom(
            'ul',
            { className: 'jasmine-suite', id: 'suite-' + resultNode.result.id },
            createDom(
              'li',
              {
                className:
                  'jasmine-suite-detail jasmine-' + resultNode.result.status
              },
              createDom(
                'a',
                { href: specHref(resultNode.result) },
                resultNode.result.description
              )
            )
          );

          summaryList(resultNode, suiteListNode);
          domParent.appendChild(suiteListNode);
        }
        if (resultNode.type === 'spec') {
          if (domParent.getAttribute('class') !== 'jasmine-specs') {
            specListNode = createDom('ul', { className: 'jasmine-specs' });
            domParent.appendChild(specListNode);
          }
          var specDescription = resultNode.result.description;
          if (noExpectations(resultNode.result)) {
            specDescription = 'SPEC HAS NO EXPECTATIONS ' + specDescription;
          }
          if (
            resultNode.result.status === 'pending' &&
            resultNode.result.pendingReason !== ''
          ) {
            specDescription =
              specDescription +
              ' PENDING WITH MESSAGE: ' +
              resultNode.result.pendingReason;
          }
          specListNode.appendChild(
            createDom(
              'li',
              {
                className: 'jasmine-' + resultNode.result.status,
                id: 'spec-' + resultNode.result.id
              },
              createDom(
                'a',
                { href: specHref(resultNode.result) },
                specDescription
              )
            )
          );
        }
      }
    }

    function optionsMenu(config) {
      var optionsMenuDom = createDom(
        'div',
        { className: 'jasmine-run-options' },
        createDom('span', { className: 'jasmine-trigger' }, 'Options'),
        createDom(
          'div',
          { className: 'jasmine-payload' },
          createDom(
            'div',
            { className: 'jasmine-stop-on-failure' },
            createDom('input', {
              className: 'jasmine-fail-fast',
              id: 'jasmine-fail-fast',
              type: 'checkbox'
            }),
            createDom(
              'label',
              { className: 'jasmine-label', for: 'jasmine-fail-fast' },
              'stop execution on spec failure'
            )
          ),
          createDom(
            'div',
            { className: 'jasmine-throw-failures' },
            createDom('input', {
              className: 'jasmine-throw',
              id: 'jasmine-throw-failures',
              type: 'checkbox'
            }),
            createDom(
              'label',
              { className: 'jasmine-label', for: 'jasmine-throw-failures' },
              'stop spec on expectation failure'
            )
          ),
          createDom(
            'div',
            { className: 'jasmine-random-order' },
            createDom('input', {
              className: 'jasmine-random',
              id: 'jasmine-random-order',
              type: 'checkbox'
            }),
            createDom(
              'label',
              { className: 'jasmine-label', for: 'jasmine-random-order' },
              'run tests in random order'
            )
          ),
          createDom(
            'div',
            { className: 'jasmine-hide-disabled' },
            createDom('input', {
              className: 'jasmine-disabled',
              id: 'jasmine-hide-disabled',
              type: 'checkbox'
            }),
            createDom(
              'label',
              { className: 'jasmine-label', for: 'jasmine-hide-disabled' },
              'hide disabled tests'
            )
          )
        )
      );

      var failFastCheckbox = optionsMenuDom.querySelector('#jasmine-fail-fast');
      failFastCheckbox.checked = config.stopOnSpecFailure;
      failFastCheckbox.onclick = function() {
        navigateWithNewParam('stopOnSpecFailure', !config.stopOnSpecFailure);
      };

      var throwCheckbox = optionsMenuDom.querySelector(
        '#jasmine-throw-failures'
      );
      throwCheckbox.checked = config.stopSpecOnExpectationFailure;
      throwCheckbox.onclick = function() {
        navigateWithNewParam(
          'stopSpecOnExpectationFailure',
          !config.stopSpecOnExpectationFailure
        );
      };

      var randomCheckbox = optionsMenuDom.querySelector(
        '#jasmine-random-order'
      );
      randomCheckbox.checked = config.random;
      randomCheckbox.onclick = function() {
        navigateWithNewParam('random', !config.random);
      };

      var hideDisabled = optionsMenuDom.querySelector('#jasmine-hide-disabled');
      hideDisabled.checked = config.hideDisabled;
      hideDisabled.onclick = function() {
        navigateWithNewParam('hideDisabled', !config.hideDisabled);
      };

      var optionsTrigger = optionsMenuDom.querySelector('.jasmine-trigger'),
        optionsPayload = optionsMenuDom.querySelector('.jasmine-payload'),
        isOpen = /\bjasmine-open\b/;

      optionsTrigger.onclick = function() {
        if (isOpen.test(optionsPayload.className)) {
          optionsPayload.className = optionsPayload.className.replace(
            isOpen,
            ''
          );
        } else {
          optionsPayload.className += ' jasmine-open';
        }
      };

      return optionsMenuDom;
    }

    function failureDescription(result, suite) {
      var wrapper = createDom(
        'div',
        { className: 'jasmine-description' },
        createDom(
          'a',
          { title: result.description, href: specHref(result) },
          result.description
        )
      );
      var suiteLink;

      while (suite && suite.parent) {
        wrapper.insertBefore(createTextNode(' > '), wrapper.firstChild);
        suiteLink = createDom(
          'a',
          { href: suiteHref(suite) },
          suite.result.description
        );
        wrapper.insertBefore(suiteLink, wrapper.firstChild);

        suite = suite.parent;
      }

      return wrapper;
    }

    function suiteHref(suite) {
      var els = [];

      while (suite && suite.parent) {
        els.unshift(suite.result.description);
        suite = suite.parent;
      }

      // include window.location.pathname to fix issue with karma-jasmine-html-reporter in angular: see https://github.com/jasmine/jasmine/issues/1906
      return (
        (window.location.pathname || '') +
        addToExistingQueryString('spec', els.join(' '))
      );
    }

    function addDeprecationWarnings(result, runnableType) {
      if (result && result.deprecationWarnings) {
        for (var i = 0; i < result.deprecationWarnings.length; i++) {
          var warning = result.deprecationWarnings[i].message;
          deprecationWarnings.push({
            message: warning,
            stack: result.deprecationWarnings[i].stack,
            runnableName: result.fullName,
            runnableType: runnableType
          });
        }
      }
    }

    function createExpander(stackTrace) {
      var expandLink = createDom('a', { href: '#' }, 'Show stack trace');
      var root = createDom(
        'div',
        { className: 'jasmine-expander' },
        expandLink,
        createDom(
          'div',
          { className: 'jasmine-expander-contents jasmine-stack-trace' },
          stackTrace
        )
      );

      expandLink.addEventListener('click', function(e) {
        e.preventDefault();

        if (root.classList.contains('jasmine-expanded')) {
          root.classList.remove('jasmine-expanded');
          expandLink.textContent = 'Show stack trace';
        } else {
          root.classList.add('jasmine-expanded');
          expandLink.textContent = 'Hide stack trace';
        }
      });

      return root;
    }

    function find(selector) {
      return getContainer().querySelector('.jasmine_html-reporter ' + selector);
    }

    function clearPrior() {
      // return the reporter
      var oldReporter = find('');

      if (oldReporter) {
        getContainer().removeChild(oldReporter);
      }
    }

    function createDom(type, attrs, childrenArrayOrVarArgs) {
      var el = createElement(type),
        children,
        i;

      if (j$.isArray_(childrenArrayOrVarArgs)) {
        children = childrenArrayOrVarArgs;
      } else {
        children = [];

        for (i = 2; i < arguments.length; i++) {
          children.push(arguments[i]);
        }
      }

      for (i = 0; i < children.length; i++) {
        var child = children[i];

        if (typeof child === 'string') {
          el.appendChild(createTextNode(child));
        } else {
          if (child) {
            el.appendChild(child);
          }
        }
      }

      for (var attr in attrs) {
        if (attr == 'className') {
          el[attr] = attrs[attr];
        } else {
          el.setAttribute(attr, attrs[attr]);
        }
      }

      return el;
    }

    function pluralize(singular, count) {
      var word = count == 1 ? singular : singular + 's';

      return '' + count + ' ' + word;
    }

    function specHref(result) {
      // include window.location.pathname to fix issue with karma-jasmine-html-reporter in angular: see https://github.com/jasmine/jasmine/issues/1906
      return (
        (window.location.pathname || '') +
        addToExistingQueryString('spec', result.fullName)
      );
    }

    function seedHref(seed) {
      // include window.location.pathname to fix issue with karma-jasmine-html-reporter in angular: see https://github.com/jasmine/jasmine/issues/1906
      return (
        (window.location.pathname || '') +
        addToExistingQueryString('seed', seed)
      );
    }

    function defaultQueryString(key, value) {
      return '?' + key + '=' + value;
    }

    function setMenuModeTo(mode) {
      htmlReporterMain.setAttribute('class', 'jasmine_html-reporter ' + mode);
    }

    function noExpectations(result) {
      var allExpectations =
        result.failedExpectations.length + result.passedExpectations.length;

      return (
        allExpectations === 0 &&
        (result.status === 'passed' || result.status === 'failed')
      );
    }

    function hasActiveSpec(resultNode) {
      if (resultNode.type == 'spec' && resultNode.result.status != 'excluded') {
        return true;
      }

      if (resultNode.type == 'suite') {
        for (var i = 0, j = resultNode.children.length; i < j; i++) {
          if (hasActiveSpec(resultNode.children[i])) {
            return true;
          }
        }
      }
    }
  }

  return HtmlReporter;
};

jasmineRequire.HtmlSpecFilter = function() {
  function HtmlSpecFilter(options) {
    var filterString =
      options &&
      options.filterString() &&
      options.filterString().replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
    var filterPattern = new RegExp(filterString);

    this.matches = function(specName) {
      return filterPattern.test(specName);
    };
  }

  return HtmlSpecFilter;
};

jasmineRequire.ResultsNode = function() {
  function ResultsNode(result, type, parent) {
    this.result = result;
    this.type = type;
    this.parent = parent;

    this.children = [];

    this.addChild = function(result, type) {
      this.children.push(new ResultsNode(result, type, this));
    };

    this.last = function() {
      return this.children[this.children.length - 1];
    };

    this.updateResult = function(result) {
      this.result = result;
    };
  }

  return ResultsNode;
};

jasmineRequire.QueryString = function() {
  function QueryString(options) {
    this.navigateWithNewParam = function(key, value) {
      options.getWindowLocation().search = this.fullStringWithNewParam(
        key,
        value
      );
    };

    this.fullStringWithNewParam = function(key, value) {
      var paramMap = queryStringToParamMap();
      paramMap[key] = value;
      return toQueryString(paramMap);
    };

    this.getParam = function(key) {
      return queryStringToParamMap()[key];
    };

    return this;

    function toQueryString(paramMap) {
      var qStrPairs = [];
      for (var prop in paramMap) {
        qStrPairs.push(
          encodeURIComponent(prop) + '=' + encodeURIComponent(paramMap[prop])
        );
      }
      return '?' + qStrPairs.join('&');
    }

    function queryStringToParamMap() {
      var paramStr = options.getWindowLocation().search.substring(1),
        params = [],
        paramMap = {};

      if (paramStr.length > 0) {
        params = paramStr.split('&');
        for (var i = 0; i < params.length; i++) {
          var p = params[i].split('=');
          var value = decodeURIComponent(p[1]);
          if (value === 'true' || value === 'false') {
            value = JSON.parse(value);
          }
          paramMap[decodeURIComponent(p[0])] = value;
        }
      }

      return paramMap;
    }
  }

  return QueryString;
};


/***/ }),

/***/ "./node_modules/jasmine-core/lib/jasmine-core/jasmine.js":
/*!***************************************************************!*\
  !*** ./node_modules/jasmine-core/lib/jasmine-core/jasmine.js ***!
  \***************************************************************/
/***/ (function(module, exports, __webpack_require__) {

/*
Copyright (c) 2008-2022 Pivotal Labs

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
// eslint-disable-next-line no-unused-vars
var getJasmineRequireObj = (function(jasmineGlobal) {
  var jasmineRequire;

  if (
     true &&
    module.exports &&
    typeof exports !== 'undefined'
  ) {
    if (typeof __webpack_require__.g !== 'undefined') {
      jasmineGlobal = __webpack_require__.g;
    } else {
      jasmineGlobal = {};
    }
    jasmineRequire = exports;
  } else {
    if (
      typeof window !== 'undefined' &&
      typeof window.toString === 'function' &&
      window.toString() === '[object GjsGlobal]'
    ) {
      jasmineGlobal = window;
    }
    jasmineRequire = jasmineGlobal.jasmineRequire = {};
  }

  function getJasmineRequire() {
    return jasmineRequire;
  }

  getJasmineRequire().core = function(jRequire) {
    var j$ = {};

    jRequire.base(j$, jasmineGlobal);
    j$.util = jRequire.util(j$);
    j$.errors = jRequire.errors();
    j$.formatErrorMsg = jRequire.formatErrorMsg();
    j$.Any = jRequire.Any(j$);
    j$.Anything = jRequire.Anything(j$);
    j$.CallTracker = jRequire.CallTracker(j$);
    j$.MockDate = jRequire.MockDate(j$);
    j$.getClearStack = jRequire.clearStack(j$);
    j$.Clock = jRequire.Clock();
    j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler(j$);
    j$.Deprecator = jRequire.Deprecator(j$);
    j$.Env = jRequire.Env(j$);
    j$.StackTrace = jRequire.StackTrace(j$);
    j$.ExceptionFormatter = jRequire.ExceptionFormatter(j$);
    j$.ExpectationFilterChain = jRequire.ExpectationFilterChain();
    j$.Expector = jRequire.Expector(j$);
    j$.Expectation = jRequire.Expectation(j$);
    j$.buildExpectationResult = jRequire.buildExpectationResult(j$);
    j$.JsApiReporter = jRequire.JsApiReporter(j$);
    j$.makePrettyPrinter = jRequire.makePrettyPrinter(j$);
    j$.basicPrettyPrinter_ = j$.makePrettyPrinter();
    j$.MatchersUtil = jRequire.MatchersUtil(j$);
    j$.ObjectContaining = jRequire.ObjectContaining(j$);
    j$.ArrayContaining = jRequire.ArrayContaining(j$);
    j$.ArrayWithExactContents = jRequire.ArrayWithExactContents(j$);
    j$.MapContaining = jRequire.MapContaining(j$);
    j$.SetContaining = jRequire.SetContaining(j$);
    j$.QueueRunner = jRequire.QueueRunner(j$);
    j$.NeverSkipPolicy = jRequire.NeverSkipPolicy(j$);
    j$.SkipAfterBeforeAllErrorPolicy = jRequire.SkipAfterBeforeAllErrorPolicy(
      j$
    );
    j$.CompleteOnFirstErrorSkipPolicy = jRequire.CompleteOnFirstErrorSkipPolicy(
      j$
    );
    j$.ReportDispatcher = jRequire.ReportDispatcher(j$);
    j$.Spec = jRequire.Spec(j$);
    j$.Spy = jRequire.Spy(j$);
    j$.SpyFactory = jRequire.SpyFactory(j$);
    j$.SpyRegistry = jRequire.SpyRegistry(j$);
    j$.SpyStrategy = jRequire.SpyStrategy(j$);
    j$.StringMatching = jRequire.StringMatching(j$);
    j$.StringContaining = jRequire.StringContaining(j$);
    j$.UserContext = jRequire.UserContext(j$);
    j$.Suite = jRequire.Suite(j$);
    j$.Timer = jRequire.Timer();
    j$.TreeProcessor = jRequire.TreeProcessor();
    j$.version = jRequire.version();
    j$.Order = jRequire.Order();
    j$.DiffBuilder = jRequire.DiffBuilder(j$);
    j$.NullDiffBuilder = jRequire.NullDiffBuilder(j$);
    j$.ObjectPath = jRequire.ObjectPath(j$);
    j$.MismatchTree = jRequire.MismatchTree(j$);
    j$.GlobalErrors = jRequire.GlobalErrors(j$);

    j$.Truthy = jRequire.Truthy(j$);
    j$.Falsy = jRequire.Falsy(j$);
    j$.Empty = jRequire.Empty(j$);
    j$.NotEmpty = jRequire.NotEmpty(j$);

    j$.matchers = jRequire.requireMatchers(jRequire, j$);
    j$.asyncMatchers = jRequire.requireAsyncMatchers(jRequire, j$);

    return j$;
  };

  return getJasmineRequire;
})(this);

getJasmineRequireObj().requireMatchers = function(jRequire, j$) {
  var availableMatchers = [
      'nothing',
      'toBe',
      'toBeCloseTo',
      'toBeDefined',
      'toBeInstanceOf',
      'toBeFalse',
      'toBeFalsy',
      'toBeGreaterThan',
      'toBeGreaterThanOrEqual',
      'toBeLessThan',
      'toBeLessThanOrEqual',
      'toBeNaN',
      'toBeNegativeInfinity',
      'toBeNull',
      'toBePositiveInfinity',
      'toBeTrue',
      'toBeTruthy',
      'toBeUndefined',
      'toContain',
      'toEqual',
      'toHaveSize',
      'toHaveBeenCalled',
      'toHaveBeenCalledBefore',
      'toHaveBeenCalledOnceWith',
      'toHaveBeenCalledTimes',
      'toHaveBeenCalledWith',
      'toHaveClass',
      'toMatch',
      'toThrow',
      'toThrowError',
      'toThrowMatching'
    ],
    matchers = {};

  for (var i = 0; i < availableMatchers.length; i++) {
    var name = availableMatchers[i];
    matchers[name] = jRequire[name](j$);
  }

  return matchers;
};

getJasmineRequireObj().base = function(j$, jasmineGlobal) {
  j$.unimplementedMethod_ = function() {
    throw new Error('unimplemented method');
  };

  /**
   * Maximum object depth the pretty printer will print to.
   * Set this to a lower value to speed up pretty printing if you have large objects.
   * @name jasmine.MAX_PRETTY_PRINT_DEPTH
   * @default 8
   * @since 1.3.0
   */
  j$.MAX_PRETTY_PRINT_DEPTH = 8;
  /**
   * Maximum number of array elements to display when pretty printing objects.
   * This will also limit the number of keys and values displayed for an object.
   * Elements past this number will be ellipised.
   * @name jasmine.MAX_PRETTY_PRINT_ARRAY_LENGTH
   * @default 50
   * @since 2.7.0
   */
  j$.MAX_PRETTY_PRINT_ARRAY_LENGTH = 50;
  /**
   * Maximum number of characters to display when pretty printing objects.
   * Characters past this number will be ellipised.
   * @name jasmine.MAX_PRETTY_PRINT_CHARS
   * @default 100
   * @since 2.9.0
   */
  j$.MAX_PRETTY_PRINT_CHARS = 1000;
  /**
   * Default number of milliseconds Jasmine will wait for an asynchronous spec,
   * before, or after function to complete. This can be overridden on a case by
   * case basis by passing a time limit as the third argument to {@link it},
   * {@link beforeEach}, {@link afterEach}, {@link beforeAll}, or
   * {@link afterAll}. The value must be no greater than the largest number of
   * milliseconds supported by setTimeout, which is usually 2147483647.
   *
   * While debugging tests, you may want to set this to a large number (or pass
   * a large number to one of the functions mentioned above) so that Jasmine
   * does not move on to after functions or the next spec while you're debugging.
   * @name jasmine.DEFAULT_TIMEOUT_INTERVAL
   * @default 5000
   * @since 1.3.0
   */
  var DEFAULT_TIMEOUT_INTERVAL = 5000;
  Object.defineProperty(j$, 'DEFAULT_TIMEOUT_INTERVAL', {
    get: function() {
      return DEFAULT_TIMEOUT_INTERVAL;
    },
    set: function(newValue) {
      j$.util.validateTimeout(newValue, 'jasmine.DEFAULT_TIMEOUT_INTERVAL');
      DEFAULT_TIMEOUT_INTERVAL = newValue;
    }
  });

  j$.getGlobal = function() {
    return jasmineGlobal;
  };

  /**
   * Get the currently booted Jasmine Environment.
   *
   * @name jasmine.getEnv
   * @since 1.3.0
   * @function
   * @return {Env}
   */
  j$.getEnv = function(options) {
    var env = (j$.currentEnv_ = j$.currentEnv_ || new j$.Env(options));
    //jasmine. singletons in here (setTimeout blah blah).
    return env;
  };

  j$.isArray_ = function(value) {
    return j$.isA_('Array', value);
  };

  j$.isObject_ = function(value) {
    return (
      !j$.util.isUndefined(value) && value !== null && j$.isA_('Object', value)
    );
  };

  j$.isString_ = function(value) {
    return j$.isA_('String', value);
  };

  j$.isNumber_ = function(value) {
    return j$.isA_('Number', value);
  };

  j$.isFunction_ = function(value) {
    return j$.isA_('Function', value);
  };

  j$.isAsyncFunction_ = function(value) {
    return j$.isA_('AsyncFunction', value);
  };

  j$.isGeneratorFunction_ = function(value) {
    return j$.isA_('GeneratorFunction', value);
  };

  j$.isTypedArray_ = function(value) {
    return (
      j$.isA_('Float32Array', value) ||
      j$.isA_('Float64Array', value) ||
      j$.isA_('Int16Array', value) ||
      j$.isA_('Int32Array', value) ||
      j$.isA_('Int8Array', value) ||
      j$.isA_('Uint16Array', value) ||
      j$.isA_('Uint32Array', value) ||
      j$.isA_('Uint8Array', value) ||
      j$.isA_('Uint8ClampedArray', value)
    );
  };

  j$.isA_ = function(typeName, value) {
    return j$.getType_(value) === '[object ' + typeName + ']';
  };

  j$.isError_ = function(value) {
    if (!value) {
      return false;
    }

    if (value instanceof Error) {
      return true;
    }

    return typeof value.stack === 'string' && typeof value.message === 'string';
  };

  j$.isAsymmetricEqualityTester_ = function(obj) {
    return obj ? j$.isA_('Function', obj.asymmetricMatch) : false;
  };

  j$.getType_ = function(value) {
    return Object.prototype.toString.apply(value);
  };

  j$.isDomNode = function(obj) {
    // Node is a function, because constructors
    return typeof jasmineGlobal.Node !== 'undefined'
      ? obj instanceof jasmineGlobal.Node
      : obj !== null &&
          typeof obj === 'object' &&
          typeof obj.nodeType === 'number' &&
          typeof obj.nodeName === 'string';
    // return obj.nodeType > 0;
  };

  j$.isMap = function(obj) {
    return (
      obj !== null &&
      typeof obj !== 'undefined' &&
      obj.constructor === jasmineGlobal.Map
    );
  };

  j$.isSet = function(obj) {
    return (
      obj !== null &&
      typeof obj !== 'undefined' &&
      obj.constructor === jasmineGlobal.Set
    );
  };

  j$.isWeakMap = function(obj) {
    return (
      obj !== null &&
      typeof obj !== 'undefined' &&
      obj.constructor === jasmineGlobal.WeakMap
    );
  };

  j$.isURL = function(obj) {
    return (
      obj !== null &&
      typeof obj !== 'undefined' &&
      obj.constructor === jasmineGlobal.URL
    );
  };

  j$.isIterable_ = function(value) {
    return value && !!value[Symbol.iterator];
  };

  j$.isDataView = function(obj) {
    return (
      obj !== null &&
      typeof obj !== 'undefined' &&
      obj.constructor === jasmineGlobal.DataView
    );
  };

  j$.isPromise = function(obj) {
    return !!obj && obj.constructor === jasmineGlobal.Promise;
  };

  j$.isPromiseLike = function(obj) {
    return !!obj && j$.isFunction_(obj.then);
  };

  j$.fnNameFor = function(func) {
    if (func.name) {
      return func.name;
    }

    var matches =
      func.toString().match(/^\s*function\s*(\w+)\s*\(/) ||
      func.toString().match(/^\s*\[object\s*(\w+)Constructor\]/);

    return matches ? matches[1] : '<anonymous>';
  };

  j$.isPending_ = function(promise) {
    var sentinel = {};
    return Promise.race([promise, Promise.resolve(sentinel)]).then(
      function(result) {
        return result === sentinel;
      },
      function() {
        return false;
      }
    );
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared is an instance of the specified class/constructor.
   * @name jasmine.any
   * @since 1.3.0
   * @function
   * @param {Constructor} clazz - The constructor to check against.
   */
  j$.any = function(clazz) {
    return new j$.Any(clazz);
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared is not `null` and not `undefined`.
   * @name jasmine.anything
   * @since 2.2.0
   * @function
   */
  j$.anything = function() {
    return new j$.Anything();
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared is `true` or anything truthy.
   * @name jasmine.truthy
   * @since 3.1.0
   * @function
   */
  j$.truthy = function() {
    return new j$.Truthy();
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared is  `null`, `undefined`, `0`, `false` or anything falsey.
   * @name jasmine.falsy
   * @since 3.1.0
   * @function
   */
  j$.falsy = function() {
    return new j$.Falsy();
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared is empty.
   * @name jasmine.empty
   * @since 3.1.0
   * @function
   */
  j$.empty = function() {
    return new j$.Empty();
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared is not empty.
   * @name jasmine.notEmpty
   * @since 3.1.0
   * @function
   */
  j$.notEmpty = function() {
    return new j$.NotEmpty();
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared contains at least the keys and values.
   * @name jasmine.objectContaining
   * @since 1.3.0
   * @function
   * @param {Object} sample - The subset of properties that _must_ be in the actual.
   */
  j$.objectContaining = function(sample) {
    return new j$.ObjectContaining(sample);
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value is a `String` that matches the `RegExp` or `String`.
   * @name jasmine.stringMatching
   * @since 2.2.0
   * @function
   * @param {RegExp|String} expected
   */
  j$.stringMatching = function(expected) {
    return new j$.StringMatching(expected);
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value is a `String` that contains the specified `String`.
   * @name jasmine.stringContaining
   * @since 3.10.0
   * @function
   * @param {String} expected
   */
  j$.stringContaining = function(expected) {
    return new j$.StringContaining(expected);
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value is an `Array` that contains at least the elements in the sample.
   * @name jasmine.arrayContaining
   * @since 2.2.0
   * @function
   * @param {Array} sample
   */
  j$.arrayContaining = function(sample) {
    return new j$.ArrayContaining(sample);
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value is an `Array` that contains all of the elements in the sample in any order.
   * @name jasmine.arrayWithExactContents
   * @since 2.8.0
   * @function
   * @param {Array} sample
   */
  j$.arrayWithExactContents = function(sample) {
    return new j$.ArrayWithExactContents(sample);
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if every key/value pair in the sample passes the deep equality comparison
   * with at least one key/value pair in the actual value being compared
   * @name jasmine.mapContaining
   * @since 3.5.0
   * @function
   * @param {Map} sample - The subset of items that _must_ be in the actual.
   */
  j$.mapContaining = function(sample) {
    return new j$.MapContaining(sample);
  };

  /**
   * Get an {@link AsymmetricEqualityTester}, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if every item in the sample passes the deep equality comparison
   * with at least one item in the actual value being compared
   * @name jasmine.setContaining
   * @since 3.5.0
   * @function
   * @param {Set} sample - The subset of items that _must_ be in the actual.
   */
  j$.setContaining = function(sample) {
    return new j$.SetContaining(sample);
  };

  /**
   * Determines whether the provided function is a Jasmine spy.
   * @name jasmine.isSpy
   * @since 2.0.0
   * @function
   * @param {Function} putativeSpy - The function to check.
   * @return {Boolean}
   */
  j$.isSpy = function(putativeSpy) {
    if (!putativeSpy) {
      return false;
    }
    return (
      putativeSpy.and instanceof j$.SpyStrategy &&
      putativeSpy.calls instanceof j$.CallTracker
    );
  };

  /**
   * Logs a message for use in debugging. If the spec fails, trace messages
   * will be included in the {@link SpecResult|result} passed to the
   * reporter's specDone method.
   *
   * This method should be called only when a spec (including any associated
   * beforeEach or afterEach functions) is running.
   * @function
   * @name jasmine.debugLog
   * @since 4.0.0
   * @param {String} msg - The message to log
   */
  j$.debugLog = function(msg) {
    j$.getEnv().debugLog(msg);
  };
};

getJasmineRequireObj().util = function(j$) {
  var util = {};

  util.inherit = function(childClass, parentClass) {
    var Subclass = function() {};
    Subclass.prototype = parentClass.prototype;
    childClass.prototype = new Subclass();
  };

  util.argsToArray = function(args) {
    var arrayOfArgs = [];
    for (var i = 0; i < args.length; i++) {
      arrayOfArgs.push(args[i]);
    }
    return arrayOfArgs;
  };

  util.isUndefined = function(obj) {
    return obj === void 0;
  };

  util.arrayContains = function(array, search) {
    var i = array.length;
    while (i--) {
      if (array[i] === search) {
        return true;
      }
    }
    return false;
  };

  util.clone = function(obj) {
    if (Object.prototype.toString.apply(obj) === '[object Array]') {
      return obj.slice();
    }

    var cloned = {};
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        cloned[prop] = obj[prop];
      }
    }

    return cloned;
  };

  util.cloneArgs = function(args) {
    var clonedArgs = [];
    var argsAsArray = j$.util.argsToArray(args);
    for (var i = 0; i < argsAsArray.length; i++) {
      var str = Object.prototype.toString.apply(argsAsArray[i]),
        primitives = /^\[object (Boolean|String|RegExp|Number)/;

      // All falsey values are either primitives, `null`, or `undefined.
      if (!argsAsArray[i] || str.match(primitives)) {
        clonedArgs.push(argsAsArray[i]);
      } else {
        clonedArgs.push(j$.util.clone(argsAsArray[i]));
      }
    }
    return clonedArgs;
  };

  util.getPropertyDescriptor = function(obj, methodName) {
    var descriptor,
      proto = obj;

    do {
      descriptor = Object.getOwnPropertyDescriptor(proto, methodName);
      proto = Object.getPrototypeOf(proto);
    } while (!descriptor && proto);

    return descriptor;
  };

  util.objectDifference = function(obj, toRemove) {
    var diff = {};

    for (var key in obj) {
      if (util.has(obj, key) && !util.has(toRemove, key)) {
        diff[key] = obj[key];
      }
    }

    return diff;
  };

  util.has = function(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  };

  util.errorWithStack = function errorWithStack() {
    // Don't throw and catch. That makes it harder for users to debug their
    // code with exception breakpoints, and it's unnecessary since all
    // supported environments populate new Error().stack
    return new Error();
  };

  function callerFile() {
    var trace = new j$.StackTrace(util.errorWithStack());
    return trace.frames[2].file;
  }

  util.jasmineFile = (function() {
    var result;

    return function() {
      if (!result) {
        result = callerFile();
      }

      return result;
    };
  })();

  function StopIteration() {}
  StopIteration.prototype = Object.create(Error.prototype);
  StopIteration.prototype.constructor = StopIteration;

  util.validateTimeout = function(timeout, msgPrefix) {
    // Timeouts are implemented with setTimeout, which only supports a limited
    // range of values. The limit is unspecified, as is the behavior when it's
    // exceeded. But on all currently supported JS runtimes, setTimeout calls
    // the callback immediately when the timeout is greater than 2147483647
    // (the maximum value of a signed 32 bit integer).
    var max = 2147483647;

    if (timeout > max) {
      throw new Error(
        (msgPrefix || 'Timeout value') + ' cannot be greater than ' + max
      );
    }
  };

  return util;
};

getJasmineRequireObj().Spec = function(j$) {
  /**
   * @interface Spec
   * @see Configuration#specFilter
   * @since 2.0.0
   */
  function Spec(attrs) {
    this.expectationFactory = attrs.expectationFactory;
    this.asyncExpectationFactory = attrs.asyncExpectationFactory;
    this.resultCallback = attrs.resultCallback || function() {};
    /**
     * The unique ID of this spec.
     * @name Spec#id
     * @readonly
     * @type {string}
     * @since 2.0.0
     */
    this.id = attrs.id;
    /**
     * The description passed to the {@link it} that created this spec.
     * @name Spec#description
     * @readonly
     * @type {string}
     * @since 2.0.0
     */
    this.description = attrs.description || '';
    this.queueableFn = attrs.queueableFn;
    this.beforeAndAfterFns =
      attrs.beforeAndAfterFns ||
      function() {
        return { befores: [], afters: [] };
      };
    this.userContext =
      attrs.userContext ||
      function() {
        return {};
      };
    this.onStart = attrs.onStart || function() {};
    this.autoCleanClosures =
      attrs.autoCleanClosures === undefined ? true : !!attrs.autoCleanClosures;
    this.getSpecName =
      attrs.getSpecName ||
      function() {
        return '';
      };
    this.expectationResultFactory =
      attrs.expectationResultFactory || function() {};
    this.onLateError = attrs.onLateError || function() {};
    this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};
    this.catchingExceptions =
      attrs.catchingExceptions ||
      function() {
        return true;
      };
    this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;
    this.timer = attrs.timer || new j$.Timer();

    if (!this.queueableFn.fn) {
      this.exclude();
    }

    /**
     * @typedef SpecResult
     * @property {Int} id - The unique id of this spec.
     * @property {String} description - The description passed to the {@link it} that created this spec.
     * @property {String} fullName - The full description including all ancestors of this spec.
     * @property {Expectation[]} failedExpectations - The list of expectations that failed during execution of this spec.
     * @property {Expectation[]} passedExpectations - The list of expectations that passed during execution of this spec.
     * @property {Expectation[]} deprecationWarnings - The list of deprecation warnings that occurred during execution this spec.
     * @property {String} pendingReason - If the spec is {@link pending}, this will be the reason.
     * @property {String} status - Once the spec has completed, this string represents the pass/fail status of this spec.
     * @property {number} duration - The time in ms used by the spec execution, including any before/afterEach.
     * @property {Object} properties - User-supplied properties, if any, that were set using {@link Env#setSpecProperty}
     * @property {DebugLogEntry[]|null} debugLogs - Messages, if any, that were logged using {@link jasmine.debugLog} during a failing spec.
     * @since 2.0.0
     */
    this.result = {
      id: this.id,
      description: this.description,
      fullName: this.getFullName(),
      failedExpectations: [],
      passedExpectations: [],
      deprecationWarnings: [],
      pendingReason: '',
      duration: null,
      properties: null,
      debugLogs: null
    };
  }

  Spec.prototype.addExpectationResult = function(passed, data, isError) {
    var expectationResult = this.expectationResultFactory(data);
    if (passed) {
      this.result.passedExpectations.push(expectationResult);
    } else {
      this.result.failedExpectations.push(expectationResult);

      if (this.throwOnExpectationFailure && !isError) {
        throw new j$.errors.ExpectationFailed();
      }
    }
  };

  Spec.prototype.setSpecProperty = function(key, value) {
    this.result.properties = this.result.properties || {};
    this.result.properties[key] = value;
  };

  Spec.prototype.expect = function(actual) {
    return this.expectationFactory(actual, this);
  };

  Spec.prototype.expectAsync = function(actual) {
    return this.asyncExpectationFactory(actual, this);
  };

  Spec.prototype.execute = function(onComplete, excluded, failSpecWithNoExp) {
    var self = this;

    var onStart = {
      fn: function(done) {
        self.timer.start();
        self.onStart(self, done);
      }
    };

    var complete = {
      fn: function(done) {
        if (self.autoCleanClosures) {
          self.queueableFn.fn = null;
        }
        self.result.status = self.status(excluded, failSpecWithNoExp);
        self.result.duration = self.timer.elapsed();

        if (self.result.status !== 'failed') {
          self.result.debugLogs = null;
        }

        self.resultCallback(self.result, done);
      },
      type: 'specCleanup'
    };

    var fns = this.beforeAndAfterFns();

    var runnerConfig = {
      isLeaf: true,
      queueableFns: [...fns.befores, this.queueableFn, ...fns.afters],
      onException: function() {
        self.onException.apply(self, arguments);
      },
      onMultipleDone: function() {
        // Issue a deprecation. Include the context ourselves and pass
        // ignoreRunnable: true, since getting here always means that we've already
        // moved on and the current runnable isn't the one that caused the problem.
        self.onLateError(
          new Error(
            'An asynchronous spec, beforeEach, or afterEach function called its ' +
              "'done' callback more than once.\n(in spec: " +
              self.getFullName() +
              ')'
          )
        );
      },
      onComplete: function() {
        if (self.result.status === 'failed') {
          onComplete(new j$.StopExecutionError('spec failed'));
        } else {
          onComplete();
        }
      },
      userContext: this.userContext(),
      runnableName: this.getFullName.bind(this)
    };

    if (this.markedPending || excluded === true) {
      runnerConfig.queueableFns = [];
    }

    runnerConfig.queueableFns.unshift(onStart);
    runnerConfig.queueableFns.push(complete);

    this.queueRunnerFactory(runnerConfig);
  };

  Spec.prototype.reset = function() {
    this.result = {
      id: this.id,
      description: this.description,
      fullName: this.getFullName(),
      failedExpectations: [],
      passedExpectations: [],
      deprecationWarnings: [],
      pendingReason: this.excludeMessage,
      duration: null,
      properties: null,
      debugLogs: null
    };
    this.markedPending = this.markedExcluding;
  };

  Spec.prototype.onException = function onException(e) {
    if (Spec.isPendingSpecException(e)) {
      this.pend(extractCustomPendingMessage(e));
      return;
    }

    if (e instanceof j$.errors.ExpectationFailed) {
      return;
    }

    this.addExpectationResult(
      false,
      {
        matcherName: '',
        passed: false,
        expected: '',
        actual: '',
        error: e
      },
      true
    );
  };

  /*
   * Marks state as pending
   * @param {string} [message] An optional reason message
   */
  Spec.prototype.pend = function(message) {
    this.markedPending = true;
    if (message) {
      this.result.pendingReason = message;
    }
  };

  /*
   * Like {@link Spec#pend}, but pending state will survive {@link Spec#reset}
   * Useful for fit, xit, where pending state remains.
   * @param {string} [message] An optional reason message
   */
  Spec.prototype.exclude = function(message) {
    this.markedExcluding = true;
    if (this.message) {
      this.excludeMessage = message;
    }
    this.pend(message);
  };

  Spec.prototype.getResult = function() {
    this.result.status = this.status();
    return this.result;
  };

  Spec.prototype.status = function(excluded, failSpecWithNoExpectations) {
    if (excluded === true) {
      return 'excluded';
    }

    if (this.markedPending) {
      return 'pending';
    }

    if (
      this.result.failedExpectations.length > 0 ||
      (failSpecWithNoExpectations &&
        this.result.failedExpectations.length +
          this.result.passedExpectations.length ===
          0)
    ) {
      return 'failed';
    }

    return 'passed';
  };

  /**
   * The full description including all ancestors of this spec.
   * @name Spec#getFullName
   * @function
   * @returns {string}
   * @since 2.0.0
   */
  Spec.prototype.getFullName = function() {
    return this.getSpecName(this);
  };

  Spec.prototype.addDeprecationWarning = function(deprecation) {
    if (typeof deprecation === 'string') {
      deprecation = { message: deprecation };
    }
    this.result.deprecationWarnings.push(
      this.expectationResultFactory(deprecation)
    );
  };

  Spec.prototype.debugLog = function(msg) {
    if (!this.result.debugLogs) {
      this.result.debugLogs = [];
    }

    /**
     * @typedef DebugLogEntry
     * @property {String} message - The message that was passed to {@link jasmine.debugLog}.
     * @property {number} timestamp - The time when the entry was added, in
     * milliseconds from the spec's start time
     */
    this.result.debugLogs.push({
      message: msg,
      timestamp: this.timer.elapsed()
    });
  };

  var extractCustomPendingMessage = function(e) {
    var fullMessage = e.toString(),
      boilerplateStart = fullMessage.indexOf(Spec.pendingSpecExceptionMessage),
      boilerplateEnd =
        boilerplateStart + Spec.pendingSpecExceptionMessage.length;

    return fullMessage.substr(boilerplateEnd);
  };

  Spec.pendingSpecExceptionMessage = '=> marked Pending';

  Spec.isPendingSpecException = function(e) {
    return !!(
      e &&
      e.toString &&
      e.toString().indexOf(Spec.pendingSpecExceptionMessage) !== -1
    );
  };

  /**
   * @interface Spec
   * @see Configuration#specFilter
   */
  Object.defineProperty(Spec.prototype, 'metadata', {
    get: function() {
      if (!this.metadata_) {
        this.metadata_ = {
          /**
           * The unique ID of this spec.
           * @name Spec#id
           * @readonly
           * @type {string}
           */
          id: this.id,

          /**
           * The description passed to the {@link it} that created this spec.
           * @name Spec#description
           * @readonly
           * @type {string}
           */
          description: this.description,

          /**
           * The full description including all ancestors of this spec.
           * @name Spec#getFullName
           * @function
           * @returns {string}
           */
          getFullName: this.getFullName.bind(this)
        };
      }

      return this.metadata_;
    }
  });

  return Spec;
};

/*jshint bitwise: false*/

getJasmineRequireObj().Order = function() {
  function Order(options) {
    this.random = 'random' in options ? options.random : true;
    var seed = (this.seed = options.seed || generateSeed());
    this.sort = this.random ? randomOrder : naturalOrder;

    function naturalOrder(items) {
      return items;
    }

    function randomOrder(items) {
      var copy = items.slice();
      copy.sort(function(a, b) {
        return jenkinsHash(seed + a.id) - jenkinsHash(seed + b.id);
      });
      return copy;
    }

    function generateSeed() {
      return String(Math.random()).slice(-5);
    }

    // Bob Jenkins One-at-a-Time Hash algorithm is a non-cryptographic hash function
    // used to get a different output when the key changes slightly.
    // We use your return to sort the children randomly in a consistent way when
    // used in conjunction with a seed

    function jenkinsHash(key) {
      var hash, i;
      for (hash = i = 0; i < key.length; ++i) {
        hash += key.charCodeAt(i);
        hash += hash << 10;
        hash ^= hash >> 6;
      }
      hash += hash << 3;
      hash ^= hash >> 11;
      hash += hash << 15;
      return hash;
    }
  }

  return Order;
};

getJasmineRequireObj().Env = function(j$) {
  /**
   * @class Env
   * @since 2.0.0
   * @classdesc The Jasmine environment.<br>
   * _Note:_ Do not construct this directly. You can obtain the Env instance by
   * calling {@link jasmine.getEnv}.
   * @hideconstructor
   */
  function Env(options) {
    options = options || {};

    var self = this;
    var global = options.global || j$.getGlobal();

    var totalSpecsDefined = 0;

    var realSetTimeout = global.setTimeout;
    var realClearTimeout = global.clearTimeout;
    var clearStack = j$.getClearStack(global);
    this.clock = new j$.Clock(
      global,
      function() {
        return new j$.DelayedFunctionScheduler();
      },
      new j$.MockDate(global)
    );

    var runnableResources = {};

    var currentSpec = null;
    var currentlyExecutingSuites = [];
    var currentDeclarationSuite = null;
    var hasFailures = false;

    /**
     * This represents the available options to configure Jasmine.
     * Options that are not provided will use their default values.
     * @see Env#configure
     * @interface Configuration
     * @since 3.3.0
     */
    var config = {
      /**
       * Whether to randomize spec execution order
       * @name Configuration#random
       * @since 3.3.0
       * @type Boolean
       * @default true
       */
      random: true,
      /**
       * Seed to use as the basis of randomization.
       * Null causes the seed to be determined randomly at the start of execution.
       * @name Configuration#seed
       * @since 3.3.0
       * @type (number|string)
       * @default null
       */
      seed: null,
      /**
       * Whether to stop execution of the suite after the first spec failure
       * @name Configuration#stopOnSpecFailure
       * @since 3.9.0
       * @type Boolean
       * @default false
       */
      stopOnSpecFailure: false,
      /**
       * Whether to fail the spec if it ran no expectations. By default
       * a spec that ran no expectations is reported as passed. Setting this
       * to true will report such spec as a failure.
       * @name Configuration#failSpecWithNoExpectations
       * @since 3.5.0
       * @type Boolean
       * @default false
       */
      failSpecWithNoExpectations: false,
      /**
       * Whether to cause specs to only have one expectation failure.
       * @name Configuration#stopSpecOnExpectationFailure
       * @since 3.3.0
       * @type Boolean
       * @default false
       */
      stopSpecOnExpectationFailure: false,
      /**
       * A function that takes a spec and returns true if it should be executed
       * or false if it should be skipped.
       * @callback SpecFilter
       * @param {Spec} spec - The spec that the filter is being applied to.
       * @return boolean
       */
      /**
       * Function to use to filter specs
       * @name Configuration#specFilter
       * @since 3.3.0
       * @type SpecFilter
       * @default A function that always returns true.
       */
      specFilter: function() {
        return true;
      },
      /**
       * Whether or not reporters should hide disabled specs from their output.
       * Currently only supported by Jasmine's HTMLReporter
       * @name Configuration#hideDisabled
       * @since 3.3.0
       * @type Boolean
       * @default false
       */
      hideDisabled: false,
      /**
       * Clean closures when a suite is done running (done by clearing the stored function reference).
       * This prevents memory leaks, but you won't be able to run jasmine multiple times.
       * @name Configuration#autoCleanClosures
       * @since 3.10.0
       * @type boolean
       * @default true
       */
      autoCleanClosures: true,
      /**
       * Whether or not to issue warnings for certain deprecated functionality
       * every time it's used. If not set or set to false, deprecation warnings
       * for methods that tend to be called frequently will be issued only once
       * or otherwise throttled to to prevent the suite output from being flooded
       * with warnings.
       * @name Configuration#verboseDeprecations
       * @since 3.6.0
       * @type Boolean
       * @default false
       */
      verboseDeprecations: false
    };

    var currentSuite = function() {
      return currentlyExecutingSuites[currentlyExecutingSuites.length - 1];
    };

    var currentRunnable = function() {
      return currentSpec || currentSuite();
    };

    var globalErrors = null;

    var installGlobalErrors = function() {
      if (globalErrors) {
        return;
      }

      globalErrors = new j$.GlobalErrors();
      globalErrors.install();
    };

    if (!options.suppressLoadErrors) {
      installGlobalErrors();
      globalErrors.pushListener(function(
        message,
        filename,
        lineno,
        colNo,
        err
      ) {
        topSuite.result.failedExpectations.push({
          passed: false,
          globalErrorType: 'load',
          message: message,
          stack: err && err.stack,
          filename: filename,
          lineno: lineno
        });
      });
    }

    /**
     * Configure your jasmine environment
     * @name Env#configure
     * @since 3.3.0
     * @argument {Configuration} configuration
     * @function
     */
    this.configure = function(configuration) {
      var booleanProps = [
        'random',
        'failSpecWithNoExpectations',
        'hideDisabled',
        'stopOnSpecFailure',
        'stopSpecOnExpectationFailure',
        'autoCleanClosures'
      ];

      booleanProps.forEach(function(prop) {
        if (typeof configuration[prop] !== 'undefined') {
          config[prop] = !!configuration[prop];
        }
      });

      if (configuration.specFilter) {
        config.specFilter = configuration.specFilter;
      }

      if (typeof configuration.seed !== 'undefined') {
        config.seed = configuration.seed;
      }

      if (configuration.hasOwnProperty('verboseDeprecations')) {
        config.verboseDeprecations = configuration.verboseDeprecations;
        deprecator.verboseDeprecations(config.verboseDeprecations);
      }
    };

    /**
     * Get the current configuration for your jasmine environment
     * @name Env#configuration
     * @since 3.3.0
     * @function
     * @returns {Configuration}
     */
    this.configuration = function() {
      var result = {};
      for (var property in config) {
        result[property] = config[property];
      }
      return result;
    };

    this.setDefaultSpyStrategy = function(defaultStrategyFn) {
      if (!currentRunnable()) {
        throw new Error(
          'Default spy strategy must be set in a before function or a spec'
        );
      }
      runnableResources[
        currentRunnable().id
      ].defaultStrategyFn = defaultStrategyFn;
    };

    this.addSpyStrategy = function(name, fn) {
      if (!currentRunnable()) {
        throw new Error(
          'Custom spy strategies must be added in a before function or a spec'
        );
      }
      runnableResources[currentRunnable().id].customSpyStrategies[name] = fn;
    };

    this.addCustomEqualityTester = function(tester) {
      if (!currentRunnable()) {
        throw new Error(
          'Custom Equalities must be added in a before function or a spec'
        );
      }
      runnableResources[currentRunnable().id].customEqualityTesters.push(
        tester
      );
    };

    this.addMatchers = function(matchersToAdd) {
      if (!currentRunnable()) {
        throw new Error(
          'Matchers must be added in a before function or a spec'
        );
      }
      var customMatchers =
        runnableResources[currentRunnable().id].customMatchers;

      for (var matcherName in matchersToAdd) {
        customMatchers[matcherName] = matchersToAdd[matcherName];
      }
    };

    this.addAsyncMatchers = function(matchersToAdd) {
      if (!currentRunnable()) {
        throw new Error(
          'Async Matchers must be added in a before function or a spec'
        );
      }
      var customAsyncMatchers =
        runnableResources[currentRunnable().id].customAsyncMatchers;

      for (var matcherName in matchersToAdd) {
        customAsyncMatchers[matcherName] = matchersToAdd[matcherName];
      }
    };

    this.addCustomObjectFormatter = function(formatter) {
      if (!currentRunnable()) {
        throw new Error(
          'Custom object formatters must be added in a before function or a spec'
        );
      }

      runnableResources[currentRunnable().id].customObjectFormatters.push(
        formatter
      );
    };

    j$.Expectation.addCoreMatchers(j$.matchers);
    j$.Expectation.addAsyncCoreMatchers(j$.asyncMatchers);

    var nextSpecId = 0;
    var getNextSpecId = function() {
      return 'spec' + nextSpecId++;
    };

    var nextSuiteId = 0;
    var getNextSuiteId = function() {
      return 'suite' + nextSuiteId++;
    };

    var makePrettyPrinter = function() {
      var customObjectFormatters =
        runnableResources[currentRunnable().id].customObjectFormatters;
      return j$.makePrettyPrinter(customObjectFormatters);
    };

    var makeMatchersUtil = function() {
      const cr = currentRunnable();

      if (cr) {
        const customEqualityTesters =
          runnableResources[cr.id].customEqualityTesters;
        return new j$.MatchersUtil({
          customTesters: customEqualityTesters,
          pp: makePrettyPrinter()
        });
      } else {
        return new j$.MatchersUtil({ pp: j$.basicPrettyPrinter_ });
      }
    };

    var expectationFactory = function(actual, spec) {
      return j$.Expectation.factory({
        matchersUtil: makeMatchersUtil(),
        customMatchers: runnableResources[spec.id].customMatchers,
        actual: actual,
        addExpectationResult: addExpectationResult
      });

      function addExpectationResult(passed, result) {
        return spec.addExpectationResult(passed, result);
      }
    };

    function recordLateError(error) {
      const result = expectationResultFactory({
        error,
        passed: false,
        matcherName: '',
        expected: '',
        actual: ''
      });
      result.globalErrorType = 'lateError';
      topSuite.result.failedExpectations.push(result);
    }

    function recordLateExpectation(runable, runableType, result) {
      var delayedExpectationResult = {};
      Object.keys(result).forEach(function(k) {
        delayedExpectationResult[k] = result[k];
      });
      delayedExpectationResult.passed = false;
      delayedExpectationResult.globalErrorType = 'lateExpectation';
      delayedExpectationResult.message =
        runableType +
        ' "' +
        runable.getFullName() +
        '" ran a "' +
        result.matcherName +
        '" expectation after it finished.\n';

      if (result.message) {
        delayedExpectationResult.message +=
          'Message: "' + result.message + '"\n';
      }

      delayedExpectationResult.message +=
        '1. Did you forget to return or await the result of expectAsync?\n' +
        '2. Was done() invoked before an async operation completed?\n' +
        '3. Did an expectation follow a call to done()?';

      topSuite.result.failedExpectations.push(delayedExpectationResult);
    }

    var asyncExpectationFactory = function(actual, spec, runableType) {
      return j$.Expectation.asyncFactory({
        matchersUtil: makeMatchersUtil(),
        customAsyncMatchers: runnableResources[spec.id].customAsyncMatchers,
        actual: actual,
        addExpectationResult: addExpectationResult
      });

      function addExpectationResult(passed, result) {
        if (currentRunnable() !== spec) {
          recordLateExpectation(spec, runableType, result);
        }
        return spec.addExpectationResult(passed, result);
      }
    };
    var suiteAsyncExpectationFactory = function(actual, suite) {
      return asyncExpectationFactory(actual, suite, 'Suite');
    };

    var specAsyncExpectationFactory = function(actual, suite) {
      return asyncExpectationFactory(actual, suite, 'Spec');
    };

    var defaultResourcesForRunnable = function(id, parentRunnableId) {
      var resources = {
        spies: [],
        customEqualityTesters: [],
        customMatchers: {},
        customAsyncMatchers: {},
        customSpyStrategies: {},
        defaultStrategyFn: undefined,
        customObjectFormatters: []
      };

      if (runnableResources[parentRunnableId]) {
        resources.customEqualityTesters = j$.util.clone(
          runnableResources[parentRunnableId].customEqualityTesters
        );
        resources.customMatchers = j$.util.clone(
          runnableResources[parentRunnableId].customMatchers
        );
        resources.customAsyncMatchers = j$.util.clone(
          runnableResources[parentRunnableId].customAsyncMatchers
        );
        resources.customObjectFormatters = j$.util.clone(
          runnableResources[parentRunnableId].customObjectFormatters
        );
        resources.customSpyStrategies = j$.util.clone(
          runnableResources[parentRunnableId].customSpyStrategies
        );
        resources.defaultStrategyFn =
          runnableResources[parentRunnableId].defaultStrategyFn;
      }

      runnableResources[id] = resources;
    };

    var clearResourcesForRunnable = function(id) {
      spyRegistry.clearSpies();
      delete runnableResources[id];
    };

    var beforeAndAfterFns = function(targetSuite) {
      return function() {
        var befores = [],
          afters = [],
          suite = targetSuite;

        while (suite) {
          befores = befores.concat(suite.beforeFns);
          afters = afters.concat(suite.afterFns);

          suite = suite.parentSuite;
        }

        return {
          befores: befores.reverse(),
          afters: afters
        };
      };
    };

    var getSpecName = function(spec, suite) {
      var fullName = [spec.description],
        suiteFullName = suite.getFullName();

      if (suiteFullName !== '') {
        fullName.unshift(suiteFullName);
      }
      return fullName.join(' ');
    };

    // TODO: we may just be able to pass in the fn instead of wrapping here
    var buildExpectationResult = j$.buildExpectationResult,
      exceptionFormatter = new j$.ExceptionFormatter(),
      expectationResultFactory = function(attrs) {
        attrs.messageFormatter = exceptionFormatter.message;
        attrs.stackFormatter = exceptionFormatter.stack;

        return buildExpectationResult(attrs);
      };

    /**
     * Causes a deprecation warning to be logged to the console and reported to
     * reporters.
     *
     * The optional second parameter is an object that can have either of the
     * following properties:
     *
     * omitStackTrace: Whether to omit the stack trace. Optional. Defaults to
     * false. This option is ignored if the deprecation is an Error. Set this
     * when the stack trace will not contain anything that helps the user find
     * the source of the deprecation.
     *
     * ignoreRunnable: Whether to log the deprecation on the root suite, ignoring
     * the spec or suite that's running when it happens. Optional. Defaults to
     * false.
     *
     * @name Env#deprecated
     * @since 2.99
     * @function
     * @param {String|Error} deprecation The deprecation message
     * @param {Object} [options] Optional extra options, as described above
     */
    this.deprecated = function(deprecation, options) {
      var runnable = currentRunnable() || topSuite;
      deprecator.addDeprecationWarning(runnable, deprecation, options);
    };

    var queueRunnerFactory = function(options, args) {
      if (options.isLeaf) {
        // A spec
        options.SkipPolicy = j$.CompleteOnFirstErrorSkipPolicy;
      } else if (options.isReporter) {
        // A reporter queue
        options.SkipPolicy = j$.NeverSkipPolicy;
      } else {
        // A suite
        if (config.stopOnSpecFailure) {
          options.SkipPolicy = j$.CompleteOnFirstErrorSkipPolicy;
        } else {
          options.SkipPolicy = j$.SkipAfterBeforeAllErrorPolicy;
        }
      }

      options.clearStack = options.clearStack || clearStack;
      options.timeout = {
        setTimeout: realSetTimeout,
        clearTimeout: realClearTimeout
      };
      options.fail = self.fail;
      options.globalErrors = globalErrors;
      options.onException =
        options.onException ||
        function(e) {
          (currentRunnable() || topSuite).onException(e);
        };
      options.deprecated = self.deprecated;

      new j$.QueueRunner(options).execute(args);
    };

    var topSuite = new j$.Suite({
      id: getNextSuiteId(),
      description: 'Jasmine__TopLevel__Suite',
      expectationFactory: expectationFactory,
      asyncExpectationFactory: suiteAsyncExpectationFactory,
      expectationResultFactory: expectationResultFactory,
      autoCleanClosures: config.autoCleanClosures,
      onLateError: recordLateError
    });
    var deprecator = new j$.Deprecator(topSuite);
    currentDeclarationSuite = topSuite;

    /**
     * Provides the root suite, through which all suites and specs can be
     * accessed.
     * @function
     * @name Env#topSuite
     * @return {Suite} the root suite
     * @since 2.0.0
     */
    this.topSuite = function() {
      return topSuite.metadata;
    };

    /**
     * This represents the available reporter callback for an object passed to {@link Env#addReporter}.
     * @interface Reporter
     * @see custom_reporter
     */
    var reporter = new j$.ReportDispatcher(
      [
        /**
         * `jasmineStarted` is called after all of the specs have been loaded, but just before execution starts.
         * @function
         * @name Reporter#jasmineStarted
         * @param {JasmineStartedInfo} suiteInfo Information about the full Jasmine suite that is being run
         * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.
         * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.
         * @see async
         */
        'jasmineStarted',
        /**
         * When the entire suite has finished execution `jasmineDone` is called
         * @function
         * @name Reporter#jasmineDone
         * @param {JasmineDoneInfo} suiteInfo Information about the full Jasmine suite that just finished running.
         * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.
         * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.
         * @see async
         */
        'jasmineDone',
        /**
         * `suiteStarted` is invoked when a `describe` starts to run
         * @function
         * @name Reporter#suiteStarted
         * @param {SuiteResult} result Information about the individual {@link describe} being run
         * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.
         * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.
         * @see async
         */
        'suiteStarted',
        /**
         * `suiteDone` is invoked when all of the child specs and suites for a given suite have been run
         *
         * While jasmine doesn't require any specific functions, not defining a `suiteDone` will make it impossible for a reporter to know when a suite has failures in an `afterAll`.
         * @function
         * @name Reporter#suiteDone
         * @param {SuiteResult} result
         * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.
         * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.
         * @see async
         */
        'suiteDone',
        /**
         * `specStarted` is invoked when an `it` starts to run (including associated `beforeEach` functions)
         * @function
         * @name Reporter#specStarted
         * @param {SpecResult} result Information about the individual {@link it} being run
         * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.
         * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.
         * @see async
         */
        'specStarted',
        /**
         * `specDone` is invoked when an `it` and its associated `beforeEach` and `afterEach` functions have been run.
         *
         * While jasmine doesn't require any specific functions, not defining a `specDone` will make it impossible for a reporter to know when a spec has failed.
         * @function
         * @name Reporter#specDone
         * @param {SpecResult} result
         * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.
         * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.
         * @see async
         */
        'specDone'
      ],
      queueRunnerFactory,
      recordLateError
    );

    /**
     * Executes the specs.
     *
     * If called with no parameters or with a falsy value as the first parameter,
     * all specs will be executed except those that are excluded by a
     * [spec filter]{@link Configuration#specFilter} or other mechanism. If the
     * first parameter is a list of spec/suite IDs, only those specs/suites will
     * be run.
     *
     * Both parameters are optional, but a completion callback is only valid as
     * the second parameter. To specify a completion callback but not a list of
     * specs/suites to run, pass null or undefined as the first parameter. The
     * completion callback is supported for backward compatibility. In most
     * cases it will be more convenient to use the returned promise instead.
     *
     * execute should not be called more than once unless the env has been
     * configured with `{autoCleanClosures: false}`.
     *
     * execute returns a promise. The promise will be resolved to the same
     * {@link JasmineDoneInfo|overall result} that's passed to a reporter's
     * `jasmineDone` method, even if the suite did not pass. To determine
     * whether the suite passed, check the value that the promise resolves to
     * or use a {@link Reporter}.
     *
     * @name Env#execute
     * @since 2.0.0
     * @function
     * @param {(string[])=} runnablesToRun IDs of suites and/or specs to run
     * @param {Function=} onComplete Function that will be called after all specs have run
     * @return {Promise<JasmineDoneInfo>}
     */
    this.execute = function(runnablesToRun, onComplete) {
      if (this._executedBefore) {
        topSuite.reset();
      }
      this._executedBefore = true;
      defaultResourcesForRunnable(topSuite.id);
      installGlobalErrors();

      if (!runnablesToRun) {
        if (focusedRunnables.length) {
          runnablesToRun = focusedRunnables;
        } else {
          runnablesToRun = [topSuite.id];
        }
      }

      var order = new j$.Order({
        random: config.random,
        seed: config.seed
      });

      var processor = new j$.TreeProcessor({
        tree: topSuite,
        runnableIds: runnablesToRun,
        queueRunnerFactory: queueRunnerFactory,
        failSpecWithNoExpectations: config.failSpecWithNoExpectations,
        nodeStart: function(suite, next) {
          currentlyExecutingSuites.push(suite);
          defaultResourcesForRunnable(suite.id, suite.parentSuite.id);
          reporter.suiteStarted(suite.result, next);
          suite.startTimer();
        },
        nodeComplete: function(suite, result, next) {
          if (suite !== currentSuite()) {
            throw new Error('Tried to complete the wrong suite');
          }

          clearResourcesForRunnable(suite.id);
          currentlyExecutingSuites.pop();

          if (result.status === 'failed') {
            hasFailures = true;
          }
          suite.endTimer();

          if (suite.hadBeforeAllFailure) {
            reportChildrenOfBeforeAllFailure(suite).then(function() {
              reporter.suiteDone(result, next);
            });
          } else {
            reporter.suiteDone(result, next);
          }
        },
        orderChildren: function(node) {
          return order.sort(node.children);
        },
        excludeNode: function(spec) {
          return !config.specFilter(spec);
        }
      });

      if (!processor.processTree().valid) {
        throw new Error(
          'Invalid order: would cause a beforeAll or afterAll to be run multiple times'
        );
      }

      var jasmineTimer = new j$.Timer();
      jasmineTimer.start();

      return new Promise(function(resolve) {
        runAll(function(jasmineDoneInfo) {
          if (onComplete) {
            onComplete();
          }

          resolve(jasmineDoneInfo);
        });
      });

      function runAll(done) {
        /**
         * Information passed to the {@link Reporter#jasmineStarted} event.
         * @typedef JasmineStartedInfo
         * @property {Int} totalSpecsDefined - The total number of specs defined in this suite.
         * @property {Order} order - Information about the ordering (random or not) of this execution of the suite.
         * @since 2.0.0
         */
        reporter.jasmineStarted(
          {
            totalSpecsDefined: totalSpecsDefined,
            order: order
          },
          function() {
            currentlyExecutingSuites.push(topSuite);

            processor.execute(function() {
              (async function() {
                if (topSuite.hadBeforeAllFailure) {
                  await reportChildrenOfBeforeAllFailure(topSuite);
                }

                clearResourcesForRunnable(topSuite.id);
                currentlyExecutingSuites.pop();
                var overallStatus, incompleteReason;

                if (
                  hasFailures ||
                  topSuite.result.failedExpectations.length > 0
                ) {
                  overallStatus = 'failed';
                } else if (focusedRunnables.length > 0) {
                  overallStatus = 'incomplete';
                  incompleteReason = 'fit() or fdescribe() was found';
                } else if (totalSpecsDefined === 0) {
                  overallStatus = 'incomplete';
                  incompleteReason = 'No specs found';
                } else {
                  overallStatus = 'passed';
                }

                /**
                 * Information passed to the {@link Reporter#jasmineDone} event.
                 * @typedef JasmineDoneInfo
                 * @property {OverallStatus} overallStatus - The overall result of the suite: 'passed', 'failed', or 'incomplete'.
                 * @property {Int} totalTime - The total time (in ms) that it took to execute the suite
                 * @property {IncompleteReason} incompleteReason - Explanation of why the suite was incomplete.
                 * @property {Order} order - Information about the ordering (random or not) of this execution of the suite.
                 * @property {Expectation[]} failedExpectations - List of expectations that failed in an {@link afterAll} at the global level.
                 * @property {Expectation[]} deprecationWarnings - List of deprecation warnings that occurred at the global level.
                 * @since 2.4.0
                 */
                const jasmineDoneInfo = {
                  overallStatus: overallStatus,
                  totalTime: jasmineTimer.elapsed(),
                  incompleteReason: incompleteReason,
                  order: order,
                  failedExpectations: topSuite.result.failedExpectations,
                  deprecationWarnings: topSuite.result.deprecationWarnings
                };
                reporter.jasmineDone(jasmineDoneInfo, function() {
                  done(jasmineDoneInfo);
                });
              })();
            });
          }
        );
      }

      async function reportChildrenOfBeforeAllFailure(suite) {
        for (const child of suite.children) {
          if (child instanceof j$.Suite) {
            await new Promise(function(resolve) {
              reporter.suiteStarted(child.result, resolve);
            });
            await reportChildrenOfBeforeAllFailure(child);

            // Marking the suite passed is consistent with how suites that
            // contain failed specs but no suite-level failures are reported.
            child.result.status = 'passed';

            await new Promise(function(resolve) {
              reporter.suiteDone(child.result, resolve);
            });
          } else {
            /* a spec */
            await new Promise(function(resolve) {
              reporter.specStarted(child.result, resolve);
            });

            child.addExpectationResult(
              false,
              {
                passed: false,
                message:
                  'Not run because a beforeAll function failed. The ' +
                  'beforeAll failure will be reported on the suite that ' +
                  'caused it.'
              },
              true
            );
            child.result.status = 'failed';

            await new Promise(function(resolve) {
              reporter.specDone(child.result, resolve);
            });
          }
        }
      }
    };

    /**
     * Add a custom reporter to the Jasmine environment.
     * @name Env#addReporter
     * @since 2.0.0
     * @function
     * @param {Reporter} reporterToAdd The reporter to be added.
     * @see custom_reporter
     */
    this.addReporter = function(reporterToAdd) {
      reporter.addReporter(reporterToAdd);
    };

    /**
     * Provide a fallback reporter if no other reporters have been specified.
     * @name Env#provideFallbackReporter
     * @since 2.5.0
     * @function
     * @param {Reporter} reporterToAdd The reporter
     * @see custom_reporter
     */
    this.provideFallbackReporter = function(reporterToAdd) {
      reporter.provideFallbackReporter(reporterToAdd);
    };

    /**
     * Clear all registered reporters
     * @name Env#clearReporters
     * @since 2.5.2
     * @function
     */
    this.clearReporters = function() {
      reporter.clearReporters();
    };

    var spyFactory = new j$.SpyFactory(
      function getCustomStrategies() {
        var runnable = currentRunnable();

        if (runnable) {
          return runnableResources[runnable.id].customSpyStrategies;
        }

        return {};
      },
      function getDefaultStrategyFn() {
        var runnable = currentRunnable();

        if (runnable) {
          return runnableResources[runnable.id].defaultStrategyFn;
        }

        return undefined;
      },
      makeMatchersUtil
    );

    var spyRegistry = new j$.SpyRegistry({
      currentSpies: function() {
        if (!currentRunnable()) {
          throw new Error(
            'Spies must be created in a before function or a spec'
          );
        }
        return runnableResources[currentRunnable().id].spies;
      },
      createSpy: function(name, originalFn) {
        return self.createSpy(name, originalFn);
      }
    });

    /**
     * Configures whether Jasmine should allow the same function to be spied on
     * more than once during the execution of a spec. By default, spying on
     * a function that is already a spy will cause an error.
     * @name Env#allowRespy
     * @function
     * @since 2.5.0
     * @param {boolean} allow Whether to allow respying
     */
    this.allowRespy = function(allow) {
      spyRegistry.allowRespy(allow);
    };

    this.spyOn = function() {
      return spyRegistry.spyOn.apply(spyRegistry, arguments);
    };

    this.spyOnProperty = function() {
      return spyRegistry.spyOnProperty.apply(spyRegistry, arguments);
    };

    this.spyOnAllFunctions = function() {
      return spyRegistry.spyOnAllFunctions.apply(spyRegistry, arguments);
    };

    this.createSpy = function(name, originalFn) {
      if (arguments.length === 1 && j$.isFunction_(name)) {
        originalFn = name;
        name = originalFn.name;
      }

      return spyFactory.createSpy(name, originalFn);
    };

    this.createSpyObj = function(baseName, methodNames, propertyNames) {
      return spyFactory.createSpyObj(baseName, methodNames, propertyNames);
    };

    var ensureIsFunction = function(fn, caller) {
      if (!j$.isFunction_(fn)) {
        throw new Error(
          caller + ' expects a function argument; received ' + j$.getType_(fn)
        );
      }
    };

    var ensureIsFunctionOrAsync = function(fn, caller) {
      if (!j$.isFunction_(fn) && !j$.isAsyncFunction_(fn)) {
        throw new Error(
          caller + ' expects a function argument; received ' + j$.getType_(fn)
        );
      }
    };

    function ensureIsNotNested(method) {
      var runnable = currentRunnable();
      if (runnable !== null && runnable !== undefined) {
        throw new Error(
          "'" + method + "' should only be used in 'describe' function"
        );
      }
    }

    var suiteFactory = function(description) {
      var suite = new j$.Suite({
        id: getNextSuiteId(),
        description: description,
        parentSuite: currentDeclarationSuite,
        timer: new j$.Timer(),
        expectationFactory: expectationFactory,
        asyncExpectationFactory: suiteAsyncExpectationFactory,
        expectationResultFactory: expectationResultFactory,
        throwOnExpectationFailure: config.stopSpecOnExpectationFailure,
        autoCleanClosures: config.autoCleanClosures,
        onLateError: recordLateError
      });

      return suite;
    };

    this.describe = function(description, specDefinitions) {
      ensureIsNotNested('describe');
      ensureIsFunction(specDefinitions, 'describe');
      var suite = suiteFactory(description);
      if (specDefinitions.length > 0) {
        throw new Error('describe does not expect any arguments');
      }
      if (currentDeclarationSuite.markedExcluding) {
        suite.exclude();
      }
      addSpecsToSuite(suite, specDefinitions);
      if (suite.parentSuite && !suite.children.length) {
        throw new Error('describe with no children (describe() or it())');
      }
      return suite.metadata;
    };

    this.xdescribe = function(description, specDefinitions) {
      ensureIsNotNested('xdescribe');
      ensureIsFunction(specDefinitions, 'xdescribe');
      var suite = suiteFactory(description);
      suite.exclude();
      addSpecsToSuite(suite, specDefinitions);
      return suite.metadata;
    };

    var focusedRunnables = [];

    this.fdescribe = function(description, specDefinitions) {
      ensureIsNotNested('fdescribe');
      ensureIsFunction(specDefinitions, 'fdescribe');
      var suite = suiteFactory(description);
      suite.isFocused = true;

      focusedRunnables.push(suite.id);
      unfocusAncestor();
      addSpecsToSuite(suite, specDefinitions);

      return suite.metadata;
    };

    function addSpecsToSuite(suite, specDefinitions) {
      var parentSuite = currentDeclarationSuite;
      parentSuite.addChild(suite);
      currentDeclarationSuite = suite;

      var declarationError = null;
      try {
        specDefinitions();
      } catch (e) {
        declarationError = e;
      }

      if (declarationError) {
        suite.onException(declarationError);
      }

      currentDeclarationSuite = parentSuite;
    }

    function findFocusedAncestor(suite) {
      while (suite) {
        if (suite.isFocused) {
          return suite.id;
        }
        suite = suite.parentSuite;
      }

      return null;
    }

    function unfocusAncestor() {
      var focusedAncestor = findFocusedAncestor(currentDeclarationSuite);
      if (focusedAncestor) {
        for (var i = 0; i < focusedRunnables.length; i++) {
          if (focusedRunnables[i] === focusedAncestor) {
            focusedRunnables.splice(i, 1);
            break;
          }
        }
      }
    }

    var specFactory = function(description, fn, suite, timeout) {
      totalSpecsDefined++;
      var spec = new j$.Spec({
        id: getNextSpecId(),
        beforeAndAfterFns: beforeAndAfterFns(suite),
        expectationFactory: expectationFactory,
        asyncExpectationFactory: specAsyncExpectationFactory,
        onLateError: recordLateError,
        resultCallback: specResultCallback,
        getSpecName: function(spec) {
          return getSpecName(spec, suite);
        },
        onStart: specStarted,
        description: description,
        expectationResultFactory: expectationResultFactory,
        queueRunnerFactory: queueRunnerFactory,
        userContext: function() {
          return suite.clonedSharedUserContext();
        },
        queueableFn: {
          fn: fn,
          timeout: timeout || 0
        },
        throwOnExpectationFailure: config.stopSpecOnExpectationFailure,
        autoCleanClosures: config.autoCleanClosures,
        timer: new j$.Timer()
      });
      return spec;

      function specResultCallback(result, next) {
        clearResourcesForRunnable(spec.id);
        currentSpec = null;

        if (result.status === 'failed') {
          hasFailures = true;
        }

        reporter.specDone(result, next);
      }

      function specStarted(spec, next) {
        currentSpec = spec;
        defaultResourcesForRunnable(spec.id, suite.id);
        reporter.specStarted(spec.result, next);
      }
    };

    this.it_ = function(description, fn, timeout) {
      ensureIsNotNested('it');
      // it() sometimes doesn't have a fn argument, so only check the type if
      // it's given.
      if (arguments.length > 1 && typeof fn !== 'undefined') {
        ensureIsFunctionOrAsync(fn, 'it');
      }

      if (timeout) {
        j$.util.validateTimeout(timeout);
      }

      var spec = specFactory(description, fn, currentDeclarationSuite, timeout);
      if (currentDeclarationSuite.markedExcluding) {
        spec.exclude();
      }
      currentDeclarationSuite.addChild(spec);

      return spec;
    };

    this.it = function(description, fn, timeout) {
      const spec = this.it_(description, fn, timeout);
      return spec.metadata;
    };

    this.xit = function(description, fn, timeout) {
      ensureIsNotNested('xit');
      // xit(), like it(), doesn't always have a fn argument, so only check the
      // type when needed.
      if (arguments.length > 1 && typeof fn !== 'undefined') {
        ensureIsFunctionOrAsync(fn, 'xit');
      }
      var spec = this.it_.apply(this, arguments);
      spec.exclude('Temporarily disabled with xit');
      return spec.metadata;
    };

    this.fit = function(description, fn, timeout) {
      ensureIsNotNested('fit');
      ensureIsFunctionOrAsync(fn, 'fit');

      if (timeout) {
        j$.util.validateTimeout(timeout);
      }
      var spec = specFactory(description, fn, currentDeclarationSuite, timeout);
      currentDeclarationSuite.addChild(spec);
      focusedRunnables.push(spec.id);
      unfocusAncestor();
      return spec.metadata;
    };

    /**
     * Sets a user-defined property that will be provided to reporters as part of the properties field of {@link SpecResult}
     * @name Env#setSpecProperty
     * @since 3.6.0
     * @function
     * @param {String} key The name of the property
     * @param {*} value The value of the property
     */
    this.setSpecProperty = function(key, value) {
      if (!currentRunnable() || currentRunnable() == currentSuite()) {
        throw new Error(
          "'setSpecProperty' was used when there was no current spec"
        );
      }
      currentRunnable().setSpecProperty(key, value);
    };

    /**
     * Sets a user-defined property that will be provided to reporters as part of the properties field of {@link SuiteResult}
     * @name Env#setSuiteProperty
     * @since 3.6.0
     * @function
     * @param {String} key The name of the property
     * @param {*} value The value of the property
     */
    this.setSuiteProperty = function(key, value) {
      if (!currentSuite()) {
        throw new Error(
          "'setSuiteProperty' was used when there was no current suite"
        );
      }
      currentSuite().setSuiteProperty(key, value);
    };

    this.debugLog = function(msg) {
      var maybeSpec = currentRunnable();

      if (!maybeSpec || !maybeSpec.debugLog) {
        throw new Error("'debugLog' was called when there was no current spec");
      }

      maybeSpec.debugLog(msg);
    };

    this.expect = function(actual) {
      if (!currentRunnable()) {
        throw new Error(
          "'expect' was used when there was no current spec, this could be because an asynchronous test timed out"
        );
      }

      return currentRunnable().expect(actual);
    };

    this.expectAsync = function(actual) {
      if (!currentRunnable()) {
        throw new Error(
          "'expectAsync' was used when there was no current spec, this could be because an asynchronous test timed out"
        );
      }

      return currentRunnable().expectAsync(actual);
    };

    this.beforeEach = function(beforeEachFunction, timeout) {
      ensureIsNotNested('beforeEach');
      ensureIsFunctionOrAsync(beforeEachFunction, 'beforeEach');

      if (timeout) {
        j$.util.validateTimeout(timeout);
      }

      currentDeclarationSuite.beforeEach({
        fn: beforeEachFunction,
        timeout: timeout || 0
      });
    };

    this.beforeAll = function(beforeAllFunction, timeout) {
      ensureIsNotNested('beforeAll');
      ensureIsFunctionOrAsync(beforeAllFunction, 'beforeAll');

      if (timeout) {
        j$.util.validateTimeout(timeout);
      }

      currentDeclarationSuite.beforeAll({
        fn: beforeAllFunction,
        timeout: timeout || 0
      });
    };

    this.afterEach = function(afterEachFunction, timeout) {
      ensureIsNotNested('afterEach');
      ensureIsFunctionOrAsync(afterEachFunction, 'afterEach');

      if (timeout) {
        j$.util.validateTimeout(timeout);
      }

      afterEachFunction.isCleanup = true;
      currentDeclarationSuite.afterEach({
        fn: afterEachFunction,
        timeout: timeout || 0
      });
    };

    this.afterAll = function(afterAllFunction, timeout) {
      ensureIsNotNested('afterAll');
      ensureIsFunctionOrAsync(afterAllFunction, 'afterAll');

      if (timeout) {
        j$.util.validateTimeout(timeout);
      }

      currentDeclarationSuite.afterAll({
        fn: afterAllFunction,
        timeout: timeout || 0
      });
    };

    this.pending = function(message) {
      var fullMessage = j$.Spec.pendingSpecExceptionMessage;
      if (message) {
        fullMessage += message;
      }
      throw fullMessage;
    };

    this.fail = function(error) {
      if (!currentRunnable()) {
        throw new Error(
          "'fail' was used when there was no current spec, this could be because an asynchronous test timed out"
        );
      }

      var message = 'Failed';
      if (error) {
        message += ': ';
        if (error.message) {
          message += error.message;
        } else if (j$.isString_(error)) {
          message += error;
        } else {
          // pretty print all kind of objects. This includes arrays.
          message += makePrettyPrinter()(error);
        }
      }

      currentRunnable().addExpectationResult(false, {
        matcherName: '',
        passed: false,
        expected: '',
        actual: '',
        message: message,
        error: error && error.message ? error : null
      });

      if (config.stopSpecOnExpectationFailure) {
        throw new Error(message);
      }
    };

    this.cleanup_ = function() {
      if (globalErrors) {
        globalErrors.uninstall();
      }
    };
  }

  return Env;
};

getJasmineRequireObj().JsApiReporter = function(j$) {
  /**
   * @name jsApiReporter
   * @classdesc {@link Reporter} added by default in `boot.js` to record results for retrieval in javascript code. An instance is made available as `jsApiReporter` on the global object.
   * @class
   * @hideconstructor
   */
  function JsApiReporter(options) {
    var timer = options.timer || new j$.Timer(),
      status = 'loaded';

    this.started = false;
    this.finished = false;
    this.runDetails = {};

    this.jasmineStarted = function() {
      this.started = true;
      status = 'started';
      timer.start();
    };

    var executionTime;

    this.jasmineDone = function(runDetails) {
      this.finished = true;
      this.runDetails = runDetails;
      executionTime = timer.elapsed();
      status = 'done';
    };

    /**
     * Get the current status for the Jasmine environment.
     * @name jsApiReporter#status
     * @since 2.0.0
     * @function
     * @return {String} - One of `loaded`, `started`, or `done`
     */
    this.status = function() {
      return status;
    };

    var suites = [],
      suites_hash = {};

    this.suiteStarted = function(result) {
      suites_hash[result.id] = result;
    };

    this.suiteDone = function(result) {
      storeSuite(result);
    };

    /**
     * Get the results for a set of suites.
     *
     * Retrievable in slices for easier serialization.
     * @name jsApiReporter#suiteResults
     * @since 2.1.0
     * @function
     * @param {Number} index - The position in the suites list to start from.
     * @param {Number} length - Maximum number of suite results to return.
     * @return {SuiteResult[]}
     */
    this.suiteResults = function(index, length) {
      return suites.slice(index, index + length);
    };

    function storeSuite(result) {
      suites.push(result);
      suites_hash[result.id] = result;
    }

    /**
     * Get all of the suites in a single object, with their `id` as the key.
     * @name jsApiReporter#suites
     * @since 2.0.0
     * @function
     * @return {Object} - Map of suite id to {@link SuiteResult}
     */
    this.suites = function() {
      return suites_hash;
    };

    var specs = [];

    this.specDone = function(result) {
      specs.push(result);
    };

    /**
     * Get the results for a set of specs.
     *
     * Retrievable in slices for easier serialization.
     * @name jsApiReporter#specResults
     * @since 2.0.0
     * @function
     * @param {Number} index - The position in the specs list to start from.
     * @param {Number} length - Maximum number of specs results to return.
     * @return {SpecResult[]}
     */
    this.specResults = function(index, length) {
      return specs.slice(index, index + length);
    };

    /**
     * Get all spec results.
     * @name jsApiReporter#specs
     * @since 2.0.0
     * @function
     * @return {SpecResult[]}
     */
    this.specs = function() {
      return specs;
    };

    /**
     * Get the number of milliseconds it took for the full Jasmine suite to run.
     * @name jsApiReporter#executionTime
     * @since 2.0.0
     * @function
     * @return {Number}
     */
    this.executionTime = function() {
      return executionTime;
    };
  }

  return JsApiReporter;
};

getJasmineRequireObj().Any = function(j$) {
  function Any(expectedObject) {
    if (typeof expectedObject === 'undefined') {
      throw new TypeError(
        'jasmine.any() expects to be passed a constructor function. ' +
          'Please pass one or use jasmine.anything() to match any object.'
      );
    }
    this.expectedObject = expectedObject;
  }

  Any.prototype.asymmetricMatch = function(other) {
    if (this.expectedObject == String) {
      return typeof other == 'string' || other instanceof String;
    }

    if (this.expectedObject == Number) {
      return typeof other == 'number' || other instanceof Number;
    }

    if (this.expectedObject == Function) {
      return typeof other == 'function' || other instanceof Function;
    }

    if (this.expectedObject == Object) {
      return other !== null && typeof other == 'object';
    }

    if (this.expectedObject == Boolean) {
      return typeof other == 'boolean';
    }

    /* jshint -W122 */
    /* global Symbol */
    if (typeof Symbol != 'undefined' && this.expectedObject == Symbol) {
      return typeof other == 'symbol';
    }
    /* jshint +W122 */

    return other instanceof this.expectedObject;
  };

  Any.prototype.jasmineToString = function() {
    return '<jasmine.any(' + j$.fnNameFor(this.expectedObject) + ')>';
  };

  return Any;
};

getJasmineRequireObj().Anything = function(j$) {
  function Anything() {}

  Anything.prototype.asymmetricMatch = function(other) {
    return !j$.util.isUndefined(other) && other !== null;
  };

  Anything.prototype.jasmineToString = function() {
    return '<jasmine.anything>';
  };

  return Anything;
};

getJasmineRequireObj().ArrayContaining = function(j$) {
  function ArrayContaining(sample) {
    this.sample = sample;
  }

  ArrayContaining.prototype.asymmetricMatch = function(other, matchersUtil) {
    if (!j$.isArray_(this.sample)) {
      throw new Error(
        'You must provide an array to arrayContaining, not ' +
          j$.basicPrettyPrinter_(this.sample) +
          '.'
      );
    }

    // If the actual parameter is not an array, we can fail immediately, since it couldn't
    // possibly be an "array containing" anything. However, we also want an empty sample
    // array to match anything, so we need to double-check we aren't in that case
    if (!j$.isArray_(other) && this.sample.length > 0) {
      return false;
    }

    for (var i = 0; i < this.sample.length; i++) {
      var item = this.sample[i];
      if (!matchersUtil.contains(other, item)) {
        return false;
      }
    }

    return true;
  };

  ArrayContaining.prototype.jasmineToString = function(pp) {
    return '<jasmine.arrayContaining(' + pp(this.sample) + ')>';
  };

  return ArrayContaining;
};

getJasmineRequireObj().ArrayWithExactContents = function(j$) {
  function ArrayWithExactContents(sample) {
    this.sample = sample;
  }

  ArrayWithExactContents.prototype.asymmetricMatch = function(
    other,
    matchersUtil
  ) {
    if (!j$.isArray_(this.sample)) {
      throw new Error(
        'You must provide an array to arrayWithExactContents, not ' +
          j$.basicPrettyPrinter_(this.sample) +
          '.'
      );
    }

    if (this.sample.length !== other.length) {
      return false;
    }

    for (var i = 0; i < this.sample.length; i++) {
      var item = this.sample[i];
      if (!matchersUtil.contains(other, item)) {
        return false;
      }
    }

    return true;
  };

  ArrayWithExactContents.prototype.jasmineToString = function(pp) {
    return '<jasmine.arrayWithExactContents(' + pp(this.sample) + ')>';
  };

  return ArrayWithExactContents;
};

getJasmineRequireObj().Empty = function(j$) {
  function Empty() {}

  Empty.prototype.asymmetricMatch = function(other) {
    if (j$.isString_(other) || j$.isArray_(other) || j$.isTypedArray_(other)) {
      return other.length === 0;
    }

    if (j$.isMap(other) || j$.isSet(other)) {
      return other.size === 0;
    }

    if (j$.isObject_(other)) {
      return Object.keys(other).length === 0;
    }
    return false;
  };

  Empty.prototype.jasmineToString = function() {
    return '<jasmine.empty>';
  };

  return Empty;
};

getJasmineRequireObj().Falsy = function(j$) {
  function Falsy() {}

  Falsy.prototype.asymmetricMatch = function(other) {
    return !other;
  };

  Falsy.prototype.jasmineToString = function() {
    return '<jasmine.falsy>';
  };

  return Falsy;
};

getJasmineRequireObj().MapContaining = function(j$) {
  function MapContaining(sample) {
    if (!j$.isMap(sample)) {
      throw new Error(
        'You must provide a map to `mapContaining`, not ' +
          j$.basicPrettyPrinter_(sample)
      );
    }

    this.sample = sample;
  }

  MapContaining.prototype.asymmetricMatch = function(other, matchersUtil) {
    if (!j$.isMap(other)) return false;

    for (const [key, value] of this.sample) {
      // for each key/value pair in `sample`
      // there should be at least one pair in `other` whose key and value both match
      var hasMatch = false;
      for (const [oKey, oValue] of other) {
        if (
          matchersUtil.equals(oKey, key) &&
          matchersUtil.equals(oValue, value)
        ) {
          hasMatch = true;
          break;
        }
      }

      if (!hasMatch) {
        return false;
      }
    }

    return true;
  };

  MapContaining.prototype.jasmineToString = function(pp) {
    return '<jasmine.mapContaining(' + pp(this.sample) + ')>';
  };

  return MapContaining;
};

getJasmineRequireObj().NotEmpty = function(j$) {
  function NotEmpty() {}

  NotEmpty.prototype.asymmetricMatch = function(other) {
    if (j$.isString_(other) || j$.isArray_(other) || j$.isTypedArray_(other)) {
      return other.length !== 0;
    }

    if (j$.isMap(other) || j$.isSet(other)) {
      return other.size !== 0;
    }

    if (j$.isObject_(other)) {
      return Object.keys(other).length !== 0;
    }

    return false;
  };

  NotEmpty.prototype.jasmineToString = function() {
    return '<jasmine.notEmpty>';
  };

  return NotEmpty;
};

getJasmineRequireObj().ObjectContaining = function(j$) {
  function ObjectContaining(sample) {
    this.sample = sample;
  }

  function hasProperty(obj, property) {
    if (!obj || typeof obj !== 'object') {
      return false;
    }

    if (Object.prototype.hasOwnProperty.call(obj, property)) {
      return true;
    }

    return hasProperty(Object.getPrototypeOf(obj), property);
  }

  ObjectContaining.prototype.asymmetricMatch = function(other, matchersUtil) {
    if (typeof this.sample !== 'object') {
      throw new Error(
        "You must provide an object to objectContaining, not '" +
          this.sample +
          "'."
      );
    }
    if (typeof other !== 'object') {
      return false;
    }

    for (var property in this.sample) {
      if (
        !hasProperty(other, property) ||
        !matchersUtil.equals(this.sample[property], other[property])
      ) {
        return false;
      }
    }

    return true;
  };

  ObjectContaining.prototype.valuesForDiff_ = function(other, pp) {
    if (!j$.isObject_(other)) {
      return {
        self: this.jasmineToString(pp),
        other: other
      };
    }

    var filteredOther = {};
    Object.keys(this.sample).forEach(function(k) {
      // eq short-circuits comparison of objects that have different key sets,
      // so include all keys even if undefined.
      filteredOther[k] = other[k];
    });

    return {
      self: this.sample,
      other: filteredOther
    };
  };

  ObjectContaining.prototype.jasmineToString = function(pp) {
    return '<jasmine.objectContaining(' + pp(this.sample) + ')>';
  };

  return ObjectContaining;
};

getJasmineRequireObj().SetContaining = function(j$) {
  function SetContaining(sample) {
    if (!j$.isSet(sample)) {
      throw new Error(
        'You must provide a set to `setContaining`, not ' +
          j$.basicPrettyPrinter_(sample)
      );
    }

    this.sample = sample;
  }

  SetContaining.prototype.asymmetricMatch = function(other, matchersUtil) {
    if (!j$.isSet(other)) return false;

    for (const item of this.sample) {
      // for each item in `sample` there should be at least one matching item in `other`
      // (not using `matchersUtil.contains` because it compares set members by reference,
      // not by deep value equality)
      var hasMatch = false;
      for (const oItem of other) {
        if (matchersUtil.equals(oItem, item)) {
          hasMatch = true;
          break;
        }
      }

      if (!hasMatch) {
        return false;
      }
    }

    return true;
  };

  SetContaining.prototype.jasmineToString = function(pp) {
    return '<jasmine.setContaining(' + pp(this.sample) + ')>';
  };

  return SetContaining;
};

getJasmineRequireObj().StringContaining = function(j$) {
  function StringContaining(expected) {
    if (!j$.isString_(expected)) {
      throw new Error('Expected is not a String');
    }

    this.expected = expected;
  }

  StringContaining.prototype.asymmetricMatch = function(other) {
    if (!j$.isString_(other)) {
      // Arrays, etc. don't match no matter what their indexOf returns.
      return false;
    }

    return other.indexOf(this.expected) !== -1;
  };

  StringContaining.prototype.jasmineToString = function() {
    return '<jasmine.stringContaining("' + this.expected + '")>';
  };

  return StringContaining;
};

getJasmineRequireObj().StringMatching = function(j$) {
  function StringMatching(expected) {
    if (!j$.isString_(expected) && !j$.isA_('RegExp', expected)) {
      throw new Error('Expected is not a String or a RegExp');
    }

    this.regexp = new RegExp(expected);
  }

  StringMatching.prototype.asymmetricMatch = function(other) {
    return this.regexp.test(other);
  };

  StringMatching.prototype.jasmineToString = function() {
    return '<jasmine.stringMatching(' + this.regexp + ')>';
  };

  return StringMatching;
};

getJasmineRequireObj().Truthy = function(j$) {
  function Truthy() {}

  Truthy.prototype.asymmetricMatch = function(other) {
    return !!other;
  };

  Truthy.prototype.jasmineToString = function() {
    return '<jasmine.truthy>';
  };

  return Truthy;
};

getJasmineRequireObj().CallTracker = function(j$) {
  /**
   * @namespace Spy#calls
   * @since 2.0.0
   */
  function CallTracker() {
    var calls = [];
    var opts = {};

    this.track = function(context) {
      if (opts.cloneArgs) {
        context.args = j$.util.cloneArgs(context.args);
      }
      calls.push(context);
    };

    /**
     * Check whether this spy has been invoked.
     * @name Spy#calls#any
     * @since 2.0.0
     * @function
     * @return {Boolean}
     */
    this.any = function() {
      return !!calls.length;
    };

    /**
     * Get the number of invocations of this spy.
     * @name Spy#calls#count
     * @since 2.0.0
     * @function
     * @return {Integer}
     */
    this.count = function() {
      return calls.length;
    };

    /**
     * Get the arguments that were passed to a specific invocation of this spy.
     * @name Spy#calls#argsFor
     * @since 2.0.0
     * @function
     * @param {Integer} index The 0-based invocation index.
     * @return {Array}
     */
    this.argsFor = function(index) {
      var call = calls[index];
      return call ? call.args : [];
    };

    /**
     * Get the "this" object that was passed to a specific invocation of this spy.
     * @name Spy#calls#thisFor
     * @since 3.8.0
     * @function
     * @param {Integer} index The 0-based invocation index.
     * @return {Object?}
     */
    this.thisFor = function(index) {
      var call = calls[index];
      return call ? call.object : undefined;
    };

    /**
     * Get the raw calls array for this spy.
     * @name Spy#calls#all
     * @since 2.0.0
     * @function
     * @return {Spy.callData[]}
     */
    this.all = function() {
      return calls;
    };

    /**
     * Get all of the arguments for each invocation of this spy in the order they were received.
     * @name Spy#calls#allArgs
     * @since 2.0.0
     * @function
     * @return {Array}
     */
    this.allArgs = function() {
      var callArgs = [];
      for (var i = 0; i < calls.length; i++) {
        callArgs.push(calls[i].args);
      }

      return callArgs;
    };

    /**
     * Get the first invocation of this spy.
     * @name Spy#calls#first
     * @since 2.0.0
     * @function
     * @return {ObjecSpy.callData}
     */
    this.first = function() {
      return calls[0];
    };

    /**
     * Get the most recent invocation of this spy.
     * @name Spy#calls#mostRecent
     * @since 2.0.0
     * @function
     * @return {ObjecSpy.callData}
     */
    this.mostRecent = function() {
      return calls[calls.length - 1];
    };

    /**
     * Reset this spy as if it has never been called.
     * @name Spy#calls#reset
     * @since 2.0.0
     * @function
     */
    this.reset = function() {
      calls = [];
    };

    /**
     * Set this spy to do a shallow clone of arguments passed to each invocation.
     * @name Spy#calls#saveArgumentsByValue
     * @since 2.5.0
     * @function
     */
    this.saveArgumentsByValue = function() {
      opts.cloneArgs = true;
    };
  }

  return CallTracker;
};

getJasmineRequireObj().clearStack = function(j$) {
  var maxInlineCallCount = 10;

  function messageChannelImpl(global, setTimeout) {
    var channel = new global.MessageChannel(),
      head = {},
      tail = head;

    var taskRunning = false;
    channel.port1.onmessage = function() {
      head = head.next;
      var task = head.task;
      delete head.task;

      if (taskRunning) {
        global.setTimeout(task, 0);
      } else {
        try {
          taskRunning = true;
          task();
        } finally {
          taskRunning = false;
        }
      }
    };

    var currentCallCount = 0;
    return function clearStack(fn) {
      currentCallCount++;

      if (currentCallCount < maxInlineCallCount) {
        tail = tail.next = { task: fn };
        channel.port2.postMessage(0);
      } else {
        currentCallCount = 0;
        setTimeout(fn);
      }
    };
  }

  function getClearStack(global) {
    var currentCallCount = 0;
    var realSetTimeout = global.setTimeout;
    var setTimeoutImpl = function clearStack(fn) {
      Function.prototype.apply.apply(realSetTimeout, [global, [fn, 0]]);
    };

    if (j$.isFunction_(global.setImmediate)) {
      var realSetImmediate = global.setImmediate;
      return function(fn) {
        currentCallCount++;

        if (currentCallCount < maxInlineCallCount) {
          realSetImmediate(fn);
        } else {
          currentCallCount = 0;

          setTimeoutImpl(fn);
        }
      };
    } else if (!j$.util.isUndefined(global.MessageChannel)) {
      return messageChannelImpl(global, setTimeoutImpl);
    } else {
      return setTimeoutImpl;
    }
  }

  return getClearStack;
};

getJasmineRequireObj().Clock = function() {
  /* global process */
  var NODE_JS =
    typeof process !== 'undefined' &&
    process.versions &&
    typeof process.versions.node === 'string';

  /**
   * @class Clock
   * @since 1.3.0
   * @classdesc Jasmine's mock clock is used when testing time dependent code.<br>
   * _Note:_ Do not construct this directly. You can get the current clock with
   * {@link jasmine.clock}.
   * @hideconstructor
   */
  function Clock(global, delayedFunctionSchedulerFactory, mockDate) {
    var self = this,
      realTimingFunctions = {
        setTimeout: global.setTimeout,
        clearTimeout: global.clearTimeout,
        setInterval: global.setInterval,
        clearInterval: global.clearInterval
      },
      fakeTimingFunctions = {
        setTimeout: setTimeout,
        clearTimeout: clearTimeout,
        setInterval: setInterval,
        clearInterval: clearInterval
      },
      installed = false,
      delayedFunctionScheduler,
      timer;

    self.FakeTimeout = FakeTimeout;

    /**
     * Install the mock clock over the built-in methods.
     * @name Clock#install
     * @since 2.0.0
     * @function
     * @return {Clock}
     */
    self.install = function() {
      if (!originalTimingFunctionsIntact()) {
        throw new Error(
          'Jasmine Clock was unable to install over custom global timer functions. Is the clock already installed?'
        );
      }
      replace(global, fakeTimingFunctions);
      timer = fakeTimingFunctions;
      delayedFunctionScheduler = delayedFunctionSchedulerFactory();
      installed = true;

      return self;
    };

    /**
     * Uninstall the mock clock, returning the built-in methods to their places.
     * @name Clock#uninstall
     * @since 2.0.0
     * @function
     */
    self.uninstall = function() {
      delayedFunctionScheduler = null;
      mockDate.uninstall();
      replace(global, realTimingFunctions);

      timer = realTimingFunctions;
      installed = false;
    };

    /**
     * Execute a function with a mocked Clock
     *
     * The clock will be {@link Clock#install|install}ed before the function is called and {@link Clock#uninstall|uninstall}ed in a `finally` after the function completes.
     * @name Clock#withMock
     * @since 2.3.0
     * @function
     * @param {Function} closure The function to be called.
     */
    self.withMock = function(closure) {
      this.install();
      try {
        closure();
      } finally {
        this.uninstall();
      }
    };

    /**
     * Instruct the installed Clock to also mock the date returned by `new Date()`
     * @name Clock#mockDate
     * @since 2.1.0
     * @function
     * @param {Date} [initialDate=now] The `Date` to provide.
     */
    self.mockDate = function(initialDate) {
      mockDate.install(initialDate);
    };

    self.setTimeout = function(fn, delay, params) {
      return Function.prototype.apply.apply(timer.setTimeout, [
        global,
        arguments
      ]);
    };

    self.setInterval = function(fn, delay, params) {
      return Function.prototype.apply.apply(timer.setInterval, [
        global,
        arguments
      ]);
    };

    self.clearTimeout = function(id) {
      return Function.prototype.call.apply(timer.clearTimeout, [global, id]);
    };

    self.clearInterval = function(id) {
      return Function.prototype.call.apply(timer.clearInterval, [global, id]);
    };

    /**
     * Tick the Clock forward, running any enqueued timeouts along the way
     * @name Clock#tick
     * @since 1.3.0
     * @function
     * @param {int} millis The number of milliseconds to tick.
     */
    self.tick = function(millis) {
      if (installed) {
        delayedFunctionScheduler.tick(millis, function(millis) {
          mockDate.tick(millis);
        });
      } else {
        throw new Error(
          'Mock clock is not installed, use jasmine.clock().install()'
        );
      }
    };

    return self;

    function originalTimingFunctionsIntact() {
      return (
        global.setTimeout === realTimingFunctions.setTimeout &&
        global.clearTimeout === realTimingFunctions.clearTimeout &&
        global.setInterval === realTimingFunctions.setInterval &&
        global.clearInterval === realTimingFunctions.clearInterval
      );
    }

    function replace(dest, source) {
      for (var prop in source) {
        dest[prop] = source[prop];
      }
    }

    function setTimeout(fn, delay) {
      if (!NODE_JS) {
        return delayedFunctionScheduler.scheduleFunction(
          fn,
          delay,
          argSlice(arguments, 2)
        );
      }

      var timeout = new FakeTimeout();

      delayedFunctionScheduler.scheduleFunction(
        fn,
        delay,
        argSlice(arguments, 2),
        false,
        timeout
      );

      return timeout;
    }

    function clearTimeout(id) {
      return delayedFunctionScheduler.removeFunctionWithId(id);
    }

    function setInterval(fn, interval) {
      if (!NODE_JS) {
        return delayedFunctionScheduler.scheduleFunction(
          fn,
          interval,
          argSlice(arguments, 2),
          true
        );
      }

      var timeout = new FakeTimeout();

      delayedFunctionScheduler.scheduleFunction(
        fn,
        interval,
        argSlice(arguments, 2),
        true,
        timeout
      );

      return timeout;
    }

    function clearInterval(id) {
      return delayedFunctionScheduler.removeFunctionWithId(id);
    }

    function argSlice(argsObj, n) {
      return Array.prototype.slice.call(argsObj, n);
    }
  }

  /**
   * Mocks Node.js Timeout class
   */
  function FakeTimeout() {}

  FakeTimeout.prototype.ref = function() {
    return this;
  };

  FakeTimeout.prototype.unref = function() {
    return this;
  };

  return Clock;
};

getJasmineRequireObj().CompleteOnFirstErrorSkipPolicy = function(j$) {
  function CompleteOnFirstErrorSkipPolicy(queueableFns) {
    this.queueableFns_ = queueableFns;
    this.erroredFnIx_ = null;
  }

  CompleteOnFirstErrorSkipPolicy.prototype.skipTo = function(lastRanFnIx) {
    let i;

    for (
      i = lastRanFnIx + 1;
      i < this.queueableFns_.length && this.shouldSkip_(i);
      i++
    ) {}
    return i;
  };

  CompleteOnFirstErrorSkipPolicy.prototype.fnErrored = function(fnIx) {
    this.erroredFnIx_ = fnIx;
  };

  CompleteOnFirstErrorSkipPolicy.prototype.shouldSkip_ = function(fnIx) {
    if (this.erroredFnIx_ === null) {
      return false;
    }

    const fn = this.queueableFns_[fnIx];
    const candidateSuite = fn.suite;
    const errorSuite = this.queueableFns_[this.erroredFnIx_].suite;
    const wasCleanupFn =
      fn.type === 'afterEach' ||
      fn.type === 'afterAll' ||
      fn.type === 'specCleanup';
    return (
      !wasCleanupFn ||
      (candidateSuite && isDescendent(candidateSuite, errorSuite))
    );
  };

  function isDescendent(candidate, ancestor) {
    if (!candidate.parentSuite) {
      return false;
    } else if (candidate.parentSuite === ancestor) {
      return true;
    } else {
      return isDescendent(candidate.parentSuite, ancestor);
    }
  }

  return CompleteOnFirstErrorSkipPolicy;
};

getJasmineRequireObj().DelayedFunctionScheduler = function(j$) {
  function DelayedFunctionScheduler() {
    var self = this;
    var scheduledLookup = [];
    var scheduledFunctions = {};
    var currentTime = 0;
    var delayedFnCount = 0;
    var deletedKeys = [];

    self.tick = function(millis, tickDate) {
      millis = millis || 0;
      var endTime = currentTime + millis;

      runScheduledFunctions(endTime, tickDate);
    };

    self.scheduleFunction = function(
      funcToCall,
      millis,
      params,
      recurring,
      timeoutKey,
      runAtMillis
    ) {
      var f;
      if (typeof funcToCall === 'string') {
        /* jshint evil: true */
        f = function() {
          return eval(funcToCall);
        };
        /* jshint evil: false */
      } else {
        f = funcToCall;
      }

      millis = millis || 0;
      timeoutKey = timeoutKey || ++delayedFnCount;
      runAtMillis = runAtMillis || currentTime + millis;

      var funcToSchedule = {
        runAtMillis: runAtMillis,
        funcToCall: f,
        recurring: recurring,
        params: params,
        timeoutKey: timeoutKey,
        millis: millis
      };

      if (runAtMillis in scheduledFunctions) {
        scheduledFunctions[runAtMillis].push(funcToSchedule);
      } else {
        scheduledFunctions[runAtMillis] = [funcToSchedule];
        scheduledLookup.push(runAtMillis);
        scheduledLookup.sort(function(a, b) {
          return a - b;
        });
      }

      return timeoutKey;
    };

    self.removeFunctionWithId = function(timeoutKey) {
      deletedKeys.push(timeoutKey);

      for (var runAtMillis in scheduledFunctions) {
        var funcs = scheduledFunctions[runAtMillis];
        var i = indexOfFirstToPass(funcs, function(func) {
          return func.timeoutKey === timeoutKey;
        });

        if (i > -1) {
          if (funcs.length === 1) {
            delete scheduledFunctions[runAtMillis];
            deleteFromLookup(runAtMillis);
          } else {
            funcs.splice(i, 1);
          }

          // intervals get rescheduled when executed, so there's never more
          // than a single scheduled function with a given timeoutKey
          break;
        }
      }
    };

    return self;

    function indexOfFirstToPass(array, testFn) {
      var index = -1;

      for (var i = 0; i < array.length; ++i) {
        if (testFn(array[i])) {
          index = i;
          break;
        }
      }

      return index;
    }

    function deleteFromLookup(key) {
      var value = Number(key);
      var i = indexOfFirstToPass(scheduledLookup, function(millis) {
        return millis === value;
      });

      if (i > -1) {
        scheduledLookup.splice(i, 1);
      }
    }

    function reschedule(scheduledFn) {
      self.scheduleFunction(
        scheduledFn.funcToCall,
        scheduledFn.millis,
        scheduledFn.params,
        true,
        scheduledFn.timeoutKey,
        scheduledFn.runAtMillis + scheduledFn.millis
      );
    }

    function forEachFunction(funcsToRun, callback) {
      for (var i = 0; i < funcsToRun.length; ++i) {
        callback(funcsToRun[i]);
      }
    }

    function runScheduledFunctions(endTime, tickDate) {
      tickDate = tickDate || function() {};
      if (scheduledLookup.length === 0 || scheduledLookup[0] > endTime) {
        if (endTime >= currentTime) {
          tickDate(endTime - currentTime);
          currentTime = endTime;
        }
        return;
      }

      do {
        deletedKeys = [];
        var newCurrentTime = scheduledLookup.shift();
        if (newCurrentTime >= currentTime) {
          tickDate(newCurrentTime - currentTime);
          currentTime = newCurrentTime;
        }

        var funcsToRun = scheduledFunctions[currentTime];

        delete scheduledFunctions[currentTime];

        forEachFunction(funcsToRun, function(funcToRun) {
          if (funcToRun.recurring) {
            reschedule(funcToRun);
          }
        });

        forEachFunction(funcsToRun, function(funcToRun) {
          if (j$.util.arrayContains(deletedKeys, funcToRun.timeoutKey)) {
            // skip a timeoutKey deleted whilst we were running
            return;
          }
          funcToRun.funcToCall.apply(null, funcToRun.params || []);
        });
        deletedKeys = [];
      } while (
        scheduledLookup.length > 0 &&
        // checking first if we're out of time prevents setTimeout(0)
        // scheduled in a funcToRun from forcing an extra iteration
        currentTime !== endTime &&
        scheduledLookup[0] <= endTime
      );

      // ran out of functions to call, but still time left on the clock
      if (endTime >= currentTime) {
        tickDate(endTime - currentTime);
        currentTime = endTime;
      }
    }
  }

  return DelayedFunctionScheduler;
};

getJasmineRequireObj().Deprecator = function(j$) {
  function Deprecator(topSuite) {
    this.topSuite_ = topSuite;
    this.verbose_ = false;
    this.toSuppress_ = [];
  }

  var verboseNote =
    'Note: This message will be shown only once. Set the verboseDeprecations ' +
    'config property to true to see every occurrence.';

  Deprecator.prototype.verboseDeprecations = function(enabled) {
    this.verbose_ = enabled;
  };

  // runnable is a spec or a suite.
  // deprecation is a string or an Error.
  // See Env#deprecated for a description of the options argument.
  Deprecator.prototype.addDeprecationWarning = function(
    runnable,
    deprecation,
    options
  ) {
    options = options || {};

    if (!this.verbose_ && !j$.isError_(deprecation)) {
      if (this.toSuppress_.indexOf(deprecation) !== -1) {
        return;
      }
      this.toSuppress_.push(deprecation);
    }

    this.log_(runnable, deprecation, options);
    this.report_(runnable, deprecation, options);
  };

  Deprecator.prototype.log_ = function(runnable, deprecation, options) {
    var context;

    if (j$.isError_(deprecation)) {
      console.error(deprecation);
      return;
    }

    if (runnable === this.topSuite_ || options.ignoreRunnable) {
      context = '';
    } else if (runnable.children) {
      context = ' (in suite: ' + runnable.getFullName() + ')';
    } else {
      context = ' (in spec: ' + runnable.getFullName() + ')';
    }

    if (!options.omitStackTrace) {
      context += '\n' + this.stackTrace_();
    }

    if (!this.verbose_) {
      context += '\n' + verboseNote;
    }

    console.error('DEPRECATION: ' + deprecation + context);
  };

  Deprecator.prototype.stackTrace_ = function() {
    var formatter = new j$.ExceptionFormatter();
    return formatter.stack(j$.util.errorWithStack()).replace(/^Error\n/m, '');
  };

  Deprecator.prototype.report_ = function(runnable, deprecation, options) {
    if (options.ignoreRunnable) {
      runnable = this.topSuite_;
    }

    if (j$.isError_(deprecation)) {
      runnable.addDeprecationWarning(deprecation);
      return;
    }

    if (!this.verbose_) {
      deprecation += '\n' + verboseNote;
    }

    runnable.addDeprecationWarning({
      message: deprecation,
      omitStackTrace: options.omitStackTrace || false
    });
  };

  return Deprecator;
};

getJasmineRequireObj().errors = function() {
  function ExpectationFailed() {}

  ExpectationFailed.prototype = new Error();
  ExpectationFailed.prototype.constructor = ExpectationFailed;

  return {
    ExpectationFailed: ExpectationFailed
  };
};

getJasmineRequireObj().ExceptionFormatter = function(j$) {
  var ignoredProperties = [
    'name',
    'message',
    'stack',
    'fileName',
    'sourceURL',
    'line',
    'lineNumber',
    'column',
    'description',
    'jasmineMessage'
  ];

  function ExceptionFormatter(options) {
    var jasmineFile = (options && options.jasmineFile) || j$.util.jasmineFile();
    this.message = function(error) {
      var message = '';

      if (error.jasmineMessage) {
        message += error.jasmineMessage;
      } else if (error.name && error.message) {
        message += error.name + ': ' + error.message;
      } else if (error.message) {
        message += error.message;
      } else {
        message += error.toString() + ' thrown';
      }

      if (error.fileName || error.sourceURL) {
        message += ' in ' + (error.fileName || error.sourceURL);
      }

      if (error.line || error.lineNumber) {
        message += ' (line ' + (error.line || error.lineNumber) + ')';
      }

      return message;
    };

    this.stack = function(error, { omitMessage } = {}) {
      if (!error || !error.stack) {
        return null;
      }

      var stackTrace = new j$.StackTrace(error);
      var lines = filterJasmine(stackTrace);
      var result = '';

      if (stackTrace.message && !omitMessage) {
        lines.unshift(stackTrace.message);
      }

      result += formatProperties(error);
      result += lines.join('\n');

      return result;
    };

    function filterJasmine(stackTrace) {
      var result = [],
        jasmineMarker =
          stackTrace.style === 'webkit' ? '<Jasmine>' : '    at <Jasmine>';

      stackTrace.frames.forEach(function(frame) {
        if (frame.file !== jasmineFile) {
          result.push(frame.raw);
        } else if (result[result.length - 1] !== jasmineMarker) {
          result.push(jasmineMarker);
        }
      });

      return result;
    }

    function formatProperties(error) {
      if (!(error instanceof Object)) {
        return;
      }

      var result = {};
      var empty = true;

      for (var prop in error) {
        if (j$.util.arrayContains(ignoredProperties, prop)) {
          continue;
        }
        result[prop] = error[prop];
        empty = false;
      }

      if (!empty) {
        return 'error properties: ' + j$.basicPrettyPrinter_(result) + '\n';
      }

      return '';
    }
  }

  return ExceptionFormatter;
};

getJasmineRequireObj().Expectation = function(j$) {
  /**
   * Matchers that come with Jasmine out of the box.
   * @namespace matchers
   */
  function Expectation(options) {
    this.expector = new j$.Expector(options);

    var customMatchers = options.customMatchers || {};
    for (var matcherName in customMatchers) {
      this[matcherName] = wrapSyncCompare(
        matcherName,
        customMatchers[matcherName]
      );
    }
  }

  /**
   * Add some context for an {@link expect}
   * @function
   * @name matchers#withContext
   * @since 3.3.0
   * @param {String} message - Additional context to show when the matcher fails
   * @return {matchers}
   */
  Expectation.prototype.withContext = function withContext(message) {
    return addFilter(this, new ContextAddingFilter(message));
  };

  /**
   * Invert the matcher following this {@link expect}
   * @member
   * @name matchers#not
   * @since 1.3.0
   * @type {matchers}
   * @example
   * expect(something).not.toBe(true);
   */
  Object.defineProperty(Expectation.prototype, 'not', {
    get: function() {
      return addFilter(this, syncNegatingFilter);
    }
  });

  /**
   * Asynchronous matchers that operate on an actual value which is a promise,
   * and return a promise.
   *
   * Most async matchers will wait indefinitely for the promise to be resolved
   * or rejected, resulting in a spec timeout if that never happens. If you
   * expect that the promise will already be resolved or rejected at the time
   * the matcher is called, you can use the {@link async-matchers#already}
   * modifier to get a faster failure with a more helpful message.
   *
   * Note: Specs must await the result of each async matcher, return the
   * promise returned by the matcher, or return a promise that's derived from
   * the one returned by the matcher. Otherwise the matcher will not be
   * evaluated before the spec completes.
   *
   * @example
   * // Good
   * await expectAsync(aPromise).toBeResolved();
   * @example
   * // Good
   * return expectAsync(aPromise).toBeResolved();
   * @example
   * // Good
   * return expectAsync(aPromise).toBeResolved()
   *  .then(function() {
   *    // more spec code
   *  });
   * @example
   * // Bad
   * expectAsync(aPromise).toBeResolved();
   * @namespace async-matchers
   */
  function AsyncExpectation(options) {
    this.expector = new j$.Expector(options);

    var customAsyncMatchers = options.customAsyncMatchers || {};
    for (var matcherName in customAsyncMatchers) {
      this[matcherName] = wrapAsyncCompare(
        matcherName,
        customAsyncMatchers[matcherName]
      );
    }
  }

  /**
   * Add some context for an {@link expectAsync}
   * @function
   * @name async-matchers#withContext
   * @since 3.3.0
   * @param {String} message - Additional context to show when the async matcher fails
   * @return {async-matchers}
   */
  AsyncExpectation.prototype.withContext = function withContext(message) {
    return addFilter(this, new ContextAddingFilter(message));
  };

  /**
   * Invert the matcher following this {@link expectAsync}
   * @member
   * @name async-matchers#not
   * @type {async-matchers}
   * @example
   * await expectAsync(myPromise).not.toBeResolved();
   * @example
   * return expectAsync(myPromise).not.toBeResolved();
   */
  Object.defineProperty(AsyncExpectation.prototype, 'not', {
    get: function() {
      return addFilter(this, asyncNegatingFilter);
    }
  });

  /**
   * Fail as soon as possible if the actual is pending.
   * Otherwise evaluate the matcher.
   * @member
   * @name async-matchers#already
   * @since 3.8.0
   * @type {async-matchers}
   * @example
   * await expectAsync(myPromise).already.toBeResolved();
   * @example
   * return expectAsync(myPromise).already.toBeResolved();
   */
  Object.defineProperty(AsyncExpectation.prototype, 'already', {
    get: function() {
      return addFilter(this, expectSettledPromiseFilter);
    }
  });

  function wrapSyncCompare(name, matcherFactory) {
    return function() {
      var result = this.expector.compare(name, matcherFactory, arguments);
      this.expector.processResult(result);
    };
  }

  function wrapAsyncCompare(name, matcherFactory) {
    return function() {
      var self = this;

      // Capture the call stack here, before we go async, so that it will contain
      // frames that are relevant to the user instead of just parts of Jasmine.
      var errorForStack = j$.util.errorWithStack();

      return this.expector
        .compare(name, matcherFactory, arguments)
        .then(function(result) {
          self.expector.processResult(result, errorForStack);
        });
    };
  }

  function addCoreMatchers(prototype, matchers, wrapper) {
    for (var matcherName in matchers) {
      var matcher = matchers[matcherName];
      prototype[matcherName] = wrapper(matcherName, matcher);
    }
  }

  function addFilter(source, filter) {
    var result = Object.create(source);
    result.expector = source.expector.addFilter(filter);
    return result;
  }

  function negatedFailureMessage(result, matcherName, args, matchersUtil) {
    if (result.message) {
      if (j$.isFunction_(result.message)) {
        return result.message();
      } else {
        return result.message;
      }
    }

    args = args.slice();
    args.unshift(true);
    args.unshift(matcherName);
    return matchersUtil.buildFailureMessage.apply(matchersUtil, args);
  }

  function negate(result) {
    result.pass = !result.pass;
    return result;
  }

  var syncNegatingFilter = {
    selectComparisonFunc: function(matcher) {
      function defaultNegativeCompare() {
        return negate(matcher.compare.apply(null, arguments));
      }

      return matcher.negativeCompare || defaultNegativeCompare;
    },
    buildFailureMessage: negatedFailureMessage
  };

  var asyncNegatingFilter = {
    selectComparisonFunc: function(matcher) {
      function defaultNegativeCompare() {
        return matcher.compare.apply(this, arguments).then(negate);
      }

      return matcher.negativeCompare || defaultNegativeCompare;
    },
    buildFailureMessage: negatedFailureMessage
  };

  var expectSettledPromiseFilter = {
    selectComparisonFunc: function(matcher) {
      return function(actual) {
        var matcherArgs = arguments;

        return j$.isPending_(actual).then(function(isPending) {
          if (isPending) {
            return {
              pass: false,
              message:
                'Expected a promise to be settled (via ' +
                'expectAsync(...).already) but it was pending.'
            };
          } else {
            return matcher.compare.apply(null, matcherArgs);
          }
        });
      };
    }
  };

  function ContextAddingFilter(message) {
    this.message = message;
  }

  ContextAddingFilter.prototype.modifyFailureMessage = function(msg) {
    var nl = msg.indexOf('\n');

    if (nl === -1) {
      return this.message + ': ' + msg;
    } else {
      return this.message + ':\n' + indent(msg);
    }
  };

  function indent(s) {
    return s.replace(/^/gm, '    ');
  }

  return {
    factory: function(options) {
      return new Expectation(options || {});
    },
    addCoreMatchers: function(matchers) {
      addCoreMatchers(Expectation.prototype, matchers, wrapSyncCompare);
    },
    asyncFactory: function(options) {
      return new AsyncExpectation(options || {});
    },
    addAsyncCoreMatchers: function(matchers) {
      addCoreMatchers(AsyncExpectation.prototype, matchers, wrapAsyncCompare);
    }
  };
};

getJasmineRequireObj().ExpectationFilterChain = function() {
  function ExpectationFilterChain(maybeFilter, prev) {
    this.filter_ = maybeFilter;
    this.prev_ = prev;
  }

  ExpectationFilterChain.prototype.addFilter = function(filter) {
    return new ExpectationFilterChain(filter, this);
  };

  ExpectationFilterChain.prototype.selectComparisonFunc = function(matcher) {
    return this.callFirst_('selectComparisonFunc', arguments).result;
  };

  ExpectationFilterChain.prototype.buildFailureMessage = function(
    result,
    matcherName,
    args,
    matchersUtil
  ) {
    return this.callFirst_('buildFailureMessage', arguments).result;
  };

  ExpectationFilterChain.prototype.modifyFailureMessage = function(msg) {
    var result = this.callFirst_('modifyFailureMessage', arguments).result;
    return result || msg;
  };

  ExpectationFilterChain.prototype.callFirst_ = function(fname, args) {
    var prevResult;

    if (this.prev_) {
      prevResult = this.prev_.callFirst_(fname, args);

      if (prevResult.found) {
        return prevResult;
      }
    }

    if (this.filter_ && this.filter_[fname]) {
      return {
        found: true,
        result: this.filter_[fname].apply(this.filter_, args)
      };
    }

    return { found: false };
  };

  return ExpectationFilterChain;
};

//TODO: expectation result may make more sense as a presentation of an expectation.
getJasmineRequireObj().buildExpectationResult = function(j$) {
  function buildExpectationResult(options) {
    var messageFormatter = options.messageFormatter || function() {},
      stackFormatter = options.stackFormatter || function() {};

    /**
     * @typedef Expectation
     * @property {String} matcherName - The name of the matcher that was executed for this expectation.
     * @property {String} message - The failure message for the expectation.
     * @property {String} stack - The stack trace for the failure if available.
     * @property {Boolean} passed - Whether the expectation passed or failed.
     * @property {Object} expected - If the expectation failed, what was the expected value.
     * @property {Object} actual - If the expectation failed, what actual value was produced.
     * @property {String|undefined} globalErrorType - The type of an error that
     * is reported on the top suite. Valid values are undefined, "afterAll",
     * "load", "lateExpectation", and "lateError".
     */
    var result = {
      matcherName: options.matcherName,
      message: message(),
      stack: options.omitStackTrace ? '' : stack(),
      passed: options.passed
    };

    if (!result.passed) {
      result.expected = options.expected;
      result.actual = options.actual;

      if (options.error && !j$.isString_(options.error)) {
        if ('code' in options.error) {
          result.code = options.error.code;
        }

        if (
          options.error.code === 'ERR_ASSERTION' &&
          options.expected === '' &&
          options.actual === ''
        ) {
          result.expected = options.error.expected;
          result.actual = options.error.actual;
          result.matcherName = 'assert ' + options.error.operator;
        }
      }
    }

    return result;

    function message() {
      if (options.passed) {
        return 'Passed.';
      } else if (options.message) {
        return options.message;
      } else if (options.error) {
        return messageFormatter(options.error);
      }
      return '';
    }

    function stack() {
      if (options.passed) {
        return '';
      }

      var error = options.error;
      if (!error) {
        if (options.errorForStack) {
          error = options.errorForStack;
        } else if (options.stack) {
          error = options;
        } else {
          try {
            throw new Error(message());
          } catch (e) {
            error = e;
          }
        }
      }
      // Omit the message from the stack trace because it will be
      // included elsewhere.
      return stackFormatter(error, { omitMessage: true });
    }
  }

  return buildExpectationResult;
};

getJasmineRequireObj().Expector = function(j$) {
  function Expector(options) {
    this.matchersUtil = options.matchersUtil || {
      buildFailureMessage: function() {}
    };
    this.actual = options.actual;
    this.addExpectationResult = options.addExpectationResult || function() {};
    this.filters = new j$.ExpectationFilterChain();
  }

  Expector.prototype.instantiateMatcher = function(
    matcherName,
    matcherFactory,
    args
  ) {
    this.matcherName = matcherName;
    this.args = Array.prototype.slice.call(args, 0);
    this.expected = this.args.slice(0);

    this.args.unshift(this.actual);

    var matcher = matcherFactory(this.matchersUtil);

    var comparisonFunc = this.filters.selectComparisonFunc(matcher);
    return comparisonFunc || matcher.compare;
  };

  Expector.prototype.buildMessage = function(result) {
    var self = this;

    if (result.pass) {
      return '';
    }

    var msg = this.filters.buildFailureMessage(
      result,
      this.matcherName,
      this.args,
      this.matchersUtil,
      defaultMessage
    );
    return this.filters.modifyFailureMessage(msg || defaultMessage());

    function defaultMessage() {
      if (!result.message) {
        var args = self.args.slice();
        args.unshift(false);
        args.unshift(self.matcherName);
        return self.matchersUtil.buildFailureMessage.apply(
          self.matchersUtil,
          args
        );
      } else if (j$.isFunction_(result.message)) {
        return result.message();
      } else {
        return result.message;
      }
    }
  };

  Expector.prototype.compare = function(matcherName, matcherFactory, args) {
    var matcherCompare = this.instantiateMatcher(
      matcherName,
      matcherFactory,
      args
    );
    return matcherCompare.apply(null, this.args);
  };

  Expector.prototype.addFilter = function(filter) {
    var result = Object.create(this);
    result.filters = this.filters.addFilter(filter);
    return result;
  };

  Expector.prototype.processResult = function(result, errorForStack) {
    var message = this.buildMessage(result);

    if (this.expected.length === 1) {
      this.expected = this.expected[0];
    }

    this.addExpectationResult(result.pass, {
      matcherName: this.matcherName,
      passed: result.pass,
      message: message,
      error: errorForStack ? undefined : result.error,
      errorForStack: errorForStack || undefined,
      actual: this.actual,
      expected: this.expected // TODO: this may need to be arrayified/sliced
    });
  };

  return Expector;
};

getJasmineRequireObj().formatErrorMsg = function() {
  function generateErrorMsg(domain, usage) {
    var usageDefinition = usage ? '\nUsage: ' + usage : '';

    return function errorMsg(msg) {
      return domain + ' : ' + msg + usageDefinition;
    };
  }

  return generateErrorMsg;
};

getJasmineRequireObj().GlobalErrors = function(j$) {
  function GlobalErrors(global) {
    var handlers = [];
    global = global || j$.getGlobal();

    var onerror = function onerror() {
      var handler = handlers[handlers.length - 1];

      if (handler) {
        handler.apply(null, Array.prototype.slice.call(arguments, 0));
      } else {
        throw arguments[0];
      }
    };

    this.originalHandlers = {};
    this.jasmineHandlers = {};
    this.installOne_ = function installOne_(errorType, jasmineMessage) {
      function taggedOnError(error) {
        var substituteMsg;

        if (j$.isError_(error)) {
          error.jasmineMessage = jasmineMessage + ': ' + error;
        } else {
          if (error) {
            substituteMsg = jasmineMessage + ': ' + error;
          } else {
            substituteMsg = jasmineMessage + ' with no error or message';
          }

          if (errorType === 'unhandledRejection') {
            substituteMsg +=
              '\n' +
              '(Tip: to get a useful stack trace, use ' +
              'Promise.reject(new Error(...)) instead of Promise.reject(' +
              (error ? '...' : '') +
              ').)';
          }

          error = new Error(substituteMsg);
        }

        var handler = handlers[handlers.length - 1];

        if (handler) {
          handler(error);
        } else {
          throw error;
        }
      }

      this.originalHandlers[errorType] = global.process.listeners(errorType);
      this.jasmineHandlers[errorType] = taggedOnError;

      global.process.removeAllListeners(errorType);
      global.process.on(errorType, taggedOnError);

      this.uninstall = function uninstall() {
        var errorTypes = Object.keys(this.originalHandlers);
        for (var iType = 0; iType < errorTypes.length; iType++) {
          var errorType = errorTypes[iType];
          global.process.removeListener(
            errorType,
            this.jasmineHandlers[errorType]
          );
          for (var i = 0; i < this.originalHandlers[errorType].length; i++) {
            global.process.on(errorType, this.originalHandlers[errorType][i]);
          }
          delete this.originalHandlers[errorType];
          delete this.jasmineHandlers[errorType];
        }
      };
    };

    this.install = function install() {
      if (
        global.process &&
        global.process.listeners &&
        j$.isFunction_(global.process.on)
      ) {
        this.installOne_('uncaughtException', 'Uncaught exception');
        this.installOne_('unhandledRejection', 'Unhandled promise rejection');
      } else {
        var originalHandler = global.onerror;
        global.onerror = onerror;

        var browserRejectionHandler = function browserRejectionHandler(event) {
          if (j$.isError_(event.reason)) {
            event.reason.jasmineMessage =
              'Unhandled promise rejection: ' + event.reason;
            global.onerror(event.reason);
          } else {
            global.onerror('Unhandled promise rejection: ' + event.reason);
          }
        };

        if (global.addEventListener) {
          global.addEventListener(
            'unhandledrejection',
            browserRejectionHandler
          );
        }

        this.uninstall = function uninstall() {
          global.onerror = originalHandler;
          if (global.removeEventListener) {
            global.removeEventListener(
              'unhandledrejection',
              browserRejectionHandler
            );
          }
        };
      }
    };

    this.pushListener = function pushListener(listener) {
      handlers.push(listener);
    };

    this.popListener = function popListener(listener) {
      if (!listener) {
        throw new Error('popListener expects a listener');
      }

      handlers.pop();
    };
  }

  return GlobalErrors;
};

getJasmineRequireObj().toBePending = function(j$) {
  /**
   * Expect a promise to be pending, i.e. the promise is neither resolved nor rejected.
   * @function
   * @async
   * @name async-matchers#toBePending
   * @since 3.6
   * @example
   * await expectAsync(aPromise).toBePending();
   */
  return function toBePending() {
    return {
      compare: function(actual) {
        if (!j$.isPromiseLike(actual)) {
          throw new Error('Expected toBePending to be called on a promise.');
        }
        var want = {};
        return Promise.race([actual, Promise.resolve(want)]).then(
          function(got) {
            return { pass: want === got };
          },
          function() {
            return { pass: false };
          }
        );
      }
    };
  };
};

getJasmineRequireObj().toBeRejected = function(j$) {
  /**
   * Expect a promise to be rejected.
   * @function
   * @async
   * @name async-matchers#toBeRejected
   * @since 3.1.0
   * @example
   * await expectAsync(aPromise).toBeRejected();
   * @example
   * return expectAsync(aPromise).toBeRejected();
   */
  return function toBeRejected() {
    return {
      compare: function(actual) {
        if (!j$.isPromiseLike(actual)) {
          throw new Error('Expected toBeRejected to be called on a promise.');
        }
        return actual.then(
          function() {
            return { pass: false };
          },
          function() {
            return { pass: true };
          }
        );
      }
    };
  };
};

getJasmineRequireObj().toBeRejectedWith = function(j$) {
  /**
   * Expect a promise to be rejected with a value equal to the expected, using deep equality comparison.
   * @function
   * @async
   * @name async-matchers#toBeRejectedWith
   * @since 3.3.0
   * @param {Object} expected - Value that the promise is expected to be rejected with
   * @example
   * await expectAsync(aPromise).toBeRejectedWith({prop: 'value'});
   * @example
   * return expectAsync(aPromise).toBeRejectedWith({prop: 'value'});
   */
  return function toBeRejectedWith(matchersUtil) {
    return {
      compare: function(actualPromise, expectedValue) {
        if (!j$.isPromiseLike(actualPromise)) {
          throw new Error(
            'Expected toBeRejectedWith to be called on a promise.'
          );
        }

        function prefix(passed) {
          return (
            'Expected a promise ' +
            (passed ? 'not ' : '') +
            'to be rejected with ' +
            matchersUtil.pp(expectedValue)
          );
        }

        return actualPromise.then(
          function() {
            return {
              pass: false,
              message: prefix(false) + ' but it was resolved.'
            };
          },
          function(actualValue) {
            if (matchersUtil.equals(actualValue, expectedValue)) {
              return {
                pass: true,
                message: prefix(true) + '.'
              };
            } else {
              return {
                pass: false,
                message:
                  prefix(false) +
                  ' but it was rejected with ' +
                  matchersUtil.pp(actualValue) +
                  '.'
              };
            }
          }
        );
      }
    };
  };
};

getJasmineRequireObj().toBeRejectedWithError = function(j$) {
  /**
   * Expect a promise to be rejected with a value matched to the expected
   * @function
   * @async
   * @name async-matchers#toBeRejectedWithError
   * @since 3.5.0
   * @param {Error} [expected] - `Error` constructor the object that was thrown needs to be an instance of. If not provided, `Error` will be used.
   * @param {RegExp|String} [message] - The message that should be set on the thrown `Error`
   * @example
   * await expectAsync(aPromise).toBeRejectedWithError(MyCustomError, 'Error message');
   * await expectAsync(aPromise).toBeRejectedWithError(MyCustomError, /Error message/);
   * await expectAsync(aPromise).toBeRejectedWithError(MyCustomError);
   * await expectAsync(aPromise).toBeRejectedWithError('Error message');
   * return expectAsync(aPromise).toBeRejectedWithError(/Error message/);
   */
  return function toBeRejectedWithError(matchersUtil) {
    return {
      compare: function(actualPromise, arg1, arg2) {
        if (!j$.isPromiseLike(actualPromise)) {
          throw new Error(
            'Expected toBeRejectedWithError to be called on a promise.'
          );
        }

        var expected = getExpectedFromArgs(arg1, arg2, matchersUtil);

        return actualPromise.then(
          function() {
            return {
              pass: false,
              message: 'Expected a promise to be rejected but it was resolved.'
            };
          },
          function(actualValue) {
            return matchError(actualValue, expected, matchersUtil);
          }
        );
      }
    };
  };

  function matchError(actual, expected, matchersUtil) {
    if (!j$.isError_(actual)) {
      return fail(expected, 'rejected with ' + matchersUtil.pp(actual));
    }

    if (!(actual instanceof expected.error)) {
      return fail(
        expected,
        'rejected with type ' + j$.fnNameFor(actual.constructor)
      );
    }

    var actualMessage = actual.message;

    if (
      actualMessage === expected.message ||
      typeof expected.message === 'undefined'
    ) {
      return pass(expected);
    }

    if (
      expected.message instanceof RegExp &&
      expected.message.test(actualMessage)
    ) {
      return pass(expected);
    }

    return fail(expected, 'rejected with ' + matchersUtil.pp(actual));
  }

  function pass(expected) {
    return {
      pass: true,
      message:
        'Expected a promise not to be rejected with ' +
        expected.printValue +
        ', but it was.'
    };
  }

  function fail(expected, message) {
    return {
      pass: false,
      message:
        'Expected a promise to be rejected with ' +
        expected.printValue +
        ' but it was ' +
        message +
        '.'
    };
  }

  function getExpectedFromArgs(arg1, arg2, matchersUtil) {
    var error, message;

    if (isErrorConstructor(arg1)) {
      error = arg1;
      message = arg2;
    } else {
      error = Error;
      message = arg1;
    }

    return {
      error: error,
      message: message,
      printValue:
        j$.fnNameFor(error) +
        (typeof message === 'undefined' ? '' : ': ' + matchersUtil.pp(message))
    };
  }

  function isErrorConstructor(value) {
    return (
      typeof value === 'function' &&
      (value === Error || j$.isError_(value.prototype))
    );
  }
};

getJasmineRequireObj().toBeResolved = function(j$) {
  /**
   * Expect a promise to be resolved.
   * @function
   * @async
   * @name async-matchers#toBeResolved
   * @since 3.1.0
   * @example
   * await expectAsync(aPromise).toBeResolved();
   * @example
   * return expectAsync(aPromise).toBeResolved();
   */
  return function toBeResolved(matchersUtil) {
    return {
      compare: function(actual) {
        if (!j$.isPromiseLike(actual)) {
          throw new Error('Expected toBeResolved to be called on a promise.');
        }

        return actual.then(
          function() {
            return { pass: true };
          },
          function(e) {
            return {
              pass: false,
              message:
                'Expected a promise to be resolved but it was ' +
                'rejected with ' +
                matchersUtil.pp(e) +
                '.'
            };
          }
        );
      }
    };
  };
};

getJasmineRequireObj().toBeResolvedTo = function(j$) {
  /**
   * Expect a promise to be resolved to a value equal to the expected, using deep equality comparison.
   * @function
   * @async
   * @name async-matchers#toBeResolvedTo
   * @since 3.1.0
   * @param {Object} expected - Value that the promise is expected to resolve to
   * @example
   * await expectAsync(aPromise).toBeResolvedTo({prop: 'value'});
   * @example
   * return expectAsync(aPromise).toBeResolvedTo({prop: 'value'});
   */
  return function toBeResolvedTo(matchersUtil) {
    return {
      compare: function(actualPromise, expectedValue) {
        if (!j$.isPromiseLike(actualPromise)) {
          throw new Error('Expected toBeResolvedTo to be called on a promise.');
        }

        function prefix(passed) {
          return (
            'Expected a promise ' +
            (passed ? 'not ' : '') +
            'to be resolved to ' +
            matchersUtil.pp(expectedValue)
          );
        }

        return actualPromise.then(
          function(actualValue) {
            if (matchersUtil.equals(actualValue, expectedValue)) {
              return {
                pass: true,
                message: prefix(true) + '.'
              };
            } else {
              return {
                pass: false,
                message:
                  prefix(false) +
                  ' but it was resolved to ' +
                  matchersUtil.pp(actualValue) +
                  '.'
              };
            }
          },
          function(e) {
            return {
              pass: false,
              message:
                prefix(false) +
                ' but it was rejected with ' +
                matchersUtil.pp(e) +
                '.'
            };
          }
        );
      }
    };
  };
};

getJasmineRequireObj().DiffBuilder = function(j$) {
  return function DiffBuilder(config) {
    var prettyPrinter = (config || {}).prettyPrinter || j$.makePrettyPrinter(),
      mismatches = new j$.MismatchTree(),
      path = new j$.ObjectPath(),
      actualRoot = undefined,
      expectedRoot = undefined;

    return {
      setRoots: function(actual, expected) {
        actualRoot = actual;
        expectedRoot = expected;
      },

      recordMismatch: function(formatter) {
        mismatches.add(path, formatter);
      },

      getMessage: function() {
        var messages = [];

        mismatches.traverse(function(path, isLeaf, formatter) {
          var actualCustom,
            expectedCustom,
            useCustom,
            derefResult = dereferencePath(
              path,
              actualRoot,
              expectedRoot,
              prettyPrinter
            ),
            actual = derefResult.actual,
            expected = derefResult.expected;

          if (formatter) {
            messages.push(formatter(actual, expected, path, prettyPrinter));
            return true;
          }

          actualCustom = prettyPrinter.customFormat_(actual);
          expectedCustom = prettyPrinter.customFormat_(expected);
          useCustom = !(
            j$.util.isUndefined(actualCustom) &&
            j$.util.isUndefined(expectedCustom)
          );

          if (useCustom) {
            messages.push(
              wrapPrettyPrinted(actualCustom, expectedCustom, path)
            );
            return false; // don't recurse further
          }

          if (isLeaf) {
            messages.push(
              defaultFormatter(actual, expected, path, prettyPrinter)
            );
          }

          return true;
        });

        return messages.join('\n');
      },

      withPath: function(pathComponent, block) {
        var oldPath = path;
        path = path.add(pathComponent);
        block();
        path = oldPath;
      }
    };

    function defaultFormatter(actual, expected, path, prettyPrinter) {
      return wrapPrettyPrinted(
        prettyPrinter(actual),
        prettyPrinter(expected),
        path
      );
    }

    function wrapPrettyPrinted(actual, expected, path) {
      return (
        'Expected ' +
        path +
        (path.depth() ? ' = ' : '') +
        actual +
        ' to equal ' +
        expected +
        '.'
      );
    }
  };

  function dereferencePath(objectPath, actual, expected, pp) {
    function handleAsymmetricExpected() {
      if (
        j$.isAsymmetricEqualityTester_(expected) &&
        j$.isFunction_(expected.valuesForDiff_)
      ) {
        var asymmetricResult = expected.valuesForDiff_(actual, pp);
        expected = asymmetricResult.self;
        actual = asymmetricResult.other;
      }
    }

    var i;
    handleAsymmetricExpected();

    for (i = 0; i < objectPath.components.length; i++) {
      actual = actual[objectPath.components[i]];
      expected = expected[objectPath.components[i]];
      handleAsymmetricExpected();
    }

    return { actual: actual, expected: expected };
  }
};

getJasmineRequireObj().MatchersUtil = function(j$) {
  /**
   * @class MatchersUtil
   * @classdesc Utilities for use in implementing matchers.<br>
   * _Note:_ Do not construct this directly. Jasmine will construct one and
   * pass it to matchers and asymmetric equality testers.
   * @hideconstructor
   */
  function MatchersUtil(options) {
    options = options || {};
    this.customTesters_ = options.customTesters || [];
    /**
     * Formats a value for use in matcher failure messages and similar contexts,
     * taking into account the current set of custom value formatters.
     * @function
     * @name MatchersUtil#pp
     * @since 3.6.0
     * @param {*} value The value to pretty-print
     * @return {string} The pretty-printed value
     */
    this.pp = options.pp || function() {};
  }

  /**
   * Determines whether `haystack` contains `needle`, using the same comparison
   * logic as {@link MatchersUtil#equals}.
   * @function
   * @name MatchersUtil#contains
   * @since 2.0.0
   * @param {*} haystack The collection to search
   * @param {*} needle The value to search for
   * @returns {boolean} True if `needle` was found in `haystack`
   */
  MatchersUtil.prototype.contains = function(haystack, needle) {
    if (!haystack) {
      return false;
    }

    if (j$.isSet(haystack)) {
      // Try .has() first. It should be faster in cases where
      // needle === something in haystack. Fall back to .equals() comparison
      // if that fails.
      if (haystack.has(needle)) {
        return true;
      }
    }

    if (j$.isIterable_(haystack) && !j$.isString_(haystack)) {
      // Arrays, Sets, etc.
      for (const candidate of haystack) {
        if (this.equals(candidate, needle)) {
          return true;
        }
      }

      return false;
    }

    if (haystack.indexOf) {
      // Mainly strings
      return haystack.indexOf(needle) >= 0;
    }

    if (j$.isNumber_(haystack.length)) {
      // Objects that are shaped like arrays but aren't iterable
      for (var i = 0; i < haystack.length; i++) {
        if (this.equals(haystack[i], needle)) {
          return true;
        }
      }
    }

    return false;
  };

  MatchersUtil.prototype.buildFailureMessage = function() {
    var self = this;
    var args = Array.prototype.slice.call(arguments, 0),
      matcherName = args[0],
      isNot = args[1],
      actual = args[2],
      expected = args.slice(3),
      englishyPredicate = matcherName.replace(/[A-Z]/g, function(s) {
        return ' ' + s.toLowerCase();
      });

    var message =
      'Expected ' +
      self.pp(actual) +
      (isNot ? ' not ' : ' ') +
      englishyPredicate;

    if (expected.length > 0) {
      for (var i = 0; i < expected.length; i++) {
        if (i > 0) {
          message += ',';
        }
        message += ' ' + self.pp(expected[i]);
      }
    }

    return message + '.';
  };

  MatchersUtil.prototype.asymmetricDiff_ = function(
    a,
    b,
    aStack,
    bStack,
    diffBuilder
  ) {
    if (j$.isFunction_(b.valuesForDiff_)) {
      var values = b.valuesForDiff_(a, this.pp);
      this.eq_(values.other, values.self, aStack, bStack, diffBuilder);
    } else {
      diffBuilder.recordMismatch();
    }
  };

  MatchersUtil.prototype.asymmetricMatch_ = function(
    a,
    b,
    aStack,
    bStack,
    diffBuilder
  ) {
    var asymmetricA = j$.isAsymmetricEqualityTester_(a),
      asymmetricB = j$.isAsymmetricEqualityTester_(b),
      result;

    if (asymmetricA === asymmetricB) {
      return undefined;
    }

    if (asymmetricA) {
      result = a.asymmetricMatch(b, this);
      if (!result) {
        diffBuilder.recordMismatch();
      }
      return result;
    }

    if (asymmetricB) {
      result = b.asymmetricMatch(a, this);
      if (!result) {
        this.asymmetricDiff_(a, b, aStack, bStack, diffBuilder);
      }
      return result;
    }
  };

  /**
   * Determines whether two values are deeply equal to each other.
   * @function
   * @name MatchersUtil#equals
   * @since 2.0.0
   * @param {*} a The first value to compare
   * @param {*} b The second value to compare
   * @returns {boolean} True if the values are equal
   */
  MatchersUtil.prototype.equals = function(a, b, diffBuilder) {
    diffBuilder = diffBuilder || j$.NullDiffBuilder();
    diffBuilder.setRoots(a, b);

    return this.eq_(a, b, [], [], diffBuilder);
  };

  // Equality function lovingly adapted from isEqual in
  //   [Underscore](http://underscorejs.org)
  MatchersUtil.prototype.eq_ = function(a, b, aStack, bStack, diffBuilder) {
    var result = true,
      self = this,
      i;

    var asymmetricResult = this.asymmetricMatch_(
      a,
      b,
      aStack,
      bStack,
      diffBuilder
    );
    if (!j$.util.isUndefined(asymmetricResult)) {
      return asymmetricResult;
    }

    for (i = 0; i < this.customTesters_.length; i++) {
      var customTesterResult = this.customTesters_[i](a, b);
      if (!j$.util.isUndefined(customTesterResult)) {
        if (!customTesterResult) {
          diffBuilder.recordMismatch();
        }
        return customTesterResult;
      }
    }

    if (a instanceof Error && b instanceof Error) {
      result = a.message == b.message;
      if (!result) {
        diffBuilder.recordMismatch();
      }
      return result;
    }

    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) {
      result = a !== 0 || 1 / a == 1 / b;
      if (!result) {
        diffBuilder.recordMismatch();
      }
      return result;
    }
    // A strict comparison is necessary because `null == undefined`.
    if (a === null || b === null) {
      result = a === b;
      if (!result) {
        diffBuilder.recordMismatch();
      }
      return result;
    }
    var className = Object.prototype.toString.call(a);
    if (className != Object.prototype.toString.call(b)) {
      diffBuilder.recordMismatch();
      return false;
    }
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        result = a == String(b);
        if (!result) {
          diffBuilder.recordMismatch();
        }
        return result;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        result =
          a != +a ? b != +b : a === 0 && b === 0 ? 1 / a == 1 / b : a == +b;
        if (!result) {
          diffBuilder.recordMismatch();
        }
        return result;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        result = +a == +b;
        if (!result) {
          diffBuilder.recordMismatch();
        }
        return result;
      case '[object ArrayBuffer]':
        // If we have an instance of ArrayBuffer the Uint8Array ctor
        // will be defined as well
        return self.eq_(
          new Uint8Array(a),
          new Uint8Array(b),
          aStack,
          bStack,
          diffBuilder
        );
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return (
          a.source == b.source &&
          a.global == b.global &&
          a.multiline == b.multiline &&
          a.ignoreCase == b.ignoreCase
        );
    }
    if (typeof a != 'object' || typeof b != 'object') {
      diffBuilder.recordMismatch();
      return false;
    }

    var aIsDomNode = j$.isDomNode(a);
    var bIsDomNode = j$.isDomNode(b);
    if (aIsDomNode && bIsDomNode) {
      // At first try to use DOM3 method isEqualNode
      result = a.isEqualNode(b);
      if (!result) {
        diffBuilder.recordMismatch();
      }
      return result;
    }
    if (aIsDomNode || bIsDomNode) {
      diffBuilder.recordMismatch();
      return false;
    }

    var aIsPromise = j$.isPromise(a);
    var bIsPromise = j$.isPromise(b);
    if (aIsPromise && bIsPromise) {
      return a === b;
    }

    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) {
        return bStack[length] == b;
      }
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0;
    // Recursively compare objects and arrays.
    // Compare array lengths to determine if a deep comparison is necessary.
    if (className == '[object Array]') {
      var aLength = a.length;
      var bLength = b.length;

      diffBuilder.withPath('length', function() {
        if (aLength !== bLength) {
          diffBuilder.recordMismatch();
          result = false;
        }
      });

      for (i = 0; i < aLength || i < bLength; i++) {
        diffBuilder.withPath(i, function() {
          if (i >= bLength) {
            diffBuilder.recordMismatch(
              actualArrayIsLongerFormatter.bind(null, self.pp)
            );
            result = false;
          } else {
            result =
              self.eq_(
                i < aLength ? a[i] : void 0,
                i < bLength ? b[i] : void 0,
                aStack,
                bStack,
                diffBuilder
              ) && result;
          }
        });
      }
      if (!result) {
        return false;
      }
    } else if (j$.isMap(a) && j$.isMap(b)) {
      if (a.size != b.size) {
        diffBuilder.recordMismatch();
        return false;
      }

      var keysA = [];
      var keysB = [];
      a.forEach(function(valueA, keyA) {
        keysA.push(keyA);
      });
      b.forEach(function(valueB, keyB) {
        keysB.push(keyB);
      });

      // For both sets of keys, check they map to equal values in both maps.
      // Keep track of corresponding keys (in insertion order) in order to handle asymmetric obj keys.
      var mapKeys = [keysA, keysB];
      var cmpKeys = [keysB, keysA];
      var mapIter, mapKey, mapValueA, mapValueB;
      var cmpIter, cmpKey;
      for (i = 0; result && i < mapKeys.length; i++) {
        mapIter = mapKeys[i];
        cmpIter = cmpKeys[i];

        for (var j = 0; result && j < mapIter.length; j++) {
          mapKey = mapIter[j];
          cmpKey = cmpIter[j];
          mapValueA = a.get(mapKey);

          // Only use the cmpKey when one of the keys is asymmetric and the corresponding key matches,
          // otherwise explicitly look up the mapKey in the other Map since we want keys with unique
          // obj identity (that are otherwise equal) to not match.
          if (
            j$.isAsymmetricEqualityTester_(mapKey) ||
            (j$.isAsymmetricEqualityTester_(cmpKey) &&
              this.eq_(mapKey, cmpKey, aStack, bStack, j$.NullDiffBuilder()))
          ) {
            mapValueB = b.get(cmpKey);
          } else {
            mapValueB = b.get(mapKey);
          }
          result = this.eq_(
            mapValueA,
            mapValueB,
            aStack,
            bStack,
            j$.NullDiffBuilder()
          );
        }
      }

      if (!result) {
        diffBuilder.recordMismatch();
        return false;
      }
    } else if (j$.isSet(a) && j$.isSet(b)) {
      if (a.size != b.size) {
        diffBuilder.recordMismatch();
        return false;
      }

      var valuesA = [];
      a.forEach(function(valueA) {
        valuesA.push(valueA);
      });
      var valuesB = [];
      b.forEach(function(valueB) {
        valuesB.push(valueB);
      });

      // For both sets, check they are all contained in the other set
      var setPairs = [[valuesA, valuesB], [valuesB, valuesA]];
      var stackPairs = [[aStack, bStack], [bStack, aStack]];
      var baseValues, baseValue, baseStack;
      var otherValues, otherValue, otherStack;
      var found;
      var prevStackSize;
      for (i = 0; result && i < setPairs.length; i++) {
        baseValues = setPairs[i][0];
        otherValues = setPairs[i][1];
        baseStack = stackPairs[i][0];
        otherStack = stackPairs[i][1];
        // For each value in the base set...
        for (var k = 0; result && k < baseValues.length; k++) {
          baseValue = baseValues[k];
          found = false;
          // ... test that it is present in the other set
          for (var l = 0; !found && l < otherValues.length; l++) {
            otherValue = otherValues[l];
            prevStackSize = baseStack.length;
            // compare by value equality
            found = this.eq_(
              baseValue,
              otherValue,
              baseStack,
              otherStack,
              j$.NullDiffBuilder()
            );
            if (!found && prevStackSize !== baseStack.length) {
              baseStack.splice(prevStackSize);
              otherStack.splice(prevStackSize);
            }
          }
          result = result && found;
        }
      }

      if (!result) {
        diffBuilder.recordMismatch();
        return false;
      }
    } else if (j$.isURL(a) && j$.isURL(b)) {
      // URLs have no enumrable properties, so the default object comparison
      // would consider any two URLs to be equal.
      return a.toString() === b.toString();
    } else {
      // Objects with different constructors are not equivalent, but `Object`s
      // or `Array`s from different frames are.
      var aCtor = a.constructor,
        bCtor = b.constructor;
      if (
        aCtor !== bCtor &&
        isFunction(aCtor) &&
        isFunction(bCtor) &&
        a instanceof aCtor &&
        b instanceof bCtor &&
        !(aCtor instanceof aCtor && bCtor instanceof bCtor)
      ) {
        diffBuilder.recordMismatch(
          constructorsAreDifferentFormatter.bind(null, this.pp)
        );
        return false;
      }
    }

    // Deep compare objects.
    var aKeys = keys(a, className == '[object Array]'),
      key;
    size = aKeys.length;

    // Ensure that both objects contain the same number of properties before comparing deep equality.
    if (keys(b, className == '[object Array]').length !== size) {
      diffBuilder.recordMismatch(
        objectKeysAreDifferentFormatter.bind(null, this.pp)
      );
      return false;
    }

    for (i = 0; i < size; i++) {
      key = aKeys[i];
      // Deep compare each member
      if (!j$.util.has(b, key)) {
        diffBuilder.recordMismatch(
          objectKeysAreDifferentFormatter.bind(null, this.pp)
        );
        result = false;
        continue;
      }

      diffBuilder.withPath(key, function() {
        if (!self.eq_(a[key], b[key], aStack, bStack, diffBuilder)) {
          result = false;
        }
      });
    }

    if (!result) {
      return false;
    }

    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();

    return result;
  };

  function keys(obj, isArray) {
    var allKeys = Object.keys
      ? Object.keys(obj)
      : (function(o) {
          var keys = [];
          for (var key in o) {
            if (j$.util.has(o, key)) {
              keys.push(key);
            }
          }
          return keys;
        })(obj);

    if (!isArray) {
      return allKeys;
    }

    if (allKeys.length === 0) {
      return allKeys;
    }

    var extraKeys = [];
    for (var i = 0; i < allKeys.length; i++) {
      if (!/^[0-9]+$/.test(allKeys[i])) {
        extraKeys.push(allKeys[i]);
      }
    }

    return extraKeys;
  }

  function isFunction(obj) {
    return typeof obj === 'function';
  }

  function objectKeysAreDifferentFormatter(pp, actual, expected, path) {
    var missingProperties = j$.util.objectDifference(expected, actual),
      extraProperties = j$.util.objectDifference(actual, expected),
      missingPropertiesMessage = formatKeyValuePairs(pp, missingProperties),
      extraPropertiesMessage = formatKeyValuePairs(pp, extraProperties),
      messages = [];

    if (!path.depth()) {
      path = 'object';
    }

    if (missingPropertiesMessage.length) {
      messages.push(
        'Expected ' + path + ' to have properties' + missingPropertiesMessage
      );
    }

    if (extraPropertiesMessage.length) {
      messages.push(
        'Expected ' + path + ' not to have properties' + extraPropertiesMessage
      );
    }

    return messages.join('\n');
  }

  function constructorsAreDifferentFormatter(pp, actual, expected, path) {
    if (!path.depth()) {
      path = 'object';
    }

    return (
      'Expected ' +
      path +
      ' to be a kind of ' +
      j$.fnNameFor(expected.constructor) +
      ', but was ' +
      pp(actual) +
      '.'
    );
  }

  function actualArrayIsLongerFormatter(pp, actual, expected, path) {
    return (
      'Unexpected ' +
      path +
      (path.depth() ? ' = ' : '') +
      pp(actual) +
      ' in array.'
    );
  }

  function formatKeyValuePairs(pp, obj) {
    var formatted = '';
    for (var key in obj) {
      formatted += '\n    ' + key + ': ' + pp(obj[key]);
    }
    return formatted;
  }

  return MatchersUtil;
};

/**
 * @interface AsymmetricEqualityTester
 * @classdesc An asymmetric equality tester is an object that can match multiple
 * objects. Examples include jasmine.any() and jasmine.stringMatching(). Jasmine
 * includes a number of built-in asymmetric equality testers, such as
 * {@link jasmine.objectContaining}. User-defined asymmetric equality testers are
 * also supported.
 *
 * Asymmetric equality testers work with any matcher, including user-defined
 * custom matchers, that uses {@link MatchersUtil#equals} or
 * {@link MatchersUtil#contains}.
 *
 * @example
 * function numberDivisibleBy(divisor) {
 *   return {
 *     asymmetricMatch: function(n) {
 *       return typeof n === 'number' && n % divisor === 0;
 *     },
 *     jasmineToString: function() {
 *       return `<a number divisible by ${divisor}>`;
 *     }
 *   };
 * }
 *
 * var actual = {
 *   n: 2,
 *   otherFields: "don't care"
 * };
 *
 * expect(actual).toEqual(jasmine.objectContaining({n: numberDivisibleBy(2)}));
 * @see custom_asymmetric_equality_testers
 * @since 2.0.0
 */
/**
 * Determines whether a value matches this tester
 * @function
 * @name AsymmetricEqualityTester#asymmetricMatch
 * @param value {any} The value to test
 * @param matchersUtil {MatchersUtil} utilities for testing equality, etc
 * @return {Boolean}
 */
/**
 * Returns a string representation of this tester to use in matcher failure messages
 * @function
 * @name AsymmetricEqualityTester#jasmineToString
 * @param pp {function} Function that takes a value and returns a pretty-printed representation
 * @return {String}
 */

getJasmineRequireObj().MismatchTree = function(j$) {
  /*
    To be able to apply custom object formatters at all possible levels of an
    object graph, DiffBuilder needs to be able to know not just where the
    mismatch occurred but also all ancestors of the mismatched value in both
    the expected and actual object graphs. MismatchTree maintains that context
    and provides it via the traverse method.
   */
  function MismatchTree(path) {
    this.path = path || new j$.ObjectPath([]);
    this.formatter = undefined;
    this.children = [];
    this.isMismatch = false;
  }

  MismatchTree.prototype.add = function(path, formatter) {
    var key, child;

    if (path.depth() === 0) {
      this.formatter = formatter;
      this.isMismatch = true;
    } else {
      key = path.components[0];
      path = path.shift();
      child = this.child(key);

      if (!child) {
        child = new MismatchTree(this.path.add(key));
        this.children.push(child);
      }

      child.add(path, formatter);
    }
  };

  MismatchTree.prototype.traverse = function(visit) {
    var i,
      hasChildren = this.children.length > 0;

    if (this.isMismatch || hasChildren) {
      if (visit(this.path, !hasChildren, this.formatter)) {
        for (i = 0; i < this.children.length; i++) {
          this.children[i].traverse(visit);
        }
      }
    }
  };

  MismatchTree.prototype.child = function(key) {
    var i, pathEls;

    for (i = 0; i < this.children.length; i++) {
      pathEls = this.children[i].path.components;
      if (pathEls[pathEls.length - 1] === key) {
        return this.children[i];
      }
    }
  };

  return MismatchTree;
};

getJasmineRequireObj().nothing = function() {
  /**
   * {@link expect} nothing explicitly.
   * @function
   * @name matchers#nothing
   * @since 2.8.0
   * @example
   * expect().nothing();
   */
  function nothing() {
    return {
      compare: function() {
        return {
          pass: true
        };
      }
    };
  }

  return nothing;
};

getJasmineRequireObj().NullDiffBuilder = function(j$) {
  return function() {
    return {
      withPath: function(_, block) {
        block();
      },
      setRoots: function() {},
      recordMismatch: function() {}
    };
  };
};

getJasmineRequireObj().ObjectPath = function(j$) {
  function ObjectPath(components) {
    this.components = components || [];
  }

  ObjectPath.prototype.toString = function() {
    if (this.components.length) {
      return '$' + map(this.components, formatPropertyAccess).join('');
    } else {
      return '';
    }
  };

  ObjectPath.prototype.add = function(component) {
    return new ObjectPath(this.components.concat([component]));
  };

  ObjectPath.prototype.shift = function() {
    return new ObjectPath(this.components.slice(1));
  };

  ObjectPath.prototype.depth = function() {
    return this.components.length;
  };

  function formatPropertyAccess(prop) {
    if (typeof prop === 'number') {
      return '[' + prop + ']';
    }

    if (isValidIdentifier(prop)) {
      return '.' + prop;
    }

    return "['" + prop + "']";
  }

  function map(array, fn) {
    var results = [];
    for (var i = 0; i < array.length; i++) {
      results.push(fn(array[i]));
    }
    return results;
  }

  function isValidIdentifier(string) {
    return /^[A-Za-z\$_][A-Za-z0-9\$_]*$/.test(string);
  }

  return ObjectPath;
};

getJasmineRequireObj().requireAsyncMatchers = function(jRequire, j$) {
  var availableMatchers = [
      'toBePending',
      'toBeResolved',
      'toBeRejected',
      'toBeResolvedTo',
      'toBeRejectedWith',
      'toBeRejectedWithError'
    ],
    matchers = {};

  for (var i = 0; i < availableMatchers.length; i++) {
    var name = availableMatchers[i];
    matchers[name] = jRequire[name](j$);
  }

  return matchers;
};

getJasmineRequireObj().toBe = function(j$) {
  /**
   * {@link expect} the actual value to be `===` to the expected value.
   * @function
   * @name matchers#toBe
   * @since 1.3.0
   * @param {Object} expected - The expected value to compare against.
   * @example
   * expect(thing).toBe(realThing);
   */
  function toBe(matchersUtil) {
    var tip =
      ' Tip: To check for deep equality, use .toEqual() instead of .toBe().';

    return {
      compare: function(actual, expected) {
        var result = {
          pass: actual === expected
        };

        if (typeof expected === 'object') {
          result.message =
            matchersUtil.buildFailureMessage(
              'toBe',
              result.pass,
              actual,
              expected
            ) + tip;
        }

        return result;
      }
    };
  }

  return toBe;
};

getJasmineRequireObj().toBeCloseTo = function() {
  /**
   * {@link expect} the actual value to be within a specified precision of the expected value.
   * @function
   * @name matchers#toBeCloseTo
   * @since 1.3.0
   * @param {Object} expected - The expected value to compare against.
   * @param {Number} [precision=2] - The number of decimal points to check.
   * @example
   * expect(number).toBeCloseTo(42.2, 3);
   */
  function toBeCloseTo() {
    return {
      compare: function(actual, expected, precision) {
        if (precision !== 0) {
          precision = precision || 2;
        }

        if (expected === null || actual === null) {
          throw new Error(
            'Cannot use toBeCloseTo with null. Arguments evaluated to: ' +
              'expect(' +
              actual +
              ').toBeCloseTo(' +
              expected +
              ').'
          );
        }

        var pow = Math.pow(10, precision + 1);
        var delta = Math.abs(expected - actual);
        var maxDelta = Math.pow(10, -precision) / 2;

        return {
          pass: Math.round(delta * pow) <= maxDelta * pow
        };
      }
    };
  }

  return toBeCloseTo;
};

getJasmineRequireObj().toBeDefined = function() {
  /**
   * {@link expect} the actual value to be defined. (Not `undefined`)
   * @function
   * @name matchers#toBeDefined
   * @since 1.3.0
   * @example
   * expect(result).toBeDefined();
   */
  function toBeDefined() {
    return {
      compare: function(actual) {
        return {
          pass: void 0 !== actual
        };
      }
    };
  }

  return toBeDefined;
};

getJasmineRequireObj().toBeFalse = function() {
  /**
   * {@link expect} the actual value to be `false`.
   * @function
   * @name matchers#toBeFalse
   * @since 3.5.0
   * @example
   * expect(result).toBeFalse();
   */
  function toBeFalse() {
    return {
      compare: function(actual) {
        return {
          pass: actual === false
        };
      }
    };
  }

  return toBeFalse;
};

getJasmineRequireObj().toBeFalsy = function() {
  /**
   * {@link expect} the actual value to be falsy
   * @function
   * @name matchers#toBeFalsy
   * @since 2.0.0
   * @example
   * expect(result).toBeFalsy();
   */
  function toBeFalsy() {
    return {
      compare: function(actual) {
        return {
          pass: !actual
        };
      }
    };
  }

  return toBeFalsy;
};

getJasmineRequireObj().toBeGreaterThan = function() {
  /**
   * {@link expect} the actual value to be greater than the expected value.
   * @function
   * @name matchers#toBeGreaterThan
   * @since 2.0.0
   * @param {Number} expected - The value to compare against.
   * @example
   * expect(result).toBeGreaterThan(3);
   */
  function toBeGreaterThan() {
    return {
      compare: function(actual, expected) {
        return {
          pass: actual > expected
        };
      }
    };
  }

  return toBeGreaterThan;
};

getJasmineRequireObj().toBeGreaterThanOrEqual = function() {
  /**
   * {@link expect} the actual value to be greater than or equal to the expected value.
   * @function
   * @name matchers#toBeGreaterThanOrEqual
   * @since 2.0.0
   * @param {Number} expected - The expected value to compare against.
   * @example
   * expect(result).toBeGreaterThanOrEqual(25);
   */
  function toBeGreaterThanOrEqual() {
    return {
      compare: function(actual, expected) {
        return {
          pass: actual >= expected
        };
      }
    };
  }

  return toBeGreaterThanOrEqual;
};

getJasmineRequireObj().toBeInstanceOf = function(j$) {
  var usageError = j$.formatErrorMsg(
    '<toBeInstanceOf>',
    'expect(value).toBeInstanceOf(<ConstructorFunction>)'
  );

  /**
   * {@link expect} the actual to be an instance of the expected class
   * @function
   * @name matchers#toBeInstanceOf
   * @since 3.5.0
   * @param {Object} expected - The class or constructor function to check for
   * @example
   * expect('foo').toBeInstanceOf(String);
   * expect(3).toBeInstanceOf(Number);
   * expect(new Error()).toBeInstanceOf(Error);
   */
  function toBeInstanceOf(matchersUtil) {
    return {
      compare: function(actual, expected) {
        var actualType =
            actual && actual.constructor
              ? j$.fnNameFor(actual.constructor)
              : matchersUtil.pp(actual),
          expectedType = expected
            ? j$.fnNameFor(expected)
            : matchersUtil.pp(expected),
          expectedMatcher,
          pass;

        try {
          expectedMatcher = new j$.Any(expected);
          pass = expectedMatcher.asymmetricMatch(actual);
        } catch (error) {
          throw new Error(
            usageError('Expected value is not a constructor function')
          );
        }

        if (pass) {
          return {
            pass: true,
            message:
              'Expected instance of ' +
              actualType +
              ' not to be an instance of ' +
              expectedType
          };
        } else {
          return {
            pass: false,
            message:
              'Expected instance of ' +
              actualType +
              ' to be an instance of ' +
              expectedType
          };
        }
      }
    };
  }

  return toBeInstanceOf;
};

getJasmineRequireObj().toBeLessThan = function() {
  /**
   * {@link expect} the actual value to be less than the expected value.
   * @function
   * @name matchers#toBeLessThan
   * @since 2.0.0
   * @param {Number} expected - The expected value to compare against.
   * @example
   * expect(result).toBeLessThan(0);
   */
  function toBeLessThan() {
    return {
      compare: function(actual, expected) {
        return {
          pass: actual < expected
        };
      }
    };
  }

  return toBeLessThan;
};

getJasmineRequireObj().toBeLessThanOrEqual = function() {
  /**
   * {@link expect} the actual value to be less than or equal to the expected value.
   * @function
   * @name matchers#toBeLessThanOrEqual
   * @since 2.0.0
   * @param {Number} expected - The expected value to compare against.
   * @example
   * expect(result).toBeLessThanOrEqual(123);
   */
  function toBeLessThanOrEqual() {
    return {
      compare: function(actual, expected) {
        return {
          pass: actual <= expected
        };
      }
    };
  }

  return toBeLessThanOrEqual;
};

getJasmineRequireObj().toBeNaN = function(j$) {
  /**
   * {@link expect} the actual value to be `NaN` (Not a Number).
   * @function
   * @name matchers#toBeNaN
   * @since 1.3.0
   * @example
   * expect(thing).toBeNaN();
   */
  function toBeNaN(matchersUtil) {
    return {
      compare: function(actual) {
        var result = {
          pass: actual !== actual
        };

        if (result.pass) {
          result.message = 'Expected actual not to be NaN.';
        } else {
          result.message = function() {
            return 'Expected ' + matchersUtil.pp(actual) + ' to be NaN.';
          };
        }

        return result;
      }
    };
  }

  return toBeNaN;
};

getJasmineRequireObj().toBeNegativeInfinity = function(j$) {
  /**
   * {@link expect} the actual value to be `-Infinity` (-infinity).
   * @function
   * @name matchers#toBeNegativeInfinity
   * @since 2.6.0
   * @example
   * expect(thing).toBeNegativeInfinity();
   */
  function toBeNegativeInfinity(matchersUtil) {
    return {
      compare: function(actual) {
        var result = {
          pass: actual === Number.NEGATIVE_INFINITY
        };

        if (result.pass) {
          result.message = 'Expected actual not to be -Infinity.';
        } else {
          result.message = function() {
            return 'Expected ' + matchersUtil.pp(actual) + ' to be -Infinity.';
          };
        }

        return result;
      }
    };
  }

  return toBeNegativeInfinity;
};

getJasmineRequireObj().toBeNull = function() {
  /**
   * {@link expect} the actual value to be `null`.
   * @function
   * @name matchers#toBeNull
   * @since 1.3.0
   * @example
   * expect(result).toBeNull();
   */
  function toBeNull() {
    return {
      compare: function(actual) {
        return {
          pass: actual === null
        };
      }
    };
  }

  return toBeNull;
};

getJasmineRequireObj().toBePositiveInfinity = function(j$) {
  /**
   * {@link expect} the actual value to be `Infinity` (infinity).
   * @function
   * @name matchers#toBePositiveInfinity
   * @since 2.6.0
   * @example
   * expect(thing).toBePositiveInfinity();
   */
  function toBePositiveInfinity(matchersUtil) {
    return {
      compare: function(actual) {
        var result = {
          pass: actual === Number.POSITIVE_INFINITY
        };

        if (result.pass) {
          result.message = 'Expected actual not to be Infinity.';
        } else {
          result.message = function() {
            return 'Expected ' + matchersUtil.pp(actual) + ' to be Infinity.';
          };
        }

        return result;
      }
    };
  }

  return toBePositiveInfinity;
};

getJasmineRequireObj().toBeTrue = function() {
  /**
   * {@link expect} the actual value to be `true`.
   * @function
   * @name matchers#toBeTrue
   * @since 3.5.0
   * @example
   * expect(result).toBeTrue();
   */
  function toBeTrue() {
    return {
      compare: function(actual) {
        return {
          pass: actual === true
        };
      }
    };
  }

  return toBeTrue;
};

getJasmineRequireObj().toBeTruthy = function() {
  /**
   * {@link expect} the actual value to be truthy.
   * @function
   * @name matchers#toBeTruthy
   * @since 2.0.0
   * @example
   * expect(thing).toBeTruthy();
   */
  function toBeTruthy() {
    return {
      compare: function(actual) {
        return {
          pass: !!actual
        };
      }
    };
  }

  return toBeTruthy;
};

getJasmineRequireObj().toBeUndefined = function() {
  /**
   * {@link expect} the actual value to be `undefined`.
   * @function
   * @name matchers#toBeUndefined
   * @since 1.3.0
   * @example
   * expect(result).toBeUndefined():
   */
  function toBeUndefined() {
    return {
      compare: function(actual) {
        return {
          pass: void 0 === actual
        };
      }
    };
  }

  return toBeUndefined;
};

getJasmineRequireObj().toContain = function() {
  /**
   * {@link expect} the actual value to contain a specific value.
   * @function
   * @name matchers#toContain
   * @since 2.0.0
   * @param {Object} expected - The value to look for.
   * @example
   * expect(array).toContain(anElement);
   * expect(string).toContain(substring);
   */
  function toContain(matchersUtil) {
    return {
      compare: function(actual, expected) {
        return {
          pass: matchersUtil.contains(actual, expected)
        };
      }
    };
  }

  return toContain;
};

getJasmineRequireObj().toEqual = function(j$) {
  /**
   * {@link expect} the actual value to be equal to the expected, using deep equality comparison.
   * @function
   * @name matchers#toEqual
   * @since 1.3.0
   * @param {Object} expected - Expected value
   * @example
   * expect(bigObject).toEqual({"foo": ['bar', 'baz']});
   */
  function toEqual(matchersUtil) {
    return {
      compare: function(actual, expected) {
        var result = {
            pass: false
          },
          diffBuilder = j$.DiffBuilder({ prettyPrinter: matchersUtil.pp });

        result.pass = matchersUtil.equals(actual, expected, diffBuilder);

        // TODO: only set error message if test fails
        result.message = diffBuilder.getMessage();

        return result;
      }
    };
  }

  return toEqual;
};

getJasmineRequireObj().toHaveBeenCalled = function(j$) {
  var getErrorMsg = j$.formatErrorMsg(
    '<toHaveBeenCalled>',
    'expect(<spyObj>).toHaveBeenCalled()'
  );

  /**
   * {@link expect} the actual (a {@link Spy}) to have been called.
   * @function
   * @name matchers#toHaveBeenCalled
   * @since 1.3.0
   * @example
   * expect(mySpy).toHaveBeenCalled();
   * expect(mySpy).not.toHaveBeenCalled();
   */
  function toHaveBeenCalled(matchersUtil) {
    return {
      compare: function(actual) {
        var result = {};

        if (!j$.isSpy(actual)) {
          throw new Error(
            getErrorMsg(
              'Expected a spy, but got ' + matchersUtil.pp(actual) + '.'
            )
          );
        }

        if (arguments.length > 1) {
          throw new Error(
            getErrorMsg('Does not take arguments, use toHaveBeenCalledWith')
          );
        }

        result.pass = actual.calls.any();

        result.message = result.pass
          ? 'Expected spy ' + actual.and.identity + ' not to have been called.'
          : 'Expected spy ' + actual.and.identity + ' to have been called.';

        return result;
      }
    };
  }

  return toHaveBeenCalled;
};

getJasmineRequireObj().toHaveBeenCalledBefore = function(j$) {
  var getErrorMsg = j$.formatErrorMsg(
    '<toHaveBeenCalledBefore>',
    'expect(<spyObj>).toHaveBeenCalledBefore(<spyObj>)'
  );

  /**
   * {@link expect} the actual value (a {@link Spy}) to have been called before another {@link Spy}.
   * @function
   * @name matchers#toHaveBeenCalledBefore
   * @since 2.6.0
   * @param {Spy} expected - {@link Spy} that should have been called after the `actual` {@link Spy}.
   * @example
   * expect(mySpy).toHaveBeenCalledBefore(otherSpy);
   */
  function toHaveBeenCalledBefore(matchersUtil) {
    return {
      compare: function(firstSpy, latterSpy) {
        if (!j$.isSpy(firstSpy)) {
          throw new Error(
            getErrorMsg(
              'Expected a spy, but got ' + matchersUtil.pp(firstSpy) + '.'
            )
          );
        }
        if (!j$.isSpy(latterSpy)) {
          throw new Error(
            getErrorMsg(
              'Expected a spy, but got ' + matchersUtil.pp(latterSpy) + '.'
            )
          );
        }

        var result = { pass: false };

        if (!firstSpy.calls.count()) {
          result.message =
            'Expected spy ' + firstSpy.and.identity + ' to have been called.';
          return result;
        }
        if (!latterSpy.calls.count()) {
          result.message =
            'Expected spy ' + latterSpy.and.identity + ' to have been called.';
          return result;
        }

        var latest1stSpyCall = firstSpy.calls.mostRecent().invocationOrder;
        var first2ndSpyCall = latterSpy.calls.first().invocationOrder;

        result.pass = latest1stSpyCall < first2ndSpyCall;

        if (result.pass) {
          result.message =
            'Expected spy ' +
            firstSpy.and.identity +
            ' to not have been called before spy ' +
            latterSpy.and.identity +
            ', but it was';
        } else {
          var first1stSpyCall = firstSpy.calls.first().invocationOrder;
          var latest2ndSpyCall = latterSpy.calls.mostRecent().invocationOrder;

          if (first1stSpyCall < first2ndSpyCall) {
            result.message =
              'Expected latest call to spy ' +
              firstSpy.and.identity +
              ' to have been called before first call to spy ' +
              latterSpy.and.identity +
              ' (no interleaved calls)';
          } else if (latest2ndSpyCall > latest1stSpyCall) {
            result.message =
              'Expected first call to spy ' +
              latterSpy.and.identity +
              ' to have been called after latest call to spy ' +
              firstSpy.and.identity +
              ' (no interleaved calls)';
          } else {
            result.message =
              'Expected spy ' +
              firstSpy.and.identity +
              ' to have been called before spy ' +
              latterSpy.and.identity;
          }
        }

        return result;
      }
    };
  }

  return toHaveBeenCalledBefore;
};

getJasmineRequireObj().toHaveBeenCalledOnceWith = function(j$) {
  var getErrorMsg = j$.formatErrorMsg(
    '<toHaveBeenCalledOnceWith>',
    'expect(<spyObj>).toHaveBeenCalledOnceWith(...arguments)'
  );

  /**
   * {@link expect} the actual (a {@link Spy}) to have been called exactly once, and exactly with the particular arguments.
   * @function
   * @name matchers#toHaveBeenCalledOnceWith
   * @since 3.6.0
   * @param {...Object} - The arguments to look for
   * @example
   * expect(mySpy).toHaveBeenCalledOnceWith('foo', 'bar', 2);
   */
  function toHaveBeenCalledOnceWith(util) {
    return {
      compare: function() {
        var args = Array.prototype.slice.call(arguments, 0),
          actual = args[0],
          expectedArgs = args.slice(1);

        if (!j$.isSpy(actual)) {
          throw new Error(
            getErrorMsg('Expected a spy, but got ' + util.pp(actual) + '.')
          );
        }

        var prettyPrintedCalls = actual.calls
          .allArgs()
          .map(function(argsForCall) {
            return '  ' + util.pp(argsForCall);
          });

        if (
          actual.calls.count() === 1 &&
          util.contains(actual.calls.allArgs(), expectedArgs)
        ) {
          return {
            pass: true,
            message:
              'Expected spy ' +
              actual.and.identity +
              ' to have been called 0 times, multiple times, or once, but with arguments different from:\n' +
              '  ' +
              util.pp(expectedArgs) +
              '\n' +
              'But the actual call was:\n' +
              prettyPrintedCalls.join(',\n') +
              '.\n\n'
          };
        }

        function getDiffs() {
          return actual.calls.allArgs().map(function(argsForCall, callIx) {
            var diffBuilder = new j$.DiffBuilder();
            util.equals(argsForCall, expectedArgs, diffBuilder);
            return diffBuilder.getMessage();
          });
        }

        function butString() {
          switch (actual.calls.count()) {
            case 0:
              return 'But it was never called.\n\n';
            case 1:
              return (
                'But the actual call was:\n' +
                prettyPrintedCalls.join(',\n') +
                '.\n' +
                getDiffs().join('\n') +
                '\n\n'
              );
            default:
              return (
                'But the actual calls were:\n' +
                prettyPrintedCalls.join(',\n') +
                '.\n\n'
              );
          }
        }

        return {
          pass: false,
          message:
            'Expected spy ' +
            actual.and.identity +
            ' to have been called only once, and with given args:\n' +
            '  ' +
            util.pp(expectedArgs) +
            '\n' +
            butString()
        };
      }
    };
  }

  return toHaveBeenCalledOnceWith;
};

getJasmineRequireObj().toHaveBeenCalledTimes = function(j$) {
  var getErrorMsg = j$.formatErrorMsg(
    '<toHaveBeenCalledTimes>',
    'expect(<spyObj>).toHaveBeenCalledTimes(<Number>)'
  );

  /**
   * {@link expect} the actual (a {@link Spy}) to have been called the specified number of times.
   * @function
   * @name matchers#toHaveBeenCalledTimes
   * @since 2.4.0
   * @param {Number} expected - The number of invocations to look for.
   * @example
   * expect(mySpy).toHaveBeenCalledTimes(3);
   */
  function toHaveBeenCalledTimes(matchersUtil) {
    return {
      compare: function(actual, expected) {
        if (!j$.isSpy(actual)) {
          throw new Error(
            getErrorMsg(
              'Expected a spy, but got ' + matchersUtil.pp(actual) + '.'
            )
          );
        }

        var args = Array.prototype.slice.call(arguments, 0),
          result = { pass: false };

        if (!j$.isNumber_(expected)) {
          throw new Error(
            getErrorMsg(
              'The expected times failed is a required argument and must be a number.'
            )
          );
        }

        actual = args[0];
        var calls = actual.calls.count();
        var timesMessage = expected === 1 ? 'once' : expected + ' times';
        result.pass = calls === expected;
        result.message = result.pass
          ? 'Expected spy ' +
            actual.and.identity +
            ' not to have been called ' +
            timesMessage +
            '. It was called ' +
            calls +
            ' times.'
          : 'Expected spy ' +
            actual.and.identity +
            ' to have been called ' +
            timesMessage +
            '. It was called ' +
            calls +
            ' times.';
        return result;
      }
    };
  }

  return toHaveBeenCalledTimes;
};

getJasmineRequireObj().toHaveBeenCalledWith = function(j$) {
  var getErrorMsg = j$.formatErrorMsg(
    '<toHaveBeenCalledWith>',
    'expect(<spyObj>).toHaveBeenCalledWith(...arguments)'
  );

  /**
   * {@link expect} the actual (a {@link Spy}) to have been called with particular arguments at least once.
   * @function
   * @name matchers#toHaveBeenCalledWith
   * @since 1.3.0
   * @param {...Object} - The arguments to look for
   * @example
   * expect(mySpy).toHaveBeenCalledWith('foo', 'bar', 2);
   */
  function toHaveBeenCalledWith(matchersUtil) {
    return {
      compare: function() {
        var args = Array.prototype.slice.call(arguments, 0),
          actual = args[0],
          expectedArgs = args.slice(1),
          result = { pass: false };

        if (!j$.isSpy(actual)) {
          throw new Error(
            getErrorMsg(
              'Expected a spy, but got ' + matchersUtil.pp(actual) + '.'
            )
          );
        }

        if (!actual.calls.any()) {
          result.message = function() {
            return (
              'Expected spy ' +
              actual.and.identity +
              ' to have been called with:\n' +
              '  ' +
              matchersUtil.pp(expectedArgs) +
              '\nbut it was never called.'
            );
          };
          return result;
        }

        if (matchersUtil.contains(actual.calls.allArgs(), expectedArgs)) {
          result.pass = true;
          result.message = function() {
            return (
              'Expected spy ' +
              actual.and.identity +
              ' not to have been called with:\n' +
              '  ' +
              matchersUtil.pp(expectedArgs) +
              '\nbut it was.'
            );
          };
        } else {
          result.message = function() {
            var prettyPrintedCalls = actual.calls
              .allArgs()
              .map(function(argsForCall) {
                return '  ' + matchersUtil.pp(argsForCall);
              });

            var diffs = actual.calls
              .allArgs()
              .map(function(argsForCall, callIx) {
                var diffBuilder = new j$.DiffBuilder();
                matchersUtil.equals(argsForCall, expectedArgs, diffBuilder);
                return (
                  'Call ' +
                  callIx +
                  ':\n' +
                  diffBuilder.getMessage().replace(/^/gm, '  ')
                );
              });

            return (
              'Expected spy ' +
              actual.and.identity +
              ' to have been called with:\n' +
              '  ' +
              matchersUtil.pp(expectedArgs) +
              '\n' +
              '' +
              'but actual calls were:\n' +
              prettyPrintedCalls.join(',\n') +
              '.\n\n' +
              diffs.join('\n')
            );
          };
        }

        return result;
      }
    };
  }

  return toHaveBeenCalledWith;
};

getJasmineRequireObj().toHaveClass = function(j$) {
  /**
   * {@link expect} the actual value to be a DOM element that has the expected class
   * @function
   * @name matchers#toHaveClass
   * @since 3.0.0
   * @param {Object} expected - The class name to test for
   * @example
   * var el = document.createElement('div');
   * el.className = 'foo bar baz';
   * expect(el).toHaveClass('bar');
   */
  function toHaveClass(matchersUtil) {
    return {
      compare: function(actual, expected) {
        if (!isElement(actual)) {
          throw new Error(matchersUtil.pp(actual) + ' is not a DOM element');
        }

        return {
          pass: actual.classList.contains(expected)
        };
      }
    };
  }

  function isElement(maybeEl) {
    return (
      maybeEl && maybeEl.classList && j$.isFunction_(maybeEl.classList.contains)
    );
  }

  return toHaveClass;
};

getJasmineRequireObj().toHaveSize = function(j$) {
  /**
   * {@link expect} the actual size to be equal to the expected, using array-like length or object keys size.
   * @function
   * @name matchers#toHaveSize
   * @since 3.6.0
   * @param {Object} expected - Expected size
   * @example
   * array = [1,2];
   * expect(array).toHaveSize(2);
   */
  function toHaveSize() {
    return {
      compare: function(actual, expected) {
        var result = {
          pass: false
        };

        if (
          j$.isA_('WeakSet', actual) ||
          j$.isWeakMap(actual) ||
          j$.isDataView(actual)
        ) {
          throw new Error('Cannot get size of ' + actual + '.');
        }

        if (j$.isSet(actual) || j$.isMap(actual)) {
          result.pass = actual.size === expected;
        } else if (isLength(actual.length)) {
          result.pass = actual.length === expected;
        } else {
          result.pass = Object.keys(actual).length === expected;
        }

        return result;
      }
    };
  }

  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  function isLength(value) {
    return (
      typeof value == 'number' &&
      value > -1 &&
      value % 1 === 0 &&
      value <= MAX_SAFE_INTEGER
    );
  }

  return toHaveSize;
};

getJasmineRequireObj().toMatch = function(j$) {
  var getErrorMsg = j$.formatErrorMsg(
    '<toMatch>',
    'expect(<expectation>).toMatch(<string> || <regexp>)'
  );

  /**
   * {@link expect} the actual value to match a regular expression
   * @function
   * @name matchers#toMatch
   * @since 1.3.0
   * @param {RegExp|String} expected - Value to look for in the string.
   * @example
   * expect("my string").toMatch(/string$/);
   * expect("other string").toMatch("her");
   */
  function toMatch() {
    return {
      compare: function(actual, expected) {
        if (!j$.isString_(expected) && !j$.isA_('RegExp', expected)) {
          throw new Error(getErrorMsg('Expected is not a String or a RegExp'));
        }

        var regexp = new RegExp(expected);

        return {
          pass: regexp.test(actual)
        };
      }
    };
  }

  return toMatch;
};

getJasmineRequireObj().toThrow = function(j$) {
  var getErrorMsg = j$.formatErrorMsg(
    '<toThrow>',
    'expect(function() {<expectation>}).toThrow()'
  );

  /**
   * {@link expect} a function to `throw` something.
   * @function
   * @name matchers#toThrow
   * @since 2.0.0
   * @param {Object} [expected] - Value that should be thrown. If not provided, simply the fact that something was thrown will be checked.
   * @example
   * expect(function() { return 'things'; }).toThrow('foo');
   * expect(function() { return 'stuff'; }).toThrow();
   */
  function toThrow(matchersUtil) {
    return {
      compare: function(actual, expected) {
        var result = { pass: false },
          threw = false,
          thrown;

        if (typeof actual != 'function') {
          throw new Error(getErrorMsg('Actual is not a Function'));
        }

        try {
          actual();
        } catch (e) {
          threw = true;
          thrown = e;
        }

        if (!threw) {
          result.message = 'Expected function to throw an exception.';
          return result;
        }

        if (arguments.length == 1) {
          result.pass = true;
          result.message = function() {
            return (
              'Expected function not to throw, but it threw ' +
              matchersUtil.pp(thrown) +
              '.'
            );
          };

          return result;
        }

        if (matchersUtil.equals(thrown, expected)) {
          result.pass = true;
          result.message = function() {
            return (
              'Expected function not to throw ' +
              matchersUtil.pp(expected) +
              '.'
            );
          };
        } else {
          result.message = function() {
            return (
              'Expected function to throw ' +
              matchersUtil.pp(expected) +
              ', but it threw ' +
              matchersUtil.pp(thrown) +
              '.'
            );
          };
        }

        return result;
      }
    };
  }

  return toThrow;
};

getJasmineRequireObj().toThrowError = function(j$) {
  var getErrorMsg = j$.formatErrorMsg(
    '<toThrowError>',
    'expect(function() {<expectation>}).toThrowError(<ErrorConstructor>, <message>)'
  );

  /**
   * {@link expect} a function to `throw` an `Error`.
   * @function
   * @name matchers#toThrowError
   * @since 2.0.0
   * @param {Error} [expected] - `Error` constructor the object that was thrown needs to be an instance of. If not provided, `Error` will be used.
   * @param {RegExp|String} [message] - The message that should be set on the thrown `Error`
   * @example
   * expect(function() { return 'things'; }).toThrowError(MyCustomError, 'message');
   * expect(function() { return 'things'; }).toThrowError(MyCustomError, /bar/);
   * expect(function() { return 'stuff'; }).toThrowError(MyCustomError);
   * expect(function() { return 'other'; }).toThrowError(/foo/);
   * expect(function() { return 'other'; }).toThrowError();
   */
  function toThrowError(matchersUtil) {
    return {
      compare: function(actual) {
        var errorMatcher = getMatcher.apply(null, arguments),
          thrown;

        if (typeof actual != 'function') {
          throw new Error(getErrorMsg('Actual is not a Function'));
        }

        try {
          actual();
          return fail('Expected function to throw an Error.');
        } catch (e) {
          thrown = e;
        }

        if (!j$.isError_(thrown)) {
          return fail(function() {
            return (
              'Expected function to throw an Error, but it threw ' +
              matchersUtil.pp(thrown) +
              '.'
            );
          });
        }

        return errorMatcher.match(thrown);
      }
    };

    function getMatcher() {
      var expected, errorType;

      if (arguments[2]) {
        errorType = arguments[1];
        expected = arguments[2];
        if (!isAnErrorType(errorType)) {
          throw new Error(getErrorMsg('Expected error type is not an Error.'));
        }

        return exactMatcher(expected, errorType);
      } else if (arguments[1]) {
        expected = arguments[1];

        if (isAnErrorType(arguments[1])) {
          return exactMatcher(null, arguments[1]);
        } else {
          return exactMatcher(arguments[1], null);
        }
      } else {
        return anyMatcher();
      }
    }

    function anyMatcher() {
      return {
        match: function(error) {
          return pass(
            'Expected function not to throw an Error, but it threw ' +
              j$.fnNameFor(error) +
              '.'
          );
        }
      };
    }

    function exactMatcher(expected, errorType) {
      if (expected && !isStringOrRegExp(expected)) {
        if (errorType) {
          throw new Error(
            getErrorMsg('Expected error message is not a string or RegExp.')
          );
        } else {
          throw new Error(
            getErrorMsg('Expected is not an Error, string, or RegExp.')
          );
        }
      }

      function messageMatch(message) {
        if (typeof expected == 'string') {
          return expected == message;
        } else {
          return expected.test(message);
        }
      }

      var errorTypeDescription = errorType
        ? j$.fnNameFor(errorType)
        : 'an exception';

      function thrownDescription(thrown) {
        var thrownName = errorType
            ? j$.fnNameFor(thrown.constructor)
            : 'an exception',
          thrownMessage = '';

        if (expected) {
          thrownMessage = ' with message ' + matchersUtil.pp(thrown.message);
        }

        return thrownName + thrownMessage;
      }

      function messageDescription() {
        if (expected === null) {
          return '';
        } else if (expected instanceof RegExp) {
          return ' with a message matching ' + matchersUtil.pp(expected);
        } else {
          return ' with message ' + matchersUtil.pp(expected);
        }
      }

      function matches(error) {
        return (
          (errorType === null || error instanceof errorType) &&
          (expected === null || messageMatch(error.message))
        );
      }

      return {
        match: function(thrown) {
          if (matches(thrown)) {
            return pass(function() {
              return (
                'Expected function not to throw ' +
                errorTypeDescription +
                messageDescription() +
                '.'
              );
            });
          } else {
            return fail(function() {
              return (
                'Expected function to throw ' +
                errorTypeDescription +
                messageDescription() +
                ', but it threw ' +
                thrownDescription(thrown) +
                '.'
              );
            });
          }
        }
      };
    }

    function isStringOrRegExp(potential) {
      return potential instanceof RegExp || typeof potential == 'string';
    }

    function isAnErrorType(type) {
      if (typeof type !== 'function') {
        return false;
      }

      var Surrogate = function() {};
      Surrogate.prototype = type.prototype;
      return j$.isError_(new Surrogate());
    }
  }

  function pass(message) {
    return {
      pass: true,
      message: message
    };
  }

  function fail(message) {
    return {
      pass: false,
      message: message
    };
  }

  return toThrowError;
};

getJasmineRequireObj().toThrowMatching = function(j$) {
  var usageError = j$.formatErrorMsg(
    '<toThrowMatching>',
    'expect(function() {<expectation>}).toThrowMatching(<Predicate>)'
  );

  /**
   * {@link expect} a function to `throw` something matching a predicate.
   * @function
   * @name matchers#toThrowMatching
   * @since 3.0.0
   * @param {Function} predicate - A function that takes the thrown exception as its parameter and returns true if it matches.
   * @example
   * expect(function() { throw new Error('nope'); }).toThrowMatching(function(thrown) { return thrown.message === 'nope'; });
   */
  function toThrowMatching(matchersUtil) {
    return {
      compare: function(actual, predicate) {
        var thrown;

        if (typeof actual !== 'function') {
          throw new Error(usageError('Actual is not a Function'));
        }

        if (typeof predicate !== 'function') {
          throw new Error(usageError('Predicate is not a Function'));
        }

        try {
          actual();
          return fail('Expected function to throw an exception.');
        } catch (e) {
          thrown = e;
        }

        if (predicate(thrown)) {
          return pass(
            'Expected function not to throw an exception matching a predicate.'
          );
        } else {
          return fail(function() {
            return (
              'Expected function to throw an exception matching a predicate, ' +
              'but it threw ' +
              thrownDescription(thrown) +
              '.'
            );
          });
        }
      }
    };

    function thrownDescription(thrown) {
      if (thrown && thrown.constructor) {
        return (
          j$.fnNameFor(thrown.constructor) +
          ' with message ' +
          matchersUtil.pp(thrown.message)
        );
      } else {
        return matchersUtil.pp(thrown);
      }
    }
  }

  function pass(message) {
    return {
      pass: true,
      message: message
    };
  }

  function fail(message) {
    return {
      pass: false,
      message: message
    };
  }

  return toThrowMatching;
};

getJasmineRequireObj().MockDate = function(j$) {
  function MockDate(global) {
    var self = this;
    var currentTime = 0;

    if (!global || !global.Date) {
      self.install = function() {};
      self.tick = function() {};
      self.uninstall = function() {};
      return self;
    }

    var GlobalDate = global.Date;

    self.install = function(mockDate) {
      if (mockDate instanceof GlobalDate) {
        currentTime = mockDate.getTime();
      } else {
        if (!j$.util.isUndefined(mockDate)) {
          throw new Error(
            'The argument to jasmine.clock().mockDate(), if specified, ' +
              'should be a Date instance.'
          );
        }

        currentTime = new GlobalDate().getTime();
      }

      global.Date = FakeDate;
    };

    self.tick = function(millis) {
      millis = millis || 0;
      currentTime = currentTime + millis;
    };

    self.uninstall = function() {
      currentTime = 0;
      global.Date = GlobalDate;
    };

    createDateProperties();

    return self;

    function FakeDate() {
      switch (arguments.length) {
        case 0:
          return new GlobalDate(currentTime);
        case 1:
          return new GlobalDate(arguments[0]);
        case 2:
          return new GlobalDate(arguments[0], arguments[1]);
        case 3:
          return new GlobalDate(arguments[0], arguments[1], arguments[2]);
        case 4:
          return new GlobalDate(
            arguments[0],
            arguments[1],
            arguments[2],
            arguments[3]
          );
        case 5:
          return new GlobalDate(
            arguments[0],
            arguments[1],
            arguments[2],
            arguments[3],
            arguments[4]
          );
        case 6:
          return new GlobalDate(
            arguments[0],
            arguments[1],
            arguments[2],
            arguments[3],
            arguments[4],
            arguments[5]
          );
        default:
          return new GlobalDate(
            arguments[0],
            arguments[1],
            arguments[2],
            arguments[3],
            arguments[4],
            arguments[5],
            arguments[6]
          );
      }
    }

    function createDateProperties() {
      FakeDate.prototype = GlobalDate.prototype;

      FakeDate.now = function() {
        return currentTime;
      };

      FakeDate.toSource = GlobalDate.toSource;
      FakeDate.toString = GlobalDate.toString;
      FakeDate.parse = GlobalDate.parse;
      FakeDate.UTC = GlobalDate.UTC;
    }
  }

  return MockDate;
};

getJasmineRequireObj().NeverSkipPolicy = function(j$) {
  function NeverSkipPolicy(queueableFns) {}

  NeverSkipPolicy.prototype.skipTo = function(lastRanFnIx) {
    return lastRanFnIx + 1;
  };

  NeverSkipPolicy.prototype.fnErrored = function(fnIx) {};

  return NeverSkipPolicy;
};

getJasmineRequireObj().makePrettyPrinter = function(j$) {
  function SinglePrettyPrintRun(customObjectFormatters, pp) {
    this.customObjectFormatters_ = customObjectFormatters;
    this.ppNestLevel_ = 0;
    this.seen = [];
    this.length = 0;
    this.stringParts = [];
    this.pp_ = pp;
  }

  function hasCustomToString(value) {
    // value.toString !== Object.prototype.toString if value has no custom toString but is from another context (e.g.
    // iframe, web worker)
    try {
      return (
        j$.isFunction_(value.toString) &&
        value.toString !== Object.prototype.toString &&
        value.toString() !== Object.prototype.toString.call(value)
      );
    } catch (e) {
      // The custom toString() threw.
      return true;
    }
  }

  SinglePrettyPrintRun.prototype.format = function(value) {
    this.ppNestLevel_++;
    try {
      var customFormatResult = this.applyCustomFormatters_(value);

      if (customFormatResult) {
        this.emitScalar(customFormatResult);
      } else if (j$.util.isUndefined(value)) {
        this.emitScalar('undefined');
      } else if (value === null) {
        this.emitScalar('null');
      } else if (value === 0 && 1 / value === -Infinity) {
        this.emitScalar('-0');
      } else if (value === j$.getGlobal()) {
        this.emitScalar('<global>');
      } else if (value.jasmineToString) {
        this.emitScalar(value.jasmineToString(this.pp_));
      } else if (typeof value === 'string') {
        this.emitString(value);
      } else if (j$.isSpy(value)) {
        this.emitScalar('spy on ' + value.and.identity);
      } else if (j$.isSpy(value.toString)) {
        this.emitScalar('spy on ' + value.toString.and.identity);
      } else if (value instanceof RegExp) {
        this.emitScalar(value.toString());
      } else if (typeof value === 'function') {
        this.emitScalar('Function');
      } else if (j$.isDomNode(value)) {
        if (value.tagName) {
          this.emitDomElement(value);
        } else {
          this.emitScalar('HTMLNode');
        }
      } else if (value instanceof Date) {
        this.emitScalar('Date(' + value + ')');
      } else if (j$.isSet(value)) {
        this.emitSet(value);
      } else if (j$.isMap(value)) {
        this.emitMap(value);
      } else if (j$.isTypedArray_(value)) {
        this.emitTypedArray(value);
      } else if (
        value.toString &&
        typeof value === 'object' &&
        !j$.isArray_(value) &&
        hasCustomToString(value)
      ) {
        try {
          this.emitScalar(value.toString());
        } catch (e) {
          this.emitScalar('has-invalid-toString-method');
        }
      } else if (j$.util.arrayContains(this.seen, value)) {
        this.emitScalar(
          '<circular reference: ' +
            (j$.isArray_(value) ? 'Array' : 'Object') +
            '>'
        );
      } else if (j$.isArray_(value) || j$.isA_('Object', value)) {
        this.seen.push(value);
        if (j$.isArray_(value)) {
          this.emitArray(value);
        } else {
          this.emitObject(value);
        }
        this.seen.pop();
      } else {
        this.emitScalar(value.toString());
      }
    } catch (e) {
      if (this.ppNestLevel_ > 1 || !(e instanceof MaxCharsReachedError)) {
        throw e;
      }
    } finally {
      this.ppNestLevel_--;
    }
  };

  SinglePrettyPrintRun.prototype.applyCustomFormatters_ = function(value) {
    return customFormat(value, this.customObjectFormatters_);
  };

  SinglePrettyPrintRun.prototype.iterateObject = function(obj, fn) {
    var objKeys = keys(obj, j$.isArray_(obj));
    var isGetter = function isGetter(prop) {};

    if (obj.__lookupGetter__) {
      isGetter = function isGetter(prop) {
        var getter = obj.__lookupGetter__(prop);
        return !j$.util.isUndefined(getter) && getter !== null;
      };
    }
    var length = Math.min(objKeys.length, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);
    for (var i = 0; i < length; i++) {
      var property = objKeys[i];
      fn(property, isGetter(property));
    }

    return objKeys.length > length;
  };

  SinglePrettyPrintRun.prototype.emitScalar = function(value) {
    this.append(value);
  };

  SinglePrettyPrintRun.prototype.emitString = function(value) {
    this.append("'" + value + "'");
  };

  SinglePrettyPrintRun.prototype.emitArray = function(array) {
    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {
      this.append('Array');
      return;
    }
    var length = Math.min(array.length, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);
    this.append('[ ');
    for (var i = 0; i < length; i++) {
      if (i > 0) {
        this.append(', ');
      }
      this.format(array[i]);
    }
    if (array.length > length) {
      this.append(', ...');
    }

    var self = this;
    var first = array.length === 0;
    var truncated = this.iterateObject(array, function(property, isGetter) {
      if (first) {
        first = false;
      } else {
        self.append(', ');
      }

      self.formatProperty(array, property, isGetter);
    });

    if (truncated) {
      this.append(', ...');
    }

    this.append(' ]');
  };

  SinglePrettyPrintRun.prototype.emitSet = function(set) {
    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {
      this.append('Set');
      return;
    }
    this.append('Set( ');
    var size = Math.min(set.size, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);
    var i = 0;
    set.forEach(function(value, key) {
      if (i >= size) {
        return;
      }
      if (i > 0) {
        this.append(', ');
      }
      this.format(value);

      i++;
    }, this);
    if (set.size > size) {
      this.append(', ...');
    }
    this.append(' )');
  };

  SinglePrettyPrintRun.prototype.emitMap = function(map) {
    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {
      this.append('Map');
      return;
    }
    this.append('Map( ');
    var size = Math.min(map.size, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);
    var i = 0;
    map.forEach(function(value, key) {
      if (i >= size) {
        return;
      }
      if (i > 0) {
        this.append(', ');
      }
      this.format([key, value]);

      i++;
    }, this);
    if (map.size > size) {
      this.append(', ...');
    }
    this.append(' )');
  };

  SinglePrettyPrintRun.prototype.emitObject = function(obj) {
    var ctor = obj.constructor,
      constructorName;

    constructorName =
      typeof ctor === 'function' && obj instanceof ctor
        ? j$.fnNameFor(obj.constructor)
        : 'null';

    this.append(constructorName);

    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {
      return;
    }

    var self = this;
    this.append('({ ');
    var first = true;

    var truncated = this.iterateObject(obj, function(property, isGetter) {
      if (first) {
        first = false;
      } else {
        self.append(', ');
      }

      self.formatProperty(obj, property, isGetter);
    });

    if (truncated) {
      this.append(', ...');
    }

    this.append(' })');
  };

  SinglePrettyPrintRun.prototype.emitTypedArray = function(arr) {
    var constructorName = j$.fnNameFor(arr.constructor),
      limitedArray = Array.prototype.slice.call(
        arr,
        0,
        j$.MAX_PRETTY_PRINT_ARRAY_LENGTH
      ),
      itemsString = Array.prototype.join.call(limitedArray, ', ');

    if (limitedArray.length !== arr.length) {
      itemsString += ', ...';
    }

    this.append(constructorName + ' [ ' + itemsString + ' ]');
  };

  SinglePrettyPrintRun.prototype.emitDomElement = function(el) {
    var tagName = el.tagName.toLowerCase(),
      attrs = el.attributes,
      i,
      len = attrs.length,
      out = '<' + tagName,
      attr;

    for (i = 0; i < len; i++) {
      attr = attrs[i];
      out += ' ' + attr.name;

      if (attr.value !== '') {
        out += '="' + attr.value + '"';
      }
    }

    out += '>';

    if (el.childElementCount !== 0 || el.textContent !== '') {
      out += '...</' + tagName + '>';
    }

    this.append(out);
  };

  SinglePrettyPrintRun.prototype.formatProperty = function(
    obj,
    property,
    isGetter
  ) {
    this.append(property);
    this.append(': ');
    if (isGetter) {
      this.append('<getter>');
    } else {
      this.format(obj[property]);
    }
  };

  SinglePrettyPrintRun.prototype.append = function(value) {
    // This check protects us from the rare case where an object has overriden
    // `toString()` with an invalid implementation (returning a non-string).
    if (typeof value !== 'string') {
      value = Object.prototype.toString.call(value);
    }

    var result = truncate(value, j$.MAX_PRETTY_PRINT_CHARS - this.length);
    this.length += result.value.length;
    this.stringParts.push(result.value);

    if (result.truncated) {
      throw new MaxCharsReachedError();
    }
  };

  function truncate(s, maxlen) {
    if (s.length <= maxlen) {
      return { value: s, truncated: false };
    }

    s = s.substring(0, maxlen - 4) + ' ...';
    return { value: s, truncated: true };
  }

  function MaxCharsReachedError() {
    this.message =
      'Exceeded ' +
      j$.MAX_PRETTY_PRINT_CHARS +
      ' characters while pretty-printing a value';
  }

  MaxCharsReachedError.prototype = new Error();

  function keys(obj, isArray) {
    var allKeys = Object.keys
      ? Object.keys(obj)
      : (function(o) {
          var keys = [];
          for (var key in o) {
            if (j$.util.has(o, key)) {
              keys.push(key);
            }
          }
          return keys;
        })(obj);

    if (!isArray) {
      return allKeys;
    }

    if (allKeys.length === 0) {
      return allKeys;
    }

    var extraKeys = [];
    for (var i = 0; i < allKeys.length; i++) {
      if (!/^[0-9]+$/.test(allKeys[i])) {
        extraKeys.push(allKeys[i]);
      }
    }

    return extraKeys;
  }

  function customFormat(value, customObjectFormatters) {
    var i, result;

    for (i = 0; i < customObjectFormatters.length; i++) {
      result = customObjectFormatters[i](value);

      if (result !== undefined) {
        return result;
      }
    }
  }

  return function(customObjectFormatters) {
    customObjectFormatters = customObjectFormatters || [];

    var pp = function(value) {
      var prettyPrinter = new SinglePrettyPrintRun(customObjectFormatters, pp);
      prettyPrinter.format(value);
      return prettyPrinter.stringParts.join('');
    };

    pp.customFormat_ = function(value) {
      return customFormat(value, customObjectFormatters);
    };

    return pp;
  };
};

getJasmineRequireObj().QueueRunner = function(j$) {
  var nextid = 1;

  function StopExecutionError() {}
  StopExecutionError.prototype = new Error();
  j$.StopExecutionError = StopExecutionError;

  function once(fn, onTwice) {
    var called = false;
    return function(arg) {
      if (called) {
        if (onTwice) {
          onTwice();
        }
      } else {
        called = true;
        // Direct call using single parameter, because cleanup/next does not need more
        fn(arg);
      }
      return null;
    };
  }

  function fallbackOnMultipleDone() {
    console.error(
      new Error(
        "An asynchronous function called its 'done' " +
          'callback more than once, in a QueueRunner without a onMultipleDone ' +
          'handler.'
      )
    );
  }

  function emptyFn() {}

  function QueueRunner(attrs) {
    this.id_ = nextid++;
    this.queueableFns = attrs.queueableFns || [];
    this.onComplete = attrs.onComplete || emptyFn;
    this.clearStack =
      attrs.clearStack ||
      function(fn) {
        fn();
      };
    this.onException = attrs.onException || emptyFn;
    this.onMultipleDone = attrs.onMultipleDone || fallbackOnMultipleDone;
    this.userContext = attrs.userContext || new j$.UserContext();
    this.timeout = attrs.timeout || {
      setTimeout: setTimeout,
      clearTimeout: clearTimeout
    };
    this.fail = attrs.fail || emptyFn;
    this.globalErrors = attrs.globalErrors || {
      pushListener: emptyFn,
      popListener: emptyFn
    };

    const SkipPolicy = attrs.SkipPolicy || j$.NeverSkipPolicy;
    this.skipPolicy_ = new SkipPolicy(this.queueableFns);
    this.errored_ = false;

    if (typeof this.onComplete !== 'function') {
      throw new Error('invalid onComplete ' + JSON.stringify(this.onComplete));
    }
    this.deprecated = attrs.deprecated;
  }

  QueueRunner.prototype.execute = function() {
    var self = this;
    this.handleFinalError = function(message, source, lineno, colno, error) {
      // Older browsers would send the error as the first parameter. HTML5
      // specifies the the five parameters above. The error instance should
      // be preffered, otherwise the call stack would get lost.
      self.onException(error || message);
    };
    this.globalErrors.pushListener(this.handleFinalError);
    this.run(0);
  };

  QueueRunner.prototype.clearTimeout = function(timeoutId) {
    Function.prototype.apply.apply(this.timeout.clearTimeout, [
      j$.getGlobal(),
      [timeoutId]
    ]);
  };

  QueueRunner.prototype.setTimeout = function(fn, timeout) {
    return Function.prototype.apply.apply(this.timeout.setTimeout, [
      j$.getGlobal(),
      [fn, timeout]
    ]);
  };

  QueueRunner.prototype.attempt = function attempt(iterativeIndex) {
    var self = this,
      completedSynchronously = true,
      handleError = function handleError(error) {
        // TODO probably shouldn't next() right away here.
        // That makes debugging async failures much more confusing.
        onException(error);
      },
      cleanup = once(function cleanup() {
        if (timeoutId !== void 0) {
          self.clearTimeout(timeoutId);
        }
        self.globalErrors.popListener(handleError);
      }),
      next = once(
        function next(err) {
          cleanup();

          if (typeof err !== 'undefined') {
            if (!(err instanceof StopExecutionError) && !err.jasmineMessage) {
              self.fail(err);
            }
            self.recordError_(iterativeIndex);
          }

          function runNext() {
            self.run(self.nextFnIx_(iterativeIndex));
          }

          if (completedSynchronously) {
            self.setTimeout(runNext);
          } else {
            runNext();
          }
        },
        function() {
          try {
            if (!timedOut) {
              self.onMultipleDone();
            }
          } catch (error) {
            // Any error we catch here is probably due to a bug in Jasmine,
            // and it's not likely to end up anywhere useful if we let it
            // propagate. Log it so it can at least show up when debugging.
            console.error(error);
          }
        }
      ),
      timedOut = false,
      queueableFn = self.queueableFns[iterativeIndex],
      timeoutId,
      maybeThenable;

    next.fail = function nextFail() {
      self.fail.apply(null, arguments);
      self.recordError_(iterativeIndex);
      next();
    };

    self.globalErrors.pushListener(handleError);

    if (queueableFn.timeout !== undefined) {
      var timeoutInterval = queueableFn.timeout || j$.DEFAULT_TIMEOUT_INTERVAL;
      timeoutId = self.setTimeout(function() {
        timedOut = true;
        var error = new Error(
          'Timeout - Async function did not complete within ' +
            timeoutInterval +
            'ms ' +
            (queueableFn.timeout
              ? '(custom timeout)'
              : '(set by jasmine.DEFAULT_TIMEOUT_INTERVAL)')
        );
        // TODO Need to decide what to do about a successful completion after a
        //   timeout. That should probably not be a deprecation, and maybe not
        //   an error in 4.0. (But a diagnostic of some sort might be helpful.)
        onException(error);
        next();
      }, timeoutInterval);
    }

    try {
      if (queueableFn.fn.length === 0) {
        maybeThenable = queueableFn.fn.call(self.userContext);

        if (maybeThenable && j$.isFunction_(maybeThenable.then)) {
          maybeThenable.then(
            wrapInPromiseResolutionHandler(next),
            onPromiseRejection
          );
          completedSynchronously = false;
          return { completedSynchronously: false };
        }
      } else {
        maybeThenable = queueableFn.fn.call(self.userContext, next);
        this.diagnoseConflictingAsync_(queueableFn.fn, maybeThenable);
        completedSynchronously = false;
        return { completedSynchronously: false };
      }
    } catch (e) {
      onException(e);
      self.recordError_(iterativeIndex);
    }

    cleanup();
    return { completedSynchronously: true };

    function onException(e) {
      self.onException(e);
      self.recordError_(iterativeIndex);
    }

    function onPromiseRejection(e) {
      onException(e);
      next();
    }
  };

  QueueRunner.prototype.run = function(recursiveIndex) {
    var length = this.queueableFns.length,
      self = this,
      iterativeIndex;

    for (
      iterativeIndex = recursiveIndex;
      iterativeIndex < length;
      iterativeIndex = this.nextFnIx_(iterativeIndex)
    ) {
      var result = this.attempt(iterativeIndex);

      if (!result.completedSynchronously) {
        return;
      }
    }

    this.clearStack(function() {
      self.globalErrors.popListener(self.handleFinalError);

      if (self.errored_) {
        self.onComplete(new StopExecutionError());
      } else {
        self.onComplete();
      }
    });
  };

  QueueRunner.prototype.nextFnIx_ = function(currentFnIx) {
    const result = this.skipPolicy_.skipTo(currentFnIx);

    if (result === currentFnIx) {
      throw new Error("Can't skip to the same queueable fn that just finished");
    }

    return result;
  };

  QueueRunner.prototype.recordError_ = function(currentFnIx) {
    this.errored_ = true;
    this.skipPolicy_.fnErrored(currentFnIx);
  };

  QueueRunner.prototype.diagnoseConflictingAsync_ = function(fn, retval) {
    var msg;

    if (retval && j$.isFunction_(retval.then)) {
      // Issue a warning that matches the user's code.
      // Omit the stack trace because there's almost certainly no user code
      // on the stack at this point.
      if (j$.isAsyncFunction_(fn)) {
        this.onException(
          'An asynchronous before/it/after ' +
            'function was defined with the async keyword but also took a ' +
            'done callback. Either remove the done callback (recommended) or ' +
            'remove the async keyword.'
        );
      } else {
        this.onException(
          'An asynchronous before/it/after ' +
            'function took a done callback but also returned a promise. ' +
            'Either remove the done callback (recommended) or change the ' +
            'function to not return a promise.'
        );
      }

      this.deprecated(msg, { omitStackTrace: true });
    }
  };

  function wrapInPromiseResolutionHandler(fn) {
    return function(maybeArg) {
      if (j$.isError_(maybeArg)) {
        fn(maybeArg);
      } else {
        fn();
      }
    };
  }

  return QueueRunner;
};

getJasmineRequireObj().ReportDispatcher = function(j$) {
  function ReportDispatcher(methods, queueRunnerFactory, onLateError) {
    var dispatchedMethods = methods || [];

    for (var i = 0; i < dispatchedMethods.length; i++) {
      var method = dispatchedMethods[i];
      this[method] = (function(m) {
        return function() {
          dispatch(m, arguments);
        };
      })(method);
    }

    var reporters = [];
    var fallbackReporter = null;

    this.addReporter = function(reporter) {
      reporters.push(reporter);
    };

    this.provideFallbackReporter = function(reporter) {
      fallbackReporter = reporter;
    };

    this.clearReporters = function() {
      reporters = [];
    };

    return this;

    function dispatch(method, args) {
      if (reporters.length === 0 && fallbackReporter !== null) {
        reporters.push(fallbackReporter);
      }
      var onComplete = args[args.length - 1];
      args = j$.util.argsToArray(args).splice(0, args.length - 1);
      var fns = [];
      for (var i = 0; i < reporters.length; i++) {
        var reporter = reporters[i];
        addFn(fns, reporter, method, args);
      }

      queueRunnerFactory({
        queueableFns: fns,
        onComplete: onComplete,
        isReporter: true,
        onMultipleDone: function() {
          onLateError(
            new Error(
              "An asynchronous reporter callback called its 'done' callback " +
                'more than once.'
            )
          );
        }
      });
    }

    function addFn(fns, reporter, method, args) {
      var fn = reporter[method];
      if (!fn) {
        return;
      }

      var thisArgs = j$.util.cloneArgs(args);
      if (fn.length <= 1) {
        fns.push({
          fn: function() {
            return fn.apply(reporter, thisArgs);
          }
        });
      } else {
        fns.push({
          fn: function(done) {
            return fn.apply(reporter, thisArgs.concat([done]));
          }
        });
      }
    }
  }

  return ReportDispatcher;
};

getJasmineRequireObj().interface = function(jasmine, env) {
  var jasmineInterface = {
    /**
     * Callback passed to parts of the Jasmine base interface.
     *
     * By default Jasmine assumes this function completes synchronously.
     * If you have code that you need to test asynchronously, you can declare that you receive a `done` callback, return a Promise, or use the `async` keyword if it is supported in your environment.
     * @callback implementationCallback
     * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.
     * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.
     */

    /**
     * Create a group of specs (often called a suite).
     *
     * Calls to `describe` can be nested within other calls to compose your suite as a tree.
     * @name describe
     * @since 1.3.0
     * @function
     * @global
     * @param {String} description Textual description of the group
     * @param {Function} specDefinitions Function for Jasmine to invoke that will define inner suites and specs
     */
    describe: function(description, specDefinitions) {
      return env.describe(description, specDefinitions);
    },

    /**
     * A temporarily disabled [`describe`]{@link describe}
     *
     * Specs within an `xdescribe` will be marked pending and not executed
     * @name xdescribe
     * @since 1.3.0
     * @function
     * @global
     * @param {String} description Textual description of the group
     * @param {Function} specDefinitions Function for Jasmine to invoke that will define inner suites and specs
     */
    xdescribe: function(description, specDefinitions) {
      return env.xdescribe(description, specDefinitions);
    },

    /**
     * A focused [`describe`]{@link describe}
     *
     * If suites or specs are focused, only those that are focused will be executed
     * @see fit
     * @name fdescribe
     * @since 2.1.0
     * @function
     * @global
     * @param {String} description Textual description of the group
     * @param {Function} specDefinitions Function for Jasmine to invoke that will define inner suites and specs
     */
    fdescribe: function(description, specDefinitions) {
      return env.fdescribe(description, specDefinitions);
    },

    /**
     * Define a single spec. A spec should contain one or more {@link expect|expectations} that test the state of the code.
     *
     * A spec whose expectations all succeed will be passing and a spec with any failures will fail.
     * The name `it` is a pronoun for the test target, not an abbreviation of anything. It makes the
     * spec more readable by connecting the function name `it` and the argument `description` as a
     * complete sentence.
     * @name it
     * @since 1.3.0
     * @function
     * @global
     * @param {String} description Textual description of what this spec is checking
     * @param {implementationCallback} [testFunction] Function that contains the code of your test. If not provided the test will be `pending`.
     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async spec.
     * @see async
     */
    it: function() {
      return env.it.apply(env, arguments);
    },

    /**
     * A temporarily disabled [`it`]{@link it}
     *
     * The spec will report as `pending` and will not be executed.
     * @name xit
     * @since 1.3.0
     * @function
     * @global
     * @param {String} description Textual description of what this spec is checking.
     * @param {implementationCallback} [testFunction] Function that contains the code of your test. Will not be executed.
     */
    xit: function() {
      return env.xit.apply(env, arguments);
    },

    /**
     * A focused [`it`]{@link it}
     *
     * If suites or specs are focused, only those that are focused will be executed.
     * @name fit
     * @since 2.1.0
     * @function
     * @global
     * @param {String} description Textual description of what this spec is checking.
     * @param {implementationCallback} testFunction Function that contains the code of your test.
     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async spec.
     * @see async
     */
    fit: function() {
      return env.fit.apply(env, arguments);
    },

    /**
     * Run some shared setup before each of the specs in the {@link describe} in which it is called.
     * @name beforeEach
     * @since 1.3.0
     * @function
     * @global
     * @param {implementationCallback} [function] Function that contains the code to setup your specs.
     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async beforeEach.
     * @see async
     */
    beforeEach: function() {
      return env.beforeEach.apply(env, arguments);
    },

    /**
     * Run some shared teardown after each of the specs in the {@link describe} in which it is called.
     * @name afterEach
     * @since 1.3.0
     * @function
     * @global
     * @param {implementationCallback} [function] Function that contains the code to teardown your specs.
     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async afterEach.
     * @see async
     */
    afterEach: function() {
      return env.afterEach.apply(env, arguments);
    },

    /**
     * Run some shared setup once before all of the specs in the {@link describe} are run.
     *
     * _Note:_ Be careful, sharing the setup from a beforeAll makes it easy to accidentally leak state between your specs so that they erroneously pass or fail.
     * @name beforeAll
     * @since 2.1.0
     * @function
     * @global
     * @param {implementationCallback} [function] Function that contains the code to setup your specs.
     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async beforeAll.
     * @see async
     */
    beforeAll: function() {
      return env.beforeAll.apply(env, arguments);
    },

    /**
     * Run some shared teardown once after all of the specs in the {@link describe} are run.
     *
     * _Note:_ Be careful, sharing the teardown from a afterAll makes it easy to accidentally leak state between your specs so that they erroneously pass or fail.
     * @name afterAll
     * @since 2.1.0
     * @function
     * @global
     * @param {implementationCallback} [function] Function that contains the code to teardown your specs.
     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async afterAll.
     * @see async
     */
    afterAll: function() {
      return env.afterAll.apply(env, arguments);
    },

    /**
     * Sets a user-defined property that will be provided to reporters as part of the properties field of {@link SpecResult}
     * @name setSpecProperty
     * @since 3.6.0
     * @function
     * @param {String} key The name of the property
     * @param {*} value The value of the property
     */
    setSpecProperty: function(key, value) {
      return env.setSpecProperty(key, value);
    },

    /**
     * Sets a user-defined property that will be provided to reporters as part of the properties field of {@link SuiteResult}
     * @name setSuiteProperty
     * @since 3.6.0
     * @function
     * @param {String} key The name of the property
     * @param {*} value The value of the property
     */
    setSuiteProperty: function(key, value) {
      return env.setSuiteProperty(key, value);
    },

    /**
     * Create an expectation for a spec.
     * @name expect
     * @since 1.3.0
     * @function
     * @global
     * @param {Object} actual - Actual computed value to test expectations against.
     * @return {matchers}
     */
    expect: function(actual) {
      return env.expect(actual);
    },

    /**
     * Create an asynchronous expectation for a spec. Note that the matchers
     * that are provided by an asynchronous expectation all return promises
     * which must be either returned from the spec or waited for using `await`
     * in order for Jasmine to associate them with the correct spec.
     * @name expectAsync
     * @since 3.3.0
     * @function
     * @global
     * @param {Object} actual - Actual computed value to test expectations against.
     * @return {async-matchers}
     * @example
     * await expectAsync(somePromise).toBeResolved();
     * @example
     * return expectAsync(somePromise).toBeResolved();
     */
    expectAsync: function(actual) {
      return env.expectAsync(actual);
    },

    /**
     * Mark a spec as pending, expectation results will be ignored.
     * @name pending
     * @since 2.0.0
     * @function
     * @global
     * @param {String} [message] - Reason the spec is pending.
     */
    pending: function() {
      return env.pending.apply(env, arguments);
    },

    /**
     * Explicitly mark a spec as failed.
     * @name fail
     * @since 2.1.0
     * @function
     * @global
     * @param {String|Error} [error] - Reason for the failure.
     */
    fail: function() {
      return env.fail.apply(env, arguments);
    },

    /**
     * Install a spy onto an existing object.
     * @name spyOn
     * @since 1.3.0
     * @function
     * @global
     * @param {Object} obj - The object upon which to install the {@link Spy}.
     * @param {String} methodName - The name of the method to replace with a {@link Spy}.
     * @returns {Spy}
     */
    spyOn: function(obj, methodName) {
      return env.spyOn(obj, methodName);
    },

    /**
     * Install a spy on a property installed with `Object.defineProperty` onto an existing object.
     * @name spyOnProperty
     * @since 2.6.0
     * @function
     * @global
     * @param {Object} obj - The object upon which to install the {@link Spy}
     * @param {String} propertyName - The name of the property to replace with a {@link Spy}.
     * @param {String} [accessType=get] - The access type (get|set) of the property to {@link Spy} on.
     * @returns {Spy}
     */
    spyOnProperty: function(obj, methodName, accessType) {
      return env.spyOnProperty(obj, methodName, accessType);
    },

    /**
     * Installs spies on all writable and configurable properties of an object.
     * @name spyOnAllFunctions
     * @since 3.2.1
     * @function
     * @global
     * @param {Object} obj - The object upon which to install the {@link Spy}s
     * @param {boolean} includeNonEnumerable - Whether or not to add spies to non-enumerable properties
     * @returns {Object} the spied object
     */
    spyOnAllFunctions: function(obj, includeNonEnumerable) {
      return env.spyOnAllFunctions(obj, includeNonEnumerable);
    },

    jsApiReporter: new jasmine.JsApiReporter({
      timer: new jasmine.Timer()
    }),

    /**
     * @namespace jasmine
     */
    jasmine: jasmine
  };

  /**
   * Add a custom equality tester for the current scope of specs.
   *
   * _Note:_ This is only callable from within a {@link beforeEach}, {@link it}, or {@link beforeAll}.
   * @name jasmine.addCustomEqualityTester
   * @since 2.0.0
   * @function
   * @param {Function} tester - A function which takes two arguments to compare and returns a `true` or `false` comparison result if it knows how to compare them, and `undefined` otherwise.
   * @see custom_equality
   */
  jasmine.addCustomEqualityTester = function(tester) {
    env.addCustomEqualityTester(tester);
  };

  /**
   * Add custom matchers for the current scope of specs.
   *
   * _Note:_ This is only callable from within a {@link beforeEach}, {@link it}, or {@link beforeAll}.
   * @name jasmine.addMatchers
   * @since 2.0.0
   * @function
   * @param {Object} matchers - Keys from this object will be the new matcher names.
   * @see custom_matcher
   */
  jasmine.addMatchers = function(matchers) {
    return env.addMatchers(matchers);
  };

  /**
   * Add custom async matchers for the current scope of specs.
   *
   * _Note:_ This is only callable from within a {@link beforeEach}, {@link it}, or {@link beforeAll}.
   * @name jasmine.addAsyncMatchers
   * @since 3.5.0
   * @function
   * @param {Object} matchers - Keys from this object will be the new async matcher names.
   * @see custom_matcher
   */
  jasmine.addAsyncMatchers = function(matchers) {
    return env.addAsyncMatchers(matchers);
  };

  /**
   * Add a custom object formatter for the current scope of specs.
   *
   * _Note:_ This is only callable from within a {@link beforeEach}, {@link it}, or {@link beforeAll}.
   * @name jasmine.addCustomObjectFormatter
   * @since 3.6.0
   * @function
   * @param {Function} formatter - A function which takes a value to format and returns a string if it knows how to format it, and `undefined` otherwise.
   * @see custom_object_formatters
   */
  jasmine.addCustomObjectFormatter = function(formatter) {
    return env.addCustomObjectFormatter(formatter);
  };

  /**
   * Get the currently booted mock {Clock} for this Jasmine environment.
   * @name jasmine.clock
   * @since 2.0.0
   * @function
   * @returns {Clock}
   */
  jasmine.clock = function() {
    return env.clock;
  };

  /**
   * Create a bare {@link Spy} object. This won't be installed anywhere and will not have any implementation behind it.
   * @name jasmine.createSpy
   * @since 1.3.0
   * @function
   * @param {String} [name] - Name to give the spy. This will be displayed in failure messages.
   * @param {Function} [originalFn] - Function to act as the real implementation.
   * @return {Spy}
   */
  jasmine.createSpy = function(name, originalFn) {
    return env.createSpy(name, originalFn);
  };

  /**
   * Create an object with multiple {@link Spy}s as its members.
   * @name jasmine.createSpyObj
   * @since 1.3.0
   * @function
   * @param {String} [baseName] - Base name for the spies in the object.
   * @param {String[]|Object} methodNames - Array of method names to create spies for, or Object whose keys will be method names and values the {@link Spy#and#returnValue|returnValue}.
   * @param {String[]|Object} [propertyNames] - Array of property names to create spies for, or Object whose keys will be propertynames and values the {@link Spy#and#returnValue|returnValue}.
   * @return {Object}
   */
  jasmine.createSpyObj = function(baseName, methodNames, propertyNames) {
    return env.createSpyObj(baseName, methodNames, propertyNames);
  };

  /**
   * Add a custom spy strategy for the current scope of specs.
   *
   * _Note:_ This is only callable from within a {@link beforeEach}, {@link it}, or {@link beforeAll}.
   * @name jasmine.addSpyStrategy
   * @since 3.5.0
   * @function
   * @param {String} name - The name of the strategy (i.e. what you call from `and`)
   * @param {Function} factory - Factory function that returns the plan to be executed.
   */
  jasmine.addSpyStrategy = function(name, factory) {
    return env.addSpyStrategy(name, factory);
  };

  /**
   * Set the default spy strategy for the current scope of specs.
   *
   * _Note:_ This is only callable from within a {@link beforeEach}, {@link it}, or {@link beforeAll}.
   * @name jasmine.setDefaultSpyStrategy
   * @function
   * @param {Function} defaultStrategyFn - a function that assigns a strategy
   * @example
   * beforeEach(function() {
   *   jasmine.setDefaultSpyStrategy(and => and.returnValue(true));
   * });
   */
  jasmine.setDefaultSpyStrategy = function(defaultStrategyFn) {
    return env.setDefaultSpyStrategy(defaultStrategyFn);
  };

  return jasmineInterface;
};

getJasmineRequireObj().SkipAfterBeforeAllErrorPolicy = function(j$) {
  function SkipAfterBeforeAllErrorPolicy(queueableFns) {
    this.queueableFns_ = queueableFns;
    this.skipping_ = false;
  }

  SkipAfterBeforeAllErrorPolicy.prototype.skipTo = function(lastRanFnIx) {
    if (this.skipping_) {
      return this.nextAfterAllAfter_(lastRanFnIx);
    } else {
      return lastRanFnIx + 1;
    }
  };

  SkipAfterBeforeAllErrorPolicy.prototype.nextAfterAllAfter_ = function(i) {
    for (
      i++;
      i < this.queueableFns_.length &&
      this.queueableFns_[i].type !== 'afterAll';
      i++
    ) {}
    return i;
  };

  SkipAfterBeforeAllErrorPolicy.prototype.fnErrored = function(fnIx) {
    if (this.queueableFns_[fnIx].type === 'beforeAll') {
      this.skipping_ = true;
      // Failures need to be reported for each contained spec. But we can't do
      // that from here because reporting is async. This function isn't async
      // (and can't be without greatly complicating QueueRunner). Mark the
      // failure so that the code that reports the suite result (which is
      // already async) can detect the failure and report the specs.
      this.queueableFns_[fnIx].suite.hadBeforeAllFailure = true;
    }
  };

  return SkipAfterBeforeAllErrorPolicy;
};

getJasmineRequireObj().Spy = function(j$) {
  var nextOrder = (function() {
    var order = 0;

    return function() {
      return order++;
    };
  })();

  /**
   * @classdesc _Note:_ Do not construct this directly. Use {@link spyOn},
   * {@link spyOnProperty}, {@link jasmine.createSpy}, or
   * {@link jasmine.createSpyObj} instead.
   * @class Spy
   * @hideconstructor
   */
  function Spy(name, matchersUtil, optionals) {
    const { originalFn, customStrategies, defaultStrategyFn } = optionals || {};

    var numArgs = typeof originalFn === 'function' ? originalFn.length : 0,
      wrapper = makeFunc(numArgs, function(context, args, invokeNew) {
        return spy(context, args, invokeNew);
      }),
      strategyDispatcher = new SpyStrategyDispatcher(
        {
          name: name,
          fn: originalFn,
          getSpy: function() {
            return wrapper;
          },
          customStrategies: customStrategies
        },
        matchersUtil
      ),
      callTracker = new j$.CallTracker(),
      spy = function(context, args, invokeNew) {
        /**
         * @name Spy.callData
         * @property {object} object - `this` context for the invocation.
         * @property {number} invocationOrder - Order of the invocation.
         * @property {Array} args - The arguments passed for this invocation.
         * @property returnValue - The value that was returned from this invocation.
         */
        var callData = {
          object: context,
          invocationOrder: nextOrder(),
          args: Array.prototype.slice.apply(args)
        };

        callTracker.track(callData);
        var returnValue = strategyDispatcher.exec(context, args, invokeNew);
        callData.returnValue = returnValue;

        return returnValue;
      };

    function makeFunc(length, fn) {
      switch (length) {
        case 1:
          return function wrap1(a) {
            return fn(this, arguments, this instanceof wrap1);
          };
        case 2:
          return function wrap2(a, b) {
            return fn(this, arguments, this instanceof wrap2);
          };
        case 3:
          return function wrap3(a, b, c) {
            return fn(this, arguments, this instanceof wrap3);
          };
        case 4:
          return function wrap4(a, b, c, d) {
            return fn(this, arguments, this instanceof wrap4);
          };
        case 5:
          return function wrap5(a, b, c, d, e) {
            return fn(this, arguments, this instanceof wrap5);
          };
        case 6:
          return function wrap6(a, b, c, d, e, f) {
            return fn(this, arguments, this instanceof wrap6);
          };
        case 7:
          return function wrap7(a, b, c, d, e, f, g) {
            return fn(this, arguments, this instanceof wrap7);
          };
        case 8:
          return function wrap8(a, b, c, d, e, f, g, h) {
            return fn(this, arguments, this instanceof wrap8);
          };
        case 9:
          return function wrap9(a, b, c, d, e, f, g, h, i) {
            return fn(this, arguments, this instanceof wrap9);
          };
        default:
          return function wrap() {
            return fn(this, arguments, this instanceof wrap);
          };
      }
    }

    for (var prop in originalFn) {
      if (prop === 'and' || prop === 'calls') {
        throw new Error(
          "Jasmine spies would overwrite the 'and' and 'calls' properties on the object being spied upon"
        );
      }

      wrapper[prop] = originalFn[prop];
    }

    /**
     * @member {SpyStrategy} - Accesses the default strategy for the spy. This strategy will be used
     * whenever the spy is called with arguments that don't match any strategy
     * created with {@link Spy#withArgs}.
     * @name Spy#and
     * @since 2.0.0
     * @example
     * spyOn(someObj, 'func').and.returnValue(42);
     */
    wrapper.and = strategyDispatcher.and;
    /**
     * Specifies a strategy to be used for calls to the spy that have the
     * specified arguments.
     * @name Spy#withArgs
     * @since 3.0.0
     * @function
     * @param {...*} args - The arguments to match
     * @type {SpyStrategy}
     * @example
     * spyOn(someObj, 'func').withArgs(1, 2, 3).and.returnValue(42);
     * someObj.func(1, 2, 3); // returns 42
     */
    wrapper.withArgs = function() {
      return strategyDispatcher.withArgs.apply(strategyDispatcher, arguments);
    };
    wrapper.calls = callTracker;

    if (defaultStrategyFn) {
      defaultStrategyFn(wrapper.and);
    }

    return wrapper;
  }

  function SpyStrategyDispatcher(strategyArgs, matchersUtil) {
    var baseStrategy = new j$.SpyStrategy(strategyArgs);
    var argsStrategies = new StrategyDict(function() {
      return new j$.SpyStrategy(strategyArgs);
    }, matchersUtil);

    this.and = baseStrategy;

    this.exec = function(spy, args, invokeNew) {
      var strategy = argsStrategies.get(args);

      if (!strategy) {
        if (argsStrategies.any() && !baseStrategy.isConfigured()) {
          throw new Error(
            "Spy '" +
              strategyArgs.name +
              "' received a call with arguments " +
              j$.basicPrettyPrinter_(Array.prototype.slice.call(args)) +
              ' but all configured strategies specify other arguments.'
          );
        } else {
          strategy = baseStrategy;
        }
      }

      return strategy.exec(spy, args, invokeNew);
    };

    this.withArgs = function() {
      return { and: argsStrategies.getOrCreate(arguments) };
    };
  }

  function StrategyDict(strategyFactory, matchersUtil) {
    this.strategies = [];
    this.strategyFactory = strategyFactory;
    this.matchersUtil = matchersUtil;
  }

  StrategyDict.prototype.any = function() {
    return this.strategies.length > 0;
  };

  StrategyDict.prototype.getOrCreate = function(args) {
    var strategy = this.get(args);

    if (!strategy) {
      strategy = this.strategyFactory();
      this.strategies.push({
        args: args,
        strategy: strategy
      });
    }

    return strategy;
  };

  StrategyDict.prototype.get = function(args) {
    var i;

    for (i = 0; i < this.strategies.length; i++) {
      if (this.matchersUtil.equals(args, this.strategies[i].args)) {
        return this.strategies[i].strategy;
      }
    }
  };

  return Spy;
};

getJasmineRequireObj().SpyFactory = function(j$) {
  function SpyFactory(
    getCustomStrategies,
    getDefaultStrategyFn,
    getMatchersUtil
  ) {
    var self = this;

    this.createSpy = function(name, originalFn) {
      return j$.Spy(name, getMatchersUtil(), {
        originalFn,
        customStrategies: getCustomStrategies(),
        defaultStrategyFn: getDefaultStrategyFn()
      });
    };

    this.createSpyObj = function(baseName, methodNames, propertyNames) {
      var baseNameIsCollection =
        j$.isObject_(baseName) || j$.isArray_(baseName);

      if (baseNameIsCollection) {
        propertyNames = methodNames;
        methodNames = baseName;
        baseName = 'unknown';
      }

      var obj = {};
      var spy, descriptor;

      var methods = normalizeKeyValues(methodNames);
      for (var i = 0; i < methods.length; i++) {
        spy = obj[methods[i][0]] = self.createSpy(
          baseName + '.' + methods[i][0]
        );
        if (methods[i].length > 1) {
          spy.and.returnValue(methods[i][1]);
        }
      }

      var properties = normalizeKeyValues(propertyNames);
      for (var i = 0; i < properties.length; i++) {
        descriptor = {
          enumerable: true,
          get: self.createSpy(baseName + '.' + properties[i][0] + '.get'),
          set: self.createSpy(baseName + '.' + properties[i][0] + '.set')
        };
        if (properties[i].length > 1) {
          descriptor.get.and.returnValue(properties[i][1]);
          descriptor.set.and.returnValue(properties[i][1]);
        }
        Object.defineProperty(obj, properties[i][0], descriptor);
      }

      if (methods.length === 0 && properties.length === 0) {
        throw 'createSpyObj requires a non-empty array or object of method names to create spies for';
      }

      return obj;
    };
  }

  function normalizeKeyValues(object) {
    var result = [];
    if (j$.isArray_(object)) {
      for (var i = 0; i < object.length; i++) {
        result.push([object[i]]);
      }
    } else if (j$.isObject_(object)) {
      for (var key in object) {
        if (object.hasOwnProperty(key)) {
          result.push([key, object[key]]);
        }
      }
    }
    return result;
  }

  return SpyFactory;
};

getJasmineRequireObj().SpyRegistry = function(j$) {
  var spyOnMsg = j$.formatErrorMsg('<spyOn>', 'spyOn(<object>, <methodName>)');
  var spyOnPropertyMsg = j$.formatErrorMsg(
    '<spyOnProperty>',
    'spyOnProperty(<object>, <propName>, [accessType])'
  );

  function SpyRegistry(options) {
    options = options || {};
    var global = options.global || j$.getGlobal();
    var createSpy = options.createSpy;
    var currentSpies =
      options.currentSpies ||
      function() {
        return [];
      };

    this.allowRespy = function(allow) {
      this.respy = allow;
    };

    this.spyOn = function(obj, methodName) {
      var getErrorMsg = spyOnMsg;

      if (j$.util.isUndefined(obj) || obj === null) {
        throw new Error(
          getErrorMsg(
            'could not find an object to spy upon for ' + methodName + '()'
          )
        );
      }

      if (j$.util.isUndefined(methodName) || methodName === null) {
        throw new Error(getErrorMsg('No method name supplied'));
      }

      if (j$.util.isUndefined(obj[methodName])) {
        throw new Error(getErrorMsg(methodName + '() method does not exist'));
      }

      if (obj[methodName] && j$.isSpy(obj[methodName])) {
        if (this.respy) {
          return obj[methodName];
        } else {
          throw new Error(
            getErrorMsg(methodName + ' has already been spied upon')
          );
        }
      }

      var descriptor = Object.getOwnPropertyDescriptor(obj, methodName);

      if (descriptor && !(descriptor.writable || descriptor.set)) {
        throw new Error(
          getErrorMsg(methodName + ' is not declared writable or has no setter')
        );
      }

      var originalMethod = obj[methodName],
        spiedMethod = createSpy(methodName, originalMethod),
        restoreStrategy;

      if (
        Object.prototype.hasOwnProperty.call(obj, methodName) ||
        (obj === global && methodName === 'onerror')
      ) {
        restoreStrategy = function() {
          obj[methodName] = originalMethod;
        };
      } else {
        restoreStrategy = function() {
          if (!delete obj[methodName]) {
            obj[methodName] = originalMethod;
          }
        };
      }

      currentSpies().push({
        restoreObjectToOriginalState: restoreStrategy
      });

      obj[methodName] = spiedMethod;

      return spiedMethod;
    };

    this.spyOnProperty = function(obj, propertyName, accessType) {
      var getErrorMsg = spyOnPropertyMsg;

      accessType = accessType || 'get';

      if (j$.util.isUndefined(obj)) {
        throw new Error(
          getErrorMsg(
            'spyOn could not find an object to spy upon for ' +
              propertyName +
              ''
          )
        );
      }

      if (j$.util.isUndefined(propertyName)) {
        throw new Error(getErrorMsg('No property name supplied'));
      }

      var descriptor = j$.util.getPropertyDescriptor(obj, propertyName);

      if (!descriptor) {
        throw new Error(getErrorMsg(propertyName + ' property does not exist'));
      }

      if (!descriptor.configurable) {
        throw new Error(
          getErrorMsg(propertyName + ' is not declared configurable')
        );
      }

      if (!descriptor[accessType]) {
        throw new Error(
          getErrorMsg(
            'Property ' +
              propertyName +
              ' does not have access type ' +
              accessType
          )
        );
      }

      if (j$.isSpy(descriptor[accessType])) {
        if (this.respy) {
          return descriptor[accessType];
        } else {
          throw new Error(
            getErrorMsg(
              propertyName + '#' + accessType + ' has already been spied upon'
            )
          );
        }
      }

      var originalDescriptor = j$.util.clone(descriptor),
        spy = createSpy(propertyName, descriptor[accessType]),
        restoreStrategy;

      if (Object.prototype.hasOwnProperty.call(obj, propertyName)) {
        restoreStrategy = function() {
          Object.defineProperty(obj, propertyName, originalDescriptor);
        };
      } else {
        restoreStrategy = function() {
          delete obj[propertyName];
        };
      }

      currentSpies().push({
        restoreObjectToOriginalState: restoreStrategy
      });

      descriptor[accessType] = spy;

      Object.defineProperty(obj, propertyName, descriptor);

      return spy;
    };

    this.spyOnAllFunctions = function(obj, includeNonEnumerable) {
      if (j$.util.isUndefined(obj)) {
        throw new Error(
          'spyOnAllFunctions could not find an object to spy upon'
        );
      }

      var pointer = obj,
        propsToSpyOn = [],
        properties,
        propertiesToSkip = [];

      while (
        pointer &&
        (!includeNonEnumerable || pointer !== Object.prototype)
      ) {
        properties = getProps(pointer, includeNonEnumerable);
        properties = properties.filter(function(prop) {
          return propertiesToSkip.indexOf(prop) === -1;
        });
        propertiesToSkip = propertiesToSkip.concat(properties);
        propsToSpyOn = propsToSpyOn.concat(
          getSpyableFunctionProps(pointer, properties)
        );
        pointer = Object.getPrototypeOf(pointer);
      }

      for (var i = 0; i < propsToSpyOn.length; i++) {
        this.spyOn(obj, propsToSpyOn[i]);
      }

      return obj;
    };

    this.clearSpies = function() {
      var spies = currentSpies();
      for (var i = spies.length - 1; i >= 0; i--) {
        var spyEntry = spies[i];
        spyEntry.restoreObjectToOriginalState();
      }
    };
  }

  function getProps(obj, includeNonEnumerable) {
    var enumerableProperties = Object.keys(obj);

    if (!includeNonEnumerable) {
      return enumerableProperties;
    }

    return Object.getOwnPropertyNames(obj).filter(function(prop) {
      return (
        prop !== 'constructor' ||
        enumerableProperties.indexOf('constructor') > -1
      );
    });
  }

  function getSpyableFunctionProps(obj, propertiesToCheck) {
    var props = [],
      prop;
    for (var i = 0; i < propertiesToCheck.length; i++) {
      prop = propertiesToCheck[i];
      if (
        Object.prototype.hasOwnProperty.call(obj, prop) &&
        isSpyableProp(obj, prop)
      ) {
        props.push(prop);
      }
    }
    return props;
  }

  function isSpyableProp(obj, prop) {
    var value, descriptor;
    try {
      value = obj[prop];
    } catch (e) {
      return false;
    }
    if (value instanceof Function) {
      descriptor = Object.getOwnPropertyDescriptor(obj, prop);
      return (descriptor.writable || descriptor.set) && descriptor.configurable;
    }
    return false;
  }

  return SpyRegistry;
};

getJasmineRequireObj().SpyStrategy = function(j$) {
  /**
   * @interface SpyStrategy
   */
  function SpyStrategy(options) {
    options = options || {};

    var self = this;

    /**
     * Get the identifying information for the spy.
     * @name SpyStrategy#identity
     * @since 3.0.0
     * @member
     * @type {String}
     */
    this.identity = options.name || 'unknown';
    this.originalFn = options.fn || function() {};
    this.getSpy = options.getSpy || function() {};
    this.plan = this._defaultPlan = function() {};

    var k,
      cs = options.customStrategies || {};
    for (k in cs) {
      if (j$.util.has(cs, k) && !this[k]) {
        this[k] = createCustomPlan(cs[k]);
      }
    }

    /**
     * Tell the spy to return a promise resolving to the specified value when invoked.
     * @name SpyStrategy#resolveTo
     * @since 3.5.0
     * @function
     * @param {*} value The value to return.
     */
    this.resolveTo = function(value) {
      self.plan = function() {
        return Promise.resolve(value);
      };
      return self.getSpy();
    };

    /**
     * Tell the spy to return a promise rejecting with the specified value when invoked.
     * @name SpyStrategy#rejectWith
     * @since 3.5.0
     * @function
     * @param {*} value The value to return.
     */
    this.rejectWith = function(value) {
      self.plan = function() {
        return Promise.reject(value);
      };
      return self.getSpy();
    };
  }

  function createCustomPlan(factory) {
    return function() {
      var plan = factory.apply(null, arguments);

      if (!j$.isFunction_(plan)) {
        throw new Error('Spy strategy must return a function');
      }

      this.plan = plan;
      return this.getSpy();
    };
  }

  /**
   * Execute the current spy strategy.
   * @name SpyStrategy#exec
   * @since 2.0.0
   * @function
   */
  SpyStrategy.prototype.exec = function(context, args, invokeNew) {
    var contextArgs = [context].concat(
      args ? Array.prototype.slice.call(args) : []
    );
    var target = this.plan.bind.apply(this.plan, contextArgs);

    return invokeNew ? new target() : target();
  };

  /**
   * Tell the spy to call through to the real implementation when invoked.
   * @name SpyStrategy#callThrough
   * @since 2.0.0
   * @function
   */
  SpyStrategy.prototype.callThrough = function() {
    this.plan = this.originalFn;
    return this.getSpy();
  };

  /**
   * Tell the spy to return the value when invoked.
   * @name SpyStrategy#returnValue
   * @since 2.0.0
   * @function
   * @param {*} value The value to return.
   */
  SpyStrategy.prototype.returnValue = function(value) {
    this.plan = function() {
      return value;
    };
    return this.getSpy();
  };

  /**
   * Tell the spy to return one of the specified values (sequentially) each time the spy is invoked.
   * @name SpyStrategy#returnValues
   * @since 2.1.0
   * @function
   * @param {...*} values - Values to be returned on subsequent calls to the spy.
   */
  SpyStrategy.prototype.returnValues = function() {
    var values = Array.prototype.slice.call(arguments);
    this.plan = function() {
      return values.shift();
    };
    return this.getSpy();
  };

  /**
   * Tell the spy to throw an error when invoked.
   * @name SpyStrategy#throwError
   * @since 2.0.0
   * @function
   * @param {Error|Object|String} something Thing to throw
   */
  SpyStrategy.prototype.throwError = function(something) {
    var error = j$.isString_(something) ? new Error(something) : something;
    this.plan = function() {
      throw error;
    };
    return this.getSpy();
  };

  /**
   * Tell the spy to call a fake implementation when invoked.
   * @name SpyStrategy#callFake
   * @since 2.0.0
   * @function
   * @param {Function} fn The function to invoke with the passed parameters.
   */
  SpyStrategy.prototype.callFake = function(fn) {
    if (
      !(
        j$.isFunction_(fn) ||
        j$.isAsyncFunction_(fn) ||
        j$.isGeneratorFunction_(fn)
      )
    ) {
      throw new Error(
        'Argument passed to callFake should be a function, got ' + fn
      );
    }
    this.plan = fn;
    return this.getSpy();
  };

  /**
   * Tell the spy to do nothing when invoked. This is the default.
   * @name SpyStrategy#stub
   * @since 2.0.0
   * @function
   */
  SpyStrategy.prototype.stub = function(fn) {
    this.plan = function() {};
    return this.getSpy();
  };

  SpyStrategy.prototype.isConfigured = function() {
    return this.plan !== this._defaultPlan;
  };

  return SpyStrategy;
};

getJasmineRequireObj().StackTrace = function(j$) {
  function StackTrace(error) {
    var lines = error.stack.split('\n').filter(function(line) {
      return line !== '';
    });

    var extractResult = extractMessage(error.message, lines);

    if (extractResult) {
      this.message = extractResult.message;
      lines = extractResult.remainder;
    }

    var parseResult = tryParseFrames(lines);
    this.frames = parseResult.frames;
    this.style = parseResult.style;
  }

  var framePatterns = [
    // Node, Chrome, Edge
    // e.g. "   at QueueRunner.run (http://localhost:8888/__jasmine__/jasmine.js:4320:20)"
    // Note that the "function name" can include a surprisingly large set of
    // characters, including angle brackets and square brackets.
    {
      re: /^\s*at ([^\)]+) \(([^\)]+)\)$/,
      fnIx: 1,
      fileLineColIx: 2,
      style: 'v8'
    },

    // NodeJS alternate form, often mixed in with the Chrome style
    // e.g. "  at /some/path:4320:20
    { re: /\s*at (.+)$/, fileLineColIx: 1, style: 'v8' },

    // PhantomJS on OS X, Safari, Firefox
    // e.g. "run@http://localhost:8888/__jasmine__/jasmine.js:4320:27"
    // or "http://localhost:8888/__jasmine__/jasmine.js:4320:27"
    {
      re: /^(?:(([^@\s]+)@)|@)?([^\s]+)$/,
      fnIx: 2,
      fileLineColIx: 3,
      style: 'webkit'
    }
  ];

  // regexes should capture the function name (if any) as group 1
  // and the file, line, and column as group 2.
  function tryParseFrames(lines) {
    var style = null;
    var frames = lines.map(function(line) {
      var convertedLine = first(framePatterns, function(pattern) {
        var overallMatch = line.match(pattern.re),
          fileLineColMatch;
        if (!overallMatch) {
          return null;
        }

        fileLineColMatch = overallMatch[pattern.fileLineColIx].match(
          /^(.*):(\d+):\d+$/
        );
        if (!fileLineColMatch) {
          return null;
        }

        style = style || pattern.style;
        return {
          raw: line,
          file: fileLineColMatch[1],
          line: parseInt(fileLineColMatch[2], 10),
          func: overallMatch[pattern.fnIx]
        };
      });

      return convertedLine || { raw: line };
    });

    return {
      style: style,
      frames: frames
    };
  }

  function first(items, fn) {
    var i, result;

    for (i = 0; i < items.length; i++) {
      result = fn(items[i]);

      if (result) {
        return result;
      }
    }
  }

  function extractMessage(message, stackLines) {
    var len = messagePrefixLength(message, stackLines);

    if (len > 0) {
      return {
        message: stackLines.slice(0, len).join('\n'),
        remainder: stackLines.slice(len)
      };
    }
  }

  function messagePrefixLength(message, stackLines) {
    if (!stackLines[0].match(/^\w*Error/)) {
      return 0;
    }

    var messageLines = message.split('\n');
    var i;

    for (i = 1; i < messageLines.length; i++) {
      if (messageLines[i] !== stackLines[i]) {
        return 0;
      }
    }

    return messageLines.length;
  }

  return StackTrace;
};

getJasmineRequireObj().Suite = function(j$) {
  /**
   * @interface Suite
   * @see Env#topSuite
   * @since 2.0.0
   */
  function Suite(attrs) {
    this.env = attrs.env;
    /**
     * The unique ID of this suite.
     * @name Suite#id
     * @readonly
     * @type {string}
     * @since 2.0.0
     */
    this.id = attrs.id;
    this.parentSuite = attrs.parentSuite;
    /**
     * The description passed to the {@link describe} that created this suite.
     * @name Suite#description
     * @readonly
     * @type {string}
     * @since 2.0.0
     */
    this.description = attrs.description;
    this.expectationFactory = attrs.expectationFactory;
    this.asyncExpectationFactory = attrs.asyncExpectationFactory;
    this.expectationResultFactory = attrs.expectationResultFactory;
    this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;
    this.autoCleanClosures =
      attrs.autoCleanClosures === undefined ? true : !!attrs.autoCleanClosures;
    this.onLateError = attrs.onLateError;

    this.beforeFns = [];
    this.afterFns = [];
    this.beforeAllFns = [];
    this.afterAllFns = [];
    this.timer = attrs.timer || new j$.Timer();

    /**
     * The suite's children.
     * @name Suite#children
     * @type {Array.<(Spec|Suite)>}
     * @since 2.0.0
     */
    this.children = [];

    this.reset();
  }

  Suite.prototype.setSuiteProperty = function(key, value) {
    this.result.properties = this.result.properties || {};
    this.result.properties[key] = value;
  };

  Suite.prototype.expect = function(actual) {
    return this.expectationFactory(actual, this);
  };

  Suite.prototype.expectAsync = function(actual) {
    return this.asyncExpectationFactory(actual, this);
  };

  /**
   * The full description including all ancestors of this suite.
   * @name Suite#getFullName
   * @function
   * @returns {string}
   * @since 2.0.0
   */
  Suite.prototype.getFullName = function() {
    var fullName = [];
    for (
      var parentSuite = this;
      parentSuite;
      parentSuite = parentSuite.parentSuite
    ) {
      if (parentSuite.parentSuite) {
        fullName.unshift(parentSuite.description);
      }
    }
    return fullName.join(' ');
  };

  /*
   * Mark the suite with "pending" status
   */
  Suite.prototype.pend = function() {
    this.markedPending = true;
  };

  /*
   * Like {@link Suite#pend}, but pending state will survive {@link Spec#reset}
   * Useful for fdescribe, xdescribe, where pending state should remain.
   */
  Suite.prototype.exclude = function() {
    this.pend();
    this.markedExcluding = true;
  };

  Suite.prototype.beforeEach = function(fn) {
    this.beforeFns.unshift({ ...fn, suite: this });
  };

  Suite.prototype.beforeAll = function(fn) {
    this.beforeAllFns.push({ ...fn, type: 'beforeAll', suite: this });
  };

  Suite.prototype.afterEach = function(fn) {
    this.afterFns.unshift({ ...fn, suite: this, type: 'afterEach' });
  };

  Suite.prototype.afterAll = function(fn) {
    this.afterAllFns.unshift({ ...fn, type: 'afterAll' });
  };

  Suite.prototype.startTimer = function() {
    this.timer.start();
  };

  Suite.prototype.endTimer = function() {
    this.result.duration = this.timer.elapsed();
  };

  function removeFns(queueableFns) {
    for (var i = 0; i < queueableFns.length; i++) {
      queueableFns[i].fn = null;
    }
  }

  Suite.prototype.cleanupBeforeAfter = function() {
    if (this.autoCleanClosures) {
      removeFns(this.beforeAllFns);
      removeFns(this.afterAllFns);
      removeFns(this.beforeFns);
      removeFns(this.afterFns);
    }
  };

  Suite.prototype.reset = function() {
    /**
     * @typedef SuiteResult
     * @property {Int} id - The unique id of this suite.
     * @property {String} description - The description text passed to the {@link describe} that made this suite.
     * @property {String} fullName - The full description including all ancestors of this suite.
     * @property {Expectation[]} failedExpectations - The list of expectations that failed in an {@link afterAll} for this suite.
     * @property {Expectation[]} deprecationWarnings - The list of deprecation warnings that occurred on this suite.
     * @property {String} status - Once the suite has completed, this string represents the pass/fail status of this suite.
     * @property {number} duration - The time in ms for Suite execution, including any before/afterAll, before/afterEach.
     * @property {Object} properties - User-supplied properties, if any, that were set using {@link Env#setSuiteProperty}
     * @since 2.0.0
     */
    this.result = {
      id: this.id,
      description: this.description,
      fullName: this.getFullName(),
      failedExpectations: [],
      deprecationWarnings: [],
      duration: null,
      properties: null
    };
    this.markedPending = this.markedExcluding;
    this.children.forEach(function(child) {
      child.reset();
    });
  };

  Suite.prototype.addChild = function(child) {
    this.children.push(child);
  };

  Suite.prototype.status = function() {
    if (this.markedPending) {
      return 'pending';
    }

    if (this.result.failedExpectations.length > 0) {
      return 'failed';
    } else {
      return 'passed';
    }
  };

  Suite.prototype.canBeReentered = function() {
    return this.beforeAllFns.length === 0 && this.afterAllFns.length === 0;
  };

  Suite.prototype.getResult = function() {
    this.result.status = this.status();
    return this.result;
  };

  Suite.prototype.sharedUserContext = function() {
    if (!this.sharedContext) {
      this.sharedContext = this.parentSuite
        ? this.parentSuite.clonedSharedUserContext()
        : new j$.UserContext();
    }

    return this.sharedContext;
  };

  Suite.prototype.clonedSharedUserContext = function() {
    return j$.UserContext.fromExisting(this.sharedUserContext());
  };

  Suite.prototype.onException = function() {
    if (arguments[0] instanceof j$.errors.ExpectationFailed) {
      return;
    }

    var data = {
      matcherName: '',
      passed: false,
      expected: '',
      actual: '',
      error: arguments[0]
    };
    var failedExpectation = this.expectationResultFactory(data);

    if (!this.parentSuite) {
      failedExpectation.globalErrorType = 'afterAll';
    }

    this.result.failedExpectations.push(failedExpectation);
  };

  Suite.prototype.onMultipleDone = function() {
    let msg;

    // Issue a deprecation. Include the context ourselves and pass
    // ignoreRunnable: true, since getting here always means that we've already
    // moved on and the current runnable isn't the one that caused the problem.
    if (this.parentSuite) {
      msg =
        "An asynchronous beforeAll or afterAll function called its 'done' " +
        'callback more than once.\n' +
        '(in suite: ' +
        this.getFullName() +
        ')';
    } else {
      msg =
        'A top-level beforeAll or afterAll function called its ' +
        "'done' callback more than once.";
    }

    this.onLateError(new Error(msg));
  };

  Suite.prototype.addExpectationResult = function() {
    if (isFailure(arguments)) {
      var data = arguments[1];
      this.result.failedExpectations.push(this.expectationResultFactory(data));
      if (this.throwOnExpectationFailure) {
        throw new j$.errors.ExpectationFailed();
      }
    }
  };

  Suite.prototype.addDeprecationWarning = function(deprecation) {
    if (typeof deprecation === 'string') {
      deprecation = { message: deprecation };
    }
    this.result.deprecationWarnings.push(
      this.expectationResultFactory(deprecation)
    );
  };

  Object.defineProperty(Suite.prototype, 'metadata', {
    get: function() {
      if (!this.metadata_) {
        this.metadata_ = new SuiteMetadata(this);
      }

      return this.metadata_;
    }
  });

  /**
   * @interface Suite
   * @see Env#topSuite
   */
  function SuiteMetadata(suite) {
    this.suite_ = suite;
    /**
     * The unique ID of this suite.
     * @name Suite#id
     * @readonly
     * @type {string}
     */
    this.id = suite.id;

    /**
     * The parent of this suite, or null if this is the top suite.
     * @name Suite#parentSuite
     * @readonly
     * @type {Suite}
     */
    this.parentSuite = suite.parentSuite ? suite.parentSuite.metadata : null;

    /**
     * The description passed to the {@link describe} that created this suite.
     * @name Suite#description
     * @readonly
     * @type {string}
     */
    this.description = suite.description;
  }

  /**
   * The full description including all ancestors of this suite.
   * @name Suite#getFullName
   * @function
   * @returns {string}
   */
  SuiteMetadata.prototype.getFullName = function() {
    return this.suite_.getFullName();
  };

  /**
   * The suite's children.
   * @name Suite#children
   * @type {Array.<(Spec|Suite)>}
   */
  Object.defineProperty(SuiteMetadata.prototype, 'children', {
    get: function() {
      return this.suite_.children.map(child => child.metadata);
    }
  });

  function isFailure(args) {
    return !args[0];
  }

  return Suite;
};

getJasmineRequireObj().Timer = function() {
  var defaultNow = (function(Date) {
    return function() {
      return new Date().getTime();
    };
  })(Date);

  function Timer(options) {
    options = options || {};

    var now = options.now || defaultNow,
      startTime;

    this.start = function() {
      startTime = now();
    };

    this.elapsed = function() {
      return now() - startTime;
    };
  }

  return Timer;
};

getJasmineRequireObj().TreeProcessor = function() {
  function TreeProcessor(attrs) {
    var tree = attrs.tree,
      runnableIds = attrs.runnableIds,
      queueRunnerFactory = attrs.queueRunnerFactory,
      nodeStart = attrs.nodeStart || function() {},
      nodeComplete = attrs.nodeComplete || function() {},
      failSpecWithNoExpectations = !!attrs.failSpecWithNoExpectations,
      orderChildren =
        attrs.orderChildren ||
        function(node) {
          return node.children;
        },
      excludeNode =
        attrs.excludeNode ||
        function(node) {
          return false;
        },
      stats = { valid: true },
      processed = false,
      defaultMin = Infinity,
      defaultMax = 1 - Infinity;

    this.processTree = function() {
      processNode(tree, true);
      processed = true;
      return stats;
    };

    this.execute = function(done) {
      if (!processed) {
        this.processTree();
      }

      if (!stats.valid) {
        throw 'invalid order';
      }

      var childFns = wrapChildren(tree, 0);

      queueRunnerFactory({
        queueableFns: childFns,
        userContext: tree.sharedUserContext(),
        onException: function() {
          tree.onException.apply(tree, arguments);
        },
        onComplete: done,
        onMultipleDone: tree.onMultipleDone
          ? tree.onMultipleDone.bind(tree)
          : null
      });
    };

    function runnableIndex(id) {
      for (var i = 0; i < runnableIds.length; i++) {
        if (runnableIds[i] === id) {
          return i;
        }
      }
    }

    function processNode(node, parentExcluded) {
      var executableIndex = runnableIndex(node.id);

      if (executableIndex !== undefined) {
        parentExcluded = false;
      }

      if (!node.children) {
        var excluded = parentExcluded || excludeNode(node);
        stats[node.id] = {
          excluded: excluded,
          willExecute: !excluded && !node.markedPending,
          segments: [
            {
              index: 0,
              owner: node,
              nodes: [node],
              min: startingMin(executableIndex),
              max: startingMax(executableIndex)
            }
          ]
        };
      } else {
        var hasExecutableChild = false;

        var orderedChildren = orderChildren(node);

        for (var i = 0; i < orderedChildren.length; i++) {
          var child = orderedChildren[i];

          processNode(child, parentExcluded);

          if (!stats.valid) {
            return;
          }

          var childStats = stats[child.id];

          hasExecutableChild = hasExecutableChild || childStats.willExecute;
        }

        stats[node.id] = {
          excluded: parentExcluded,
          willExecute: hasExecutableChild
        };

        segmentChildren(node, orderedChildren, stats[node.id], executableIndex);

        if (!node.canBeReentered() && stats[node.id].segments.length > 1) {
          stats = { valid: false };
        }
      }
    }

    function startingMin(executableIndex) {
      return executableIndex === undefined ? defaultMin : executableIndex;
    }

    function startingMax(executableIndex) {
      return executableIndex === undefined ? defaultMax : executableIndex;
    }

    function segmentChildren(
      node,
      orderedChildren,
      nodeStats,
      executableIndex
    ) {
      var currentSegment = {
          index: 0,
          owner: node,
          nodes: [],
          min: startingMin(executableIndex),
          max: startingMax(executableIndex)
        },
        result = [currentSegment],
        lastMax = defaultMax,
        orderedChildSegments = orderChildSegments(orderedChildren);

      function isSegmentBoundary(minIndex) {
        return (
          lastMax !== defaultMax &&
          minIndex !== defaultMin &&
          lastMax < minIndex - 1
        );
      }

      for (var i = 0; i < orderedChildSegments.length; i++) {
        var childSegment = orderedChildSegments[i],
          maxIndex = childSegment.max,
          minIndex = childSegment.min;

        if (isSegmentBoundary(minIndex)) {
          currentSegment = {
            index: result.length,
            owner: node,
            nodes: [],
            min: defaultMin,
            max: defaultMax
          };
          result.push(currentSegment);
        }

        currentSegment.nodes.push(childSegment);
        currentSegment.min = Math.min(currentSegment.min, minIndex);
        currentSegment.max = Math.max(currentSegment.max, maxIndex);
        lastMax = maxIndex;
      }

      nodeStats.segments = result;
    }

    function orderChildSegments(children) {
      var specifiedOrder = [],
        unspecifiedOrder = [];

      for (var i = 0; i < children.length; i++) {
        var child = children[i],
          segments = stats[child.id].segments;

        for (var j = 0; j < segments.length; j++) {
          var seg = segments[j];

          if (seg.min === defaultMin) {
            unspecifiedOrder.push(seg);
          } else {
            specifiedOrder.push(seg);
          }
        }
      }

      specifiedOrder.sort(function(a, b) {
        return a.min - b.min;
      });

      return specifiedOrder.concat(unspecifiedOrder);
    }

    function executeNode(node, segmentNumber) {
      if (node.children) {
        return {
          fn: function(done) {
            var onStart = {
              fn: function(next) {
                nodeStart(node, next);
              }
            };

            queueRunnerFactory({
              onComplete: function() {
                var args = Array.prototype.slice.call(arguments, [0]);
                node.cleanupBeforeAfter();
                nodeComplete(node, node.getResult(), function() {
                  done.apply(undefined, args);
                });
              },
              queueableFns: [onStart].concat(wrapChildren(node, segmentNumber)),
              userContext: node.sharedUserContext(),
              onException: function() {
                node.onException.apply(node, arguments);
              },
              onMultipleDone: node.onMultipleDone
                ? node.onMultipleDone.bind(node)
                : null
            });
          }
        };
      } else {
        return {
          fn: function(done) {
            node.execute(
              done,
              stats[node.id].excluded,
              failSpecWithNoExpectations
            );
          }
        };
      }
    }

    function wrapChildren(node, segmentNumber) {
      var result = [],
        segmentChildren = stats[node.id].segments[segmentNumber].nodes;

      for (var i = 0; i < segmentChildren.length; i++) {
        result.push(
          executeNode(segmentChildren[i].owner, segmentChildren[i].index)
        );
      }

      if (!stats[node.id].willExecute) {
        return result;
      }

      return node.beforeAllFns.concat(result).concat(node.afterAllFns);
    }
  }

  return TreeProcessor;
};

getJasmineRequireObj().UserContext = function(j$) {
  function UserContext() {}

  UserContext.fromExisting = function(oldContext) {
    var context = new UserContext();

    for (var prop in oldContext) {
      if (oldContext.hasOwnProperty(prop)) {
        context[prop] = oldContext[prop];
      }
    }

    return context;
  };

  return UserContext;
};

getJasmineRequireObj().version = function() {
  return '4.0.1';
};


/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/compute-voxels.wgsl":
/*!***********************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/compute-voxels.wgsl ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("struct Permutations {\n  Perm : array<i32, 512>,\n};\n\n@binding(0) @group(0)\nvar<storage, read> perm : Permutations;\n\nstruct CornerMaterials {\n  cornerMaterials : array<u32>,\n};\n\n@binding(1) @group(0)\nvar<storage, read_write> cornerMaterials: CornerMaterials;\n\nstruct VoxelMaterials {\n  voxelMaterials : array<u32>,\n};\n\n@binding(2) @group(0)\nvar<storage, read_write> voxelMaterials: VoxelMaterials;\n\nstruct CornerIndex {\n  cornerCount : u32,\n  cornerIndexes : array<u32>\n};\n\n@binding(3) @group(0)\nvar<storage, read_write> cornerIndex: CornerIndex;\n\nstruct GPUVOX\n{\n\tvoxMin: vec3<f32>,\n\tcorners: f32,\n\tvertPoint: vec3<f32>,\n\tavgNormal: vec3<f32>,\n\tnumPoints: f32\n};\nstruct GPUVOXS {\n  voxels : array<GPUVOX>,\n};\n\n@binding(4) @group(0)\nvar<storage, read_write> voxels: GPUVOXS;\n\nstruct UniformBufferObject {\n  chunkPosition : vec3<f32>,\n  stride : f32,\n\twidth: u32\n};\n\n@binding(5) @group(0)\nvar<uniform> uniforms : UniformBufferObject;\n\nconst CHILD_MIN_OFFSETS: array<vec3<u32>, 8> = array<vec3<u32>, 8>\n(\n  vec3<u32>(0u, 0u, 0u),\n  vec3<u32>(0u, 0u, 1u),\n  vec3<u32>(0u, 1u, 0u),\n  vec3<u32>(0u, 1u, 1u),\n  vec3<u32>(1u, 0u, 0u),\n  vec3<u32>(1u, 0u, 1u),\n  vec3<u32>(1u, 1u, 0u),\n  vec3<u32>(1u, 1u, 1u)\n);\n\nconst edgevmap: array<vec2<i32>, 12> = array<vec2<i32>, 12>\n(\n\tvec2<i32>(0,4), vec2<i32>(1,5), vec2<i32>(2,6), vec2<i32>(3,7),\n\tvec2<i32>(0,2), vec2<i32>(1,3), vec2<i32>(4,6), vec2<i32>(5,7),\n\tvec2<i32>(0,1), vec2<i32>(2,3), vec2<i32>(4,5), vec2<i32>(6,7)\n);\n\nfn random(i: vec2<f32>) -> f32 {\n  return fract(sin(dot(i,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nfn Vec3Dot(a: vec3<f32>, b: vec3<f32>) -> f32\n{\n\treturn (a.x * b.x) + (a.y * b.y) + (a.z * b.z);\n}\n\nconst Grad3: array<vec3<f32>, 12> = array<vec3<f32>, 12>(\n\tvec3<f32>(1.0,1.0,0.0), vec3<f32>(-1.0,1.0,0.0), vec3<f32>(1.0,-1.0,0.0), vec3<f32>(-1.0,-1.0,0.0),\n\tvec3<f32>(1.0,0.0,1.0), vec3<f32>(-1.0,0.0,1.0), vec3<f32>(1.0,0.0,-1.0), vec3<f32>(-1.0,0.0,-1.0),\n\tvec3<f32>(0.0,1.0,1.0), vec3<f32>(0.0,-1.0,1.0), vec3<f32>(0.0,1.0,-1.0), vec3<f32>(0.0,-1.0,-1.0)\n);\n\nfn Perlin(x1: f32, y1: f32, z1: f32) -> f32\n{\n\tvar X: i32 = 0;\n\tif (x1 > 0.0) {\n\t\tX = i32(x1);\n\t} else {\n\t\tX = i32(x1) - 1;\n\t}\n\n\tvar Y: i32 = 0;\n\tif (y1 > 0.0) {\n\t\tY = i32(y1);\n\t} else {\n\t\tY = i32(y1) - 1;\n\t}\n\n\tvar Z: i32 = 0;\n\tif (z1 > 0.0) {\n\t\tZ = i32(z1);\n\t} else {\n\t\tZ = i32(z1) - 1;\n\t}\n\t\n\tlet x: f32 = x1 - f32(X);\n\tlet y: f32 = y1 - f32(Y);\n\tlet z: f32 = z1 - f32(Z);\n\t\n\tX = X & 255;\n\tY = Y & 255;\n\tZ = Z & 255;\n\t\n\tlet gi000: i32 = (perm.Perm[X + perm.Perm[Y + perm.Perm[Z] ] ] % 12);\n\tlet gi001: i32 = (perm.Perm[X + perm.Perm[Y + perm.Perm[Z + 1] ] ] % 12);\n\tlet gi010: i32 = (perm.Perm[X + perm.Perm[Y + 1 + perm.Perm[Z] ] ] % 12);\n\tlet gi011: i32 = (perm.Perm[X + perm.Perm[Y + 1 + perm.Perm[Z + 1] ] ] % 12);\n\tlet gi100: i32 = (perm.Perm[X + 1 + perm.Perm[Y + perm.Perm[Z] ] ] % 12);\n\tlet gi101: i32 = (perm.Perm[X + 1 + perm.Perm[Y + perm.Perm[Z + 1] ] ] % 12);\n\tlet gi110: i32 = (perm.Perm[X + 1 + perm.Perm[Y + 1 + perm.Perm[Z] ] ] % 12);\n\tlet gi111: i32 = (perm.Perm[X + 1 + perm.Perm[Y + 1 + perm.Perm[Z + 1] ] ] % 12);\n\n\tlet n000: f32 = dot(Grad3[gi000], vec3<f32>(x, y, z));\n\tlet n100: f32 = dot(Grad3[gi100], vec3<f32>(x - 1.0, y, z));\n\tlet n010: f32 = dot(Grad3[gi010], vec3<f32>(x, y - 1.0, z));\n\tlet n110: f32 = dot(Grad3[gi110], vec3<f32>(x - 1.0, y - 1.0, z));\n\tlet n001: f32 = dot(Grad3[gi001], vec3<f32>(x, y, z - 1.0));\n\tlet n101: f32 = dot(Grad3[gi101], vec3<f32>(x - 1.0, y, z - 1.0));\n\tlet n011: f32 = dot(Grad3[gi011], vec3<f32>(x, y - 1.0, z - 1.0));\n\tlet n111: f32 = dot(Grad3[gi111], vec3<f32>(x - 1.0, y - 1.0, z - 1.0));\n\t\n\tlet u: f32 = f32(x * x * x * (x * (x * 6.0 - 15.0) + 10.0));\n\tlet v: f32 = f32(y * y * y * (y * (y * 6.0 - 15.0) + 10.0));\n\tlet w: f32 = f32(z * z * z * (z * (z * 6.0 - 15.0) + 10.0));\n\tlet nx00: f32 = mix(n000, n100, u);\n\tlet nx01: f32 = mix(n001, n101, u);\n\tlet nx10: f32 = mix(n010, n110, u);\n\tlet nx11: f32 = mix(n011, n111, u);\n\tlet nxy0: f32 = mix(nx00, nx10, v);\n\tlet nxy1: f32 = mix(nx01, nx11, v);\n\tlet nxyz: f32 = mix(nxy0, nxy1, w);\n\t\n\treturn nxyz;\n}\n\nfn FractalNoise(octaves: i32, frequency: f32, lacunarity: f32, persistence: f32, position: vec3<f32>) -> f32\n{\n\tlet SCALE: f32 = 1.0 / 128.0;\n\tvar p: vec3<f32> = position * SCALE;\n\tvar nois: f32 = 0.0;\n\n\tvar amplitude: f32 = 1.0;\n\tp = p * frequency;\n\n\tvar i: i32 = 0;\n\tloop {\n\t\tif (i >= octaves) { break; }\n\n\t\tnois = nois + Perlin(p.x, p.y, p.z) * amplitude;\n\t\tp = p * lacunarity;\n\t\tamplitude = amplitude * persistence;\n\n\t\tcontinuing {\n\t\t\ti = i + 1;\n\t\t}\n\t}\n\t\n\treturn nois;\n}\n\nfn FractalNoise1(frequency: f32, lacunarity: f32, persistence: f32, position: vec3<f32>) -> f32\n{\n\tlet SCALE: f32 = 1.0 / 128.0;\n\tvar p: vec3<f32> = position * SCALE;\n\tvar nois: f32 = 0.0;\n\n\tvar amplitude: f32 = 1.0;\n\tp = p * frequency;\n\t\n\tnois = nois + Perlin(p.x, p.y, p.z) * amplitude;\n\tp = p * lacunarity;\n\tamplitude = amplitude * persistence;\n\t\n\treturn nois;\n}\n\nfn CalculateNoiseValue(pos: vec3<f32>, scale: f32) -> f32\n{\n\treturn FractalNoise(4, 0.5343, 2.2324, 0.68324, pos * scale);\n}\n\nfn CLerp(a: f32, b: f32, t: f32) -> f32\n{\n\treturn (1.0 - t) * a + t * b;\n}\n\n// SVD\n\nconst SVD_NUM_SWEEPS: i32 = 4;\nconst PSUEDO_INVERSE_THRESHOLD: f32 = 0.00000001;\n\nfn svd_mul_matrix_vec(m: mat3x3<f32>, b: vec4<f32>) -> vec4<f32>\n{\n\tvar a: mat3x3<f32> = m;\n\t\n\treturn vec4<f32>(\n\t\tdot(vec4<f32>(a[0][0], a[0][1], a[0][2], 0.0), b),\n\t\tdot(vec4<f32>(a[1][0], a[1][1], a[1][2], 0.0), b),\n\t\tdot(vec4<f32>(a[2][0], a[2][1], a[2][2], 0.0), b),\n\t\t0.0\n\t);\n}\n\nfn givens_coeffs_sym(a_pp: f32, a_pq: f32, a_qq: f32) -> vec2<f32>\n{\n\tif (a_pq == 0.0) {\n\t\treturn vec2<f32>(1.0, 0.0);\n\t}\n\t\n\tlet tau: f32 = (a_qq - a_pp) / (2.0 * a_pq);\n\tlet stt: f32 = sqrt(1.0 + tau * tau);\n\tvar tan: f32;\n\tif ((tau >= 0.0)) {\n\t\ttan = (tau + stt);\n\t} else {\n\t\ttan = (tau - stt);\n\t}\n\ttan = 1.0 / tan;\n\n\tlet c: f32 = inverseSqrt(1.0 + tan * tan);\n\tlet s: f32 = tan * c;\n\n\treturn vec2<f32>(c, s);\n}\n\nfn svd_rotate_xy(x: f32, y: f32, c: f32, s: f32) -> vec2<f32>\n{\n\treturn vec2<f32>(c * x - s * y, s * x + c * y);\n}\n\nfn svd_rotateq_xy(x: f32, y: f32, z: f32, c: f32, s: f32) -> vec2<f32>\n{\n\tlet cc: f32 = c * c;\n\tlet ss: f32 = s * s;\n\tlet mx: f32 = 2.0 * c * s * z;\n\n\treturn vec2<f32>(\n\t\tcc * x - mx + ss * y,\n\t\tss * x + mx + cc * z\n\t);\n}\n\nvar<private> vtav: mat3x3<f32>;\nvar<private> v: mat3x3<f32>;\nvar<private> ATA: array<f32, 6>;\nvar<private> Atb: vec4<f32>;\nvar<private> pointaccum: vec4<f32>;\nvar<private> btb: f32;\n\nfn svd_rotate(a: i32, b: i32)\n{\n\tif (vtav[a][b] == 0.0) { return; }\n\n\n\t\n\tlet coeffs: vec2<f32> = givens_coeffs_sym(vtav[a][a], vtav[a][b], vtav[b][b]);\n\tlet c: f32 = coeffs.x;\n\tlet s: f32 = coeffs.y;\n\t\n\tlet rot1: vec2<f32> = svd_rotateq_xy(vtav[a][a], vtav[b][b], vtav[a][b], c, s);\n\tvtav[a][a] = rot1.x;\n\tvtav[b][b] = rot1.y;\n\t\n\tlet rot2: vec2<f32> = svd_rotate_xy(vtav[0][3-b], vtav[1-a][2], c, s);\n\tvtav[0][3-b] = rot2.x; \n\tvtav[1-a][2] = rot2.y;\n\t\n\tvtav[a][b] = 0.0;\n\t\n\tlet rot3: vec2<f32> = svd_rotate_xy(v[0][a], v[0][b], c, s);\n\tv[0][a] = rot3.x; v[0][b] = rot3.y;\n\t\n\tlet rot4: vec2<f32> = svd_rotate_xy(v[1][a], v[1][b], c, s);\n\tv[1][a] = rot4.x; v[1][b] = rot4.y;\n\t\n\tlet rot5: vec2<f32> = svd_rotate_xy(v[2][a], v[2][b], c, s);\n\tv[2][a] = rot5.x; v[2][b] = rot5.y;\n}\n\nfn svd_solve_sym(b: array<f32, 6>) -> vec4<f32>\n{\n\tvar a: array<f32, 6> = b;\n\t\n\tvtav = mat3x3<f32>( \n\t\tvec3<f32>(a[0], a[1], a[2]), \n\t\tvec3<f32>(0.0, a[3], a[4]), \n\t\tvec3<f32>(0.0, 0.0, a[5])\n\t);\n\n\tvar i: i32;\n\tloop {\n\t\tif (i >= SVD_NUM_SWEEPS) { break; }\n\n\t\tsvd_rotate(0, 1);\n\t\tsvd_rotate(0, 2);\n\t\tsvd_rotate(1, 2);\n\n\t\tcontinuing {\n\t\t\ti = i + 1;\n\t\t}\n\t}\n\n\tvar copy: mat3x3<f32> = vtav;\n\treturn vec4<f32>(copy[0][0], copy[1][1], copy[2][2], 0.0);\n}\n\n\nfn svd_invdet(x: f32, tol: f32) -> f32\n{\n\tif (abs(x) < tol || abs(1.0 / x) < tol) {\n\t\treturn 0.0;\n\t}\n\treturn (1.0 / x);\n}\n\nfn svd_pseudoinverse(sigma: vec4<f32>, c: mat3x3<f32>) -> mat3x3<f32>\n{\n\tlet d0: f32 = svd_invdet(sigma.x, PSUEDO_INVERSE_THRESHOLD);\n\tlet d1: f32 = svd_invdet(sigma.y, PSUEDO_INVERSE_THRESHOLD);\n\tlet d2: f32 = svd_invdet(sigma.z, PSUEDO_INVERSE_THRESHOLD);\n\n\tvar copy: mat3x3<f32> = c;\n\n\treturn mat3x3<f32> (\n\t\tvec3<f32>(\n\t\t\tcopy[0][0] * d0 * copy[0][0] + copy[0][1] * d1 * copy[0][1] + copy[0][2] * d2 * copy[0][2],\n\t\t\tcopy[0][0] * d0 * copy[1][0] + copy[0][1] * d1 * copy[1][1] + copy[0][2] * d2 * copy[1][2],\n\t\t\tcopy[0][0] * d0 * copy[2][0] + copy[0][1] * d1 * copy[2][1] + copy[0][2] * d2 * copy[2][2]\n\t\t),\n\t\tvec3<f32>(\n\t\t\tcopy[1][0] * d0 * copy[0][0] + copy[1][1] * d1 * copy[0][1] + copy[1][2] * d2 * copy[0][2],\n\t\t\tcopy[1][0] * d0 * copy[1][0] + copy[1][1] * d1 * copy[1][1] + copy[1][2] * d2 * copy[1][2],\n\t\t\tcopy[1][0] * d0 * copy[2][0] + copy[1][1] * d1 * copy[2][1] + copy[1][2] * d2 * copy[2][2]\n\t\t),\n\t\tvec3<f32>(\n\t\t\tcopy[2][0] * d0 * copy[0][0] + copy[2][1] * d1 * copy[0][1] + copy[2][2] * d2 * copy[0][2],\n\t\t\tcopy[2][0] * d0 * copy[1][0] + copy[2][1] * d1 * copy[1][1] + copy[2][2] * d2 * copy[1][2],\n\t\t\tcopy[2][0] * d0 * copy[2][0] + copy[2][1] * d1 * copy[2][1] + copy[2][2] * d2 * copy[2][2]\n\t\t),\n\t);\n}\n\nfn svd_solve_ATA_Atb(a: vec4<f32>) -> vec4<f32>\n{\n\tv = mat3x3<f32>(vec3<f32>(1.0, 0.0, 0.0), vec3<f32>(0.0, 1.0, 0.0), vec3<f32>(0.0, 0.0, 1.0));\n\t\n\tlet sigma: vec4<f32> = svd_solve_sym(ATA);\n\t\n\tlet Vinv: mat3x3<f32> = svd_pseudoinverse(sigma, v);\n\treturn svd_mul_matrix_vec(Vinv, a);\n}\n\nfn svd_vmul_sym(v: vec4<f32>) -> vec4<f32>\n{\n\tlet A_row_x: vec4<f32> = vec4<f32>(ATA[0], ATA[1], ATA[2], 0.0);\n\treturn vec4<f32> (\n\t\tdot(A_row_x, v),\n\t\tATA[1] * v.x + ATA[3] * v.y + ATA[4] * v.z,\n\t\tATA[2] * v.x + ATA[4] * v.y + ATA[5] * v.z,\n\t\t0.0\n\t);\n}\n\n\n// // QEF\n\nfn qef_add(n: vec4<f32>, p: vec4<f32>)\n{\n\tATA[0] = ATA[0] + n.x * n.x;\n\tATA[1] = ATA[1] + n.x * n.y;\n\tATA[2] = ATA[2] + n.x * n.z;\n\tATA[3] = ATA[3] + n.y * n.y;\n\tATA[4] = ATA[4] + n.y * n.z;\n\tATA[5] = ATA[5] + n.z * n.z;\n\t\n\tlet b: f32 = dot(p, n);\n\tAtb.x = Atb.x +n.x * b;\n\tAtb.y = Atb.y +n.y * b;\n\tAtb.z = Atb.z +n.z * b;\n\tbtb = btb + b * b;\n\t\n\tpointaccum.x = pointaccum.x +p.x;\n\tpointaccum.y = pointaccum.y +p.y;\n\tpointaccum.z = pointaccum.z +p.z;\n\tpointaccum.w = pointaccum.w +1.0;\n}\n\nfn qef_calc_error(x: vec4<f32>) -> f32\n{\n\tvar tmp: vec4<f32> = svd_vmul_sym(x);\n\ttmp = Atb - tmp;\n\t\n\treturn dot(tmp, tmp);\n}\n\nfn qef_solve() -> vec4<f32>\n{\n\tlet masspoint: vec4<f32> = vec4<f32>(pointaccum.x / pointaccum.w, pointaccum.y / pointaccum.w, pointaccum.z / pointaccum.w, pointaccum.w / pointaccum.w);\n\t\n\tvar A_mp: vec4<f32> = svd_vmul_sym(masspoint);\n\tA_mp = Atb - A_mp;\n\t\n\tlet x: vec4<f32> = svd_solve_ATA_Atb(A_mp);\n\t\n\tlet error: f32 = qef_calc_error(x);\n\tlet r: vec4<f32> = x + masspoint;\n\t\n\treturn vec4<f32>(r.x, r.y, r.z, error);\n}\n\n#import density\n\nfn ApproximateZeroCrossingPosition(p0: vec3<f32>, p1: vec3<f32>) -> vec3<f32>\n{\n\tvar minValue: f32 = 100000.0;\n\tvar t: f32 = 0.0;\n\tvar currentT: f32 = 0.0;\n\tlet steps: f32 = 8.0;\n\tlet increment: f32 = 1.0 / steps;\n\tloop {\n\t\tif (currentT > 1.0) { break; }\n\n\t\tlet p: vec3<f32> = p0 + ((p1 - p0) * currentT);\n\t\tlet density: f32 = abs(getDensity(p));\n\t\tif (density < minValue)\n\t\t{\n\t\t\tminValue = density;\n\t\t\tt = currentT;\n\t\t}\n\n\t\tcontinuing {\n\t\t\tcurrentT = currentT + increment;\n\t\t}\n\t}\n\n\treturn p0 + ((p1 - p0) * t);\n}\n\nfn CalculateSurfaceNormal(p: vec3<f32>) -> vec3<f32>\n{\n\tlet H: f32 = uniforms.stride; // This needs to scale based on something...\n\tlet dx: f32 = getDensity(p + vec3<f32>(H, 0.0, 0.0)) - getDensity(p - vec3<f32>(H, 0.0, 0.0));\n\tlet dy: f32 = getDensity(p + vec3<f32>(0.0, H, 0.0)) - getDensity(p - vec3<f32>(0.0, H, 0.0));\n\tlet dz: f32 = getDensity(p + vec3<f32>(0.0, 0.0, H)) - getDensity(p - vec3<f32>(0.0, 0.0, H));\n\n\treturn normalize(vec3<f32>(dx, dy, dz));\n}\n\n@compute @workgroup_size(128)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n\tlet trueIndex: u32 = GlobalInvocationID.x;\n\n\tif (trueIndex < cornerIndex.cornerCount)\n\t{\n\t\tlet ures: u32 = 32u;\n\n\t\tlet nodeSize: u32 = u32(uniforms.stride);\n\n\t\tlet voxelIndex: u32 = cornerIndex.cornerIndexes[trueIndex];\n\t\tlet z: u32 = voxelIndex / (ures * ures);\n\t\tlet y: u32 = (voxelIndex - (z * ures * ures)) / ures;\n\t\tlet x: u32 = voxelIndex - (z * ures * ures) - (y * ures);\n\n\t\tlet corners: u32 = voxelMaterials.voxelMaterials[voxelIndex];\n\n\t\tlet nodePos: vec3<f32> = (vec3<f32>(f32(x), f32(y), f32 (z)) * uniforms.stride) + uniforms.chunkPosition;\n\t\tvoxels.voxels[trueIndex].voxMin = nodePos;\n\t\tlet MAX_CROSSINGS: i32 = 6;\n\t\tvar edgeCount: i32 = 0;\n\n\t\tpointaccum = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n\t\tATA = array<f32, 6>(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\n\t\tAtb = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n\t\tvar averageNormal: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);\n\t\tbtb = 0.0;\n\n\t\tvar j: i32 = 0;\n\t\tloop {\n\t\t\tif (!(j < 12 && edgeCount <= MAX_CROSSINGS)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlet c1: i32 = edgevmap[j].x;\n\t\t\tlet c2: i32 = edgevmap[j].y;\n\n\t\t\tlet m1: u32 = (corners >> u32(c1)) & 1u;\n\t\t\tlet m2: u32 = (corners >> u32(c2)) & 1u;\n\n\t\t\tif (!((m1 == 0u && m2 == 0u) || (m1 == 1u && m2 == 1u)))\n\t\t\t{\n\t\t\t\tlet p1: vec3<f32> = nodePos + vec3<f32>(f32(CHILD_MIN_OFFSETS[c1].x * nodeSize), f32(CHILD_MIN_OFFSETS[c1].y * nodeSize), f32(CHILD_MIN_OFFSETS[c1].z * nodeSize));\n\t\t\t\tlet p2: vec3<f32> = nodePos + vec3<f32>(f32(CHILD_MIN_OFFSETS[c2].x * nodeSize), f32(CHILD_MIN_OFFSETS[c2].y * nodeSize), f32(CHILD_MIN_OFFSETS[c2].z * nodeSize));\n\t\t\t\tlet p: vec3<f32> = ApproximateZeroCrossingPosition(p1, p2);\n\t\t\t\tlet n: vec3<f32> = CalculateSurfaceNormal(p);\n\n\t\t\t\tqef_add(vec4<f32>(n.x, n.y, n.z, 0.0), vec4<f32>(p.x, p.y, p.z, 0.0));\n\n\t\t\t\taverageNormal = averageNormal + n;\n\n\t\t\t\tedgeCount = edgeCount + 1;\n\t\t\t}\n\n\t\t\tcontinuing {\n\t\t\t\tj = j + 1;\n\t\t\t}\n\t\t}\n\n\n\t\taverageNormal = normalize(averageNormal / vec3<f32>(f32(edgeCount), f32(edgeCount), f32(edgeCount)));\n\n\t\tlet com: vec3<f32> = vec3<f32>(pointaccum.x / pointaccum.w, pointaccum.y / pointaccum.w, pointaccum.z / pointaccum.w);\n\n\t\tlet result: vec4<f32> = qef_solve();\n\t\tvar solved_position: vec3<f32> = result.xyz;\n\t\tlet error: f32 = result.w;\n\n\n\t\tlet Min: vec3<f32> = nodePos;\n\t\tlet Max: vec3<f32> = nodePos + vec3<f32>(1.0, 1.0, 1.0);\n\t\tif (solved_position.x < Min.x || solved_position.x > Max.x ||\n\t\t\t\tsolved_position.y < Min.y || solved_position.y > Max.y ||\n\t\t\t\tsolved_position.z < Min.z || solved_position.z > Max.z)\n\t\t{\n\t\t\tsolved_position = com;\n\t\t}\n\n\t\tvoxels.voxels[trueIndex].vertPoint = solved_position;\n\t\tvoxels.voxels[trueIndex].avgNormal = averageNormal;\n\t\tvoxels.voxels[trueIndex].numPoints = f32(edgeCount);\n\t\tvoxels.voxels[trueIndex].corners = f32(voxelMaterials.voxelMaterials[voxelIndex]);\n\t}\n}\n\n@compute @workgroup_size(1)\nfn computeMaterials(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n\t\tlet width = uniforms.width;\n    let index: u32 = GlobalInvocationID.z * width * width + GlobalInvocationID.y * width + GlobalInvocationID.x;\n    let cornerPos: vec3<f32> = vec3<f32>(f32(GlobalInvocationID.x) * uniforms.stride, f32(GlobalInvocationID.y) * uniforms.stride, f32(GlobalInvocationID.z) * uniforms.stride);\n\n    let density: f32 = getDensity(cornerPos + uniforms.chunkPosition);\n\n\t\tif (density < 0.0) {\n\t\t\tif (length(cornerPos + uniforms.chunkPosition) < 2000.0) {\n        //cornerMaterials.cornerMaterials[index] = u32(random(vec2(f32(index))) * 255.0) + 1;\n\t\t\t  cornerMaterials.cornerMaterials[index] = 256u;\n\t\t\t} else {\n        cornerMaterials.cornerMaterials[index] = u32(length(cornerPos) / uniforms.stride * 256.0);\n\t\t\t}\n\t\t} else {\n\t\t\tcornerMaterials.cornerMaterials[index] = 0u;\n\t\t}\n}");

/***/ }),

/***/ "./node_modules/seedrandom/index.js":
/*!******************************************!*\
  !*** ./node_modules/seedrandom/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

// alea, a 53-bit multiply-with-carry generator by Johannes Baagøe.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea = __webpack_require__(/*! ./lib/alea */ "./node_modules/seedrandom/lib/alea.js");

// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128 = __webpack_require__(/*! ./lib/xor128 */ "./node_modules/seedrandom/lib/xor128.js");

// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow = __webpack_require__(/*! ./lib/xorwow */ "./node_modules/seedrandom/lib/xorwow.js");

// xorshift7, by François Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7 = __webpack_require__(/*! ./lib/xorshift7 */ "./node_modules/seedrandom/lib/xorshift7.js");

// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096 = __webpack_require__(/*! ./lib/xor4096 */ "./node_modules/seedrandom/lib/xor4096.js");

// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei = __webpack_require__(/*! ./lib/tychei */ "./node_modules/seedrandom/lib/tychei.js");

// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr = __webpack_require__(/*! ./seedrandom */ "./node_modules/seedrandom/seedrandom.js");

sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;

module.exports = sr;


/***/ }),

/***/ "./node_modules/seedrandom/lib/alea.js":
/*!*********************************************!*\
  !*** ./node_modules/seedrandom/lib/alea.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -

// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



(function(global, module, define) {

function Alea(seed) {
  var me = this, mash = Mash();

  me.next = function() {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) { me.s0 += 1; }
  me.s1 -= mash(seed);
  if (me.s1 < 0) { me.s1 += 1; }
  me.s2 -= mash(seed);
  if (me.s2 < 0) { me.s2 += 1; }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function impl(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; }
  prng.double = function() {
    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
  };
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function(data) {
    data = String(data);
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}


if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.alea = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ }),

/***/ "./node_modules/seedrandom/lib/tychei.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/lib/tychei.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var b = me.b, c = me.c, d = me.d, a = me.a;
    b = (b << 25) ^ (b >>> 7) ^ c;
    c = (c - d) | 0;
    d = (d << 24) ^ (d >>> 8) ^ a;
    a = (a - b) | 0;
    me.b = b = (b << 20) ^ (b >>> 12) ^ c;
    me.c = c = (c - d) | 0;
    me.d = (d << 16) ^ (c >>> 16) ^ a;
    return me.a = (a - b) | 0;
  };

  /* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */

  me.a = 0;
  me.b = 0;
  me.c = 2654435769 | 0;
  me.d = 1367130551;

  if (seed === Math.floor(seed)) {
    // Integer seed.
    me.a = (seed / 0x100000000) | 0;
    me.b = seed | 0;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 20; k++) {
    me.b ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.a = f.a;
  t.b = f.b;
  t.c = f.c;
  t.d = f.d;
  return t;
};

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.tychei = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ }),

/***/ "./node_modules/seedrandom/lib/xor128.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/lib/xor128.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;

  // Set up generator function.
  me.next = function() {
    var t = me.x ^ (me.x << 11);
    me.x = me.y;
    me.y = me.z;
    me.z = me.w;
    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
  };

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xor128 = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ }),

/***/ "./node_modules/seedrandom/lib/xor4096.js":
/*!************************************************!*\
  !*** ./node_modules/seedrandom/lib/xor4096.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1004.3115v1.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    var w = me.w,
        X = me.X, i = me.i, t, v;
    // Update Weyl generator.
    me.w = w = (w + 0x61c88647) | 0;
    // Update xor generator.
    v = X[(i + 34) & 127];
    t = X[i = ((i + 1) & 127)];
    v ^= v << 13;
    t ^= t << 17;
    v ^= v >>> 15;
    t ^= t >>> 12;
    // Update Xor generator array state.
    v = X[i] = v ^ t;
    me.i = i;
    // Result is the combination.
    return (v + (w ^ (w >>> 16))) | 0;
  };

  function init(me, seed) {
    var t, v, i, j, w, X = [], limit = 128;
    if (seed === (seed | 0)) {
      // Numeric seeds initialize v, which is used to generates X.
      v = seed;
      seed = null;
    } else {
      // String seeds are mixed into v and X one character at a time.
      seed = seed + '\0';
      v = 0;
      limit = Math.max(limit, seed.length);
    }
    // Initialize circular array and weyl value.
    for (i = 0, j = -32; j < limit; ++j) {
      // Put the unicode characters into the array, and shuffle them.
      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
      // After 32 shuffles, take v as the starting w value.
      if (j === 0) w = v;
      v ^= v << 10;
      v ^= v >>> 15;
      v ^= v << 4;
      v ^= v >>> 13;
      if (j >= 0) {
        w = (w + 0x61c88647) | 0;     // Weyl.
        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
        i = (0 == t) ? i + 1 : 0;     // Count zeroes.
      }
    }
    // We have detected all zeroes; make the key nonzero.
    if (i >= 128) {
      X[(seed && seed.length || 0) & 127] = -1;
    }
    // Run the generator 512 times to further mix the state before using it.
    // Factoring this as a function slows the main generator, so it is just
    // unrolled here.  The weyl generator is not advanced while warming up.
    i = 127;
    for (j = 4 * 128; j > 0; --j) {
      v = X[(i + 34) & 127];
      t = X[i = ((i + 1) & 127)];
      v ^= v << 13;
      t ^= t << 17;
      v ^= v >>> 15;
      t ^= t >>> 12;
      X[i] = v ^ t;
    }
    // Storing state as object members is faster than using closure variables.
    me.w = w;
    me.X = X;
    me.i = i;
  }

  init(me, seed);
}

function copy(f, t) {
  t.i = f.i;
  t.w = f.w;
  t.X = f.X.slice();
  return t;
};

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.X) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xor4096 = impl;
}

})(
  this,                                     // window object or global
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);


/***/ }),

/***/ "./node_modules/seedrandom/lib/xorshift7.js":
/*!**************************************************!*\
  !*** ./node_modules/seedrandom/lib/xorshift7.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xorshift7" algorithm by
// François Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    // Update xor generator.
    var X = me.x, i = me.i, t, v, w;
    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
    X[i] = v;
    me.i = (i + 1) & 7;
    return v;
  };

  function init(me, seed) {
    var j, w, X = [];

    if (seed === (seed | 0)) {
      // Seed state array using a 32-bit integer.
      w = X[0] = seed;
    } else {
      // Seed state using a string.
      seed = '' + seed;
      for (j = 0; j < seed.length; ++j) {
        X[j & 7] = (X[j & 7] << 15) ^
            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
      }
    }
    // Enforce an array length of 8, not all zeroes.
    while (X.length < 8) X.push(0);
    for (j = 0; j < 8 && X[j] === 0; ++j);
    if (j == 8) w = X[7] = -1; else w = X[j];

    me.x = X;
    me.i = 0;

    // Discard an initial 256 values.
    for (j = 256; j > 0; --j) {
      me.next();
    }
  }

  init(me, seed);
}

function copy(f, t) {
  t.x = f.x.slice();
  t.i = f.i;
  return t;
}

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.x) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xorshift7 = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);



/***/ }),

/***/ "./node_modules/seedrandom/lib/xorwow.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/lib/xorwow.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var t = (me.x ^ (me.x >>> 2));
    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
    return (me.d = (me.d + 362437 | 0)) +
       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
  };

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;
  me.v = 0;

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    if (k == strseed.length) {
      me.d = me.x << 10 ^ me.x >>> 4;
    }
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  t.v = f.v;
  t.d = f.d;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xorwow = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ }),

/***/ "./node_modules/seedrandom/seedrandom.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/seedrandom.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
Copyright 2019 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function (global, pool, math) {
//
// The following constants are related to IEEE 754 limits.
//

var width = 256,        // each RC4 output is 0 <= x < 256
    chunks = 6,         // at least six RC4 outputs for each double
    digits = 52,        // there are 52 significant digits in a double
    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
    startdenom = math.pow(width, chunks),
    significance = math.pow(2, digits),
    overflow = significance * 2,
    mask = width - 1,
    nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed, options, callback) {
  var key = [];
  options = (options == true) ? { entropy: true } : (options || {});

  // Flatten the seed string or build one from local entropy if needed.
  var shortseed = mixkey(flatten(
    options.entropy ? [seed, tostring(pool)] :
    (seed == null) ? autoseed() : seed, 3), key);

  // Use the seed to initialize an ARC4 generator.
  var arc4 = new ARC4(key);

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.
  var prng = function() {
    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
        d = startdenom,                 //   and denominator d = 2 ^ 48.
        x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  prng.int32 = function() { return arc4.g(4) | 0; }
  prng.quick = function() { return arc4.g(4) / 0x100000000; }
  prng.double = prng;

  // Mix the randomness into accumulated entropy.
  mixkey(tostring(arc4.S), pool);

  // Calling convention: what to return as a function of prng, seed, is_math.
  return (options.pass || callback ||
      function(prng, seed, is_math_call, state) {
        if (state) {
          // Load the arc4 state from the given state if it has an S array.
          if (state.S) { copy(state, arc4); }
          // Only provide the .state method if requested via options.state.
          prng.state = function() { return copy(arc4, {}); }
        }

        // If called as a method of Math (Math.seedrandom()), mutate
        // Math.random because that is how seedrandom.js has worked since v1.0.
        if (is_math_call) { math[rngname] = prng; return seed; }

        // Otherwise, it is a newer calling convention, so return the
        // prng directly.
        else return prng;
      })(
  prng,
  shortseed,
  'global' in options ? options.global : (this == math),
  options.state);
}

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key) {
  var t, keylen = key.length,
      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) {
    s[i] = i++;
  }
  for (i = 0; i < width; i++) {
    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
    s[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  (me.g = function(count) {
    // Using instance members instead of closure state nearly doubles speed.
    var t, r = 0,
        i = me.i, j = me.j, s = me.S;
    while (count--) {
      t = s[i = mask & (i + 1)];
      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
    }
    me.i = i; me.j = j;
    return r;
    // For robust unpredictability, the function call below automatically
    // discards an initial batch of values.  This is called RC4-drop[256].
    // See http://google.com/search?q=rsa+fluhrer+response&btnI
  })(width);
}

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f, t) {
  t.i = f.i;
  t.j = f.j;
  t.S = f.S.slice();
  return t;
};

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
  var result = [], typ = (typeof obj), prop;
  if (depth && typ == 'object') {
    for (prop in obj) {
      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
    }
  }
  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
  var stringseed = seed + '', smear, j = 0;
  while (j < stringseed.length) {
    key[mask & j] =
      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
  }
  return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed() {
  try {
    var out;
    if (nodecrypto && (out = nodecrypto.randomBytes)) {
      // The use of 'out' to remember randomBytes makes tight minified code.
      out = out(width);
    } else {
      out = new Uint8Array(width);
      (global.crypto || global.msCrypto).getRandomValues(out);
    }
    return tostring(out);
  } catch (e) {
    var browser = global.navigator,
        plugins = browser && browser.plugins;
    return [+new Date, global, plugins, global.screen, tostring(pool)];
  }
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
  return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if ( true && module.exports) {
  module.exports = seedrandom;
  // When in node.js, try using crypto package for autoseeding.
  try {
    nodecrypto = __webpack_require__(/*! crypto */ "?8465");
  } catch (ex) {}
} else if (true) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return seedrandom; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}


// End anonymous scope, and pass initial values.
})(
  // global: `self` in browsers (including strict mode and web workers),
  // otherwise `this` in Node and other environments
  (typeof self !== 'undefined') ? self : this,
  [],     // pool: entropy pool starts empty
  Math    // math: package containing random, pow, and seedrandom
);


/***/ }),

/***/ "./node_modules/jasmine-core/lib/jasmine-core/jasmine.css":
/*!****************************************************************!*\
  !*** ./node_modules/jasmine-core/lib/jasmine-core/jasmine.css ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _css_loader_dist_cjs_js_jasmine_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../css-loader/dist/cjs.js!./jasmine.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/jasmine-core/lib/jasmine-core/jasmine.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_jasmine_css__WEBPACK_IMPORTED_MODULE_6__.default, options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_jasmine_css__WEBPACK_IMPORTED_MODULE_6__.default && _css_loader_dist_cjs_js_jasmine_css__WEBPACK_IMPORTED_MODULE_6__.default.locals ? _css_loader_dist_cjs_js_jasmine_css__WEBPACK_IMPORTED_MODULE_6__.default.locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";


var stylesInDOM = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };

    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);

  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }

      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };

  return updater;
}

module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();

        stylesInDOM.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


var memo = {};
/* istanbul ignore next  */

function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }

    memo[target] = styleTarget;
  }

  return memo[target];
}
/* istanbul ignore next  */


function insertBySelector(insert, style) {
  var target = getTarget(insert);

  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }

  target.appendChild(style);
}

module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}

module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;

  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}

module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";

  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }

  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }

  var needLayer = typeof obj.layer !== "undefined";

  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }

  css += obj.css;

  if (needLayer) {
    css += "}";
  }

  if (obj.media) {
    css += "}";
  }

  if (obj.supports) {
    css += "}";
  }

  var sourceMap = obj.sourceMap;

  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  options.styleTagTransform(css, styleElement, options.options);
}

function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }

  styleElement.parentNode.removeChild(styleElement);
}
/* istanbul ignore next  */


function domAPI(options) {
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}

module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }

    styleElement.appendChild(document.createTextNode(css));
  }
}

module.exports = styleTagTransform;

/***/ }),

/***/ "./src/compute-voxels.test.ts":
/*!************************************!*\
  !*** ./src/compute-voxels.test.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _raw_loader_compute_voxels_wgsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !!raw-loader!./compute-voxels.wgsl */ "./node_modules/raw-loader/dist/cjs.js!./src/compute-voxels.wgsl");
/* harmony import */ var seedrandom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! seedrandom */ "./node_modules/seedrandom/index.js");
/* harmony import */ var seedrandom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(seedrandom__WEBPACK_IMPORTED_MODULE_1__);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};


describe('compute-voxels', function () {
    describe('computeMaterials', function () {
        var materials;
        beforeAll(function () { return __awaiter(void 0, void 0, void 0, function () {
            var adapter, device, density, computeVoxels, computePipeline, permutations, random, i, i, permutationsBuffer, cornerMaterials, cornerMaterialsRead, uniformBufferSize, uniformBuffer, computeBindGroup, computeEncoder, computePassEncoder, copyEncoder, buffer, uniform, queue, arrayBuffer;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, navigator.gpu.requestAdapter()];
                    case 1:
                        adapter = _a.sent();
                        return [4 /*yield*/, adapter.requestDevice()];
                    case 2:
                        device = _a.sent();
                        density = "fn getDensity(worldPosition: vec3<f32>) -> f32 { \n        if (worldPosition.y < 3.0) {\n          return -1.0;\n        } else {\n          return 1.0;\n        }\n       }";
                        computeVoxels = _raw_loader_compute_voxels_wgsl__WEBPACK_IMPORTED_MODULE_0__.default.replace("#import density", density);
                        return [4 /*yield*/, device.createComputePipelineAsync({
                                layout: 'auto',
                                compute: {
                                    module: device.createShaderModule({
                                        code: computeVoxels,
                                    }),
                                    entryPoint: 'computeMaterials',
                                },
                            })];
                    case 3:
                        computePipeline = _a.sent();
                        permutations = new Int32Array(512);
                        random = new (seedrandom__WEBPACK_IMPORTED_MODULE_1___default())(6452);
                        for (i = 0; i < 256; i++)
                            permutations[i] = (256 * (random()));
                        for (i = 256; i < 512; i++)
                            permutations[i] = permutations[i - 256];
                        permutationsBuffer = device.createBuffer({
                            size: permutations.byteLength,
                            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                            mappedAtCreation: true,
                        });
                        new Int32Array(permutationsBuffer.getMappedRange()).set(permutations);
                        permutationsBuffer.unmap();
                        cornerMaterials = device.createBuffer({
                            size: Uint32Array.BYTES_PER_ELEMENT * 5 * 5 * 5,
                            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
                            mappedAtCreation: false,
                        });
                        cornerMaterialsRead = device.createBuffer({
                            size: Uint32Array.BYTES_PER_ELEMENT * 5 * 5 * 5,
                            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
                        });
                        uniformBufferSize = 4 * 5;
                        uniformBuffer = device.createBuffer({
                            size: uniformBufferSize,
                            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
                        });
                        computeBindGroup = device.createBindGroup({
                            layout: computePipeline.getBindGroupLayout(0),
                            entries: [
                                {
                                    binding: 1,
                                    resource: {
                                        buffer: cornerMaterials
                                    },
                                },
                                {
                                    binding: 5,
                                    resource: {
                                        buffer: uniformBuffer
                                    },
                                }
                            ]
                        });
                        computeEncoder = device.createCommandEncoder();
                        computePassEncoder = computeEncoder.beginComputePass();
                        computePassEncoder.setPipeline(computePipeline);
                        computePassEncoder.setBindGroup(0, computeBindGroup);
                        computePassEncoder.dispatchWorkgroups(5, 5, 5);
                        computePassEncoder.end();
                        copyEncoder = device.createCommandEncoder();
                        copyEncoder.copyBufferToBuffer(cornerMaterials, 0, cornerMaterialsRead, 0, Uint32Array.BYTES_PER_ELEMENT * 5 * 5 * 5);
                        buffer = new ArrayBuffer(4 * 5);
                        uniform = new Float32Array(buffer, 0, 4);
                        uniform[3] = 1;
                        new Uint32Array(buffer, 16, 1)[0] = 5;
                        device.queue.writeBuffer(uniformBuffer, 0, buffer, 0, buffer.byteLength);
                        queue = device.queue.onSubmittedWorkDone();
                        device.queue.submit([computeEncoder.finish(), copyEncoder.finish()]);
                        return [4 /*yield*/, queue];
                    case 4:
                        _a.sent();
                        return [4 /*yield*/, cornerMaterialsRead.mapAsync(GPUMapMode.READ)];
                    case 5:
                        _a.sent();
                        arrayBuffer = cornerMaterialsRead.getMappedRange();
                        materials = new Uint32Array(arrayBuffer).slice();
                        cornerMaterialsRead.unmap();
                        return [2 /*return*/];
                }
            });
        }); });
        it('then materials is not null', function () {
            var expectedResult = new Uint32Array(5 * 5 * 5);
            for (var x = 0; x < 5; x++)
                for (var y = 0; y < 5; y++)
                    for (var z = 0; z < 5; z++) {
                        expectedResult[z * 5 * 5 + y * 5 + x] = y < 3 ? 1 : 0;
                    }
            expect(materials).toEqual(expectedResult);
        });
    });
});


/***/ }),

/***/ "./src/renderer.test.ts":
/*!******************************!*\
  !*** ./src/renderer.test.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./renderer */ "./src/renderer.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};

describe('Renderer', function () {
    var canvas;
    beforeEach(function () {
        canvas = document.getElementById('canvas');
    });
    it('should not throw when initialized', function () { return __awaiter(void 0, void 0, void 0, function () {
        var renderer;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    renderer = new _renderer__WEBPACK_IMPORTED_MODULE_0__.default();
                    return [4 /*yield*/, expectAsync(renderer.init(canvas)).toBeResolved()];
                case 1:
                    _a.sent();
                    expect(function () { return renderer.configure(canvas.width, canvas.height); }).not.toThrow();
                    expect(function () { return renderer.render(function () { }); }).not.toThrow();
                    return [2 /*return*/];
            }
        });
    }); });
});


/***/ }),

/***/ "./src/renderer.ts":
/*!*************************!*\
  !*** ./src/renderer.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var Renderer = /** @class */ (function () {
    function Renderer() {
    }
    Renderer.prototype.init = function (canvas) {
        return __awaiter(this, void 0, void 0, function () {
            var adapter, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, navigator.gpu.requestAdapter()];
                    case 1:
                        adapter = _b.sent();
                        _a = this;
                        return [4 /*yield*/, adapter.requestDevice()];
                    case 2:
                        _a.device = _b.sent();
                        this.context = canvas.getContext('webgpu');
                        this.presentationFormat = navigator.gpu.getPreferredCanvasFormat();
                        return [2 /*return*/];
                }
            });
        });
    };
    Renderer.prototype.configure = function (width, height) {
        this.context.configure({
            device: this.device,
            format: this.presentationFormat,
            alphaMode: 'opaque'
        });
        this.depthTexture = this.device.createTexture({
            size: { width: width, height: height },
            format: 'depth24plus-stencil8',
            usage: GPUTextureUsage.RENDER_ATTACHMENT,
        });
    };
    Renderer.prototype.render = function (callback) {
        var commandEncoder = this.device.createCommandEncoder();
        var textureView = this.context.getCurrentTexture().createView();
        var renderPassDescriptor = {
            colorAttachments: [
                {
                    view: textureView,
                    clearValue: { r: 75 / 255, g: 0 / 255, b: 130 / 255, a: 1.0 },
                    loadOp: 'clear',
                    storeOp: 'store'
                }
            ],
            depthStencilAttachment: {
                view: this.depthTexture.createView(),
                depthClearValue: 1.0,
                depthLoadOp: 'clear',
                depthStoreOp: 'store',
                stencilClearValue: 0,
                stencilLoadOp: 'clear',
                stencilStoreOp: 'store',
            }
        };
        var passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
        callback(passEncoder);
        passEncoder.end();
        this.device.queue.submit([commandEncoder.finish()]);
    };
    return Renderer;
}());
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Renderer);


/***/ }),

/***/ "./src/tests.ts":
/*!**********************!*\
  !*** ./src/tests.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jasmine_core_lib_jasmine_core_jasmine_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jasmine-core/lib/jasmine-core/jasmine.css */ "./node_modules/jasmine-core/lib/jasmine-core/jasmine.css");
/* harmony import */ var jasmine_core_lib_jasmine_core_jasmine_html_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jasmine-core/lib/jasmine-core/jasmine-html.js */ "./node_modules/jasmine-core/lib/jasmine-core/jasmine-html.js");
/* harmony import */ var jasmine_core_lib_jasmine_core_jasmine_html_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jasmine_core_lib_jasmine_core_jasmine_html_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var jasmine_core_lib_jasmine_core_boot0_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jasmine-core/lib/jasmine-core/boot0.js */ "./node_modules/jasmine-core/lib/jasmine-core/boot0.js");
/* harmony import */ var jasmine_core_lib_jasmine_core_boot0_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jasmine_core_lib_jasmine_core_boot0_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var jasmine_core_lib_jasmine_core_boot1_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! jasmine-core/lib/jasmine-core/boot1.js */ "./node_modules/jasmine-core/lib/jasmine-core/boot1.js");
/* harmony import */ var jasmine_core_lib_jasmine_core_boot1_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(jasmine_core_lib_jasmine_core_boot1_js__WEBPACK_IMPORTED_MODULE_3__);




// @ts-ignore
var tests = __webpack_require__("./src sync recursive .test.(j|t)s$");
var testFiles = tests.keys();
for (var test in testFiles) {
    tests(testFiles[test]);
}


/***/ }),

/***/ "./src/world-generator.test.ts":
/*!*************************************!*\
  !*** ./src/world-generator.test.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _world_generator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./world-generator */ "./src/world-generator.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};

describe('World Generator', function () {
    var worldGenerator;
    beforeEach(function () {
        worldGenerator = new _world_generator__WEBPACK_IMPORTED_MODULE_0__.default(8);
    });
    describe('when init is called', function () {
        var info;
        beforeEach(function () {
            info = worldGenerator.init(3, 20, 43);
        });
        it('position is rounded to nearest stride', function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                expect(info.x).toEqual(0);
                expect(info.y).toEqual(24);
                expect(info.z).toEqual(40);
                return [2 /*return*/];
            });
        }); });
        it('current stride defaults to minimum stride', function () {
            expect(info.stride).toEqual(8);
        });
        it('previousOffset is correct', function () {
            expect(info.previousOffset).toEqual(-4);
        });
        it('layer is correct', function () {
            expect(info.layer).toEqual(1);
        });
    });
    describe('when next is called', function () {
        it('returns origin position', function () {
            var _a = __read(worldGenerator.next({
                x: 0, y: 0, z: 0, stride: 8, iteration: 0, layer: 1, previousOffset: -4
            }), 2), result = _a[0], info = _a[1];
            expect(result).toEqual({
                x: -4, y: -4, z: -4, stride: 8
            });
            expect(info).toEqual({
                x: 0, y: 0, z: 0, stride: 8, iteration: 1, layer: 1, previousOffset: -4
            });
        });
        it('returns origin position for iteration 1', function () {
            var _a = __read(worldGenerator.next({
                x: 0, y: 0, z: 0, stride: 8, iteration: 1, layer: 1, previousOffset: -4
            }), 2), result = _a[0], info = _a[1];
            expect(result).toEqual({
                x: -4, y: -4, z: 4, stride: 8
            });
            expect(info).toEqual({
                x: 0, y: 0, z: 0, stride: 8, iteration: 2, layer: 1, previousOffset: -4
            });
        });
        it('returns origin position for second layer', function () {
            var _a = __read(worldGenerator.next({
                x: 0, y: 0, z: 0, stride: 8, iteration: 0, layer: 2, previousOffset: -4
            }), 2), result = _a[0], info = _a[1];
            expect(result).toEqual({
                x: -12, y: -12, z: -12, stride: 8
            });
            expect(info).toEqual({
                x: 0, y: 0, z: 0, stride: 8, iteration: 1, layer: 2, previousOffset: -4
            });
        });
        it('returns origin position for second layer second iteration', function () {
            var _a = __read(worldGenerator.next({
                x: 0, y: 0, z: 0, stride: 8, iteration: 6, layer: 2, previousOffset: -4
            }), 2), result = _a[0], info = _a[1];
            expect(result).toEqual({
                x: -12, y: -4, z: 4, stride: 8
            });
            expect(info).toEqual({
                x: 0, y: 0, z: 0, stride: 8, iteration: 7, layer: 2, previousOffset: -4
            });
        });
        it('offsets position by root', function () {
            var _a = __read(worldGenerator.next({
                x: 40, y: 24, z: 32, stride: 8, iteration: 0, layer: 1, previousOffset: -4
            }), 2), result = _a[0], info = _a[1];
            expect(result).toEqual({
                x: 36, y: 20, z: 28, stride: 8
            });
            expect(info).toEqual({
                x: 40, y: 24, z: 32, stride: 8, iteration: 1, layer: 1, previousOffset: -4
            });
        });
        it('offsets position by iteration', function () {
            var _a = __read(worldGenerator.next({
                x: 40, y: 24, z: 32, stride: 8, iteration: 1, layer: 1, previousOffset: -4
            }), 2), result = _a[0], info = _a[1];
            expect(result).toEqual({
                x: 36, y: 20, z: 36, stride: 8
            });
            expect(info).toEqual({
                x: 40, y: 24, z: 32, stride: 8, iteration: 2, layer: 1, previousOffset: -4
            });
        });
        it('offsets position by last iteration', function () {
            var _a = __read(worldGenerator.next({
                x: 40, y: 24, z: 32, stride: 8, iteration: 7, layer: 1, previousOffset: -4
            }), 2), result = _a[0], info = _a[1];
            expect(result).toEqual({
                x: 44, y: 28, z: 36, stride: 8
            });
            expect(info).toEqual({
                x: 40, y: 24, z: 32, stride: 8, iteration: 0, layer: 2, previousOffset: -4
            });
        });
        it('offsets position by last layer', function () {
            var _a = __read(worldGenerator.next({
                x: 40, y: 24, z: 32, stride: 8, iteration: 55, layer: 2, previousOffset: -4
            }), 2), result = _a[0], info = _a[1];
            expect(result).toEqual({
                x: 52, y: 36, z: 44, stride: 8
            });
            expect(info).toEqual({
                x: 40, y: 24, z: 32, stride: 16, iteration: 0, layer: 1, previousOffset: 8
            });
        });
        it('returns correct position for next stride', function () {
            var _a = __read(worldGenerator.next({
                x: 0, y: 0, z: 0, stride: 16, iteration: 0, layer: 1, previousOffset: 8
            }), 2), result = _a[0], info = _a[1];
            expect(result).toEqual({
                x: -24, y: -24, z: -24, stride: 16
            });
            expect(info).toEqual({
                x: 0, y: 0, z: 0, stride: 16, iteration: 1, layer: 1, previousOffset: 8
            });
        });
        it('returns correct position 32/0/1', function () {
            var _a = __read(worldGenerator.next({
                x: 0, y: 0, z: 0, stride: 32, iteration: 0, layer: 1, previousOffset: 48
            }), 2), result = _a[0], info = _a[1];
            expect(result).toEqual({
                x: -80, y: -80, z: -80, stride: 32
            });
            expect(info).toEqual({
                x: 0, y: 0, z: 0, stride: 32, iteration: 1, layer: 1, previousOffset: 48
            });
        });
    });
    describe('when radius is called', function () {
        var expectedResults = [
            { layer: 1, stride: 8, previousOffset: -4, result: 4 },
            { layer: 2, stride: 8, previousOffset: -4, result: 12 },
            { layer: 1, stride: 16, previousOffset: 8, result: 24 },
            { layer: 2, stride: 16, previousOffset: 8, result: 40 },
            { layer: -2, stride: 16, previousOffset: 8, result: -40 },
        ];
        var _loop_1 = function (i) {
            var _a = expectedResults[i], layer = _a.layer, stride = _a.stride, previousOffset = _a.previousOffset, result = _a.result;
            it("then ring ".concat(i + 1, " is correct"), function () {
                expect(worldGenerator.radius(layer, stride, previousOffset)).toEqual(result);
            });
        };
        for (var i = 0; i < expectedResults.length; i++) {
            _loop_1(i);
        }
    });
    describe('when layerRadius is called', function () {
        var expectedResults = [
            { layer: 1, stride: 8, result: 1 },
            { layer: 2, stride: 8, result: 2 },
            { layer: 1, stride: 16, result: 2 },
            { layer: 2, stride: 16, result: 3 },
            { layer: 3, stride: 16, result: 4 },
            { layer: 1, stride: 32, result: 3 },
            { layer: 2, stride: 32, result: 4 },
        ];
        var _loop_2 = function (i) {
            var _a = expectedResults[i], layer = _a.layer, stride = _a.stride, result = _a.result;
            it("then ring ".concat(i + 1, " is correct"), function () {
                expect(worldGenerator.layerRadius(layer, stride)).toEqual(result);
            });
        };
        for (var i = 0; i < expectedResults.length; i++) {
            _loop_2(i);
        }
    });
    describe('when layerCount is called', function () {
        it('returns 2 for first stride', function () {
            expect(worldGenerator.layerCount(8)).toEqual(2);
        });
        it('returns 3 for second stride', function () {
            expect(worldGenerator.layerCount(16)).toEqual(3);
        });
        it('returns 2 for subsequent strides', function () {
            for (var i = 32; i < 1024; i += i) {
                expect(worldGenerator.layerCount(i)).toEqual(2);
            }
        });
    });
    describe('generate points', function () {
        it('returns the correct values', function () {
            expect((0,_world_generator__WEBPACK_IMPORTED_MODULE_0__.generatePoints)(1)).toEqual([
                { x: -1, y: -1, z: -1 },
                { x: -1, y: -1, z: 1 },
                { x: -1, y: 1, z: -1 },
                { x: -1, y: 1, z: 1 },
                { x: 1, y: -1, z: -1 },
                { x: 1, y: -1, z: 1 },
                { x: 1, y: 1, z: -1 },
                { x: 1, y: 1, z: 1 },
            ]);
        });
        it('returns the correct values 2', function () {
            expect((0,_world_generator__WEBPACK_IMPORTED_MODULE_0__.generatePoints)(2).length).toEqual(56);
        });
    });
});


/***/ }),

/***/ "./src/world-generator.ts":
/*!********************************!*\
  !*** ./src/world-generator.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WorldPosition": () => (/* binding */ WorldPosition),
/* harmony export */   "generatePoints": () => (/* binding */ generatePoints),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var WorldPosition = /** @class */ (function () {
    function WorldPosition() {
    }
    WorldPosition.equal = function (a, b) {
        return a.stride == b.stride && a.x == b.x && a.y == b.y && a.z == b.z;
    };
    return WorldPosition;
}());

function fixPoint(i) {
    if (i >= 0)
        return i + 1;
    return i;
}
function generatePoints(radius) {
    var points = [];
    var diameter = radius * 2;
    for (var x = 0; x < diameter; x++)
        for (var y = 0; y < diameter; y++)
            for (var z = 0; z < diameter; z++) {
                if (!(x === 0 || x === diameter - 1 || y === 0 || y === diameter - 1 || z === 0 || z === diameter - 1)) {
                    continue;
                }
                var point = {
                    x: fixPoint(x - radius),
                    y: fixPoint(y - radius),
                    z: fixPoint(z - radius)
                };
                points.push(point);
            }
    return points;
}
var points = [];
for (var i = 0; i <= 6; i++) {
    points[i] = generatePoints(i);
}
var WorldGenerator = /** @class */ (function () {
    function WorldGenerator(minStride) {
        this.minStride = minStride;
    }
    WorldGenerator.prototype.init = function (x, y, z) {
        return {
            x: Math.round(x / this.minStride) * this.minStride,
            y: Math.round(y / this.minStride) * this.minStride,
            z: Math.round(z / this.minStride) * this.minStride,
            stride: this.minStride,
            iteration: 0,
            layer: 1,
            previousOffset: -1 * this.minStride / 2
        };
    };
    WorldGenerator.prototype.layerRadius = function (layer, stride) {
        if (stride === this.minStride) {
            return layer;
        }
        if (stride === this.minStride * 2) {
            return layer + 1;
        }
        return layer + 2;
    };
    WorldGenerator.prototype.radius = function (layer, stride, previousOffset) {
        return Math.sign(layer) * (previousOffset + (Math.abs(layer) * stride));
    };
    WorldGenerator.prototype.layerCount = function (stride) {
        if (stride == this.minStride * 2)
            return 3;
        return 2;
    };
    WorldGenerator.prototype.next = function (info) {
        var offsets = points[this.layerRadius(info.layer, info.stride)];
        var offset = offsets[info.iteration];
        var halfStride = info.stride / 2;
        var iteration = info.iteration + 1;
        var layer = info.layer;
        var stride = info.stride;
        var previousOffset = info.previousOffset;
        if (iteration >= offsets.length) {
            iteration = 0;
            layer++;
            var layerCount = this.layerCount(info.stride);
            if (layer > layerCount) {
                layer = 1;
                stride *= 2;
                previousOffset = this.radius(info.layer, info.stride, info.previousOffset) - info.stride / 2;
            }
        }
        return [
            {
                x: info.stride * offset.x + info.x - Math.sign(offset.x) * halfStride,
                y: info.stride * offset.y + info.y - Math.sign(offset.y) * halfStride,
                z: info.stride * offset.z + info.z - Math.sign(offset.z) * halfStride,
                stride: info.stride
            },
            __assign(__assign({}, info), { iteration: iteration, layer: layer, stride: stride, previousOffset: previousOffset })
        ];
    };
    return WorldGenerator;
}());
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WorldGenerator);


/***/ }),

/***/ "./src sync recursive .test.(j|t)s$":
/*!*********************************!*\
  !*** ./src/ sync .test.(j|t)s$ ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./compute-voxels.test.ts": "./src/compute-voxels.test.ts",
	"./renderer.test.ts": "./src/renderer.test.ts",
	"./world-generator.test.ts": "./src/world-generator.test.ts"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./src sync recursive .test.(j|t)s$";

/***/ }),

/***/ "?8465":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd define */
/******/ 	(() => {
/******/ 		__webpack_require__.amdD = function () {
/******/ 			throw new Error('define cannot be used indirect');
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./src/tests.ts");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL25vZGVfbW9kdWxlcy9qYXNtaW5lLWNvcmUvbGliL2phc21pbmUtY29yZS9qYXNtaW5lLmNzcyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qcyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL25vZGVfbW9kdWxlcy9qYXNtaW5lLWNvcmUvbGliL2phc21pbmUtY29yZS9ib290MC5qcyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL25vZGVfbW9kdWxlcy9qYXNtaW5lLWNvcmUvbGliL2phc21pbmUtY29yZS9ib290MS5qcyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL25vZGVfbW9kdWxlcy9qYXNtaW5lLWNvcmUvbGliL2phc21pbmUtY29yZS9qYXNtaW5lLWh0bWwuanMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvLi9ub2RlX21vZHVsZXMvamFzbWluZS1jb3JlL2xpYi9qYXNtaW5lLWNvcmUvamFzbWluZS5qcyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL3NyYy9jb21wdXRlLXZveGVscy53Z3NsIiwid2VicGFjazovL3dlYmdwdS1jb21wdXRlLy4vbm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIvYWxlYS5qcyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL25vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi90eWNoZWkuanMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yMTI4LmpzIiwid2VicGFjazovL3dlYmdwdS1jb21wdXRlLy4vbm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vbGliL3hvcjQwOTYuanMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yc2hpZnQ3LmpzIiwid2VicGFjazovL3dlYmdwdS1jb21wdXRlLy4vbm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vbGliL3hvcndvdy5qcyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL25vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL3NlZWRyYW5kb20uanMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvLi9ub2RlX21vZHVsZXMvamFzbWluZS1jb3JlL2xpYi9qYXNtaW5lLWNvcmUvamFzbWluZS5jc3M/NGU4ZiIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzIiwid2VicGFjazovL3dlYmdwdS1jb21wdXRlLy4vc3JjL2NvbXB1dGUtdm94ZWxzLnRlc3QudHMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvLi9zcmMvcmVuZGVyZXIudGVzdC50cyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL3NyYy9yZW5kZXJlci50cyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL3NyYy90ZXN0cy50cyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL3NyYy93b3JsZC1nZW5lcmF0b3IudGVzdC50cyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS8uL3NyYy93b3JsZC1nZW5lcmF0b3IudHMiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvL2hvbWUvcnVubmVyL3dvcmsvd2ViZ3B1LXdvcmxkL3dlYmdwdS13b3JsZC9zcmN8c3luY3wvLnRlc3QuKGp8dClzJC8iLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvaWdub3JlZHxjcnlwdG8iLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvd2VicGFjay9ydW50aW1lL2FtZCBkZWZpbmUiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvd2VicGFjay9ydW50aW1lL2FtZCBvcHRpb25zIiwid2VicGFjazovL3dlYmdwdS1jb21wdXRlL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL3dlYmdwdS1jb21wdXRlL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL3dlYmdwdS1jb21wdXRlL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vd2ViZ3B1LWNvbXB1dGUvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly93ZWJncHUtY29tcHV0ZS93ZWJwYWNrL3J1bnRpbWUvbm9kZSBtb2R1bGUgZGVjb3JhdG9yIiwid2VicGFjazovL3dlYmdwdS1jb21wdXRlL3dlYnBhY2svc3RhcnR1cCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNtRztBQUNqQjtBQUNsRiw4QkFBOEIsc0VBQTJCLENBQUMsK0VBQXFDO0FBQy9GO0FBQ0EsNkRBQTZELFFBQVEsdUJBQXVCLEdBQUcsNEJBQTRCLGdCQUFnQiwyQkFBMkIsaUJBQWlCLGlCQUFpQixvQkFBb0IsdURBQXVELHNCQUFzQixnQkFBZ0IsR0FBRyw0QkFBNEIsMEJBQTBCLEdBQUcsa0NBQWtDLCtCQUErQixHQUFHLDhMQUE4TCxjQUFjLHNCQUFzQixHQUFHLHdaQUF3WixzQkFBc0IsdUJBQXVCLEdBQUcsMENBQTBDLHVCQUF1QixHQUFHLHlEQUF5RCxxQ0FBcUMscXdFQUFxd0UseUNBQXlDLCtoWEFBK2hYLCtCQUErQiw2QkFBNkIsa0NBQWtDLDBCQUEwQixtQkFBbUIsZ0JBQWdCLGdCQUFnQixpQkFBaUIsR0FBRywyREFBMkQsc0JBQXNCLHVCQUF1QixhQUFhLEdBQUcsMkNBQTJDLG9CQUFvQixnQkFBZ0IsR0FBRywyQ0FBMkMsZ0JBQWdCLEdBQUcsMENBQTBDLHFCQUFxQixHQUFHLDRDQUE0QyxnQkFBZ0IsaUJBQWlCLHNCQUFzQix1QkFBdUIsR0FBRyxrREFBa0QscUJBQXFCLG1CQUFtQixHQUFHLHFEQUFxRCwwQkFBMEIsaUJBQWlCLGdCQUFnQixvQkFBb0IsR0FBRyxvRUFBb0Usb0JBQW9CLEdBQUcsMkVBQTJFLG1CQUFtQixtQkFBbUIsR0FBRyxvRUFBb0UscUJBQXFCLEdBQUcsMkVBQTJFLG1CQUFtQixtQkFBbUIsc0JBQXNCLHNCQUFzQixHQUFHLHNFQUFzRSxvQkFBb0IsR0FBRyw2RUFBNkUsbUJBQW1CLG1CQUFtQixHQUFHLGlGQUFpRixvQkFB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VUFBVSxLQUFLLEtBQUssVUFBVSxNQUFNLEtBQUssVUFBVSxVQUFVLEtBQUssS0FBSyxVQUFVLFlBQVksYUFBYSxXQUFXLFlBQVksYUFBYSxNQUFNLEtBQUssVUFBVSxZQUFZLE1BQU0sS0FBSyxZQUFZLFdBQVcsVUFBVSxZQUFZLGFBQWEsYUFBYSxhQUFhLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxZQUFZLFdBQVcsVUFBVSxVQUFVLEtBQUssS0FBSyxZQUFZLGFBQWEsTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLFlBQVksYUFBYSxhQUFhLFdBQVcsS0FBSyxLQUFLLFlBQVksV0FBVyxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLE1BQU0sVUFBVSxLQUFLLE1BQU0sVUFBVSxLQUFLLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxhQUFhLFdBQVcsVUFBVSxNQUFNLEtBQUssVUFBVSxZQUFZLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxZQUFZLE1BQU0sS0FBSyxVQUFVLEtBQUssS0FBSyxZQUFZLE1BQU0sS0FBSyxZQUFZLFdBQVcsS0FBSyxLQUFLLFVBQVUsS0FBSyxLQUFLLFlBQVksV0FBVyxZQUFZLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxZQUFZLGFBQWEsV0FBVyxZQUFZLFdBQVcsWUFBWSxhQUFhLGFBQWEsTUFBTSxLQUFLLFVBQVUsWUFBWSxXQUFXLFlBQVksTUFBTSxLQUFLLFVBQVUsS0FBSyxLQUFLLFlBQVksTUFBTSxLQUFLLFVBQVUsWUFBWSxXQUFXLEtBQUssS0FBSyxZQUFZLFdBQVcsVUFBVSxZQUFZLGFBQWEs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QUNBLEU7Ozs7Ozs7Ozs7QUNyQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxtQkFBTyxDQUFDLDZFQUFjOztBQUV0RTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7O0FDL0REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrREFBK0QsSUFBSTtBQUNuRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7QUNuSUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsbUJBQU8sQ0FBQyw2RUFBYzs7QUFFcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxxQ0FBcUM7QUFDOUM7QUFDQTtBQUNBLFdBQVcsOEJBQThCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLDZCQUE2QiwrQkFBK0I7QUFDNUQ7QUFDQSx5QkFBeUIsc0NBQXNDO0FBQy9ELDBCQUEwQiw2QkFBNkI7QUFDdkQ7QUFDQTtBQUNBLFdBQVcsK0JBQStCO0FBQzFDLDRCQUE0QixnQ0FBZ0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLCtCQUErQjs7QUFFbkU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQ0FBZ0M7QUFDM0M7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDJDQUEyQztBQUN4RDtBQUNBO0FBQ0EsZUFBZSw0Q0FBNEM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdDQUFnQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQ0FBZ0M7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0JBQStCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQkFBaUIsZ0NBQWdDO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDJDQUEyQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwREFBMEQ7QUFDdkUsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxlQUFlLGdEQUFnRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkRBQTZEO0FBQzFFO0FBQ0E7QUFDQSxlQUFlLGlEQUFpRDtBQUNoRTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxrREFBa0Q7QUFDM0Q7QUFDQSwwQkFBMEIsZ0NBQWdDO0FBQzFEO0FBQ0E7O0FBRUEscUJBQXFCLHNDQUFzQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0NBQXNDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUNBQW1DO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzQ0FBc0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxTQUFTLGlDQUFpQztBQUMxQztBQUNBO0FBQ0EsV0FBVyx3Q0FBd0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsaUNBQWlDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrRUFBa0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsaUJBQWlCLG9DQUFvQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDZCQUE2QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGlCQUFpQixvQ0FBb0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxtQ0FBbUM7QUFDNUMsMkJBQTJCLCtCQUErQjtBQUMxRDtBQUNBO0FBQ0EsV0FBVywrQkFBK0I7QUFDMUM7QUFDQTtBQUNBLGFBQWEsdUNBQXVDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxlQUFlLHVEQUF1RDtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzQ0FBc0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGVBQWUsNERBQTREO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9DQUFvQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZUFBZSwwREFBMEQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUNBQXFDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxlQUFlLDJEQUEyRDtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbUNBQW1DO0FBQzVDO0FBQ0E7QUFDQSxXQUFXLG9EQUFvRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qix1Q0FBdUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QyxZQUFZO0FBQ25EO0FBQ0E7QUFDQSxTQUFTLGdDQUFnQztBQUN6QztBQUNBO0FBQ0E7QUFDQSxXQUFXLDZEQUE2RDtBQUN4RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIscUJBQXFCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7OztBQzk3QkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEtBQTZCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUJBQU07QUFDckIsc0JBQXNCLHFCQUFNO0FBQzVCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsOEJBQThCO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFNBQVM7QUFDM0UsTUFBTSxpQkFBaUIsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0I7QUFDN0QsTUFBTSxlQUFlO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLG9DQUFvQyw2QkFBNkI7QUFDakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiwrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2QkFBNkI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkdBQTJHO0FBQzNHO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkdBQTJHO0FBQzNHO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG9CQUFvQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0QkFBNEIsc0NBQXNDLGdDQUFnQztBQUM1SDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsSUFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQ0FBa0MsY0FBYyxLQUFLO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLCtDQUErQztBQUMvQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLE9BQU87QUFDekIsa0JB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VztBQUNYO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLG1EQUFtRCxjQUFjO0FBQ2pFO0FBQ0Esb0RBQW9ELGNBQWM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixhQUFhLEVBQUU7QUFDZixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxnQ0FBZ0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLGlCQUFpQiw0QkFBNEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOEJBQThCO0FBQy9DO0FBQ0E7O0FBRUEsdUJBQXVCLDhCQUE4QjtBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0JBQStCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUNBQWlDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQ0FBa0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrQkFBK0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsK0JBQStC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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLGFBQWE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLGFBQWE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLGFBQWE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxhQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxhQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxhQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sYUFBYTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLGFBQWE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sYUFBYTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLGFBQWE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sYUFBYTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxhQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLGFBQWE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sYUFBYTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxnQ0FBZ0Msc0JBQXNCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCx3Q0FBd0MsaUNBQWlDOztBQUV6RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sYUFBYSxnQkFBZ0IsVUFBVTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sYUFBYSxzQkFBc0IsVUFBVSxzQ0FBc0MsVUFBVTtBQUNuRztBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUksYUFBYSxVQUFVLGtEQUFrRCxVQUFVO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sYUFBYSxnQkFBZ0IsVUFBVTtBQUM3QztBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLGFBQWEsZ0JBQWdCLFVBQVU7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZUFBZSxtQ0FBbUM7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLLG1EQUFtRDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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RUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLFNBQVMsRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFDO2FBQ3hFLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLDBCQUEwQixFQUFFO1lBQ3pCLGdCQUFpQixjQUFjLENBQUMsSUFBSSxDQUFDO2dCQUN2QyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLFNBQVMsRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFDO2FBQzNFLENBQUMsTUFGRyxNQUFNLFVBQUUsSUFBSSxRQUVmLENBQUM7WUFFSCxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDO2dCQUNyQixDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsQ0FBQzthQUMvQixDQUFDLENBQUM7WUFFSCxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDO2dCQUNuQixDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLFNBQVMsRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFDO2FBQzNFLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLCtCQUErQixFQUFFO1lBQzlCLGdCQUFpQixjQUFjLENBQUMsSUFBSSxDQUFDO2dCQUN2QyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLFNBQVMsRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFDO2FBQzNFLENBQUMsTUFGRyxNQUFNLFVBQUUsSUFBSSxRQUVmLENBQUM7WUFFSCxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDO2dCQUNyQixDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsQ0FBQzthQUMvQixDQUFDLENBQUM7WUFFSCxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDO2dCQUNuQixDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLFNBQVMsRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFDO2FBQzNFLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLG9DQUFvQyxFQUFFO1lBQ25DLGdCQUFpQixjQUFjLENBQUMsSUFBSSxDQUFDO2dCQUN2QyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLFNBQVMsRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFDO2FBQzNFLENBQUMsTUFGRyxNQUFNLFVBQUUsSUFBSSxRQUVmLENBQUM7WUFFSCxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDO2dCQUNyQixDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsQ0FBQzthQUMvQixDQUFDLENBQUM7WUFFSCxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDO2dCQUNu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QztBQUFELENBQUM7Ozs7Ozs7Ozs7OztBQ3BJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUQ7Ozs7Ozs7Ozs7QUN4QkEsZTs7Ozs7O1VDQUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7V0N4QkE7V0FDQTtXQUNBLEU7Ozs7O1dDRkEsOEI7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLGdDQUFnQyxZQUFZO1dBQzVDO1dBQ0EsRTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHdDQUF3Qyx5Q0FBeUM7V0FDakY7V0FDQTtXQUNBLEU7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSxFQUFFO1dBQ0Y7V0FDQTtXQUNBLENBQUMsSTs7Ozs7V0NQRCx3Rjs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSxzREFBc0Qsa0JBQWtCO1dBQ3hFO1dBQ0EsK0NBQStDLGNBQWM7V0FDN0QsRTs7Ozs7V0NOQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEU7Ozs7VUNKQTtVQUNBO1VBQ0E7VUFDQSIsImZpbGUiOiJ0ZXN0cy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIkBjaGFyc2V0IFxcXCJVVEYtOFxcXCI7XFxuYm9keSB7XFxuICBvdmVyZmxvdy15OiBzY3JvbGw7XFxufVxcblxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlO1xcbiAgcGFkZGluZzogNXB4O1xcbiAgbWFyZ2luOiAtOHB4O1xcbiAgZm9udC1zaXplOiAxMXB4O1xcbiAgZm9udC1mYW1pbHk6IE1vbmFjbywgXFxcIkx1Y2lkYSBDb25zb2xlXFxcIiwgbW9ub3NwYWNlO1xcbiAgbGluZS1oZWlnaHQ6IDE0cHg7XFxuICBjb2xvcjogIzMzMztcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciBhIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciBhOmhvdmVyIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIHAsIC5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgaDEsIC5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgaDIsIC5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgaDMsIC5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgaDQsIC5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgaDUsIC5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgaDYge1xcbiAgbWFyZ2luOiAwO1xcbiAgbGluZS1oZWlnaHQ6IDE0cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFubmVyLFxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnksXFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdW1tYXJ5LFxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtcmVzdWx0LW1lc3NhZ2UsXFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zcGVjIC5qYXNtaW5lLWRlc2NyaXB0aW9uLFxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3BlYy1kZXRhaWwgLmphc21pbmUtZGVzY3JpcHRpb24sXFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1hbGVydCAuamFzbWluZS1iYXIsXFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdGFjay10cmFjZSB7XFxuICBwYWRkaW5nLWxlZnQ6IDlweDtcXG4gIHBhZGRpbmctcmlnaHQ6IDlweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYW5uZXIge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhbm5lciAuamFzbWluZS10aXRsZSB7XFxuICBiYWNrZ3JvdW5kOiB1cmwoXFxcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBRm9BQUFBWkNBTUFBQUNHdXNueUFBQUNkbEJNVkVYLy8vLy9BUCtBZ0lDcVZhcUFRSUNaTTVtQVZZQ1NTWktBUUlDT09ZNkFUWUNMUm91QVFJQ0pPNG1TU1lDSVJJaVBRSUNIUEllT1I0Q0dRNGFNUUlDR1BZYUxSb0NGUTRXS1FJQ1BQWVdKUllDT1FvU0pRSUNOUG9TSVJJQ01Rb1NIUUlDSFJJQ0tRb09IUUlDS1BvT0pPNE9KUVlPTVFJQ01RNENJUVlLTFFJQ0lQb0tMUTRDS1FJQ05Qb0tKUUlTTVE0S0pRb1NMUVlLSlFJU0xRNEtJUW9TS1FZS0lRSUNJUUlTTVFvU0tRWUtMUUlPTFFvT0pRWUdMUUlPS1FJT01Rb0dLUVlPTFFZR0tRSU9MUW9HSlFZT0pRSU9LUVlHSlFJT0tRb0dLUUlHTFFJS0xRNEtLUW9HTFFZS0pRSUdLUVlLSlFJR0tRSUtKUW9HS1FZS0xRSUdLUVlLTFFJT0pRb0tLUW9PSlFZS0tRSU9KUW9LS1FvT0tRSU9MUW9LS1FZT0xRWUtKUUlPS1FvS0tRWUtLUW9LSlFZT0tRWUtMUUlPS1FvS0xRWU9LUVlLTFFJT0pRb0dLUVlLSlFZR0pRb0dLUVlLTFFvR0xRWUdLUW9HSlFZS0tRWUdKUUlLS1FvR0pRWUtMUUlLS1FZR0xRWUtLUVlHS1FZR0tRWUtKUVlPS1FvS0pRWU9LUVlLTFFZT0xRWU9LUVlLTFFZT0tRb0tLUVlLS1FZT0tRWU9KUVlLS1FZS0xRWUtLUUlLS1FvS0tRWUtLUVlLS1FvS0pRSUtLUVlLTFFZS0tRWUtLUUlLS1FZS0tRWUtLUVlLS1FJS0tRWUtKUVlHTFFZR0tRWUtLUVlLS1FZR0tRSUtLUVlHS1FZT0pRb0tLUVlPTFFZS0tRWU9LUW9LS1FZS0tRb0tLUVlLS1FZS0pRWUtMUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtKUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtMUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLbUlEcEVBQUFBMFhSU1RsTUFBUUlEQkFVR0J3Z0pDZ3NNRFE0UEVCRVNFeFFWRmhjWUdSb2JIQjBlSHlBaUl5UWxKeWNvS2lzc0xTNHdNVFExTmpjNE9UbzdQRHcrUDBCQ1EwUklTVXBMVEUxT1VGTlVWVmRZV0ZsYVcxNWZZR0ZpWTJabmFHbHFhMnh0YjNCeGNuTjBkbmg1ZW50OGZYNS9nSUdDaElXSWlveU5qbytRa1pPVWxaYVltWnFibkoyZW9LR2lvNldtcUttc3JhNnZzTEd6dHJlNHVicTd2TDIrd01IRHhNakp5c3ZOenMvUTBkTFUxdGZZMmR2YzN0L2c0ZUxqNWVibjZPbnE2K3p0N3Uvdzh2UDA5ZmIzK1BuNisvejkvdmtWUVhBQUFBTWFTVVJCVkhoZTVkWHhWMU4xR01meHoyQUJiRGdJQW01VkRKT3lWRElKTFVNYVZwQldVWlVhR2JtcW9HcFpSU2lHaVJXcDZLb1o1QUIwWlk1MFJJbVpRSWxhaEtrTVlYdi9SOTBkQnZFVC9ySmZPcjNPdWM4djk5elBlYzU5enZmNTZqK3ZZS2xWaVNmNzI1MFg0TXIzTzI5VGdxMDhCZEdCNERoY2VrRUo1WWtRS0ZzZ1daZHRqOUpwVitJOHhQakxGcWtyc0VJcU84UEhTcGlzMzZqV2F6Y3FqRXNmSmprdlJzc1ZVMzdTZElPdTRYQ2Y1dkVKUHNud0pwblJOVTlKbXhoTWs4bDFnZWhJcnE3aFRGanpPRCtWZjg4NjI5cUtNSlZObHRJbkZlUmV4UlF5SmxOZXFkMWlHRGxTenJJVUl5WGJ5RmZtM1JZcHJjUVJlN2xxdFd5R1liZmM2ZFQwUjJ2bWRPT2tYM3U1NUMxclAzN2Z0aUgrdERieTRyL1JCVDB3OFR5RWtyK2VwQjlYZ1BEbVNZWVdicmhDdUZZYUl5dzNmRFFBWFRuU2toK0FOb2ZpSG1XZjlsK0ZZMUk5MEZkUVRldHN0TzAwbzIzbm92elZzSjd1QjMvQzVUa2JqUndaNUplcndWNGlSV3E5SEZiRk1hSy9kMFRZcWF5UmlRUHVJeHhTM0J1OEpXVTkwLzYwdEtpN3ZraGF6bmV6MGEvVGJWT0tqNUNhT1poNmZXRzYvTHl2OUIvWkxSMWd3L1MvZnBiZVZEM01DVzFsaTZTdldET242NXRyOTkvdXZXdEJTMFhEbTRzMXQrc09IcEcwa3BCS3gvbDc3d09TbnhMcGN4NlRYbVhMVFBRT0tZT2Y5UTFkZnI4L1NKMm1GZEN2bDFZbDkzRGlIVVp2WGVMSmJHU3pZdTVnVkoyc2xiU2FrT1I4ZHhDcTVhZFEyb0ZMcXNFOUV4M0w0cVFPMGVPUGVVNXg1NmJ5cFhwNG9uU0ViNU9rSUNYNmxEYXQ1NVRlb3p0TktRY0phYWtyejlLQ2I5NW9ENjlJS3EreUtXNFhQamtuYVM1MlYwVFpxRTJjVHRYamNIU0NSbVVPODhlKzg1aGozRVA3NGk5cDhweWx3N2x4Z01EeXlsNk9WN1plam5qTk1mYXR1ODdMeFJiSDBJUzM1Z3QyYTRaam1HcFZCZEtLM1dyNklOazhqV1dTR3FiQTU1Q0tnakJSQzZFOXc3OHlkVGczQUJTM0FGVjFRTjBZNEFhMnBnRWpXblFVUmo5TDBheUs2UjJ5c0VxeEhVS3pZbkx2dnlVK2k5S00ySkhKekU0dnlaT3lEY093T3N5U2FqZUxQYzhzTnZQSmtGbHlKZDIwd3BxQXpaZUFmWjNvV3lieGQrUC8zaitTRzN1U0JkZjJWUUFBQUFCSlJVNUVya0pnZ2c9PVxcXCIpIG5vLXJlcGVhdDtcXG4gIGJhY2tncm91bmQ6IHVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQRDk0Yld3Z2RtVnljMmx2YmowaU1TNHdJaUJsYm1OdlpHbHVaejBpVlZSR0xUZ2lJSE4wWVc1a1lXeHZibVU5SW01dklqOCtDandoTFMwZ1EzSmxZWFJsWkNCM2FYUm9JRWx1YTNOallYQmxJQ2hvZEhSd09pOHZkM2QzTG1sdWEzTmpZWEJsTG05eVp5OHBJQzB0UGdvS1BITjJad29nSUNCNGJXeHVjenBrWXowaWFIUjBjRG92TDNCMWNtd3ViM0puTDJSakwyVnNaVzFsYm5Sekx6RXVNUzhpQ2lBZ0lIaHRiRzV6T21OalBTSm9kSFJ3T2k4dlkzSmxZWFJwZG1WamIyMXRiMjV6TG05eVp5OXVjeU1pQ2lBZ0lIaHRiRzV6T25Ka1pqMGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNVGs1T1M4d01pOHlNaTF5WkdZdGMzbHVkR0Y0TFc1ekl5SUtJQ0FnZUcxc2JuTTZjM1puUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJS0lDQWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklnb2dJQ0I0Yld4dWN6cHBibXR6WTJGd1pUMGlhSFIwY0RvdkwzZDNkeTVwYm10elkyRndaUzV2Y21jdmJtRnRaWE53WVdObGN5OXBibXR6WTJGd1pTSUtJQ0FnZG1WeWMybHZiajBpTVM0eElnb2dJQ0IzYVdSMGFEMGlOamd4TGprMk1qVXlJZ29nSUNCb1pXbG5hSFE5SWpFNE55NDFJZ29nSUNCcFpEMGljM1puTWlJS0lDQWdlRzFzT25Od1lXTmxQU0p3Y21WelpYSjJaU0krUEcxbGRHRmtZWFJoQ2lBZ0lDQWdhV1E5SW0xbGRHRmtZWFJoT0NJK1BISmtaanBTUkVZK1BHTmpPbGR2Y21zS0lDQWdJQ0FnSUNBZ2NtUm1PbUZpYjNWMFBTSWlQanhrWXpwbWIzSnRZWFErYVcxaFoyVXZjM1puSzNodGJEd3ZaR002Wm05eWJXRjBQanhrWXpwMGVYQmxDaUFnSUNBZ0lDQWdJQ0FnY21SbU9uSmxjMjkxY21ObFBTSm9kSFJ3T2k4dmNIVnliQzV2Y21jdlpHTXZaR050YVhSNWNHVXZVM1JwYkd4SmJXRm5aU0lnTHo0OEwyTmpPbGR2Y21zK1BDOXlaR1k2VWtSR1Bqd3ZiV1YwWVdSaGRHRStQR1JsWm5NS0lDQWdJQ0JwWkQwaVpHVm1jellpUGp4amJHbHdVR0YwYUFvZ0lDQWdJQ0FnYVdROUltTnNhWEJRWVhSb01UZ2lQanh3WVhSb0NpQWdJQ0FnSUNBZ0lHUTlJazBnTUN3eE5UQXdJREFzTUNCc0lEVTBOVFV1TnpRc01DQXdMREUxTURBZ1RDQXdMREUxTURBZ2VpSUtJQ0FnSUNBZ0lDQWdhVzVyYzJOaGNHVTZZMjl1Ym1WamRHOXlMV04xY25aaGRIVnlaVDBpTUNJS0lDQWdJQ0FnSUNBZ2FXUTlJbkJoZEdneU1DSWdMejQ4TDJOc2FYQlFZWFJvUGp3dlpHVm1jejQ4WndvZ0lDQWdJSFJ5WVc1elptOXliVDBpYldGMGNtbDRLREV1TWpVc01Dd3dMQzB4TGpJMUxEQXNNVGczTGpVcElnb2dJQ0FnSUdsa1BTSm5NVEFpUGp4bkNpQWdJQ0FnSUNCMGNtRnVjMlp2Y20wOUluTmpZV3hsS0RBdU1Td3dMakVwSWdvZ0lDQWdJQ0FnYVdROUltY3hNaUkrUEdjS0lDQWdJQ0FnSUNBZ2FXUTlJbWN4TkNJK1BHY0tJQ0FnSUNBZ0lDQWdJQ0JqYkdsd0xYQmhkR2c5SW5WeWJDZ2pZMnhwY0ZCaGRHZ3hPQ2tpQ2lBZ0lDQWdJQ0FnSUNBZ2FXUTlJbWN4TmlJK1BIQmhkR2dLSUNBZ0lDQWdJQ0FnSUNBZ0lHUTlJbTBnTVRVME5DdzFPVGt1TkRNMElHTWdNQzQ1TWl3dE5EQXVNelV5SURJMUxqWTRMQzA0TVM0Mk1ESWdOekV1TlRNc0xUZ3hMall3TWlBeU55NDFNU3d3SURRM0xqWTRMREV5TGpnek1pQTJNUzQwTkN3ek5TNDNOVFFnTVRJdU9ETXNNakl1T1RNZ01USXVPRE1zTlRZdU9EVXlJREV5TGpnekxEZ3lMalV5TnlCc0lEQXNNekk1TGpFNE5DQXROekV1TlRJc01DQXdMREV3TkM0MU5ETWdNalkyTGpnekxEQWdNQ3d0TVRBMExqVTBNeUF0TnpBdU5pd3dJREFzTFRNME5DNDNOeUJqSURBc0xUVTRMalk1TVNBdE15NDJPQ3d0TVRBMExqVXpNU0F0TkRRdU9UTXNMVEUxTWk0eU1UZ2dMVE0yTGpZNExDMDBNaTR4T0NBdE9UWXVNamdzTFRZMkxqQXlJQzB4TlRNdU1UUXNMVFkyTGpBeUlDMHhNVGN1TXpjc01DQXRNakEzTGpJMExEYzNMamswTVNBdE1qQXlMalkwTERFNU55NHhORFVnYkNBeE16QXVNaXd3SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdhVzVyYzJOaGNHVTZZMjl1Ym1WamRHOXlMV04xY25aaGRIVnlaVDBpTUNJS0lDQWdJQ0FnSUNBZ0lDQWdJR2xrUFNKd1lYUm9NaklpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnpkSGxzWlQwaVptbHNiRG9qT0dFME1UZ3lPMlpwYkd3dGIzQmhZMmwwZVRveE8yWnBiR3d0Y25Wc1pUcHViMjU2WlhKdk8zTjBjbTlyWlRwdWIyNWxJaUF2UGp4d1lYUm9DaUFnSUNBZ0lDQWdJQ0FnSUNCa1BTSnRJREl6TURFdU5DdzJOakl1TmprMUlHTWdNQ3c0TUM0M01ETWdMVFkyTGprMExERTBOUzQ0TVRNZ0xURTBOeTQyTXl3eE5EVXVPREV6SUMwNE15NDBOQ3d3SUMweE5EY3VOak1zTFRZNExqYzRNU0F0TVRRM0xqWXpMQzB4TlRFdU16QXhJREFzTFRjNUxqYzROU0EyTmk0NU5Dd3RNVFExTGpnd01TQXhORFV1T0N3dE1UUTFMamd3TVNBNE5DNHpOU3d3SURFME9TNDBOaXcyTnk0NE5USWdNVFE1TGpRMkxERTFNUzR5T0RrZ2VpQnRJQzB4TGpnekxDMHhPREV1TlRRM0lHTWdMVE0xTGpjM0xDMDFOQzR3T1RjZ0xUa3pMalV6TEMwM09DNDROVGtnTFRFMU55NDNNaXd0TnpndU9EVTVJQzB4TkRBdU15d3dJQzB5TlRFdU1qUXNNVEUyTGpRME9TQXRNalV4TGpJMExESTFOQzQ1TVRnZ01Dd3hOREl1TVRJNUlERXhNeTQzTERJMk1DNDBNU0F5TlRZdU56UXNNall3TGpReElEWXpMakkzTERBZ01URTRMakk1TEMweU9TNHpNellnTVRVeUxqSXlMQzA0TWk0MU1qTWdiQ0F3TERZNUxqWTROeUF4TnpVdU1UUXNNQ0F3TEMweE1EUXVOVEkzSUMwMk1TNDBOQ3d3SURBc0xUSTRNQzQxT1RnZ05qRXVORFFzTUNBd0xDMHhNRFF1TlRJM0lDMHhOelV1TVRRc01DQXdMRFkyTGpBeE9TSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsdWEzTmpZWEJsT21OdmJtNWxZM1J2Y2kxamRYSjJZWFIxY21VOUlqQWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcFpEMGljR0YwYURJMElnb2dJQ0FnSUNBZ0lDQWdJQ0FnYzNSNWJHVTlJbVpwYkd3Nkl6aGhOREU0TWp0bWFXeHNMVzl3WVdOcGRIazZNVHRtYVd4c0xYSjFiR1U2Ym05dWVtVnlienR6ZEhKdmEyVTZibTl1WlNJZ0x6NDhjR0YwYUFvZ0lDQWdJQ0FnSUNBZ0lDQWdaRDBpYlNBeU5qSXlMak16TERVMU55NHlOVGdnWXlBekxqWTNMQzAwTkM0d01UWWdNek11TURFc0xUY3pMak0wT0NBM09DNDROaXd0TnpNdU16UTRJRE16TGprekxEQWdOall1T1RNc01qTXVPREkwSURZMkxqa3pMRFl3TGpVd05DQXdMRFE0TGpZd05pQXRORFV1T0RRc05UWXVPRFUySUMwNE15NDBOQ3cyTmk0NU5ERWdMVGcxTGpJNExESXlMakF3TkNBdE1UYzRMamd4TERRNExqWXdOaUF0TVRjNExqZ3hMREUxTlM0NE56a2dNQ3c1TXk0MU16WWdOemd1T0RZc01UUTNMall6TXlBeE5qVXVPVGdzTVRRM0xqWXpNeUEwTkN3d0lEZ3pMalF6TEMwNUxqRTNOaUF4TVRBdU9UUXNMVFEwTGpBd09DQnNJREFzTXpNdU9USXlJRGd5TGpVekxEQWdNQ3d0TVRNeUxqazJOU0F0TVRBNExqSXhMREFnWXlBdE1TNDRNeXd6TkM0NE5UWWdMVEk0TGpReUxEVTNMamMzTkNBdE5qTXVNallzTlRjdU56YzBJQzB6TUM0eU5pd3dJQzAyTWk0ek5Td3RNVGN1TkRJeUlDMDJNaTR6TlN3dE5URXVNelE0SURBc0xUUTFMamcwTnlBME5DNDVNeXd0TlRVdU9UTWdPREF1Tmprc0xUWTBMakU0SURnNExqQXlMQzB5TUM0eE56VWdNVGd5TGpRM0xDMDBOeTQyT1RVZ01UZ3lMalEzTEMweE5UY3VOek0wSURBc0xUazVMakF5TnlBdE9ETXVORFFzTFRFMU5DNHdNemtnTFRFM05TNHhNeXd0TVRVMExqQXpPU0F0TkRrdU5UTXNNQ0F0T1RRdU5EWXNNVFV1TlRneUlDMHhNall1TlRVc05UTXVNVGdnYkNBd0xDMDBNQzR6TkNBdE9EVXVNamNzTUNBd0xERTBNaTR4TWprZ01URTBMall5TERBaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwYm10elkyRndaVHBqYjI1dVpXTjBiM0l0WTNWeWRtRjBkWEpsUFNJd0lnb2dJQ0FnSUNBZ0lDQWdJQ0FnYVdROUluQmhkR2d5TmlJS0lDQWdJQ0FnSUNBZ0lDQWdJSE4wZVd4bFBTSm1hV3hzT2lNNFlUUXhPREk3Wm1sc2JDMXZjR0ZqYVhSNU9qRTdabWxzYkMxeWRXeGxPbTV2Ym5wbGNtODdjM1J5YjJ0bE9tNXZibVVpSUM4K1BIQmhkR2dLSUNBZ0lDQWdJQ0FnSUNBZ0lHUTlJbTBnTWprNE9DNHhPQ3c0TURBdU1qVTBJQzAyTXk0eU5pd3dJREFzTVRBMExqVXlOeUF4TmpVdU1EVXNNQ0F3TEMwM015NHpOVFVnWXlBek1TNHhPQ3cxTVM0ek5EY2dOemd1T0RZc09EVXVNamMzSURFME1TNHlNU3c0TlM0eU56Y2dOamN1T0RVc01DQXhNalF1TnpFc0xUUXhMakkxT0NBeE5USXVNakVzTFRFd01pNDJPVGtnTWpZdU5pdzJNaTR6TlRFZ09USXVOaklzTVRBeUxqWTVPU0F4TmpBdU5EY3NNVEF5TGpZNU9TQTFNeTR4T1N3d0lERXdOUzQwTml3dE1qSWdNVFF4TGpJeExDMDJNaTR6TlRFZ016Z3VOVElzTFRRMExqa3pPQ0F6T0M0MU1pd3RPVE11TlRNeUlETTRMalV5TEMweE5Ea3VORFUzSUd3Z01Dd3RNVGcxTGpJek9TQTJNeTR5Tnl3d0lEQXNMVEV3TkM0MU1qY2dMVEl6T0M0ME1pd3dJREFzTVRBMExqVXlOeUEyTXk0eU9Dd3dJREFzTVRVM0xqY3hOU0JqSURBc016SXVNVEF5SURBc05qQXVOVEkzSUMweE5DNDJOeXc0T0M0NU5UY2dMVEU0TGpNMExESTJMalU0TWlBdE5EZ3VOakVzTkRBdU16UTBJQzAzT1M0M055dzBNQzR6TkRRZ0xUTXdMakkyTERBZ0xUWXpMakk0TEMweE1pNDRORFFnTFRneUxqVXpMQzB6Tmk0Mk56SWdMVEl5TGprekxDMHlPUzR6TlRVZ0xUSXlMamt6TEMwMU5pNDROak1nTFRJeUxqa3pMQzA1TWk0Mk1qa2diQ0F3TEMweE5UY3VOekUxSURZekxqSTNMREFnTUN3dE1UQTBMalV5TnlBdE1qTTRMalF4TERBZ01Dd3hNRFF1TlRJM0lEWXpMakk0TERBZ01Dd3hOVEF1TXpneklHTWdNQ3d5T1M0ek5EZ2dNQ3cyTmk0d01qTWdMVEUwTGpZM0xEa3hMalk1T1NBdE1UVXVOVGtzTWprdU16TTJJQzAwTnk0Mk9TdzBOQzQ1TXpRZ0xUZ3dMamNzTkRRdU9UTTBJQzB6TVM0eE9Dd3dJQzAxTnk0M055d3RNVEV1TURBNElDMDNOeTQ1TkN3dE16VXVOemMwSUMweU5DNDNOeXd0TXpBdU1qVXpJQzB5Tmk0MkxDMDJNaTR6TkRNZ0xUSTJMallzTFRrNUxqazBNU0JzSURBc0xURTFNUzR6TURFZ05qTXVNamNzTUNBd0xDMHhNRFF1TlRJM0lDMHlNemd1TkN3d0lEQXNNVEEwTGpVeU55QTJNeTR5Tml3d0lEQXNNamd3TGpVNU9DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsdWEzTmpZWEJsT21OdmJtNWxZM1J2Y2kxamRYSjJZWFIxY21VOUlqQWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcFpEMGljR0YwYURJNElnb2dJQ0FnSUNBZ0lDQWdJQ0FnYzNSNWJHVTlJbVpwYkd3Nkl6aGhOREU0TWp0bWFXeHNMVzl3WVdOcGRIazZNVHRtYVd4c0xYSjFiR1U2Ym05dWVtVnlienR6ZEhKdmEyVTZibTl1WlNJZ0x6NDhjR0YwYUFvZ0lDQWdJQ0FnSUNBZ0lDQWdaRDBpYlNBek9UazRMalkyTERrMU1TNDFORGNnTFRFeE1TNDROeXd3SURBc01URTRMakk1TXlBeE1URXVPRGNzTUNBd0xDMHhNVGd1TWpreklIb2diU0F3TEMwME16RXVPRGt4SURZekxqSTNMREFnTUN3dE1UQTBMalV5TnlBdE1qTTVMak16TERBZ01Dd3hNRFF1TlRJM0lEWTBMakU1TERBZ01Dd3lPREF1TlRrNElDMDJNeTR5Tnl3d0lEQXNNVEEwTGpVeU55QXhOelV1TVRRc01DQXdMQzB6T0RVdU1USTFJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXNXJjMk5oY0dVNlkyOXVibVZqZEc5eUxXTjFjblpoZEhWeVpUMGlNQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbGtQU0p3WVhSb016QWlDaUFnSUNBZ0lDQWdJQ0FnSUNCemRIbHNaVDBpWm1sc2JEb2pPR0UwTVRneU8yWnBiR3d0YjNCaFkybDBlVG94TzJacGJHd3RjblZzWlRwdWIyNTZaWEp2TzNOMGNtOXJaVHB1YjI1bElpQXZQanh3WVhSb0NpQWdJQ0FnSUNBZ0lDQWdJQ0JrUFNKdElEUXhOVGt1TVRJc09EQXdMakkxTkNBdE5qTXVNamNzTUNBd0xERXdOQzQxTWpjZ01UYzFMakUwTERBZ01Dd3ROamt1TmpnM0lHTWdNamt1TXpVc05UUXVNVEF4SURnMExqTTJMRGd3TGpZNU9TQXhORFF1T0Rjc09EQXVOams1SURVekxqRTVMREFnTVRBMUxqUTFMQzB5TWk0d01UWWdNVFF4TGpJeUxDMDJNQzQxTWpjZ05EQXVNelFzTFRRMExqa3pOQ0EwTVM0eU5pd3RPRGd1TURNeUlEUXhMakkyTEMweE5ETXVPVFUzSUd3Z01Dd3RNVGt4TGpZMU15QTJNeTR5Tnl3d0lEQXNMVEV3TkM0MU1qY2dMVEl6T0M0MExEQWdNQ3d4TURRdU5USTNJRFl6TGpJMkxEQWdNQ3d4TlRndU5qTTNJR01nTUN3ek1DNHlOaklnTUN3Mk1TNDBNelFnTFRFNUxqSTJMRGc0TGpBek5TQXRNakF1TVRjc01qWXVOVGd5SUMwMU15NHhPQ3d6T1M0ME1UUWdMVGcyTGpFNUxETTVMalF4TkNBdE16TXVPVE1zTUNBdE5qZ3VOemNzTFRFekxqYzFJQzA0T0M0NU5Dd3ROREV1TWpVZ0xUSXhMakE1TEMweU55NDFJQzB5TVM0d09Td3ROamt1TmpnM0lDMHlNUzR3T1N3dE1UQXlMamN3TnlCc0lEQXNMVEUwTWk0eE1qa2dOak11TWpZc01DQXdMQzB4TURRdU5USTNJQzB5TXpndU5Dd3dJREFzTVRBMExqVXlOeUEyTXk0eU55d3dJREFzTWpnd0xqVTVPQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbHVhM05qWVhCbE9tTnZibTVsWTNSdmNpMWpkWEoyWVhSMWNtVTlJakFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBaRDBpY0dGMGFETXlJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2MzUjViR1U5SW1acGJHdzZJemhoTkRFNE1qdG1hV3hzTFc5d1lXTnBkSGs2TVR0bWFXeHNMWEoxYkdVNmJtOXVlbVZ5Ynp0emRISnZhMlU2Ym05dVpTSWdMejQ4Y0dGMGFBb2dJQ0FnSUNBZ0lDQWdJQ0FnWkQwaWJTQTFNRGd5TGpRNExEY3dNeTQ1TmpVZ1l5QXRNVGt1TWpRc056QXVOakExSUMwNE1TNDJMREV4TlM0MU5EY2dMVEUxTkM0d05Dd3hNVFV1TlRRM0lDMDJOaTR3TkN3d0lDMHhNamt1TXl3dE5URXVNelE0SUMweE5ETXVNRFVzTFRFeE5TNDFORGNnYkNBeU9UY3VNRGtzTUNCNklHMGdPRFV1TWpjc0xURTBOQzQ0T0RNZ1l5QXRNemd1TlRFc0xUa3pMalV5TXlBdE1USTVMakkzTEMweE5UWXVOemt6SUMweU16RXVNRFVzTFRFMU5pNDNPVE1nTFRFME15NHdOeXd3SUMweU5UY3VOamdzTVRFeExqZzNNU0F0TWpVM0xqWTRMREkxTlM0NE16WWdNQ3d4TkRRdU9EZ3pJREV3T1M0eE1pd3lOakV1TXpJNElESTFOQzQ1TVN3eU5qRXVNekk0SURZM0xqZzNMREFnTVRNMUxqY3lMQzB6TUM0eU5UZ2dNVGd6TGpNNUxDMDNPQzQ0TmpNZ05EZ3VOaklzTFRVeExqTTBOQ0EyT0M0M09Td3RNVEV6TGpZNU5TQTJPQzQzT1N3dE1UZ3pMak00TXlCc0lDMHpMalkzTEMwek9TNDBNelFnTFRNNU5pNHhNeXd3SUdNZ01UUXVOamNzTFRZM0xqZzJNeUEzTnk0d015d3RNVEUzTGpNMk15QXhORFl1TnpJc0xURXhOeTR6TmpNZ05EZ3VOVGtzTUNBNU1DNDNOaXd4T0M0ek1qZ2dNVEU0TGpJNExEVTRMalkzTWlCc0lERXhOaTQwTkN3d0lnb2dJQ0FnSUNBZ0lDQWdJQ0FnYVc1cmMyTmhjR1U2WTI5dWJtVmpkRzl5TFdOMWNuWmhkSFZ5WlQwaU1DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsa1BTSndZWFJvTXpRaUNpQWdJQ0FnSUNBZ0lDQWdJQ0J6ZEhsc1pUMGlabWxzYkRvak9HRTBNVGd5TzJacGJHd3RiM0JoWTJsMGVUb3hPMlpwYkd3dGNuVnNaVHB1YjI1NlpYSnZPM04wY205clpUcHViMjVsSWlBdlBqeHdZWFJvQ2lBZ0lDQWdJQ0FnSUNBZ0lDQmtQU0p0SURZNU1DNDRPVFVzT0RVd0xqY3dNeUE1TUM0M05Td3dJREl5TGpVME15d3pNUzR3TXpVZ01Dd3lORE11TVRJeUlDMHhNelV1T0RJNUxEQWdNQ3d0TWpRekxqRTBNU0F5TWk0MU16WXNMVE14TGpBeE5pSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsdWEzTmpZWEJsT21OdmJtNWxZM1J2Y2kxamRYSjJZWFIxY21VOUlqQWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcFpEMGljR0YwYURNMklnb2dJQ0FnSUNBZ0lDQWdJQ0FnYzNSNWJHVTlJbVpwYkd3Nkl6aGhOREU0TWp0bWFXeHNMVzl3WVdOcGRIazZNVHRtYVd4c0xYSjFiR1U2Ym05dWVtVnlienR6ZEhKdmEyVTZibTl1WlNJZ0x6NDhjR0YwYUFvZ0lDQWdJQ0FnSUNBZ0lDQWdaRDBpYlNBMk16SXVNemsxTERjME1pNHlOVGdnTWpndU1ETTVMRGcyTGpNd05DQXRNakl1TlRVeExETXhMakEwSUMweU16RXVNakl6TERjMUxqRXlPQ0F0TkRFdU9UYzJMQzB4TWprdU1UZ3pJREl6TVM0eU5UY3NMVGMxTGpFek55QXpOaTQwTlRRc01URXVPRFE0SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdhVzVyYzJOaGNHVTZZMjl1Ym1WamRHOXlMV04xY25aaGRIVnlaVDBpTUNJS0lDQWdJQ0FnSUNBZ0lDQWdJR2xrUFNKd1lYUm9NemdpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnpkSGxzWlQwaVptbHNiRG9qT0dFME1UZ3lPMlpwYkd3dGIzQmhZMmwwZVRveE8yWnBiR3d0Y25Wc1pUcHViMjU2WlhKdk8zTjBjbTlyWlRwdWIyNWxJaUF2UGp4d1lYUm9DaUFnSUNBZ0lDQWdJQ0FnSUNCa1BTSnRJRGN4Tnk0ME5Ea3NOalV6TGpFd05TQXROek11TkRFc05UTXVNellnTFRNMkxqUTRPQ3d0TVRFdU9EYzFJQzB4TkRJdU9UQXpMQzB4T1RZdU5qa3lJREV3T1M0NE9ETXNMVGM1TGpneU9DQXhOREl1T1RFNExERTVOaTQzTURNZ01Dd3pPQzR6TXpJaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwYm10elkyRndaVHBqYjI1dVpXTjBiM0l0WTNWeWRtRjBkWEpsUFNJd0lnb2dJQ0FnSUNBZ0lDQWdJQ0FnYVdROUluQmhkR2cwTUNJS0lDQWdJQ0FnSUNBZ0lDQWdJSE4wZVd4bFBTSm1hV3hzT2lNNFlUUXhPREk3Wm1sc2JDMXZjR0ZqYVhSNU9qRTdabWxzYkMxeWRXeGxPbTV2Ym5wbGNtODdjM1J5YjJ0bE9tNXZibVVpSUM4K1BIQmhkR2dLSUNBZ0lDQWdJQ0FnSUNBZ0lHUTlJbTBnT0RJNExqVXlMRGN3Tmk0ME5qVWdMVGN6TGpReU5pd3ROVE11TXpRZ01DNHdNVEVzTFRNNExqTTFPU0JNSURnNU9DNHdNRFFzTkRFNExqQTNJREV3TURjdU9TdzBPVGN1T0RrNElEZzJOQzQ1TnpNc05qazBMall3T1NBNE1qZ3VOVElzTnpBMkxqUTJOU0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbHVhM05qWVhCbE9tTnZibTVsWTNSdmNpMWpkWEoyWVhSMWNtVTlJakFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBaRDBpY0dGMGFEUXlJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2MzUjViR1U5SW1acGJHdzZJemhoTkRFNE1qdG1hV3hzTFc5d1lXTnBkSGs2TVR0bWFXeHNMWEoxYkdVNmJtOXVlbVZ5Ynp0emRISnZhMlU2Ym05dVpTSWdMejQ4Y0dGMGFBb2dJQ0FnSUNBZ0lDQWdJQ0FnWkQwaWJTQTRNVEl1TURnMkxEZ3lPQzQxT0RZZ01qZ3VNRFUxTEMwNE5pNHpNaUF6Tmk0ME9EUXNMVEV4TGpnek5pQXlNekV1TWpJMUxEYzFMakV4TnlBdE5ERXVPVGNzTVRJNUxqRTRNeUF0TWpNeExqSXpPU3d0TnpVdU1UUWdMVEl5TGpVMU5Td3RNekV1TURBMElnb2dJQ0FnSUNBZ0lDQWdJQ0FnYVc1cmMyTmhjR1U2WTI5dWJtVmpkRzl5TFdOMWNuWmhkSFZ5WlQwaU1DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsa1BTSndZWFJvTkRRaUNpQWdJQ0FnSUNBZ0lDQWdJQ0J6ZEhsc1pUMGlabWxzYkRvak9HRTBNVGd5TzJacGJHd3RiM0JoWTJsMGVUb3hPMlpwYkd3dGNuVnNaVHB1YjI1NlpYSnZPM04wY205clpUcHViMjVsSWlBdlBqeHdZWFJvQ2lBZ0lDQWdJQ0FnSUNBZ0lDQmtQU0p0SURjek5pNHpNREVzTVRNek5TNDRPQ0JqSUMwek1qTXVNRFEzTERBZ0xUVTROUzQ0TnpVc0xUSTJNaTQzT0NBdE5UZzFMamczTlN3dE5UZzFMamM0TWlBd0xDMHpNak11TVRFNElESTJNaTQ0TWpnc0xUVTROUzQ1TnpjZ05UZzFMamczTlN3dE5UZzFMamszTnlBek1qTXVNREU1TERBZ05UZzFMamd3T1N3eU5qSXVPRFU1SURVNE5TNDRNRGtzTlRnMUxqazNOeUF3TERNeU15NHdNRElnTFRJMk1pNDNPU3cxT0RVdU56Z3lJQzAxT0RVdU9EQTVMRFU0TlM0M09ESWdiQ0F3TERBZ2VpQnRJREFzTFRFeE9DNDJNU0JqSURJMU55NDVOeklzTUNBME5qY3VNVGc1TEMweU1Ea3VNVE1nTkRZM0xqRTRPU3d0TkRZM0xqRTNNaUF3TEMweU5UZ3VNVEk1SUMweU1Ea3VNakUzTEMwME5qY3VNelE0SUMwME5qY3VNVGc1TEMwME5qY3VNelE0SUMweU5UZ3VNRGMwTERBZ0xUUTJOeTR5TlRRc01qQTVMakl4T1NBdE5EWTNMakkxTkN3ME5qY3VNelE0SURBc01qVTRMakEwTWlBeU1Ea3VNVGdzTkRZM0xqRTNNaUEwTmpjdU1qVTBMRFEyTnk0eE56SWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcGJtdHpZMkZ3WlRwamIyNXVaV04wYjNJdFkzVnlkbUYwZFhKbFBTSXdJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXUTlJbkJoZEdnME5pSUtJQ0FnSUNBZ0lDQWdJQ0FnSUhOMGVXeGxQU0ptYVd4c09pTTRZVFF4T0RJN1ptbHNiQzF2Y0dGamFYUjVPakU3Wm1sc2JDMXlkV3hsT201dmJucGxjbTg3YzNSeWIydGxPbTV2Ym1VaUlDOCtQSEJoZEdnS0lDQWdJQ0FnSUNBZ0lDQWdJR1E5SW0wZ01UQTVNUzR4TXl3Mk1Ua3VPRGd6SUMweE56VXVOemN4TERVM0xqRXlNU0F4TVM0Mk1qa3NNelV1T0RBNElERTNOUzQzTmpJc0xUVTNMakV5TVNBdE1URXVOaklzTFRNMUxqZ3dPQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbHVhM05qWVhCbE9tTnZibTVsWTNSdmNpMWpkWEoyWVhSMWNtVTlJakFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBaRDBpY0dGMGFEUTRJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2MzUjViR1U5SW1acGJHdzZJemhoTkRFNE1qdG1hV3hzTFc5d1lXTnBkSGs2TVR0bWFXeHNMWEoxYkdVNmJtOXVlbVZ5Ynp0emRISnZhMlU2Ym05dVpTSWdMejQ4Y0dGMGFBb2dJQ0FnSUNBZ0lDQWdJQ0FnWkQwaVRTQTROall1T1RVM0xEa3dNaTR3TnpRZ09ETTJMalVzT1RJMExqRTVPU0E1TkRVdU1USXhMREV3TnpNdU56TWdPVGMxTGpVNE5pd3hNRFV4TGpZeElEZzJOaTQ1TlRjc09UQXlMakEzTkNJS0lDQWdJQ0FnSUNBZ0lDQWdJR2x1YTNOallYQmxPbU52Ym01bFkzUnZjaTFqZFhKMllYUjFjbVU5SWpBaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwWkQwaWNHRjBhRFV3SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdjM1I1YkdVOUltWnBiR3c2SXpoaE5ERTRNanRtYVd4c0xXOXdZV05wZEhrNk1UdG1hV3hzTFhKMWJHVTZibTl1ZW1WeWJ6dHpkSEp2YTJVNmJtOXVaU0lnTHo0OGNHRjBhQW9nSUNBZ0lDQWdJQ0FnSUNBZ1pEMGlUU0EyTURjdU5EWTFMRGt3TXk0ME5EVWdORGs0TGpnMU5Td3hNRFV5TGprM0lEVXlPUzR6TWl3eE1EYzFMakVnTmpNM0xqa3pMRGt5TlM0MU5qWWdOakEzTGpRMk5TdzVNRE11TkRRMUlnb2dJQ0FnSUNBZ0lDQWdJQ0FnYVc1cmMyTmhjR1U2WTI5dWJtVmpkRzl5TFdOMWNuWmhkSFZ5WlQwaU1DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsa1BTSndZWFJvTlRJaUNpQWdJQ0FnSUNBZ0lDQWdJQ0J6ZEhsc1pUMGlabWxzYkRvak9HRTBNVGd5TzJacGJHd3RiM0JoWTJsMGVUb3hPMlpwYkd3dGNuVnNaVHB1YjI1NlpYSnZPM04wY205clpUcHViMjVsSWlBdlBqeHdZWFJvQ2lBZ0lDQWdJQ0FnSUNBZ0lDQmtQU0p0SURNNE1DNDJPRGdzTmpJeUxqRXlPU0F0TVRFdU5qSTJMRE0xTGpnd01TQXhOelV1TnpVNExEVTNMakE1SURFeExqWXlNU3d0TXpVdU9EQXhJQzB4TnpVdU56VXpMQzAxTnk0d09TSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsdWEzTmpZWEJsT21OdmJtNWxZM1J2Y2kxamRYSjJZWFIxY21VOUlqQWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcFpEMGljR0YwYURVMElnb2dJQ0FnSUNBZ0lDQWdJQ0FnYzNSNWJHVTlJbVpwYkd3Nkl6aGhOREU0TWp0bWFXeHNMVzl3WVdOcGRIazZNVHRtYVd4c0xYSjFiR1U2Ym05dWVtVnlienR6ZEhKdmEyVTZibTl1WlNJZ0x6NDhjR0YwYUFvZ0lDQWdJQ0FnSUNBZ0lDQWdaRDBpYlNBM01UWXVNamc1TERNM05pNDFPU0F6Tnk0Mk5EQTJMREFnTUN3eE9EUXVPREUySUMwek55NDJOREEyTERBZ01Dd3RNVGcwTGpneE5pQjZJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXNXJjMk5oY0dVNlkyOXVibVZqZEc5eUxXTjFjblpoZEhWeVpUMGlNQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbGtQU0p3WVhSb05UWWlDaUFnSUNBZ0lDQWdJQ0FnSUNCemRIbHNaVDBpWm1sc2JEb2pPR0UwTVRneU8yWnBiR3d0YjNCaFkybDBlVG94TzJacGJHd3RjblZzWlRwdWIyNTZaWEp2TzNOMGNtOXJaVHB1YjI1bElpQXZQand2Wno0OEwyYytQQzluUGp3dlp6NDhMM04yWno0PVxcXCIpIG5vLXJlcGVhdCwgbm9uZTtcXG4gIC1tb3otYmFja2dyb3VuZC1zaXplOiAxMDAlO1xcbiAgLW8tYmFja2dyb3VuZC1zaXplOiAxMDAlO1xcbiAgLXdlYmtpdC1iYWNrZ3JvdW5kLXNpemU6IDEwMCU7XFxuICBiYWNrZ3JvdW5kLXNpemU6IDEwMCU7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgd2lkdGg6IDkwcHg7XFxuICBoZWlnaHQ6IDI1cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFubmVyIC5qYXNtaW5lLXZlcnNpb24ge1xcbiAgbWFyZ2luLWxlZnQ6IDE0cHg7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB0b3A6IDZweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAjamFzbWluZV9jb250ZW50IHtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHJpZ2h0OiAxMDAlO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXZlcnNpb24ge1xcbiAgY29sb3I6ICNhYWE7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFubmVyIHtcXG4gIG1hcmdpbi10b3A6IDE0cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZHVyYXRpb24ge1xcbiAgY29sb3I6ICNmZmY7XFxuICBmbG9hdDogcmlnaHQ7XFxuICBsaW5lLWhlaWdodDogMjhweDtcXG4gIHBhZGRpbmctcmlnaHQ6IDlweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSB7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgbWFyZ2luOiAxNHB4IDA7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkgbGkge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgaGVpZ2h0OiAxMHB4O1xcbiAgd2lkdGg6IDE0cHg7XFxuICBmb250LXNpemU6IDE2cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkgbGkuamFzbWluZS1wYXNzZWQge1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpLmphc21pbmUtcGFzc2VkOmJlZm9yZSB7XFxuICBjb2xvcjogIzAwNzA2OTtcXG4gIGNvbnRlbnQ6IFxcXCLigKJcXFwiO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpLmphc21pbmUtZmFpbGVkIHtcXG4gIGxpbmUtaGVpZ2h0OiA5cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkgbGkuamFzbWluZS1mYWlsZWQ6YmVmb3JlIHtcXG4gIGNvbG9yOiAjY2EzYTExO1xcbiAgY29udGVudDogXFxcIsOXXFxcIjtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgbWFyZ2luLWxlZnQ6IC0xcHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkgbGkuamFzbWluZS1leGNsdWRlZCB7XFxuICBmb250LXNpemU6IDE0cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkgbGkuamFzbWluZS1leGNsdWRlZDpiZWZvcmUge1xcbiAgY29sb3I6ICNiYWJhYmE7XFxuICBjb250ZW50OiBcXFwi4oCiXFxcIjtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaS5qYXNtaW5lLWV4Y2x1ZGVkLW5vLWRpc3BsYXkge1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaS5qYXNtaW5lLXBlbmRpbmcge1xcbiAgbGluZS1oZWlnaHQ6IDE3cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkgbGkuamFzbWluZS1wZW5kaW5nOmJlZm9yZSB7XFxuICBjb2xvcjogI2JhOWQzNztcXG4gIGNvbnRlbnQ6IFxcXCIqXFxcIjtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaS5qYXNtaW5lLWVtcHR5IHtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaS5qYXNtaW5lLWVtcHR5OmJlZm9yZSB7XFxuICBjb2xvcjogI2JhOWQzNztcXG4gIGNvbnRlbnQ6IFxcXCLigKJcXFwiO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXJ1bi1vcHRpb25zIHtcXG4gIGZsb2F0OiByaWdodDtcXG4gIG1hcmdpbi1yaWdodDogNXB4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgIzhhNDE4MjtcXG4gIGNvbG9yOiAjOGE0MTgyO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgbGluZS1oZWlnaHQ6IDIwcHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtcnVuLW9wdGlvbnMgLmphc21pbmUtdHJpZ2dlciB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBwYWRkaW5nOiA4cHggMTZweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1ydW4tb3B0aW9ucyAuamFzbWluZS1wYXlsb2FkIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGRpc3BsYXk6IG5vbmU7XFxuICByaWdodDogLTFweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICM4YTQxODI7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlO1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gIHBhZGRpbmc6IDRweCA4cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtcnVuLW9wdGlvbnMgLmphc21pbmUtcGF5bG9hZC5qYXNtaW5lLW9wZW4ge1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFyIHtcXG4gIGxpbmUtaGVpZ2h0OiAyOHB4O1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBjb2xvcjogI2VlZTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYXIuamFzbWluZS1mYWlsZWQsIC5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFyLmphc21pbmUtZXJyb3JlZCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjY2EzYTExO1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNlZWU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFyLmphc21pbmUtcGFzc2VkIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMwMDcwNjk7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFyLmphc21pbmUtaW5jb21wbGV0ZSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjYmFiYWJhO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhci5qYXNtaW5lLXNraXBwZWQge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2JhYmFiYTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYXIuamFzbWluZS13YXJuaW5nIHtcXG4gIG1hcmdpbi10b3A6IDE0cHg7XFxuICBtYXJnaW4tYm90dG9tOiAxNHB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2JhOWQzNztcXG4gIGNvbG9yOiAjMzMzO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhci5qYXNtaW5lLW1lbnUge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIGNvbG9yOiAjYWFhO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhci5qYXNtaW5lLW1lbnUgYSB7XFxuICBjb2xvcjogIzMzMztcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYXIgYSB7XFxuICBjb2xvcjogd2hpdGU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIuamFzbWluZS1zcGVjLWxpc3QgLmphc21pbmUtYmFyLmphc21pbmUtbWVudS5qYXNtaW5lLWZhaWx1cmUtbGlzdCxcXG4uamFzbWluZV9odG1sLXJlcG9ydGVyLmphc21pbmUtc3BlYy1saXN0IC5qYXNtaW5lLXJlc3VsdHMgLmphc21pbmUtZmFpbHVyZXMge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlci5qYXNtaW5lLWZhaWx1cmUtbGlzdCAuamFzbWluZS1iYXIuamFzbWluZS1tZW51Lmphc21pbmUtc3BlYy1saXN0LFxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIuamFzbWluZS1mYWlsdXJlLWxpc3QgLmphc21pbmUtc3VtbWFyeSB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXJlc3VsdHMge1xcbiAgbWFyZ2luLXRvcDogMTRweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdW1tYXJ5IHtcXG4gIG1hcmdpbi10b3A6IDE0cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3VtbWFyeSB1bCB7XFxuICBsaXN0LXN0eWxlLXR5cGU6IG5vbmU7XFxuICBtYXJnaW4tbGVmdDogMTRweDtcXG4gIHBhZGRpbmctdG9wOiAwO1xcbiAgcGFkZGluZy1sZWZ0OiAwO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1bW1hcnkgdWwuamFzbWluZS1zdWl0ZSB7XFxuICBtYXJnaW4tdG9wOiA3cHg7XFxuICBtYXJnaW4tYm90dG9tOiA3cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3VtbWFyeSBsaS5qYXNtaW5lLXBhc3NlZCBhIHtcXG4gIGNvbG9yOiAjMDA3MDY5O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1bW1hcnkgbGkuamFzbWluZS1mYWlsZWQgYSB7XFxuICBjb2xvcjogI2NhM2ExMTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdW1tYXJ5IGxpLmphc21pbmUtZW1wdHkgYSB7XFxuICBjb2xvcjogI2JhOWQzNztcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdW1tYXJ5IGxpLmphc21pbmUtcGVuZGluZyBhIHtcXG4gIGNvbG9yOiAjYmE5ZDM3O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1bW1hcnkgbGkuamFzbWluZS1leGNsdWRlZCBhIHtcXG4gIGNvbG9yOiAjYmFiYWJhO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXNwZWNzIGxpLmphc21pbmUtcGFzc2VkIGE6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCLigKIgXFxcIjtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zcGVjcyBsaS5qYXNtaW5lLWZhaWxlZCBhOmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwiw5cgXFxcIjtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zcGVjcyBsaS5qYXNtaW5lLWVtcHR5IGE6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCIqIFxcXCI7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3BlY3MgbGkuamFzbWluZS1wZW5kaW5nIGE6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCLigKIgXFxcIjtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zcGVjcyBsaS5qYXNtaW5lLWV4Y2x1ZGVkIGE6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCLigKIgXFxcIjtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1kZXNjcmlwdGlvbiArIC5qYXNtaW5lLXN1aXRlIHtcXG4gIG1hcmdpbi10b3A6IDA7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3VpdGUge1xcbiAgbWFyZ2luLXRvcDogMTRweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdWl0ZSBhIHtcXG4gIGNvbG9yOiAjMzMzO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWZhaWx1cmVzIC5qYXNtaW5lLXNwZWMtZGV0YWlsIHtcXG4gIG1hcmdpbi1ib3R0b206IDI4cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZmFpbHVyZXMgLmphc21pbmUtc3BlYy1kZXRhaWwgLmphc21pbmUtZGVzY3JpcHRpb24ge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2NhM2ExMTtcXG4gIGNvbG9yOiB3aGl0ZTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1mYWlsdXJlcyAuamFzbWluZS1zcGVjLWRldGFpbCAuamFzbWluZS1kZXNjcmlwdGlvbiBhIHtcXG4gIGNvbG9yOiB3aGl0ZTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1yZXN1bHQtbWVzc2FnZSB7XFxuICBwYWRkaW5nLXRvcDogMTRweDtcXG4gIGNvbG9yOiAjMzMzO1xcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXJlc3VsdC1tZXNzYWdlIHNwYW4uamFzbWluZS1yZXN1bHQge1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3RhY2stdHJhY2Uge1xcbiAgbWFyZ2luOiA1cHggMCAwIDA7XFxuICBtYXgtaGVpZ2h0OiAyMjRweDtcXG4gIG92ZXJmbG93OiBhdXRvO1xcbiAgbGluZS1oZWlnaHQ6IDE4cHg7XFxuICBjb2xvcjogIzY2NjtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNkZGQ7XFxuICBiYWNrZ3JvdW5kOiB3aGl0ZTtcXG4gIHdoaXRlLXNwYWNlOiBwcmU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZXhwYW5kZXIgYSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIG1hcmdpbi1sZWZ0OiAxNHB4O1xcbiAgY29sb3I6IGJsdWU7XFxuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1leHBhbmRlci1jb250ZW50cyB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWV4cGFuZGVkIHtcXG4gIHBhZGRpbmctYm90dG9tOiAxMHB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWV4cGFuZGVkIC5qYXNtaW5lLWV4cGFuZGVyLWNvbnRlbnRzIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgbWFyZ2luLWxlZnQ6IDE0cHg7XFxuICBwYWRkaW5nOiA1cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZGVidWctbG9nIHtcXG4gIG1hcmdpbjogNXB4IDAgMCAwO1xcbiAgcGFkZGluZzogNXB4O1xcbiAgY29sb3I6ICM2NjY7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZGRkO1xcbiAgYmFja2dyb3VuZDogd2hpdGU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZGVidWctbG9nIHRhYmxlIHtcXG4gIGJvcmRlci1zcGFjaW5nOiAwO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWRlYnVnLWxvZyB0YWJsZSwgLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1kZWJ1Zy1sb2cgdGgsIC5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZGVidWctbG9nIHRkIHtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNkZGQ7XFxufVwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL25vZGVfbW9kdWxlcy9qYXNtaW5lLWNvcmUvbGliL2phc21pbmUtY29yZS9qYXNtaW5lLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSxnQkFBZ0I7QUFDaEI7RUFDRSxrQkFBa0I7QUFDcEI7O0FBRUE7RUFDRSxXQUFXO0VBQ1gsc0JBQXNCO0VBQ3RCLFlBQVk7RUFDWixZQUFZO0VBQ1osZUFBZTtFQUNmLGdEQUFnRDtFQUNoRCxpQkFBaUI7RUFDakIsV0FBVztBQUNiO0FBQ0E7RUFDRSxxQkFBcUI7QUFDdkI7QUFDQTtFQUNFLDBCQUEwQjtBQUM1QjtBQUNBO0VBQ0UsU0FBUztFQUNULGlCQUFpQjtBQUNuQjtBQUNBOzs7Ozs7OztFQVFFLGlCQUFpQjtFQUNqQixrQkFBa0I7QUFDcEI7QUFDQTtFQUNFLGtCQUFrQjtBQUNwQjtBQUNBO0VBQ0UsbXlFQUFteUU7RUFDbnlFLGlrWEFBaWtYO0VB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QjtFQUNqQixpQkFBaUI7RUFDakIsY0FBYztFQUNkLGlCQUFpQjtFQUNqQixXQUFXO0VBQ1gsc0JBQXNCO0VBQ3RCLGlCQUFpQjtFQUNqQixnQkFBZ0I7QUFDbEI7QUFDQTtFQUNFLGNBQWM7RUFDZCxpQkFBaUI7RUFDakIsV0FBVztFQUNYLDBCQUEwQjtBQUM1QjtBQUNBO0VBQ0UsYUFBYTtBQUNmO0FBQ0E7RUFDRSxvQkFBb0I7QUFDdEI7QUFDQTtFQUNFLGNBQWM7RUFDZCxpQkFBaUI7RUFDakIsWUFBWTtBQUNkO0FBQ0E7RUFDRSxpQkFBaUI7RUFDakIsWUFBWTtFQUNaLFdBQVc7RUFDWCxzQkFBc0I7RUFDdEIsaUJBQWlCO0FBQ25CO0FBQ0E7RUFDRSxpQkFBaUI7QUFDbkI7QUFDQTtFQUNFLHNCQUFzQjtBQUN4QlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJAY2hhcnNldCBcXFwiVVRGLThcXFwiO1xcbmJvZHkge1xcbiAgb3ZlcmZsb3cteTogc2Nyb2xsO1xcbn1cXG5cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VlZTtcXG4gIHBhZGRpbmc6IDVweDtcXG4gIG1hcmdpbjogLThweDtcXG4gIGZvbnQtc2l6ZTogMTFweDtcXG4gIGZvbnQtZmFtaWx5OiBNb25hY28sIFxcXCJMdWNpZGEgQ29uc29sZVxcXCIsIG1vbm9zcGFjZTtcXG4gIGxpbmUtaGVpZ2h0OiAxNHB4O1xcbiAgY29sb3I6ICMzMzM7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgYSB7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgYTpob3ZlciB7XFxuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciBwLCAuamFzbWluZV9odG1sLXJlcG9ydGVyIGgxLCAuamFzbWluZV9odG1sLXJlcG9ydGVyIGgyLCAuamFzbWluZV9odG1sLXJlcG9ydGVyIGgzLCAuamFzbWluZV9odG1sLXJlcG9ydGVyIGg0LCAuamFzbWluZV9odG1sLXJlcG9ydGVyIGg1LCAuamFzbWluZV9odG1sLXJlcG9ydGVyIGg2IHtcXG4gIG1hcmdpbjogMDtcXG4gIGxpbmUtaGVpZ2h0OiAxNHB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhbm5lcixcXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5LFxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3VtbWFyeSxcXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXJlc3VsdC1tZXNzYWdlLFxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3BlYyAuamFzbWluZS1kZXNjcmlwdGlvbixcXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXNwZWMtZGV0YWlsIC5qYXNtaW5lLWRlc2NyaXB0aW9uLFxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYWxlcnQgLmphc21pbmUtYmFyLFxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3RhY2stdHJhY2Uge1xcbiAgcGFkZGluZy1sZWZ0OiA5cHg7XFxuICBwYWRkaW5nLXJpZ2h0OiA5cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFubmVyIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYW5uZXIgLmphc21pbmUtdGl0bGUge1xcbiAgYmFja2dyb3VuZDogdXJsKFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUZvQUFBQVpDQU1BQUFDR3VzbnlBQUFDZGxCTVZFWC8vLy8vQVArQWdJQ3FWYXFBUUlDWk01bUFWWUNTU1pLQVFJQ09PWTZBVFlDTFJvdUFRSUNKTzRtU1NZQ0lSSWlQUUlDSFBJZU9SNENHUTRhTVFJQ0dQWWFMUm9DRlE0V0tRSUNQUFlXSlJZQ09Rb1NKUUlDTlBvU0lSSUNNUW9TSFFJQ0hSSUNLUW9PSFFJQ0tQb09KTzRPSlFZT01RSUNNUTRDSVFZS0xRSUNJUG9LTFE0Q0tRSUNOUG9LSlFJU01RNEtKUW9TTFFZS0pRSVNMUTRLSVFvU0tRWUtJUUlDSVFJU01Rb1NLUVlLTFFJT0xRb09KUVlHTFFJT0tRSU9NUW9HS1FZT0xRWUdLUUlPTFFvR0pRWU9KUUlPS1FZR0pRSU9LUW9HS1FJR0xRSUtMUTRLS1FvR0xRWUtKUUlHS1FZS0pRSUdLUUlLSlFvR0tRWUtMUUlHS1FZS0xRSU9KUW9LS1FvT0pRWUtLUUlPSlFvS0tRb09LUUlPTFFvS0tRWU9MUVlLSlFJT0tRb0tLUVlLS1FvS0pRWU9LUVlLTFFJT0tRb0tMUVlPS1FZS0xRSU9KUW9HS1FZS0pRWUdKUW9HS1FZS0xRb0dMUVlHS1FvR0pRWUtLUVlHSlFJS0tRb0dKUVlLTFFJS0tRWUdMUVlLS1FZR0tRWUdLUVlLSlFZT0tRb0tKUVlPS1FZS0xRWU9MUVlPS1FZS0xRWU9LUW9LS1FZS0tRWU9LUVlPSlFZS0tRWUtMUVlLS1FJS0tRb0tLUVlLS1FZS0tRb0tKUUlLS1FZS0xRWUtLUVlLS1FJS0tRWUtLUVlLS1FZS0tRSUtLUVlLSlFZR0xRWUdLUVlLS1FZS0tRWUdLUUlLS1FZR0tRWU9KUW9LS1FZT0xRWUtLUVlPS1FvS0tRWUtLUW9LS1FZS0tRWUtKUVlLTFFZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLSlFZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLTFFZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS21JRHBFQUFBQTBYUlNUbE1BQVFJREJBVUdCd2dKQ2dzTURRNFBFQkVTRXhRVkZoY1lHUm9iSEIwZUh5QWlJeVFsSnljb0tpc3NMUzR3TVRRMU5qYzRPVG83UER3K1AwQkNRMFJJU1VwTFRFMU9VRk5VVlZkWVdGbGFXMTVmWUdGaVkyWm5hR2xxYTJ4dGIzQnhjbk4wZG5oNWVudDhmWDUvZ0lHQ2hJV0lpb3lOam8rUWtaT1VsWmFZbVpxYm5KMmVvS0dpbzZXbXFLbXNyYTZ2c0xHenRyZTR1YnE3dkwyK3dNSER4TWpKeXN2TnpzL1EwZExVMXRmWTJkdmMzdC9nNGVMajVlYm42T25xNit6dDd1L3c4dlAwOWZiMytQbjYrL3o5L3ZrVlFYQUFBQU1hU1VSQlZIaGU1ZFh4VjFOMUdNZnh6MkFCYkRnSUFtNVZESk95VkRJSkxVTWFWcEJXVVpVYUdibXFvR3BaUlNpR2lSV3A2S29aNUFCMFpZNTBSSW1aUUlsYWhLa01ZWHYvUjkwZEJ2RVQvckpmT3IzT3VjOHY5OXpQZWM1OXp2ZjU2ait2WUtsVmlTZjcyNTBYNE1yM08yOVRncTA4QmRHQjREaGNla0VKNVlrUUtGc2dXWmR0ajlKcFYrSTh4UGpMRnFrcnNFSXFPOFBIU3BpczM2aldhemNxakVzZkpqa3ZSc3NWVTM3U2RJT3U0WENmNXZFSlBzbndKcG5STlU5Sm14aE1rOGwxZ2VoSXJxN2hURmp6T0QrVmY4ODYyOXFLTUpWTmx0SW5GZVJleFJReUpsTmVxZDFpR0RsU3pySVVJeVhieUZmbTNSWXByY1FSZTdscXRXeUdZYmZjNmRUMFIydm1kT09rWDN1NTVDMXJQMzdmdGlIK3REYnk0ci9SQlQwdzhUeUVrcitlcEI5WGdQRG1TWVlXYnJoQ3VGWWFJeXczZkRRQVhUblNraCtBTm9maUhtV2Y5bCtGWTFJOTBGZFFUZXRzdE8wMG8yM25vdnpWc0o3dUIzL0M1VGtialJ3WjVKZXJ3VjRpUldxOUhGYkZNYUsvZDBUWXFheVJpUVB1SXh4UzNCdThKV1U5MC82MHRLaTd2a2hhem5lejBhL1RiVk9LajVDYU9aaDZmV0c2L0x5djlCL1pMUjFndy9TL2ZwYmVWRDNNQ1cxbGk2U3ZXRE9uNjV0cjk5L3V2V3RCUzBYRG00czF0K3NPSHBHMGtwQkt4L2w3N3dPU254THBjeDZUWG1YTFRQUU9LWU9mOVExZGZyOC9TSjJtRmRDdmwxWWw5M0RpSFVadlhlTEpiR1N6WXU1Z1ZKMnNsYlNha09SOGR4Q3E1YWRRMm9GTHFzRTlFeDNMNHFRTzBlT1BlVTV4NTZieXBYcDRvblNFYjVPa0lDWDZsRGF0NTVUZW96dE5LUWNKYWFrcno5S0NiOTVvRDY5SUtxK3lLVzRYUGprbmFTNTJWMFRacUUyY1R0WGpjSFNDUm1VTzg4ZSs4NWhqM0VQNzRpOXA4cHlsdzdseGdNRHl5bDZPVjdaZWpuak5NZmF0dTg3THhSYkgwSVMzNWd0MmE0WmptR3BWQmRLSzNXcjZJTms4aldXU0dxYkE1NUNLZ2pCUkM2RTl3Nzh5ZFRnM0FCUzNBRlYxUU4wWTRBYTJwZ0VqV25RVVJqOUwwYXlLNlIyeXNFcXhIVUt6WW5MdnZ5VStpOUtNMkpISnpFNHZ5Wk95RGNPd09zeVNhamVMUGM4c052UEprRmx5SmQyMHdwcUF6WmVBZlozb1d5YnhkK1AvM2orU0czdVNCZGYyVlFBQUFBQkpSVTVFcmtKZ2dnPT1cXFwiKSBuby1yZXBlYXQ7XFxuICBiYWNrZ3JvdW5kOiB1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaVZWUkdMVGdpSUhOMFlXNWtZV3h2Ym1VOUltNXZJajgrQ2p3aExTMGdRM0psWVhSbFpDQjNhWFJvSUVsdWEzTmpZWEJsSUNob2RIUndPaTh2ZDNkM0xtbHVhM05qWVhCbExtOXlaeThwSUMwdFBnb0tQSE4yWndvZ0lDQjRiV3h1Y3pwa1l6MGlhSFIwY0RvdkwzQjFjbXd1YjNKbkwyUmpMMlZzWlcxbGJuUnpMekV1TVM4aUNpQWdJSGh0Ykc1ek9tTmpQU0pvZEhSd09pOHZZM0psWVhScGRtVmpiMjF0YjI1ekxtOXlaeTl1Y3lNaUNpQWdJSGh0Ykc1ek9uSmtaajBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TVRrNU9TOHdNaTh5TWkxeVpHWXRjM2x1ZEdGNExXNXpJeUlLSUNBZ2VHMXNibk02YzNablBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SUtJQ0FnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUNCNGJXeHVjenBwYm10elkyRndaVDBpYUhSMGNEb3ZMM2QzZHk1cGJtdHpZMkZ3WlM1dmNtY3ZibUZ0WlhOd1lXTmxjeTlwYm10elkyRndaU0lLSUNBZ2RtVnljMmx2YmowaU1TNHhJZ29nSUNCM2FXUjBhRDBpTmpneExqazJNalV5SWdvZ0lDQm9aV2xuYUhROUlqRTROeTQxSWdvZ0lDQnBaRDBpYzNabk1pSUtJQ0FnZUcxc09uTndZV05sUFNKd2NtVnpaWEoyWlNJK1BHMWxkR0ZrWVhSaENpQWdJQ0FnYVdROUltMWxkR0ZrWVhSaE9DSStQSEprWmpwU1JFWStQR05qT2xkdmNtc0tJQ0FnSUNBZ0lDQWdjbVJtT21GaWIzVjBQU0lpUGp4a1l6cG1iM0p0WVhRK2FXMWhaMlV2YzNabkszaHRiRHd2WkdNNlptOXliV0YwUGp4a1l6cDBlWEJsQ2lBZ0lDQWdJQ0FnSUNBZ2NtUm1PbkpsYzI5MWNtTmxQU0pvZEhSd09pOHZjSFZ5YkM1dmNtY3ZaR012WkdOdGFYUjVjR1V2VTNScGJHeEpiV0ZuWlNJZ0x6NDhMMk5qT2xkdmNtcytQQzl5WkdZNlVrUkdQand2YldWMFlXUmhkR0UrUEdSbFpuTUtJQ0FnSUNCcFpEMGlaR1ZtY3pZaVBqeGpiR2x3VUdGMGFBb2dJQ0FnSUNBZ2FXUTlJbU5zYVhCUVlYUm9NVGdpUGp4d1lYUm9DaUFnSUNBZ0lDQWdJR1E5SWswZ01Dd3hOVEF3SURBc01DQnNJRFUwTlRVdU56UXNNQ0F3TERFMU1EQWdUQ0F3TERFMU1EQWdlaUlLSUNBZ0lDQWdJQ0FnYVc1cmMyTmhjR1U2WTI5dWJtVmpkRzl5TFdOMWNuWmhkSFZ5WlQwaU1DSUtJQ0FnSUNBZ0lDQWdhV1E5SW5CaGRHZ3lNQ0lnTHo0OEwyTnNhWEJRWVhSb1Bqd3ZaR1ZtY3o0OFp3b2dJQ0FnSUhSeVlXNXpabTl5YlQwaWJXRjBjbWw0S0RFdU1qVXNNQ3d3TEMweExqSTFMREFzTVRnM0xqVXBJZ29nSUNBZ0lHbGtQU0puTVRBaVBqeG5DaUFnSUNBZ0lDQjBjbUZ1YzJadmNtMDlJbk5qWVd4bEtEQXVNU3d3TGpFcElnb2dJQ0FnSUNBZ2FXUTlJbWN4TWlJK1BHY0tJQ0FnSUNBZ0lDQWdhV1E5SW1jeE5DSStQR2NLSUNBZ0lDQWdJQ0FnSUNCamJHbHdMWEJoZEdnOUluVnliQ2dqWTJ4cGNGQmhkR2d4T0NraUNpQWdJQ0FnSUNBZ0lDQWdhV1E5SW1jeE5pSStQSEJoZEdnS0lDQWdJQ0FnSUNBZ0lDQWdJR1E5SW0wZ01UVTBOQ3cxT1RrdU5ETTBJR01nTUM0NU1pd3ROREF1TXpVeUlESTFMalk0TEMwNE1TNDJNRElnTnpFdU5UTXNMVGd4TGpZd01pQXlOeTQxTVN3d0lEUTNMalk0TERFeUxqZ3pNaUEyTVM0ME5Dd3pOUzQzTlRRZ01USXVPRE1zTWpJdU9UTWdNVEl1T0RNc05UWXVPRFV5SURFeUxqZ3pMRGd5TGpVeU55QnNJREFzTXpJNUxqRTROQ0F0TnpFdU5USXNNQ0F3TERFd05DNDFORE1nTWpZMkxqZ3pMREFnTUN3dE1UQTBMalUwTXlBdE56QXVOaXd3SURBc0xUTTBOQzQzTnlCaklEQXNMVFU0TGpZNU1TQXRNeTQyT0N3dE1UQTBMalV6TVNBdE5EUXVPVE1zTFRFMU1pNHlNVGdnTFRNMkxqWTRMQzAwTWk0eE9DQXRPVFl1TWpnc0xUWTJMakF5SUMweE5UTXVNVFFzTFRZMkxqQXlJQzB4TVRjdU16Y3NNQ0F0TWpBM0xqSTBMRGMzTGprME1TQXRNakF5TGpZMExERTVOeTR4TkRVZ2JDQXhNekF1TWl3d0lnb2dJQ0FnSUNBZ0lDQWdJQ0FnYVc1cmMyTmhjR1U2WTI5dWJtVmpkRzl5TFdOMWNuWmhkSFZ5WlQwaU1DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsa1BTSndZWFJvTWpJaUNpQWdJQ0FnSUNBZ0lDQWdJQ0J6ZEhsc1pUMGlabWxzYkRvak9HRTBNVGd5TzJacGJHd3RiM0JoWTJsMGVUb3hPMlpwYkd3dGNuVnNaVHB1YjI1NlpYSnZPM04wY205clpUcHViMjVsSWlBdlBqeHdZWFJvQ2lBZ0lDQWdJQ0FnSUNBZ0lDQmtQU0p0SURJek1ERXVOQ3cyTmpJdU5qazFJR01nTUN3NE1DNDNNRE1nTFRZMkxqazBMREUwTlM0NE1UTWdMVEUwTnk0Mk15d3hORFV1T0RFeklDMDRNeTQwTkN3d0lDMHhORGN1TmpNc0xUWTRMamM0TVNBdE1UUTNMall6TEMweE5URXVNekF4SURBc0xUYzVMamM0TlNBMk5pNDVOQ3d0TVRRMUxqZ3dNU0F4TkRVdU9Dd3RNVFExTGpnd01TQTROQzR6TlN3d0lERTBPUzQwTml3Mk55NDROVElnTVRRNUxqUTJMREUxTVM0eU9Ea2dlaUJ0SUMweExqZ3pMQzB4T0RFdU5UUTNJR01nTFRNMUxqYzNMQzAxTkM0d09UY2dMVGt6TGpVekxDMDNPQzQ0TlRrZ0xURTFOeTQzTWl3dE56Z3VPRFU1SUMweE5EQXVNeXd3SUMweU5URXVNalFzTVRFMkxqUTBPU0F0TWpVeExqSTBMREkxTkM0NU1UZ2dNQ3d4TkRJdU1USTVJREV4TXk0M0xESTJNQzQwTVNBeU5UWXVOelFzTWpZd0xqUXhJRFl6TGpJM0xEQWdNVEU0TGpJNUxDMHlPUzR6TXpZZ01UVXlMakl5TEMwNE1pNDFNak1nYkNBd0xEWTVMalk0TnlBeE56VXVNVFFzTUNBd0xDMHhNRFF1TlRJM0lDMDJNUzQwTkN3d0lEQXNMVEk0TUM0MU9UZ2dOakV1TkRRc01DQXdMQzB4TURRdU5USTNJQzB4TnpVdU1UUXNNQ0F3TERZMkxqQXhPU0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbHVhM05qWVhCbE9tTnZibTVsWTNSdmNpMWpkWEoyWVhSMWNtVTlJakFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBaRDBpY0dGMGFESTBJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2MzUjViR1U5SW1acGJHdzZJemhoTkRFNE1qdG1hV3hzTFc5d1lXTnBkSGs2TVR0bWFXeHNMWEoxYkdVNmJtOXVlbVZ5Ynp0emRISnZhMlU2Ym05dVpTSWdMejQ4Y0dGMGFBb2dJQ0FnSUNBZ0lDQWdJQ0FnWkQwaWJTQXlOakl5TGpNekxEVTFOeTR5TlRnZ1l5QXpMalkzTEMwME5DNHdNVFlnTXpNdU1ERXNMVGN6TGpNME9DQTNPQzQ0Tml3dE56TXVNelE0SURNekxqa3pMREFnTmpZdU9UTXNNak11T0RJMElEWTJMamt6TERZd0xqVXdOQ0F3TERRNExqWXdOaUF0TkRVdU9EUXNOVFl1T0RVMklDMDRNeTQwTkN3Mk5pNDVOREVnTFRnMUxqSTRMREl5TGpBd05DQXRNVGM0TGpneExEUTRMall3TmlBdE1UYzRMamd4TERFMU5TNDROemtnTUN3NU15NDFNellnTnpndU9EWXNNVFEzTGpZek15QXhOalV1T1Rnc01UUTNMall6TXlBME5Dd3dJRGd6TGpRekxDMDVMakUzTmlBeE1UQXVPVFFzTFRRMExqQXdPQ0JzSURBc016TXVPVEl5SURneUxqVXpMREFnTUN3dE1UTXlMamsyTlNBdE1UQTRMakl4TERBZ1l5QXRNUzQ0TXl3ek5DNDROVFlnTFRJNExqUXlMRFUzTGpjM05DQXROak11TWpZc05UY3VOemMwSUMwek1DNHlOaXd3SUMwMk1pNHpOU3d0TVRjdU5ESXlJQzAyTWk0ek5Td3ROVEV1TXpRNElEQXNMVFExTGpnME55QTBOQzQ1TXl3dE5UVXVPVE1nT0RBdU5qa3NMVFkwTGpFNElEZzRMakF5TEMweU1DNHhOelVnTVRneUxqUTNMQzAwTnk0Mk9UVWdNVGd5TGpRM0xDMHhOVGN1TnpNMElEQXNMVGs1TGpBeU55QXRPRE11TkRRc0xURTFOQzR3TXprZ0xURTNOUzR4TXl3dE1UVTBMakF6T1NBdE5Ea3VOVE1zTUNBdE9UUXVORFlzTVRVdU5UZ3lJQzB4TWpZdU5UVXNOVE11TVRnZ2JDQXdMQzAwTUM0ek5DQXRPRFV1TWpjc01DQXdMREUwTWk0eE1qa2dNVEUwTGpZeUxEQWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcGJtdHpZMkZ3WlRwamIyNXVaV04wYjNJdFkzVnlkbUYwZFhKbFBTSXdJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXUTlJbkJoZEdneU5pSUtJQ0FnSUNBZ0lDQWdJQ0FnSUhOMGVXeGxQU0ptYVd4c09pTTRZVFF4T0RJN1ptbHNiQzF2Y0dGamFYUjVPakU3Wm1sc2JDMXlkV3hsT201dmJucGxjbTg3YzNSeWIydGxPbTV2Ym1VaUlDOCtQSEJoZEdnS0lDQWdJQ0FnSUNBZ0lDQWdJR1E5SW0wZ01qazRPQzR4T0N3NE1EQXVNalUwSUMwMk15NHlOaXd3SURBc01UQTBMalV5TnlBeE5qVXVNRFVzTUNBd0xDMDNNeTR6TlRVZ1l5QXpNUzR4T0N3MU1TNHpORGNnTnpndU9EWXNPRFV1TWpjM0lERTBNUzR5TVN3NE5TNHlOemNnTmpjdU9EVXNNQ0F4TWpRdU56RXNMVFF4TGpJMU9DQXhOVEl1TWpFc0xURXdNaTQyT1RrZ01qWXVOaXcyTWk0ek5URWdPVEl1TmpJc01UQXlMalk1T1NBeE5qQXVORGNzTVRBeUxqWTVPU0ExTXk0eE9Td3dJREV3TlM0ME5pd3RNaklnTVRReExqSXhMQzAyTWk0ek5URWdNemd1TlRJc0xUUTBMamt6T0NBek9DNDFNaXd0T1RNdU5UTXlJRE00TGpVeUxDMHhORGt1TkRVM0lHd2dNQ3d0TVRnMUxqSXpPU0EyTXk0eU55d3dJREFzTFRFd05DNDFNamNnTFRJek9DNDBNaXd3SURBc01UQTBMalV5TnlBMk15NHlPQ3d3SURBc01UVTNMamN4TlNCaklEQXNNekl1TVRBeUlEQXNOakF1TlRJM0lDMHhOQzQyTnl3NE9DNDVOVGNnTFRFNExqTTBMREkyTGpVNE1pQXRORGd1TmpFc05EQXVNelEwSUMwM09TNDNOeXcwTUM0ek5EUWdMVE13TGpJMkxEQWdMVFl6TGpJNExDMHhNaTQ0TkRRZ0xUZ3lMalV6TEMwek5pNDJOeklnTFRJeUxqa3pMQzB5T1M0ek5UVWdMVEl5TGprekxDMDFOaTQ0TmpNZ0xUSXlMamt6TEMwNU1pNDJNamtnYkNBd0xDMHhOVGN1TnpFMUlEWXpMakkzTERBZ01Dd3RNVEEwTGpVeU55QXRNak00TGpReExEQWdNQ3d4TURRdU5USTNJRFl6TGpJNExEQWdNQ3d4TlRBdU16Z3pJR01nTUN3eU9TNHpORGdnTUN3Mk5pNHdNak1nTFRFMExqWTNMRGt4TGpZNU9TQXRNVFV1TlRrc01qa3VNek0ySUMwME55NDJPU3cwTkM0NU16UWdMVGd3TGpjc05EUXVPVE0wSUMwek1TNHhPQ3d3SUMwMU55NDNOeXd0TVRFdU1EQTRJQzAzTnk0NU5Dd3RNelV1TnpjMElDMHlOQzQzTnl3dE16QXVNalV6SUMweU5pNDJMQzAyTWk0ek5ETWdMVEkyTGpZc0xUazVMamswTVNCc0lEQXNMVEUxTVM0ek1ERWdOak11TWpjc01DQXdMQzB4TURRdU5USTNJQzB5TXpndU5Dd3dJREFzTVRBMExqVXlOeUEyTXk0eU5pd3dJREFzTWpnd0xqVTVPQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbHVhM05qWVhCbE9tTnZibTVsWTNSdmNpMWpkWEoyWVhSMWNtVTlJakFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBaRDBpY0dGMGFESTRJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2MzUjViR1U5SW1acGJHdzZJemhoTkRFNE1qdG1hV3hzTFc5d1lXTnBkSGs2TVR0bWFXeHNMWEoxYkdVNmJtOXVlbVZ5Ynp0emRISnZhMlU2Ym05dVpTSWdMejQ4Y0dGMGFBb2dJQ0FnSUNBZ0lDQWdJQ0FnWkQwaWJTQXpPVGs0TGpZMkxEazFNUzQxTkRjZ0xURXhNUzQ0Tnl3d0lEQXNNVEU0TGpJNU15QXhNVEV1T0Rjc01DQXdMQzB4TVRndU1qa3pJSG9nYlNBd0xDMDBNekV1T0RreElEWXpMakkzTERBZ01Dd3RNVEEwTGpVeU55QXRNak01TGpNekxEQWdNQ3d4TURRdU5USTNJRFkwTGpFNUxEQWdNQ3d5T0RBdU5UazRJQzAyTXk0eU55d3dJREFzTVRBMExqVXlOeUF4TnpVdU1UUXNNQ0F3TEMwek9EVXVNVEkxSWdvZ0lDQWdJQ0FnSUNBZ0lDQWdhVzVyYzJOaGNHVTZZMjl1Ym1WamRHOXlMV04xY25aaGRIVnlaVDBpTUNJS0lDQWdJQ0FnSUNBZ0lDQWdJR2xrUFNKd1lYUm9NekFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnpkSGxzWlQwaVptbHNiRG9qT0dFME1UZ3lPMlpwYkd3dGIzQmhZMmwwZVRveE8yWnBiR3d0Y25Wc1pUcHViMjU2WlhKdk8zTjBjbTlyWlRwdWIyNWxJaUF2UGp4d1lYUm9DaUFnSUNBZ0lDQWdJQ0FnSUNCa1BTSnRJRFF4TlRrdU1USXNPREF3TGpJMU5DQXROak11TWpjc01DQXdMREV3TkM0MU1qY2dNVGMxTGpFMExEQWdNQ3d0TmprdU5qZzNJR01nTWprdU16VXNOVFF1TVRBeElEZzBMak0yTERnd0xqWTVPU0F4TkRRdU9EY3NPREF1TmprNUlEVXpMakU1TERBZ01UQTFMalExTEMweU1pNHdNVFlnTVRReExqSXlMQzAyTUM0MU1qY2dOREF1TXpRc0xUUTBMamt6TkNBME1TNHlOaXd0T0RndU1ETXlJRFF4TGpJMkxDMHhORE11T1RVM0lHd2dNQ3d0TVRreExqWTFNeUEyTXk0eU55d3dJREFzTFRFd05DNDFNamNnTFRJek9DNDBMREFnTUN3eE1EUXVOVEkzSURZekxqSTJMREFnTUN3eE5UZ3VOak0zSUdNZ01Dd3pNQzR5TmpJZ01DdzJNUzQwTXpRZ0xURTVMakkyTERnNExqQXpOU0F0TWpBdU1UY3NNall1TlRneUlDMDFNeTR4T0N3ek9TNDBNVFFnTFRnMkxqRTVMRE01TGpReE5DQXRNek11T1RNc01DQXROamd1Tnpjc0xURXpMamMxSUMwNE9DNDVOQ3d0TkRFdU1qVWdMVEl4TGpBNUxDMHlOeTQxSUMweU1TNHdPU3d0TmprdU5qZzNJQzB5TVM0d09Td3RNVEF5TGpjd055QnNJREFzTFRFME1pNHhNamtnTmpNdU1qWXNNQ0F3TEMweE1EUXVOVEkzSUMweU16Z3VOQ3d3SURBc01UQTBMalV5TnlBMk15NHlOeXd3SURBc01qZ3dMalU1T0NJS0lDQWdJQ0FnSUNBZ0lDQWdJR2x1YTNOallYQmxPbU52Ym01bFkzUnZjaTFqZFhKMllYUjFjbVU5SWpBaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwWkQwaWNHRjBhRE15SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdjM1I1YkdVOUltWnBiR3c2SXpoaE5ERTRNanRtYVd4c0xXOXdZV05wZEhrNk1UdG1hV3hzTFhKMWJHVTZibTl1ZW1WeWJ6dHpkSEp2YTJVNmJtOXVaU0lnTHo0OGNHRjBhQW9nSUNBZ0lDQWdJQ0FnSUNBZ1pEMGliU0ExTURneUxqUTRMRGN3TXk0NU5qVWdZeUF0TVRrdU1qUXNOekF1TmpBMUlDMDRNUzQyTERFeE5TNDFORGNnTFRFMU5DNHdOQ3d4TVRVdU5UUTNJQzAyTmk0d05Dd3dJQzB4TWprdU15d3ROVEV1TXpRNElDMHhORE11TURVc0xURXhOUzQxTkRjZ2JDQXlPVGN1TURrc01DQjZJRzBnT0RVdU1qY3NMVEUwTkM0NE9ETWdZeUF0TXpndU5URXNMVGt6TGpVeU15QXRNVEk1TGpJM0xDMHhOVFl1TnpreklDMHlNekV1TURVc0xURTFOaTQzT1RNZ0xURTBNeTR3Tnl3d0lDMHlOVGN1Tmpnc01URXhMamczTVNBdE1qVTNMalk0TERJMU5TNDRNellnTUN3eE5EUXVPRGd6SURFd09TNHhNaXd5TmpFdU16STRJREkxTkM0NU1Td3lOakV1TXpJNElEWTNMamczTERBZ01UTTFMamN5TEMwek1DNHlOVGdnTVRnekxqTTVMQzAzT0M0NE5qTWdORGd1TmpJc0xUVXhMak0wTkNBMk9DNDNPU3d0TVRFekxqWTVOU0EyT0M0M09Td3RNVGd6TGpNNE15QnNJQzB6TGpZM0xDMHpPUzQwTXpRZ0xUTTVOaTR4TXl3d0lHTWdNVFF1Tmpjc0xUWTNMamcyTXlBM055NHdNeXd0TVRFM0xqTTJNeUF4TkRZdU56SXNMVEV4Tnk0ek5qTWdORGd1TlRrc01DQTVNQzQzTml3eE9DNHpNamdnTVRFNExqSTRMRFU0TGpZM01pQnNJREV4Tmk0ME5Dd3dJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXNXJjMk5oY0dVNlkyOXVibVZqZEc5eUxXTjFjblpoZEhWeVpUMGlNQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbGtQU0p3WVhSb016UWlDaUFnSUNBZ0lDQWdJQ0FnSUNCemRIbHNaVDBpWm1sc2JEb2pPR0UwTVRneU8yWnBiR3d0YjNCaFkybDBlVG94TzJacGJHd3RjblZzWlRwdWIyNTZaWEp2TzNOMGNtOXJaVHB1YjI1bElpQXZQanh3WVhSb0NpQWdJQ0FnSUNBZ0lDQWdJQ0JrUFNKdElEWTVNQzQ0T1RVc09EVXdMamN3TXlBNU1DNDNOU3d3SURJeUxqVTBNeXd6TVM0d016VWdNQ3d5TkRNdU1USXlJQzB4TXpVdU9ESTVMREFnTUN3dE1qUXpMakUwTVNBeU1pNDFNellzTFRNeExqQXhOaUlLSUNBZ0lDQWdJQ0FnSUNBZ0lHbHVhM05qWVhCbE9tTnZibTVsWTNSdmNpMWpkWEoyWVhSMWNtVTlJakFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBaRDBpY0dGMGFETTJJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2MzUjViR1U5SW1acGJHdzZJemhoTkRFNE1qdG1hV3hzTFc5d1lXTnBkSGs2TVR0bWFXeHNMWEoxYkdVNmJtOXVlbVZ5Ynp0emRISnZhMlU2Ym05dVpTSWdMejQ4Y0dGMGFBb2dJQ0FnSUNBZ0lDQWdJQ0FnWkQwaWJTQTJNekl1TXprMUxEYzBNaTR5TlRnZ01qZ3VNRE01TERnMkxqTXdOQ0F0TWpJdU5UVXhMRE14TGpBMElDMHlNekV1TWpJekxEYzFMakV5T0NBdE5ERXVPVGMyTEMweE1qa3VNVGd6SURJek1TNHlOVGNzTFRjMUxqRXpOeUF6Tmk0ME5UUXNNVEV1T0RRNElnb2dJQ0FnSUNBZ0lDQWdJQ0FnYVc1cmMyTmhjR1U2WTI5dWJtVmpkRzl5TFdOMWNuWmhkSFZ5WlQwaU1DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsa1BTSndZWFJvTXpnaUNpQWdJQ0FnSUNBZ0lDQWdJQ0J6ZEhsc1pUMGlabWxzYkRvak9HRTBNVGd5TzJacGJHd3RiM0JoWTJsMGVUb3hPMlpwYkd3dGNuVnNaVHB1YjI1NlpYSnZPM04wY205clpUcHViMjVsSWlBdlBqeHdZWFJvQ2lBZ0lDQWdJQ0FnSUNBZ0lDQmtQU0p0SURjeE55NDBORGtzTmpVekxqRXdOU0F0TnpNdU5ERXNOVE11TXpZZ0xUTTJMalE0T0N3dE1URXVPRGMxSUMweE5ESXVPVEF6TEMweE9UWXVOamt5SURFd09TNDRPRE1zTFRjNUxqZ3lPQ0F4TkRJdU9URTRMREU1Tmk0M01ETWdNQ3d6T0M0ek16SWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcGJtdHpZMkZ3WlRwamIyNXVaV04wYjNJdFkzVnlkbUYwZFhKbFBTSXdJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXUTlJbkJoZEdnME1DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUhOMGVXeGxQU0ptYVd4c09pTTRZVFF4T0RJN1ptbHNiQzF2Y0dGamFYUjVPakU3Wm1sc2JDMXlkV3hsT201dmJucGxjbTg3YzNSeWIydGxPbTV2Ym1VaUlDOCtQSEJoZEdnS0lDQWdJQ0FnSUNBZ0lDQWdJR1E5SW0wZ09ESTRMalV5TERjd05pNDBOalVnTFRjekxqUXlOaXd0TlRNdU16UWdNQzR3TVRFc0xUTTRMak0xT1NCTUlEZzVPQzR3TURRc05ERTRMakEzSURFd01EY3VPU3cwT1RjdU9EazRJRGcyTkM0NU56TXNOamswTGpZd09TQTRNamd1TlRJc056QTJMalEyTlNJS0lDQWdJQ0FnSUNBZ0lDQWdJR2x1YTNOallYQmxPbU52Ym01bFkzUnZjaTFqZFhKMllYUjFjbVU5SWpBaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwWkQwaWNHRjBhRFF5SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdjM1I1YkdVOUltWnBiR3c2SXpoaE5ERTRNanRtYVd4c0xXOXdZV05wZEhrNk1UdG1hV3hzTFhKMWJHVTZibTl1ZW1WeWJ6dHpkSEp2YTJVNmJtOXVaU0lnTHo0OGNHRjBhQW9nSUNBZ0lDQWdJQ0FnSUNBZ1pEMGliU0E0TVRJdU1EZzJMRGd5T0M0MU9EWWdNamd1TURVMUxDMDROaTR6TWlBek5pNDBPRFFzTFRFeExqZ3pOaUF5TXpFdU1qSTFMRGMxTGpFeE55QXROREV1T1Rjc01USTVMakU0TXlBdE1qTXhMakl6T1N3dE56VXVNVFFnTFRJeUxqVTFOU3d0TXpFdU1EQTBJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXNXJjMk5oY0dVNlkyOXVibVZqZEc5eUxXTjFjblpoZEhWeVpUMGlNQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbGtQU0p3WVhSb05EUWlDaUFnSUNBZ0lDQWdJQ0FnSUNCemRIbHNaVDBpWm1sc2JEb2pPR0UwTVRneU8yWnBiR3d0YjNCaFkybDBlVG94TzJacGJHd3RjblZzWlRwdWIyNTZaWEp2TzNOMGNtOXJaVHB1YjI1bElpQXZQanh3WVhSb0NpQWdJQ0FnSUNBZ0lDQWdJQ0JrUFNKdElEY3pOaTR6TURFc01UTXpOUzQ0T0NCaklDMHpNak11TURRM0xEQWdMVFU0TlM0NE56VXNMVEkyTWk0M09DQXROVGcxTGpnM05Td3ROVGcxTGpjNE1pQXdMQzB6TWpNdU1URTRJREkyTWk0NE1qZ3NMVFU0TlM0NU56Y2dOVGcxTGpnM05Td3ROVGcxTGprM055QXpNak11TURFNUxEQWdOVGcxTGpnd09Td3lOakl1T0RVNUlEVTROUzQ0TURrc05UZzFMamszTnlBd0xETXlNeTR3TURJZ0xUSTJNaTQzT1N3MU9EVXVOemd5SUMwMU9EVXVPREE1TERVNE5TNDNPRElnYkNBd0xEQWdlaUJ0SURBc0xURXhPQzQyTVNCaklESTFOeTQ1TnpJc01DQTBOamN1TVRnNUxDMHlNRGt1TVRNZ05EWTNMakU0T1N3dE5EWTNMakUzTWlBd0xDMHlOVGd1TVRJNUlDMHlNRGt1TWpFM0xDMDBOamN1TXpRNElDMDBOamN1TVRnNUxDMDBOamN1TXpRNElDMHlOVGd1TURjMExEQWdMVFEyTnk0eU5UUXNNakE1TGpJeE9TQXRORFkzTGpJMU5DdzBOamN1TXpRNElEQXNNalU0TGpBME1pQXlNRGt1TVRnc05EWTNMakUzTWlBME5qY3VNalUwTERRMk55NHhOeklpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBibXR6WTJGd1pUcGpiMjV1WldOMGIzSXRZM1Z5ZG1GMGRYSmxQU0l3SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdhV1E5SW5CaGRHZzBOaUlLSUNBZ0lDQWdJQ0FnSUNBZ0lITjBlV3hsUFNKbWFXeHNPaU00WVRReE9ESTdabWxzYkMxdmNHRmphWFI1T2pFN1ptbHNiQzF5ZFd4bE9tNXZibnBsY204N2MzUnliMnRsT201dmJtVWlJQzgrUEhCaGRHZ0tJQ0FnSUNBZ0lDQWdJQ0FnSUdROUltMGdNVEE1TVM0eE15dzJNVGt1T0RneklDMHhOelV1TnpjeExEVTNMakV5TVNBeE1TNDJNamtzTXpVdU9EQTRJREUzTlM0M05qSXNMVFUzTGpFeU1TQXRNVEV1TmpJc0xUTTFMamd3T0NJS0lDQWdJQ0FnSUNBZ0lDQWdJR2x1YTNOallYQmxPbU52Ym01bFkzUnZjaTFqZFhKMllYUjFjbVU5SWpBaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwWkQwaWNHRjBhRFE0SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdjM1I1YkdVOUltWnBiR3c2SXpoaE5ERTRNanRtYVd4c0xXOXdZV05wZEhrNk1UdG1hV3hzTFhKMWJHVTZibTl1ZW1WeWJ6dHpkSEp2YTJVNmJtOXVaU0lnTHo0OGNHRjBhQW9nSUNBZ0lDQWdJQ0FnSUNBZ1pEMGlUU0E0TmpZdU9UVTNMRGt3TWk0d056UWdPRE0yTGpVc09USTBMakU1T1NBNU5EVXVNVEl4TERFd056TXVOek1nT1RjMUxqVTROaXd4TURVeExqWXhJRGcyTmk0NU5UY3NPVEF5TGpBM05DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsdWEzTmpZWEJsT21OdmJtNWxZM1J2Y2kxamRYSjJZWFIxY21VOUlqQWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcFpEMGljR0YwYURVd0lnb2dJQ0FnSUNBZ0lDQWdJQ0FnYzNSNWJHVTlJbVpwYkd3Nkl6aGhOREU0TWp0bWFXeHNMVzl3WVdOcGRIazZNVHRtYVd4c0xYSjFiR1U2Ym05dWVtVnlienR6ZEhKdmEyVTZibTl1WlNJZ0x6NDhjR0YwYUFvZ0lDQWdJQ0FnSUNBZ0lDQWdaRDBpVFNBMk1EY3VORFkxTERrd015NDBORFVnTkRrNExqZzFOU3d4TURVeUxqazNJRFV5T1M0ek1pd3hNRGMxTGpFZ05qTTNMamt6TERreU5TNDFOallnTmpBM0xqUTJOU3c1TURNdU5EUTFJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXNXJjMk5oY0dVNlkyOXVibVZqZEc5eUxXTjFjblpoZEhWeVpUMGlNQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbGtQU0p3WVhSb05USWlDaUFnSUNBZ0lDQWdJQ0FnSUNCemRIbHNaVDBpWm1sc2JEb2pPR0UwTVRneU8yWnBiR3d0YjNCaFkybDBlVG94TzJacGJHd3RjblZzWlRwdWIyNTZaWEp2TzNOMGNtOXJaVHB1YjI1bElpQXZQanh3WVhSb0NpQWdJQ0FnSUNBZ0lDQWdJQ0JrUFNKdElETTRNQzQyT0Rnc05qSXlMakV5T1NBdE1URXVOakkyTERNMUxqZ3dNU0F4TnpVdU56VTRMRFUzTGpBNUlERXhMall5TVN3dE16VXVPREF4SUMweE56VXVOelV6TEMwMU55NHdPU0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbHVhM05qWVhCbE9tTnZibTVsWTNSdmNpMWpkWEoyWVhSMWNtVTlJakFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBaRDBpY0dGMGFEVTBJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2MzUjViR1U5SW1acGJHdzZJemhoTkRFNE1qdG1hV3hzTFc5d1lXTnBkSGs2TVR0bWFXeHNMWEoxYkdVNmJtOXVlbVZ5Ynp0emRISnZhMlU2Ym05dVpTSWdMejQ4Y0dGMGFBb2dJQ0FnSUNBZ0lDQWdJQ0FnWkQwaWJTQTNNVFl1TWpnNUxETTNOaTQxT1NBek55NDJOREEyTERBZ01Dd3hPRFF1T0RFMklDMHpOeTQyTkRBMkxEQWdNQ3d0TVRnMExqZ3hOaUI2SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdhVzVyYzJOaGNHVTZZMjl1Ym1WamRHOXlMV04xY25aaGRIVnlaVDBpTUNJS0lDQWdJQ0FnSUNBZ0lDQWdJR2xrUFNKd1lYUm9OVFlpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnpkSGxzWlQwaVptbHNiRG9qT0dFME1UZ3lPMlpwYkd3dGIzQmhZMmwwZVRveE8yWnBiR3d0Y25Wc1pUcHViMjU2WlhKdk8zTjBjbTlyWlRwdWIyNWxJaUF2UGp3dlp6NDhMMmMrUEM5blBqd3ZaejQ4TDNOMlp6ND1cXFwiKSBuby1yZXBlYXQsIG5vbmU7XFxuICAtbW96LWJhY2tncm91bmQtc2l6ZTogMTAwJTtcXG4gIC1vLWJhY2tncm91bmQtc2l6ZTogMTAwJTtcXG4gIC13ZWJraXQtYmFja2dyb3VuZC1zaXplOiAxMDAlO1xcbiAgYmFja2dyb3VuZC1zaXplOiAxMDAlO1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBmbG9hdDogbGVmdDtcXG4gIHdpZHRoOiA5MHB4O1xcbiAgaGVpZ2h0OiAyNXB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhbm5lciAuamFzbWluZS12ZXJzaW9uIHtcXG4gIG1hcmdpbi1sZWZ0OiAxNHB4O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgdG9wOiA2cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgI2phc21pbmVfY29udGVudCB7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICByaWdodDogMTAwJTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS12ZXJzaW9uIHtcXG4gIGNvbG9yOiAjYWFhO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhbm5lciB7XFxuICBtYXJnaW4tdG9wOiAxNHB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWR1cmF0aW9uIHtcXG4gIGNvbG9yOiAjZmZmO1xcbiAgZmxvYXQ6IHJpZ2h0O1xcbiAgbGluZS1oZWlnaHQ6IDI4cHg7XFxuICBwYWRkaW5nLXJpZ2h0OiA5cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkge1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIG1hcmdpbjogMTRweCAwO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGhlaWdodDogMTBweDtcXG4gIHdpZHRoOiAxNHB4O1xcbiAgZm9udC1zaXplOiAxNnB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpLmphc21pbmUtcGFzc2VkIHtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaS5qYXNtaW5lLXBhc3NlZDpiZWZvcmUge1xcbiAgY29sb3I6ICMwMDcwNjk7XFxuICBjb250ZW50OiBcXFwi4oCiXFxcIjtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaS5qYXNtaW5lLWZhaWxlZCB7XFxuICBsaW5lLWhlaWdodDogOXB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpLmphc21pbmUtZmFpbGVkOmJlZm9yZSB7XFxuICBjb2xvcjogI2NhM2ExMTtcXG4gIGNvbnRlbnQ6IFxcXCLDl1xcXCI7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIG1hcmdpbi1sZWZ0OiAtMXB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpLmphc21pbmUtZXhjbHVkZWQge1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpLmphc21pbmUtZXhjbHVkZWQ6YmVmb3JlIHtcXG4gIGNvbG9yOiAjYmFiYWJhO1xcbiAgY29udGVudDogXFxcIuKAolxcXCI7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkgbGkuamFzbWluZS1leGNsdWRlZC1uby1kaXNwbGF5IHtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkgbGkuamFzbWluZS1wZW5kaW5nIHtcXG4gIGxpbmUtaGVpZ2h0OiAxN3B4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpLmphc21pbmUtcGVuZGluZzpiZWZvcmUge1xcbiAgY29sb3I6ICNiYTlkMzc7XFxuICBjb250ZW50OiBcXFwiKlxcXCI7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkgbGkuamFzbWluZS1lbXB0eSB7XFxuICBmb250LXNpemU6IDE0cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkgbGkuamFzbWluZS1lbXB0eTpiZWZvcmUge1xcbiAgY29sb3I6ICNiYTlkMzc7XFxuICBjb250ZW50OiBcXFwi4oCiXFxcIjtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1ydW4tb3B0aW9ucyB7XFxuICBmbG9hdDogcmlnaHQ7XFxuICBtYXJnaW4tcmlnaHQ6IDVweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICM4YTQxODI7XFxuICBjb2xvcjogIzhhNDE4MjtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGxpbmUtaGVpZ2h0OiAyMHB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXJ1bi1vcHRpb25zIC5qYXNtaW5lLXRyaWdnZXIge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgcGFkZGluZzogOHB4IDE2cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtcnVuLW9wdGlvbnMgLmphc21pbmUtcGF5bG9hZCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBkaXNwbGF5OiBub25lO1xcbiAgcmlnaHQ6IC0xcHg7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjOGE0MTgyO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VlZTtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuICBwYWRkaW5nOiA0cHggOHB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXJ1bi1vcHRpb25zIC5qYXNtaW5lLXBheWxvYWQuamFzbWluZS1vcGVuIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhciB7XFxuICBsaW5lLWhlaWdodDogMjhweDtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgY29sb3I6ICNlZWU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFyLmphc21pbmUtZmFpbGVkLCAuamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhci5qYXNtaW5lLWVycm9yZWQge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2NhM2ExMTtcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZWVlO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhci5qYXNtaW5lLXBhc3NlZCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDA3MDY5O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhci5qYXNtaW5lLWluY29tcGxldGUge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2JhYmFiYTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYXIuamFzbWluZS1za2lwcGVkIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNiYWJhYmE7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFyLmphc21pbmUtd2FybmluZyB7XFxuICBtYXJnaW4tdG9wOiAxNHB4O1xcbiAgbWFyZ2luLWJvdHRvbTogMTRweDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNiYTlkMzc7XFxuICBjb2xvcjogIzMzMztcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYXIuamFzbWluZS1tZW51IHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICBjb2xvcjogI2FhYTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYXIuamFzbWluZS1tZW51IGEge1xcbiAgY29sb3I6ICMzMzM7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFyIGEge1xcbiAgY29sb3I6IHdoaXRlO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyLmphc21pbmUtc3BlYy1saXN0IC5qYXNtaW5lLWJhci5qYXNtaW5lLW1lbnUuamFzbWluZS1mYWlsdXJlLWxpc3QsXFxuLmphc21pbmVfaHRtbC1yZXBvcnRlci5qYXNtaW5lLXNwZWMtbGlzdCAuamFzbWluZS1yZXN1bHRzIC5qYXNtaW5lLWZhaWx1cmVzIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIuamFzbWluZS1mYWlsdXJlLWxpc3QgLmphc21pbmUtYmFyLmphc21pbmUtbWVudS5qYXNtaW5lLXNwZWMtbGlzdCxcXG4uamFzbWluZV9odG1sLXJlcG9ydGVyLmphc21pbmUtZmFpbHVyZS1saXN0IC5qYXNtaW5lLXN1bW1hcnkge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1yZXN1bHRzIHtcXG4gIG1hcmdpbi10b3A6IDE0cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3VtbWFyeSB7XFxuICBtYXJnaW4tdG9wOiAxNHB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1bW1hcnkgdWwge1xcbiAgbGlzdC1zdHlsZS10eXBlOiBub25lO1xcbiAgbWFyZ2luLWxlZnQ6IDE0cHg7XFxuICBwYWRkaW5nLXRvcDogMDtcXG4gIHBhZGRpbmctbGVmdDogMDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdW1tYXJ5IHVsLmphc21pbmUtc3VpdGUge1xcbiAgbWFyZ2luLXRvcDogN3B4O1xcbiAgbWFyZ2luLWJvdHRvbTogN3B4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1bW1hcnkgbGkuamFzbWluZS1wYXNzZWQgYSB7XFxuICBjb2xvcjogIzAwNzA2OTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdW1tYXJ5IGxpLmphc21pbmUtZmFpbGVkIGEge1xcbiAgY29sb3I6ICNjYTNhMTE7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3VtbWFyeSBsaS5qYXNtaW5lLWVtcHR5IGEge1xcbiAgY29sb3I6ICNiYTlkMzc7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3VtbWFyeSBsaS5qYXNtaW5lLXBlbmRpbmcgYSB7XFxuICBjb2xvcjogI2JhOWQzNztcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdW1tYXJ5IGxpLmphc21pbmUtZXhjbHVkZWQgYSB7XFxuICBjb2xvcjogI2JhYmFiYTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zcGVjcyBsaS5qYXNtaW5lLXBhc3NlZCBhOmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwi4oCiIFxcXCI7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3BlY3MgbGkuamFzbWluZS1mYWlsZWQgYTpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIsOXIFxcXCI7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3BlY3MgbGkuamFzbWluZS1lbXB0eSBhOmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwiKiBcXFwiO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXNwZWNzIGxpLmphc21pbmUtcGVuZGluZyBhOmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwi4oCiIFxcXCI7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3BlY3MgbGkuamFzbWluZS1leGNsdWRlZCBhOmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwi4oCiIFxcXCI7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZGVzY3JpcHRpb24gKyAuamFzbWluZS1zdWl0ZSB7XFxuICBtYXJnaW4tdG9wOiAwO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1aXRlIHtcXG4gIG1hcmdpbi10b3A6IDE0cHg7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3VpdGUgYSB7XFxuICBjb2xvcjogIzMzMztcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1mYWlsdXJlcyAuamFzbWluZS1zcGVjLWRldGFpbCB7XFxuICBtYXJnaW4tYm90dG9tOiAyOHB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWZhaWx1cmVzIC5qYXNtaW5lLXNwZWMtZGV0YWlsIC5qYXNtaW5lLWRlc2NyaXB0aW9uIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNjYTNhMTE7XFxuICBjb2xvcjogd2hpdGU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZmFpbHVyZXMgLmphc21pbmUtc3BlYy1kZXRhaWwgLmphc21pbmUtZGVzY3JpcHRpb24gYSB7XFxuICBjb2xvcjogd2hpdGU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtcmVzdWx0LW1lc3NhZ2Uge1xcbiAgcGFkZGluZy10b3A6IDE0cHg7XFxuICBjb2xvcjogIzMzMztcXG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1yZXN1bHQtbWVzc2FnZSBzcGFuLmphc21pbmUtcmVzdWx0IHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN0YWNrLXRyYWNlIHtcXG4gIG1hcmdpbjogNXB4IDAgMCAwO1xcbiAgbWF4LWhlaWdodDogMjI0cHg7XFxuICBvdmVyZmxvdzogYXV0bztcXG4gIGxpbmUtaGVpZ2h0OiAxOHB4O1xcbiAgY29sb3I6ICM2NjY7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZGRkO1xcbiAgYmFja2dyb3VuZDogd2hpdGU7XFxuICB3aGl0ZS1zcGFjZTogcHJlO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWV4cGFuZGVyIGEge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBtYXJnaW4tbGVmdDogMTRweDtcXG4gIGNvbG9yOiBibHVlO1xcbiAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxufVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZXhwYW5kZXItY29udGVudHMge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1leHBhbmRlZCB7XFxuICBwYWRkaW5nLWJvdHRvbTogMTBweDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1leHBhbmRlZCAuamFzbWluZS1leHBhbmRlci1jb250ZW50cyB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIG1hcmdpbi1sZWZ0OiAxNHB4O1xcbiAgcGFkZGluZzogNXB4O1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWRlYnVnLWxvZyB7XFxuICBtYXJnaW46IDVweCAwIDAgMDtcXG4gIHBhZGRpbmc6IDVweDtcXG4gIGNvbG9yOiAjNjY2O1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2RkZDtcXG4gIGJhY2tncm91bmQ6IHdoaXRlO1xcbn1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWRlYnVnLWxvZyB0YWJsZSB7XFxuICBib3JkZXItc3BhY2luZzogMDtcXG59XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1kZWJ1Zy1sb2cgdGFibGUsIC5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZGVidWctbG9nIHRoLCAuamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWRlYnVnLWxvZyB0ZCB7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZGRkO1xcbn1cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IFwiXCI7XG4gICAgICB2YXIgbmVlZExheWVyID0gdHlwZW9mIGl0ZW1bNV0gIT09IFwidW5kZWZpbmVkXCI7XG5cbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnRlbnQgKz0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtKTtcblxuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gaShtb2R1bGVzLCBtZWRpYSwgZGVkdXBlLCBzdXBwb3J0cywgbGF5ZXIpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIHVuZGVmaW5lZF1dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGlkID0gdGhpc1trXVswXTtcblxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9rID0gMDsgX2sgPCBtb2R1bGVzLmxlbmd0aDsgX2srKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfa10pO1xuXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgbGF5ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtWzVdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdXBwb3J0cykge1xuICAgICAgICBpZiAoIWl0ZW1bNF0pIHtcbiAgICAgICAgICBpdGVtWzRdID0gXCJcIi5jb25jYXQoc3VwcG9ydHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs0XSA9IHN1cHBvcnRzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXTtcbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoY3NzTWFwcGluZykpKSk7XG4gICAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgXCJcIikuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbihcIlxcblwiKTtcbn07IiwiLypcbkNvcHlyaWdodCAoYykgMjAwOC0yMDIyIFBpdm90YWwgTGFic1xuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbmEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG53aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG5kaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbnBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xudGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG5FWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbk1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG5OT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXG5MSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OXG5PRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbldJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuKi9cbi8qKlxuIFRoaXMgZmlsZSBzdGFydHMgdGhlIHByb2Nlc3Mgb2YgXCJib290aW5nXCIgSmFzbWluZS4gSXQgaW5pdGlhbGl6ZXMgSmFzbWluZSxcbiBtYWtlcyBpdHMgZ2xvYmFscyBhdmFpbGFibGUsIGFuZCBjcmVhdGVzIHRoZSBlbnYuIFRoaXMgZmlsZSBzaG91bGQgYmUgbG9hZGVkXG4gYWZ0ZXIgYGphc21pbmUuanNgIGFuZCBgamFzbWluZV9odG1sLmpzYCwgYnV0IGJlZm9yZSBgYm9vdDEuanNgIG9yIGFueSBwcm9qZWN0XG4gc291cmNlIGZpbGVzIG9yIHNwZWMgZmlsZXMgYXJlIGxvYWRlZC5cbiAqL1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgamFzbWluZVJlcXVpcmUgPSB3aW5kb3cuamFzbWluZVJlcXVpcmUgfHwgcmVxdWlyZSgnLi9qYXNtaW5lLmpzJyk7XG5cbiAgLyoqXG4gICAqICMjIFJlcXVpcmUgJmFtcDsgSW5zdGFudGlhdGVcbiAgICpcbiAgICogUmVxdWlyZSBKYXNtaW5lJ3MgY29yZSBmaWxlcy4gU3BlY2lmaWNhbGx5LCB0aGlzIHJlcXVpcmVzIGFuZCBhdHRhY2hlcyBhbGwgb2YgSmFzbWluZSdzIGNvZGUgdG8gdGhlIGBqYXNtaW5lYCByZWZlcmVuY2UuXG4gICAqL1xuICB2YXIgamFzbWluZSA9IGphc21pbmVSZXF1aXJlLmNvcmUoamFzbWluZVJlcXVpcmUpLFxuICAgIGdsb2JhbCA9IGphc21pbmUuZ2V0R2xvYmFsKCk7XG4gIGdsb2JhbC5qYXNtaW5lID0gamFzbWluZTtcblxuICAvKipcbiAgICogU2luY2UgdGhpcyBpcyBiZWluZyBydW4gaW4gYSBicm93c2VyIGFuZCB0aGUgcmVzdWx0cyBzaG91bGQgcG9wdWxhdGUgdG8gYW4gSFRNTCBwYWdlLCByZXF1aXJlIHRoZSBIVE1MLXNwZWNpZmljIEphc21pbmUgY29kZSwgaW5qZWN0aW5nIHRoZSBzYW1lIHJlZmVyZW5jZS5cbiAgICovXG4gIGphc21pbmVSZXF1aXJlLmh0bWwoamFzbWluZSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgSmFzbWluZSBlbnZpcm9ubWVudC4gVGhpcyBpcyB1c2VkIHRvIHJ1biBhbGwgc3BlY3MgaW4gYSBwcm9qZWN0LlxuICAgKi9cbiAgdmFyIGVudiA9IGphc21pbmUuZ2V0RW52KCk7XG5cbiAgLyoqXG4gICAqICMjIFRoZSBHbG9iYWwgSW50ZXJmYWNlXG4gICAqXG4gICAqIEJ1aWxkIHVwIHRoZSBmdW5jdGlvbnMgdGhhdCB3aWxsIGJlIGV4cG9zZWQgYXMgdGhlIEphc21pbmUgcHVibGljIGludGVyZmFjZS4gQSBwcm9qZWN0IGNhbiBjdXN0b21pemUsIHJlbmFtZSBvciBhbGlhcyBhbnkgb2YgdGhlc2UgZnVuY3Rpb25zIGFzIGRlc2lyZWQsIHByb3ZpZGVkIHRoZSBpbXBsZW1lbnRhdGlvbiByZW1haW5zIHVuY2hhbmdlZC5cbiAgICovXG4gIHZhciBqYXNtaW5lSW50ZXJmYWNlID0gamFzbWluZVJlcXVpcmUuaW50ZXJmYWNlKGphc21pbmUsIGVudik7XG5cbiAgLyoqXG4gICAqIEFkZCBhbGwgb2YgdGhlIEphc21pbmUgZ2xvYmFsL3B1YmxpYyBpbnRlcmZhY2UgdG8gdGhlIGdsb2JhbCBzY29wZSwgc28gYSBwcm9qZWN0IGNhbiB1c2UgdGhlIHB1YmxpYyBpbnRlcmZhY2UgZGlyZWN0bHkuIEZvciBleGFtcGxlLCBjYWxsaW5nIGBkZXNjcmliZWAgaW4gc3BlY3MgaW5zdGVhZCBvZiBgamFzbWluZS5nZXRFbnYoKS5kZXNjcmliZWAuXG4gICAqL1xuICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBqYXNtaW5lSW50ZXJmYWNlKSB7XG4gICAgZ2xvYmFsW3Byb3BlcnR5XSA9IGphc21pbmVJbnRlcmZhY2VbcHJvcGVydHldO1xuICB9XG59KSgpO1xuIiwiLypcbkNvcHlyaWdodCAoYykgMjAwOC0yMDIyIFBpdm90YWwgTGFic1xuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbmEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG53aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG5kaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbnBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xudGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG5FWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbk1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG5OT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXG5MSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OXG5PRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbldJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuKi9cbi8qKlxuIFRoaXMgZmlsZSBmaW5pc2hlcyAnYm9vdGluZycgSmFzbWluZSwgcGVyZm9ybWluZyBhbGwgb2YgdGhlIG5lY2Vzc2FyeVxuIGluaXRpYWxpemF0aW9uIGJlZm9yZSBleGVjdXRpbmcgdGhlIGxvYWRlZCBlbnZpcm9ubWVudCBhbmQgYWxsIG9mIGEgcHJvamVjdCdzXG4gc3BlY3MuIFRoaXMgZmlsZSBzaG91bGQgYmUgbG9hZGVkIGFmdGVyIGBib290MC5qc2AgYnV0IGJlZm9yZSBhbnkgcHJvamVjdFxuIHNvdXJjZSBmaWxlcyBvciBzcGVjIGZpbGVzIGFyZSBsb2FkZWQuIFRodXMgdGhpcyBmaWxlIGNhbiBhbHNvIGJlIHVzZWQgdG9cbiBjdXN0b21pemUgSmFzbWluZSBmb3IgYSBwcm9qZWN0LlxuXG4gSWYgYSBwcm9qZWN0IGlzIHVzaW5nIEphc21pbmUgdmlhIHRoZSBzdGFuZGFsb25lIGRpc3RyaWJ1dGlvbiwgdGhpcyBmaWxlIGNhblxuIGJlIGN1c3RvbWl6ZWQgZGlyZWN0bHkuIElmIHlvdSBvbmx5IHdpc2ggdG8gY29uZmlndXJlIHRoZSBKYXNtaW5lIGVudiwgeW91XG4gY2FuIGxvYWQgYW5vdGhlciBmaWxlIHRoYXQgY2FsbHMgYGphc21pbmUuZ2V0RW52KCkuY29uZmlndXJlKHsuLi59KWBcbiBhZnRlciBgYm9vdDAuanNgIGlzIGxvYWRlZCBhbmQgYmVmb3JlIHRoaXMgZmlsZSBpcyBsb2FkZWQuXG4gKi9cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgZW52ID0gamFzbWluZS5nZXRFbnYoKTtcblxuICAvKipcbiAgICogIyMgUnVubmVyIFBhcmFtZXRlcnNcbiAgICpcbiAgICogTW9yZSBicm93c2VyIHNwZWNpZmljIGNvZGUgLSB3cmFwIHRoZSBxdWVyeSBzdHJpbmcgaW4gYW4gb2JqZWN0IGFuZCB0byBhbGxvdyBmb3IgZ2V0dGluZy9zZXR0aW5nIHBhcmFtZXRlcnMgZnJvbSB0aGUgcnVubmVyIHVzZXIgaW50ZXJmYWNlLlxuICAgKi9cblxuICB2YXIgcXVlcnlTdHJpbmcgPSBuZXcgamFzbWluZS5RdWVyeVN0cmluZyh7XG4gICAgZ2V0V2luZG93TG9jYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbjtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBmaWx0ZXJTcGVjcyA9ICEhcXVlcnlTdHJpbmcuZ2V0UGFyYW0oJ3NwZWMnKTtcblxuICB2YXIgY29uZmlnID0ge1xuICAgIHN0b3BPblNwZWNGYWlsdXJlOiBxdWVyeVN0cmluZy5nZXRQYXJhbSgnc3RvcE9uU3BlY0ZhaWx1cmUnKSxcbiAgICBzdG9wU3BlY09uRXhwZWN0YXRpb25GYWlsdXJlOiBxdWVyeVN0cmluZy5nZXRQYXJhbShcbiAgICAgICdzdG9wU3BlY09uRXhwZWN0YXRpb25GYWlsdXJlJ1xuICAgICksXG4gICAgaGlkZURpc2FibGVkOiBxdWVyeVN0cmluZy5nZXRQYXJhbSgnaGlkZURpc2FibGVkJylcbiAgfTtcblxuICB2YXIgcmFuZG9tID0gcXVlcnlTdHJpbmcuZ2V0UGFyYW0oJ3JhbmRvbScpO1xuXG4gIGlmIChyYW5kb20gIT09IHVuZGVmaW5lZCAmJiByYW5kb20gIT09ICcnKSB7XG4gICAgY29uZmlnLnJhbmRvbSA9IHJhbmRvbTtcbiAgfVxuXG4gIHZhciBzZWVkID0gcXVlcnlTdHJpbmcuZ2V0UGFyYW0oJ3NlZWQnKTtcbiAgaWYgKHNlZWQpIHtcbiAgICBjb25maWcuc2VlZCA9IHNlZWQ7XG4gIH1cblxuICAvKipcbiAgICogIyMgUmVwb3J0ZXJzXG4gICAqIFRoZSBgSHRtbFJlcG9ydGVyYCBidWlsZHMgYWxsIG9mIHRoZSBIVE1MIFVJIGZvciB0aGUgcnVubmVyIHBhZ2UuIFRoaXMgcmVwb3J0ZXIgcGFpbnRzIHRoZSBkb3RzLCBzdGFycywgYW5kIHgncyBmb3Igc3BlY3MsIGFzIHdlbGwgYXMgYWxsIHNwZWMgbmFtZXMgYW5kIGFsbCBmYWlsdXJlcyAoaWYgYW55KS5cbiAgICovXG4gIHZhciBodG1sUmVwb3J0ZXIgPSBuZXcgamFzbWluZS5IdG1sUmVwb3J0ZXIoe1xuICAgIGVudjogZW52LFxuICAgIG5hdmlnYXRlV2l0aE5ld1BhcmFtOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gcXVlcnlTdHJpbmcubmF2aWdhdGVXaXRoTmV3UGFyYW0oa2V5LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBhZGRUb0V4aXN0aW5nUXVlcnlTdHJpbmc6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBxdWVyeVN0cmluZy5mdWxsU3RyaW5nV2l0aE5ld1BhcmFtKGtleSwgdmFsdWUpO1xuICAgIH0sXG4gICAgZ2V0Q29udGFpbmVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICAgIH0sXG4gICAgY3JlYXRlRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudC5hcHBseShkb2N1bWVudCwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGNyZWF0ZVRleHROb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZS5hcHBseShkb2N1bWVudCwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHRpbWVyOiBuZXcgamFzbWluZS5UaW1lcigpLFxuICAgIGZpbHRlclNwZWNzOiBmaWx0ZXJTcGVjc1xuICB9KTtcblxuICAvKipcbiAgICogVGhlIGBqc0FwaVJlcG9ydGVyYCBhbHNvIHJlY2VpdmVzIHNwZWMgcmVzdWx0cywgYW5kIGlzIHVzZWQgYnkgYW55IGVudmlyb25tZW50IHRoYXQgbmVlZHMgdG8gZXh0cmFjdCB0aGUgcmVzdWx0cyAgZnJvbSBKYXZhU2NyaXB0LlxuICAgKi9cbiAgZW52LmFkZFJlcG9ydGVyKGpzQXBpUmVwb3J0ZXIpO1xuICBlbnYuYWRkUmVwb3J0ZXIoaHRtbFJlcG9ydGVyKTtcblxuICAvKipcbiAgICogRmlsdGVyIHdoaWNoIHNwZWNzIHdpbGwgYmUgcnVuIGJ5IG1hdGNoaW5nIHRoZSBzdGFydCBvZiB0aGUgZnVsbCBuYW1lIGFnYWluc3QgdGhlIGBzcGVjYCBxdWVyeSBwYXJhbS5cbiAgICovXG4gIHZhciBzcGVjRmlsdGVyID0gbmV3IGphc21pbmUuSHRtbFNwZWNGaWx0ZXIoe1xuICAgIGZpbHRlclN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcXVlcnlTdHJpbmcuZ2V0UGFyYW0oJ3NwZWMnKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbmZpZy5zcGVjRmlsdGVyID0gZnVuY3Rpb24oc3BlYykge1xuICAgIHJldHVybiBzcGVjRmlsdGVyLm1hdGNoZXMoc3BlYy5nZXRGdWxsTmFtZSgpKTtcbiAgfTtcblxuICBlbnYuY29uZmlndXJlKGNvbmZpZyk7XG5cbiAgLyoqXG4gICAqICMjIEV4ZWN1dGlvblxuICAgKlxuICAgKiBSZXBsYWNlIHRoZSBicm93c2VyIHdpbmRvdydzIGBvbmxvYWRgLCBlbnN1cmUgaXQncyBjYWxsZWQsIGFuZCB0aGVuIHJ1biBhbGwgb2YgdGhlIGxvYWRlZCBzcGVjcy4gVGhpcyBpbmNsdWRlcyBpbml0aWFsaXppbmcgdGhlIGBIdG1sUmVwb3J0ZXJgIGluc3RhbmNlIGFuZCB0aGVuIGV4ZWN1dGluZyB0aGUgbG9hZGVkIEphc21pbmUgZW52aXJvbm1lbnQuIEFsbCBvZiB0aGlzIHdpbGwgaGFwcGVuIGFmdGVyIGFsbCBvZiB0aGUgc3BlY3MgYXJlIGxvYWRlZC5cbiAgICovXG4gIHZhciBjdXJyZW50V2luZG93T25sb2FkID0gd2luZG93Lm9ubG9hZDtcblxuICB3aW5kb3cub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGN1cnJlbnRXaW5kb3dPbmxvYWQpIHtcbiAgICAgIGN1cnJlbnRXaW5kb3dPbmxvYWQoKTtcbiAgICB9XG4gICAgaHRtbFJlcG9ydGVyLmluaXRpYWxpemUoKTtcbiAgICBlbnYuZXhlY3V0ZSgpO1xuICB9O1xufSkoKTtcbiIsIi8qXG5Db3B5cmlnaHQgKGMpIDIwMDgtMjAyMiBQaXZvdGFsIExhYnNcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG5hIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcblwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xud2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG5wZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbnRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG5NRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxuTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxuT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG5XSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG52YXIgamFzbWluZVJlcXVpcmUgPSB3aW5kb3cuamFzbWluZVJlcXVpcmUgfHwgcmVxdWlyZSgnLi9qYXNtaW5lLmpzJyk7XG5cbmphc21pbmVSZXF1aXJlLmh0bWwgPSBmdW5jdGlvbihqJCkge1xuICBqJC5SZXN1bHRzTm9kZSA9IGphc21pbmVSZXF1aXJlLlJlc3VsdHNOb2RlKCk7XG4gIGokLkh0bWxSZXBvcnRlciA9IGphc21pbmVSZXF1aXJlLkh0bWxSZXBvcnRlcihqJCk7XG4gIGokLlF1ZXJ5U3RyaW5nID0gamFzbWluZVJlcXVpcmUuUXVlcnlTdHJpbmcoKTtcbiAgaiQuSHRtbFNwZWNGaWx0ZXIgPSBqYXNtaW5lUmVxdWlyZS5IdG1sU3BlY0ZpbHRlcigpO1xufTtcblxuamFzbWluZVJlcXVpcmUuSHRtbFJlcG9ydGVyID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gUmVzdWx0c1N0YXRlQnVpbGRlcigpIHtcbiAgICB0aGlzLnRvcFJlc3VsdHMgPSBuZXcgaiQuUmVzdWx0c05vZGUoe30sICcnLCBudWxsKTtcbiAgICB0aGlzLmN1cnJlbnRQYXJlbnQgPSB0aGlzLnRvcFJlc3VsdHM7XG4gICAgdGhpcy5zcGVjc0V4ZWN1dGVkID0gMDtcbiAgICB0aGlzLmZhaWx1cmVDb3VudCA9IDA7XG4gICAgdGhpcy5wZW5kaW5nU3BlY0NvdW50ID0gMDtcbiAgfVxuXG4gIFJlc3VsdHNTdGF0ZUJ1aWxkZXIucHJvdG90eXBlLnN1aXRlU3RhcnRlZCA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIHRoaXMuY3VycmVudFBhcmVudC5hZGRDaGlsZChyZXN1bHQsICdzdWl0ZScpO1xuICAgIHRoaXMuY3VycmVudFBhcmVudCA9IHRoaXMuY3VycmVudFBhcmVudC5sYXN0KCk7XG4gIH07XG5cbiAgUmVzdWx0c1N0YXRlQnVpbGRlci5wcm90b3R5cGUuc3VpdGVEb25lID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgdGhpcy5jdXJyZW50UGFyZW50LnVwZGF0ZVJlc3VsdChyZXN1bHQpO1xuICAgIGlmICh0aGlzLmN1cnJlbnRQYXJlbnQgIT09IHRoaXMudG9wUmVzdWx0cykge1xuICAgICAgdGhpcy5jdXJyZW50UGFyZW50ID0gdGhpcy5jdXJyZW50UGFyZW50LnBhcmVudDtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgIHRoaXMuZmFpbHVyZUNvdW50Kys7XG4gICAgfVxuICB9O1xuXG4gIFJlc3VsdHNTdGF0ZUJ1aWxkZXIucHJvdG90eXBlLnNwZWNTdGFydGVkID0gZnVuY3Rpb24ocmVzdWx0KSB7fTtcblxuICBSZXN1bHRzU3RhdGVCdWlsZGVyLnByb3RvdHlwZS5zcGVjRG9uZSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIHRoaXMuY3VycmVudFBhcmVudC5hZGRDaGlsZChyZXN1bHQsICdzcGVjJyk7XG5cbiAgICBpZiAocmVzdWx0LnN0YXR1cyAhPT0gJ2V4Y2x1ZGVkJykge1xuICAgICAgdGhpcy5zcGVjc0V4ZWN1dGVkKys7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09ICdmYWlsZWQnKSB7XG4gICAgICB0aGlzLmZhaWx1cmVDb3VudCsrO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQuc3RhdHVzID09ICdwZW5kaW5nJykge1xuICAgICAgdGhpcy5wZW5kaW5nU3BlY0NvdW50Kys7XG4gICAgfVxuICB9O1xuXG4gIFJlc3VsdHNTdGF0ZUJ1aWxkZXIucHJvdG90eXBlLmphc21pbmVEb25lID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMpIHtcbiAgICAgIHRoaXMuZmFpbHVyZUNvdW50ICs9IHJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBIdG1sUmVwb3J0ZXIob3B0aW9ucykge1xuICAgIHZhciBjb25maWcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmVudiAmJiBvcHRpb25zLmVudi5jb25maWd1cmF0aW9uKCkpIHx8IHt9O1xuICAgICAgfSxcbiAgICAgIGdldENvbnRhaW5lciA9IG9wdGlvbnMuZ2V0Q29udGFpbmVyLFxuICAgICAgY3JlYXRlRWxlbWVudCA9IG9wdGlvbnMuY3JlYXRlRWxlbWVudCxcbiAgICAgIGNyZWF0ZVRleHROb2RlID0gb3B0aW9ucy5jcmVhdGVUZXh0Tm9kZSxcbiAgICAgIG5hdmlnYXRlV2l0aE5ld1BhcmFtID0gb3B0aW9ucy5uYXZpZ2F0ZVdpdGhOZXdQYXJhbSB8fCBmdW5jdGlvbigpIHt9LFxuICAgICAgYWRkVG9FeGlzdGluZ1F1ZXJ5U3RyaW5nID1cbiAgICAgICAgb3B0aW9ucy5hZGRUb0V4aXN0aW5nUXVlcnlTdHJpbmcgfHwgZGVmYXVsdFF1ZXJ5U3RyaW5nLFxuICAgICAgZmlsdGVyU3BlY3MgPSBvcHRpb25zLmZpbHRlclNwZWNzLFxuICAgICAgaHRtbFJlcG9ydGVyTWFpbixcbiAgICAgIHN5bWJvbHMsXG4gICAgICBkZXByZWNhdGlvbldhcm5pbmdzID0gW107XG5cbiAgICB0aGlzLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNsZWFyUHJpb3IoKTtcbiAgICAgIGh0bWxSZXBvcnRlck1haW4gPSBjcmVhdGVEb20oXG4gICAgICAgICdkaXYnLFxuICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmVfaHRtbC1yZXBvcnRlcicgfSxcbiAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICdkaXYnLFxuICAgICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZS1iYW5uZXInIH0sXG4gICAgICAgICAgY3JlYXRlRG9tKCdhJywge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnamFzbWluZS10aXRsZScsXG4gICAgICAgICAgICBocmVmOiAnaHR0cDovL2phc21pbmUuZ2l0aHViLmlvLycsXG4gICAgICAgICAgICB0YXJnZXQ6ICdfYmxhbmsnXG4gICAgICAgICAgfSksXG4gICAgICAgICAgY3JlYXRlRG9tKCdzcGFuJywgeyBjbGFzc05hbWU6ICdqYXNtaW5lLXZlcnNpb24nIH0sIGokLnZlcnNpb24pXG4gICAgICAgICksXG4gICAgICAgIGNyZWF0ZURvbSgndWwnLCB7IGNsYXNzTmFtZTogJ2phc21pbmUtc3ltYm9sLXN1bW1hcnknIH0pLFxuICAgICAgICBjcmVhdGVEb20oJ2RpdicsIHsgY2xhc3NOYW1lOiAnamFzbWluZS1hbGVydCcgfSksXG4gICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmUtcmVzdWx0cycgfSxcbiAgICAgICAgICBjcmVhdGVEb20oJ2RpdicsIHsgY2xhc3NOYW1lOiAnamFzbWluZS1mYWlsdXJlcycgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIGdldENvbnRhaW5lcigpLmFwcGVuZENoaWxkKGh0bWxSZXBvcnRlck1haW4pO1xuICAgIH07XG5cbiAgICB2YXIgdG90YWxTcGVjc0RlZmluZWQ7XG4gICAgdGhpcy5qYXNtaW5lU3RhcnRlZCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRvdGFsU3BlY3NEZWZpbmVkID0gb3B0aW9ucy50b3RhbFNwZWNzRGVmaW5lZCB8fCAwO1xuICAgIH07XG5cbiAgICB2YXIgc3VtbWFyeSA9IGNyZWF0ZURvbSgnZGl2JywgeyBjbGFzc05hbWU6ICdqYXNtaW5lLXN1bW1hcnknIH0pO1xuXG4gICAgdmFyIHN0YXRlQnVpbGRlciA9IG5ldyBSZXN1bHRzU3RhdGVCdWlsZGVyKCk7XG5cbiAgICB0aGlzLnN1aXRlU3RhcnRlZCA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgc3RhdGVCdWlsZGVyLnN1aXRlU3RhcnRlZChyZXN1bHQpO1xuICAgIH07XG5cbiAgICB0aGlzLnN1aXRlRG9uZSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgc3RhdGVCdWlsZGVyLnN1aXRlRG9uZShyZXN1bHQpO1xuXG4gICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgZmFpbHVyZXMucHVzaChmYWlsdXJlRG9tKHJlc3VsdCkpO1xuICAgICAgfVxuICAgICAgYWRkRGVwcmVjYXRpb25XYXJuaW5ncyhyZXN1bHQsICdzdWl0ZScpO1xuICAgIH07XG5cbiAgICB0aGlzLnNwZWNTdGFydGVkID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICBzdGF0ZUJ1aWxkZXIuc3BlY1N0YXJ0ZWQocmVzdWx0KTtcbiAgICB9O1xuXG4gICAgdmFyIGZhaWx1cmVzID0gW107XG4gICAgdGhpcy5zcGVjRG9uZSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgc3RhdGVCdWlsZGVyLnNwZWNEb25lKHJlc3VsdCk7XG5cbiAgICAgIGlmIChub0V4cGVjdGF0aW9ucyhyZXN1bHQpKSB7XG4gICAgICAgIHZhciBub1NwZWNNc2cgPSBcIlNwZWMgJ1wiICsgcmVzdWx0LmZ1bGxOYW1lICsgXCInIGhhcyBubyBleHBlY3RhdGlvbnMuXCI7XG4gICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZmFpbGVkJykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3Iobm9TcGVjTXNnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4obm9TcGVjTXNnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXN5bWJvbHMpIHtcbiAgICAgICAgc3ltYm9scyA9IGZpbmQoJy5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5Jyk7XG4gICAgICB9XG5cbiAgICAgIHN5bWJvbHMuYXBwZW5kQ2hpbGQoXG4gICAgICAgIGNyZWF0ZURvbSgnbGknLCB7XG4gICAgICAgICAgY2xhc3NOYW1lOiB0aGlzLmRpc3BsYXlTcGVjSW5Db3JyZWN0Rm9ybWF0KHJlc3VsdCksXG4gICAgICAgICAgaWQ6ICdzcGVjXycgKyByZXN1bHQuaWQsXG4gICAgICAgICAgdGl0bGU6IHJlc3VsdC5mdWxsTmFtZVxuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgIGZhaWx1cmVzLnB1c2goZmFpbHVyZURvbShyZXN1bHQpKTtcbiAgICAgIH1cblxuICAgICAgYWRkRGVwcmVjYXRpb25XYXJuaW5ncyhyZXN1bHQsICdzcGVjJyk7XG4gICAgfTtcblxuICAgIHRoaXMuZGlzcGxheVNwZWNJbkNvcnJlY3RGb3JtYXQgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIHJldHVybiBub0V4cGVjdGF0aW9ucyhyZXN1bHQpICYmIHJlc3VsdC5zdGF0dXMgPT09ICdwYXNzZWQnXG4gICAgICAgID8gJ2phc21pbmUtZW1wdHknXG4gICAgICAgIDogdGhpcy5yZXN1bHRTdGF0dXMocmVzdWx0LnN0YXR1cyk7XG4gICAgfTtcblxuICAgIHRoaXMucmVzdWx0U3RhdHVzID0gZnVuY3Rpb24oc3RhdHVzKSB7XG4gICAgICBpZiAoc3RhdHVzID09PSAnZXhjbHVkZWQnKSB7XG4gICAgICAgIHJldHVybiBjb25maWcoKS5oaWRlRGlzYWJsZWRcbiAgICAgICAgICA/ICdqYXNtaW5lLWV4Y2x1ZGVkLW5vLWRpc3BsYXknXG4gICAgICAgICAgOiAnamFzbWluZS1leGNsdWRlZCc7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ2phc21pbmUtJyArIHN0YXR1cztcbiAgICB9O1xuXG4gICAgdGhpcy5qYXNtaW5lRG9uZSA9IGZ1bmN0aW9uKGRvbmVSZXN1bHQpIHtcbiAgICAgIHN0YXRlQnVpbGRlci5qYXNtaW5lRG9uZShkb25lUmVzdWx0KTtcbiAgICAgIHZhciBiYW5uZXIgPSBmaW5kKCcuamFzbWluZS1iYW5uZXInKTtcbiAgICAgIHZhciBhbGVydCA9IGZpbmQoJy5qYXNtaW5lLWFsZXJ0Jyk7XG4gICAgICB2YXIgb3JkZXIgPSBkb25lUmVzdWx0ICYmIGRvbmVSZXN1bHQub3JkZXI7XG4gICAgICB2YXIgaTtcbiAgICAgIGFsZXJ0LmFwcGVuZENoaWxkKFxuICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZS1kdXJhdGlvbicgfSxcbiAgICAgICAgICAnZmluaXNoZWQgaW4gJyArIGRvbmVSZXN1bHQudG90YWxUaW1lIC8gMTAwMCArICdzJ1xuICAgICAgICApXG4gICAgICApO1xuXG4gICAgICBiYW5uZXIuYXBwZW5kQ2hpbGQob3B0aW9uc01lbnUoY29uZmlnKCkpKTtcblxuICAgICAgaWYgKHN0YXRlQnVpbGRlci5zcGVjc0V4ZWN1dGVkIDwgdG90YWxTcGVjc0RlZmluZWQpIHtcbiAgICAgICAgdmFyIHNraXBwZWRNZXNzYWdlID1cbiAgICAgICAgICAnUmFuICcgK1xuICAgICAgICAgIHN0YXRlQnVpbGRlci5zcGVjc0V4ZWN1dGVkICtcbiAgICAgICAgICAnIG9mICcgK1xuICAgICAgICAgIHRvdGFsU3BlY3NEZWZpbmVkICtcbiAgICAgICAgICAnIHNwZWNzIC0gcnVuIGFsbCc7XG4gICAgICAgIC8vIGluY2x1ZGUgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lIHRvIGZpeCBpc3N1ZSB3aXRoIGthcm1hLWphc21pbmUtaHRtbC1yZXBvcnRlciBpbiBhbmd1bGFyOiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc21pbmUvamFzbWluZS9pc3N1ZXMvMTkwNlxuICAgICAgICB2YXIgc2tpcHBlZExpbmsgPVxuICAgICAgICAgICh3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgfHwgJycpICtcbiAgICAgICAgICBhZGRUb0V4aXN0aW5nUXVlcnlTdHJpbmcoJ3NwZWMnLCAnJyk7XG4gICAgICAgIGFsZXJ0LmFwcGVuZENoaWxkKFxuICAgICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZS1iYXIgamFzbWluZS1za2lwcGVkJyB9LFxuICAgICAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICAgICAnYScsXG4gICAgICAgICAgICAgIHsgaHJlZjogc2tpcHBlZExpbmssIHRpdGxlOiAnUnVuIGFsbCBzcGVjcycgfSxcbiAgICAgICAgICAgICAgc2tpcHBlZE1lc3NhZ2VcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2YXIgc3RhdHVzQmFyTWVzc2FnZSA9ICcnO1xuICAgICAgdmFyIHN0YXR1c0JhckNsYXNzTmFtZSA9ICdqYXNtaW5lLW92ZXJhbGwtcmVzdWx0IGphc21pbmUtYmFyICc7XG4gICAgICB2YXIgZ2xvYmFsRmFpbHVyZXMgPSAoZG9uZVJlc3VsdCAmJiBkb25lUmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9ucykgfHwgW107XG4gICAgICB2YXIgZmFpbGVkID0gc3RhdGVCdWlsZGVyLmZhaWx1cmVDb3VudCArIGdsb2JhbEZhaWx1cmVzLmxlbmd0aCA+IDA7XG5cbiAgICAgIGlmICh0b3RhbFNwZWNzRGVmaW5lZCA+IDAgfHwgZmFpbGVkKSB7XG4gICAgICAgIHN0YXR1c0Jhck1lc3NhZ2UgKz1cbiAgICAgICAgICBwbHVyYWxpemUoJ3NwZWMnLCBzdGF0ZUJ1aWxkZXIuc3BlY3NFeGVjdXRlZCkgK1xuICAgICAgICAgICcsICcgK1xuICAgICAgICAgIHBsdXJhbGl6ZSgnZmFpbHVyZScsIHN0YXRlQnVpbGRlci5mYWlsdXJlQ291bnQpO1xuICAgICAgICBpZiAoc3RhdGVCdWlsZGVyLnBlbmRpbmdTcGVjQ291bnQpIHtcbiAgICAgICAgICBzdGF0dXNCYXJNZXNzYWdlICs9XG4gICAgICAgICAgICAnLCAnICsgcGx1cmFsaXplKCdwZW5kaW5nIHNwZWMnLCBzdGF0ZUJ1aWxkZXIucGVuZGluZ1NwZWNDb3VudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRvbmVSZXN1bHQub3ZlcmFsbFN0YXR1cyA9PT0gJ3Bhc3NlZCcpIHtcbiAgICAgICAgc3RhdHVzQmFyQ2xhc3NOYW1lICs9ICcgamFzbWluZS1wYXNzZWQgJztcbiAgICAgIH0gZWxzZSBpZiAoZG9uZVJlc3VsdC5vdmVyYWxsU3RhdHVzID09PSAnaW5jb21wbGV0ZScpIHtcbiAgICAgICAgc3RhdHVzQmFyQ2xhc3NOYW1lICs9ICcgamFzbWluZS1pbmNvbXBsZXRlICc7XG4gICAgICAgIHN0YXR1c0Jhck1lc3NhZ2UgPVxuICAgICAgICAgICdJbmNvbXBsZXRlOiAnICtcbiAgICAgICAgICBkb25lUmVzdWx0LmluY29tcGxldGVSZWFzb24gK1xuICAgICAgICAgICcsICcgK1xuICAgICAgICAgIHN0YXR1c0Jhck1lc3NhZ2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0dXNCYXJDbGFzc05hbWUgKz0gJyBqYXNtaW5lLWZhaWxlZCAnO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VlZEJhcjtcbiAgICAgIGlmIChvcmRlciAmJiBvcmRlci5yYW5kb20pIHtcbiAgICAgICAgc2VlZEJhciA9IGNyZWF0ZURvbShcbiAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lLXNlZWQtYmFyJyB9LFxuICAgICAgICAgICcsIHJhbmRvbWl6ZWQgd2l0aCBzZWVkICcsXG4gICAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aXRsZTogJ3JhbmRvbWl6ZWQgd2l0aCBzZWVkICcgKyBvcmRlci5zZWVkLFxuICAgICAgICAgICAgICBocmVmOiBzZWVkSHJlZihvcmRlci5zZWVkKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9yZGVyLnNlZWRcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGFsZXJ0LmFwcGVuZENoaWxkKFxuICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgIHsgY2xhc3NOYW1lOiBzdGF0dXNCYXJDbGFzc05hbWUgfSxcbiAgICAgICAgICBzdGF0dXNCYXJNZXNzYWdlLFxuICAgICAgICAgIHNlZWRCYXJcbiAgICAgICAgKVxuICAgICAgKTtcblxuICAgICAgdmFyIGVycm9yQmFyQ2xhc3NOYW1lID0gJ2phc21pbmUtYmFyIGphc21pbmUtZXJyb3JlZCc7XG4gICAgICB2YXIgYWZ0ZXJBbGxNZXNzYWdlUHJlZml4ID0gJ0FmdGVyQWxsICc7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBnbG9iYWxGYWlsdXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhbGVydC5hcHBlbmRDaGlsZChcbiAgICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogZXJyb3JCYXJDbGFzc05hbWUgfSxcbiAgICAgICAgICAgIGdsb2JhbEZhaWx1cmVNZXNzYWdlKGdsb2JhbEZhaWx1cmVzW2ldKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2xvYmFsRmFpbHVyZU1lc3NhZ2UoZmFpbHVyZSkge1xuICAgICAgICBpZiAoZmFpbHVyZS5nbG9iYWxFcnJvclR5cGUgPT09ICdsb2FkJykge1xuICAgICAgICAgIHZhciBwcmVmaXggPSAnRXJyb3IgZHVyaW5nIGxvYWRpbmc6ICcgKyBmYWlsdXJlLm1lc3NhZ2U7XG5cbiAgICAgICAgICBpZiAoZmFpbHVyZS5maWxlbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgcHJlZml4ICsgJyBpbiAnICsgZmFpbHVyZS5maWxlbmFtZSArICcgbGluZSAnICsgZmFpbHVyZS5saW5lbm9cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXg7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGZhaWx1cmUuZ2xvYmFsRXJyb3JUeXBlID09PSAnYWZ0ZXJBbGwnKSB7XG4gICAgICAgICAgcmV0dXJuIGFmdGVyQWxsTWVzc2FnZVByZWZpeCArIGZhaWx1cmUubWVzc2FnZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFpbHVyZS5tZXNzYWdlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFkZERlcHJlY2F0aW9uV2FybmluZ3MoZG9uZVJlc3VsdCk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBkZXByZWNhdGlvbldhcm5pbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IFtdLFxuICAgICAgICAgIGNvbnRleHQ7XG5cbiAgICAgICAgc3dpdGNoIChkZXByZWNhdGlvbldhcm5pbmdzW2ldLnJ1bm5hYmxlVHlwZSkge1xuICAgICAgICAgIGNhc2UgJ3NwZWMnOlxuICAgICAgICAgICAgY29udGV4dCA9ICcoaW4gc3BlYzogJyArIGRlcHJlY2F0aW9uV2FybmluZ3NbaV0ucnVubmFibGVOYW1lICsgJyknO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc3VpdGUnOlxuICAgICAgICAgICAgY29udGV4dCA9ICcoaW4gc3VpdGU6ICcgKyBkZXByZWNhdGlvbldhcm5pbmdzW2ldLnJ1bm5hYmxlTmFtZSArICcpJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb250ZXh0ID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBkZXByZWNhdGlvbldhcm5pbmdzW2ldLm1lc3NhZ2Uuc3BsaXQoJ1xcbicpLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2gobGluZSk7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjcmVhdGVEb20oJ2JyJykpO1xuICAgICAgICB9KTtcblxuICAgICAgICBjaGlsZHJlblswXSA9ICdERVBSRUNBVElPTjogJyArIGNoaWxkcmVuWzBdO1xuICAgICAgICBjaGlsZHJlbi5wdXNoKGNvbnRleHQpO1xuXG4gICAgICAgIGlmIChkZXByZWNhdGlvbldhcm5pbmdzW2ldLnN0YWNrKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjcmVhdGVFeHBhbmRlcihkZXByZWNhdGlvbldhcm5pbmdzW2ldLnN0YWNrKSk7XG4gICAgICAgIH1cblxuICAgICAgICBhbGVydC5hcHBlbmRDaGlsZChcbiAgICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmUtYmFyIGphc21pbmUtd2FybmluZycgfSxcbiAgICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0cyA9IGZpbmQoJy5qYXNtaW5lLXJlc3VsdHMnKTtcbiAgICAgIHJlc3VsdHMuYXBwZW5kQ2hpbGQoc3VtbWFyeSk7XG5cbiAgICAgIHN1bW1hcnlMaXN0KHN0YXRlQnVpbGRlci50b3BSZXN1bHRzLCBzdW1tYXJ5KTtcblxuICAgICAgaWYgKGZhaWx1cmVzLmxlbmd0aCkge1xuICAgICAgICBhbGVydC5hcHBlbmRDaGlsZChcbiAgICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmUtbWVudSBqYXNtaW5lLWJhciBqYXNtaW5lLXNwZWMtbGlzdCcgfSxcbiAgICAgICAgICAgIGNyZWF0ZURvbSgnc3BhbicsIHt9LCAnU3BlYyBMaXN0IHwgJyksXG4gICAgICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lLWZhaWx1cmVzLW1lbnUnLCBocmVmOiAnIycgfSxcbiAgICAgICAgICAgICAgJ0ZhaWx1cmVzJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgYWxlcnQuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lLW1lbnUgamFzbWluZS1iYXIgamFzbWluZS1mYWlsdXJlLWxpc3QnIH0sXG4gICAgICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lLXNwZWMtbGlzdC1tZW51JywgaHJlZjogJyMnIH0sXG4gICAgICAgICAgICAgICdTcGVjIExpc3QnXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgY3JlYXRlRG9tKCdzcGFuJywge30sICcgfCBGYWlsdXJlcyAnKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICBmaW5kKCcuamFzbWluZS1mYWlsdXJlcy1tZW51Jykub25jbGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNldE1lbnVNb2RlVG8oJ2phc21pbmUtZmFpbHVyZS1saXN0Jyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBmaW5kKCcuamFzbWluZS1zcGVjLWxpc3QtbWVudScpLm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZXRNZW51TW9kZVRvKCdqYXNtaW5lLXNwZWMtbGlzdCcpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICBzZXRNZW51TW9kZVRvKCdqYXNtaW5lLWZhaWx1cmUtbGlzdCcpO1xuXG4gICAgICAgIHZhciBmYWlsdXJlTm9kZSA9IGZpbmQoJy5qYXNtaW5lLWZhaWx1cmVzJyk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmYWlsdXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGZhaWx1cmVOb2RlLmFwcGVuZENoaWxkKGZhaWx1cmVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcztcblxuICAgIGZ1bmN0aW9uIGZhaWx1cmVEb20ocmVzdWx0KSB7XG4gICAgICB2YXIgZmFpbHVyZSA9IGNyZWF0ZURvbShcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZS1zcGVjLWRldGFpbCBqYXNtaW5lLWZhaWxlZCcgfSxcbiAgICAgICAgZmFpbHVyZURlc2NyaXB0aW9uKHJlc3VsdCwgc3RhdGVCdWlsZGVyLmN1cnJlbnRQYXJlbnQpLFxuICAgICAgICBjcmVhdGVEb20oJ2RpdicsIHsgY2xhc3NOYW1lOiAnamFzbWluZS1tZXNzYWdlcycgfSlcbiAgICAgICk7XG4gICAgICB2YXIgbWVzc2FnZXMgPSBmYWlsdXJlLmNoaWxkTm9kZXNbMV07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXhwZWN0YXRpb24gPSByZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zW2ldO1xuICAgICAgICBtZXNzYWdlcy5hcHBlbmRDaGlsZChcbiAgICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZS1yZXN1bHQtbWVzc2FnZScgfSxcbiAgICAgICAgICAgIGV4cGVjdGF0aW9uLm1lc3NhZ2VcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIG1lc3NhZ2VzLmFwcGVuZENoaWxkKFxuICAgICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lLXN0YWNrLXRyYWNlJyB9LFxuICAgICAgICAgICAgZXhwZWN0YXRpb24uc3RhY2tcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBtZXNzYWdlcy5hcHBlbmRDaGlsZChcbiAgICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZS1yZXN1bHQtbWVzc2FnZScgfSxcbiAgICAgICAgICAgICdTcGVjIGhhcyBubyBleHBlY3RhdGlvbnMnXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0LmRlYnVnTG9ncykge1xuICAgICAgICBtZXNzYWdlcy5hcHBlbmRDaGlsZChkZWJ1Z0xvZ1RhYmxlKHJlc3VsdC5kZWJ1Z0xvZ3MpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhaWx1cmU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVidWdMb2dUYWJsZShkZWJ1Z0xvZ3MpIHtcbiAgICAgIHZhciB0Ym9keSA9IGNyZWF0ZURvbSgndGJvZHknKTtcblxuICAgICAgZGVidWdMb2dzLmZvckVhY2goZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgdGJvZHkuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICAgJ3RyJyxcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgY3JlYXRlRG9tKCd0ZCcsIHt9LCBlbnRyeS50aW1lc3RhbXAudG9TdHJpbmcoKSksXG4gICAgICAgICAgICBjcmVhdGVEb20oJ3RkJywge30sIGVudHJ5Lm1lc3NhZ2UpXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBjcmVhdGVEb20oXG4gICAgICAgICdkaXYnLFxuICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmUtZGVidWctbG9nJyB9LFxuICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lLWRlYnVnLWxvZy1oZWFkZXInIH0sXG4gICAgICAgICAgJ0RlYnVnIGxvZ3MnXG4gICAgICAgICksXG4gICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAndGFibGUnLFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAgICd0aGVhZCcsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAgICAgJ3RyJyxcbiAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgIGNyZWF0ZURvbSgndGgnLCB7fSwgJ1RpbWUgKG1zKScpLFxuICAgICAgICAgICAgICBjcmVhdGVEb20oJ3RoJywge30sICdNZXNzYWdlJylcbiAgICAgICAgICAgIClcbiAgICAgICAgICApLFxuICAgICAgICAgIHRib2R5XG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3VtbWFyeUxpc3QocmVzdWx0c1RyZWUsIGRvbVBhcmVudCkge1xuICAgICAgdmFyIHNwZWNMaXN0Tm9kZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0c1RyZWUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJlc3VsdE5vZGUgPSByZXN1bHRzVHJlZS5jaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKGZpbHRlclNwZWNzICYmICFoYXNBY3RpdmVTcGVjKHJlc3VsdE5vZGUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdE5vZGUudHlwZSA9PT0gJ3N1aXRlJykge1xuICAgICAgICAgIHZhciBzdWl0ZUxpc3ROb2RlID0gY3JlYXRlRG9tKFxuICAgICAgICAgICAgJ3VsJyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZS1zdWl0ZScsIGlkOiAnc3VpdGUtJyArIHJlc3VsdE5vZGUucmVzdWx0LmlkIH0sXG4gICAgICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgICAgICdsaScsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6XG4gICAgICAgICAgICAgICAgICAnamFzbWluZS1zdWl0ZS1kZXRhaWwgamFzbWluZS0nICsgcmVzdWx0Tm9kZS5yZXN1bHQuc3RhdHVzXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAgICAgICAnYScsXG4gICAgICAgICAgICAgICAgeyBocmVmOiBzcGVjSHJlZihyZXN1bHROb2RlLnJlc3VsdCkgfSxcbiAgICAgICAgICAgICAgICByZXN1bHROb2RlLnJlc3VsdC5kZXNjcmlwdGlvblxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHN1bW1hcnlMaXN0KHJlc3VsdE5vZGUsIHN1aXRlTGlzdE5vZGUpO1xuICAgICAgICAgIGRvbVBhcmVudC5hcHBlbmRDaGlsZChzdWl0ZUxpc3ROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0Tm9kZS50eXBlID09PSAnc3BlYycpIHtcbiAgICAgICAgICBpZiAoZG9tUGFyZW50LmdldEF0dHJpYnV0ZSgnY2xhc3MnKSAhPT0gJ2phc21pbmUtc3BlY3MnKSB7XG4gICAgICAgICAgICBzcGVjTGlzdE5vZGUgPSBjcmVhdGVEb20oJ3VsJywgeyBjbGFzc05hbWU6ICdqYXNtaW5lLXNwZWNzJyB9KTtcbiAgICAgICAgICAgIGRvbVBhcmVudC5hcHBlbmRDaGlsZChzcGVjTGlzdE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc3BlY0Rlc2NyaXB0aW9uID0gcmVzdWx0Tm9kZS5yZXN1bHQuZGVzY3JpcHRpb247XG4gICAgICAgICAgaWYgKG5vRXhwZWN0YXRpb25zKHJlc3VsdE5vZGUucmVzdWx0KSkge1xuICAgICAgICAgICAgc3BlY0Rlc2NyaXB0aW9uID0gJ1NQRUMgSEFTIE5PIEVYUEVDVEFUSU9OUyAnICsgc3BlY0Rlc2NyaXB0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICByZXN1bHROb2RlLnJlc3VsdC5zdGF0dXMgPT09ICdwZW5kaW5nJyAmJlxuICAgICAgICAgICAgcmVzdWx0Tm9kZS5yZXN1bHQucGVuZGluZ1JlYXNvbiAhPT0gJydcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHNwZWNEZXNjcmlwdGlvbiA9XG4gICAgICAgICAgICAgIHNwZWNEZXNjcmlwdGlvbiArXG4gICAgICAgICAgICAgICcgUEVORElORyBXSVRIIE1FU1NBR0U6ICcgK1xuICAgICAgICAgICAgICByZXN1bHROb2RlLnJlc3VsdC5wZW5kaW5nUmVhc29uO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzcGVjTGlzdE5vZGUuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgICAgICdsaScsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdqYXNtaW5lLScgKyByZXN1bHROb2RlLnJlc3VsdC5zdGF0dXMsXG4gICAgICAgICAgICAgICAgaWQ6ICdzcGVjLScgKyByZXN1bHROb2RlLnJlc3VsdC5pZFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgICAgIHsgaHJlZjogc3BlY0hyZWYocmVzdWx0Tm9kZS5yZXN1bHQpIH0sXG4gICAgICAgICAgICAgICAgc3BlY0Rlc2NyaXB0aW9uXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb3B0aW9uc01lbnUoY29uZmlnKSB7XG4gICAgICB2YXIgb3B0aW9uc01lbnVEb20gPSBjcmVhdGVEb20oXG4gICAgICAgICdkaXYnLFxuICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmUtcnVuLW9wdGlvbnMnIH0sXG4gICAgICAgIGNyZWF0ZURvbSgnc3BhbicsIHsgY2xhc3NOYW1lOiAnamFzbWluZS10cmlnZ2VyJyB9LCAnT3B0aW9ucycpLFxuICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lLXBheWxvYWQnIH0sXG4gICAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmUtc3RvcC1vbi1mYWlsdXJlJyB9LFxuICAgICAgICAgICAgY3JlYXRlRG9tKCdpbnB1dCcsIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnamFzbWluZS1mYWlsLWZhc3QnLFxuICAgICAgICAgICAgICBpZDogJ2phc21pbmUtZmFpbC1mYXN0JyxcbiAgICAgICAgICAgICAgdHlwZTogJ2NoZWNrYm94J1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgICAgICdsYWJlbCcsXG4gICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZS1sYWJlbCcsIGZvcjogJ2phc21pbmUtZmFpbC1mYXN0JyB9LFxuICAgICAgICAgICAgICAnc3RvcCBleGVjdXRpb24gb24gc3BlYyBmYWlsdXJlJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgICksXG4gICAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmUtdGhyb3ctZmFpbHVyZXMnIH0sXG4gICAgICAgICAgICBjcmVhdGVEb20oJ2lucHV0Jywge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6ICdqYXNtaW5lLXRocm93JyxcbiAgICAgICAgICAgICAgaWQ6ICdqYXNtaW5lLXRocm93LWZhaWx1cmVzJyxcbiAgICAgICAgICAgICAgdHlwZTogJ2NoZWNrYm94J1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgICAgICdsYWJlbCcsXG4gICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZS1sYWJlbCcsIGZvcjogJ2phc21pbmUtdGhyb3ctZmFpbHVyZXMnIH0sXG4gICAgICAgICAgICAgICdzdG9wIHNwZWMgb24gZXhwZWN0YXRpb24gZmFpbHVyZSdcbiAgICAgICAgICAgIClcbiAgICAgICAgICApLFxuICAgICAgICAgIGNyZWF0ZURvbShcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lLXJhbmRvbS1vcmRlcicgfSxcbiAgICAgICAgICAgIGNyZWF0ZURvbSgnaW5wdXQnLCB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2phc21pbmUtcmFuZG9tJyxcbiAgICAgICAgICAgICAgaWQ6ICdqYXNtaW5lLXJhbmRvbS1vcmRlcicsXG4gICAgICAgICAgICAgIHR5cGU6ICdjaGVja2JveCdcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICAgICAnbGFiZWwnLFxuICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2phc21pbmUtbGFiZWwnLCBmb3I6ICdqYXNtaW5lLXJhbmRvbS1vcmRlcicgfSxcbiAgICAgICAgICAgICAgJ3J1biB0ZXN0cyBpbiByYW5kb20gb3JkZXInXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSxcbiAgICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZS1oaWRlLWRpc2FibGVkJyB9LFxuICAgICAgICAgICAgY3JlYXRlRG9tKCdpbnB1dCcsIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnamFzbWluZS1kaXNhYmxlZCcsXG4gICAgICAgICAgICAgIGlkOiAnamFzbWluZS1oaWRlLWRpc2FibGVkJyxcbiAgICAgICAgICAgICAgdHlwZTogJ2NoZWNrYm94J1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgICAgICdsYWJlbCcsXG4gICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZS1sYWJlbCcsIGZvcjogJ2phc21pbmUtaGlkZS1kaXNhYmxlZCcgfSxcbiAgICAgICAgICAgICAgJ2hpZGUgZGlzYWJsZWQgdGVzdHMnXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApO1xuXG4gICAgICB2YXIgZmFpbEZhc3RDaGVja2JveCA9IG9wdGlvbnNNZW51RG9tLnF1ZXJ5U2VsZWN0b3IoJyNqYXNtaW5lLWZhaWwtZmFzdCcpO1xuICAgICAgZmFpbEZhc3RDaGVja2JveC5jaGVja2VkID0gY29uZmlnLnN0b3BPblNwZWNGYWlsdXJlO1xuICAgICAgZmFpbEZhc3RDaGVja2JveC5vbmNsaWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG5hdmlnYXRlV2l0aE5ld1BhcmFtKCdzdG9wT25TcGVjRmFpbHVyZScsICFjb25maWcuc3RvcE9uU3BlY0ZhaWx1cmUpO1xuICAgICAgfTtcblxuICAgICAgdmFyIHRocm93Q2hlY2tib3ggPSBvcHRpb25zTWVudURvbS5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAnI2phc21pbmUtdGhyb3ctZmFpbHVyZXMnXG4gICAgICApO1xuICAgICAgdGhyb3dDaGVja2JveC5jaGVja2VkID0gY29uZmlnLnN0b3BTcGVjT25FeHBlY3RhdGlvbkZhaWx1cmU7XG4gICAgICB0aHJvd0NoZWNrYm94Lm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbmF2aWdhdGVXaXRoTmV3UGFyYW0oXG4gICAgICAgICAgJ3N0b3BTcGVjT25FeHBlY3RhdGlvbkZhaWx1cmUnLFxuICAgICAgICAgICFjb25maWcuc3RvcFNwZWNPbkV4cGVjdGF0aW9uRmFpbHVyZVxuICAgICAgICApO1xuICAgICAgfTtcblxuICAgICAgdmFyIHJhbmRvbUNoZWNrYm94ID0gb3B0aW9uc01lbnVEb20ucXVlcnlTZWxlY3RvcihcbiAgICAgICAgJyNqYXNtaW5lLXJhbmRvbS1vcmRlcidcbiAgICAgICk7XG4gICAgICByYW5kb21DaGVja2JveC5jaGVja2VkID0gY29uZmlnLnJhbmRvbTtcbiAgICAgIHJhbmRvbUNoZWNrYm94Lm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbmF2aWdhdGVXaXRoTmV3UGFyYW0oJ3JhbmRvbScsICFjb25maWcucmFuZG9tKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBoaWRlRGlzYWJsZWQgPSBvcHRpb25zTWVudURvbS5xdWVyeVNlbGVjdG9yKCcjamFzbWluZS1oaWRlLWRpc2FibGVkJyk7XG4gICAgICBoaWRlRGlzYWJsZWQuY2hlY2tlZCA9IGNvbmZpZy5oaWRlRGlzYWJsZWQ7XG4gICAgICBoaWRlRGlzYWJsZWQub25jbGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBuYXZpZ2F0ZVdpdGhOZXdQYXJhbSgnaGlkZURpc2FibGVkJywgIWNvbmZpZy5oaWRlRGlzYWJsZWQpO1xuICAgICAgfTtcblxuICAgICAgdmFyIG9wdGlvbnNUcmlnZ2VyID0gb3B0aW9uc01lbnVEb20ucXVlcnlTZWxlY3RvcignLmphc21pbmUtdHJpZ2dlcicpLFxuICAgICAgICBvcHRpb25zUGF5bG9hZCA9IG9wdGlvbnNNZW51RG9tLnF1ZXJ5U2VsZWN0b3IoJy5qYXNtaW5lLXBheWxvYWQnKSxcbiAgICAgICAgaXNPcGVuID0gL1xcYmphc21pbmUtb3BlblxcYi87XG5cbiAgICAgIG9wdGlvbnNUcmlnZ2VyLm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGlzT3Blbi50ZXN0KG9wdGlvbnNQYXlsb2FkLmNsYXNzTmFtZSkpIHtcbiAgICAgICAgICBvcHRpb25zUGF5bG9hZC5jbGFzc05hbWUgPSBvcHRpb25zUGF5bG9hZC5jbGFzc05hbWUucmVwbGFjZShcbiAgICAgICAgICAgIGlzT3BlbixcbiAgICAgICAgICAgICcnXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zUGF5bG9hZC5jbGFzc05hbWUgKz0gJyBqYXNtaW5lLW9wZW4nO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gb3B0aW9uc01lbnVEb207XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmFpbHVyZURlc2NyaXB0aW9uKHJlc3VsdCwgc3VpdGUpIHtcbiAgICAgIHZhciB3cmFwcGVyID0gY3JlYXRlRG9tKFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgeyBjbGFzc05hbWU6ICdqYXNtaW5lLWRlc2NyaXB0aW9uJyB9LFxuICAgICAgICBjcmVhdGVEb20oXG4gICAgICAgICAgJ2EnLFxuICAgICAgICAgIHsgdGl0bGU6IHJlc3VsdC5kZXNjcmlwdGlvbiwgaHJlZjogc3BlY0hyZWYocmVzdWx0KSB9LFxuICAgICAgICAgIHJlc3VsdC5kZXNjcmlwdGlvblxuICAgICAgICApXG4gICAgICApO1xuICAgICAgdmFyIHN1aXRlTGluaztcblxuICAgICAgd2hpbGUgKHN1aXRlICYmIHN1aXRlLnBhcmVudCkge1xuICAgICAgICB3cmFwcGVyLmluc2VydEJlZm9yZShjcmVhdGVUZXh0Tm9kZSgnID4gJyksIHdyYXBwZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgIHN1aXRlTGluayA9IGNyZWF0ZURvbShcbiAgICAgICAgICAnYScsXG4gICAgICAgICAgeyBocmVmOiBzdWl0ZUhyZWYoc3VpdGUpIH0sXG4gICAgICAgICAgc3VpdGUucmVzdWx0LmRlc2NyaXB0aW9uXG4gICAgICAgICk7XG4gICAgICAgIHdyYXBwZXIuaW5zZXJ0QmVmb3JlKHN1aXRlTGluaywgd3JhcHBlci5maXJzdENoaWxkKTtcblxuICAgICAgICBzdWl0ZSA9IHN1aXRlLnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3VpdGVIcmVmKHN1aXRlKSB7XG4gICAgICB2YXIgZWxzID0gW107XG5cbiAgICAgIHdoaWxlIChzdWl0ZSAmJiBzdWl0ZS5wYXJlbnQpIHtcbiAgICAgICAgZWxzLnVuc2hpZnQoc3VpdGUucmVzdWx0LmRlc2NyaXB0aW9uKTtcbiAgICAgICAgc3VpdGUgPSBzdWl0ZS5wYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIGluY2x1ZGUgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lIHRvIGZpeCBpc3N1ZSB3aXRoIGthcm1hLWphc21pbmUtaHRtbC1yZXBvcnRlciBpbiBhbmd1bGFyOiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc21pbmUvamFzbWluZS9pc3N1ZXMvMTkwNlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSB8fCAnJykgK1xuICAgICAgICBhZGRUb0V4aXN0aW5nUXVlcnlTdHJpbmcoJ3NwZWMnLCBlbHMuam9pbignICcpKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGREZXByZWNhdGlvbldhcm5pbmdzKHJlc3VsdCwgcnVubmFibGVUeXBlKSB7XG4gICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5kZXByZWNhdGlvbldhcm5pbmdzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0LmRlcHJlY2F0aW9uV2FybmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgd2FybmluZyA9IHJlc3VsdC5kZXByZWNhdGlvbldhcm5pbmdzW2ldLm1lc3NhZ2U7XG4gICAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IHdhcm5pbmcsXG4gICAgICAgICAgICBzdGFjazogcmVzdWx0LmRlcHJlY2F0aW9uV2FybmluZ3NbaV0uc3RhY2ssXG4gICAgICAgICAgICBydW5uYWJsZU5hbWU6IHJlc3VsdC5mdWxsTmFtZSxcbiAgICAgICAgICAgIHJ1bm5hYmxlVHlwZTogcnVubmFibGVUeXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVFeHBhbmRlcihzdGFja1RyYWNlKSB7XG4gICAgICB2YXIgZXhwYW5kTGluayA9IGNyZWF0ZURvbSgnYScsIHsgaHJlZjogJyMnIH0sICdTaG93IHN0YWNrIHRyYWNlJyk7XG4gICAgICB2YXIgcm9vdCA9IGNyZWF0ZURvbShcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZS1leHBhbmRlcicgfSxcbiAgICAgICAgZXhwYW5kTGluayxcbiAgICAgICAgY3JlYXRlRG9tKFxuICAgICAgICAgICdkaXYnLFxuICAgICAgICAgIHsgY2xhc3NOYW1lOiAnamFzbWluZS1leHBhbmRlci1jb250ZW50cyBqYXNtaW5lLXN0YWNrLXRyYWNlJyB9LFxuICAgICAgICAgIHN0YWNrVHJhY2VcbiAgICAgICAgKVxuICAgICAgKTtcblxuICAgICAgZXhwYW5kTGluay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmIChyb290LmNsYXNzTGlzdC5jb250YWlucygnamFzbWluZS1leHBhbmRlZCcpKSB7XG4gICAgICAgICAgcm9vdC5jbGFzc0xpc3QucmVtb3ZlKCdqYXNtaW5lLWV4cGFuZGVkJyk7XG4gICAgICAgICAgZXhwYW5kTGluay50ZXh0Q29udGVudCA9ICdTaG93IHN0YWNrIHRyYWNlJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb290LmNsYXNzTGlzdC5hZGQoJ2phc21pbmUtZXhwYW5kZWQnKTtcbiAgICAgICAgICBleHBhbmRMaW5rLnRleHRDb250ZW50ID0gJ0hpZGUgc3RhY2sgdHJhY2UnO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmluZChzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIGdldENvbnRhaW5lcigpLnF1ZXJ5U2VsZWN0b3IoJy5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgJyArIHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhclByaW9yKCkge1xuICAgICAgLy8gcmV0dXJuIHRoZSByZXBvcnRlclxuICAgICAgdmFyIG9sZFJlcG9ydGVyID0gZmluZCgnJyk7XG5cbiAgICAgIGlmIChvbGRSZXBvcnRlcikge1xuICAgICAgICBnZXRDb250YWluZXIoKS5yZW1vdmVDaGlsZChvbGRSZXBvcnRlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRG9tKHR5cGUsIGF0dHJzLCBjaGlsZHJlbkFycmF5T3JWYXJBcmdzKSB7XG4gICAgICB2YXIgZWwgPSBjcmVhdGVFbGVtZW50KHR5cGUpLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgaTtcblxuICAgICAgaWYgKGokLmlzQXJyYXlfKGNoaWxkcmVuQXJyYXlPclZhckFyZ3MpKSB7XG4gICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW5BcnJheU9yVmFyQXJncztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkcmVuID0gW107XG5cbiAgICAgICAgZm9yIChpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBlbC5hcHBlbmRDaGlsZChjcmVhdGVUZXh0Tm9kZShjaGlsZCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBhdHRyIGluIGF0dHJzKSB7XG4gICAgICAgIGlmIChhdHRyID09ICdjbGFzc05hbWUnKSB7XG4gICAgICAgICAgZWxbYXR0cl0gPSBhdHRyc1thdHRyXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgYXR0cnNbYXR0cl0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwbHVyYWxpemUoc2luZ3VsYXIsIGNvdW50KSB7XG4gICAgICB2YXIgd29yZCA9IGNvdW50ID09IDEgPyBzaW5ndWxhciA6IHNpbmd1bGFyICsgJ3MnO1xuXG4gICAgICByZXR1cm4gJycgKyBjb3VudCArICcgJyArIHdvcmQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3BlY0hyZWYocmVzdWx0KSB7XG4gICAgICAvLyBpbmNsdWRlIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSB0byBmaXggaXNzdWUgd2l0aCBrYXJtYS1qYXNtaW5lLWh0bWwtcmVwb3J0ZXIgaW4gYW5ndWxhcjogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNtaW5lL2phc21pbmUvaXNzdWVzLzE5MDZcbiAgICAgIHJldHVybiAoXG4gICAgICAgICh3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgfHwgJycpICtcbiAgICAgICAgYWRkVG9FeGlzdGluZ1F1ZXJ5U3RyaW5nKCdzcGVjJywgcmVzdWx0LmZ1bGxOYW1lKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZWVkSHJlZihzZWVkKSB7XG4gICAgICAvLyBpbmNsdWRlIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSB0byBmaXggaXNzdWUgd2l0aCBrYXJtYS1qYXNtaW5lLWh0bWwtcmVwb3J0ZXIgaW4gYW5ndWxhcjogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNtaW5lL2phc21pbmUvaXNzdWVzLzE5MDZcbiAgICAgIHJldHVybiAoXG4gICAgICAgICh3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgfHwgJycpICtcbiAgICAgICAgYWRkVG9FeGlzdGluZ1F1ZXJ5U3RyaW5nKCdzZWVkJywgc2VlZClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdFF1ZXJ5U3RyaW5nKGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiAnPycgKyBrZXkgKyAnPScgKyB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRNZW51TW9kZVRvKG1vZGUpIHtcbiAgICAgIGh0bWxSZXBvcnRlck1haW4uc2V0QXR0cmlidXRlKCdjbGFzcycsICdqYXNtaW5lX2h0bWwtcmVwb3J0ZXIgJyArIG1vZGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vRXhwZWN0YXRpb25zKHJlc3VsdCkge1xuICAgICAgdmFyIGFsbEV4cGVjdGF0aW9ucyA9XG4gICAgICAgIHJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMubGVuZ3RoICsgcmVzdWx0LnBhc3NlZEV4cGVjdGF0aW9ucy5sZW5ndGg7XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIGFsbEV4cGVjdGF0aW9ucyA9PT0gMCAmJlxuICAgICAgICAocmVzdWx0LnN0YXR1cyA9PT0gJ3Bhc3NlZCcgfHwgcmVzdWx0LnN0YXR1cyA9PT0gJ2ZhaWxlZCcpXG4gICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0FjdGl2ZVNwZWMocmVzdWx0Tm9kZSkge1xuICAgICAgaWYgKHJlc3VsdE5vZGUudHlwZSA9PSAnc3BlYycgJiYgcmVzdWx0Tm9kZS5yZXN1bHQuc3RhdHVzICE9ICdleGNsdWRlZCcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHROb2RlLnR5cGUgPT0gJ3N1aXRlJykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHJlc3VsdE5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgaWYgKGhhc0FjdGl2ZVNwZWMocmVzdWx0Tm9kZS5jaGlsZHJlbltpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBIdG1sUmVwb3J0ZXI7XG59O1xuXG5qYXNtaW5lUmVxdWlyZS5IdG1sU3BlY0ZpbHRlciA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBIdG1sU3BlY0ZpbHRlcihvcHRpb25zKSB7XG4gICAgdmFyIGZpbHRlclN0cmluZyA9XG4gICAgICBvcHRpb25zICYmXG4gICAgICBvcHRpb25zLmZpbHRlclN0cmluZygpICYmXG4gICAgICBvcHRpb25zLmZpbHRlclN0cmluZygpLnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJyk7XG4gICAgdmFyIGZpbHRlclBhdHRlcm4gPSBuZXcgUmVnRXhwKGZpbHRlclN0cmluZyk7XG5cbiAgICB0aGlzLm1hdGNoZXMgPSBmdW5jdGlvbihzcGVjTmFtZSkge1xuICAgICAgcmV0dXJuIGZpbHRlclBhdHRlcm4udGVzdChzcGVjTmFtZSk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBIdG1sU3BlY0ZpbHRlcjtcbn07XG5cbmphc21pbmVSZXF1aXJlLlJlc3VsdHNOb2RlID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFJlc3VsdHNOb2RlKHJlc3VsdCwgdHlwZSwgcGFyZW50KSB7XG4gICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcblxuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcblxuICAgIHRoaXMuYWRkQ2hpbGQgPSBmdW5jdGlvbihyZXN1bHQsIHR5cGUpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChuZXcgUmVzdWx0c05vZGUocmVzdWx0LCB0eXBlLCB0aGlzKSk7XG4gICAgfTtcblxuICAgIHRoaXMubGFzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICB9O1xuXG4gICAgdGhpcy51cGRhdGVSZXN1bHQgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gUmVzdWx0c05vZGU7XG59O1xuXG5qYXNtaW5lUmVxdWlyZS5RdWVyeVN0cmluZyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBRdWVyeVN0cmluZyhvcHRpb25zKSB7XG4gICAgdGhpcy5uYXZpZ2F0ZVdpdGhOZXdQYXJhbSA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIG9wdGlvbnMuZ2V0V2luZG93TG9jYXRpb24oKS5zZWFyY2ggPSB0aGlzLmZ1bGxTdHJpbmdXaXRoTmV3UGFyYW0oXG4gICAgICAgIGtleSxcbiAgICAgICAgdmFsdWVcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHRoaXMuZnVsbFN0cmluZ1dpdGhOZXdQYXJhbSA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBwYXJhbU1hcCA9IHF1ZXJ5U3RyaW5nVG9QYXJhbU1hcCgpO1xuICAgICAgcGFyYW1NYXBba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRvUXVlcnlTdHJpbmcocGFyYW1NYXApO1xuICAgIH07XG5cbiAgICB0aGlzLmdldFBhcmFtID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gcXVlcnlTdHJpbmdUb1BhcmFtTWFwKClba2V5XTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgICBmdW5jdGlvbiB0b1F1ZXJ5U3RyaW5nKHBhcmFtTWFwKSB7XG4gICAgICB2YXIgcVN0clBhaXJzID0gW107XG4gICAgICBmb3IgKHZhciBwcm9wIGluIHBhcmFtTWFwKSB7XG4gICAgICAgIHFTdHJQYWlycy5wdXNoKFxuICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChwcm9wKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbU1hcFtwcm9wXSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnPycgKyBxU3RyUGFpcnMuam9pbignJicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHF1ZXJ5U3RyaW5nVG9QYXJhbU1hcCgpIHtcbiAgICAgIHZhciBwYXJhbVN0ciA9IG9wdGlvbnMuZ2V0V2luZG93TG9jYXRpb24oKS5zZWFyY2guc3Vic3RyaW5nKDEpLFxuICAgICAgICBwYXJhbXMgPSBbXSxcbiAgICAgICAgcGFyYW1NYXAgPSB7fTtcblxuICAgICAgaWYgKHBhcmFtU3RyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1TdHIuc3BsaXQoJyYnKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcCA9IHBhcmFtc1tpXS5zcGxpdCgnPScpO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudChwWzFdKTtcbiAgICAgICAgICBpZiAodmFsdWUgPT09ICd0cnVlJyB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJykge1xuICAgICAgICAgICAgdmFsdWUgPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyYW1NYXBbZGVjb2RlVVJJQ29tcG9uZW50KHBbMF0pXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJhbU1hcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gUXVlcnlTdHJpbmc7XG59O1xuIiwiLypcbkNvcHlyaWdodCAoYykgMjAwOC0yMDIyIFBpdm90YWwgTGFic1xuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbmEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG53aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG5kaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbnBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xudGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG5FWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbk1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG5OT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXG5MSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OXG5PRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbldJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xudmFyIGdldEphc21pbmVSZXF1aXJlT2JqID0gKGZ1bmN0aW9uKGphc21pbmVHbG9iYWwpIHtcbiAgdmFyIGphc21pbmVSZXF1aXJlO1xuXG4gIGlmIChcbiAgICB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIG1vZHVsZS5leHBvcnRzICYmXG4gICAgdHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnXG4gICkge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgamFzbWluZUdsb2JhbCA9IGdsb2JhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgamFzbWluZUdsb2JhbCA9IHt9O1xuICAgIH1cbiAgICBqYXNtaW5lUmVxdWlyZSA9IGV4cG9ydHM7XG4gIH0gZWxzZSB7XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiB3aW5kb3cudG9TdHJpbmcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIHdpbmRvdy50b1N0cmluZygpID09PSAnW29iamVjdCBHanNHbG9iYWxdJ1xuICAgICkge1xuICAgICAgamFzbWluZUdsb2JhbCA9IHdpbmRvdztcbiAgICB9XG4gICAgamFzbWluZVJlcXVpcmUgPSBqYXNtaW5lR2xvYmFsLmphc21pbmVSZXF1aXJlID0ge307XG4gIH1cblxuICBmdW5jdGlvbiBnZXRKYXNtaW5lUmVxdWlyZSgpIHtcbiAgICByZXR1cm4gamFzbWluZVJlcXVpcmU7XG4gIH1cblxuICBnZXRKYXNtaW5lUmVxdWlyZSgpLmNvcmUgPSBmdW5jdGlvbihqUmVxdWlyZSkge1xuICAgIHZhciBqJCA9IHt9O1xuXG4gICAgalJlcXVpcmUuYmFzZShqJCwgamFzbWluZUdsb2JhbCk7XG4gICAgaiQudXRpbCA9IGpSZXF1aXJlLnV0aWwoaiQpO1xuICAgIGokLmVycm9ycyA9IGpSZXF1aXJlLmVycm9ycygpO1xuICAgIGokLmZvcm1hdEVycm9yTXNnID0galJlcXVpcmUuZm9ybWF0RXJyb3JNc2coKTtcbiAgICBqJC5BbnkgPSBqUmVxdWlyZS5BbnkoaiQpO1xuICAgIGokLkFueXRoaW5nID0galJlcXVpcmUuQW55dGhpbmcoaiQpO1xuICAgIGokLkNhbGxUcmFja2VyID0galJlcXVpcmUuQ2FsbFRyYWNrZXIoaiQpO1xuICAgIGokLk1vY2tEYXRlID0galJlcXVpcmUuTW9ja0RhdGUoaiQpO1xuICAgIGokLmdldENsZWFyU3RhY2sgPSBqUmVxdWlyZS5jbGVhclN0YWNrKGokKTtcbiAgICBqJC5DbG9jayA9IGpSZXF1aXJlLkNsb2NrKCk7XG4gICAgaiQuRGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyID0galJlcXVpcmUuRGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyKGokKTtcbiAgICBqJC5EZXByZWNhdG9yID0galJlcXVpcmUuRGVwcmVjYXRvcihqJCk7XG4gICAgaiQuRW52ID0galJlcXVpcmUuRW52KGokKTtcbiAgICBqJC5TdGFja1RyYWNlID0galJlcXVpcmUuU3RhY2tUcmFjZShqJCk7XG4gICAgaiQuRXhjZXB0aW9uRm9ybWF0dGVyID0galJlcXVpcmUuRXhjZXB0aW9uRm9ybWF0dGVyKGokKTtcbiAgICBqJC5FeHBlY3RhdGlvbkZpbHRlckNoYWluID0galJlcXVpcmUuRXhwZWN0YXRpb25GaWx0ZXJDaGFpbigpO1xuICAgIGokLkV4cGVjdG9yID0galJlcXVpcmUuRXhwZWN0b3IoaiQpO1xuICAgIGokLkV4cGVjdGF0aW9uID0galJlcXVpcmUuRXhwZWN0YXRpb24oaiQpO1xuICAgIGokLmJ1aWxkRXhwZWN0YXRpb25SZXN1bHQgPSBqUmVxdWlyZS5idWlsZEV4cGVjdGF0aW9uUmVzdWx0KGokKTtcbiAgICBqJC5Kc0FwaVJlcG9ydGVyID0galJlcXVpcmUuSnNBcGlSZXBvcnRlcihqJCk7XG4gICAgaiQubWFrZVByZXR0eVByaW50ZXIgPSBqUmVxdWlyZS5tYWtlUHJldHR5UHJpbnRlcihqJCk7XG4gICAgaiQuYmFzaWNQcmV0dHlQcmludGVyXyA9IGokLm1ha2VQcmV0dHlQcmludGVyKCk7XG4gICAgaiQuTWF0Y2hlcnNVdGlsID0galJlcXVpcmUuTWF0Y2hlcnNVdGlsKGokKTtcbiAgICBqJC5PYmplY3RDb250YWluaW5nID0galJlcXVpcmUuT2JqZWN0Q29udGFpbmluZyhqJCk7XG4gICAgaiQuQXJyYXlDb250YWluaW5nID0galJlcXVpcmUuQXJyYXlDb250YWluaW5nKGokKTtcbiAgICBqJC5BcnJheVdpdGhFeGFjdENvbnRlbnRzID0galJlcXVpcmUuQXJyYXlXaXRoRXhhY3RDb250ZW50cyhqJCk7XG4gICAgaiQuTWFwQ29udGFpbmluZyA9IGpSZXF1aXJlLk1hcENvbnRhaW5pbmcoaiQpO1xuICAgIGokLlNldENvbnRhaW5pbmcgPSBqUmVxdWlyZS5TZXRDb250YWluaW5nKGokKTtcbiAgICBqJC5RdWV1ZVJ1bm5lciA9IGpSZXF1aXJlLlF1ZXVlUnVubmVyKGokKTtcbiAgICBqJC5OZXZlclNraXBQb2xpY3kgPSBqUmVxdWlyZS5OZXZlclNraXBQb2xpY3koaiQpO1xuICAgIGokLlNraXBBZnRlckJlZm9yZUFsbEVycm9yUG9saWN5ID0galJlcXVpcmUuU2tpcEFmdGVyQmVmb3JlQWxsRXJyb3JQb2xpY3koXG4gICAgICBqJFxuICAgICk7XG4gICAgaiQuQ29tcGxldGVPbkZpcnN0RXJyb3JTa2lwUG9saWN5ID0galJlcXVpcmUuQ29tcGxldGVPbkZpcnN0RXJyb3JTa2lwUG9saWN5KFxuICAgICAgaiRcbiAgICApO1xuICAgIGokLlJlcG9ydERpc3BhdGNoZXIgPSBqUmVxdWlyZS5SZXBvcnREaXNwYXRjaGVyKGokKTtcbiAgICBqJC5TcGVjID0galJlcXVpcmUuU3BlYyhqJCk7XG4gICAgaiQuU3B5ID0galJlcXVpcmUuU3B5KGokKTtcbiAgICBqJC5TcHlGYWN0b3J5ID0galJlcXVpcmUuU3B5RmFjdG9yeShqJCk7XG4gICAgaiQuU3B5UmVnaXN0cnkgPSBqUmVxdWlyZS5TcHlSZWdpc3RyeShqJCk7XG4gICAgaiQuU3B5U3RyYXRlZ3kgPSBqUmVxdWlyZS5TcHlTdHJhdGVneShqJCk7XG4gICAgaiQuU3RyaW5nTWF0Y2hpbmcgPSBqUmVxdWlyZS5TdHJpbmdNYXRjaGluZyhqJCk7XG4gICAgaiQuU3RyaW5nQ29udGFpbmluZyA9IGpSZXF1aXJlLlN0cmluZ0NvbnRhaW5pbmcoaiQpO1xuICAgIGokLlVzZXJDb250ZXh0ID0galJlcXVpcmUuVXNlckNvbnRleHQoaiQpO1xuICAgIGokLlN1aXRlID0galJlcXVpcmUuU3VpdGUoaiQpO1xuICAgIGokLlRpbWVyID0galJlcXVpcmUuVGltZXIoKTtcbiAgICBqJC5UcmVlUHJvY2Vzc29yID0galJlcXVpcmUuVHJlZVByb2Nlc3NvcigpO1xuICAgIGokLnZlcnNpb24gPSBqUmVxdWlyZS52ZXJzaW9uKCk7XG4gICAgaiQuT3JkZXIgPSBqUmVxdWlyZS5PcmRlcigpO1xuICAgIGokLkRpZmZCdWlsZGVyID0galJlcXVpcmUuRGlmZkJ1aWxkZXIoaiQpO1xuICAgIGokLk51bGxEaWZmQnVpbGRlciA9IGpSZXF1aXJlLk51bGxEaWZmQnVpbGRlcihqJCk7XG4gICAgaiQuT2JqZWN0UGF0aCA9IGpSZXF1aXJlLk9iamVjdFBhdGgoaiQpO1xuICAgIGokLk1pc21hdGNoVHJlZSA9IGpSZXF1aXJlLk1pc21hdGNoVHJlZShqJCk7XG4gICAgaiQuR2xvYmFsRXJyb3JzID0galJlcXVpcmUuR2xvYmFsRXJyb3JzKGokKTtcblxuICAgIGokLlRydXRoeSA9IGpSZXF1aXJlLlRydXRoeShqJCk7XG4gICAgaiQuRmFsc3kgPSBqUmVxdWlyZS5GYWxzeShqJCk7XG4gICAgaiQuRW1wdHkgPSBqUmVxdWlyZS5FbXB0eShqJCk7XG4gICAgaiQuTm90RW1wdHkgPSBqUmVxdWlyZS5Ob3RFbXB0eShqJCk7XG5cbiAgICBqJC5tYXRjaGVycyA9IGpSZXF1aXJlLnJlcXVpcmVNYXRjaGVycyhqUmVxdWlyZSwgaiQpO1xuICAgIGokLmFzeW5jTWF0Y2hlcnMgPSBqUmVxdWlyZS5yZXF1aXJlQXN5bmNNYXRjaGVycyhqUmVxdWlyZSwgaiQpO1xuXG4gICAgcmV0dXJuIGokO1xuICB9O1xuXG4gIHJldHVybiBnZXRKYXNtaW5lUmVxdWlyZTtcbn0pKHRoaXMpO1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnJlcXVpcmVNYXRjaGVycyA9IGZ1bmN0aW9uKGpSZXF1aXJlLCBqJCkge1xuICB2YXIgYXZhaWxhYmxlTWF0Y2hlcnMgPSBbXG4gICAgICAnbm90aGluZycsXG4gICAgICAndG9CZScsXG4gICAgICAndG9CZUNsb3NlVG8nLFxuICAgICAgJ3RvQmVEZWZpbmVkJyxcbiAgICAgICd0b0JlSW5zdGFuY2VPZicsXG4gICAgICAndG9CZUZhbHNlJyxcbiAgICAgICd0b0JlRmFsc3knLFxuICAgICAgJ3RvQmVHcmVhdGVyVGhhbicsXG4gICAgICAndG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCcsXG4gICAgICAndG9CZUxlc3NUaGFuJyxcbiAgICAgICd0b0JlTGVzc1RoYW5PckVxdWFsJyxcbiAgICAgICd0b0JlTmFOJyxcbiAgICAgICd0b0JlTmVnYXRpdmVJbmZpbml0eScsXG4gICAgICAndG9CZU51bGwnLFxuICAgICAgJ3RvQmVQb3NpdGl2ZUluZmluaXR5JyxcbiAgICAgICd0b0JlVHJ1ZScsXG4gICAgICAndG9CZVRydXRoeScsXG4gICAgICAndG9CZVVuZGVmaW5lZCcsXG4gICAgICAndG9Db250YWluJyxcbiAgICAgICd0b0VxdWFsJyxcbiAgICAgICd0b0hhdmVTaXplJyxcbiAgICAgICd0b0hhdmVCZWVuQ2FsbGVkJyxcbiAgICAgICd0b0hhdmVCZWVuQ2FsbGVkQmVmb3JlJyxcbiAgICAgICd0b0hhdmVCZWVuQ2FsbGVkT25jZVdpdGgnLFxuICAgICAgJ3RvSGF2ZUJlZW5DYWxsZWRUaW1lcycsXG4gICAgICAndG9IYXZlQmVlbkNhbGxlZFdpdGgnLFxuICAgICAgJ3RvSGF2ZUNsYXNzJyxcbiAgICAgICd0b01hdGNoJyxcbiAgICAgICd0b1Rocm93JyxcbiAgICAgICd0b1Rocm93RXJyb3InLFxuICAgICAgJ3RvVGhyb3dNYXRjaGluZydcbiAgICBdLFxuICAgIG1hdGNoZXJzID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdmFpbGFibGVNYXRjaGVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuYW1lID0gYXZhaWxhYmxlTWF0Y2hlcnNbaV07XG4gICAgbWF0Y2hlcnNbbmFtZV0gPSBqUmVxdWlyZVtuYW1lXShqJCk7XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcnM7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLmJhc2UgPSBmdW5jdGlvbihqJCwgamFzbWluZUdsb2JhbCkge1xuICBqJC51bmltcGxlbWVudGVkTWV0aG9kXyA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndW5pbXBsZW1lbnRlZCBtZXRob2QnKTtcbiAgfTtcblxuICAvKipcbiAgICogTWF4aW11bSBvYmplY3QgZGVwdGggdGhlIHByZXR0eSBwcmludGVyIHdpbGwgcHJpbnQgdG8uXG4gICAqIFNldCB0aGlzIHRvIGEgbG93ZXIgdmFsdWUgdG8gc3BlZWQgdXAgcHJldHR5IHByaW50aW5nIGlmIHlvdSBoYXZlIGxhcmdlIG9iamVjdHMuXG4gICAqIEBuYW1lIGphc21pbmUuTUFYX1BSRVRUWV9QUklOVF9ERVBUSFxuICAgKiBAZGVmYXVsdCA4XG4gICAqIEBzaW5jZSAxLjMuMFxuICAgKi9cbiAgaiQuTUFYX1BSRVRUWV9QUklOVF9ERVBUSCA9IDg7XG4gIC8qKlxuICAgKiBNYXhpbXVtIG51bWJlciBvZiBhcnJheSBlbGVtZW50cyB0byBkaXNwbGF5IHdoZW4gcHJldHR5IHByaW50aW5nIG9iamVjdHMuXG4gICAqIFRoaXMgd2lsbCBhbHNvIGxpbWl0IHRoZSBudW1iZXIgb2Yga2V5cyBhbmQgdmFsdWVzIGRpc3BsYXllZCBmb3IgYW4gb2JqZWN0LlxuICAgKiBFbGVtZW50cyBwYXN0IHRoaXMgbnVtYmVyIHdpbGwgYmUgZWxsaXBpc2VkLlxuICAgKiBAbmFtZSBqYXNtaW5lLk1BWF9QUkVUVFlfUFJJTlRfQVJSQVlfTEVOR1RIXG4gICAqIEBkZWZhdWx0IDUwXG4gICAqIEBzaW5jZSAyLjcuMFxuICAgKi9cbiAgaiQuTUFYX1BSRVRUWV9QUklOVF9BUlJBWV9MRU5HVEggPSA1MDtcbiAgLyoqXG4gICAqIE1heGltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gZGlzcGxheSB3aGVuIHByZXR0eSBwcmludGluZyBvYmplY3RzLlxuICAgKiBDaGFyYWN0ZXJzIHBhc3QgdGhpcyBudW1iZXIgd2lsbCBiZSBlbGxpcGlzZWQuXG4gICAqIEBuYW1lIGphc21pbmUuTUFYX1BSRVRUWV9QUklOVF9DSEFSU1xuICAgKiBAZGVmYXVsdCAxMDBcbiAgICogQHNpbmNlIDIuOS4wXG4gICAqL1xuICBqJC5NQVhfUFJFVFRZX1BSSU5UX0NIQVJTID0gMTAwMDtcbiAgLyoqXG4gICAqIERlZmF1bHQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBKYXNtaW5lIHdpbGwgd2FpdCBmb3IgYW4gYXN5bmNocm9ub3VzIHNwZWMsXG4gICAqIGJlZm9yZSwgb3IgYWZ0ZXIgZnVuY3Rpb24gdG8gY29tcGxldGUuIFRoaXMgY2FuIGJlIG92ZXJyaWRkZW4gb24gYSBjYXNlIGJ5XG4gICAqIGNhc2UgYmFzaXMgYnkgcGFzc2luZyBhIHRpbWUgbGltaXQgYXMgdGhlIHRoaXJkIGFyZ3VtZW50IHRvIHtAbGluayBpdH0sXG4gICAqIHtAbGluayBiZWZvcmVFYWNofSwge0BsaW5rIGFmdGVyRWFjaH0sIHtAbGluayBiZWZvcmVBbGx9LCBvclxuICAgKiB7QGxpbmsgYWZ0ZXJBbGx9LiBUaGUgdmFsdWUgbXVzdCBiZSBubyBncmVhdGVyIHRoYW4gdGhlIGxhcmdlc3QgbnVtYmVyIG9mXG4gICAqIG1pbGxpc2Vjb25kcyBzdXBwb3J0ZWQgYnkgc2V0VGltZW91dCwgd2hpY2ggaXMgdXN1YWxseSAyMTQ3NDgzNjQ3LlxuICAgKlxuICAgKiBXaGlsZSBkZWJ1Z2dpbmcgdGVzdHMsIHlvdSBtYXkgd2FudCB0byBzZXQgdGhpcyB0byBhIGxhcmdlIG51bWJlciAob3IgcGFzc1xuICAgKiBhIGxhcmdlIG51bWJlciB0byBvbmUgb2YgdGhlIGZ1bmN0aW9ucyBtZW50aW9uZWQgYWJvdmUpIHNvIHRoYXQgSmFzbWluZVxuICAgKiBkb2VzIG5vdCBtb3ZlIG9uIHRvIGFmdGVyIGZ1bmN0aW9ucyBvciB0aGUgbmV4dCBzcGVjIHdoaWxlIHlvdSdyZSBkZWJ1Z2dpbmcuXG4gICAqIEBuYW1lIGphc21pbmUuREVGQVVMVF9USU1FT1VUX0lOVEVSVkFMXG4gICAqIEBkZWZhdWx0IDUwMDBcbiAgICogQHNpbmNlIDEuMy4wXG4gICAqL1xuICB2YXIgREVGQVVMVF9USU1FT1VUX0lOVEVSVkFMID0gNTAwMDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGokLCAnREVGQVVMVF9USU1FT1VUX0lOVEVSVkFMJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gREVGQVVMVF9USU1FT1VUX0lOVEVSVkFMO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgICAgaiQudXRpbC52YWxpZGF0ZVRpbWVvdXQobmV3VmFsdWUsICdqYXNtaW5lLkRFRkFVTFRfVElNRU9VVF9JTlRFUlZBTCcpO1xuICAgICAgREVGQVVMVF9USU1FT1VUX0lOVEVSVkFMID0gbmV3VmFsdWU7XG4gICAgfVxuICB9KTtcblxuICBqJC5nZXRHbG9iYWwgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gamFzbWluZUdsb2JhbDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50bHkgYm9vdGVkIEphc21pbmUgRW52aXJvbm1lbnQuXG4gICAqXG4gICAqIEBuYW1lIGphc21pbmUuZ2V0RW52XG4gICAqIEBzaW5jZSAxLjMuMFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHJldHVybiB7RW52fVxuICAgKi9cbiAgaiQuZ2V0RW52ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBlbnYgPSAoaiQuY3VycmVudEVudl8gPSBqJC5jdXJyZW50RW52XyB8fCBuZXcgaiQuRW52KG9wdGlvbnMpKTtcbiAgICAvL2phc21pbmUuIHNpbmdsZXRvbnMgaW4gaGVyZSAoc2V0VGltZW91dCBibGFoIGJsYWgpLlxuICAgIHJldHVybiBlbnY7XG4gIH07XG5cbiAgaiQuaXNBcnJheV8gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBqJC5pc0FfKCdBcnJheScsIHZhbHVlKTtcbiAgfTtcblxuICBqJC5pc09iamVjdF8gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiAoXG4gICAgICAhaiQudXRpbC5pc1VuZGVmaW5lZCh2YWx1ZSkgJiYgdmFsdWUgIT09IG51bGwgJiYgaiQuaXNBXygnT2JqZWN0JywgdmFsdWUpXG4gICAgKTtcbiAgfTtcblxuICBqJC5pc1N0cmluZ18gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBqJC5pc0FfKCdTdHJpbmcnLCB2YWx1ZSk7XG4gIH07XG5cbiAgaiQuaXNOdW1iZXJfID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gaiQuaXNBXygnTnVtYmVyJywgdmFsdWUpO1xuICB9O1xuXG4gIGokLmlzRnVuY3Rpb25fID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gaiQuaXNBXygnRnVuY3Rpb24nLCB2YWx1ZSk7XG4gIH07XG5cbiAgaiQuaXNBc3luY0Z1bmN0aW9uXyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGokLmlzQV8oJ0FzeW5jRnVuY3Rpb24nLCB2YWx1ZSk7XG4gIH07XG5cbiAgaiQuaXNHZW5lcmF0b3JGdW5jdGlvbl8gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBqJC5pc0FfKCdHZW5lcmF0b3JGdW5jdGlvbicsIHZhbHVlKTtcbiAgfTtcblxuICBqJC5pc1R5cGVkQXJyYXlfID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgaiQuaXNBXygnRmxvYXQzMkFycmF5JywgdmFsdWUpIHx8XG4gICAgICBqJC5pc0FfKCdGbG9hdDY0QXJyYXknLCB2YWx1ZSkgfHxcbiAgICAgIGokLmlzQV8oJ0ludDE2QXJyYXknLCB2YWx1ZSkgfHxcbiAgICAgIGokLmlzQV8oJ0ludDMyQXJyYXknLCB2YWx1ZSkgfHxcbiAgICAgIGokLmlzQV8oJ0ludDhBcnJheScsIHZhbHVlKSB8fFxuICAgICAgaiQuaXNBXygnVWludDE2QXJyYXknLCB2YWx1ZSkgfHxcbiAgICAgIGokLmlzQV8oJ1VpbnQzMkFycmF5JywgdmFsdWUpIHx8XG4gICAgICBqJC5pc0FfKCdVaW50OEFycmF5JywgdmFsdWUpIHx8XG4gICAgICBqJC5pc0FfKCdVaW50OENsYW1wZWRBcnJheScsIHZhbHVlKVxuICAgICk7XG4gIH07XG5cbiAgaiQuaXNBXyA9IGZ1bmN0aW9uKHR5cGVOYW1lLCB2YWx1ZSkge1xuICAgIHJldHVybiBqJC5nZXRUeXBlXyh2YWx1ZSkgPT09ICdbb2JqZWN0ICcgKyB0eXBlTmFtZSArICddJztcbiAgfTtcblxuICBqJC5pc0Vycm9yXyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlLnN0YWNrID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUubWVzc2FnZSA9PT0gJ3N0cmluZyc7XG4gIH07XG5cbiAgaiQuaXNBc3ltbWV0cmljRXF1YWxpdHlUZXN0ZXJfID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA/IGokLmlzQV8oJ0Z1bmN0aW9uJywgb2JqLmFzeW1tZXRyaWNNYXRjaCkgOiBmYWxzZTtcbiAgfTtcblxuICBqJC5nZXRUeXBlXyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpO1xuICB9O1xuXG4gIGokLmlzRG9tTm9kZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIC8vIE5vZGUgaXMgYSBmdW5jdGlvbiwgYmVjYXVzZSBjb25zdHJ1Y3RvcnNcbiAgICByZXR1cm4gdHlwZW9mIGphc21pbmVHbG9iYWwuTm9kZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgID8gb2JqIGluc3RhbmNlb2YgamFzbWluZUdsb2JhbC5Ob2RlXG4gICAgICA6IG9iaiAhPT0gbnVsbCAmJlxuICAgICAgICAgIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgdHlwZW9mIG9iai5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICB0eXBlb2Ygb2JqLm5vZGVOYW1lID09PSAnc3RyaW5nJztcbiAgICAvLyByZXR1cm4gb2JqLm5vZGVUeXBlID4gMDtcbiAgfTtcblxuICBqJC5pc01hcCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAoXG4gICAgICBvYmogIT09IG51bGwgJiZcbiAgICAgIHR5cGVvZiBvYmogIT09ICd1bmRlZmluZWQnICYmXG4gICAgICBvYmouY29uc3RydWN0b3IgPT09IGphc21pbmVHbG9iYWwuTWFwXG4gICAgKTtcbiAgfTtcblxuICBqJC5pc1NldCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAoXG4gICAgICBvYmogIT09IG51bGwgJiZcbiAgICAgIHR5cGVvZiBvYmogIT09ICd1bmRlZmluZWQnICYmXG4gICAgICBvYmouY29uc3RydWN0b3IgPT09IGphc21pbmVHbG9iYWwuU2V0XG4gICAgKTtcbiAgfTtcblxuICBqJC5pc1dlYWtNYXAgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gKFxuICAgICAgb2JqICE9PSBudWxsICYmXG4gICAgICB0eXBlb2Ygb2JqICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yID09PSBqYXNtaW5lR2xvYmFsLldlYWtNYXBcbiAgICApO1xuICB9O1xuXG4gIGokLmlzVVJMID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIG9iaiAhPT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIG9iaiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3RvciA9PT0gamFzbWluZUdsb2JhbC5VUkxcbiAgICApO1xuICB9O1xuXG4gIGokLmlzSXRlcmFibGVfID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgISF2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdO1xuICB9O1xuXG4gIGokLmlzRGF0YVZpZXcgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gKFxuICAgICAgb2JqICE9PSBudWxsICYmXG4gICAgICB0eXBlb2Ygb2JqICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yID09PSBqYXNtaW5lR2xvYmFsLkRhdGFWaWV3XG4gICAgKTtcbiAgfTtcblxuICBqJC5pc1Byb21pc2UgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISFvYmogJiYgb2JqLmNvbnN0cnVjdG9yID09PSBqYXNtaW5lR2xvYmFsLlByb21pc2U7XG4gIH07XG5cbiAgaiQuaXNQcm9taXNlTGlrZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAhIW9iaiAmJiBqJC5pc0Z1bmN0aW9uXyhvYmoudGhlbik7XG4gIH07XG5cbiAgaiQuZm5OYW1lRm9yID0gZnVuY3Rpb24oZnVuYykge1xuICAgIGlmIChmdW5jLm5hbWUpIHtcbiAgICAgIHJldHVybiBmdW5jLm5hbWU7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoZXMgPVxuICAgICAgZnVuYy50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uXFxzKihcXHcrKVxccypcXCgvKSB8fFxuICAgICAgZnVuYy50b1N0cmluZygpLm1hdGNoKC9eXFxzKlxcW29iamVjdFxccyooXFx3KylDb25zdHJ1Y3RvclxcXS8pO1xuXG4gICAgcmV0dXJuIG1hdGNoZXMgPyBtYXRjaGVzWzFdIDogJzxhbm9ueW1vdXM+JztcbiAgfTtcblxuICBqJC5pc1BlbmRpbmdfID0gZnVuY3Rpb24ocHJvbWlzZSkge1xuICAgIHZhciBzZW50aW5lbCA9IHt9O1xuICAgIHJldHVybiBQcm9taXNlLnJhY2UoW3Byb21pc2UsIFByb21pc2UucmVzb2x2ZShzZW50aW5lbCldKS50aGVuKFxuICAgICAgZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IHNlbnRpbmVsO1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFuIHtAbGluayBBc3ltbWV0cmljRXF1YWxpdHlUZXN0ZXJ9LCB1c2FibGUgaW4gYW55IHtAbGluayBtYXRjaGVyc3xtYXRjaGVyfSB0aGF0IHVzZXMgSmFzbWluZSdzIGVxdWFsaXR5IChlLmcuIHtAbGluayBtYXRjaGVycyN0b0VxdWFsfHRvRXF1YWx9LCB7QGxpbmsgbWF0Y2hlcnMjdG9Db250YWlufHRvQ29udGFpbn0sIG9yIHtAbGluayBtYXRjaGVycyN0b0hhdmVCZWVuQ2FsbGVkV2l0aHx0b0hhdmVCZWVuQ2FsbGVkV2l0aH0pLFxuICAgKiB0aGF0IHdpbGwgc3VjY2VlZCBpZiB0aGUgYWN0dWFsIHZhbHVlIGJlaW5nIGNvbXBhcmVkIGlzIGFuIGluc3RhbmNlIG9mIHRoZSBzcGVjaWZpZWQgY2xhc3MvY29uc3RydWN0b3IuXG4gICAqIEBuYW1lIGphc21pbmUuYW55XG4gICAqIEBzaW5jZSAxLjMuMFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtDb25zdHJ1Y3Rvcn0gY2xhenogLSBUaGUgY29uc3RydWN0b3IgdG8gY2hlY2sgYWdhaW5zdC5cbiAgICovXG4gIGokLmFueSA9IGZ1bmN0aW9uKGNsYXp6KSB7XG4gICAgcmV0dXJuIG5ldyBqJC5BbnkoY2xhenopO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYW4ge0BsaW5rIEFzeW1tZXRyaWNFcXVhbGl0eVRlc3Rlcn0sIHVzYWJsZSBpbiBhbnkge0BsaW5rIG1hdGNoZXJzfG1hdGNoZXJ9IHRoYXQgdXNlcyBKYXNtaW5lJ3MgZXF1YWxpdHkgKGUuZy4ge0BsaW5rIG1hdGNoZXJzI3RvRXF1YWx8dG9FcXVhbH0sIHtAbGluayBtYXRjaGVycyN0b0NvbnRhaW58dG9Db250YWlufSwgb3Ige0BsaW5rIG1hdGNoZXJzI3RvSGF2ZUJlZW5DYWxsZWRXaXRofHRvSGF2ZUJlZW5DYWxsZWRXaXRofSksXG4gICAqIHRoYXQgd2lsbCBzdWNjZWVkIGlmIHRoZSBhY3R1YWwgdmFsdWUgYmVpbmcgY29tcGFyZWQgaXMgbm90IGBudWxsYCBhbmQgbm90IGB1bmRlZmluZWRgLlxuICAgKiBAbmFtZSBqYXNtaW5lLmFueXRoaW5nXG4gICAqIEBzaW5jZSAyLjIuMFxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIGokLmFueXRoaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBqJC5Bbnl0aGluZygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYW4ge0BsaW5rIEFzeW1tZXRyaWNFcXVhbGl0eVRlc3Rlcn0sIHVzYWJsZSBpbiBhbnkge0BsaW5rIG1hdGNoZXJzfG1hdGNoZXJ9IHRoYXQgdXNlcyBKYXNtaW5lJ3MgZXF1YWxpdHkgKGUuZy4ge0BsaW5rIG1hdGNoZXJzI3RvRXF1YWx8dG9FcXVhbH0sIHtAbGluayBtYXRjaGVycyN0b0NvbnRhaW58dG9Db250YWlufSwgb3Ige0BsaW5rIG1hdGNoZXJzI3RvSGF2ZUJlZW5DYWxsZWRXaXRofHRvSGF2ZUJlZW5DYWxsZWRXaXRofSksXG4gICAqIHRoYXQgd2lsbCBzdWNjZWVkIGlmIHRoZSBhY3R1YWwgdmFsdWUgYmVpbmcgY29tcGFyZWQgaXMgYHRydWVgIG9yIGFueXRoaW5nIHRydXRoeS5cbiAgICogQG5hbWUgamFzbWluZS50cnV0aHlcbiAgICogQHNpbmNlIDMuMS4wXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgaiQudHJ1dGh5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBqJC5UcnV0aHkoKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFuIHtAbGluayBBc3ltbWV0cmljRXF1YWxpdHlUZXN0ZXJ9LCB1c2FibGUgaW4gYW55IHtAbGluayBtYXRjaGVyc3xtYXRjaGVyfSB0aGF0IHVzZXMgSmFzbWluZSdzIGVxdWFsaXR5IChlLmcuIHtAbGluayBtYXRjaGVycyN0b0VxdWFsfHRvRXF1YWx9LCB7QGxpbmsgbWF0Y2hlcnMjdG9Db250YWlufHRvQ29udGFpbn0sIG9yIHtAbGluayBtYXRjaGVycyN0b0hhdmVCZWVuQ2FsbGVkV2l0aHx0b0hhdmVCZWVuQ2FsbGVkV2l0aH0pLFxuICAgKiB0aGF0IHdpbGwgc3VjY2VlZCBpZiB0aGUgYWN0dWFsIHZhbHVlIGJlaW5nIGNvbXBhcmVkIGlzICBgbnVsbGAsIGB1bmRlZmluZWRgLCBgMGAsIGBmYWxzZWAgb3IgYW55dGhpbmcgZmFsc2V5LlxuICAgKiBAbmFtZSBqYXNtaW5lLmZhbHN5XG4gICAqIEBzaW5jZSAzLjEuMFxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIGokLmZhbHN5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBqJC5GYWxzeSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYW4ge0BsaW5rIEFzeW1tZXRyaWNFcXVhbGl0eVRlc3Rlcn0sIHVzYWJsZSBpbiBhbnkge0BsaW5rIG1hdGNoZXJzfG1hdGNoZXJ9IHRoYXQgdXNlcyBKYXNtaW5lJ3MgZXF1YWxpdHkgKGUuZy4ge0BsaW5rIG1hdGNoZXJzI3RvRXF1YWx8dG9FcXVhbH0sIHtAbGluayBtYXRjaGVycyN0b0NvbnRhaW58dG9Db250YWlufSwgb3Ige0BsaW5rIG1hdGNoZXJzI3RvSGF2ZUJlZW5DYWxsZWRXaXRofHRvSGF2ZUJlZW5DYWxsZWRXaXRofSksXG4gICAqIHRoYXQgd2lsbCBzdWNjZWVkIGlmIHRoZSBhY3R1YWwgdmFsdWUgYmVpbmcgY29tcGFyZWQgaXMgZW1wdHkuXG4gICAqIEBuYW1lIGphc21pbmUuZW1wdHlcbiAgICogQHNpbmNlIDMuMS4wXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgaiQuZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IGokLkVtcHR5KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiB7QGxpbmsgQXN5bW1ldHJpY0VxdWFsaXR5VGVzdGVyfSwgdXNhYmxlIGluIGFueSB7QGxpbmsgbWF0Y2hlcnN8bWF0Y2hlcn0gdGhhdCB1c2VzIEphc21pbmUncyBlcXVhbGl0eSAoZS5nLiB7QGxpbmsgbWF0Y2hlcnMjdG9FcXVhbHx0b0VxdWFsfSwge0BsaW5rIG1hdGNoZXJzI3RvQ29udGFpbnx0b0NvbnRhaW59LCBvciB7QGxpbmsgbWF0Y2hlcnMjdG9IYXZlQmVlbkNhbGxlZFdpdGh8dG9IYXZlQmVlbkNhbGxlZFdpdGh9KSxcbiAgICogdGhhdCB3aWxsIHN1Y2NlZWQgaWYgdGhlIGFjdHVhbCB2YWx1ZSBiZWluZyBjb21wYXJlZCBpcyBub3QgZW1wdHkuXG4gICAqIEBuYW1lIGphc21pbmUubm90RW1wdHlcbiAgICogQHNpbmNlIDMuMS4wXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgaiQubm90RW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IGokLk5vdEVtcHR5KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiB7QGxpbmsgQXN5bW1ldHJpY0VxdWFsaXR5VGVzdGVyfSwgdXNhYmxlIGluIGFueSB7QGxpbmsgbWF0Y2hlcnN8bWF0Y2hlcn0gdGhhdCB1c2VzIEphc21pbmUncyBlcXVhbGl0eSAoZS5nLiB7QGxpbmsgbWF0Y2hlcnMjdG9FcXVhbHx0b0VxdWFsfSwge0BsaW5rIG1hdGNoZXJzI3RvQ29udGFpbnx0b0NvbnRhaW59LCBvciB7QGxpbmsgbWF0Y2hlcnMjdG9IYXZlQmVlbkNhbGxlZFdpdGh8dG9IYXZlQmVlbkNhbGxlZFdpdGh9KSxcbiAgICogdGhhdCB3aWxsIHN1Y2NlZWQgaWYgdGhlIGFjdHVhbCB2YWx1ZSBiZWluZyBjb21wYXJlZCBjb250YWlucyBhdCBsZWFzdCB0aGUga2V5cyBhbmQgdmFsdWVzLlxuICAgKiBAbmFtZSBqYXNtaW5lLm9iamVjdENvbnRhaW5pbmdcbiAgICogQHNpbmNlIDEuMy4wXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gc2FtcGxlIC0gVGhlIHN1YnNldCBvZiBwcm9wZXJ0aWVzIHRoYXQgX211c3RfIGJlIGluIHRoZSBhY3R1YWwuXG4gICAqL1xuICBqJC5vYmplY3RDb250YWluaW5nID0gZnVuY3Rpb24oc2FtcGxlKSB7XG4gICAgcmV0dXJuIG5ldyBqJC5PYmplY3RDb250YWluaW5nKHNhbXBsZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiB7QGxpbmsgQXN5bW1ldHJpY0VxdWFsaXR5VGVzdGVyfSwgdXNhYmxlIGluIGFueSB7QGxpbmsgbWF0Y2hlcnN8bWF0Y2hlcn0gdGhhdCB1c2VzIEphc21pbmUncyBlcXVhbGl0eSAoZS5nLiB7QGxpbmsgbWF0Y2hlcnMjdG9FcXVhbHx0b0VxdWFsfSwge0BsaW5rIG1hdGNoZXJzI3RvQ29udGFpbnx0b0NvbnRhaW59LCBvciB7QGxpbmsgbWF0Y2hlcnMjdG9IYXZlQmVlbkNhbGxlZFdpdGh8dG9IYXZlQmVlbkNhbGxlZFdpdGh9KSxcbiAgICogdGhhdCB3aWxsIHN1Y2NlZWQgaWYgdGhlIGFjdHVhbCB2YWx1ZSBpcyBhIGBTdHJpbmdgIHRoYXQgbWF0Y2hlcyB0aGUgYFJlZ0V4cGAgb3IgYFN0cmluZ2AuXG4gICAqIEBuYW1lIGphc21pbmUuc3RyaW5nTWF0Y2hpbmdcbiAgICogQHNpbmNlIDIuMi4wXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IGV4cGVjdGVkXG4gICAqL1xuICBqJC5zdHJpbmdNYXRjaGluZyA9IGZ1bmN0aW9uKGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIG5ldyBqJC5TdHJpbmdNYXRjaGluZyhleHBlY3RlZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiB7QGxpbmsgQXN5bW1ldHJpY0VxdWFsaXR5VGVzdGVyfSwgdXNhYmxlIGluIGFueSB7QGxpbmsgbWF0Y2hlcnN8bWF0Y2hlcn0gdGhhdCB1c2VzIEphc21pbmUncyBlcXVhbGl0eSAoZS5nLiB7QGxpbmsgbWF0Y2hlcnMjdG9FcXVhbHx0b0VxdWFsfSwge0BsaW5rIG1hdGNoZXJzI3RvQ29udGFpbnx0b0NvbnRhaW59LCBvciB7QGxpbmsgbWF0Y2hlcnMjdG9IYXZlQmVlbkNhbGxlZFdpdGh8dG9IYXZlQmVlbkNhbGxlZFdpdGh9KSxcbiAgICogdGhhdCB3aWxsIHN1Y2NlZWQgaWYgdGhlIGFjdHVhbCB2YWx1ZSBpcyBhIGBTdHJpbmdgIHRoYXQgY29udGFpbnMgdGhlIHNwZWNpZmllZCBgU3RyaW5nYC5cbiAgICogQG5hbWUgamFzbWluZS5zdHJpbmdDb250YWluaW5nXG4gICAqIEBzaW5jZSAzLjEwLjBcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBleHBlY3RlZFxuICAgKi9cbiAgaiQuc3RyaW5nQ29udGFpbmluZyA9IGZ1bmN0aW9uKGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIG5ldyBqJC5TdHJpbmdDb250YWluaW5nKGV4cGVjdGVkKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFuIHtAbGluayBBc3ltbWV0cmljRXF1YWxpdHlUZXN0ZXJ9LCB1c2FibGUgaW4gYW55IHtAbGluayBtYXRjaGVyc3xtYXRjaGVyfSB0aGF0IHVzZXMgSmFzbWluZSdzIGVxdWFsaXR5IChlLmcuIHtAbGluayBtYXRjaGVycyN0b0VxdWFsfHRvRXF1YWx9LCB7QGxpbmsgbWF0Y2hlcnMjdG9Db250YWlufHRvQ29udGFpbn0sIG9yIHtAbGluayBtYXRjaGVycyN0b0hhdmVCZWVuQ2FsbGVkV2l0aHx0b0hhdmVCZWVuQ2FsbGVkV2l0aH0pLFxuICAgKiB0aGF0IHdpbGwgc3VjY2VlZCBpZiB0aGUgYWN0dWFsIHZhbHVlIGlzIGFuIGBBcnJheWAgdGhhdCBjb250YWlucyBhdCBsZWFzdCB0aGUgZWxlbWVudHMgaW4gdGhlIHNhbXBsZS5cbiAgICogQG5hbWUgamFzbWluZS5hcnJheUNvbnRhaW5pbmdcbiAgICogQHNpbmNlIDIuMi4wXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0FycmF5fSBzYW1wbGVcbiAgICovXG4gIGokLmFycmF5Q29udGFpbmluZyA9IGZ1bmN0aW9uKHNhbXBsZSkge1xuICAgIHJldHVybiBuZXcgaiQuQXJyYXlDb250YWluaW5nKHNhbXBsZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiB7QGxpbmsgQXN5bW1ldHJpY0VxdWFsaXR5VGVzdGVyfSwgdXNhYmxlIGluIGFueSB7QGxpbmsgbWF0Y2hlcnN8bWF0Y2hlcn0gdGhhdCB1c2VzIEphc21pbmUncyBlcXVhbGl0eSAoZS5nLiB7QGxpbmsgbWF0Y2hlcnMjdG9FcXVhbHx0b0VxdWFsfSwge0BsaW5rIG1hdGNoZXJzI3RvQ29udGFpbnx0b0NvbnRhaW59LCBvciB7QGxpbmsgbWF0Y2hlcnMjdG9IYXZlQmVlbkNhbGxlZFdpdGh8dG9IYXZlQmVlbkNhbGxlZFdpdGh9KSxcbiAgICogdGhhdCB3aWxsIHN1Y2NlZWQgaWYgdGhlIGFjdHVhbCB2YWx1ZSBpcyBhbiBgQXJyYXlgIHRoYXQgY29udGFpbnMgYWxsIG9mIHRoZSBlbGVtZW50cyBpbiB0aGUgc2FtcGxlIGluIGFueSBvcmRlci5cbiAgICogQG5hbWUgamFzbWluZS5hcnJheVdpdGhFeGFjdENvbnRlbnRzXG4gICAqIEBzaW5jZSAyLjguMFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheX0gc2FtcGxlXG4gICAqL1xuICBqJC5hcnJheVdpdGhFeGFjdENvbnRlbnRzID0gZnVuY3Rpb24oc2FtcGxlKSB7XG4gICAgcmV0dXJuIG5ldyBqJC5BcnJheVdpdGhFeGFjdENvbnRlbnRzKHNhbXBsZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiB7QGxpbmsgQXN5bW1ldHJpY0VxdWFsaXR5VGVzdGVyfSwgdXNhYmxlIGluIGFueSB7QGxpbmsgbWF0Y2hlcnN8bWF0Y2hlcn0gdGhhdCB1c2VzIEphc21pbmUncyBlcXVhbGl0eSAoZS5nLiB7QGxpbmsgbWF0Y2hlcnMjdG9FcXVhbHx0b0VxdWFsfSwge0BsaW5rIG1hdGNoZXJzI3RvQ29udGFpbnx0b0NvbnRhaW59LCBvciB7QGxpbmsgbWF0Y2hlcnMjdG9IYXZlQmVlbkNhbGxlZFdpdGh8dG9IYXZlQmVlbkNhbGxlZFdpdGh9KSxcbiAgICogdGhhdCB3aWxsIHN1Y2NlZWQgaWYgZXZlcnkga2V5L3ZhbHVlIHBhaXIgaW4gdGhlIHNhbXBsZSBwYXNzZXMgdGhlIGRlZXAgZXF1YWxpdHkgY29tcGFyaXNvblxuICAgKiB3aXRoIGF0IGxlYXN0IG9uZSBrZXkvdmFsdWUgcGFpciBpbiB0aGUgYWN0dWFsIHZhbHVlIGJlaW5nIGNvbXBhcmVkXG4gICAqIEBuYW1lIGphc21pbmUubWFwQ29udGFpbmluZ1xuICAgKiBAc2luY2UgMy41LjBcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7TWFwfSBzYW1wbGUgLSBUaGUgc3Vic2V0IG9mIGl0ZW1zIHRoYXQgX211c3RfIGJlIGluIHRoZSBhY3R1YWwuXG4gICAqL1xuICBqJC5tYXBDb250YWluaW5nID0gZnVuY3Rpb24oc2FtcGxlKSB7XG4gICAgcmV0dXJuIG5ldyBqJC5NYXBDb250YWluaW5nKHNhbXBsZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiB7QGxpbmsgQXN5bW1ldHJpY0VxdWFsaXR5VGVzdGVyfSwgdXNhYmxlIGluIGFueSB7QGxpbmsgbWF0Y2hlcnN8bWF0Y2hlcn0gdGhhdCB1c2VzIEphc21pbmUncyBlcXVhbGl0eSAoZS5nLiB7QGxpbmsgbWF0Y2hlcnMjdG9FcXVhbHx0b0VxdWFsfSwge0BsaW5rIG1hdGNoZXJzI3RvQ29udGFpbnx0b0NvbnRhaW59LCBvciB7QGxpbmsgbWF0Y2hlcnMjdG9IYXZlQmVlbkNhbGxlZFdpdGh8dG9IYXZlQmVlbkNhbGxlZFdpdGh9KSxcbiAgICogdGhhdCB3aWxsIHN1Y2NlZWQgaWYgZXZlcnkgaXRlbSBpbiB0aGUgc2FtcGxlIHBhc3NlcyB0aGUgZGVlcCBlcXVhbGl0eSBjb21wYXJpc29uXG4gICAqIHdpdGggYXQgbGVhc3Qgb25lIGl0ZW0gaW4gdGhlIGFjdHVhbCB2YWx1ZSBiZWluZyBjb21wYXJlZFxuICAgKiBAbmFtZSBqYXNtaW5lLnNldENvbnRhaW5pbmdcbiAgICogQHNpbmNlIDMuNS4wXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1NldH0gc2FtcGxlIC0gVGhlIHN1YnNldCBvZiBpdGVtcyB0aGF0IF9tdXN0XyBiZSBpbiB0aGUgYWN0dWFsLlxuICAgKi9cbiAgaiQuc2V0Q29udGFpbmluZyA9IGZ1bmN0aW9uKHNhbXBsZSkge1xuICAgIHJldHVybiBuZXcgaiQuU2V0Q29udGFpbmluZyhzYW1wbGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGlzIGEgSmFzbWluZSBzcHkuXG4gICAqIEBuYW1lIGphc21pbmUuaXNTcHlcbiAgICogQHNpbmNlIDIuMC4wXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwdXRhdGl2ZVNweSAtIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGokLmlzU3B5ID0gZnVuY3Rpb24ocHV0YXRpdmVTcHkpIHtcbiAgICBpZiAoIXB1dGF0aXZlU3B5KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICBwdXRhdGl2ZVNweS5hbmQgaW5zdGFuY2VvZiBqJC5TcHlTdHJhdGVneSAmJlxuICAgICAgcHV0YXRpdmVTcHkuY2FsbHMgaW5zdGFuY2VvZiBqJC5DYWxsVHJhY2tlclxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIExvZ3MgYSBtZXNzYWdlIGZvciB1c2UgaW4gZGVidWdnaW5nLiBJZiB0aGUgc3BlYyBmYWlscywgdHJhY2UgbWVzc2FnZXNcbiAgICogd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUge0BsaW5rIFNwZWNSZXN1bHR8cmVzdWx0fSBwYXNzZWQgdG8gdGhlXG4gICAqIHJlcG9ydGVyJ3Mgc3BlY0RvbmUgbWV0aG9kLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIG9ubHkgd2hlbiBhIHNwZWMgKGluY2x1ZGluZyBhbnkgYXNzb2NpYXRlZFxuICAgKiBiZWZvcmVFYWNoIG9yIGFmdGVyRWFjaCBmdW5jdGlvbnMpIGlzIHJ1bm5pbmcuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBqYXNtaW5lLmRlYnVnTG9nXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gVGhlIG1lc3NhZ2UgdG8gbG9nXG4gICAqL1xuICBqJC5kZWJ1Z0xvZyA9IGZ1bmN0aW9uKG1zZykge1xuICAgIGokLmdldEVudigpLmRlYnVnTG9nKG1zZyk7XG4gIH07XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnV0aWwgPSBmdW5jdGlvbihqJCkge1xuICB2YXIgdXRpbCA9IHt9O1xuXG4gIHV0aWwuaW5oZXJpdCA9IGZ1bmN0aW9uKGNoaWxkQ2xhc3MsIHBhcmVudENsYXNzKSB7XG4gICAgdmFyIFN1YmNsYXNzID0gZnVuY3Rpb24oKSB7fTtcbiAgICBTdWJjbGFzcy5wcm90b3R5cGUgPSBwYXJlbnRDbGFzcy5wcm90b3R5cGU7XG4gICAgY2hpbGRDbGFzcy5wcm90b3R5cGUgPSBuZXcgU3ViY2xhc3MoKTtcbiAgfTtcblxuICB1dGlsLmFyZ3NUb0FycmF5ID0gZnVuY3Rpb24oYXJncykge1xuICAgIHZhciBhcnJheU9mQXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyYXlPZkFyZ3MucHVzaChhcmdzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5T2ZBcmdzO1xuICB9O1xuXG4gIHV0aWwuaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG4gIH07XG5cbiAgdXRpbC5hcnJheUNvbnRhaW5zID0gZnVuY3Rpb24oYXJyYXksIHNlYXJjaCkge1xuICAgIHZhciBpID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmIChhcnJheVtpXSA9PT0gc2VhcmNoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgdXRpbC5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KG9iaikgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHJldHVybiBvYmouc2xpY2UoKTtcbiAgICB9XG5cbiAgICB2YXIgY2xvbmVkID0ge307XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgY2xvbmVkW3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbG9uZWQ7XG4gIH07XG5cbiAgdXRpbC5jbG9uZUFyZ3MgPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgdmFyIGNsb25lZEFyZ3MgPSBbXTtcbiAgICB2YXIgYXJnc0FzQXJyYXkgPSBqJC51dGlsLmFyZ3NUb0FycmF5KGFyZ3MpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnc0FzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KGFyZ3NBc0FycmF5W2ldKSxcbiAgICAgICAgcHJpbWl0aXZlcyA9IC9eXFxbb2JqZWN0IChCb29sZWFufFN0cmluZ3xSZWdFeHB8TnVtYmVyKS87XG5cbiAgICAgIC8vIEFsbCBmYWxzZXkgdmFsdWVzIGFyZSBlaXRoZXIgcHJpbWl0aXZlcywgYG51bGxgLCBvciBgdW5kZWZpbmVkLlxuICAgICAgaWYgKCFhcmdzQXNBcnJheVtpXSB8fCBzdHIubWF0Y2gocHJpbWl0aXZlcykpIHtcbiAgICAgICAgY2xvbmVkQXJncy5wdXNoKGFyZ3NBc0FycmF5W2ldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsb25lZEFyZ3MucHVzaChqJC51dGlsLmNsb25lKGFyZ3NBc0FycmF5W2ldKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbG9uZWRBcmdzO1xuICB9O1xuXG4gIHV0aWwuZ2V0UHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24ob2JqLCBtZXRob2ROYW1lKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IsXG4gICAgICBwcm90byA9IG9iajtcblxuICAgIGRvIHtcbiAgICAgIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBtZXRob2ROYW1lKTtcbiAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICB9IHdoaWxlICghZGVzY3JpcHRvciAmJiBwcm90byk7XG5cbiAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgfTtcblxuICB1dGlsLm9iamVjdERpZmZlcmVuY2UgPSBmdW5jdGlvbihvYmosIHRvUmVtb3ZlKSB7XG4gICAgdmFyIGRpZmYgPSB7fTtcblxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmICh1dGlsLmhhcyhvYmosIGtleSkgJiYgIXV0aWwuaGFzKHRvUmVtb3ZlLCBrZXkpKSB7XG4gICAgICAgIGRpZmZba2V5XSA9IG9ialtrZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkaWZmO1xuICB9O1xuXG4gIHV0aWwuaGFzID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbiAgfTtcblxuICB1dGlsLmVycm9yV2l0aFN0YWNrID0gZnVuY3Rpb24gZXJyb3JXaXRoU3RhY2soKSB7XG4gICAgLy8gRG9uJ3QgdGhyb3cgYW5kIGNhdGNoLiBUaGF0IG1ha2VzIGl0IGhhcmRlciBmb3IgdXNlcnMgdG8gZGVidWcgdGhlaXJcbiAgICAvLyBjb2RlIHdpdGggZXhjZXB0aW9uIGJyZWFrcG9pbnRzLCBhbmQgaXQncyB1bm5lY2Vzc2FyeSBzaW5jZSBhbGxcbiAgICAvLyBzdXBwb3J0ZWQgZW52aXJvbm1lbnRzIHBvcHVsYXRlIG5ldyBFcnJvcigpLnN0YWNrXG4gICAgcmV0dXJuIG5ldyBFcnJvcigpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGNhbGxlckZpbGUoKSB7XG4gICAgdmFyIHRyYWNlID0gbmV3IGokLlN0YWNrVHJhY2UodXRpbC5lcnJvcldpdGhTdGFjaygpKTtcbiAgICByZXR1cm4gdHJhY2UuZnJhbWVzWzJdLmZpbGU7XG4gIH1cblxuICB1dGlsLmphc21pbmVGaWxlID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXN1bHQgPSBjYWxsZXJGaWxlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfSkoKTtcblxuICBmdW5jdGlvbiBTdG9wSXRlcmF0aW9uKCkge31cbiAgU3RvcEl0ZXJhdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gIFN0b3BJdGVyYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3RvcEl0ZXJhdGlvbjtcblxuICB1dGlsLnZhbGlkYXRlVGltZW91dCA9IGZ1bmN0aW9uKHRpbWVvdXQsIG1zZ1ByZWZpeCkge1xuICAgIC8vIFRpbWVvdXRzIGFyZSBpbXBsZW1lbnRlZCB3aXRoIHNldFRpbWVvdXQsIHdoaWNoIG9ubHkgc3VwcG9ydHMgYSBsaW1pdGVkXG4gICAgLy8gcmFuZ2Ugb2YgdmFsdWVzLiBUaGUgbGltaXQgaXMgdW5zcGVjaWZpZWQsIGFzIGlzIHRoZSBiZWhhdmlvciB3aGVuIGl0J3NcbiAgICAvLyBleGNlZWRlZC4gQnV0IG9uIGFsbCBjdXJyZW50bHkgc3VwcG9ydGVkIEpTIHJ1bnRpbWVzLCBzZXRUaW1lb3V0IGNhbGxzXG4gICAgLy8gdGhlIGNhbGxiYWNrIGltbWVkaWF0ZWx5IHdoZW4gdGhlIHRpbWVvdXQgaXMgZ3JlYXRlciB0aGFuIDIxNDc0ODM2NDdcbiAgICAvLyAodGhlIG1heGltdW0gdmFsdWUgb2YgYSBzaWduZWQgMzIgYml0IGludGVnZXIpLlxuICAgIHZhciBtYXggPSAyMTQ3NDgzNjQ3O1xuXG4gICAgaWYgKHRpbWVvdXQgPiBtYXgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgKG1zZ1ByZWZpeCB8fCAnVGltZW91dCB2YWx1ZScpICsgJyBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuICcgKyBtYXhcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB1dGlsO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5TcGVjID0gZnVuY3Rpb24oaiQpIHtcbiAgLyoqXG4gICAqIEBpbnRlcmZhY2UgU3BlY1xuICAgKiBAc2VlIENvbmZpZ3VyYXRpb24jc3BlY0ZpbHRlclxuICAgKiBAc2luY2UgMi4wLjBcbiAgICovXG4gIGZ1bmN0aW9uIFNwZWMoYXR0cnMpIHtcbiAgICB0aGlzLmV4cGVjdGF0aW9uRmFjdG9yeSA9IGF0dHJzLmV4cGVjdGF0aW9uRmFjdG9yeTtcbiAgICB0aGlzLmFzeW5jRXhwZWN0YXRpb25GYWN0b3J5ID0gYXR0cnMuYXN5bmNFeHBlY3RhdGlvbkZhY3Rvcnk7XG4gICAgdGhpcy5yZXN1bHRDYWxsYmFjayA9IGF0dHJzLnJlc3VsdENhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XG4gICAgLyoqXG4gICAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGlzIHNwZWMuXG4gICAgICogQG5hbWUgU3BlYyNpZFxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICovXG4gICAgdGhpcy5pZCA9IGF0dHJzLmlkO1xuICAgIC8qKlxuICAgICAqIFRoZSBkZXNjcmlwdGlvbiBwYXNzZWQgdG8gdGhlIHtAbGluayBpdH0gdGhhdCBjcmVhdGVkIHRoaXMgc3BlYy5cbiAgICAgKiBAbmFtZSBTcGVjI2Rlc2NyaXB0aW9uXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKi9cbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gYXR0cnMuZGVzY3JpcHRpb24gfHwgJyc7XG4gICAgdGhpcy5xdWV1ZWFibGVGbiA9IGF0dHJzLnF1ZXVlYWJsZUZuO1xuICAgIHRoaXMuYmVmb3JlQW5kQWZ0ZXJGbnMgPVxuICAgICAgYXR0cnMuYmVmb3JlQW5kQWZ0ZXJGbnMgfHxcbiAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4geyBiZWZvcmVzOiBbXSwgYWZ0ZXJzOiBbXSB9O1xuICAgICAgfTtcbiAgICB0aGlzLnVzZXJDb250ZXh0ID1cbiAgICAgIGF0dHJzLnVzZXJDb250ZXh0IHx8XG4gICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfTtcbiAgICB0aGlzLm9uU3RhcnQgPSBhdHRycy5vblN0YXJ0IHx8IGZ1bmN0aW9uKCkge307XG4gICAgdGhpcy5hdXRvQ2xlYW5DbG9zdXJlcyA9XG4gICAgICBhdHRycy5hdXRvQ2xlYW5DbG9zdXJlcyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICEhYXR0cnMuYXV0b0NsZWFuQ2xvc3VyZXM7XG4gICAgdGhpcy5nZXRTcGVjTmFtZSA9XG4gICAgICBhdHRycy5nZXRTcGVjTmFtZSB8fFxuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH07XG4gICAgdGhpcy5leHBlY3RhdGlvblJlc3VsdEZhY3RvcnkgPVxuICAgICAgYXR0cnMuZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5IHx8IGZ1bmN0aW9uKCkge307XG4gICAgdGhpcy5vbkxhdGVFcnJvciA9IGF0dHJzLm9uTGF0ZUVycm9yIHx8IGZ1bmN0aW9uKCkge307XG4gICAgdGhpcy5xdWV1ZVJ1bm5lckZhY3RvcnkgPSBhdHRycy5xdWV1ZVJ1bm5lckZhY3RvcnkgfHwgZnVuY3Rpb24oKSB7fTtcbiAgICB0aGlzLmNhdGNoaW5nRXhjZXB0aW9ucyA9XG4gICAgICBhdHRycy5jYXRjaGluZ0V4Y2VwdGlvbnMgfHxcbiAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgdGhpcy50aHJvd09uRXhwZWN0YXRpb25GYWlsdXJlID0gISFhdHRycy50aHJvd09uRXhwZWN0YXRpb25GYWlsdXJlO1xuICAgIHRoaXMudGltZXIgPSBhdHRycy50aW1lciB8fCBuZXcgaiQuVGltZXIoKTtcblxuICAgIGlmICghdGhpcy5xdWV1ZWFibGVGbi5mbikge1xuICAgICAgdGhpcy5leGNsdWRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYgU3BlY1Jlc3VsdFxuICAgICAqIEBwcm9wZXJ0eSB7SW50fSBpZCAtIFRoZSB1bmlxdWUgaWQgb2YgdGhpcyBzcGVjLlxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkZXNjcmlwdGlvbiAtIFRoZSBkZXNjcmlwdGlvbiBwYXNzZWQgdG8gdGhlIHtAbGluayBpdH0gdGhhdCBjcmVhdGVkIHRoaXMgc3BlYy5cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gZnVsbE5hbWUgLSBUaGUgZnVsbCBkZXNjcmlwdGlvbiBpbmNsdWRpbmcgYWxsIGFuY2VzdG9ycyBvZiB0aGlzIHNwZWMuXG4gICAgICogQHByb3BlcnR5IHtFeHBlY3RhdGlvbltdfSBmYWlsZWRFeHBlY3RhdGlvbnMgLSBUaGUgbGlzdCBvZiBleHBlY3RhdGlvbnMgdGhhdCBmYWlsZWQgZHVyaW5nIGV4ZWN1dGlvbiBvZiB0aGlzIHNwZWMuXG4gICAgICogQHByb3BlcnR5IHtFeHBlY3RhdGlvbltdfSBwYXNzZWRFeHBlY3RhdGlvbnMgLSBUaGUgbGlzdCBvZiBleHBlY3RhdGlvbnMgdGhhdCBwYXNzZWQgZHVyaW5nIGV4ZWN1dGlvbiBvZiB0aGlzIHNwZWMuXG4gICAgICogQHByb3BlcnR5IHtFeHBlY3RhdGlvbltdfSBkZXByZWNhdGlvbldhcm5pbmdzIC0gVGhlIGxpc3Qgb2YgZGVwcmVjYXRpb24gd2FybmluZ3MgdGhhdCBvY2N1cnJlZCBkdXJpbmcgZXhlY3V0aW9uIHRoaXMgc3BlYy5cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gcGVuZGluZ1JlYXNvbiAtIElmIHRoZSBzcGVjIGlzIHtAbGluayBwZW5kaW5nfSwgdGhpcyB3aWxsIGJlIHRoZSByZWFzb24uXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IHN0YXR1cyAtIE9uY2UgdGhlIHNwZWMgaGFzIGNvbXBsZXRlZCwgdGhpcyBzdHJpbmcgcmVwcmVzZW50cyB0aGUgcGFzcy9mYWlsIHN0YXR1cyBvZiB0aGlzIHNwZWMuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIHRpbWUgaW4gbXMgdXNlZCBieSB0aGUgc3BlYyBleGVjdXRpb24sIGluY2x1ZGluZyBhbnkgYmVmb3JlL2FmdGVyRWFjaC5cbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gcHJvcGVydGllcyAtIFVzZXItc3VwcGxpZWQgcHJvcGVydGllcywgaWYgYW55LCB0aGF0IHdlcmUgc2V0IHVzaW5nIHtAbGluayBFbnYjc2V0U3BlY1Byb3BlcnR5fVxuICAgICAqIEBwcm9wZXJ0eSB7RGVidWdMb2dFbnRyeVtdfG51bGx9IGRlYnVnTG9ncyAtIE1lc3NhZ2VzLCBpZiBhbnksIHRoYXQgd2VyZSBsb2dnZWQgdXNpbmcge0BsaW5rIGphc21pbmUuZGVidWdMb2d9IGR1cmluZyBhIGZhaWxpbmcgc3BlYy5cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKi9cbiAgICB0aGlzLnJlc3VsdCA9IHtcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICBmdWxsTmFtZTogdGhpcy5nZXRGdWxsTmFtZSgpLFxuICAgICAgZmFpbGVkRXhwZWN0YXRpb25zOiBbXSxcbiAgICAgIHBhc3NlZEV4cGVjdGF0aW9uczogW10sXG4gICAgICBkZXByZWNhdGlvbldhcm5pbmdzOiBbXSxcbiAgICAgIHBlbmRpbmdSZWFzb246ICcnLFxuICAgICAgZHVyYXRpb246IG51bGwsXG4gICAgICBwcm9wZXJ0aWVzOiBudWxsLFxuICAgICAgZGVidWdMb2dzOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIFNwZWMucHJvdG90eXBlLmFkZEV4cGVjdGF0aW9uUmVzdWx0ID0gZnVuY3Rpb24ocGFzc2VkLCBkYXRhLCBpc0Vycm9yKSB7XG4gICAgdmFyIGV4cGVjdGF0aW9uUmVzdWx0ID0gdGhpcy5leHBlY3RhdGlvblJlc3VsdEZhY3RvcnkoZGF0YSk7XG4gICAgaWYgKHBhc3NlZCkge1xuICAgICAgdGhpcy5yZXN1bHQucGFzc2VkRXhwZWN0YXRpb25zLnB1c2goZXhwZWN0YXRpb25SZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMucHVzaChleHBlY3RhdGlvblJlc3VsdCk7XG5cbiAgICAgIGlmICh0aGlzLnRocm93T25FeHBlY3RhdGlvbkZhaWx1cmUgJiYgIWlzRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IGokLmVycm9ycy5FeHBlY3RhdGlvbkZhaWxlZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBTcGVjLnByb3RvdHlwZS5zZXRTcGVjUHJvcGVydHkgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5yZXN1bHQucHJvcGVydGllcyA9IHRoaXMucmVzdWx0LnByb3BlcnRpZXMgfHwge307XG4gICAgdGhpcy5yZXN1bHQucHJvcGVydGllc1trZXldID0gdmFsdWU7XG4gIH07XG5cbiAgU3BlYy5wcm90b3R5cGUuZXhwZWN0ID0gZnVuY3Rpb24oYWN0dWFsKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhwZWN0YXRpb25GYWN0b3J5KGFjdHVhbCwgdGhpcyk7XG4gIH07XG5cbiAgU3BlYy5wcm90b3R5cGUuZXhwZWN0QXN5bmMgPSBmdW5jdGlvbihhY3R1YWwpIHtcbiAgICByZXR1cm4gdGhpcy5hc3luY0V4cGVjdGF0aW9uRmFjdG9yeShhY3R1YWwsIHRoaXMpO1xuICB9O1xuXG4gIFNwZWMucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbihvbkNvbXBsZXRlLCBleGNsdWRlZCwgZmFpbFNwZWNXaXRoTm9FeHApIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgb25TdGFydCA9IHtcbiAgICAgIGZuOiBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIHNlbGYudGltZXIuc3RhcnQoKTtcbiAgICAgICAgc2VsZi5vblN0YXJ0KHNlbGYsIGRvbmUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgY29tcGxldGUgPSB7XG4gICAgICBmbjogZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICBpZiAoc2VsZi5hdXRvQ2xlYW5DbG9zdXJlcykge1xuICAgICAgICAgIHNlbGYucXVldWVhYmxlRm4uZm4gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYucmVzdWx0LnN0YXR1cyA9IHNlbGYuc3RhdHVzKGV4Y2x1ZGVkLCBmYWlsU3BlY1dpdGhOb0V4cCk7XG4gICAgICAgIHNlbGYucmVzdWx0LmR1cmF0aW9uID0gc2VsZi50aW1lci5lbGFwc2VkKCk7XG5cbiAgICAgICAgaWYgKHNlbGYucmVzdWx0LnN0YXR1cyAhPT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgICBzZWxmLnJlc3VsdC5kZWJ1Z0xvZ3MgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5yZXN1bHRDYWxsYmFjayhzZWxmLnJlc3VsdCwgZG9uZSk7XG4gICAgICB9LFxuICAgICAgdHlwZTogJ3NwZWNDbGVhbnVwJ1xuICAgIH07XG5cbiAgICB2YXIgZm5zID0gdGhpcy5iZWZvcmVBbmRBZnRlckZucygpO1xuXG4gICAgdmFyIHJ1bm5lckNvbmZpZyA9IHtcbiAgICAgIGlzTGVhZjogdHJ1ZSxcbiAgICAgIHF1ZXVlYWJsZUZuczogWy4uLmZucy5iZWZvcmVzLCB0aGlzLnF1ZXVlYWJsZUZuLCAuLi5mbnMuYWZ0ZXJzXSxcbiAgICAgIG9uRXhjZXB0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5vbkV4Y2VwdGlvbi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgfSxcbiAgICAgIG9uTXVsdGlwbGVEb25lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gSXNzdWUgYSBkZXByZWNhdGlvbi4gSW5jbHVkZSB0aGUgY29udGV4dCBvdXJzZWx2ZXMgYW5kIHBhc3NcbiAgICAgICAgLy8gaWdub3JlUnVubmFibGU6IHRydWUsIHNpbmNlIGdldHRpbmcgaGVyZSBhbHdheXMgbWVhbnMgdGhhdCB3ZSd2ZSBhbHJlYWR5XG4gICAgICAgIC8vIG1vdmVkIG9uIGFuZCB0aGUgY3VycmVudCBydW5uYWJsZSBpc24ndCB0aGUgb25lIHRoYXQgY2F1c2VkIHRoZSBwcm9ibGVtLlxuICAgICAgICBzZWxmLm9uTGF0ZUVycm9yKFxuICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICdBbiBhc3luY2hyb25vdXMgc3BlYywgYmVmb3JlRWFjaCwgb3IgYWZ0ZXJFYWNoIGZ1bmN0aW9uIGNhbGxlZCBpdHMgJyArXG4gICAgICAgICAgICAgIFwiJ2RvbmUnIGNhbGxiYWNrIG1vcmUgdGhhbiBvbmNlLlxcbihpbiBzcGVjOiBcIiArXG4gICAgICAgICAgICAgIHNlbGYuZ2V0RnVsbE5hbWUoKSArXG4gICAgICAgICAgICAgICcpJ1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHNlbGYucmVzdWx0LnN0YXR1cyA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgICBvbkNvbXBsZXRlKG5ldyBqJC5TdG9wRXhlY3V0aW9uRXJyb3IoJ3NwZWMgZmFpbGVkJykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZXJDb250ZXh0OiB0aGlzLnVzZXJDb250ZXh0KCksXG4gICAgICBydW5uYWJsZU5hbWU6IHRoaXMuZ2V0RnVsbE5hbWUuYmluZCh0aGlzKVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5tYXJrZWRQZW5kaW5nIHx8IGV4Y2x1ZGVkID09PSB0cnVlKSB7XG4gICAgICBydW5uZXJDb25maWcucXVldWVhYmxlRm5zID0gW107XG4gICAgfVxuXG4gICAgcnVubmVyQ29uZmlnLnF1ZXVlYWJsZUZucy51bnNoaWZ0KG9uU3RhcnQpO1xuICAgIHJ1bm5lckNvbmZpZy5xdWV1ZWFibGVGbnMucHVzaChjb21wbGV0ZSk7XG5cbiAgICB0aGlzLnF1ZXVlUnVubmVyRmFjdG9yeShydW5uZXJDb25maWcpO1xuICB9O1xuXG4gIFNwZWMucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZXN1bHQgPSB7XG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgZnVsbE5hbWU6IHRoaXMuZ2V0RnVsbE5hbWUoKSxcbiAgICAgIGZhaWxlZEV4cGVjdGF0aW9uczogW10sXG4gICAgICBwYXNzZWRFeHBlY3RhdGlvbnM6IFtdLFxuICAgICAgZGVwcmVjYXRpb25XYXJuaW5nczogW10sXG4gICAgICBwZW5kaW5nUmVhc29uOiB0aGlzLmV4Y2x1ZGVNZXNzYWdlLFxuICAgICAgZHVyYXRpb246IG51bGwsXG4gICAgICBwcm9wZXJ0aWVzOiBudWxsLFxuICAgICAgZGVidWdMb2dzOiBudWxsXG4gICAgfTtcbiAgICB0aGlzLm1hcmtlZFBlbmRpbmcgPSB0aGlzLm1hcmtlZEV4Y2x1ZGluZztcbiAgfTtcblxuICBTcGVjLnByb3RvdHlwZS5vbkV4Y2VwdGlvbiA9IGZ1bmN0aW9uIG9uRXhjZXB0aW9uKGUpIHtcbiAgICBpZiAoU3BlYy5pc1BlbmRpbmdTcGVjRXhjZXB0aW9uKGUpKSB7XG4gICAgICB0aGlzLnBlbmQoZXh0cmFjdEN1c3RvbVBlbmRpbmdNZXNzYWdlKGUpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZSBpbnN0YW5jZW9mIGokLmVycm9ycy5FeHBlY3RhdGlvbkZhaWxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYWRkRXhwZWN0YXRpb25SZXN1bHQoXG4gICAgICBmYWxzZSxcbiAgICAgIHtcbiAgICAgICAgbWF0Y2hlck5hbWU6ICcnLFxuICAgICAgICBwYXNzZWQ6IGZhbHNlLFxuICAgICAgICBleHBlY3RlZDogJycsXG4gICAgICAgIGFjdHVhbDogJycsXG4gICAgICAgIGVycm9yOiBlXG4gICAgICB9LFxuICAgICAgdHJ1ZVxuICAgICk7XG4gIH07XG5cbiAgLypcbiAgICogTWFya3Mgc3RhdGUgYXMgcGVuZGluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW21lc3NhZ2VdIEFuIG9wdGlvbmFsIHJlYXNvbiBtZXNzYWdlXG4gICAqL1xuICBTcGVjLnByb3RvdHlwZS5wZW5kID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIHRoaXMubWFya2VkUGVuZGluZyA9IHRydWU7XG4gICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgIHRoaXMucmVzdWx0LnBlbmRpbmdSZWFzb24gPSBtZXNzYWdlO1xuICAgIH1cbiAgfTtcblxuICAvKlxuICAgKiBMaWtlIHtAbGluayBTcGVjI3BlbmR9LCBidXQgcGVuZGluZyBzdGF0ZSB3aWxsIHN1cnZpdmUge0BsaW5rIFNwZWMjcmVzZXR9XG4gICAqIFVzZWZ1bCBmb3IgZml0LCB4aXQsIHdoZXJlIHBlbmRpbmcgc3RhdGUgcmVtYWlucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFttZXNzYWdlXSBBbiBvcHRpb25hbCByZWFzb24gbWVzc2FnZVxuICAgKi9cbiAgU3BlYy5wcm90b3R5cGUuZXhjbHVkZSA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1hcmtlZEV4Y2x1ZGluZyA9IHRydWU7XG4gICAgaWYgKHRoaXMubWVzc2FnZSkge1xuICAgICAgdGhpcy5leGNsdWRlTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgfVxuICAgIHRoaXMucGVuZChtZXNzYWdlKTtcbiAgfTtcblxuICBTcGVjLnByb3RvdHlwZS5nZXRSZXN1bHQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlc3VsdC5zdGF0dXMgPSB0aGlzLnN0YXR1cygpO1xuICAgIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgfTtcblxuICBTcGVjLnByb3RvdHlwZS5zdGF0dXMgPSBmdW5jdGlvbihleGNsdWRlZCwgZmFpbFNwZWNXaXRoTm9FeHBlY3RhdGlvbnMpIHtcbiAgICBpZiAoZXhjbHVkZWQgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiAnZXhjbHVkZWQnO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1hcmtlZFBlbmRpbmcpIHtcbiAgICAgIHJldHVybiAncGVuZGluZyc7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdGhpcy5yZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zLmxlbmd0aCA+IDAgfHxcbiAgICAgIChmYWlsU3BlY1dpdGhOb0V4cGVjdGF0aW9ucyAmJlxuICAgICAgICB0aGlzLnJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMubGVuZ3RoICtcbiAgICAgICAgICB0aGlzLnJlc3VsdC5wYXNzZWRFeHBlY3RhdGlvbnMubGVuZ3RoID09PVxuICAgICAgICAgIDApXG4gICAgKSB7XG4gICAgICByZXR1cm4gJ2ZhaWxlZCc7XG4gICAgfVxuXG4gICAgcmV0dXJuICdwYXNzZWQnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgZnVsbCBkZXNjcmlwdGlvbiBpbmNsdWRpbmcgYWxsIGFuY2VzdG9ycyBvZiB0aGlzIHNwZWMuXG4gICAqIEBuYW1lIFNwZWMjZ2V0RnVsbE5hbWVcbiAgICogQGZ1bmN0aW9uXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKi9cbiAgU3BlYy5wcm90b3R5cGUuZ2V0RnVsbE5hbWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTcGVjTmFtZSh0aGlzKTtcbiAgfTtcblxuICBTcGVjLnByb3RvdHlwZS5hZGREZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbihkZXByZWNhdGlvbikge1xuICAgIGlmICh0eXBlb2YgZGVwcmVjYXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICBkZXByZWNhdGlvbiA9IHsgbWVzc2FnZTogZGVwcmVjYXRpb24gfTtcbiAgICB9XG4gICAgdGhpcy5yZXN1bHQuZGVwcmVjYXRpb25XYXJuaW5ncy5wdXNoKFxuICAgICAgdGhpcy5leHBlY3RhdGlvblJlc3VsdEZhY3RvcnkoZGVwcmVjYXRpb24pXG4gICAgKTtcbiAgfTtcblxuICBTcGVjLnByb3RvdHlwZS5kZWJ1Z0xvZyA9IGZ1bmN0aW9uKG1zZykge1xuICAgIGlmICghdGhpcy5yZXN1bHQuZGVidWdMb2dzKSB7XG4gICAgICB0aGlzLnJlc3VsdC5kZWJ1Z0xvZ3MgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiBEZWJ1Z0xvZ0VudHJ5XG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0aGF0IHdhcyBwYXNzZWQgdG8ge0BsaW5rIGphc21pbmUuZGVidWdMb2d9LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lc3RhbXAgLSBUaGUgdGltZSB3aGVuIHRoZSBlbnRyeSB3YXMgYWRkZWQsIGluXG4gICAgICogbWlsbGlzZWNvbmRzIGZyb20gdGhlIHNwZWMncyBzdGFydCB0aW1lXG4gICAgICovXG4gICAgdGhpcy5yZXN1bHQuZGVidWdMb2dzLnB1c2goe1xuICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgdGltZXN0YW1wOiB0aGlzLnRpbWVyLmVsYXBzZWQoKVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBleHRyYWN0Q3VzdG9tUGVuZGluZ01lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGZ1bGxNZXNzYWdlID0gZS50b1N0cmluZygpLFxuICAgICAgYm9pbGVycGxhdGVTdGFydCA9IGZ1bGxNZXNzYWdlLmluZGV4T2YoU3BlYy5wZW5kaW5nU3BlY0V4Y2VwdGlvbk1lc3NhZ2UpLFxuICAgICAgYm9pbGVycGxhdGVFbmQgPVxuICAgICAgICBib2lsZXJwbGF0ZVN0YXJ0ICsgU3BlYy5wZW5kaW5nU3BlY0V4Y2VwdGlvbk1lc3NhZ2UubGVuZ3RoO1xuXG4gICAgcmV0dXJuIGZ1bGxNZXNzYWdlLnN1YnN0cihib2lsZXJwbGF0ZUVuZCk7XG4gIH07XG5cbiAgU3BlYy5wZW5kaW5nU3BlY0V4Y2VwdGlvbk1lc3NhZ2UgPSAnPT4gbWFya2VkIFBlbmRpbmcnO1xuXG4gIFNwZWMuaXNQZW5kaW5nU3BlY0V4Y2VwdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gISEoXG4gICAgICBlICYmXG4gICAgICBlLnRvU3RyaW5nICYmXG4gICAgICBlLnRvU3RyaW5nKCkuaW5kZXhPZihTcGVjLnBlbmRpbmdTcGVjRXhjZXB0aW9uTWVzc2FnZSkgIT09IC0xXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogQGludGVyZmFjZSBTcGVjXG4gICAqIEBzZWUgQ29uZmlndXJhdGlvbiNzcGVjRmlsdGVyXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3BlYy5wcm90b3R5cGUsICdtZXRhZGF0YScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLm1ldGFkYXRhXykge1xuICAgICAgICB0aGlzLm1ldGFkYXRhXyA9IHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoaXMgc3BlYy5cbiAgICAgICAgICAgKiBAbmFtZSBTcGVjI2lkXG4gICAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBpZDogdGhpcy5pZCxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBkZXNjcmlwdGlvbiBwYXNzZWQgdG8gdGhlIHtAbGluayBpdH0gdGhhdCBjcmVhdGVkIHRoaXMgc3BlYy5cbiAgICAgICAgICAgKiBAbmFtZSBTcGVjI2Rlc2NyaXB0aW9uXG4gICAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBmdWxsIGRlc2NyaXB0aW9uIGluY2x1ZGluZyBhbGwgYW5jZXN0b3JzIG9mIHRoaXMgc3BlYy5cbiAgICAgICAgICAgKiBAbmFtZSBTcGVjI2dldEZ1bGxOYW1lXG4gICAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBnZXRGdWxsTmFtZTogdGhpcy5nZXRGdWxsTmFtZS5iaW5kKHRoaXMpXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLm1ldGFkYXRhXztcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBTcGVjO1xufTtcblxuLypqc2hpbnQgYml0d2lzZTogZmFsc2UqL1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLk9yZGVyID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIE9yZGVyKG9wdGlvbnMpIHtcbiAgICB0aGlzLnJhbmRvbSA9ICdyYW5kb20nIGluIG9wdGlvbnMgPyBvcHRpb25zLnJhbmRvbSA6IHRydWU7XG4gICAgdmFyIHNlZWQgPSAodGhpcy5zZWVkID0gb3B0aW9ucy5zZWVkIHx8IGdlbmVyYXRlU2VlZCgpKTtcbiAgICB0aGlzLnNvcnQgPSB0aGlzLnJhbmRvbSA/IHJhbmRvbU9yZGVyIDogbmF0dXJhbE9yZGVyO1xuXG4gICAgZnVuY3Rpb24gbmF0dXJhbE9yZGVyKGl0ZW1zKSB7XG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmFuZG9tT3JkZXIoaXRlbXMpIHtcbiAgICAgIHZhciBjb3B5ID0gaXRlbXMuc2xpY2UoKTtcbiAgICAgIGNvcHkuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBqZW5raW5zSGFzaChzZWVkICsgYS5pZCkgLSBqZW5raW5zSGFzaChzZWVkICsgYi5pZCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlU2VlZCgpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoTWF0aC5yYW5kb20oKSkuc2xpY2UoLTUpO1xuICAgIH1cblxuICAgIC8vIEJvYiBKZW5raW5zIE9uZS1hdC1hLVRpbWUgSGFzaCBhbGdvcml0aG0gaXMgYSBub24tY3J5cHRvZ3JhcGhpYyBoYXNoIGZ1bmN0aW9uXG4gICAgLy8gdXNlZCB0byBnZXQgYSBkaWZmZXJlbnQgb3V0cHV0IHdoZW4gdGhlIGtleSBjaGFuZ2VzIHNsaWdodGx5LlxuICAgIC8vIFdlIHVzZSB5b3VyIHJldHVybiB0byBzb3J0IHRoZSBjaGlsZHJlbiByYW5kb21seSBpbiBhIGNvbnNpc3RlbnQgd2F5IHdoZW5cbiAgICAvLyB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYSBzZWVkXG5cbiAgICBmdW5jdGlvbiBqZW5raW5zSGFzaChrZXkpIHtcbiAgICAgIHZhciBoYXNoLCBpO1xuICAgICAgZm9yIChoYXNoID0gaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaGFzaCArPSBrZXkuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaGFzaCArPSBoYXNoIDw8IDEwO1xuICAgICAgICBoYXNoIF49IGhhc2ggPj4gNjtcbiAgICAgIH1cbiAgICAgIGhhc2ggKz0gaGFzaCA8PCAzO1xuICAgICAgaGFzaCBePSBoYXNoID4+IDExO1xuICAgICAgaGFzaCArPSBoYXNoIDw8IDE1O1xuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIE9yZGVyO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5FbnYgPSBmdW5jdGlvbihqJCkge1xuICAvKipcbiAgICogQGNsYXNzIEVudlxuICAgKiBAc2luY2UgMi4wLjBcbiAgICogQGNsYXNzZGVzYyBUaGUgSmFzbWluZSBlbnZpcm9ubWVudC48YnI+XG4gICAqIF9Ob3RlOl8gRG8gbm90IGNvbnN0cnVjdCB0aGlzIGRpcmVjdGx5LiBZb3UgY2FuIG9idGFpbiB0aGUgRW52IGluc3RhbmNlIGJ5XG4gICAqIGNhbGxpbmcge0BsaW5rIGphc21pbmUuZ2V0RW52fS5cbiAgICogQGhpZGVjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gRW52KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZ2xvYmFsID0gb3B0aW9ucy5nbG9iYWwgfHwgaiQuZ2V0R2xvYmFsKCk7XG5cbiAgICB2YXIgdG90YWxTcGVjc0RlZmluZWQgPSAwO1xuXG4gICAgdmFyIHJlYWxTZXRUaW1lb3V0ID0gZ2xvYmFsLnNldFRpbWVvdXQ7XG4gICAgdmFyIHJlYWxDbGVhclRpbWVvdXQgPSBnbG9iYWwuY2xlYXJUaW1lb3V0O1xuICAgIHZhciBjbGVhclN0YWNrID0gaiQuZ2V0Q2xlYXJTdGFjayhnbG9iYWwpO1xuICAgIHRoaXMuY2xvY2sgPSBuZXcgaiQuQ2xvY2soXG4gICAgICBnbG9iYWwsXG4gICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBqJC5EZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIoKTtcbiAgICAgIH0sXG4gICAgICBuZXcgaiQuTW9ja0RhdGUoZ2xvYmFsKVxuICAgICk7XG5cbiAgICB2YXIgcnVubmFibGVSZXNvdXJjZXMgPSB7fTtcblxuICAgIHZhciBjdXJyZW50U3BlYyA9IG51bGw7XG4gICAgdmFyIGN1cnJlbnRseUV4ZWN1dGluZ1N1aXRlcyA9IFtdO1xuICAgIHZhciBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZSA9IG51bGw7XG4gICAgdmFyIGhhc0ZhaWx1cmVzID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHJlcHJlc2VudHMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIHRvIGNvbmZpZ3VyZSBKYXNtaW5lLlxuICAgICAqIE9wdGlvbnMgdGhhdCBhcmUgbm90IHByb3ZpZGVkIHdpbGwgdXNlIHRoZWlyIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqIEBzZWUgRW52I2NvbmZpZ3VyZVxuICAgICAqIEBpbnRlcmZhY2UgQ29uZmlndXJhdGlvblxuICAgICAqIEBzaW5jZSAzLjMuMFxuICAgICAqL1xuICAgIHZhciBjb25maWcgPSB7XG4gICAgICAvKipcbiAgICAgICAqIFdoZXRoZXIgdG8gcmFuZG9taXplIHNwZWMgZXhlY3V0aW9uIG9yZGVyXG4gICAgICAgKiBAbmFtZSBDb25maWd1cmF0aW9uI3JhbmRvbVxuICAgICAgICogQHNpbmNlIDMuMy4wXG4gICAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgKi9cbiAgICAgIHJhbmRvbTogdHJ1ZSxcbiAgICAgIC8qKlxuICAgICAgICogU2VlZCB0byB1c2UgYXMgdGhlIGJhc2lzIG9mIHJhbmRvbWl6YXRpb24uXG4gICAgICAgKiBOdWxsIGNhdXNlcyB0aGUgc2VlZCB0byBiZSBkZXRlcm1pbmVkIHJhbmRvbWx5IGF0IHRoZSBzdGFydCBvZiBleGVjdXRpb24uXG4gICAgICAgKiBAbmFtZSBDb25maWd1cmF0aW9uI3NlZWRcbiAgICAgICAqIEBzaW5jZSAzLjMuMFxuICAgICAgICogQHR5cGUgKG51bWJlcnxzdHJpbmcpXG4gICAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICAgKi9cbiAgICAgIHNlZWQ6IG51bGwsXG4gICAgICAvKipcbiAgICAgICAqIFdoZXRoZXIgdG8gc3RvcCBleGVjdXRpb24gb2YgdGhlIHN1aXRlIGFmdGVyIHRoZSBmaXJzdCBzcGVjIGZhaWx1cmVcbiAgICAgICAqIEBuYW1lIENvbmZpZ3VyYXRpb24jc3RvcE9uU3BlY0ZhaWx1cmVcbiAgICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAgICogQHR5cGUgQm9vbGVhblxuICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAqL1xuICAgICAgc3RvcE9uU3BlY0ZhaWx1cmU6IGZhbHNlLFxuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIHRvIGZhaWwgdGhlIHNwZWMgaWYgaXQgcmFuIG5vIGV4cGVjdGF0aW9ucy4gQnkgZGVmYXVsdFxuICAgICAgICogYSBzcGVjIHRoYXQgcmFuIG5vIGV4cGVjdGF0aW9ucyBpcyByZXBvcnRlZCBhcyBwYXNzZWQuIFNldHRpbmcgdGhpc1xuICAgICAgICogdG8gdHJ1ZSB3aWxsIHJlcG9ydCBzdWNoIHNwZWMgYXMgYSBmYWlsdXJlLlxuICAgICAgICogQG5hbWUgQ29uZmlndXJhdGlvbiNmYWlsU3BlY1dpdGhOb0V4cGVjdGF0aW9uc1xuICAgICAgICogQHNpbmNlIDMuNS4wXG4gICAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICovXG4gICAgICBmYWlsU3BlY1dpdGhOb0V4cGVjdGF0aW9uczogZmFsc2UsXG4gICAgICAvKipcbiAgICAgICAqIFdoZXRoZXIgdG8gY2F1c2Ugc3BlY3MgdG8gb25seSBoYXZlIG9uZSBleHBlY3RhdGlvbiBmYWlsdXJlLlxuICAgICAgICogQG5hbWUgQ29uZmlndXJhdGlvbiNzdG9wU3BlY09uRXhwZWN0YXRpb25GYWlsdXJlXG4gICAgICAgKiBAc2luY2UgMy4zLjBcbiAgICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgKi9cbiAgICAgIHN0b3BTcGVjT25FeHBlY3RhdGlvbkZhaWx1cmU6IGZhbHNlLFxuICAgICAgLyoqXG4gICAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBzcGVjIGFuZCByZXR1cm5zIHRydWUgaWYgaXQgc2hvdWxkIGJlIGV4ZWN1dGVkXG4gICAgICAgKiBvciBmYWxzZSBpZiBpdCBzaG91bGQgYmUgc2tpcHBlZC5cbiAgICAgICAqIEBjYWxsYmFjayBTcGVjRmlsdGVyXG4gICAgICAgKiBAcGFyYW0ge1NwZWN9IHNwZWMgLSBUaGUgc3BlYyB0aGF0IHRoZSBmaWx0ZXIgaXMgYmVpbmcgYXBwbGllZCB0by5cbiAgICAgICAqIEByZXR1cm4gYm9vbGVhblxuICAgICAgICovXG4gICAgICAvKipcbiAgICAgICAqIEZ1bmN0aW9uIHRvIHVzZSB0byBmaWx0ZXIgc3BlY3NcbiAgICAgICAqIEBuYW1lIENvbmZpZ3VyYXRpb24jc3BlY0ZpbHRlclxuICAgICAgICogQHNpbmNlIDMuMy4wXG4gICAgICAgKiBAdHlwZSBTcGVjRmlsdGVyXG4gICAgICAgKiBAZGVmYXVsdCBBIGZ1bmN0aW9uIHRoYXQgYWx3YXlzIHJldHVybnMgdHJ1ZS5cbiAgICAgICAqL1xuICAgICAgc3BlY0ZpbHRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogV2hldGhlciBvciBub3QgcmVwb3J0ZXJzIHNob3VsZCBoaWRlIGRpc2FibGVkIHNwZWNzIGZyb20gdGhlaXIgb3V0cHV0LlxuICAgICAgICogQ3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGJ5IEphc21pbmUncyBIVE1MUmVwb3J0ZXJcbiAgICAgICAqIEBuYW1lIENvbmZpZ3VyYXRpb24jaGlkZURpc2FibGVkXG4gICAgICAgKiBAc2luY2UgMy4zLjBcbiAgICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgKi9cbiAgICAgIGhpZGVEaXNhYmxlZDogZmFsc2UsXG4gICAgICAvKipcbiAgICAgICAqIENsZWFuIGNsb3N1cmVzIHdoZW4gYSBzdWl0ZSBpcyBkb25lIHJ1bm5pbmcgKGRvbmUgYnkgY2xlYXJpbmcgdGhlIHN0b3JlZCBmdW5jdGlvbiByZWZlcmVuY2UpLlxuICAgICAgICogVGhpcyBwcmV2ZW50cyBtZW1vcnkgbGVha3MsIGJ1dCB5b3Ugd29uJ3QgYmUgYWJsZSB0byBydW4gamFzbWluZSBtdWx0aXBsZSB0aW1lcy5cbiAgICAgICAqIEBuYW1lIENvbmZpZ3VyYXRpb24jYXV0b0NsZWFuQ2xvc3VyZXNcbiAgICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAqL1xuICAgICAgYXV0b0NsZWFuQ2xvc3VyZXM6IHRydWUsXG4gICAgICAvKipcbiAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRvIGlzc3VlIHdhcm5pbmdzIGZvciBjZXJ0YWluIGRlcHJlY2F0ZWQgZnVuY3Rpb25hbGl0eVxuICAgICAgICogZXZlcnkgdGltZSBpdCdzIHVzZWQuIElmIG5vdCBzZXQgb3Igc2V0IHRvIGZhbHNlLCBkZXByZWNhdGlvbiB3YXJuaW5nc1xuICAgICAgICogZm9yIG1ldGhvZHMgdGhhdCB0ZW5kIHRvIGJlIGNhbGxlZCBmcmVxdWVudGx5IHdpbGwgYmUgaXNzdWVkIG9ubHkgb25jZVxuICAgICAgICogb3Igb3RoZXJ3aXNlIHRocm90dGxlZCB0byB0byBwcmV2ZW50IHRoZSBzdWl0ZSBvdXRwdXQgZnJvbSBiZWluZyBmbG9vZGVkXG4gICAgICAgKiB3aXRoIHdhcm5pbmdzLlxuICAgICAgICogQG5hbWUgQ29uZmlndXJhdGlvbiN2ZXJib3NlRGVwcmVjYXRpb25zXG4gICAgICAgKiBAc2luY2UgMy42LjBcbiAgICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgKi9cbiAgICAgIHZlcmJvc2VEZXByZWNhdGlvbnM6IGZhbHNlXG4gICAgfTtcblxuICAgIHZhciBjdXJyZW50U3VpdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjdXJyZW50bHlFeGVjdXRpbmdTdWl0ZXNbY3VycmVudGx5RXhlY3V0aW5nU3VpdGVzLmxlbmd0aCAtIDFdO1xuICAgIH07XG5cbiAgICB2YXIgY3VycmVudFJ1bm5hYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY3VycmVudFNwZWMgfHwgY3VycmVudFN1aXRlKCk7XG4gICAgfTtcblxuICAgIHZhciBnbG9iYWxFcnJvcnMgPSBudWxsO1xuXG4gICAgdmFyIGluc3RhbGxHbG9iYWxFcnJvcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChnbG9iYWxFcnJvcnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBnbG9iYWxFcnJvcnMgPSBuZXcgaiQuR2xvYmFsRXJyb3JzKCk7XG4gICAgICBnbG9iYWxFcnJvcnMuaW5zdGFsbCgpO1xuICAgIH07XG5cbiAgICBpZiAoIW9wdGlvbnMuc3VwcHJlc3NMb2FkRXJyb3JzKSB7XG4gICAgICBpbnN0YWxsR2xvYmFsRXJyb3JzKCk7XG4gICAgICBnbG9iYWxFcnJvcnMucHVzaExpc3RlbmVyKGZ1bmN0aW9uKFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgbGluZW5vLFxuICAgICAgICBjb2xObyxcbiAgICAgICAgZXJyXG4gICAgICApIHtcbiAgICAgICAgdG9wU3VpdGUucmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9ucy5wdXNoKHtcbiAgICAgICAgICBwYXNzZWQ6IGZhbHNlLFxuICAgICAgICAgIGdsb2JhbEVycm9yVHlwZTogJ2xvYWQnLFxuICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgc3RhY2s6IGVyciAmJiBlcnIuc3RhY2ssXG4gICAgICAgICAgZmlsZW5hbWU6IGZpbGVuYW1lLFxuICAgICAgICAgIGxpbmVubzogbGluZW5vXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlIHlvdXIgamFzbWluZSBlbnZpcm9ubWVudFxuICAgICAqIEBuYW1lIEVudiNjb25maWd1cmVcbiAgICAgKiBAc2luY2UgMy4zLjBcbiAgICAgKiBAYXJndW1lbnQge0NvbmZpZ3VyYXRpb259IGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICB0aGlzLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgIHZhciBib29sZWFuUHJvcHMgPSBbXG4gICAgICAgICdyYW5kb20nLFxuICAgICAgICAnZmFpbFNwZWNXaXRoTm9FeHBlY3RhdGlvbnMnLFxuICAgICAgICAnaGlkZURpc2FibGVkJyxcbiAgICAgICAgJ3N0b3BPblNwZWNGYWlsdXJlJyxcbiAgICAgICAgJ3N0b3BTcGVjT25FeHBlY3RhdGlvbkZhaWx1cmUnLFxuICAgICAgICAnYXV0b0NsZWFuQ2xvc3VyZXMnXG4gICAgICBdO1xuXG4gICAgICBib29sZWFuUHJvcHMuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlndXJhdGlvbltwcm9wXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjb25maWdbcHJvcF0gPSAhIWNvbmZpZ3VyYXRpb25bcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoY29uZmlndXJhdGlvbi5zcGVjRmlsdGVyKSB7XG4gICAgICAgIGNvbmZpZy5zcGVjRmlsdGVyID0gY29uZmlndXJhdGlvbi5zcGVjRmlsdGVyO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZ3VyYXRpb24uc2VlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uZmlnLnNlZWQgPSBjb25maWd1cmF0aW9uLnNlZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWd1cmF0aW9uLmhhc093blByb3BlcnR5KCd2ZXJib3NlRGVwcmVjYXRpb25zJykpIHtcbiAgICAgICAgY29uZmlnLnZlcmJvc2VEZXByZWNhdGlvbnMgPSBjb25maWd1cmF0aW9uLnZlcmJvc2VEZXByZWNhdGlvbnM7XG4gICAgICAgIGRlcHJlY2F0b3IudmVyYm9zZURlcHJlY2F0aW9ucyhjb25maWcudmVyYm9zZURlcHJlY2F0aW9ucyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBjb25maWd1cmF0aW9uIGZvciB5b3VyIGphc21pbmUgZW52aXJvbm1lbnRcbiAgICAgKiBAbmFtZSBFbnYjY29uZmlndXJhdGlvblxuICAgICAqIEBzaW5jZSAzLjMuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtDb25maWd1cmF0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gY29uZmlnKSB7XG4gICAgICAgIHJlc3VsdFtwcm9wZXJ0eV0gPSBjb25maWdbcHJvcGVydHldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgdGhpcy5zZXREZWZhdWx0U3B5U3RyYXRlZ3kgPSBmdW5jdGlvbihkZWZhdWx0U3RyYXRlZ3lGbikge1xuICAgICAgaWYgKCFjdXJyZW50UnVubmFibGUoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0RlZmF1bHQgc3B5IHN0cmF0ZWd5IG11c3QgYmUgc2V0IGluIGEgYmVmb3JlIGZ1bmN0aW9uIG9yIGEgc3BlYydcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJ1bm5hYmxlUmVzb3VyY2VzW1xuICAgICAgICBjdXJyZW50UnVubmFibGUoKS5pZFxuICAgICAgXS5kZWZhdWx0U3RyYXRlZ3lGbiA9IGRlZmF1bHRTdHJhdGVneUZuO1xuICAgIH07XG5cbiAgICB0aGlzLmFkZFNweVN0cmF0ZWd5ID0gZnVuY3Rpb24obmFtZSwgZm4pIHtcbiAgICAgIGlmICghY3VycmVudFJ1bm5hYmxlKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdDdXN0b20gc3B5IHN0cmF0ZWdpZXMgbXVzdCBiZSBhZGRlZCBpbiBhIGJlZm9yZSBmdW5jdGlvbiBvciBhIHNwZWMnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBydW5uYWJsZVJlc291cmNlc1tjdXJyZW50UnVubmFibGUoKS5pZF0uY3VzdG9tU3B5U3RyYXRlZ2llc1tuYW1lXSA9IGZuO1xuICAgIH07XG5cbiAgICB0aGlzLmFkZEN1c3RvbUVxdWFsaXR5VGVzdGVyID0gZnVuY3Rpb24odGVzdGVyKSB7XG4gICAgICBpZiAoIWN1cnJlbnRSdW5uYWJsZSgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnQ3VzdG9tIEVxdWFsaXRpZXMgbXVzdCBiZSBhZGRlZCBpbiBhIGJlZm9yZSBmdW5jdGlvbiBvciBhIHNwZWMnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBydW5uYWJsZVJlc291cmNlc1tjdXJyZW50UnVubmFibGUoKS5pZF0uY3VzdG9tRXF1YWxpdHlUZXN0ZXJzLnB1c2goXG4gICAgICAgIHRlc3RlclxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgdGhpcy5hZGRNYXRjaGVycyA9IGZ1bmN0aW9uKG1hdGNoZXJzVG9BZGQpIHtcbiAgICAgIGlmICghY3VycmVudFJ1bm5hYmxlKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdNYXRjaGVycyBtdXN0IGJlIGFkZGVkIGluIGEgYmVmb3JlIGZ1bmN0aW9uIG9yIGEgc3BlYydcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZhciBjdXN0b21NYXRjaGVycyA9XG4gICAgICAgIHJ1bm5hYmxlUmVzb3VyY2VzW2N1cnJlbnRSdW5uYWJsZSgpLmlkXS5jdXN0b21NYXRjaGVycztcblxuICAgICAgZm9yICh2YXIgbWF0Y2hlck5hbWUgaW4gbWF0Y2hlcnNUb0FkZCkge1xuICAgICAgICBjdXN0b21NYXRjaGVyc1ttYXRjaGVyTmFtZV0gPSBtYXRjaGVyc1RvQWRkW21hdGNoZXJOYW1lXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5hZGRBc3luY01hdGNoZXJzID0gZnVuY3Rpb24obWF0Y2hlcnNUb0FkZCkge1xuICAgICAgaWYgKCFjdXJyZW50UnVubmFibGUoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0FzeW5jIE1hdGNoZXJzIG11c3QgYmUgYWRkZWQgaW4gYSBiZWZvcmUgZnVuY3Rpb24gb3IgYSBzcGVjJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdmFyIGN1c3RvbUFzeW5jTWF0Y2hlcnMgPVxuICAgICAgICBydW5uYWJsZVJlc291cmNlc1tjdXJyZW50UnVubmFibGUoKS5pZF0uY3VzdG9tQXN5bmNNYXRjaGVycztcblxuICAgICAgZm9yICh2YXIgbWF0Y2hlck5hbWUgaW4gbWF0Y2hlcnNUb0FkZCkge1xuICAgICAgICBjdXN0b21Bc3luY01hdGNoZXJzW21hdGNoZXJOYW1lXSA9IG1hdGNoZXJzVG9BZGRbbWF0Y2hlck5hbWVdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmFkZEN1c3RvbU9iamVjdEZvcm1hdHRlciA9IGZ1bmN0aW9uKGZvcm1hdHRlcikge1xuICAgICAgaWYgKCFjdXJyZW50UnVubmFibGUoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0N1c3RvbSBvYmplY3QgZm9ybWF0dGVycyBtdXN0IGJlIGFkZGVkIGluIGEgYmVmb3JlIGZ1bmN0aW9uIG9yIGEgc3BlYydcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcnVubmFibGVSZXNvdXJjZXNbY3VycmVudFJ1bm5hYmxlKCkuaWRdLmN1c3RvbU9iamVjdEZvcm1hdHRlcnMucHVzaChcbiAgICAgICAgZm9ybWF0dGVyXG4gICAgICApO1xuICAgIH07XG5cbiAgICBqJC5FeHBlY3RhdGlvbi5hZGRDb3JlTWF0Y2hlcnMoaiQubWF0Y2hlcnMpO1xuICAgIGokLkV4cGVjdGF0aW9uLmFkZEFzeW5jQ29yZU1hdGNoZXJzKGokLmFzeW5jTWF0Y2hlcnMpO1xuXG4gICAgdmFyIG5leHRTcGVjSWQgPSAwO1xuICAgIHZhciBnZXROZXh0U3BlY0lkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJ3NwZWMnICsgbmV4dFNwZWNJZCsrO1xuICAgIH07XG5cbiAgICB2YXIgbmV4dFN1aXRlSWQgPSAwO1xuICAgIHZhciBnZXROZXh0U3VpdGVJZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICdzdWl0ZScgKyBuZXh0U3VpdGVJZCsrO1xuICAgIH07XG5cbiAgICB2YXIgbWFrZVByZXR0eVByaW50ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdXN0b21PYmplY3RGb3JtYXR0ZXJzID1cbiAgICAgICAgcnVubmFibGVSZXNvdXJjZXNbY3VycmVudFJ1bm5hYmxlKCkuaWRdLmN1c3RvbU9iamVjdEZvcm1hdHRlcnM7XG4gICAgICByZXR1cm4gaiQubWFrZVByZXR0eVByaW50ZXIoY3VzdG9tT2JqZWN0Rm9ybWF0dGVycyk7XG4gICAgfTtcblxuICAgIHZhciBtYWtlTWF0Y2hlcnNVdGlsID0gZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBjciA9IGN1cnJlbnRSdW5uYWJsZSgpO1xuXG4gICAgICBpZiAoY3IpIHtcbiAgICAgICAgY29uc3QgY3VzdG9tRXF1YWxpdHlUZXN0ZXJzID1cbiAgICAgICAgICBydW5uYWJsZVJlc291cmNlc1tjci5pZF0uY3VzdG9tRXF1YWxpdHlUZXN0ZXJzO1xuICAgICAgICByZXR1cm4gbmV3IGokLk1hdGNoZXJzVXRpbCh7XG4gICAgICAgICAgY3VzdG9tVGVzdGVyczogY3VzdG9tRXF1YWxpdHlUZXN0ZXJzLFxuICAgICAgICAgIHBwOiBtYWtlUHJldHR5UHJpbnRlcigpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBqJC5NYXRjaGVyc1V0aWwoeyBwcDogaiQuYmFzaWNQcmV0dHlQcmludGVyXyB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGV4cGVjdGF0aW9uRmFjdG9yeSA9IGZ1bmN0aW9uKGFjdHVhbCwgc3BlYykge1xuICAgICAgcmV0dXJuIGokLkV4cGVjdGF0aW9uLmZhY3Rvcnkoe1xuICAgICAgICBtYXRjaGVyc1V0aWw6IG1ha2VNYXRjaGVyc1V0aWwoKSxcbiAgICAgICAgY3VzdG9tTWF0Y2hlcnM6IHJ1bm5hYmxlUmVzb3VyY2VzW3NwZWMuaWRdLmN1c3RvbU1hdGNoZXJzLFxuICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgICAgYWRkRXhwZWN0YXRpb25SZXN1bHQ6IGFkZEV4cGVjdGF0aW9uUmVzdWx0XG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gYWRkRXhwZWN0YXRpb25SZXN1bHQocGFzc2VkLCByZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHNwZWMuYWRkRXhwZWN0YXRpb25SZXN1bHQocGFzc2VkLCByZXN1bHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZWNvcmRMYXRlRXJyb3IoZXJyb3IpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeSh7XG4gICAgICAgIGVycm9yLFxuICAgICAgICBwYXNzZWQ6IGZhbHNlLFxuICAgICAgICBtYXRjaGVyTmFtZTogJycsXG4gICAgICAgIGV4cGVjdGVkOiAnJyxcbiAgICAgICAgYWN0dWFsOiAnJ1xuICAgICAgfSk7XG4gICAgICByZXN1bHQuZ2xvYmFsRXJyb3JUeXBlID0gJ2xhdGVFcnJvcic7XG4gICAgICB0b3BTdWl0ZS5yZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zLnB1c2gocmVzdWx0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWNvcmRMYXRlRXhwZWN0YXRpb24ocnVuYWJsZSwgcnVuYWJsZVR5cGUsIHJlc3VsdCkge1xuICAgICAgdmFyIGRlbGF5ZWRFeHBlY3RhdGlvblJlc3VsdCA9IHt9O1xuICAgICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgZGVsYXllZEV4cGVjdGF0aW9uUmVzdWx0W2tdID0gcmVzdWx0W2tdO1xuICAgICAgfSk7XG4gICAgICBkZWxheWVkRXhwZWN0YXRpb25SZXN1bHQucGFzc2VkID0gZmFsc2U7XG4gICAgICBkZWxheWVkRXhwZWN0YXRpb25SZXN1bHQuZ2xvYmFsRXJyb3JUeXBlID0gJ2xhdGVFeHBlY3RhdGlvbic7XG4gICAgICBkZWxheWVkRXhwZWN0YXRpb25SZXN1bHQubWVzc2FnZSA9XG4gICAgICAgIHJ1bmFibGVUeXBlICtcbiAgICAgICAgJyBcIicgK1xuICAgICAgICBydW5hYmxlLmdldEZ1bGxOYW1lKCkgK1xuICAgICAgICAnXCIgcmFuIGEgXCInICtcbiAgICAgICAgcmVzdWx0Lm1hdGNoZXJOYW1lICtcbiAgICAgICAgJ1wiIGV4cGVjdGF0aW9uIGFmdGVyIGl0IGZpbmlzaGVkLlxcbic7XG5cbiAgICAgIGlmIChyZXN1bHQubWVzc2FnZSkge1xuICAgICAgICBkZWxheWVkRXhwZWN0YXRpb25SZXN1bHQubWVzc2FnZSArPVxuICAgICAgICAgICdNZXNzYWdlOiBcIicgKyByZXN1bHQubWVzc2FnZSArICdcIlxcbic7XG4gICAgICB9XG5cbiAgICAgIGRlbGF5ZWRFeHBlY3RhdGlvblJlc3VsdC5tZXNzYWdlICs9XG4gICAgICAgICcxLiBEaWQgeW91IGZvcmdldCB0byByZXR1cm4gb3IgYXdhaXQgdGhlIHJlc3VsdCBvZiBleHBlY3RBc3luYz9cXG4nICtcbiAgICAgICAgJzIuIFdhcyBkb25lKCkgaW52b2tlZCBiZWZvcmUgYW4gYXN5bmMgb3BlcmF0aW9uIGNvbXBsZXRlZD9cXG4nICtcbiAgICAgICAgJzMuIERpZCBhbiBleHBlY3RhdGlvbiBmb2xsb3cgYSBjYWxsIHRvIGRvbmUoKT8nO1xuXG4gICAgICB0b3BTdWl0ZS5yZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zLnB1c2goZGVsYXllZEV4cGVjdGF0aW9uUmVzdWx0KTtcbiAgICB9XG5cbiAgICB2YXIgYXN5bmNFeHBlY3RhdGlvbkZhY3RvcnkgPSBmdW5jdGlvbihhY3R1YWwsIHNwZWMsIHJ1bmFibGVUeXBlKSB7XG4gICAgICByZXR1cm4gaiQuRXhwZWN0YXRpb24uYXN5bmNGYWN0b3J5KHtcbiAgICAgICAgbWF0Y2hlcnNVdGlsOiBtYWtlTWF0Y2hlcnNVdGlsKCksXG4gICAgICAgIGN1c3RvbUFzeW5jTWF0Y2hlcnM6IHJ1bm5hYmxlUmVzb3VyY2VzW3NwZWMuaWRdLmN1c3RvbUFzeW5jTWF0Y2hlcnMsXG4gICAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgICBhZGRFeHBlY3RhdGlvblJlc3VsdDogYWRkRXhwZWN0YXRpb25SZXN1bHRcbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBhZGRFeHBlY3RhdGlvblJlc3VsdChwYXNzZWQsIHJlc3VsdCkge1xuICAgICAgICBpZiAoY3VycmVudFJ1bm5hYmxlKCkgIT09IHNwZWMpIHtcbiAgICAgICAgICByZWNvcmRMYXRlRXhwZWN0YXRpb24oc3BlYywgcnVuYWJsZVR5cGUsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwZWMuYWRkRXhwZWN0YXRpb25SZXN1bHQocGFzc2VkLCByZXN1bHQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN1aXRlQXN5bmNFeHBlY3RhdGlvbkZhY3RvcnkgPSBmdW5jdGlvbihhY3R1YWwsIHN1aXRlKSB7XG4gICAgICByZXR1cm4gYXN5bmNFeHBlY3RhdGlvbkZhY3RvcnkoYWN0dWFsLCBzdWl0ZSwgJ1N1aXRlJyk7XG4gICAgfTtcblxuICAgIHZhciBzcGVjQXN5bmNFeHBlY3RhdGlvbkZhY3RvcnkgPSBmdW5jdGlvbihhY3R1YWwsIHN1aXRlKSB7XG4gICAgICByZXR1cm4gYXN5bmNFeHBlY3RhdGlvbkZhY3RvcnkoYWN0dWFsLCBzdWl0ZSwgJ1NwZWMnKTtcbiAgICB9O1xuXG4gICAgdmFyIGRlZmF1bHRSZXNvdXJjZXNGb3JSdW5uYWJsZSA9IGZ1bmN0aW9uKGlkLCBwYXJlbnRSdW5uYWJsZUlkKSB7XG4gICAgICB2YXIgcmVzb3VyY2VzID0ge1xuICAgICAgICBzcGllczogW10sXG4gICAgICAgIGN1c3RvbUVxdWFsaXR5VGVzdGVyczogW10sXG4gICAgICAgIGN1c3RvbU1hdGNoZXJzOiB7fSxcbiAgICAgICAgY3VzdG9tQXN5bmNNYXRjaGVyczoge30sXG4gICAgICAgIGN1c3RvbVNweVN0cmF0ZWdpZXM6IHt9LFxuICAgICAgICBkZWZhdWx0U3RyYXRlZ3lGbjogdW5kZWZpbmVkLFxuICAgICAgICBjdXN0b21PYmplY3RGb3JtYXR0ZXJzOiBbXVxuICAgICAgfTtcblxuICAgICAgaWYgKHJ1bm5hYmxlUmVzb3VyY2VzW3BhcmVudFJ1bm5hYmxlSWRdKSB7XG4gICAgICAgIHJlc291cmNlcy5jdXN0b21FcXVhbGl0eVRlc3RlcnMgPSBqJC51dGlsLmNsb25lKFxuICAgICAgICAgIHJ1bm5hYmxlUmVzb3VyY2VzW3BhcmVudFJ1bm5hYmxlSWRdLmN1c3RvbUVxdWFsaXR5VGVzdGVyc1xuICAgICAgICApO1xuICAgICAgICByZXNvdXJjZXMuY3VzdG9tTWF0Y2hlcnMgPSBqJC51dGlsLmNsb25lKFxuICAgICAgICAgIHJ1bm5hYmxlUmVzb3VyY2VzW3BhcmVudFJ1bm5hYmxlSWRdLmN1c3RvbU1hdGNoZXJzXG4gICAgICAgICk7XG4gICAgICAgIHJlc291cmNlcy5jdXN0b21Bc3luY01hdGNoZXJzID0gaiQudXRpbC5jbG9uZShcbiAgICAgICAgICBydW5uYWJsZVJlc291cmNlc1twYXJlbnRSdW5uYWJsZUlkXS5jdXN0b21Bc3luY01hdGNoZXJzXG4gICAgICAgICk7XG4gICAgICAgIHJlc291cmNlcy5jdXN0b21PYmplY3RGb3JtYXR0ZXJzID0gaiQudXRpbC5jbG9uZShcbiAgICAgICAgICBydW5uYWJsZVJlc291cmNlc1twYXJlbnRSdW5uYWJsZUlkXS5jdXN0b21PYmplY3RGb3JtYXR0ZXJzXG4gICAgICAgICk7XG4gICAgICAgIHJlc291cmNlcy5jdXN0b21TcHlTdHJhdGVnaWVzID0gaiQudXRpbC5jbG9uZShcbiAgICAgICAgICBydW5uYWJsZVJlc291cmNlc1twYXJlbnRSdW5uYWJsZUlkXS5jdXN0b21TcHlTdHJhdGVnaWVzXG4gICAgICAgICk7XG4gICAgICAgIHJlc291cmNlcy5kZWZhdWx0U3RyYXRlZ3lGbiA9XG4gICAgICAgICAgcnVubmFibGVSZXNvdXJjZXNbcGFyZW50UnVubmFibGVJZF0uZGVmYXVsdFN0cmF0ZWd5Rm47XG4gICAgICB9XG5cbiAgICAgIHJ1bm5hYmxlUmVzb3VyY2VzW2lkXSA9IHJlc291cmNlcztcbiAgICB9O1xuXG4gICAgdmFyIGNsZWFyUmVzb3VyY2VzRm9yUnVubmFibGUgPSBmdW5jdGlvbihpZCkge1xuICAgICAgc3B5UmVnaXN0cnkuY2xlYXJTcGllcygpO1xuICAgICAgZGVsZXRlIHJ1bm5hYmxlUmVzb3VyY2VzW2lkXTtcbiAgICB9O1xuXG4gICAgdmFyIGJlZm9yZUFuZEFmdGVyRm5zID0gZnVuY3Rpb24odGFyZ2V0U3VpdGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJlZm9yZXMgPSBbXSxcbiAgICAgICAgICBhZnRlcnMgPSBbXSxcbiAgICAgICAgICBzdWl0ZSA9IHRhcmdldFN1aXRlO1xuXG4gICAgICAgIHdoaWxlIChzdWl0ZSkge1xuICAgICAgICAgIGJlZm9yZXMgPSBiZWZvcmVzLmNvbmNhdChzdWl0ZS5iZWZvcmVGbnMpO1xuICAgICAgICAgIGFmdGVycyA9IGFmdGVycy5jb25jYXQoc3VpdGUuYWZ0ZXJGbnMpO1xuXG4gICAgICAgICAgc3VpdGUgPSBzdWl0ZS5wYXJlbnRTdWl0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYmVmb3JlczogYmVmb3Jlcy5yZXZlcnNlKCksXG4gICAgICAgICAgYWZ0ZXJzOiBhZnRlcnNcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBnZXRTcGVjTmFtZSA9IGZ1bmN0aW9uKHNwZWMsIHN1aXRlKSB7XG4gICAgICB2YXIgZnVsbE5hbWUgPSBbc3BlYy5kZXNjcmlwdGlvbl0sXG4gICAgICAgIHN1aXRlRnVsbE5hbWUgPSBzdWl0ZS5nZXRGdWxsTmFtZSgpO1xuXG4gICAgICBpZiAoc3VpdGVGdWxsTmFtZSAhPT0gJycpIHtcbiAgICAgICAgZnVsbE5hbWUudW5zaGlmdChzdWl0ZUZ1bGxOYW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdWxsTmFtZS5qb2luKCcgJyk7XG4gICAgfTtcblxuICAgIC8vIFRPRE86IHdlIG1heSBqdXN0IGJlIGFibGUgdG8gcGFzcyBpbiB0aGUgZm4gaW5zdGVhZCBvZiB3cmFwcGluZyBoZXJlXG4gICAgdmFyIGJ1aWxkRXhwZWN0YXRpb25SZXN1bHQgPSBqJC5idWlsZEV4cGVjdGF0aW9uUmVzdWx0LFxuICAgICAgZXhjZXB0aW9uRm9ybWF0dGVyID0gbmV3IGokLkV4Y2VwdGlvbkZvcm1hdHRlcigpLFxuICAgICAgZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5ID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAgICAgYXR0cnMubWVzc2FnZUZvcm1hdHRlciA9IGV4Y2VwdGlvbkZvcm1hdHRlci5tZXNzYWdlO1xuICAgICAgICBhdHRycy5zdGFja0Zvcm1hdHRlciA9IGV4Y2VwdGlvbkZvcm1hdHRlci5zdGFjaztcblxuICAgICAgICByZXR1cm4gYnVpbGRFeHBlY3RhdGlvblJlc3VsdChhdHRycyk7XG4gICAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2F1c2VzIGEgZGVwcmVjYXRpb24gd2FybmluZyB0byBiZSBsb2dnZWQgdG8gdGhlIGNvbnNvbGUgYW5kIHJlcG9ydGVkIHRvXG4gICAgICogcmVwb3J0ZXJzLlxuICAgICAqXG4gICAgICogVGhlIG9wdGlvbmFsIHNlY29uZCBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGhhdmUgZWl0aGVyIG9mIHRoZVxuICAgICAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAqXG4gICAgICogb21pdFN0YWNrVHJhY2U6IFdoZXRoZXIgdG8gb21pdCB0aGUgc3RhY2sgdHJhY2UuIE9wdGlvbmFsLiBEZWZhdWx0cyB0b1xuICAgICAqIGZhbHNlLiBUaGlzIG9wdGlvbiBpcyBpZ25vcmVkIGlmIHRoZSBkZXByZWNhdGlvbiBpcyBhbiBFcnJvci4gU2V0IHRoaXNcbiAgICAgKiB3aGVuIHRoZSBzdGFjayB0cmFjZSB3aWxsIG5vdCBjb250YWluIGFueXRoaW5nIHRoYXQgaGVscHMgdGhlIHVzZXIgZmluZFxuICAgICAqIHRoZSBzb3VyY2Ugb2YgdGhlIGRlcHJlY2F0aW9uLlxuICAgICAqXG4gICAgICogaWdub3JlUnVubmFibGU6IFdoZXRoZXIgdG8gbG9nIHRoZSBkZXByZWNhdGlvbiBvbiB0aGUgcm9vdCBzdWl0ZSwgaWdub3JpbmdcbiAgICAgKiB0aGUgc3BlYyBvciBzdWl0ZSB0aGF0J3MgcnVubmluZyB3aGVuIGl0IGhhcHBlbnMuIE9wdGlvbmFsLiBEZWZhdWx0cyB0b1xuICAgICAqIGZhbHNlLlxuICAgICAqXG4gICAgICogQG5hbWUgRW52I2RlcHJlY2F0ZWRcbiAgICAgKiBAc2luY2UgMi45OVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEVycm9yfSBkZXByZWNhdGlvbiBUaGUgZGVwcmVjYXRpb24gbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uYWwgZXh0cmEgb3B0aW9ucywgYXMgZGVzY3JpYmVkIGFib3ZlXG4gICAgICovXG4gICAgdGhpcy5kZXByZWNhdGVkID0gZnVuY3Rpb24oZGVwcmVjYXRpb24sIG9wdGlvbnMpIHtcbiAgICAgIHZhciBydW5uYWJsZSA9IGN1cnJlbnRSdW5uYWJsZSgpIHx8IHRvcFN1aXRlO1xuICAgICAgZGVwcmVjYXRvci5hZGREZXByZWNhdGlvbldhcm5pbmcocnVubmFibGUsIGRlcHJlY2F0aW9uLCBvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgdmFyIHF1ZXVlUnVubmVyRmFjdG9yeSA9IGZ1bmN0aW9uKG9wdGlvbnMsIGFyZ3MpIHtcbiAgICAgIGlmIChvcHRpb25zLmlzTGVhZikge1xuICAgICAgICAvLyBBIHNwZWNcbiAgICAgICAgb3B0aW9ucy5Ta2lwUG9saWN5ID0gaiQuQ29tcGxldGVPbkZpcnN0RXJyb3JTa2lwUG9saWN5O1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmlzUmVwb3J0ZXIpIHtcbiAgICAgICAgLy8gQSByZXBvcnRlciBxdWV1ZVxuICAgICAgICBvcHRpb25zLlNraXBQb2xpY3kgPSBqJC5OZXZlclNraXBQb2xpY3k7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBIHN1aXRlXG4gICAgICAgIGlmIChjb25maWcuc3RvcE9uU3BlY0ZhaWx1cmUpIHtcbiAgICAgICAgICBvcHRpb25zLlNraXBQb2xpY3kgPSBqJC5Db21wbGV0ZU9uRmlyc3RFcnJvclNraXBQb2xpY3k7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy5Ta2lwUG9saWN5ID0gaiQuU2tpcEFmdGVyQmVmb3JlQWxsRXJyb3JQb2xpY3k7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb3B0aW9ucy5jbGVhclN0YWNrID0gb3B0aW9ucy5jbGVhclN0YWNrIHx8IGNsZWFyU3RhY2s7XG4gICAgICBvcHRpb25zLnRpbWVvdXQgPSB7XG4gICAgICAgIHNldFRpbWVvdXQ6IHJlYWxTZXRUaW1lb3V0LFxuICAgICAgICBjbGVhclRpbWVvdXQ6IHJlYWxDbGVhclRpbWVvdXRcbiAgICAgIH07XG4gICAgICBvcHRpb25zLmZhaWwgPSBzZWxmLmZhaWw7XG4gICAgICBvcHRpb25zLmdsb2JhbEVycm9ycyA9IGdsb2JhbEVycm9ycztcbiAgICAgIG9wdGlvbnMub25FeGNlcHRpb24gPVxuICAgICAgICBvcHRpb25zLm9uRXhjZXB0aW9uIHx8XG4gICAgICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAoY3VycmVudFJ1bm5hYmxlKCkgfHwgdG9wU3VpdGUpLm9uRXhjZXB0aW9uKGUpO1xuICAgICAgICB9O1xuICAgICAgb3B0aW9ucy5kZXByZWNhdGVkID0gc2VsZi5kZXByZWNhdGVkO1xuXG4gICAgICBuZXcgaiQuUXVldWVSdW5uZXIob3B0aW9ucykuZXhlY3V0ZShhcmdzKTtcbiAgICB9O1xuXG4gICAgdmFyIHRvcFN1aXRlID0gbmV3IGokLlN1aXRlKHtcbiAgICAgIGlkOiBnZXROZXh0U3VpdGVJZCgpLFxuICAgICAgZGVzY3JpcHRpb246ICdKYXNtaW5lX19Ub3BMZXZlbF9fU3VpdGUnLFxuICAgICAgZXhwZWN0YXRpb25GYWN0b3J5OiBleHBlY3RhdGlvbkZhY3RvcnksXG4gICAgICBhc3luY0V4cGVjdGF0aW9uRmFjdG9yeTogc3VpdGVBc3luY0V4cGVjdGF0aW9uRmFjdG9yeSxcbiAgICAgIGV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeTogZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5LFxuICAgICAgYXV0b0NsZWFuQ2xvc3VyZXM6IGNvbmZpZy5hdXRvQ2xlYW5DbG9zdXJlcyxcbiAgICAgIG9uTGF0ZUVycm9yOiByZWNvcmRMYXRlRXJyb3JcbiAgICB9KTtcbiAgICB2YXIgZGVwcmVjYXRvciA9IG5ldyBqJC5EZXByZWNhdG9yKHRvcFN1aXRlKTtcbiAgICBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZSA9IHRvcFN1aXRlO1xuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgdGhlIHJvb3Qgc3VpdGUsIHRocm91Z2ggd2hpY2ggYWxsIHN1aXRlcyBhbmQgc3BlY3MgY2FuIGJlXG4gICAgICogYWNjZXNzZWQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG5hbWUgRW52I3RvcFN1aXRlXG4gICAgICogQHJldHVybiB7U3VpdGV9IHRoZSByb290IHN1aXRlXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICovXG4gICAgdGhpcy50b3BTdWl0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRvcFN1aXRlLm1ldGFkYXRhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHJlcHJlc2VudHMgdGhlIGF2YWlsYWJsZSByZXBvcnRlciBjYWxsYmFjayBmb3IgYW4gb2JqZWN0IHBhc3NlZCB0byB7QGxpbmsgRW52I2FkZFJlcG9ydGVyfS5cbiAgICAgKiBAaW50ZXJmYWNlIFJlcG9ydGVyXG4gICAgICogQHNlZSBjdXN0b21fcmVwb3J0ZXJcbiAgICAgKi9cbiAgICB2YXIgcmVwb3J0ZXIgPSBuZXcgaiQuUmVwb3J0RGlzcGF0Y2hlcihcbiAgICAgIFtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGBqYXNtaW5lU3RhcnRlZGAgaXMgY2FsbGVkIGFmdGVyIGFsbCBvZiB0aGUgc3BlY3MgaGF2ZSBiZWVuIGxvYWRlZCwgYnV0IGp1c3QgYmVmb3JlIGV4ZWN1dGlvbiBzdGFydHMuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAbmFtZSBSZXBvcnRlciNqYXNtaW5lU3RhcnRlZFxuICAgICAgICAgKiBAcGFyYW0ge0phc21pbmVTdGFydGVkSW5mb30gc3VpdGVJbmZvIEluZm9ybWF0aW9uIGFib3V0IHRoZSBmdWxsIEphc21pbmUgc3VpdGUgdGhhdCBpcyBiZWluZyBydW5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2RvbmVdIFVzZWQgdG8gc3BlY2lmeSB0byBKYXNtaW5lIHRoYXQgdGhpcyBjYWxsYmFjayBpcyBhc3luY2hyb25vdXMgYW5kIEphc21pbmUgc2hvdWxkIHdhaXQgdW50aWwgaXQgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSBtb3Zpbmcgb24uXG4gICAgICAgICAqIEByZXR1cm5zIHt9IE9wdGlvbmFsbHkgcmV0dXJuIGEgUHJvbWlzZSBpbnN0ZWFkIG9mIHVzaW5nIGBkb25lYCB0byBjYXVzZSBKYXNtaW5lIHRvIHdhaXQgZm9yIGNvbXBsZXRpb24uXG4gICAgICAgICAqIEBzZWUgYXN5bmNcbiAgICAgICAgICovXG4gICAgICAgICdqYXNtaW5lU3RhcnRlZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIHRoZSBlbnRpcmUgc3VpdGUgaGFzIGZpbmlzaGVkIGV4ZWN1dGlvbiBgamFzbWluZURvbmVgIGlzIGNhbGxlZFxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQG5hbWUgUmVwb3J0ZXIjamFzbWluZURvbmVcbiAgICAgICAgICogQHBhcmFtIHtKYXNtaW5lRG9uZUluZm99IHN1aXRlSW5mbyBJbmZvcm1hdGlvbiBhYm91dCB0aGUgZnVsbCBKYXNtaW5lIHN1aXRlIHRoYXQganVzdCBmaW5pc2hlZCBydW5uaW5nLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZG9uZV0gVXNlZCB0byBzcGVjaWZ5IHRvIEphc21pbmUgdGhhdCB0aGlzIGNhbGxiYWNrIGlzIGFzeW5jaHJvbm91cyBhbmQgSmFzbWluZSBzaG91bGQgd2FpdCB1bnRpbCBpdCBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlIG1vdmluZyBvbi5cbiAgICAgICAgICogQHJldHVybnMge30gT3B0aW9uYWxseSByZXR1cm4gYSBQcm9taXNlIGluc3RlYWQgb2YgdXNpbmcgYGRvbmVgIHRvIGNhdXNlIEphc21pbmUgdG8gd2FpdCBmb3IgY29tcGxldGlvbi5cbiAgICAgICAgICogQHNlZSBhc3luY1xuICAgICAgICAgKi9cbiAgICAgICAgJ2phc21pbmVEb25lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGBzdWl0ZVN0YXJ0ZWRgIGlzIGludm9rZWQgd2hlbiBhIGBkZXNjcmliZWAgc3RhcnRzIHRvIHJ1blxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQG5hbWUgUmVwb3J0ZXIjc3VpdGVTdGFydGVkXG4gICAgICAgICAqIEBwYXJhbSB7U3VpdGVSZXN1bHR9IHJlc3VsdCBJbmZvcm1hdGlvbiBhYm91dCB0aGUgaW5kaXZpZHVhbCB7QGxpbmsgZGVzY3JpYmV9IGJlaW5nIHJ1blxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZG9uZV0gVXNlZCB0byBzcGVjaWZ5IHRvIEphc21pbmUgdGhhdCB0aGlzIGNhbGxiYWNrIGlzIGFzeW5jaHJvbm91cyBhbmQgSmFzbWluZSBzaG91bGQgd2FpdCB1bnRpbCBpdCBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlIG1vdmluZyBvbi5cbiAgICAgICAgICogQHJldHVybnMge30gT3B0aW9uYWxseSByZXR1cm4gYSBQcm9taXNlIGluc3RlYWQgb2YgdXNpbmcgYGRvbmVgIHRvIGNhdXNlIEphc21pbmUgdG8gd2FpdCBmb3IgY29tcGxldGlvbi5cbiAgICAgICAgICogQHNlZSBhc3luY1xuICAgICAgICAgKi9cbiAgICAgICAgJ3N1aXRlU3RhcnRlZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgc3VpdGVEb25lYCBpcyBpbnZva2VkIHdoZW4gYWxsIG9mIHRoZSBjaGlsZCBzcGVjcyBhbmQgc3VpdGVzIGZvciBhIGdpdmVuIHN1aXRlIGhhdmUgYmVlbiBydW5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hpbGUgamFzbWluZSBkb2Vzbid0IHJlcXVpcmUgYW55IHNwZWNpZmljIGZ1bmN0aW9ucywgbm90IGRlZmluaW5nIGEgYHN1aXRlRG9uZWAgd2lsbCBtYWtlIGl0IGltcG9zc2libGUgZm9yIGEgcmVwb3J0ZXIgdG8ga25vdyB3aGVuIGEgc3VpdGUgaGFzIGZhaWx1cmVzIGluIGFuIGBhZnRlckFsbGAuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAbmFtZSBSZXBvcnRlciNzdWl0ZURvbmVcbiAgICAgICAgICogQHBhcmFtIHtTdWl0ZVJlc3VsdH0gcmVzdWx0XG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtkb25lXSBVc2VkIHRvIHNwZWNpZnkgdG8gSmFzbWluZSB0aGF0IHRoaXMgY2FsbGJhY2sgaXMgYXN5bmNocm9ub3VzIGFuZCBKYXNtaW5lIHNob3VsZCB3YWl0IHVudGlsIGl0IGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUgbW92aW5nIG9uLlxuICAgICAgICAgKiBAcmV0dXJucyB7fSBPcHRpb25hbGx5IHJldHVybiBhIFByb21pc2UgaW5zdGVhZCBvZiB1c2luZyBgZG9uZWAgdG8gY2F1c2UgSmFzbWluZSB0byB3YWl0IGZvciBjb21wbGV0aW9uLlxuICAgICAgICAgKiBAc2VlIGFzeW5jXG4gICAgICAgICAqL1xuICAgICAgICAnc3VpdGVEb25lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGBzcGVjU3RhcnRlZGAgaXMgaW52b2tlZCB3aGVuIGFuIGBpdGAgc3RhcnRzIHRvIHJ1biAoaW5jbHVkaW5nIGFzc29jaWF0ZWQgYGJlZm9yZUVhY2hgIGZ1bmN0aW9ucylcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBuYW1lIFJlcG9ydGVyI3NwZWNTdGFydGVkXG4gICAgICAgICAqIEBwYXJhbSB7U3BlY1Jlc3VsdH0gcmVzdWx0IEluZm9ybWF0aW9uIGFib3V0IHRoZSBpbmRpdmlkdWFsIHtAbGluayBpdH0gYmVpbmcgcnVuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtkb25lXSBVc2VkIHRvIHNwZWNpZnkgdG8gSmFzbWluZSB0aGF0IHRoaXMgY2FsbGJhY2sgaXMgYXN5bmNocm9ub3VzIGFuZCBKYXNtaW5lIHNob3VsZCB3YWl0IHVudGlsIGl0IGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUgbW92aW5nIG9uLlxuICAgICAgICAgKiBAcmV0dXJucyB7fSBPcHRpb25hbGx5IHJldHVybiBhIFByb21pc2UgaW5zdGVhZCBvZiB1c2luZyBgZG9uZWAgdG8gY2F1c2UgSmFzbWluZSB0byB3YWl0IGZvciBjb21wbGV0aW9uLlxuICAgICAgICAgKiBAc2VlIGFzeW5jXG4gICAgICAgICAqL1xuICAgICAgICAnc3BlY1N0YXJ0ZWQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogYHNwZWNEb25lYCBpcyBpbnZva2VkIHdoZW4gYW4gYGl0YCBhbmQgaXRzIGFzc29jaWF0ZWQgYGJlZm9yZUVhY2hgIGFuZCBgYWZ0ZXJFYWNoYCBmdW5jdGlvbnMgaGF2ZSBiZWVuIHJ1bi5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hpbGUgamFzbWluZSBkb2Vzbid0IHJlcXVpcmUgYW55IHNwZWNpZmljIGZ1bmN0aW9ucywgbm90IGRlZmluaW5nIGEgYHNwZWNEb25lYCB3aWxsIG1ha2UgaXQgaW1wb3NzaWJsZSBmb3IgYSByZXBvcnRlciB0byBrbm93IHdoZW4gYSBzcGVjIGhhcyBmYWlsZWQuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAbmFtZSBSZXBvcnRlciNzcGVjRG9uZVxuICAgICAgICAgKiBAcGFyYW0ge1NwZWNSZXN1bHR9IHJlc3VsdFxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZG9uZV0gVXNlZCB0byBzcGVjaWZ5IHRvIEphc21pbmUgdGhhdCB0aGlzIGNhbGxiYWNrIGlzIGFzeW5jaHJvbm91cyBhbmQgSmFzbWluZSBzaG91bGQgd2FpdCB1bnRpbCBpdCBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlIG1vdmluZyBvbi5cbiAgICAgICAgICogQHJldHVybnMge30gT3B0aW9uYWxseSByZXR1cm4gYSBQcm9taXNlIGluc3RlYWQgb2YgdXNpbmcgYGRvbmVgIHRvIGNhdXNlIEphc21pbmUgdG8gd2FpdCBmb3IgY29tcGxldGlvbi5cbiAgICAgICAgICogQHNlZSBhc3luY1xuICAgICAgICAgKi9cbiAgICAgICAgJ3NwZWNEb25lJ1xuICAgICAgXSxcbiAgICAgIHF1ZXVlUnVubmVyRmFjdG9yeSxcbiAgICAgIHJlY29yZExhdGVFcnJvclxuICAgICk7XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgc3BlY3MuXG4gICAgICpcbiAgICAgKiBJZiBjYWxsZWQgd2l0aCBubyBwYXJhbWV0ZXJzIG9yIHdpdGggYSBmYWxzeSB2YWx1ZSBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyLFxuICAgICAqIGFsbCBzcGVjcyB3aWxsIGJlIGV4ZWN1dGVkIGV4Y2VwdCB0aG9zZSB0aGF0IGFyZSBleGNsdWRlZCBieSBhXG4gICAgICogW3NwZWMgZmlsdGVyXXtAbGluayBDb25maWd1cmF0aW9uI3NwZWNGaWx0ZXJ9IG9yIG90aGVyIG1lY2hhbmlzbS4gSWYgdGhlXG4gICAgICogZmlyc3QgcGFyYW1ldGVyIGlzIGEgbGlzdCBvZiBzcGVjL3N1aXRlIElEcywgb25seSB0aG9zZSBzcGVjcy9zdWl0ZXMgd2lsbFxuICAgICAqIGJlIHJ1bi5cbiAgICAgKlxuICAgICAqIEJvdGggcGFyYW1ldGVycyBhcmUgb3B0aW9uYWwsIGJ1dCBhIGNvbXBsZXRpb24gY2FsbGJhY2sgaXMgb25seSB2YWxpZCBhc1xuICAgICAqIHRoZSBzZWNvbmQgcGFyYW1ldGVyLiBUbyBzcGVjaWZ5IGEgY29tcGxldGlvbiBjYWxsYmFjayBidXQgbm90IGEgbGlzdCBvZlxuICAgICAqIHNwZWNzL3N1aXRlcyB0byBydW4sIHBhc3MgbnVsbCBvciB1bmRlZmluZWQgYXMgdGhlIGZpcnN0IHBhcmFtZXRlci4gVGhlXG4gICAgICogY29tcGxldGlvbiBjYWxsYmFjayBpcyBzdXBwb3J0ZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuIEluIG1vc3RcbiAgICAgKiBjYXNlcyBpdCB3aWxsIGJlIG1vcmUgY29udmVuaWVudCB0byB1c2UgdGhlIHJldHVybmVkIHByb21pc2UgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIGV4ZWN1dGUgc2hvdWxkIG5vdCBiZSBjYWxsZWQgbW9yZSB0aGFuIG9uY2UgdW5sZXNzIHRoZSBlbnYgaGFzIGJlZW5cbiAgICAgKiBjb25maWd1cmVkIHdpdGggYHthdXRvQ2xlYW5DbG9zdXJlczogZmFsc2V9YC5cbiAgICAgKlxuICAgICAqIGV4ZWN1dGUgcmV0dXJucyBhIHByb21pc2UuIFRoZSBwcm9taXNlIHdpbGwgYmUgcmVzb2x2ZWQgdG8gdGhlIHNhbWVcbiAgICAgKiB7QGxpbmsgSmFzbWluZURvbmVJbmZvfG92ZXJhbGwgcmVzdWx0fSB0aGF0J3MgcGFzc2VkIHRvIGEgcmVwb3J0ZXInc1xuICAgICAqIGBqYXNtaW5lRG9uZWAgbWV0aG9kLCBldmVuIGlmIHRoZSBzdWl0ZSBkaWQgbm90IHBhc3MuIFRvIGRldGVybWluZVxuICAgICAqIHdoZXRoZXIgdGhlIHN1aXRlIHBhc3NlZCwgY2hlY2sgdGhlIHZhbHVlIHRoYXQgdGhlIHByb21pc2UgcmVzb2x2ZXMgdG9cbiAgICAgKiBvciB1c2UgYSB7QGxpbmsgUmVwb3J0ZXJ9LlxuICAgICAqXG4gICAgICogQG5hbWUgRW52I2V4ZWN1dGVcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyhzdHJpbmdbXSk9fSBydW5uYWJsZXNUb1J1biBJRHMgb2Ygc3VpdGVzIGFuZC9vciBzcGVjcyB0byBydW5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25Db21wbGV0ZSBGdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIGFmdGVyIGFsbCBzcGVjcyBoYXZlIHJ1blxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8SmFzbWluZURvbmVJbmZvPn1cbiAgICAgKi9cbiAgICB0aGlzLmV4ZWN1dGUgPSBmdW5jdGlvbihydW5uYWJsZXNUb1J1biwgb25Db21wbGV0ZSkge1xuICAgICAgaWYgKHRoaXMuX2V4ZWN1dGVkQmVmb3JlKSB7XG4gICAgICAgIHRvcFN1aXRlLnJlc2V0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9leGVjdXRlZEJlZm9yZSA9IHRydWU7XG4gICAgICBkZWZhdWx0UmVzb3VyY2VzRm9yUnVubmFibGUodG9wU3VpdGUuaWQpO1xuICAgICAgaW5zdGFsbEdsb2JhbEVycm9ycygpO1xuXG4gICAgICBpZiAoIXJ1bm5hYmxlc1RvUnVuKSB7XG4gICAgICAgIGlmIChmb2N1c2VkUnVubmFibGVzLmxlbmd0aCkge1xuICAgICAgICAgIHJ1bm5hYmxlc1RvUnVuID0gZm9jdXNlZFJ1bm5hYmxlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBydW5uYWJsZXNUb1J1biA9IFt0b3BTdWl0ZS5pZF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG9yZGVyID0gbmV3IGokLk9yZGVyKHtcbiAgICAgICAgcmFuZG9tOiBjb25maWcucmFuZG9tLFxuICAgICAgICBzZWVkOiBjb25maWcuc2VlZFxuICAgICAgfSk7XG5cbiAgICAgIHZhciBwcm9jZXNzb3IgPSBuZXcgaiQuVHJlZVByb2Nlc3Nvcih7XG4gICAgICAgIHRyZWU6IHRvcFN1aXRlLFxuICAgICAgICBydW5uYWJsZUlkczogcnVubmFibGVzVG9SdW4sXG4gICAgICAgIHF1ZXVlUnVubmVyRmFjdG9yeTogcXVldWVSdW5uZXJGYWN0b3J5LFxuICAgICAgICBmYWlsU3BlY1dpdGhOb0V4cGVjdGF0aW9uczogY29uZmlnLmZhaWxTcGVjV2l0aE5vRXhwZWN0YXRpb25zLFxuICAgICAgICBub2RlU3RhcnQ6IGZ1bmN0aW9uKHN1aXRlLCBuZXh0KSB7XG4gICAgICAgICAgY3VycmVudGx5RXhlY3V0aW5nU3VpdGVzLnB1c2goc3VpdGUpO1xuICAgICAgICAgIGRlZmF1bHRSZXNvdXJjZXNGb3JSdW5uYWJsZShzdWl0ZS5pZCwgc3VpdGUucGFyZW50U3VpdGUuaWQpO1xuICAgICAgICAgIHJlcG9ydGVyLnN1aXRlU3RhcnRlZChzdWl0ZS5yZXN1bHQsIG5leHQpO1xuICAgICAgICAgIHN1aXRlLnN0YXJ0VGltZXIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgbm9kZUNvbXBsZXRlOiBmdW5jdGlvbihzdWl0ZSwgcmVzdWx0LCBuZXh0KSB7XG4gICAgICAgICAgaWYgKHN1aXRlICE9PSBjdXJyZW50U3VpdGUoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmllZCB0byBjb21wbGV0ZSB0aGUgd3Jvbmcgc3VpdGUnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjbGVhclJlc291cmNlc0ZvclJ1bm5hYmxlKHN1aXRlLmlkKTtcbiAgICAgICAgICBjdXJyZW50bHlFeGVjdXRpbmdTdWl0ZXMucG9wKCk7XG5cbiAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgICAgIGhhc0ZhaWx1cmVzID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3VpdGUuZW5kVGltZXIoKTtcblxuICAgICAgICAgIGlmIChzdWl0ZS5oYWRCZWZvcmVBbGxGYWlsdXJlKSB7XG4gICAgICAgICAgICByZXBvcnRDaGlsZHJlbk9mQmVmb3JlQWxsRmFpbHVyZShzdWl0ZSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmVwb3J0ZXIuc3VpdGVEb25lKHJlc3VsdCwgbmV4dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVwb3J0ZXIuc3VpdGVEb25lKHJlc3VsdCwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvcmRlckNoaWxkcmVuOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIG9yZGVyLnNvcnQobm9kZS5jaGlsZHJlbik7XG4gICAgICAgIH0sXG4gICAgICAgIGV4Y2x1ZGVOb2RlOiBmdW5jdGlvbihzcGVjKSB7XG4gICAgICAgICAgcmV0dXJuICFjb25maWcuc3BlY0ZpbHRlcihzcGVjKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcHJvY2Vzc29yLnByb2Nlc3NUcmVlKCkudmFsaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIG9yZGVyOiB3b3VsZCBjYXVzZSBhIGJlZm9yZUFsbCBvciBhZnRlckFsbCB0byBiZSBydW4gbXVsdGlwbGUgdGltZXMnXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHZhciBqYXNtaW5lVGltZXIgPSBuZXcgaiQuVGltZXIoKTtcbiAgICAgIGphc21pbmVUaW1lci5zdGFydCgpO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICBydW5BbGwoZnVuY3Rpb24oamFzbWluZURvbmVJbmZvKSB7XG4gICAgICAgICAgaWYgKG9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXNvbHZlKGphc21pbmVEb25lSW5mbyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJ1bkFsbChkb25lKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmZvcm1hdGlvbiBwYXNzZWQgdG8gdGhlIHtAbGluayBSZXBvcnRlciNqYXNtaW5lU3RhcnRlZH0gZXZlbnQuXG4gICAgICAgICAqIEB0eXBlZGVmIEphc21pbmVTdGFydGVkSW5mb1xuICAgICAgICAgKiBAcHJvcGVydHkge0ludH0gdG90YWxTcGVjc0RlZmluZWQgLSBUaGUgdG90YWwgbnVtYmVyIG9mIHNwZWNzIGRlZmluZWQgaW4gdGhpcyBzdWl0ZS5cbiAgICAgICAgICogQHByb3BlcnR5IHtPcmRlcn0gb3JkZXIgLSBJbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JkZXJpbmcgKHJhbmRvbSBvciBub3QpIG9mIHRoaXMgZXhlY3V0aW9uIG9mIHRoZSBzdWl0ZS5cbiAgICAgICAgICogQHNpbmNlIDIuMC4wXG4gICAgICAgICAqL1xuICAgICAgICByZXBvcnRlci5qYXNtaW5lU3RhcnRlZChcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0b3RhbFNwZWNzRGVmaW5lZDogdG90YWxTcGVjc0RlZmluZWQsXG4gICAgICAgICAgICBvcmRlcjogb3JkZXJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY3VycmVudGx5RXhlY3V0aW5nU3VpdGVzLnB1c2godG9wU3VpdGUpO1xuXG4gICAgICAgICAgICBwcm9jZXNzb3IuZXhlY3V0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgKGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICh0b3BTdWl0ZS5oYWRCZWZvcmVBbGxGYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgICBhd2FpdCByZXBvcnRDaGlsZHJlbk9mQmVmb3JlQWxsRmFpbHVyZSh0b3BTdWl0ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2xlYXJSZXNvdXJjZXNGb3JSdW5uYWJsZSh0b3BTdWl0ZS5pZCk7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5RXhlY3V0aW5nU3VpdGVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHZhciBvdmVyYWxsU3RhdHVzLCBpbmNvbXBsZXRlUmVhc29uO1xuXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgaGFzRmFpbHVyZXMgfHxcbiAgICAgICAgICAgICAgICAgIHRvcFN1aXRlLnJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgb3ZlcmFsbFN0YXR1cyA9ICdmYWlsZWQnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9jdXNlZFJ1bm5hYmxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBvdmVyYWxsU3RhdHVzID0gJ2luY29tcGxldGUnO1xuICAgICAgICAgICAgICAgICAgaW5jb21wbGV0ZVJlYXNvbiA9ICdmaXQoKSBvciBmZGVzY3JpYmUoKSB3YXMgZm91bmQnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG90YWxTcGVjc0RlZmluZWQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIG92ZXJhbGxTdGF0dXMgPSAnaW5jb21wbGV0ZSc7XG4gICAgICAgICAgICAgICAgICBpbmNvbXBsZXRlUmVhc29uID0gJ05vIHNwZWNzIGZvdW5kJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3ZlcmFsbFN0YXR1cyA9ICdwYXNzZWQnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEluZm9ybWF0aW9uIHBhc3NlZCB0byB0aGUge0BsaW5rIFJlcG9ydGVyI2phc21pbmVEb25lfSBldmVudC5cbiAgICAgICAgICAgICAgICAgKiBAdHlwZWRlZiBKYXNtaW5lRG9uZUluZm9cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge092ZXJhbGxTdGF0dXN9IG92ZXJhbGxTdGF0dXMgLSBUaGUgb3ZlcmFsbCByZXN1bHQgb2YgdGhlIHN1aXRlOiAncGFzc2VkJywgJ2ZhaWxlZCcsIG9yICdpbmNvbXBsZXRlJy5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0ludH0gdG90YWxUaW1lIC0gVGhlIHRvdGFsIHRpbWUgKGluIG1zKSB0aGF0IGl0IHRvb2sgdG8gZXhlY3V0ZSB0aGUgc3VpdGVcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0luY29tcGxldGVSZWFzb259IGluY29tcGxldGVSZWFzb24gLSBFeHBsYW5hdGlvbiBvZiB3aHkgdGhlIHN1aXRlIHdhcyBpbmNvbXBsZXRlLlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T3JkZXJ9IG9yZGVyIC0gSW5mb3JtYXRpb24gYWJvdXQgdGhlIG9yZGVyaW5nIChyYW5kb20gb3Igbm90KSBvZiB0aGlzIGV4ZWN1dGlvbiBvZiB0aGUgc3VpdGUuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtFeHBlY3RhdGlvbltdfSBmYWlsZWRFeHBlY3RhdGlvbnMgLSBMaXN0IG9mIGV4cGVjdGF0aW9ucyB0aGF0IGZhaWxlZCBpbiBhbiB7QGxpbmsgYWZ0ZXJBbGx9IGF0IHRoZSBnbG9iYWwgbGV2ZWwuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtFeHBlY3RhdGlvbltdfSBkZXByZWNhdGlvbldhcm5pbmdzIC0gTGlzdCBvZiBkZXByZWNhdGlvbiB3YXJuaW5ncyB0aGF0IG9jY3VycmVkIGF0IHRoZSBnbG9iYWwgbGV2ZWwuXG4gICAgICAgICAgICAgICAgICogQHNpbmNlIDIuNC4wXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY29uc3QgamFzbWluZURvbmVJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgb3ZlcmFsbFN0YXR1czogb3ZlcmFsbFN0YXR1cyxcbiAgICAgICAgICAgICAgICAgIHRvdGFsVGltZTogamFzbWluZVRpbWVyLmVsYXBzZWQoKSxcbiAgICAgICAgICAgICAgICAgIGluY29tcGxldGVSZWFzb246IGluY29tcGxldGVSZWFzb24sXG4gICAgICAgICAgICAgICAgICBvcmRlcjogb3JkZXIsXG4gICAgICAgICAgICAgICAgICBmYWlsZWRFeHBlY3RhdGlvbnM6IHRvcFN1aXRlLnJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMsXG4gICAgICAgICAgICAgICAgICBkZXByZWNhdGlvbldhcm5pbmdzOiB0b3BTdWl0ZS5yZXN1bHQuZGVwcmVjYXRpb25XYXJuaW5nc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVwb3J0ZXIuamFzbWluZURvbmUoamFzbWluZURvbmVJbmZvLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIGRvbmUoamFzbWluZURvbmVJbmZvKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgYXN5bmMgZnVuY3Rpb24gcmVwb3J0Q2hpbGRyZW5PZkJlZm9yZUFsbEZhaWx1cmUoc3VpdGUpIHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBzdWl0ZS5jaGlsZHJlbikge1xuICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIGokLlN1aXRlKSB7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICAgIHJlcG9ydGVyLnN1aXRlU3RhcnRlZChjaGlsZC5yZXN1bHQsIHJlc29sdmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByZXBvcnRDaGlsZHJlbk9mQmVmb3JlQWxsRmFpbHVyZShjaGlsZCk7XG5cbiAgICAgICAgICAgIC8vIE1hcmtpbmcgdGhlIHN1aXRlIHBhc3NlZCBpcyBjb25zaXN0ZW50IHdpdGggaG93IHN1aXRlcyB0aGF0XG4gICAgICAgICAgICAvLyBjb250YWluIGZhaWxlZCBzcGVjcyBidXQgbm8gc3VpdGUtbGV2ZWwgZmFpbHVyZXMgYXJlIHJlcG9ydGVkLlxuICAgICAgICAgICAgY2hpbGQucmVzdWx0LnN0YXR1cyA9ICdwYXNzZWQnO1xuXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICAgIHJlcG9ydGVyLnN1aXRlRG9uZShjaGlsZC5yZXN1bHQsIHJlc29sdmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qIGEgc3BlYyAqL1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgICByZXBvcnRlci5zcGVjU3RhcnRlZChjaGlsZC5yZXN1bHQsIHJlc29sdmUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNoaWxkLmFkZEV4cGVjdGF0aW9uUmVzdWx0KFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHBhc3NlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgICAgICdOb3QgcnVuIGJlY2F1c2UgYSBiZWZvcmVBbGwgZnVuY3Rpb24gZmFpbGVkLiBUaGUgJyArXG4gICAgICAgICAgICAgICAgICAnYmVmb3JlQWxsIGZhaWx1cmUgd2lsbCBiZSByZXBvcnRlZCBvbiB0aGUgc3VpdGUgdGhhdCAnICtcbiAgICAgICAgICAgICAgICAgICdjYXVzZWQgaXQuJ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY2hpbGQucmVzdWx0LnN0YXR1cyA9ICdmYWlsZWQnO1xuXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICAgIHJlcG9ydGVyLnNwZWNEb25lKGNoaWxkLnJlc3VsdCwgcmVzb2x2ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkIGEgY3VzdG9tIHJlcG9ydGVyIHRvIHRoZSBKYXNtaW5lIGVudmlyb25tZW50LlxuICAgICAqIEBuYW1lIEVudiNhZGRSZXBvcnRlclxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7UmVwb3J0ZXJ9IHJlcG9ydGVyVG9BZGQgVGhlIHJlcG9ydGVyIHRvIGJlIGFkZGVkLlxuICAgICAqIEBzZWUgY3VzdG9tX3JlcG9ydGVyXG4gICAgICovXG4gICAgdGhpcy5hZGRSZXBvcnRlciA9IGZ1bmN0aW9uKHJlcG9ydGVyVG9BZGQpIHtcbiAgICAgIHJlcG9ydGVyLmFkZFJlcG9ydGVyKHJlcG9ydGVyVG9BZGQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlIGEgZmFsbGJhY2sgcmVwb3J0ZXIgaWYgbm8gb3RoZXIgcmVwb3J0ZXJzIGhhdmUgYmVlbiBzcGVjaWZpZWQuXG4gICAgICogQG5hbWUgRW52I3Byb3ZpZGVGYWxsYmFja1JlcG9ydGVyXG4gICAgICogQHNpbmNlIDIuNS4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtSZXBvcnRlcn0gcmVwb3J0ZXJUb0FkZCBUaGUgcmVwb3J0ZXJcbiAgICAgKiBAc2VlIGN1c3RvbV9yZXBvcnRlclxuICAgICAqL1xuICAgIHRoaXMucHJvdmlkZUZhbGxiYWNrUmVwb3J0ZXIgPSBmdW5jdGlvbihyZXBvcnRlclRvQWRkKSB7XG4gICAgICByZXBvcnRlci5wcm92aWRlRmFsbGJhY2tSZXBvcnRlcihyZXBvcnRlclRvQWRkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgYWxsIHJlZ2lzdGVyZWQgcmVwb3J0ZXJzXG4gICAgICogQG5hbWUgRW52I2NsZWFyUmVwb3J0ZXJzXG4gICAgICogQHNpbmNlIDIuNS4yXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgdGhpcy5jbGVhclJlcG9ydGVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVwb3J0ZXIuY2xlYXJSZXBvcnRlcnMoKTtcbiAgICB9O1xuXG4gICAgdmFyIHNweUZhY3RvcnkgPSBuZXcgaiQuU3B5RmFjdG9yeShcbiAgICAgIGZ1bmN0aW9uIGdldEN1c3RvbVN0cmF0ZWdpZXMoKSB7XG4gICAgICAgIHZhciBydW5uYWJsZSA9IGN1cnJlbnRSdW5uYWJsZSgpO1xuXG4gICAgICAgIGlmIChydW5uYWJsZSkge1xuICAgICAgICAgIHJldHVybiBydW5uYWJsZVJlc291cmNlc1tydW5uYWJsZS5pZF0uY3VzdG9tU3B5U3RyYXRlZ2llcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbiBnZXREZWZhdWx0U3RyYXRlZ3lGbigpIHtcbiAgICAgICAgdmFyIHJ1bm5hYmxlID0gY3VycmVudFJ1bm5hYmxlKCk7XG5cbiAgICAgICAgaWYgKHJ1bm5hYmxlKSB7XG4gICAgICAgICAgcmV0dXJuIHJ1bm5hYmxlUmVzb3VyY2VzW3J1bm5hYmxlLmlkXS5kZWZhdWx0U3RyYXRlZ3lGbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9LFxuICAgICAgbWFrZU1hdGNoZXJzVXRpbFxuICAgICk7XG5cbiAgICB2YXIgc3B5UmVnaXN0cnkgPSBuZXcgaiQuU3B5UmVnaXN0cnkoe1xuICAgICAgY3VycmVudFNwaWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFjdXJyZW50UnVubmFibGUoKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdTcGllcyBtdXN0IGJlIGNyZWF0ZWQgaW4gYSBiZWZvcmUgZnVuY3Rpb24gb3IgYSBzcGVjJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bm5hYmxlUmVzb3VyY2VzW2N1cnJlbnRSdW5uYWJsZSgpLmlkXS5zcGllcztcbiAgICAgIH0sXG4gICAgICBjcmVhdGVTcHk6IGZ1bmN0aW9uKG5hbWUsIG9yaWdpbmFsRm4pIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuY3JlYXRlU3B5KG5hbWUsIG9yaWdpbmFsRm4pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyB3aGV0aGVyIEphc21pbmUgc2hvdWxkIGFsbG93IHRoZSBzYW1lIGZ1bmN0aW9uIHRvIGJlIHNwaWVkIG9uXG4gICAgICogbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBleGVjdXRpb24gb2YgYSBzcGVjLiBCeSBkZWZhdWx0LCBzcHlpbmcgb25cbiAgICAgKiBhIGZ1bmN0aW9uIHRoYXQgaXMgYWxyZWFkeSBhIHNweSB3aWxsIGNhdXNlIGFuIGVycm9yLlxuICAgICAqIEBuYW1lIEVudiNhbGxvd1Jlc3B5XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHNpbmNlIDIuNS4wXG4gICAgICogQHBhcmFtIHtib29sZWFufSBhbGxvdyBXaGV0aGVyIHRvIGFsbG93IHJlc3B5aW5nXG4gICAgICovXG4gICAgdGhpcy5hbGxvd1Jlc3B5ID0gZnVuY3Rpb24oYWxsb3cpIHtcbiAgICAgIHNweVJlZ2lzdHJ5LmFsbG93UmVzcHkoYWxsb3cpO1xuICAgIH07XG5cbiAgICB0aGlzLnNweU9uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3B5UmVnaXN0cnkuc3B5T24uYXBwbHkoc3B5UmVnaXN0cnksIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIHRoaXMuc3B5T25Qcm9wZXJ0eSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNweVJlZ2lzdHJ5LnNweU9uUHJvcGVydHkuYXBwbHkoc3B5UmVnaXN0cnksIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIHRoaXMuc3B5T25BbGxGdW5jdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzcHlSZWdpc3RyeS5zcHlPbkFsbEZ1bmN0aW9ucy5hcHBseShzcHlSZWdpc3RyeSwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgdGhpcy5jcmVhdGVTcHkgPSBmdW5jdGlvbihuYW1lLCBvcmlnaW5hbEZuKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBqJC5pc0Z1bmN0aW9uXyhuYW1lKSkge1xuICAgICAgICBvcmlnaW5hbEZuID0gbmFtZTtcbiAgICAgICAgbmFtZSA9IG9yaWdpbmFsRm4ubmFtZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNweUZhY3RvcnkuY3JlYXRlU3B5KG5hbWUsIG9yaWdpbmFsRm4pO1xuICAgIH07XG5cbiAgICB0aGlzLmNyZWF0ZVNweU9iaiA9IGZ1bmN0aW9uKGJhc2VOYW1lLCBtZXRob2ROYW1lcywgcHJvcGVydHlOYW1lcykge1xuICAgICAgcmV0dXJuIHNweUZhY3RvcnkuY3JlYXRlU3B5T2JqKGJhc2VOYW1lLCBtZXRob2ROYW1lcywgcHJvcGVydHlOYW1lcyk7XG4gICAgfTtcblxuICAgIHZhciBlbnN1cmVJc0Z1bmN0aW9uID0gZnVuY3Rpb24oZm4sIGNhbGxlcikge1xuICAgICAgaWYgKCFqJC5pc0Z1bmN0aW9uXyhmbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGNhbGxlciArICcgZXhwZWN0cyBhIGZ1bmN0aW9uIGFyZ3VtZW50OyByZWNlaXZlZCAnICsgaiQuZ2V0VHlwZV8oZm4pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBlbnN1cmVJc0Z1bmN0aW9uT3JBc3luYyA9IGZ1bmN0aW9uKGZuLCBjYWxsZXIpIHtcbiAgICAgIGlmICghaiQuaXNGdW5jdGlvbl8oZm4pICYmICFqJC5pc0FzeW5jRnVuY3Rpb25fKGZuKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgY2FsbGVyICsgJyBleHBlY3RzIGEgZnVuY3Rpb24gYXJndW1lbnQ7IHJlY2VpdmVkICcgKyBqJC5nZXRUeXBlXyhmbilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZW5zdXJlSXNOb3ROZXN0ZWQobWV0aG9kKSB7XG4gICAgICB2YXIgcnVubmFibGUgPSBjdXJyZW50UnVubmFibGUoKTtcbiAgICAgIGlmIChydW5uYWJsZSAhPT0gbnVsbCAmJiBydW5uYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIidcIiArIG1ldGhvZCArIFwiJyBzaG91bGQgb25seSBiZSB1c2VkIGluICdkZXNjcmliZScgZnVuY3Rpb25cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzdWl0ZUZhY3RvcnkgPSBmdW5jdGlvbihkZXNjcmlwdGlvbikge1xuICAgICAgdmFyIHN1aXRlID0gbmV3IGokLlN1aXRlKHtcbiAgICAgICAgaWQ6IGdldE5leHRTdWl0ZUlkKCksXG4gICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgICAgcGFyZW50U3VpdGU6IGN1cnJlbnREZWNsYXJhdGlvblN1aXRlLFxuICAgICAgICB0aW1lcjogbmV3IGokLlRpbWVyKCksXG4gICAgICAgIGV4cGVjdGF0aW9uRmFjdG9yeTogZXhwZWN0YXRpb25GYWN0b3J5LFxuICAgICAgICBhc3luY0V4cGVjdGF0aW9uRmFjdG9yeTogc3VpdGVBc3luY0V4cGVjdGF0aW9uRmFjdG9yeSxcbiAgICAgICAgZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5OiBleHBlY3RhdGlvblJlc3VsdEZhY3RvcnksXG4gICAgICAgIHRocm93T25FeHBlY3RhdGlvbkZhaWx1cmU6IGNvbmZpZy5zdG9wU3BlY09uRXhwZWN0YXRpb25GYWlsdXJlLFxuICAgICAgICBhdXRvQ2xlYW5DbG9zdXJlczogY29uZmlnLmF1dG9DbGVhbkNsb3N1cmVzLFxuICAgICAgICBvbkxhdGVFcnJvcjogcmVjb3JkTGF0ZUVycm9yXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHN1aXRlO1xuICAgIH07XG5cbiAgICB0aGlzLmRlc2NyaWJlID0gZnVuY3Rpb24oZGVzY3JpcHRpb24sIHNwZWNEZWZpbml0aW9ucykge1xuICAgICAgZW5zdXJlSXNOb3ROZXN0ZWQoJ2Rlc2NyaWJlJyk7XG4gICAgICBlbnN1cmVJc0Z1bmN0aW9uKHNwZWNEZWZpbml0aW9ucywgJ2Rlc2NyaWJlJyk7XG4gICAgICB2YXIgc3VpdGUgPSBzdWl0ZUZhY3RvcnkoZGVzY3JpcHRpb24pO1xuICAgICAgaWYgKHNwZWNEZWZpbml0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGVzY3JpYmUgZG9lcyBub3QgZXhwZWN0IGFueSBhcmd1bWVudHMnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50RGVjbGFyYXRpb25TdWl0ZS5tYXJrZWRFeGNsdWRpbmcpIHtcbiAgICAgICAgc3VpdGUuZXhjbHVkZSgpO1xuICAgICAgfVxuICAgICAgYWRkU3BlY3NUb1N1aXRlKHN1aXRlLCBzcGVjRGVmaW5pdGlvbnMpO1xuICAgICAgaWYgKHN1aXRlLnBhcmVudFN1aXRlICYmICFzdWl0ZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZXNjcmliZSB3aXRoIG5vIGNoaWxkcmVuIChkZXNjcmliZSgpIG9yIGl0KCkpJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VpdGUubWV0YWRhdGE7XG4gICAgfTtcblxuICAgIHRoaXMueGRlc2NyaWJlID0gZnVuY3Rpb24oZGVzY3JpcHRpb24sIHNwZWNEZWZpbml0aW9ucykge1xuICAgICAgZW5zdXJlSXNOb3ROZXN0ZWQoJ3hkZXNjcmliZScpO1xuICAgICAgZW5zdXJlSXNGdW5jdGlvbihzcGVjRGVmaW5pdGlvbnMsICd4ZGVzY3JpYmUnKTtcbiAgICAgIHZhciBzdWl0ZSA9IHN1aXRlRmFjdG9yeShkZXNjcmlwdGlvbik7XG4gICAgICBzdWl0ZS5leGNsdWRlKCk7XG4gICAgICBhZGRTcGVjc1RvU3VpdGUoc3VpdGUsIHNwZWNEZWZpbml0aW9ucyk7XG4gICAgICByZXR1cm4gc3VpdGUubWV0YWRhdGE7XG4gICAgfTtcblxuICAgIHZhciBmb2N1c2VkUnVubmFibGVzID0gW107XG5cbiAgICB0aGlzLmZkZXNjcmliZSA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uLCBzcGVjRGVmaW5pdGlvbnMpIHtcbiAgICAgIGVuc3VyZUlzTm90TmVzdGVkKCdmZGVzY3JpYmUnKTtcbiAgICAgIGVuc3VyZUlzRnVuY3Rpb24oc3BlY0RlZmluaXRpb25zLCAnZmRlc2NyaWJlJyk7XG4gICAgICB2YXIgc3VpdGUgPSBzdWl0ZUZhY3RvcnkoZGVzY3JpcHRpb24pO1xuICAgICAgc3VpdGUuaXNGb2N1c2VkID0gdHJ1ZTtcblxuICAgICAgZm9jdXNlZFJ1bm5hYmxlcy5wdXNoKHN1aXRlLmlkKTtcbiAgICAgIHVuZm9jdXNBbmNlc3RvcigpO1xuICAgICAgYWRkU3BlY3NUb1N1aXRlKHN1aXRlLCBzcGVjRGVmaW5pdGlvbnMpO1xuXG4gICAgICByZXR1cm4gc3VpdGUubWV0YWRhdGE7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGFkZFNwZWNzVG9TdWl0ZShzdWl0ZSwgc3BlY0RlZmluaXRpb25zKSB7XG4gICAgICB2YXIgcGFyZW50U3VpdGUgPSBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZTtcbiAgICAgIHBhcmVudFN1aXRlLmFkZENoaWxkKHN1aXRlKTtcbiAgICAgIGN1cnJlbnREZWNsYXJhdGlvblN1aXRlID0gc3VpdGU7XG5cbiAgICAgIHZhciBkZWNsYXJhdGlvbkVycm9yID0gbnVsbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNwZWNEZWZpbml0aW9ucygpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkZWNsYXJhdGlvbkVycm9yID0gZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlY2xhcmF0aW9uRXJyb3IpIHtcbiAgICAgICAgc3VpdGUub25FeGNlcHRpb24oZGVjbGFyYXRpb25FcnJvcik7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnREZWNsYXJhdGlvblN1aXRlID0gcGFyZW50U3VpdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmluZEZvY3VzZWRBbmNlc3RvcihzdWl0ZSkge1xuICAgICAgd2hpbGUgKHN1aXRlKSB7XG4gICAgICAgIGlmIChzdWl0ZS5pc0ZvY3VzZWQpIHtcbiAgICAgICAgICByZXR1cm4gc3VpdGUuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgc3VpdGUgPSBzdWl0ZS5wYXJlbnRTdWl0ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5mb2N1c0FuY2VzdG9yKCkge1xuICAgICAgdmFyIGZvY3VzZWRBbmNlc3RvciA9IGZpbmRGb2N1c2VkQW5jZXN0b3IoY3VycmVudERlY2xhcmF0aW9uU3VpdGUpO1xuICAgICAgaWYgKGZvY3VzZWRBbmNlc3Rvcikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvY3VzZWRSdW5uYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZm9jdXNlZFJ1bm5hYmxlc1tpXSA9PT0gZm9jdXNlZEFuY2VzdG9yKSB7XG4gICAgICAgICAgICBmb2N1c2VkUnVubmFibGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzcGVjRmFjdG9yeSA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uLCBmbiwgc3VpdGUsIHRpbWVvdXQpIHtcbiAgICAgIHRvdGFsU3BlY3NEZWZpbmVkKys7XG4gICAgICB2YXIgc3BlYyA9IG5ldyBqJC5TcGVjKHtcbiAgICAgICAgaWQ6IGdldE5leHRTcGVjSWQoKSxcbiAgICAgICAgYmVmb3JlQW5kQWZ0ZXJGbnM6IGJlZm9yZUFuZEFmdGVyRm5zKHN1aXRlKSxcbiAgICAgICAgZXhwZWN0YXRpb25GYWN0b3J5OiBleHBlY3RhdGlvbkZhY3RvcnksXG4gICAgICAgIGFzeW5jRXhwZWN0YXRpb25GYWN0b3J5OiBzcGVjQXN5bmNFeHBlY3RhdGlvbkZhY3RvcnksXG4gICAgICAgIG9uTGF0ZUVycm9yOiByZWNvcmRMYXRlRXJyb3IsXG4gICAgICAgIHJlc3VsdENhbGxiYWNrOiBzcGVjUmVzdWx0Q2FsbGJhY2ssXG4gICAgICAgIGdldFNwZWNOYW1lOiBmdW5jdGlvbihzcGVjKSB7XG4gICAgICAgICAgcmV0dXJuIGdldFNwZWNOYW1lKHNwZWMsIHN1aXRlKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25TdGFydDogc3BlY1N0YXJ0ZWQsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgICAgZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5OiBleHBlY3RhdGlvblJlc3VsdEZhY3RvcnksXG4gICAgICAgIHF1ZXVlUnVubmVyRmFjdG9yeTogcXVldWVSdW5uZXJGYWN0b3J5LFxuICAgICAgICB1c2VyQ29udGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHN1aXRlLmNsb25lZFNoYXJlZFVzZXJDb250ZXh0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHF1ZXVlYWJsZUZuOiB7XG4gICAgICAgICAgZm46IGZuLFxuICAgICAgICAgIHRpbWVvdXQ6IHRpbWVvdXQgfHwgMFxuICAgICAgICB9LFxuICAgICAgICB0aHJvd09uRXhwZWN0YXRpb25GYWlsdXJlOiBjb25maWcuc3RvcFNwZWNPbkV4cGVjdGF0aW9uRmFpbHVyZSxcbiAgICAgICAgYXV0b0NsZWFuQ2xvc3VyZXM6IGNvbmZpZy5hdXRvQ2xlYW5DbG9zdXJlcyxcbiAgICAgICAgdGltZXI6IG5ldyBqJC5UaW1lcigpXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzcGVjO1xuXG4gICAgICBmdW5jdGlvbiBzcGVjUmVzdWx0Q2FsbGJhY2socmVzdWx0LCBuZXh0KSB7XG4gICAgICAgIGNsZWFyUmVzb3VyY2VzRm9yUnVubmFibGUoc3BlYy5pZCk7XG4gICAgICAgIGN1cnJlbnRTcGVjID0gbnVsbDtcblxuICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgICBoYXNGYWlsdXJlcyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXBvcnRlci5zcGVjRG9uZShyZXN1bHQsIG5leHQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzcGVjU3RhcnRlZChzcGVjLCBuZXh0KSB7XG4gICAgICAgIGN1cnJlbnRTcGVjID0gc3BlYztcbiAgICAgICAgZGVmYXVsdFJlc291cmNlc0ZvclJ1bm5hYmxlKHNwZWMuaWQsIHN1aXRlLmlkKTtcbiAgICAgICAgcmVwb3J0ZXIuc3BlY1N0YXJ0ZWQoc3BlYy5yZXN1bHQsIG5leHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLml0XyA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uLCBmbiwgdGltZW91dCkge1xuICAgICAgZW5zdXJlSXNOb3ROZXN0ZWQoJ2l0Jyk7XG4gICAgICAvLyBpdCgpIHNvbWV0aW1lcyBkb2Vzbid0IGhhdmUgYSBmbiBhcmd1bWVudCwgc28gb25seSBjaGVjayB0aGUgdHlwZSBpZlxuICAgICAgLy8gaXQncyBnaXZlbi5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgZm4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGVuc3VyZUlzRnVuY3Rpb25PckFzeW5jKGZuLCAnaXQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgaiQudXRpbC52YWxpZGF0ZVRpbWVvdXQodGltZW91dCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzcGVjID0gc3BlY0ZhY3RvcnkoZGVzY3JpcHRpb24sIGZuLCBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZSwgdGltZW91dCk7XG4gICAgICBpZiAoY3VycmVudERlY2xhcmF0aW9uU3VpdGUubWFya2VkRXhjbHVkaW5nKSB7XG4gICAgICAgIHNwZWMuZXhjbHVkZSgpO1xuICAgICAgfVxuICAgICAgY3VycmVudERlY2xhcmF0aW9uU3VpdGUuYWRkQ2hpbGQoc3BlYyk7XG5cbiAgICAgIHJldHVybiBzcGVjO1xuICAgIH07XG5cbiAgICB0aGlzLml0ID0gZnVuY3Rpb24oZGVzY3JpcHRpb24sIGZuLCB0aW1lb3V0KSB7XG4gICAgICBjb25zdCBzcGVjID0gdGhpcy5pdF8oZGVzY3JpcHRpb24sIGZuLCB0aW1lb3V0KTtcbiAgICAgIHJldHVybiBzcGVjLm1ldGFkYXRhO1xuICAgIH07XG5cbiAgICB0aGlzLnhpdCA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uLCBmbiwgdGltZW91dCkge1xuICAgICAgZW5zdXJlSXNOb3ROZXN0ZWQoJ3hpdCcpO1xuICAgICAgLy8geGl0KCksIGxpa2UgaXQoKSwgZG9lc24ndCBhbHdheXMgaGF2ZSBhIGZuIGFyZ3VtZW50LCBzbyBvbmx5IGNoZWNrIHRoZVxuICAgICAgLy8gdHlwZSB3aGVuIG5lZWRlZC5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgZm4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGVuc3VyZUlzRnVuY3Rpb25PckFzeW5jKGZuLCAneGl0Jyk7XG4gICAgICB9XG4gICAgICB2YXIgc3BlYyA9IHRoaXMuaXRfLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBzcGVjLmV4Y2x1ZGUoJ1RlbXBvcmFyaWx5IGRpc2FibGVkIHdpdGggeGl0Jyk7XG4gICAgICByZXR1cm4gc3BlYy5tZXRhZGF0YTtcbiAgICB9O1xuXG4gICAgdGhpcy5maXQgPSBmdW5jdGlvbihkZXNjcmlwdGlvbiwgZm4sIHRpbWVvdXQpIHtcbiAgICAgIGVuc3VyZUlzTm90TmVzdGVkKCdmaXQnKTtcbiAgICAgIGVuc3VyZUlzRnVuY3Rpb25PckFzeW5jKGZuLCAnZml0Jyk7XG5cbiAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgIGokLnV0aWwudmFsaWRhdGVUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgdmFyIHNwZWMgPSBzcGVjRmFjdG9yeShkZXNjcmlwdGlvbiwgZm4sIGN1cnJlbnREZWNsYXJhdGlvblN1aXRlLCB0aW1lb3V0KTtcbiAgICAgIGN1cnJlbnREZWNsYXJhdGlvblN1aXRlLmFkZENoaWxkKHNwZWMpO1xuICAgICAgZm9jdXNlZFJ1bm5hYmxlcy5wdXNoKHNwZWMuaWQpO1xuICAgICAgdW5mb2N1c0FuY2VzdG9yKCk7XG4gICAgICByZXR1cm4gc3BlYy5tZXRhZGF0YTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIHVzZXItZGVmaW5lZCBwcm9wZXJ0eSB0aGF0IHdpbGwgYmUgcHJvdmlkZWQgdG8gcmVwb3J0ZXJzIGFzIHBhcnQgb2YgdGhlIHByb3BlcnRpZXMgZmllbGQgb2Yge0BsaW5rIFNwZWNSZXN1bHR9XG4gICAgICogQG5hbWUgRW52I3NldFNwZWNQcm9wZXJ0eVxuICAgICAqIEBzaW5jZSAzLjYuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICovXG4gICAgdGhpcy5zZXRTcGVjUHJvcGVydHkgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoIWN1cnJlbnRSdW5uYWJsZSgpIHx8IGN1cnJlbnRSdW5uYWJsZSgpID09IGN1cnJlbnRTdWl0ZSgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIidzZXRTcGVjUHJvcGVydHknIHdhcyB1c2VkIHdoZW4gdGhlcmUgd2FzIG5vIGN1cnJlbnQgc3BlY1wiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjdXJyZW50UnVubmFibGUoKS5zZXRTcGVjUHJvcGVydHkoa2V5LCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgYSB1c2VyLWRlZmluZWQgcHJvcGVydHkgdGhhdCB3aWxsIGJlIHByb3ZpZGVkIHRvIHJlcG9ydGVycyBhcyBwYXJ0IG9mIHRoZSBwcm9wZXJ0aWVzIGZpZWxkIG9mIHtAbGluayBTdWl0ZVJlc3VsdH1cbiAgICAgKiBAbmFtZSBFbnYjc2V0U3VpdGVQcm9wZXJ0eVxuICAgICAqIEBzaW5jZSAzLjYuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICovXG4gICAgdGhpcy5zZXRTdWl0ZVByb3BlcnR5ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKCFjdXJyZW50U3VpdGUoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCInc2V0U3VpdGVQcm9wZXJ0eScgd2FzIHVzZWQgd2hlbiB0aGVyZSB3YXMgbm8gY3VycmVudCBzdWl0ZVwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjdXJyZW50U3VpdGUoKS5zZXRTdWl0ZVByb3BlcnR5KGtleSwgdmFsdWUpO1xuICAgIH07XG5cbiAgICB0aGlzLmRlYnVnTG9nID0gZnVuY3Rpb24obXNnKSB7XG4gICAgICB2YXIgbWF5YmVTcGVjID0gY3VycmVudFJ1bm5hYmxlKCk7XG5cbiAgICAgIGlmICghbWF5YmVTcGVjIHx8ICFtYXliZVNwZWMuZGVidWdMb2cpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ2RlYnVnTG9nJyB3YXMgY2FsbGVkIHdoZW4gdGhlcmUgd2FzIG5vIGN1cnJlbnQgc3BlY1wiKTtcbiAgICAgIH1cblxuICAgICAgbWF5YmVTcGVjLmRlYnVnTG9nKG1zZyk7XG4gICAgfTtcblxuICAgIHRoaXMuZXhwZWN0ID0gZnVuY3Rpb24oYWN0dWFsKSB7XG4gICAgICBpZiAoIWN1cnJlbnRSdW5uYWJsZSgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIidleHBlY3QnIHdhcyB1c2VkIHdoZW4gdGhlcmUgd2FzIG5vIGN1cnJlbnQgc3BlYywgdGhpcyBjb3VsZCBiZSBiZWNhdXNlIGFuIGFzeW5jaHJvbm91cyB0ZXN0IHRpbWVkIG91dFwiXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdXJyZW50UnVubmFibGUoKS5leHBlY3QoYWN0dWFsKTtcbiAgICB9O1xuXG4gICAgdGhpcy5leHBlY3RBc3luYyA9IGZ1bmN0aW9uKGFjdHVhbCkge1xuICAgICAgaWYgKCFjdXJyZW50UnVubmFibGUoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCInZXhwZWN0QXN5bmMnIHdhcyB1c2VkIHdoZW4gdGhlcmUgd2FzIG5vIGN1cnJlbnQgc3BlYywgdGhpcyBjb3VsZCBiZSBiZWNhdXNlIGFuIGFzeW5jaHJvbm91cyB0ZXN0IHRpbWVkIG91dFwiXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdXJyZW50UnVubmFibGUoKS5leHBlY3RBc3luYyhhY3R1YWwpO1xuICAgIH07XG5cbiAgICB0aGlzLmJlZm9yZUVhY2ggPSBmdW5jdGlvbihiZWZvcmVFYWNoRnVuY3Rpb24sIHRpbWVvdXQpIHtcbiAgICAgIGVuc3VyZUlzTm90TmVzdGVkKCdiZWZvcmVFYWNoJyk7XG4gICAgICBlbnN1cmVJc0Z1bmN0aW9uT3JBc3luYyhiZWZvcmVFYWNoRnVuY3Rpb24sICdiZWZvcmVFYWNoJyk7XG5cbiAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgIGokLnV0aWwudmFsaWRhdGVUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZS5iZWZvcmVFYWNoKHtcbiAgICAgICAgZm46IGJlZm9yZUVhY2hGdW5jdGlvbixcbiAgICAgICAgdGltZW91dDogdGltZW91dCB8fCAwXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5iZWZvcmVBbGwgPSBmdW5jdGlvbihiZWZvcmVBbGxGdW5jdGlvbiwgdGltZW91dCkge1xuICAgICAgZW5zdXJlSXNOb3ROZXN0ZWQoJ2JlZm9yZUFsbCcpO1xuICAgICAgZW5zdXJlSXNGdW5jdGlvbk9yQXN5bmMoYmVmb3JlQWxsRnVuY3Rpb24sICdiZWZvcmVBbGwnKTtcblxuICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgaiQudXRpbC52YWxpZGF0ZVRpbWVvdXQodGltZW91dCk7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnREZWNsYXJhdGlvblN1aXRlLmJlZm9yZUFsbCh7XG4gICAgICAgIGZuOiBiZWZvcmVBbGxGdW5jdGlvbixcbiAgICAgICAgdGltZW91dDogdGltZW91dCB8fCAwXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5hZnRlckVhY2ggPSBmdW5jdGlvbihhZnRlckVhY2hGdW5jdGlvbiwgdGltZW91dCkge1xuICAgICAgZW5zdXJlSXNOb3ROZXN0ZWQoJ2FmdGVyRWFjaCcpO1xuICAgICAgZW5zdXJlSXNGdW5jdGlvbk9yQXN5bmMoYWZ0ZXJFYWNoRnVuY3Rpb24sICdhZnRlckVhY2gnKTtcblxuICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgaiQudXRpbC52YWxpZGF0ZVRpbWVvdXQodGltZW91dCk7XG4gICAgICB9XG5cbiAgICAgIGFmdGVyRWFjaEZ1bmN0aW9uLmlzQ2xlYW51cCA9IHRydWU7XG4gICAgICBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZS5hZnRlckVhY2goe1xuICAgICAgICBmbjogYWZ0ZXJFYWNoRnVuY3Rpb24sXG4gICAgICAgIHRpbWVvdXQ6IHRpbWVvdXQgfHwgMFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMuYWZ0ZXJBbGwgPSBmdW5jdGlvbihhZnRlckFsbEZ1bmN0aW9uLCB0aW1lb3V0KSB7XG4gICAgICBlbnN1cmVJc05vdE5lc3RlZCgnYWZ0ZXJBbGwnKTtcbiAgICAgIGVuc3VyZUlzRnVuY3Rpb25PckFzeW5jKGFmdGVyQWxsRnVuY3Rpb24sICdhZnRlckFsbCcpO1xuXG4gICAgICBpZiAodGltZW91dCkge1xuICAgICAgICBqJC51dGlsLnZhbGlkYXRlVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudERlY2xhcmF0aW9uU3VpdGUuYWZ0ZXJBbGwoe1xuICAgICAgICBmbjogYWZ0ZXJBbGxGdW5jdGlvbixcbiAgICAgICAgdGltZW91dDogdGltZW91dCB8fCAwXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5wZW5kaW5nID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgdmFyIGZ1bGxNZXNzYWdlID0gaiQuU3BlYy5wZW5kaW5nU3BlY0V4Y2VwdGlvbk1lc3NhZ2U7XG4gICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICBmdWxsTWVzc2FnZSArPSBtZXNzYWdlO1xuICAgICAgfVxuICAgICAgdGhyb3cgZnVsbE1lc3NhZ2U7XG4gICAgfTtcblxuICAgIHRoaXMuZmFpbCA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICBpZiAoIWN1cnJlbnRSdW5uYWJsZSgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIidmYWlsJyB3YXMgdXNlZCB3aGVuIHRoZXJlIHdhcyBubyBjdXJyZW50IHNwZWMsIHRoaXMgY291bGQgYmUgYmVjYXVzZSBhbiBhc3luY2hyb25vdXMgdGVzdCB0aW1lZCBvdXRcIlxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWVzc2FnZSA9ICdGYWlsZWQnO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gJzogJztcbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UpIHtcbiAgICAgICAgICBtZXNzYWdlICs9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgIH0gZWxzZSBpZiAoaiQuaXNTdHJpbmdfKGVycm9yKSkge1xuICAgICAgICAgIG1lc3NhZ2UgKz0gZXJyb3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gcHJldHR5IHByaW50IGFsbCBraW5kIG9mIG9iamVjdHMuIFRoaXMgaW5jbHVkZXMgYXJyYXlzLlxuICAgICAgICAgIG1lc3NhZ2UgKz0gbWFrZVByZXR0eVByaW50ZXIoKShlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3VycmVudFJ1bm5hYmxlKCkuYWRkRXhwZWN0YXRpb25SZXN1bHQoZmFsc2UsIHtcbiAgICAgICAgbWF0Y2hlck5hbWU6ICcnLFxuICAgICAgICBwYXNzZWQ6IGZhbHNlLFxuICAgICAgICBleHBlY3RlZDogJycsXG4gICAgICAgIGFjdHVhbDogJycsXG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgIGVycm9yOiBlcnJvciAmJiBlcnJvci5tZXNzYWdlID8gZXJyb3IgOiBudWxsXG4gICAgICB9KTtcblxuICAgICAgaWYgKGNvbmZpZy5zdG9wU3BlY09uRXhwZWN0YXRpb25GYWlsdXJlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5jbGVhbnVwXyA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGdsb2JhbEVycm9ycykge1xuICAgICAgICBnbG9iYWxFcnJvcnMudW5pbnN0YWxsKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBFbnY7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkpzQXBpUmVwb3J0ZXIgPSBmdW5jdGlvbihqJCkge1xuICAvKipcbiAgICogQG5hbWUganNBcGlSZXBvcnRlclxuICAgKiBAY2xhc3NkZXNjIHtAbGluayBSZXBvcnRlcn0gYWRkZWQgYnkgZGVmYXVsdCBpbiBgYm9vdC5qc2AgdG8gcmVjb3JkIHJlc3VsdHMgZm9yIHJldHJpZXZhbCBpbiBqYXZhc2NyaXB0IGNvZGUuIEFuIGluc3RhbmNlIGlzIG1hZGUgYXZhaWxhYmxlIGFzIGBqc0FwaVJlcG9ydGVyYCBvbiB0aGUgZ2xvYmFsIG9iamVjdC5cbiAgICogQGNsYXNzXG4gICAqIEBoaWRlY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIEpzQXBpUmVwb3J0ZXIob3B0aW9ucykge1xuICAgIHZhciB0aW1lciA9IG9wdGlvbnMudGltZXIgfHwgbmV3IGokLlRpbWVyKCksXG4gICAgICBzdGF0dXMgPSAnbG9hZGVkJztcblxuICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJ1bkRldGFpbHMgPSB7fTtcblxuICAgIHRoaXMuamFzbWluZVN0YXJ0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICBzdGF0dXMgPSAnc3RhcnRlZCc7XG4gICAgICB0aW1lci5zdGFydCgpO1xuICAgIH07XG5cbiAgICB2YXIgZXhlY3V0aW9uVGltZTtcblxuICAgIHRoaXMuamFzbWluZURvbmUgPSBmdW5jdGlvbihydW5EZXRhaWxzKSB7XG4gICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMucnVuRGV0YWlscyA9IHJ1bkRldGFpbHM7XG4gICAgICBleGVjdXRpb25UaW1lID0gdGltZXIuZWxhcHNlZCgpO1xuICAgICAgc3RhdHVzID0gJ2RvbmUnO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgc3RhdHVzIGZvciB0aGUgSmFzbWluZSBlbnZpcm9ubWVudC5cbiAgICAgKiBAbmFtZSBqc0FwaVJlcG9ydGVyI3N0YXR1c1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gLSBPbmUgb2YgYGxvYWRlZGAsIGBzdGFydGVkYCwgb3IgYGRvbmVgXG4gICAgICovXG4gICAgdGhpcy5zdGF0dXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfTtcblxuICAgIHZhciBzdWl0ZXMgPSBbXSxcbiAgICAgIHN1aXRlc19oYXNoID0ge307XG5cbiAgICB0aGlzLnN1aXRlU3RhcnRlZCA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgc3VpdGVzX2hhc2hbcmVzdWx0LmlkXSA9IHJlc3VsdDtcbiAgICB9O1xuXG4gICAgdGhpcy5zdWl0ZURvbmUgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIHN0b3JlU3VpdGUocmVzdWx0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSByZXN1bHRzIGZvciBhIHNldCBvZiBzdWl0ZXMuXG4gICAgICpcbiAgICAgKiBSZXRyaWV2YWJsZSBpbiBzbGljZXMgZm9yIGVhc2llciBzZXJpYWxpemF0aW9uLlxuICAgICAqIEBuYW1lIGpzQXBpUmVwb3J0ZXIjc3VpdGVSZXN1bHRzXG4gICAgICogQHNpbmNlIDIuMS4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIHBvc2l0aW9uIGluIHRoZSBzdWl0ZXMgbGlzdCB0byBzdGFydCBmcm9tLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggLSBNYXhpbXVtIG51bWJlciBvZiBzdWl0ZSByZXN1bHRzIHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJuIHtTdWl0ZVJlc3VsdFtdfVxuICAgICAqL1xuICAgIHRoaXMuc3VpdGVSZXN1bHRzID0gZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCkge1xuICAgICAgcmV0dXJuIHN1aXRlcy5zbGljZShpbmRleCwgaW5kZXggKyBsZW5ndGgpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzdG9yZVN1aXRlKHJlc3VsdCkge1xuICAgICAgc3VpdGVzLnB1c2gocmVzdWx0KTtcbiAgICAgIHN1aXRlc19oYXNoW3Jlc3VsdC5pZF0gPSByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBvZiB0aGUgc3VpdGVzIGluIGEgc2luZ2xlIG9iamVjdCwgd2l0aCB0aGVpciBgaWRgIGFzIHRoZSBrZXkuXG4gICAgICogQG5hbWUganNBcGlSZXBvcnRlciNzdWl0ZXNcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IC0gTWFwIG9mIHN1aXRlIGlkIHRvIHtAbGluayBTdWl0ZVJlc3VsdH1cbiAgICAgKi9cbiAgICB0aGlzLnN1aXRlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN1aXRlc19oYXNoO1xuICAgIH07XG5cbiAgICB2YXIgc3BlY3MgPSBbXTtcblxuICAgIHRoaXMuc3BlY0RvbmUgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIHNwZWNzLnB1c2gocmVzdWx0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSByZXN1bHRzIGZvciBhIHNldCBvZiBzcGVjcy5cbiAgICAgKlxuICAgICAqIFJldHJpZXZhYmxlIGluIHNsaWNlcyBmb3IgZWFzaWVyIHNlcmlhbGl6YXRpb24uXG4gICAgICogQG5hbWUganNBcGlSZXBvcnRlciNzcGVjUmVzdWx0c1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSBwb3NpdGlvbiBpbiB0aGUgc3BlY3MgbGlzdCB0byBzdGFydCBmcm9tLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggLSBNYXhpbXVtIG51bWJlciBvZiBzcGVjcyByZXN1bHRzIHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJuIHtTcGVjUmVzdWx0W119XG4gICAgICovXG4gICAgdGhpcy5zcGVjUmVzdWx0cyA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIHJldHVybiBzcGVjcy5zbGljZShpbmRleCwgaW5kZXggKyBsZW5ndGgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHNwZWMgcmVzdWx0cy5cbiAgICAgKiBAbmFtZSBqc0FwaVJlcG9ydGVyI3NwZWNzXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7U3BlY1Jlc3VsdFtdfVxuICAgICAqL1xuICAgIHRoaXMuc3BlY3MgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzcGVjcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBmdWxsIEphc21pbmUgc3VpdGUgdG8gcnVuLlxuICAgICAqIEBuYW1lIGpzQXBpUmVwb3J0ZXIjZXhlY3V0aW9uVGltZVxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmV4ZWN1dGlvblRpbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleGVjdXRpb25UaW1lO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gSnNBcGlSZXBvcnRlcjtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuQW55ID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gQW55KGV4cGVjdGVkT2JqZWN0KSB7XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZE9iamVjdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdqYXNtaW5lLmFueSgpIGV4cGVjdHMgdG8gYmUgcGFzc2VkIGEgY29uc3RydWN0b3IgZnVuY3Rpb24uICcgK1xuICAgICAgICAgICdQbGVhc2UgcGFzcyBvbmUgb3IgdXNlIGphc21pbmUuYW55dGhpbmcoKSB0byBtYXRjaCBhbnkgb2JqZWN0LidcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0ZWRPYmplY3QgPSBleHBlY3RlZE9iamVjdDtcbiAgfVxuXG4gIEFueS5wcm90b3R5cGUuYXN5bW1ldHJpY01hdGNoID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICBpZiAodGhpcy5leHBlY3RlZE9iamVjdCA9PSBTdHJpbmcpIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb3RoZXIgPT0gJ3N0cmluZycgfHwgb3RoZXIgaW5zdGFuY2VvZiBTdHJpbmc7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZXhwZWN0ZWRPYmplY3QgPT0gTnVtYmVyKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG90aGVyID09ICdudW1iZXInIHx8IG90aGVyIGluc3RhbmNlb2YgTnVtYmVyO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmV4cGVjdGVkT2JqZWN0ID09IEZ1bmN0aW9uKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG90aGVyID09ICdmdW5jdGlvbicgfHwgb3RoZXIgaW5zdGFuY2VvZiBGdW5jdGlvbjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5leHBlY3RlZE9iamVjdCA9PSBPYmplY3QpIHtcbiAgICAgIHJldHVybiBvdGhlciAhPT0gbnVsbCAmJiB0eXBlb2Ygb3RoZXIgPT0gJ29iamVjdCc7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZXhwZWN0ZWRPYmplY3QgPT0gQm9vbGVhbikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvdGhlciA9PSAnYm9vbGVhbic7XG4gICAgfVxuXG4gICAgLyoganNoaW50IC1XMTIyICovXG4gICAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICAgIGlmICh0eXBlb2YgU3ltYm9sICE9ICd1bmRlZmluZWQnICYmIHRoaXMuZXhwZWN0ZWRPYmplY3QgPT0gU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG90aGVyID09ICdzeW1ib2wnO1xuICAgIH1cbiAgICAvKiBqc2hpbnQgK1cxMjIgKi9cblxuICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIHRoaXMuZXhwZWN0ZWRPYmplY3Q7XG4gIH07XG5cbiAgQW55LnByb3RvdHlwZS5qYXNtaW5lVG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJzxqYXNtaW5lLmFueSgnICsgaiQuZm5OYW1lRm9yKHRoaXMuZXhwZWN0ZWRPYmplY3QpICsgJyk+JztcbiAgfTtcblxuICByZXR1cm4gQW55O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5Bbnl0aGluZyA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIEFueXRoaW5nKCkge31cblxuICBBbnl0aGluZy5wcm90b3R5cGUuYXN5bW1ldHJpY01hdGNoID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICByZXR1cm4gIWokLnV0aWwuaXNVbmRlZmluZWQob3RoZXIpICYmIG90aGVyICE9PSBudWxsO1xuICB9O1xuXG4gIEFueXRoaW5nLnByb3RvdHlwZS5qYXNtaW5lVG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJzxqYXNtaW5lLmFueXRoaW5nPic7XG4gIH07XG5cbiAgcmV0dXJuIEFueXRoaW5nO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5BcnJheUNvbnRhaW5pbmcgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBBcnJheUNvbnRhaW5pbmcoc2FtcGxlKSB7XG4gICAgdGhpcy5zYW1wbGUgPSBzYW1wbGU7XG4gIH1cblxuICBBcnJheUNvbnRhaW5pbmcucHJvdG90eXBlLmFzeW1tZXRyaWNNYXRjaCA9IGZ1bmN0aW9uKG90aGVyLCBtYXRjaGVyc1V0aWwpIHtcbiAgICBpZiAoIWokLmlzQXJyYXlfKHRoaXMuc2FtcGxlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnWW91IG11c3QgcHJvdmlkZSBhbiBhcnJheSB0byBhcnJheUNvbnRhaW5pbmcsIG5vdCAnICtcbiAgICAgICAgICBqJC5iYXNpY1ByZXR0eVByaW50ZXJfKHRoaXMuc2FtcGxlKSArXG4gICAgICAgICAgJy4nXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBhY3R1YWwgcGFyYW1ldGVyIGlzIG5vdCBhbiBhcnJheSwgd2UgY2FuIGZhaWwgaW1tZWRpYXRlbHksIHNpbmNlIGl0IGNvdWxkbid0XG4gICAgLy8gcG9zc2libHkgYmUgYW4gXCJhcnJheSBjb250YWluaW5nXCIgYW55dGhpbmcuIEhvd2V2ZXIsIHdlIGFsc28gd2FudCBhbiBlbXB0eSBzYW1wbGVcbiAgICAvLyBhcnJheSB0byBtYXRjaCBhbnl0aGluZywgc28gd2UgbmVlZCB0byBkb3VibGUtY2hlY2sgd2UgYXJlbid0IGluIHRoYXQgY2FzZVxuICAgIGlmICghaiQuaXNBcnJheV8ob3RoZXIpICYmIHRoaXMuc2FtcGxlLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2FtcGxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IHRoaXMuc2FtcGxlW2ldO1xuICAgICAgaWYgKCFtYXRjaGVyc1V0aWwuY29udGFpbnMob3RoZXIsIGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBBcnJheUNvbnRhaW5pbmcucHJvdG90eXBlLmphc21pbmVUb1N0cmluZyA9IGZ1bmN0aW9uKHBwKSB7XG4gICAgcmV0dXJuICc8amFzbWluZS5hcnJheUNvbnRhaW5pbmcoJyArIHBwKHRoaXMuc2FtcGxlKSArICcpPic7XG4gIH07XG5cbiAgcmV0dXJuIEFycmF5Q29udGFpbmluZztcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuQXJyYXlXaXRoRXhhY3RDb250ZW50cyA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIEFycmF5V2l0aEV4YWN0Q29udGVudHMoc2FtcGxlKSB7XG4gICAgdGhpcy5zYW1wbGUgPSBzYW1wbGU7XG4gIH1cblxuICBBcnJheVdpdGhFeGFjdENvbnRlbnRzLnByb3RvdHlwZS5hc3ltbWV0cmljTWF0Y2ggPSBmdW5jdGlvbihcbiAgICBvdGhlcixcbiAgICBtYXRjaGVyc1V0aWxcbiAgKSB7XG4gICAgaWYgKCFqJC5pc0FycmF5Xyh0aGlzLnNhbXBsZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1lvdSBtdXN0IHByb3ZpZGUgYW4gYXJyYXkgdG8gYXJyYXlXaXRoRXhhY3RDb250ZW50cywgbm90ICcgK1xuICAgICAgICAgIGokLmJhc2ljUHJldHR5UHJpbnRlcl8odGhpcy5zYW1wbGUpICtcbiAgICAgICAgICAnLidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2FtcGxlLmxlbmd0aCAhPT0gb3RoZXIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNhbXBsZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSB0aGlzLnNhbXBsZVtpXTtcbiAgICAgIGlmICghbWF0Y2hlcnNVdGlsLmNvbnRhaW5zKG90aGVyLCBpdGVtKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgQXJyYXlXaXRoRXhhY3RDb250ZW50cy5wcm90b3R5cGUuamFzbWluZVRvU3RyaW5nID0gZnVuY3Rpb24ocHApIHtcbiAgICByZXR1cm4gJzxqYXNtaW5lLmFycmF5V2l0aEV4YWN0Q29udGVudHMoJyArIHBwKHRoaXMuc2FtcGxlKSArICcpPic7XG4gIH07XG5cbiAgcmV0dXJuIEFycmF5V2l0aEV4YWN0Q29udGVudHM7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkVtcHR5ID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gRW1wdHkoKSB7fVxuXG4gIEVtcHR5LnByb3RvdHlwZS5hc3ltbWV0cmljTWF0Y2ggPSBmdW5jdGlvbihvdGhlcikge1xuICAgIGlmIChqJC5pc1N0cmluZ18ob3RoZXIpIHx8IGokLmlzQXJyYXlfKG90aGVyKSB8fCBqJC5pc1R5cGVkQXJyYXlfKG90aGVyKSkge1xuICAgICAgcmV0dXJuIG90aGVyLmxlbmd0aCA9PT0gMDtcbiAgICB9XG5cbiAgICBpZiAoaiQuaXNNYXAob3RoZXIpIHx8IGokLmlzU2V0KG90aGVyKSkge1xuICAgICAgcmV0dXJuIG90aGVyLnNpemUgPT09IDA7XG4gICAgfVxuXG4gICAgaWYgKGokLmlzT2JqZWN0XyhvdGhlcikpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvdGhlcikubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgRW1wdHkucHJvdG90eXBlLmphc21pbmVUb1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnPGphc21pbmUuZW1wdHk+JztcbiAgfTtcblxuICByZXR1cm4gRW1wdHk7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkZhbHN5ID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gRmFsc3koKSB7fVxuXG4gIEZhbHN5LnByb3RvdHlwZS5hc3ltbWV0cmljTWF0Y2ggPSBmdW5jdGlvbihvdGhlcikge1xuICAgIHJldHVybiAhb3RoZXI7XG4gIH07XG5cbiAgRmFsc3kucHJvdG90eXBlLmphc21pbmVUb1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnPGphc21pbmUuZmFsc3k+JztcbiAgfTtcblxuICByZXR1cm4gRmFsc3k7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLk1hcENvbnRhaW5pbmcgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBNYXBDb250YWluaW5nKHNhbXBsZSkge1xuICAgIGlmICghaiQuaXNNYXAoc2FtcGxlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnWW91IG11c3QgcHJvdmlkZSBhIG1hcCB0byBgbWFwQ29udGFpbmluZ2AsIG5vdCAnICtcbiAgICAgICAgICBqJC5iYXNpY1ByZXR0eVByaW50ZXJfKHNhbXBsZSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5zYW1wbGUgPSBzYW1wbGU7XG4gIH1cblxuICBNYXBDb250YWluaW5nLnByb3RvdHlwZS5hc3ltbWV0cmljTWF0Y2ggPSBmdW5jdGlvbihvdGhlciwgbWF0Y2hlcnNVdGlsKSB7XG4gICAgaWYgKCFqJC5pc01hcChvdGhlcikpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuc2FtcGxlKSB7XG4gICAgICAvLyBmb3IgZWFjaCBrZXkvdmFsdWUgcGFpciBpbiBgc2FtcGxlYFxuICAgICAgLy8gdGhlcmUgc2hvdWxkIGJlIGF0IGxlYXN0IG9uZSBwYWlyIGluIGBvdGhlcmAgd2hvc2Uga2V5IGFuZCB2YWx1ZSBib3RoIG1hdGNoXG4gICAgICB2YXIgaGFzTWF0Y2ggPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3QgW29LZXksIG9WYWx1ZV0gb2Ygb3RoZXIpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG1hdGNoZXJzVXRpbC5lcXVhbHMob0tleSwga2V5KSAmJlxuICAgICAgICAgIG1hdGNoZXJzVXRpbC5lcXVhbHMob1ZhbHVlLCB2YWx1ZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaGFzTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFzTWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIE1hcENvbnRhaW5pbmcucHJvdG90eXBlLmphc21pbmVUb1N0cmluZyA9IGZ1bmN0aW9uKHBwKSB7XG4gICAgcmV0dXJuICc8amFzbWluZS5tYXBDb250YWluaW5nKCcgKyBwcCh0aGlzLnNhbXBsZSkgKyAnKT4nO1xuICB9O1xuXG4gIHJldHVybiBNYXBDb250YWluaW5nO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5Ob3RFbXB0eSA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIE5vdEVtcHR5KCkge31cblxuICBOb3RFbXB0eS5wcm90b3R5cGUuYXN5bW1ldHJpY01hdGNoID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICBpZiAoaiQuaXNTdHJpbmdfKG90aGVyKSB8fCBqJC5pc0FycmF5XyhvdGhlcikgfHwgaiQuaXNUeXBlZEFycmF5XyhvdGhlcikpIHtcbiAgICAgIHJldHVybiBvdGhlci5sZW5ndGggIT09IDA7XG4gICAgfVxuXG4gICAgaWYgKGokLmlzTWFwKG90aGVyKSB8fCBqJC5pc1NldChvdGhlcikpIHtcbiAgICAgIHJldHVybiBvdGhlci5zaXplICE9PSAwO1xuICAgIH1cblxuICAgIGlmIChqJC5pc09iamVjdF8ob3RoZXIpKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMob3RoZXIpLmxlbmd0aCAhPT0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgTm90RW1wdHkucHJvdG90eXBlLmphc21pbmVUb1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnPGphc21pbmUubm90RW1wdHk+JztcbiAgfTtcblxuICByZXR1cm4gTm90RW1wdHk7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLk9iamVjdENvbnRhaW5pbmcgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBPYmplY3RDb250YWluaW5nKHNhbXBsZSkge1xuICAgIHRoaXMuc2FtcGxlID0gc2FtcGxlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzUHJvcGVydHkob2JqLCBwcm9wZXJ0eSkge1xuICAgIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3BlcnR5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhc1Byb3BlcnR5KE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopLCBwcm9wZXJ0eSk7XG4gIH1cblxuICBPYmplY3RDb250YWluaW5nLnByb3RvdHlwZS5hc3ltbWV0cmljTWF0Y2ggPSBmdW5jdGlvbihvdGhlciwgbWF0Y2hlcnNVdGlsKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnNhbXBsZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJZb3UgbXVzdCBwcm92aWRlIGFuIG9iamVjdCB0byBvYmplY3RDb250YWluaW5nLCBub3QgJ1wiICtcbiAgICAgICAgICB0aGlzLnNhbXBsZSArXG4gICAgICAgICAgXCInLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG90aGVyICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMuc2FtcGxlKSB7XG4gICAgICBpZiAoXG4gICAgICAgICFoYXNQcm9wZXJ0eShvdGhlciwgcHJvcGVydHkpIHx8XG4gICAgICAgICFtYXRjaGVyc1V0aWwuZXF1YWxzKHRoaXMuc2FtcGxlW3Byb3BlcnR5XSwgb3RoZXJbcHJvcGVydHldKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBPYmplY3RDb250YWluaW5nLnByb3RvdHlwZS52YWx1ZXNGb3JEaWZmXyA9IGZ1bmN0aW9uKG90aGVyLCBwcCkge1xuICAgIGlmICghaiQuaXNPYmplY3RfKG90aGVyKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZjogdGhpcy5qYXNtaW5lVG9TdHJpbmcocHApLFxuICAgICAgICBvdGhlcjogb3RoZXJcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGZpbHRlcmVkT3RoZXIgPSB7fTtcbiAgICBPYmplY3Qua2V5cyh0aGlzLnNhbXBsZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICAvLyBlcSBzaG9ydC1jaXJjdWl0cyBjb21wYXJpc29uIG9mIG9iamVjdHMgdGhhdCBoYXZlIGRpZmZlcmVudCBrZXkgc2V0cyxcbiAgICAgIC8vIHNvIGluY2x1ZGUgYWxsIGtleXMgZXZlbiBpZiB1bmRlZmluZWQuXG4gICAgICBmaWx0ZXJlZE90aGVyW2tdID0gb3RoZXJba107XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2VsZjogdGhpcy5zYW1wbGUsXG4gICAgICBvdGhlcjogZmlsdGVyZWRPdGhlclxuICAgIH07XG4gIH07XG5cbiAgT2JqZWN0Q29udGFpbmluZy5wcm90b3R5cGUuamFzbWluZVRvU3RyaW5nID0gZnVuY3Rpb24ocHApIHtcbiAgICByZXR1cm4gJzxqYXNtaW5lLm9iamVjdENvbnRhaW5pbmcoJyArIHBwKHRoaXMuc2FtcGxlKSArICcpPic7XG4gIH07XG5cbiAgcmV0dXJuIE9iamVjdENvbnRhaW5pbmc7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlNldENvbnRhaW5pbmcgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBTZXRDb250YWluaW5nKHNhbXBsZSkge1xuICAgIGlmICghaiQuaXNTZXQoc2FtcGxlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnWW91IG11c3QgcHJvdmlkZSBhIHNldCB0byBgc2V0Q29udGFpbmluZ2AsIG5vdCAnICtcbiAgICAgICAgICBqJC5iYXNpY1ByZXR0eVByaW50ZXJfKHNhbXBsZSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5zYW1wbGUgPSBzYW1wbGU7XG4gIH1cblxuICBTZXRDb250YWluaW5nLnByb3RvdHlwZS5hc3ltbWV0cmljTWF0Y2ggPSBmdW5jdGlvbihvdGhlciwgbWF0Y2hlcnNVdGlsKSB7XG4gICAgaWYgKCFqJC5pc1NldChvdGhlcikpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLnNhbXBsZSkge1xuICAgICAgLy8gZm9yIGVhY2ggaXRlbSBpbiBgc2FtcGxlYCB0aGVyZSBzaG91bGQgYmUgYXQgbGVhc3Qgb25lIG1hdGNoaW5nIGl0ZW0gaW4gYG90aGVyYFxuICAgICAgLy8gKG5vdCB1c2luZyBgbWF0Y2hlcnNVdGlsLmNvbnRhaW5zYCBiZWNhdXNlIGl0IGNvbXBhcmVzIHNldCBtZW1iZXJzIGJ5IHJlZmVyZW5jZSxcbiAgICAgIC8vIG5vdCBieSBkZWVwIHZhbHVlIGVxdWFsaXR5KVxuICAgICAgdmFyIGhhc01hdGNoID0gZmFsc2U7XG4gICAgICBmb3IgKGNvbnN0IG9JdGVtIG9mIG90aGVyKSB7XG4gICAgICAgIGlmIChtYXRjaGVyc1V0aWwuZXF1YWxzKG9JdGVtLCBpdGVtKSkge1xuICAgICAgICAgIGhhc01hdGNoID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWhhc01hdGNoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBTZXRDb250YWluaW5nLnByb3RvdHlwZS5qYXNtaW5lVG9TdHJpbmcgPSBmdW5jdGlvbihwcCkge1xuICAgIHJldHVybiAnPGphc21pbmUuc2V0Q29udGFpbmluZygnICsgcHAodGhpcy5zYW1wbGUpICsgJyk+JztcbiAgfTtcblxuICByZXR1cm4gU2V0Q29udGFpbmluZztcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuU3RyaW5nQ29udGFpbmluZyA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIFN0cmluZ0NvbnRhaW5pbmcoZXhwZWN0ZWQpIHtcbiAgICBpZiAoIWokLmlzU3RyaW5nXyhleHBlY3RlZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaXMgbm90IGEgU3RyaW5nJyk7XG4gICAgfVxuXG4gICAgdGhpcy5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICB9XG5cbiAgU3RyaW5nQ29udGFpbmluZy5wcm90b3R5cGUuYXN5bW1ldHJpY01hdGNoID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICBpZiAoIWokLmlzU3RyaW5nXyhvdGhlcikpIHtcbiAgICAgIC8vIEFycmF5cywgZXRjLiBkb24ndCBtYXRjaCBubyBtYXR0ZXIgd2hhdCB0aGVpciBpbmRleE9mIHJldHVybnMuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIG90aGVyLmluZGV4T2YodGhpcy5leHBlY3RlZCkgIT09IC0xO1xuICB9O1xuXG4gIFN0cmluZ0NvbnRhaW5pbmcucHJvdG90eXBlLmphc21pbmVUb1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnPGphc21pbmUuc3RyaW5nQ29udGFpbmluZyhcIicgKyB0aGlzLmV4cGVjdGVkICsgJ1wiKT4nO1xuICB9O1xuXG4gIHJldHVybiBTdHJpbmdDb250YWluaW5nO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5TdHJpbmdNYXRjaGluZyA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIFN0cmluZ01hdGNoaW5nKGV4cGVjdGVkKSB7XG4gICAgaWYgKCFqJC5pc1N0cmluZ18oZXhwZWN0ZWQpICYmICFqJC5pc0FfKCdSZWdFeHAnLCBleHBlY3RlZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaXMgbm90IGEgU3RyaW5nIG9yIGEgUmVnRXhwJyk7XG4gICAgfVxuXG4gICAgdGhpcy5yZWdleHAgPSBuZXcgUmVnRXhwKGV4cGVjdGVkKTtcbiAgfVxuXG4gIFN0cmluZ01hdGNoaW5nLnByb3RvdHlwZS5hc3ltbWV0cmljTWF0Y2ggPSBmdW5jdGlvbihvdGhlcikge1xuICAgIHJldHVybiB0aGlzLnJlZ2V4cC50ZXN0KG90aGVyKTtcbiAgfTtcblxuICBTdHJpbmdNYXRjaGluZy5wcm90b3R5cGUuamFzbWluZVRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICc8amFzbWluZS5zdHJpbmdNYXRjaGluZygnICsgdGhpcy5yZWdleHAgKyAnKT4nO1xuICB9O1xuXG4gIHJldHVybiBTdHJpbmdNYXRjaGluZztcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuVHJ1dGh5ID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gVHJ1dGh5KCkge31cblxuICBUcnV0aHkucHJvdG90eXBlLmFzeW1tZXRyaWNNYXRjaCA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgcmV0dXJuICEhb3RoZXI7XG4gIH07XG5cbiAgVHJ1dGh5LnByb3RvdHlwZS5qYXNtaW5lVG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJzxqYXNtaW5lLnRydXRoeT4nO1xuICB9O1xuXG4gIHJldHVybiBUcnV0aHk7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkNhbGxUcmFja2VyID0gZnVuY3Rpb24oaiQpIHtcbiAgLyoqXG4gICAqIEBuYW1lc3BhY2UgU3B5I2NhbGxzXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKi9cbiAgZnVuY3Rpb24gQ2FsbFRyYWNrZXIoKSB7XG4gICAgdmFyIGNhbGxzID0gW107XG4gICAgdmFyIG9wdHMgPSB7fTtcblxuICAgIHRoaXMudHJhY2sgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICBpZiAob3B0cy5jbG9uZUFyZ3MpIHtcbiAgICAgICAgY29udGV4dC5hcmdzID0gaiQudXRpbC5jbG9uZUFyZ3MoY29udGV4dC5hcmdzKTtcbiAgICAgIH1cbiAgICAgIGNhbGxzLnB1c2goY29udGV4dCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhpcyBzcHkgaGFzIGJlZW4gaW52b2tlZC5cbiAgICAgKiBAbmFtZSBTcHkjY2FsbHMjYW55XG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmFueSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICEhY2FsbHMubGVuZ3RoO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG51bWJlciBvZiBpbnZvY2F0aW9ucyBvZiB0aGlzIHNweS5cbiAgICAgKiBAbmFtZSBTcHkjY2FsbHMjY291bnRcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtJbnRlZ2VyfVxuICAgICAqL1xuICAgIHRoaXMuY291bnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjYWxscy5sZW5ndGg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYXJndW1lbnRzIHRoYXQgd2VyZSBwYXNzZWQgdG8gYSBzcGVjaWZpYyBpbnZvY2F0aW9uIG9mIHRoaXMgc3B5LlxuICAgICAqIEBuYW1lIFNweSNjYWxscyNhcmdzRm9yXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBpbmRleCBUaGUgMC1iYXNlZCBpbnZvY2F0aW9uIGluZGV4LlxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYXJnc0ZvciA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICB2YXIgY2FsbCA9IGNhbGxzW2luZGV4XTtcbiAgICAgIHJldHVybiBjYWxsID8gY2FsbC5hcmdzIDogW107XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgXCJ0aGlzXCIgb2JqZWN0IHRoYXQgd2FzIHBhc3NlZCB0byBhIHNwZWNpZmljIGludm9jYXRpb24gb2YgdGhpcyBzcHkuXG4gICAgICogQG5hbWUgU3B5I2NhbGxzI3RoaXNGb3JcbiAgICAgKiBAc2luY2UgMy44LjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGluZGV4IFRoZSAwLWJhc2VkIGludm9jYXRpb24gaW5kZXguXG4gICAgICogQHJldHVybiB7T2JqZWN0P31cbiAgICAgKi9cbiAgICB0aGlzLnRoaXNGb3IgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgdmFyIGNhbGwgPSBjYWxsc1tpbmRleF07XG4gICAgICByZXR1cm4gY2FsbCA/IGNhbGwub2JqZWN0IDogdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHJhdyBjYWxscyBhcnJheSBmb3IgdGhpcyBzcHkuXG4gICAgICogQG5hbWUgU3B5I2NhbGxzI2FsbFxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge1NweS5jYWxsRGF0YVtdfVxuICAgICAqL1xuICAgIHRoaXMuYWxsID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY2FsbHM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgb2YgdGhlIGFyZ3VtZW50cyBmb3IgZWFjaCBpbnZvY2F0aW9uIG9mIHRoaXMgc3B5IGluIHRoZSBvcmRlciB0aGV5IHdlcmUgcmVjZWl2ZWQuXG4gICAgICogQG5hbWUgU3B5I2NhbGxzI2FsbEFyZ3NcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmFsbEFyZ3MgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjYWxsQXJncyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsQXJncy5wdXNoKGNhbGxzW2ldLmFyZ3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FsbEFyZ3M7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZmlyc3QgaW52b2NhdGlvbiBvZiB0aGlzIHNweS5cbiAgICAgKiBAbmFtZSBTcHkjY2FsbHMjZmlyc3RcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtPYmplY1NweS5jYWxsRGF0YX1cbiAgICAgKi9cbiAgICB0aGlzLmZpcnN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY2FsbHNbMF07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbW9zdCByZWNlbnQgaW52b2NhdGlvbiBvZiB0aGlzIHNweS5cbiAgICAgKiBAbmFtZSBTcHkjY2FsbHMjbW9zdFJlY2VudFxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge09iamVjU3B5LmNhbGxEYXRhfVxuICAgICAqL1xuICAgIHRoaXMubW9zdFJlY2VudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNhbGxzW2NhbGxzLmxlbmd0aCAtIDFdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGlzIHNweSBhcyBpZiBpdCBoYXMgbmV2ZXIgYmVlbiBjYWxsZWQuXG4gICAgICogQG5hbWUgU3B5I2NhbGxzI3Jlc2V0XG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgY2FsbHMgPSBbXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoaXMgc3B5IHRvIGRvIGEgc2hhbGxvdyBjbG9uZSBvZiBhcmd1bWVudHMgcGFzc2VkIHRvIGVhY2ggaW52b2NhdGlvbi5cbiAgICAgKiBAbmFtZSBTcHkjY2FsbHMjc2F2ZUFyZ3VtZW50c0J5VmFsdWVcbiAgICAgKiBAc2luY2UgMi41LjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICB0aGlzLnNhdmVBcmd1bWVudHNCeVZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICBvcHRzLmNsb25lQXJncyA9IHRydWU7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBDYWxsVHJhY2tlcjtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuY2xlYXJTdGFjayA9IGZ1bmN0aW9uKGokKSB7XG4gIHZhciBtYXhJbmxpbmVDYWxsQ291bnQgPSAxMDtcblxuICBmdW5jdGlvbiBtZXNzYWdlQ2hhbm5lbEltcGwoZ2xvYmFsLCBzZXRUaW1lb3V0KSB7XG4gICAgdmFyIGNoYW5uZWwgPSBuZXcgZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKCksXG4gICAgICBoZWFkID0ge30sXG4gICAgICB0YWlsID0gaGVhZDtcblxuICAgIHZhciB0YXNrUnVubmluZyA9IGZhbHNlO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdmFyIHRhc2sgPSBoZWFkLnRhc2s7XG4gICAgICBkZWxldGUgaGVhZC50YXNrO1xuXG4gICAgICBpZiAodGFza1J1bm5pbmcpIHtcbiAgICAgICAgZ2xvYmFsLnNldFRpbWVvdXQodGFzaywgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRhc2tSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICB0YXNrKCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGFza1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgY3VycmVudENhbGxDb3VudCA9IDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNsZWFyU3RhY2soZm4pIHtcbiAgICAgIGN1cnJlbnRDYWxsQ291bnQrKztcblxuICAgICAgaWYgKGN1cnJlbnRDYWxsQ291bnQgPCBtYXhJbmxpbmVDYWxsQ291bnQpIHtcbiAgICAgICAgdGFpbCA9IHRhaWwubmV4dCA9IHsgdGFzazogZm4gfTtcbiAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRDYWxsQ291bnQgPSAwO1xuICAgICAgICBzZXRUaW1lb3V0KGZuKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2xlYXJTdGFjayhnbG9iYWwpIHtcbiAgICB2YXIgY3VycmVudENhbGxDb3VudCA9IDA7XG4gICAgdmFyIHJlYWxTZXRUaW1lb3V0ID0gZ2xvYmFsLnNldFRpbWVvdXQ7XG4gICAgdmFyIHNldFRpbWVvdXRJbXBsID0gZnVuY3Rpb24gY2xlYXJTdGFjayhmbikge1xuICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KHJlYWxTZXRUaW1lb3V0LCBbZ2xvYmFsLCBbZm4sIDBdXSk7XG4gICAgfTtcblxuICAgIGlmIChqJC5pc0Z1bmN0aW9uXyhnbG9iYWwuc2V0SW1tZWRpYXRlKSkge1xuICAgICAgdmFyIHJlYWxTZXRJbW1lZGlhdGUgPSBnbG9iYWwuc2V0SW1tZWRpYXRlO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgIGN1cnJlbnRDYWxsQ291bnQrKztcblxuICAgICAgICBpZiAoY3VycmVudENhbGxDb3VudCA8IG1heElubGluZUNhbGxDb3VudCkge1xuICAgICAgICAgIHJlYWxTZXRJbW1lZGlhdGUoZm4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRDYWxsQ291bnQgPSAwO1xuXG4gICAgICAgICAgc2V0VGltZW91dEltcGwoZm4pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoIWokLnV0aWwuaXNVbmRlZmluZWQoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSkge1xuICAgICAgcmV0dXJuIG1lc3NhZ2VDaGFubmVsSW1wbChnbG9iYWwsIHNldFRpbWVvdXRJbXBsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNldFRpbWVvdXRJbXBsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBnZXRDbGVhclN0YWNrO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5DbG9jayA9IGZ1bmN0aW9uKCkge1xuICAvKiBnbG9iYWwgcHJvY2VzcyAqL1xuICB2YXIgTk9ERV9KUyA9XG4gICAgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmXG4gICAgcHJvY2Vzcy52ZXJzaW9ucyAmJlxuICAgIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUgPT09ICdzdHJpbmcnO1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgQ2xvY2tcbiAgICogQHNpbmNlIDEuMy4wXG4gICAqIEBjbGFzc2Rlc2MgSmFzbWluZSdzIG1vY2sgY2xvY2sgaXMgdXNlZCB3aGVuIHRlc3RpbmcgdGltZSBkZXBlbmRlbnQgY29kZS48YnI+XG4gICAqIF9Ob3RlOl8gRG8gbm90IGNvbnN0cnVjdCB0aGlzIGRpcmVjdGx5LiBZb3UgY2FuIGdldCB0aGUgY3VycmVudCBjbG9jayB3aXRoXG4gICAqIHtAbGluayBqYXNtaW5lLmNsb2NrfS5cbiAgICogQGhpZGVjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gQ2xvY2soZ2xvYmFsLCBkZWxheWVkRnVuY3Rpb25TY2hlZHVsZXJGYWN0b3J5LCBtb2NrRGF0ZSkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIHJlYWxUaW1pbmdGdW5jdGlvbnMgPSB7XG4gICAgICAgIHNldFRpbWVvdXQ6IGdsb2JhbC5zZXRUaW1lb3V0LFxuICAgICAgICBjbGVhclRpbWVvdXQ6IGdsb2JhbC5jbGVhclRpbWVvdXQsXG4gICAgICAgIHNldEludGVydmFsOiBnbG9iYWwuc2V0SW50ZXJ2YWwsXG4gICAgICAgIGNsZWFySW50ZXJ2YWw6IGdsb2JhbC5jbGVhckludGVydmFsXG4gICAgICB9LFxuICAgICAgZmFrZVRpbWluZ0Z1bmN0aW9ucyA9IHtcbiAgICAgICAgc2V0VGltZW91dDogc2V0VGltZW91dCxcbiAgICAgICAgY2xlYXJUaW1lb3V0OiBjbGVhclRpbWVvdXQsXG4gICAgICAgIHNldEludGVydmFsOiBzZXRJbnRlcnZhbCxcbiAgICAgICAgY2xlYXJJbnRlcnZhbDogY2xlYXJJbnRlcnZhbFxuICAgICAgfSxcbiAgICAgIGluc3RhbGxlZCA9IGZhbHNlLFxuICAgICAgZGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyLFxuICAgICAgdGltZXI7XG5cbiAgICBzZWxmLkZha2VUaW1lb3V0ID0gRmFrZVRpbWVvdXQ7XG5cbiAgICAvKipcbiAgICAgKiBJbnN0YWxsIHRoZSBtb2NrIGNsb2NrIG92ZXIgdGhlIGJ1aWx0LWluIG1ldGhvZHMuXG4gICAgICogQG5hbWUgQ2xvY2sjaW5zdGFsbFxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge0Nsb2NrfVxuICAgICAqL1xuICAgIHNlbGYuaW5zdGFsbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFvcmlnaW5hbFRpbWluZ0Z1bmN0aW9uc0ludGFjdCgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnSmFzbWluZSBDbG9jayB3YXMgdW5hYmxlIHRvIGluc3RhbGwgb3ZlciBjdXN0b20gZ2xvYmFsIHRpbWVyIGZ1bmN0aW9ucy4gSXMgdGhlIGNsb2NrIGFscmVhZHkgaW5zdGFsbGVkPydcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJlcGxhY2UoZ2xvYmFsLCBmYWtlVGltaW5nRnVuY3Rpb25zKTtcbiAgICAgIHRpbWVyID0gZmFrZVRpbWluZ0Z1bmN0aW9ucztcbiAgICAgIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlciA9IGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlckZhY3RvcnkoKTtcbiAgICAgIGluc3RhbGxlZCA9IHRydWU7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVbmluc3RhbGwgdGhlIG1vY2sgY2xvY2ssIHJldHVybmluZyB0aGUgYnVpbHQtaW4gbWV0aG9kcyB0byB0aGVpciBwbGFjZXMuXG4gICAgICogQG5hbWUgQ2xvY2sjdW5pbnN0YWxsXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgc2VsZi51bmluc3RhbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlciA9IG51bGw7XG4gICAgICBtb2NrRGF0ZS51bmluc3RhbGwoKTtcbiAgICAgIHJlcGxhY2UoZ2xvYmFsLCByZWFsVGltaW5nRnVuY3Rpb25zKTtcblxuICAgICAgdGltZXIgPSByZWFsVGltaW5nRnVuY3Rpb25zO1xuICAgICAgaW5zdGFsbGVkID0gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgYSBmdW5jdGlvbiB3aXRoIGEgbW9ja2VkIENsb2NrXG4gICAgICpcbiAgICAgKiBUaGUgY2xvY2sgd2lsbCBiZSB7QGxpbmsgQ2xvY2sjaW5zdGFsbHxpbnN0YWxsfWVkIGJlZm9yZSB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIGFuZCB7QGxpbmsgQ2xvY2sjdW5pbnN0YWxsfHVuaW5zdGFsbH1lZCBpbiBhIGBmaW5hbGx5YCBhZnRlciB0aGUgZnVuY3Rpb24gY29tcGxldGVzLlxuICAgICAqIEBuYW1lIENsb2NrI3dpdGhNb2NrXG4gICAgICogQHNpbmNlIDIuMy4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2xvc3VyZSBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxuICAgICAqL1xuICAgIHNlbGYud2l0aE1vY2sgPSBmdW5jdGlvbihjbG9zdXJlKSB7XG4gICAgICB0aGlzLmluc3RhbGwoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNsb3N1cmUoKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMudW5pbnN0YWxsKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEluc3RydWN0IHRoZSBpbnN0YWxsZWQgQ2xvY2sgdG8gYWxzbyBtb2NrIHRoZSBkYXRlIHJldHVybmVkIGJ5IGBuZXcgRGF0ZSgpYFxuICAgICAqIEBuYW1lIENsb2NrI21vY2tEYXRlXG4gICAgICogQHNpbmNlIDIuMS4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtEYXRlfSBbaW5pdGlhbERhdGU9bm93XSBUaGUgYERhdGVgIHRvIHByb3ZpZGUuXG4gICAgICovXG4gICAgc2VsZi5tb2NrRGF0ZSA9IGZ1bmN0aW9uKGluaXRpYWxEYXRlKSB7XG4gICAgICBtb2NrRGF0ZS5pbnN0YWxsKGluaXRpYWxEYXRlKTtcbiAgICB9O1xuXG4gICAgc2VsZi5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oZm4sIGRlbGF5LCBwYXJhbXMpIHtcbiAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkodGltZXIuc2V0VGltZW91dCwgW1xuICAgICAgICBnbG9iYWwsXG4gICAgICAgIGFyZ3VtZW50c1xuICAgICAgXSk7XG4gICAgfTtcblxuICAgIHNlbGYuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbihmbiwgZGVsYXksIHBhcmFtcykge1xuICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseSh0aW1lci5zZXRJbnRlcnZhbCwgW1xuICAgICAgICBnbG9iYWwsXG4gICAgICAgIGFyZ3VtZW50c1xuICAgICAgXSk7XG4gICAgfTtcblxuICAgIHNlbGYuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbC5hcHBseSh0aW1lci5jbGVhclRpbWVvdXQsIFtnbG9iYWwsIGlkXSk7XG4gICAgfTtcblxuICAgIHNlbGYuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYXBwbHkodGltZXIuY2xlYXJJbnRlcnZhbCwgW2dsb2JhbCwgaWRdKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGljayB0aGUgQ2xvY2sgZm9yd2FyZCwgcnVubmluZyBhbnkgZW5xdWV1ZWQgdGltZW91dHMgYWxvbmcgdGhlIHdheVxuICAgICAqIEBuYW1lIENsb2NrI3RpY2tcbiAgICAgKiBAc2luY2UgMS4zLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge2ludH0gbWlsbGlzIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRpY2suXG4gICAgICovXG4gICAgc2VsZi50aWNrID0gZnVuY3Rpb24obWlsbGlzKSB7XG4gICAgICBpZiAoaW5zdGFsbGVkKSB7XG4gICAgICAgIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlci50aWNrKG1pbGxpcywgZnVuY3Rpb24obWlsbGlzKSB7XG4gICAgICAgICAgbW9ja0RhdGUudGljayhtaWxsaXMpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnTW9jayBjbG9jayBpcyBub3QgaW5zdGFsbGVkLCB1c2UgamFzbWluZS5jbG9jaygpLmluc3RhbGwoKSdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG5cbiAgICBmdW5jdGlvbiBvcmlnaW5hbFRpbWluZ0Z1bmN0aW9uc0ludGFjdCgpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGdsb2JhbC5zZXRUaW1lb3V0ID09PSByZWFsVGltaW5nRnVuY3Rpb25zLnNldFRpbWVvdXQgJiZcbiAgICAgICAgZ2xvYmFsLmNsZWFyVGltZW91dCA9PT0gcmVhbFRpbWluZ0Z1bmN0aW9ucy5jbGVhclRpbWVvdXQgJiZcbiAgICAgICAgZ2xvYmFsLnNldEludGVydmFsID09PSByZWFsVGltaW5nRnVuY3Rpb25zLnNldEludGVydmFsICYmXG4gICAgICAgIGdsb2JhbC5jbGVhckludGVydmFsID09PSByZWFsVGltaW5nRnVuY3Rpb25zLmNsZWFySW50ZXJ2YWxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZShkZXN0LCBzb3VyY2UpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgIGRlc3RbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0VGltZW91dChmbiwgZGVsYXkpIHtcbiAgICAgIGlmICghTk9ERV9KUykge1xuICAgICAgICByZXR1cm4gZGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyLnNjaGVkdWxlRnVuY3Rpb24oXG4gICAgICAgICAgZm4sXG4gICAgICAgICAgZGVsYXksXG4gICAgICAgICAgYXJnU2xpY2UoYXJndW1lbnRzLCAyKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGltZW91dCA9IG5ldyBGYWtlVGltZW91dCgpO1xuXG4gICAgICBkZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIuc2NoZWR1bGVGdW5jdGlvbihcbiAgICAgICAgZm4sXG4gICAgICAgIGRlbGF5LFxuICAgICAgICBhcmdTbGljZShhcmd1bWVudHMsIDIpLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGltZW91dFxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHRpbWVvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJUaW1lb3V0KGlkKSB7XG4gICAgICByZXR1cm4gZGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyLnJlbW92ZUZ1bmN0aW9uV2l0aElkKGlkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRJbnRlcnZhbChmbiwgaW50ZXJ2YWwpIHtcbiAgICAgIGlmICghTk9ERV9KUykge1xuICAgICAgICByZXR1cm4gZGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyLnNjaGVkdWxlRnVuY3Rpb24oXG4gICAgICAgICAgZm4sXG4gICAgICAgICAgaW50ZXJ2YWwsXG4gICAgICAgICAgYXJnU2xpY2UoYXJndW1lbnRzLCAyKSxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0aW1lb3V0ID0gbmV3IEZha2VUaW1lb3V0KCk7XG5cbiAgICAgIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlci5zY2hlZHVsZUZ1bmN0aW9uKFxuICAgICAgICBmbixcbiAgICAgICAgaW50ZXJ2YWwsXG4gICAgICAgIGFyZ1NsaWNlKGFyZ3VtZW50cywgMiksXG4gICAgICAgIHRydWUsXG4gICAgICAgIHRpbWVvdXRcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB0aW1lb3V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW50ZXJ2YWwoaWQpIHtcbiAgICAgIHJldHVybiBkZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIucmVtb3ZlRnVuY3Rpb25XaXRoSWQoaWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFyZ1NsaWNlKGFyZ3NPYmosIG4pIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzT2JqLCBuKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTW9ja3MgTm9kZS5qcyBUaW1lb3V0IGNsYXNzXG4gICAqL1xuICBmdW5jdGlvbiBGYWtlVGltZW91dCgpIHt9XG5cbiAgRmFrZVRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEZha2VUaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiBDbG9jaztcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuQ29tcGxldGVPbkZpcnN0RXJyb3JTa2lwUG9saWN5ID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gQ29tcGxldGVPbkZpcnN0RXJyb3JTa2lwUG9saWN5KHF1ZXVlYWJsZUZucykge1xuICAgIHRoaXMucXVldWVhYmxlRm5zXyA9IHF1ZXVlYWJsZUZucztcbiAgICB0aGlzLmVycm9yZWRGbkl4XyA9IG51bGw7XG4gIH1cblxuICBDb21wbGV0ZU9uRmlyc3RFcnJvclNraXBQb2xpY3kucHJvdG90eXBlLnNraXBUbyA9IGZ1bmN0aW9uKGxhc3RSYW5Gbkl4KSB7XG4gICAgbGV0IGk7XG5cbiAgICBmb3IgKFxuICAgICAgaSA9IGxhc3RSYW5Gbkl4ICsgMTtcbiAgICAgIGkgPCB0aGlzLnF1ZXVlYWJsZUZuc18ubGVuZ3RoICYmIHRoaXMuc2hvdWxkU2tpcF8oaSk7XG4gICAgICBpKytcbiAgICApIHt9XG4gICAgcmV0dXJuIGk7XG4gIH07XG5cbiAgQ29tcGxldGVPbkZpcnN0RXJyb3JTa2lwUG9saWN5LnByb3RvdHlwZS5mbkVycm9yZWQgPSBmdW5jdGlvbihmbkl4KSB7XG4gICAgdGhpcy5lcnJvcmVkRm5JeF8gPSBmbkl4O1xuICB9O1xuXG4gIENvbXBsZXRlT25GaXJzdEVycm9yU2tpcFBvbGljeS5wcm90b3R5cGUuc2hvdWxkU2tpcF8gPSBmdW5jdGlvbihmbkl4KSB7XG4gICAgaWYgKHRoaXMuZXJyb3JlZEZuSXhfID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgZm4gPSB0aGlzLnF1ZXVlYWJsZUZuc19bZm5JeF07XG4gICAgY29uc3QgY2FuZGlkYXRlU3VpdGUgPSBmbi5zdWl0ZTtcbiAgICBjb25zdCBlcnJvclN1aXRlID0gdGhpcy5xdWV1ZWFibGVGbnNfW3RoaXMuZXJyb3JlZEZuSXhfXS5zdWl0ZTtcbiAgICBjb25zdCB3YXNDbGVhbnVwRm4gPVxuICAgICAgZm4udHlwZSA9PT0gJ2FmdGVyRWFjaCcgfHxcbiAgICAgIGZuLnR5cGUgPT09ICdhZnRlckFsbCcgfHxcbiAgICAgIGZuLnR5cGUgPT09ICdzcGVjQ2xlYW51cCc7XG4gICAgcmV0dXJuIChcbiAgICAgICF3YXNDbGVhbnVwRm4gfHxcbiAgICAgIChjYW5kaWRhdGVTdWl0ZSAmJiBpc0Rlc2NlbmRlbnQoY2FuZGlkYXRlU3VpdGUsIGVycm9yU3VpdGUpKVxuICAgICk7XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNEZXNjZW5kZW50KGNhbmRpZGF0ZSwgYW5jZXN0b3IpIHtcbiAgICBpZiAoIWNhbmRpZGF0ZS5wYXJlbnRTdWl0ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoY2FuZGlkYXRlLnBhcmVudFN1aXRlID09PSBhbmNlc3Rvcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpc0Rlc2NlbmRlbnQoY2FuZGlkYXRlLnBhcmVudFN1aXRlLCBhbmNlc3Rvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIENvbXBsZXRlT25GaXJzdEVycm9yU2tpcFBvbGljeTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuRGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gRGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgc2NoZWR1bGVkTG9va3VwID0gW107XG4gICAgdmFyIHNjaGVkdWxlZEZ1bmN0aW9ucyA9IHt9O1xuICAgIHZhciBjdXJyZW50VGltZSA9IDA7XG4gICAgdmFyIGRlbGF5ZWRGbkNvdW50ID0gMDtcbiAgICB2YXIgZGVsZXRlZEtleXMgPSBbXTtcblxuICAgIHNlbGYudGljayA9IGZ1bmN0aW9uKG1pbGxpcywgdGlja0RhdGUpIHtcbiAgICAgIG1pbGxpcyA9IG1pbGxpcyB8fCAwO1xuICAgICAgdmFyIGVuZFRpbWUgPSBjdXJyZW50VGltZSArIG1pbGxpcztcblxuICAgICAgcnVuU2NoZWR1bGVkRnVuY3Rpb25zKGVuZFRpbWUsIHRpY2tEYXRlKTtcbiAgICB9O1xuXG4gICAgc2VsZi5zY2hlZHVsZUZ1bmN0aW9uID0gZnVuY3Rpb24oXG4gICAgICBmdW5jVG9DYWxsLFxuICAgICAgbWlsbGlzLFxuICAgICAgcGFyYW1zLFxuICAgICAgcmVjdXJyaW5nLFxuICAgICAgdGltZW91dEtleSxcbiAgICAgIHJ1bkF0TWlsbGlzXG4gICAgKSB7XG4gICAgICB2YXIgZjtcbiAgICAgIGlmICh0eXBlb2YgZnVuY1RvQ2FsbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLyoganNoaW50IGV2aWw6IHRydWUgKi9cbiAgICAgICAgZiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBldmFsKGZ1bmNUb0NhbGwpO1xuICAgICAgICB9O1xuICAgICAgICAvKiBqc2hpbnQgZXZpbDogZmFsc2UgKi9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGYgPSBmdW5jVG9DYWxsO1xuICAgICAgfVxuXG4gICAgICBtaWxsaXMgPSBtaWxsaXMgfHwgMDtcbiAgICAgIHRpbWVvdXRLZXkgPSB0aW1lb3V0S2V5IHx8ICsrZGVsYXllZEZuQ291bnQ7XG4gICAgICBydW5BdE1pbGxpcyA9IHJ1bkF0TWlsbGlzIHx8IGN1cnJlbnRUaW1lICsgbWlsbGlzO1xuXG4gICAgICB2YXIgZnVuY1RvU2NoZWR1bGUgPSB7XG4gICAgICAgIHJ1bkF0TWlsbGlzOiBydW5BdE1pbGxpcyxcbiAgICAgICAgZnVuY1RvQ2FsbDogZixcbiAgICAgICAgcmVjdXJyaW5nOiByZWN1cnJpbmcsXG4gICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICB0aW1lb3V0S2V5OiB0aW1lb3V0S2V5LFxuICAgICAgICBtaWxsaXM6IG1pbGxpc1xuICAgICAgfTtcblxuICAgICAgaWYgKHJ1bkF0TWlsbGlzIGluIHNjaGVkdWxlZEZ1bmN0aW9ucykge1xuICAgICAgICBzY2hlZHVsZWRGdW5jdGlvbnNbcnVuQXRNaWxsaXNdLnB1c2goZnVuY1RvU2NoZWR1bGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NoZWR1bGVkRnVuY3Rpb25zW3J1bkF0TWlsbGlzXSA9IFtmdW5jVG9TY2hlZHVsZV07XG4gICAgICAgIHNjaGVkdWxlZExvb2t1cC5wdXNoKHJ1bkF0TWlsbGlzKTtcbiAgICAgICAgc2NoZWR1bGVkTG9va3VwLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aW1lb3V0S2V5O1xuICAgIH07XG5cbiAgICBzZWxmLnJlbW92ZUZ1bmN0aW9uV2l0aElkID0gZnVuY3Rpb24odGltZW91dEtleSkge1xuICAgICAgZGVsZXRlZEtleXMucHVzaCh0aW1lb3V0S2V5KTtcblxuICAgICAgZm9yICh2YXIgcnVuQXRNaWxsaXMgaW4gc2NoZWR1bGVkRnVuY3Rpb25zKSB7XG4gICAgICAgIHZhciBmdW5jcyA9IHNjaGVkdWxlZEZ1bmN0aW9uc1tydW5BdE1pbGxpc107XG4gICAgICAgIHZhciBpID0gaW5kZXhPZkZpcnN0VG9QYXNzKGZ1bmNzLCBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMudGltZW91dEtleSA9PT0gdGltZW91dEtleTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGkgPiAtMSkge1xuICAgICAgICAgIGlmIChmdW5jcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzY2hlZHVsZWRGdW5jdGlvbnNbcnVuQXRNaWxsaXNdO1xuICAgICAgICAgICAgZGVsZXRlRnJvbUxvb2t1cChydW5BdE1pbGxpcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZ1bmNzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpbnRlcnZhbHMgZ2V0IHJlc2NoZWR1bGVkIHdoZW4gZXhlY3V0ZWQsIHNvIHRoZXJlJ3MgbmV2ZXIgbW9yZVxuICAgICAgICAgIC8vIHRoYW4gYSBzaW5nbGUgc2NoZWR1bGVkIGZ1bmN0aW9uIHdpdGggYSBnaXZlbiB0aW1lb3V0S2V5XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG5cbiAgICBmdW5jdGlvbiBpbmRleE9mRmlyc3RUb1Bhc3MoYXJyYXksIHRlc3RGbikge1xuICAgICAgdmFyIGluZGV4ID0gLTE7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHRlc3RGbihhcnJheVtpXSkpIHtcbiAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlbGV0ZUZyb21Mb29rdXAoa2V5KSB7XG4gICAgICB2YXIgdmFsdWUgPSBOdW1iZXIoa2V5KTtcbiAgICAgIHZhciBpID0gaW5kZXhPZkZpcnN0VG9QYXNzKHNjaGVkdWxlZExvb2t1cCwgZnVuY3Rpb24obWlsbGlzKSB7XG4gICAgICAgIHJldHVybiBtaWxsaXMgPT09IHZhbHVlO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgc2NoZWR1bGVkTG9va3VwLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNjaGVkdWxlKHNjaGVkdWxlZEZuKSB7XG4gICAgICBzZWxmLnNjaGVkdWxlRnVuY3Rpb24oXG4gICAgICAgIHNjaGVkdWxlZEZuLmZ1bmNUb0NhbGwsXG4gICAgICAgIHNjaGVkdWxlZEZuLm1pbGxpcyxcbiAgICAgICAgc2NoZWR1bGVkRm4ucGFyYW1zLFxuICAgICAgICB0cnVlLFxuICAgICAgICBzY2hlZHVsZWRGbi50aW1lb3V0S2V5LFxuICAgICAgICBzY2hlZHVsZWRGbi5ydW5BdE1pbGxpcyArIHNjaGVkdWxlZEZuLm1pbGxpc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JFYWNoRnVuY3Rpb24oZnVuY3NUb1J1biwgY2FsbGJhY2spIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3NUb1J1bi5sZW5ndGg7ICsraSkge1xuICAgICAgICBjYWxsYmFjayhmdW5jc1RvUnVuW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5TY2hlZHVsZWRGdW5jdGlvbnMoZW5kVGltZSwgdGlja0RhdGUpIHtcbiAgICAgIHRpY2tEYXRlID0gdGlja0RhdGUgfHwgZnVuY3Rpb24oKSB7fTtcbiAgICAgIGlmIChzY2hlZHVsZWRMb29rdXAubGVuZ3RoID09PSAwIHx8IHNjaGVkdWxlZExvb2t1cFswXSA+IGVuZFRpbWUpIHtcbiAgICAgICAgaWYgKGVuZFRpbWUgPj0gY3VycmVudFRpbWUpIHtcbiAgICAgICAgICB0aWNrRGF0ZShlbmRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgICAgICAgIGN1cnJlbnRUaW1lID0gZW5kVGltZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGRvIHtcbiAgICAgICAgZGVsZXRlZEtleXMgPSBbXTtcbiAgICAgICAgdmFyIG5ld0N1cnJlbnRUaW1lID0gc2NoZWR1bGVkTG9va3VwLnNoaWZ0KCk7XG4gICAgICAgIGlmIChuZXdDdXJyZW50VGltZSA+PSBjdXJyZW50VGltZSkge1xuICAgICAgICAgIHRpY2tEYXRlKG5ld0N1cnJlbnRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgICAgICAgIGN1cnJlbnRUaW1lID0gbmV3Q3VycmVudFRpbWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZnVuY3NUb1J1biA9IHNjaGVkdWxlZEZ1bmN0aW9uc1tjdXJyZW50VGltZV07XG5cbiAgICAgICAgZGVsZXRlIHNjaGVkdWxlZEZ1bmN0aW9uc1tjdXJyZW50VGltZV07XG5cbiAgICAgICAgZm9yRWFjaEZ1bmN0aW9uKGZ1bmNzVG9SdW4sIGZ1bmN0aW9uKGZ1bmNUb1J1bikge1xuICAgICAgICAgIGlmIChmdW5jVG9SdW4ucmVjdXJyaW5nKSB7XG4gICAgICAgICAgICByZXNjaGVkdWxlKGZ1bmNUb1J1bik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBmb3JFYWNoRnVuY3Rpb24oZnVuY3NUb1J1biwgZnVuY3Rpb24oZnVuY1RvUnVuKSB7XG4gICAgICAgICAgaWYgKGokLnV0aWwuYXJyYXlDb250YWlucyhkZWxldGVkS2V5cywgZnVuY1RvUnVuLnRpbWVvdXRLZXkpKSB7XG4gICAgICAgICAgICAvLyBza2lwIGEgdGltZW91dEtleSBkZWxldGVkIHdoaWxzdCB3ZSB3ZXJlIHJ1bm5pbmdcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY1RvUnVuLmZ1bmNUb0NhbGwuYXBwbHkobnVsbCwgZnVuY1RvUnVuLnBhcmFtcyB8fCBbXSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWxldGVkS2V5cyA9IFtdO1xuICAgICAgfSB3aGlsZSAoXG4gICAgICAgIHNjaGVkdWxlZExvb2t1cC5sZW5ndGggPiAwICYmXG4gICAgICAgIC8vIGNoZWNraW5nIGZpcnN0IGlmIHdlJ3JlIG91dCBvZiB0aW1lIHByZXZlbnRzIHNldFRpbWVvdXQoMClcbiAgICAgICAgLy8gc2NoZWR1bGVkIGluIGEgZnVuY1RvUnVuIGZyb20gZm9yY2luZyBhbiBleHRyYSBpdGVyYXRpb25cbiAgICAgICAgY3VycmVudFRpbWUgIT09IGVuZFRpbWUgJiZcbiAgICAgICAgc2NoZWR1bGVkTG9va3VwWzBdIDw9IGVuZFRpbWVcbiAgICAgICk7XG5cbiAgICAgIC8vIHJhbiBvdXQgb2YgZnVuY3Rpb25zIHRvIGNhbGwsIGJ1dCBzdGlsbCB0aW1lIGxlZnQgb24gdGhlIGNsb2NrXG4gICAgICBpZiAoZW5kVGltZSA+PSBjdXJyZW50VGltZSkge1xuICAgICAgICB0aWNrRGF0ZShlbmRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgICAgICBjdXJyZW50VGltZSA9IGVuZFRpbWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIERlbGF5ZWRGdW5jdGlvblNjaGVkdWxlcjtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuRGVwcmVjYXRvciA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIERlcHJlY2F0b3IodG9wU3VpdGUpIHtcbiAgICB0aGlzLnRvcFN1aXRlXyA9IHRvcFN1aXRlO1xuICAgIHRoaXMudmVyYm9zZV8gPSBmYWxzZTtcbiAgICB0aGlzLnRvU3VwcHJlc3NfID0gW107XG4gIH1cblxuICB2YXIgdmVyYm9zZU5vdGUgPVxuICAgICdOb3RlOiBUaGlzIG1lc3NhZ2Ugd2lsbCBiZSBzaG93biBvbmx5IG9uY2UuIFNldCB0aGUgdmVyYm9zZURlcHJlY2F0aW9ucyAnICtcbiAgICAnY29uZmlnIHByb3BlcnR5IHRvIHRydWUgdG8gc2VlIGV2ZXJ5IG9jY3VycmVuY2UuJztcblxuICBEZXByZWNhdG9yLnByb3RvdHlwZS52ZXJib3NlRGVwcmVjYXRpb25zID0gZnVuY3Rpb24oZW5hYmxlZCkge1xuICAgIHRoaXMudmVyYm9zZV8gPSBlbmFibGVkO1xuICB9O1xuXG4gIC8vIHJ1bm5hYmxlIGlzIGEgc3BlYyBvciBhIHN1aXRlLlxuICAvLyBkZXByZWNhdGlvbiBpcyBhIHN0cmluZyBvciBhbiBFcnJvci5cbiAgLy8gU2VlIEVudiNkZXByZWNhdGVkIGZvciBhIGRlc2NyaXB0aW9uIG9mIHRoZSBvcHRpb25zIGFyZ3VtZW50LlxuICBEZXByZWNhdG9yLnByb3RvdHlwZS5hZGREZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbihcbiAgICBydW5uYWJsZSxcbiAgICBkZXByZWNhdGlvbixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKCF0aGlzLnZlcmJvc2VfICYmICFqJC5pc0Vycm9yXyhkZXByZWNhdGlvbikpIHtcbiAgICAgIGlmICh0aGlzLnRvU3VwcHJlc3NfLmluZGV4T2YoZGVwcmVjYXRpb24pICE9PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnRvU3VwcHJlc3NfLnB1c2goZGVwcmVjYXRpb24pO1xuICAgIH1cblxuICAgIHRoaXMubG9nXyhydW5uYWJsZSwgZGVwcmVjYXRpb24sIG9wdGlvbnMpO1xuICAgIHRoaXMucmVwb3J0XyhydW5uYWJsZSwgZGVwcmVjYXRpb24sIG9wdGlvbnMpO1xuICB9O1xuXG4gIERlcHJlY2F0b3IucHJvdG90eXBlLmxvZ18gPSBmdW5jdGlvbihydW5uYWJsZSwgZGVwcmVjYXRpb24sIG9wdGlvbnMpIHtcbiAgICB2YXIgY29udGV4dDtcblxuICAgIGlmIChqJC5pc0Vycm9yXyhkZXByZWNhdGlvbikpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZGVwcmVjYXRpb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChydW5uYWJsZSA9PT0gdGhpcy50b3BTdWl0ZV8gfHwgb3B0aW9ucy5pZ25vcmVSdW5uYWJsZSkge1xuICAgICAgY29udGV4dCA9ICcnO1xuICAgIH0gZWxzZSBpZiAocnVubmFibGUuY2hpbGRyZW4pIHtcbiAgICAgIGNvbnRleHQgPSAnIChpbiBzdWl0ZTogJyArIHJ1bm5hYmxlLmdldEZ1bGxOYW1lKCkgKyAnKSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQgPSAnIChpbiBzcGVjOiAnICsgcnVubmFibGUuZ2V0RnVsbE5hbWUoKSArICcpJztcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMub21pdFN0YWNrVHJhY2UpIHtcbiAgICAgIGNvbnRleHQgKz0gJ1xcbicgKyB0aGlzLnN0YWNrVHJhY2VfKCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnZlcmJvc2VfKSB7XG4gICAgICBjb250ZXh0ICs9ICdcXG4nICsgdmVyYm9zZU5vdGU7XG4gICAgfVxuXG4gICAgY29uc29sZS5lcnJvcignREVQUkVDQVRJT046ICcgKyBkZXByZWNhdGlvbiArIGNvbnRleHQpO1xuICB9O1xuXG4gIERlcHJlY2F0b3IucHJvdG90eXBlLnN0YWNrVHJhY2VfID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZvcm1hdHRlciA9IG5ldyBqJC5FeGNlcHRpb25Gb3JtYXR0ZXIoKTtcbiAgICByZXR1cm4gZm9ybWF0dGVyLnN0YWNrKGokLnV0aWwuZXJyb3JXaXRoU3RhY2soKSkucmVwbGFjZSgvXkVycm9yXFxuL20sICcnKTtcbiAgfTtcblxuICBEZXByZWNhdG9yLnByb3RvdHlwZS5yZXBvcnRfID0gZnVuY3Rpb24ocnVubmFibGUsIGRlcHJlY2F0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuaWdub3JlUnVubmFibGUpIHtcbiAgICAgIHJ1bm5hYmxlID0gdGhpcy50b3BTdWl0ZV87XG4gICAgfVxuXG4gICAgaWYgKGokLmlzRXJyb3JfKGRlcHJlY2F0aW9uKSkge1xuICAgICAgcnVubmFibGUuYWRkRGVwcmVjYXRpb25XYXJuaW5nKGRlcHJlY2F0aW9uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMudmVyYm9zZV8pIHtcbiAgICAgIGRlcHJlY2F0aW9uICs9ICdcXG4nICsgdmVyYm9zZU5vdGU7XG4gICAgfVxuXG4gICAgcnVubmFibGUuYWRkRGVwcmVjYXRpb25XYXJuaW5nKHtcbiAgICAgIG1lc3NhZ2U6IGRlcHJlY2F0aW9uLFxuICAgICAgb21pdFN0YWNrVHJhY2U6IG9wdGlvbnMub21pdFN0YWNrVHJhY2UgfHwgZmFsc2VcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gRGVwcmVjYXRvcjtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuZXJyb3JzID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIEV4cGVjdGF0aW9uRmFpbGVkKCkge31cblxuICBFeHBlY3RhdGlvbkZhaWxlZC5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgRXhwZWN0YXRpb25GYWlsZWQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXhwZWN0YXRpb25GYWlsZWQ7XG5cbiAgcmV0dXJuIHtcbiAgICBFeHBlY3RhdGlvbkZhaWxlZDogRXhwZWN0YXRpb25GYWlsZWRcbiAgfTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuRXhjZXB0aW9uRm9ybWF0dGVyID0gZnVuY3Rpb24oaiQpIHtcbiAgdmFyIGlnbm9yZWRQcm9wZXJ0aWVzID0gW1xuICAgICduYW1lJyxcbiAgICAnbWVzc2FnZScsXG4gICAgJ3N0YWNrJyxcbiAgICAnZmlsZU5hbWUnLFxuICAgICdzb3VyY2VVUkwnLFxuICAgICdsaW5lJyxcbiAgICAnbGluZU51bWJlcicsXG4gICAgJ2NvbHVtbicsXG4gICAgJ2Rlc2NyaXB0aW9uJyxcbiAgICAnamFzbWluZU1lc3NhZ2UnXG4gIF07XG5cbiAgZnVuY3Rpb24gRXhjZXB0aW9uRm9ybWF0dGVyKG9wdGlvbnMpIHtcbiAgICB2YXIgamFzbWluZUZpbGUgPSAob3B0aW9ucyAmJiBvcHRpb25zLmphc21pbmVGaWxlKSB8fCBqJC51dGlsLmphc21pbmVGaWxlKCk7XG4gICAgdGhpcy5tZXNzYWdlID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgIHZhciBtZXNzYWdlID0gJyc7XG5cbiAgICAgIGlmIChlcnJvci5qYXNtaW5lTWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlICs9IGVycm9yLmphc21pbmVNZXNzYWdlO1xuICAgICAgfSBlbHNlIGlmIChlcnJvci5uYW1lICYmIGVycm9yLm1lc3NhZ2UpIHtcbiAgICAgICAgbWVzc2FnZSArPSBlcnJvci5uYW1lICsgJzogJyArIGVycm9yLm1lc3NhZ2U7XG4gICAgICB9IGVsc2UgaWYgKGVycm9yLm1lc3NhZ2UpIHtcbiAgICAgICAgbWVzc2FnZSArPSBlcnJvci5tZXNzYWdlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVzc2FnZSArPSBlcnJvci50b1N0cmluZygpICsgJyB0aHJvd24nO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXJyb3IuZmlsZU5hbWUgfHwgZXJyb3Iuc291cmNlVVJMKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gJyBpbiAnICsgKGVycm9yLmZpbGVOYW1lIHx8IGVycm9yLnNvdXJjZVVSTCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlcnJvci5saW5lIHx8IGVycm9yLmxpbmVOdW1iZXIpIHtcbiAgICAgICAgbWVzc2FnZSArPSAnIChsaW5lICcgKyAoZXJyb3IubGluZSB8fCBlcnJvci5saW5lTnVtYmVyKSArICcpJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIHRoaXMuc3RhY2sgPSBmdW5jdGlvbihlcnJvciwgeyBvbWl0TWVzc2FnZSB9ID0ge30pIHtcbiAgICAgIGlmICghZXJyb3IgfHwgIWVycm9yLnN0YWNrKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhY2tUcmFjZSA9IG5ldyBqJC5TdGFja1RyYWNlKGVycm9yKTtcbiAgICAgIHZhciBsaW5lcyA9IGZpbHRlckphc21pbmUoc3RhY2tUcmFjZSk7XG4gICAgICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgICAgIGlmIChzdGFja1RyYWNlLm1lc3NhZ2UgJiYgIW9taXRNZXNzYWdlKSB7XG4gICAgICAgIGxpbmVzLnVuc2hpZnQoc3RhY2tUcmFjZS5tZXNzYWdlKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0ICs9IGZvcm1hdFByb3BlcnRpZXMoZXJyb3IpO1xuICAgICAgcmVzdWx0ICs9IGxpbmVzLmpvaW4oJ1xcbicpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBmaWx0ZXJKYXNtaW5lKHN0YWNrVHJhY2UpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgamFzbWluZU1hcmtlciA9XG4gICAgICAgICAgc3RhY2tUcmFjZS5zdHlsZSA9PT0gJ3dlYmtpdCcgPyAnPEphc21pbmU+JyA6ICcgICAgYXQgPEphc21pbmU+JztcblxuICAgICAgc3RhY2tUcmFjZS5mcmFtZXMuZm9yRWFjaChmdW5jdGlvbihmcmFtZSkge1xuICAgICAgICBpZiAoZnJhbWUuZmlsZSAhPT0gamFzbWluZUZpbGUpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChmcmFtZS5yYXcpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gIT09IGphc21pbmVNYXJrZXIpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChqYXNtaW5lTWFya2VyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0UHJvcGVydGllcyhlcnJvcikge1xuICAgICAgaWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBPYmplY3QpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgdmFyIGVtcHR5ID0gdHJ1ZTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBlcnJvcikge1xuICAgICAgICBpZiAoaiQudXRpbC5hcnJheUNvbnRhaW5zKGlnbm9yZWRQcm9wZXJ0aWVzLCBwcm9wKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtwcm9wXSA9IGVycm9yW3Byb3BdO1xuICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWVtcHR5KSB7XG4gICAgICAgIHJldHVybiAnZXJyb3IgcHJvcGVydGllczogJyArIGokLmJhc2ljUHJldHR5UHJpbnRlcl8ocmVzdWx0KSArICdcXG4nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEV4Y2VwdGlvbkZvcm1hdHRlcjtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuRXhwZWN0YXRpb24gPSBmdW5jdGlvbihqJCkge1xuICAvKipcbiAgICogTWF0Y2hlcnMgdGhhdCBjb21lIHdpdGggSmFzbWluZSBvdXQgb2YgdGhlIGJveC5cbiAgICogQG5hbWVzcGFjZSBtYXRjaGVyc1xuICAgKi9cbiAgZnVuY3Rpb24gRXhwZWN0YXRpb24ob3B0aW9ucykge1xuICAgIHRoaXMuZXhwZWN0b3IgPSBuZXcgaiQuRXhwZWN0b3Iob3B0aW9ucyk7XG5cbiAgICB2YXIgY3VzdG9tTWF0Y2hlcnMgPSBvcHRpb25zLmN1c3RvbU1hdGNoZXJzIHx8IHt9O1xuICAgIGZvciAodmFyIG1hdGNoZXJOYW1lIGluIGN1c3RvbU1hdGNoZXJzKSB7XG4gICAgICB0aGlzW21hdGNoZXJOYW1lXSA9IHdyYXBTeW5jQ29tcGFyZShcbiAgICAgICAgbWF0Y2hlck5hbWUsXG4gICAgICAgIGN1c3RvbU1hdGNoZXJzW21hdGNoZXJOYW1lXVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIHNvbWUgY29udGV4dCBmb3IgYW4ge0BsaW5rIGV4cGVjdH1cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3dpdGhDb250ZXh0XG4gICAqIEBzaW5jZSAzLjMuMFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSAtIEFkZGl0aW9uYWwgY29udGV4dCB0byBzaG93IHdoZW4gdGhlIG1hdGNoZXIgZmFpbHNcbiAgICogQHJldHVybiB7bWF0Y2hlcnN9XG4gICAqL1xuICBFeHBlY3RhdGlvbi5wcm90b3R5cGUud2l0aENvbnRleHQgPSBmdW5jdGlvbiB3aXRoQ29udGV4dChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIGFkZEZpbHRlcih0aGlzLCBuZXcgQ29udGV4dEFkZGluZ0ZpbHRlcihtZXNzYWdlKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEludmVydCB0aGUgbWF0Y2hlciBmb2xsb3dpbmcgdGhpcyB7QGxpbmsgZXhwZWN0fVxuICAgKiBAbWVtYmVyXG4gICAqIEBuYW1lIG1hdGNoZXJzI25vdFxuICAgKiBAc2luY2UgMS4zLjBcbiAgICogQHR5cGUge21hdGNoZXJzfVxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3Qoc29tZXRoaW5nKS5ub3QudG9CZSh0cnVlKTtcbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFeHBlY3RhdGlvbi5wcm90b3R5cGUsICdub3QnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBhZGRGaWx0ZXIodGhpcywgc3luY05lZ2F0aW5nRmlsdGVyKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBc3luY2hyb25vdXMgbWF0Y2hlcnMgdGhhdCBvcGVyYXRlIG9uIGFuIGFjdHVhbCB2YWx1ZSB3aGljaCBpcyBhIHByb21pc2UsXG4gICAqIGFuZCByZXR1cm4gYSBwcm9taXNlLlxuICAgKlxuICAgKiBNb3N0IGFzeW5jIG1hdGNoZXJzIHdpbGwgd2FpdCBpbmRlZmluaXRlbHkgZm9yIHRoZSBwcm9taXNlIHRvIGJlIHJlc29sdmVkXG4gICAqIG9yIHJlamVjdGVkLCByZXN1bHRpbmcgaW4gYSBzcGVjIHRpbWVvdXQgaWYgdGhhdCBuZXZlciBoYXBwZW5zLiBJZiB5b3VcbiAgICogZXhwZWN0IHRoYXQgdGhlIHByb21pc2Ugd2lsbCBhbHJlYWR5IGJlIHJlc29sdmVkIG9yIHJlamVjdGVkIGF0IHRoZSB0aW1lXG4gICAqIHRoZSBtYXRjaGVyIGlzIGNhbGxlZCwgeW91IGNhbiB1c2UgdGhlIHtAbGluayBhc3luYy1tYXRjaGVycyNhbHJlYWR5fVxuICAgKiBtb2RpZmllciB0byBnZXQgYSBmYXN0ZXIgZmFpbHVyZSB3aXRoIGEgbW9yZSBoZWxwZnVsIG1lc3NhZ2UuXG4gICAqXG4gICAqIE5vdGU6IFNwZWNzIG11c3QgYXdhaXQgdGhlIHJlc3VsdCBvZiBlYWNoIGFzeW5jIG1hdGNoZXIsIHJldHVybiB0aGVcbiAgICogcHJvbWlzZSByZXR1cm5lZCBieSB0aGUgbWF0Y2hlciwgb3IgcmV0dXJuIGEgcHJvbWlzZSB0aGF0J3MgZGVyaXZlZCBmcm9tXG4gICAqIHRoZSBvbmUgcmV0dXJuZWQgYnkgdGhlIG1hdGNoZXIuIE90aGVyd2lzZSB0aGUgbWF0Y2hlciB3aWxsIG5vdCBiZVxuICAgKiBldmFsdWF0ZWQgYmVmb3JlIHRoZSBzcGVjIGNvbXBsZXRlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gR29vZFxuICAgKiBhd2FpdCBleHBlY3RBc3luYyhhUHJvbWlzZSkudG9CZVJlc29sdmVkKCk7XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEdvb2RcbiAgICogcmV0dXJuIGV4cGVjdEFzeW5jKGFQcm9taXNlKS50b0JlUmVzb2x2ZWQoKTtcbiAgICogQGV4YW1wbGVcbiAgICogLy8gR29vZFxuICAgKiByZXR1cm4gZXhwZWN0QXN5bmMoYVByb21pc2UpLnRvQmVSZXNvbHZlZCgpXG4gICAqICAudGhlbihmdW5jdGlvbigpIHtcbiAgICogICAgLy8gbW9yZSBzcGVjIGNvZGVcbiAgICogIH0pO1xuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBCYWRcbiAgICogZXhwZWN0QXN5bmMoYVByb21pc2UpLnRvQmVSZXNvbHZlZCgpO1xuICAgKiBAbmFtZXNwYWNlIGFzeW5jLW1hdGNoZXJzXG4gICAqL1xuICBmdW5jdGlvbiBBc3luY0V4cGVjdGF0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLmV4cGVjdG9yID0gbmV3IGokLkV4cGVjdG9yKG9wdGlvbnMpO1xuXG4gICAgdmFyIGN1c3RvbUFzeW5jTWF0Y2hlcnMgPSBvcHRpb25zLmN1c3RvbUFzeW5jTWF0Y2hlcnMgfHwge307XG4gICAgZm9yICh2YXIgbWF0Y2hlck5hbWUgaW4gY3VzdG9tQXN5bmNNYXRjaGVycykge1xuICAgICAgdGhpc1ttYXRjaGVyTmFtZV0gPSB3cmFwQXN5bmNDb21wYXJlKFxuICAgICAgICBtYXRjaGVyTmFtZSxcbiAgICAgICAgY3VzdG9tQXN5bmNNYXRjaGVyc1ttYXRjaGVyTmFtZV1cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBzb21lIGNvbnRleHQgZm9yIGFuIHtAbGluayBleHBlY3RBc3luY31cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGFzeW5jLW1hdGNoZXJzI3dpdGhDb250ZXh0XG4gICAqIEBzaW5jZSAzLjMuMFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSAtIEFkZGl0aW9uYWwgY29udGV4dCB0byBzaG93IHdoZW4gdGhlIGFzeW5jIG1hdGNoZXIgZmFpbHNcbiAgICogQHJldHVybiB7YXN5bmMtbWF0Y2hlcnN9XG4gICAqL1xuICBBc3luY0V4cGVjdGF0aW9uLnByb3RvdHlwZS53aXRoQ29udGV4dCA9IGZ1bmN0aW9uIHdpdGhDb250ZXh0KG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gYWRkRmlsdGVyKHRoaXMsIG5ldyBDb250ZXh0QWRkaW5nRmlsdGVyKG1lc3NhZ2UpKTtcbiAgfTtcblxuICAvKipcbiAgICogSW52ZXJ0IHRoZSBtYXRjaGVyIGZvbGxvd2luZyB0aGlzIHtAbGluayBleHBlY3RBc3luY31cbiAgICogQG1lbWJlclxuICAgKiBAbmFtZSBhc3luYy1tYXRjaGVycyNub3RcbiAgICogQHR5cGUge2FzeW5jLW1hdGNoZXJzfVxuICAgKiBAZXhhbXBsZVxuICAgKiBhd2FpdCBleHBlY3RBc3luYyhteVByb21pc2UpLm5vdC50b0JlUmVzb2x2ZWQoKTtcbiAgICogQGV4YW1wbGVcbiAgICogcmV0dXJuIGV4cGVjdEFzeW5jKG15UHJvbWlzZSkubm90LnRvQmVSZXNvbHZlZCgpO1xuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFzeW5jRXhwZWN0YXRpb24ucHJvdG90eXBlLCAnbm90Jywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYWRkRmlsdGVyKHRoaXMsIGFzeW5jTmVnYXRpbmdGaWx0ZXIpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEZhaWwgYXMgc29vbiBhcyBwb3NzaWJsZSBpZiB0aGUgYWN0dWFsIGlzIHBlbmRpbmcuXG4gICAqIE90aGVyd2lzZSBldmFsdWF0ZSB0aGUgbWF0Y2hlci5cbiAgICogQG1lbWJlclxuICAgKiBAbmFtZSBhc3luYy1tYXRjaGVycyNhbHJlYWR5XG4gICAqIEBzaW5jZSAzLjguMFxuICAgKiBAdHlwZSB7YXN5bmMtbWF0Y2hlcnN9XG4gICAqIEBleGFtcGxlXG4gICAqIGF3YWl0IGV4cGVjdEFzeW5jKG15UHJvbWlzZSkuYWxyZWFkeS50b0JlUmVzb2x2ZWQoKTtcbiAgICogQGV4YW1wbGVcbiAgICogcmV0dXJuIGV4cGVjdEFzeW5jKG15UHJvbWlzZSkuYWxyZWFkeS50b0JlUmVzb2x2ZWQoKTtcbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBc3luY0V4cGVjdGF0aW9uLnByb3RvdHlwZSwgJ2FscmVhZHknLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBhZGRGaWx0ZXIodGhpcywgZXhwZWN0U2V0dGxlZFByb21pc2VGaWx0ZXIpO1xuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gd3JhcFN5bmNDb21wYXJlKG5hbWUsIG1hdGNoZXJGYWN0b3J5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZXhwZWN0b3IuY29tcGFyZShuYW1lLCBtYXRjaGVyRmFjdG9yeSwgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMuZXhwZWN0b3IucHJvY2Vzc1Jlc3VsdChyZXN1bHQpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwQXN5bmNDb21wYXJlKG5hbWUsIG1hdGNoZXJGYWN0b3J5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBDYXB0dXJlIHRoZSBjYWxsIHN0YWNrIGhlcmUsIGJlZm9yZSB3ZSBnbyBhc3luYywgc28gdGhhdCBpdCB3aWxsIGNvbnRhaW5cbiAgICAgIC8vIGZyYW1lcyB0aGF0IGFyZSByZWxldmFudCB0byB0aGUgdXNlciBpbnN0ZWFkIG9mIGp1c3QgcGFydHMgb2YgSmFzbWluZS5cbiAgICAgIHZhciBlcnJvckZvclN0YWNrID0gaiQudXRpbC5lcnJvcldpdGhTdGFjaygpO1xuXG4gICAgICByZXR1cm4gdGhpcy5leHBlY3RvclxuICAgICAgICAuY29tcGFyZShuYW1lLCBtYXRjaGVyRmFjdG9yeSwgYXJndW1lbnRzKVxuICAgICAgICAudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICBzZWxmLmV4cGVjdG9yLnByb2Nlc3NSZXN1bHQocmVzdWx0LCBlcnJvckZvclN0YWNrKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZENvcmVNYXRjaGVycyhwcm90b3R5cGUsIG1hdGNoZXJzLCB3cmFwcGVyKSB7XG4gICAgZm9yICh2YXIgbWF0Y2hlck5hbWUgaW4gbWF0Y2hlcnMpIHtcbiAgICAgIHZhciBtYXRjaGVyID0gbWF0Y2hlcnNbbWF0Y2hlck5hbWVdO1xuICAgICAgcHJvdG90eXBlW21hdGNoZXJOYW1lXSA9IHdyYXBwZXIobWF0Y2hlck5hbWUsIG1hdGNoZXIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEZpbHRlcihzb3VyY2UsIGZpbHRlcikge1xuICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKHNvdXJjZSk7XG4gICAgcmVzdWx0LmV4cGVjdG9yID0gc291cmNlLmV4cGVjdG9yLmFkZEZpbHRlcihmaWx0ZXIpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBuZWdhdGVkRmFpbHVyZU1lc3NhZ2UocmVzdWx0LCBtYXRjaGVyTmFtZSwgYXJncywgbWF0Y2hlcnNVdGlsKSB7XG4gICAgaWYgKHJlc3VsdC5tZXNzYWdlKSB7XG4gICAgICBpZiAoaiQuaXNGdW5jdGlvbl8ocmVzdWx0Lm1lc3NhZ2UpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQubWVzc2FnZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5tZXNzYWdlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFyZ3MgPSBhcmdzLnNsaWNlKCk7XG4gICAgYXJncy51bnNoaWZ0KHRydWUpO1xuICAgIGFyZ3MudW5zaGlmdChtYXRjaGVyTmFtZSk7XG4gICAgcmV0dXJuIG1hdGNoZXJzVXRpbC5idWlsZEZhaWx1cmVNZXNzYWdlLmFwcGx5KG1hdGNoZXJzVXRpbCwgYXJncyk7XG4gIH1cblxuICBmdW5jdGlvbiBuZWdhdGUocmVzdWx0KSB7XG4gICAgcmVzdWx0LnBhc3MgPSAhcmVzdWx0LnBhc3M7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBzeW5jTmVnYXRpbmdGaWx0ZXIgPSB7XG4gICAgc2VsZWN0Q29tcGFyaXNvbkZ1bmM6IGZ1bmN0aW9uKG1hdGNoZXIpIHtcbiAgICAgIGZ1bmN0aW9uIGRlZmF1bHROZWdhdGl2ZUNvbXBhcmUoKSB7XG4gICAgICAgIHJldHVybiBuZWdhdGUobWF0Y2hlci5jb21wYXJlLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF0Y2hlci5uZWdhdGl2ZUNvbXBhcmUgfHwgZGVmYXVsdE5lZ2F0aXZlQ29tcGFyZTtcbiAgICB9LFxuICAgIGJ1aWxkRmFpbHVyZU1lc3NhZ2U6IG5lZ2F0ZWRGYWlsdXJlTWVzc2FnZVxuICB9O1xuXG4gIHZhciBhc3luY05lZ2F0aW5nRmlsdGVyID0ge1xuICAgIHNlbGVjdENvbXBhcmlzb25GdW5jOiBmdW5jdGlvbihtYXRjaGVyKSB7XG4gICAgICBmdW5jdGlvbiBkZWZhdWx0TmVnYXRpdmVDb21wYXJlKCkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlci5jb21wYXJlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykudGhlbihuZWdhdGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF0Y2hlci5uZWdhdGl2ZUNvbXBhcmUgfHwgZGVmYXVsdE5lZ2F0aXZlQ29tcGFyZTtcbiAgICB9LFxuICAgIGJ1aWxkRmFpbHVyZU1lc3NhZ2U6IG5lZ2F0ZWRGYWlsdXJlTWVzc2FnZVxuICB9O1xuXG4gIHZhciBleHBlY3RTZXR0bGVkUHJvbWlzZUZpbHRlciA9IHtcbiAgICBzZWxlY3RDb21wYXJpc29uRnVuYzogZnVuY3Rpb24obWF0Y2hlcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGFjdHVhbCkge1xuICAgICAgICB2YXIgbWF0Y2hlckFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgcmV0dXJuIGokLmlzUGVuZGluZ18oYWN0dWFsKS50aGVuKGZ1bmN0aW9uKGlzUGVuZGluZykge1xuICAgICAgICAgIGlmIChpc1BlbmRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHBhc3M6IGZhbHNlLFxuICAgICAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgICAgICdFeHBlY3RlZCBhIHByb21pc2UgdG8gYmUgc2V0dGxlZCAodmlhICcgK1xuICAgICAgICAgICAgICAgICdleHBlY3RBc3luYyguLi4pLmFscmVhZHkpIGJ1dCBpdCB3YXMgcGVuZGluZy4nXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlci5jb21wYXJlLmFwcGx5KG51bGwsIG1hdGNoZXJBcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gQ29udGV4dEFkZGluZ0ZpbHRlcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuXG4gIENvbnRleHRBZGRpbmdGaWx0ZXIucHJvdG90eXBlLm1vZGlmeUZhaWx1cmVNZXNzYWdlID0gZnVuY3Rpb24obXNnKSB7XG4gICAgdmFyIG5sID0gbXNnLmluZGV4T2YoJ1xcbicpO1xuXG4gICAgaWYgKG5sID09PSAtMSkge1xuICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZSArICc6ICcgKyBtc2c7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2UgKyAnOlxcbicgKyBpbmRlbnQobXNnKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gaW5kZW50KHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC9eL2dtLCAnICAgICcpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmYWN0b3J5OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IEV4cGVjdGF0aW9uKG9wdGlvbnMgfHwge30pO1xuICAgIH0sXG4gICAgYWRkQ29yZU1hdGNoZXJzOiBmdW5jdGlvbihtYXRjaGVycykge1xuICAgICAgYWRkQ29yZU1hdGNoZXJzKEV4cGVjdGF0aW9uLnByb3RvdHlwZSwgbWF0Y2hlcnMsIHdyYXBTeW5jQ29tcGFyZSk7XG4gICAgfSxcbiAgICBhc3luY0ZhY3Rvcnk6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgQXN5bmNFeHBlY3RhdGlvbihvcHRpb25zIHx8IHt9KTtcbiAgICB9LFxuICAgIGFkZEFzeW5jQ29yZU1hdGNoZXJzOiBmdW5jdGlvbihtYXRjaGVycykge1xuICAgICAgYWRkQ29yZU1hdGNoZXJzKEFzeW5jRXhwZWN0YXRpb24ucHJvdG90eXBlLCBtYXRjaGVycywgd3JhcEFzeW5jQ29tcGFyZSk7XG4gICAgfVxuICB9O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5FeHBlY3RhdGlvbkZpbHRlckNoYWluID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIEV4cGVjdGF0aW9uRmlsdGVyQ2hhaW4obWF5YmVGaWx0ZXIsIHByZXYpIHtcbiAgICB0aGlzLmZpbHRlcl8gPSBtYXliZUZpbHRlcjtcbiAgICB0aGlzLnByZXZfID0gcHJldjtcbiAgfVxuXG4gIEV4cGVjdGF0aW9uRmlsdGVyQ2hhaW4ucHJvdG90eXBlLmFkZEZpbHRlciA9IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgIHJldHVybiBuZXcgRXhwZWN0YXRpb25GaWx0ZXJDaGFpbihmaWx0ZXIsIHRoaXMpO1xuICB9O1xuXG4gIEV4cGVjdGF0aW9uRmlsdGVyQ2hhaW4ucHJvdG90eXBlLnNlbGVjdENvbXBhcmlzb25GdW5jID0gZnVuY3Rpb24obWF0Y2hlcikge1xuICAgIHJldHVybiB0aGlzLmNhbGxGaXJzdF8oJ3NlbGVjdENvbXBhcmlzb25GdW5jJywgYXJndW1lbnRzKS5yZXN1bHQ7XG4gIH07XG5cbiAgRXhwZWN0YXRpb25GaWx0ZXJDaGFpbi5wcm90b3R5cGUuYnVpbGRGYWlsdXJlTWVzc2FnZSA9IGZ1bmN0aW9uKFxuICAgIHJlc3VsdCxcbiAgICBtYXRjaGVyTmFtZSxcbiAgICBhcmdzLFxuICAgIG1hdGNoZXJzVXRpbFxuICApIHtcbiAgICByZXR1cm4gdGhpcy5jYWxsRmlyc3RfKCdidWlsZEZhaWx1cmVNZXNzYWdlJywgYXJndW1lbnRzKS5yZXN1bHQ7XG4gIH07XG5cbiAgRXhwZWN0YXRpb25GaWx0ZXJDaGFpbi5wcm90b3R5cGUubW9kaWZ5RmFpbHVyZU1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5jYWxsRmlyc3RfKCdtb2RpZnlGYWlsdXJlTWVzc2FnZScsIGFyZ3VtZW50cykucmVzdWx0O1xuICAgIHJldHVybiByZXN1bHQgfHwgbXNnO1xuICB9O1xuXG4gIEV4cGVjdGF0aW9uRmlsdGVyQ2hhaW4ucHJvdG90eXBlLmNhbGxGaXJzdF8gPSBmdW5jdGlvbihmbmFtZSwgYXJncykge1xuICAgIHZhciBwcmV2UmVzdWx0O1xuXG4gICAgaWYgKHRoaXMucHJldl8pIHtcbiAgICAgIHByZXZSZXN1bHQgPSB0aGlzLnByZXZfLmNhbGxGaXJzdF8oZm5hbWUsIGFyZ3MpO1xuXG4gICAgICBpZiAocHJldlJlc3VsdC5mb3VuZCkge1xuICAgICAgICByZXR1cm4gcHJldlJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5maWx0ZXJfICYmIHRoaXMuZmlsdGVyX1tmbmFtZV0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZvdW5kOiB0cnVlLFxuICAgICAgICByZXN1bHQ6IHRoaXMuZmlsdGVyX1tmbmFtZV0uYXBwbHkodGhpcy5maWx0ZXJfLCBhcmdzKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBmb3VuZDogZmFsc2UgfTtcbiAgfTtcblxuICByZXR1cm4gRXhwZWN0YXRpb25GaWx0ZXJDaGFpbjtcbn07XG5cbi8vVE9ETzogZXhwZWN0YXRpb24gcmVzdWx0IG1heSBtYWtlIG1vcmUgc2Vuc2UgYXMgYSBwcmVzZW50YXRpb24gb2YgYW4gZXhwZWN0YXRpb24uXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLmJ1aWxkRXhwZWN0YXRpb25SZXN1bHQgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBidWlsZEV4cGVjdGF0aW9uUmVzdWx0KG9wdGlvbnMpIHtcbiAgICB2YXIgbWVzc2FnZUZvcm1hdHRlciA9IG9wdGlvbnMubWVzc2FnZUZvcm1hdHRlciB8fCBmdW5jdGlvbigpIHt9LFxuICAgICAgc3RhY2tGb3JtYXR0ZXIgPSBvcHRpb25zLnN0YWNrRm9ybWF0dGVyIHx8IGZ1bmN0aW9uKCkge307XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiBFeHBlY3RhdGlvblxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBtYXRjaGVyTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBtYXRjaGVyIHRoYXQgd2FzIGV4ZWN1dGVkIGZvciB0aGlzIGV4cGVjdGF0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBtZXNzYWdlIC0gVGhlIGZhaWx1cmUgbWVzc2FnZSBmb3IgdGhlIGV4cGVjdGF0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzdGFjayAtIFRoZSBzdGFjayB0cmFjZSBmb3IgdGhlIGZhaWx1cmUgaWYgYXZhaWxhYmxlLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gcGFzc2VkIC0gV2hldGhlciB0aGUgZXhwZWN0YXRpb24gcGFzc2VkIG9yIGZhaWxlZC5cbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gZXhwZWN0ZWQgLSBJZiB0aGUgZXhwZWN0YXRpb24gZmFpbGVkLCB3aGF0IHdhcyB0aGUgZXhwZWN0ZWQgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IGFjdHVhbCAtIElmIHRoZSBleHBlY3RhdGlvbiBmYWlsZWQsIHdoYXQgYWN0dWFsIHZhbHVlIHdhcyBwcm9kdWNlZC5cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ3x1bmRlZmluZWR9IGdsb2JhbEVycm9yVHlwZSAtIFRoZSB0eXBlIG9mIGFuIGVycm9yIHRoYXRcbiAgICAgKiBpcyByZXBvcnRlZCBvbiB0aGUgdG9wIHN1aXRlLiBWYWxpZCB2YWx1ZXMgYXJlIHVuZGVmaW5lZCwgXCJhZnRlckFsbFwiLFxuICAgICAqIFwibG9hZFwiLCBcImxhdGVFeHBlY3RhdGlvblwiLCBhbmQgXCJsYXRlRXJyb3JcIi5cbiAgICAgKi9cbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgbWF0Y2hlck5hbWU6IG9wdGlvbnMubWF0Y2hlck5hbWUsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlKCksXG4gICAgICBzdGFjazogb3B0aW9ucy5vbWl0U3RhY2tUcmFjZSA/ICcnIDogc3RhY2soKSxcbiAgICAgIHBhc3NlZDogb3B0aW9ucy5wYXNzZWRcbiAgICB9O1xuXG4gICAgaWYgKCFyZXN1bHQucGFzc2VkKSB7XG4gICAgICByZXN1bHQuZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xuICAgICAgcmVzdWx0LmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xuXG4gICAgICBpZiAob3B0aW9ucy5lcnJvciAmJiAhaiQuaXNTdHJpbmdfKG9wdGlvbnMuZXJyb3IpKSB7XG4gICAgICAgIGlmICgnY29kZScgaW4gb3B0aW9ucy5lcnJvcikge1xuICAgICAgICAgIHJlc3VsdC5jb2RlID0gb3B0aW9ucy5lcnJvci5jb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIG9wdGlvbnMuZXJyb3IuY29kZSA9PT0gJ0VSUl9BU1NFUlRJT04nICYmXG4gICAgICAgICAgb3B0aW9ucy5leHBlY3RlZCA9PT0gJycgJiZcbiAgICAgICAgICBvcHRpb25zLmFjdHVhbCA9PT0gJydcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmVzdWx0LmV4cGVjdGVkID0gb3B0aW9ucy5lcnJvci5leHBlY3RlZDtcbiAgICAgICAgICByZXN1bHQuYWN0dWFsID0gb3B0aW9ucy5lcnJvci5hY3R1YWw7XG4gICAgICAgICAgcmVzdWx0Lm1hdGNoZXJOYW1lID0gJ2Fzc2VydCAnICsgb3B0aW9ucy5lcnJvci5vcGVyYXRvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBmdW5jdGlvbiBtZXNzYWdlKCkge1xuICAgICAgaWYgKG9wdGlvbnMucGFzc2VkKSB7XG4gICAgICAgIHJldHVybiAnUGFzc2VkLic7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMubWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5tZXNzYWdlO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmVycm9yKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlRm9ybWF0dGVyKG9wdGlvbnMuZXJyb3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YWNrKCkge1xuICAgICAgaWYgKG9wdGlvbnMucGFzc2VkKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgdmFyIGVycm9yID0gb3B0aW9ucy5lcnJvcjtcbiAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuZXJyb3JGb3JTdGFjaykge1xuICAgICAgICAgIGVycm9yID0gb3B0aW9ucy5lcnJvckZvclN0YWNrO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc3RhY2spIHtcbiAgICAgICAgICBlcnJvciA9IG9wdGlvbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGVycm9yID0gZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIE9taXQgdGhlIG1lc3NhZ2UgZnJvbSB0aGUgc3RhY2sgdHJhY2UgYmVjYXVzZSBpdCB3aWxsIGJlXG4gICAgICAvLyBpbmNsdWRlZCBlbHNld2hlcmUuXG4gICAgICByZXR1cm4gc3RhY2tGb3JtYXR0ZXIoZXJyb3IsIHsgb21pdE1lc3NhZ2U6IHRydWUgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1aWxkRXhwZWN0YXRpb25SZXN1bHQ7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkV4cGVjdG9yID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gRXhwZWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMubWF0Y2hlcnNVdGlsID0gb3B0aW9ucy5tYXRjaGVyc1V0aWwgfHwge1xuICAgICAgYnVpbGRGYWlsdXJlTWVzc2FnZTogZnVuY3Rpb24oKSB7fVxuICAgIH07XG4gICAgdGhpcy5hY3R1YWwgPSBvcHRpb25zLmFjdHVhbDtcbiAgICB0aGlzLmFkZEV4cGVjdGF0aW9uUmVzdWx0ID0gb3B0aW9ucy5hZGRFeHBlY3RhdGlvblJlc3VsdCB8fCBmdW5jdGlvbigpIHt9O1xuICAgIHRoaXMuZmlsdGVycyA9IG5ldyBqJC5FeHBlY3RhdGlvbkZpbHRlckNoYWluKCk7XG4gIH1cblxuICBFeHBlY3Rvci5wcm90b3R5cGUuaW5zdGFudGlhdGVNYXRjaGVyID0gZnVuY3Rpb24oXG4gICAgbWF0Y2hlck5hbWUsXG4gICAgbWF0Y2hlckZhY3RvcnksXG4gICAgYXJnc1xuICApIHtcbiAgICB0aGlzLm1hdGNoZXJOYW1lID0gbWF0Y2hlck5hbWU7XG4gICAgdGhpcy5hcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMCk7XG4gICAgdGhpcy5leHBlY3RlZCA9IHRoaXMuYXJncy5zbGljZSgwKTtcblxuICAgIHRoaXMuYXJncy51bnNoaWZ0KHRoaXMuYWN0dWFsKTtcblxuICAgIHZhciBtYXRjaGVyID0gbWF0Y2hlckZhY3RvcnkodGhpcy5tYXRjaGVyc1V0aWwpO1xuXG4gICAgdmFyIGNvbXBhcmlzb25GdW5jID0gdGhpcy5maWx0ZXJzLnNlbGVjdENvbXBhcmlzb25GdW5jKG1hdGNoZXIpO1xuICAgIHJldHVybiBjb21wYXJpc29uRnVuYyB8fCBtYXRjaGVyLmNvbXBhcmU7XG4gIH07XG5cbiAgRXhwZWN0b3IucHJvdG90eXBlLmJ1aWxkTWVzc2FnZSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmIChyZXN1bHQucGFzcykge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIHZhciBtc2cgPSB0aGlzLmZpbHRlcnMuYnVpbGRGYWlsdXJlTWVzc2FnZShcbiAgICAgIHJlc3VsdCxcbiAgICAgIHRoaXMubWF0Y2hlck5hbWUsXG4gICAgICB0aGlzLmFyZ3MsXG4gICAgICB0aGlzLm1hdGNoZXJzVXRpbCxcbiAgICAgIGRlZmF1bHRNZXNzYWdlXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXJzLm1vZGlmeUZhaWx1cmVNZXNzYWdlKG1zZyB8fCBkZWZhdWx0TWVzc2FnZSgpKTtcblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRNZXNzYWdlKCkge1xuICAgICAgaWYgKCFyZXN1bHQubWVzc2FnZSkge1xuICAgICAgICB2YXIgYXJncyA9IHNlbGYuYXJncy5zbGljZSgpO1xuICAgICAgICBhcmdzLnVuc2hpZnQoZmFsc2UpO1xuICAgICAgICBhcmdzLnVuc2hpZnQoc2VsZi5tYXRjaGVyTmFtZSk7XG4gICAgICAgIHJldHVybiBzZWxmLm1hdGNoZXJzVXRpbC5idWlsZEZhaWx1cmVNZXNzYWdlLmFwcGx5KFxuICAgICAgICAgIHNlbGYubWF0Y2hlcnNVdGlsLFxuICAgICAgICAgIGFyZ3NcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoaiQuaXNGdW5jdGlvbl8ocmVzdWx0Lm1lc3NhZ2UpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQubWVzc2FnZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5tZXNzYWdlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBFeHBlY3Rvci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uKG1hdGNoZXJOYW1lLCBtYXRjaGVyRmFjdG9yeSwgYXJncykge1xuICAgIHZhciBtYXRjaGVyQ29tcGFyZSA9IHRoaXMuaW5zdGFudGlhdGVNYXRjaGVyKFxuICAgICAgbWF0Y2hlck5hbWUsXG4gICAgICBtYXRjaGVyRmFjdG9yeSxcbiAgICAgIGFyZ3NcbiAgICApO1xuICAgIHJldHVybiBtYXRjaGVyQ29tcGFyZS5hcHBseShudWxsLCB0aGlzLmFyZ3MpO1xuICB9O1xuXG4gIEV4cGVjdG9yLnByb3RvdHlwZS5hZGRGaWx0ZXIgPSBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICByZXN1bHQuZmlsdGVycyA9IHRoaXMuZmlsdGVycy5hZGRGaWx0ZXIoZmlsdGVyKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIEV4cGVjdG9yLnByb3RvdHlwZS5wcm9jZXNzUmVzdWx0ID0gZnVuY3Rpb24ocmVzdWx0LCBlcnJvckZvclN0YWNrKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSB0aGlzLmJ1aWxkTWVzc2FnZShyZXN1bHQpO1xuXG4gICAgaWYgKHRoaXMuZXhwZWN0ZWQubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLmV4cGVjdGVkID0gdGhpcy5leHBlY3RlZFswXTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZEV4cGVjdGF0aW9uUmVzdWx0KHJlc3VsdC5wYXNzLCB7XG4gICAgICBtYXRjaGVyTmFtZTogdGhpcy5tYXRjaGVyTmFtZSxcbiAgICAgIHBhc3NlZDogcmVzdWx0LnBhc3MsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgZXJyb3I6IGVycm9yRm9yU3RhY2sgPyB1bmRlZmluZWQgOiByZXN1bHQuZXJyb3IsXG4gICAgICBlcnJvckZvclN0YWNrOiBlcnJvckZvclN0YWNrIHx8IHVuZGVmaW5lZCxcbiAgICAgIGFjdHVhbDogdGhpcy5hY3R1YWwsXG4gICAgICBleHBlY3RlZDogdGhpcy5leHBlY3RlZCAvLyBUT0RPOiB0aGlzIG1heSBuZWVkIHRvIGJlIGFycmF5aWZpZWQvc2xpY2VkXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEV4cGVjdG9yO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5mb3JtYXRFcnJvck1zZyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBnZW5lcmF0ZUVycm9yTXNnKGRvbWFpbiwgdXNhZ2UpIHtcbiAgICB2YXIgdXNhZ2VEZWZpbml0aW9uID0gdXNhZ2UgPyAnXFxuVXNhZ2U6ICcgKyB1c2FnZSA6ICcnO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGVycm9yTXNnKG1zZykge1xuICAgICAgcmV0dXJuIGRvbWFpbiArICcgOiAnICsgbXNnICsgdXNhZ2VEZWZpbml0aW9uO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZ2VuZXJhdGVFcnJvck1zZztcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuR2xvYmFsRXJyb3JzID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gR2xvYmFsRXJyb3JzKGdsb2JhbCkge1xuICAgIHZhciBoYW5kbGVycyA9IFtdO1xuICAgIGdsb2JhbCA9IGdsb2JhbCB8fCBqJC5nZXRHbG9iYWwoKTtcblxuICAgIHZhciBvbmVycm9yID0gZnVuY3Rpb24gb25lcnJvcigpIHtcbiAgICAgIHZhciBoYW5kbGVyID0gaGFuZGxlcnNbaGFuZGxlcnMubGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkobnVsbCwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBhcmd1bWVudHNbMF07XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMub3JpZ2luYWxIYW5kbGVycyA9IHt9O1xuICAgIHRoaXMuamFzbWluZUhhbmRsZXJzID0ge307XG4gICAgdGhpcy5pbnN0YWxsT25lXyA9IGZ1bmN0aW9uIGluc3RhbGxPbmVfKGVycm9yVHlwZSwgamFzbWluZU1lc3NhZ2UpIHtcbiAgICAgIGZ1bmN0aW9uIHRhZ2dlZE9uRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdmFyIHN1YnN0aXR1dGVNc2c7XG5cbiAgICAgICAgaWYgKGokLmlzRXJyb3JfKGVycm9yKSkge1xuICAgICAgICAgIGVycm9yLmphc21pbmVNZXNzYWdlID0gamFzbWluZU1lc3NhZ2UgKyAnOiAnICsgZXJyb3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBzdWJzdGl0dXRlTXNnID0gamFzbWluZU1lc3NhZ2UgKyAnOiAnICsgZXJyb3I7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YnN0aXR1dGVNc2cgPSBqYXNtaW5lTWVzc2FnZSArICcgd2l0aCBubyBlcnJvciBvciBtZXNzYWdlJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZXJyb3JUeXBlID09PSAndW5oYW5kbGVkUmVqZWN0aW9uJykge1xuICAgICAgICAgICAgc3Vic3RpdHV0ZU1zZyArPVxuICAgICAgICAgICAgICAnXFxuJyArXG4gICAgICAgICAgICAgICcoVGlwOiB0byBnZXQgYSB1c2VmdWwgc3RhY2sgdHJhY2UsIHVzZSAnICtcbiAgICAgICAgICAgICAgJ1Byb21pc2UucmVqZWN0KG5ldyBFcnJvciguLi4pKSBpbnN0ZWFkIG9mIFByb21pc2UucmVqZWN0KCcgK1xuICAgICAgICAgICAgICAoZXJyb3IgPyAnLi4uJyA6ICcnKSArXG4gICAgICAgICAgICAgICcpLiknO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKHN1YnN0aXR1dGVNc2cpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhbmRsZXIgPSBoYW5kbGVyc1toYW5kbGVycy5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIGhhbmRsZXIoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMub3JpZ2luYWxIYW5kbGVyc1tlcnJvclR5cGVdID0gZ2xvYmFsLnByb2Nlc3MubGlzdGVuZXJzKGVycm9yVHlwZSk7XG4gICAgICB0aGlzLmphc21pbmVIYW5kbGVyc1tlcnJvclR5cGVdID0gdGFnZ2VkT25FcnJvcjtcblxuICAgICAgZ2xvYmFsLnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzKGVycm9yVHlwZSk7XG4gICAgICBnbG9iYWwucHJvY2Vzcy5vbihlcnJvclR5cGUsIHRhZ2dlZE9uRXJyb3IpO1xuXG4gICAgICB0aGlzLnVuaW5zdGFsbCA9IGZ1bmN0aW9uIHVuaW5zdGFsbCgpIHtcbiAgICAgICAgdmFyIGVycm9yVHlwZXMgPSBPYmplY3Qua2V5cyh0aGlzLm9yaWdpbmFsSGFuZGxlcnMpO1xuICAgICAgICBmb3IgKHZhciBpVHlwZSA9IDA7IGlUeXBlIDwgZXJyb3JUeXBlcy5sZW5ndGg7IGlUeXBlKyspIHtcbiAgICAgICAgICB2YXIgZXJyb3JUeXBlID0gZXJyb3JUeXBlc1tpVHlwZV07XG4gICAgICAgICAgZ2xvYmFsLnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIoXG4gICAgICAgICAgICBlcnJvclR5cGUsXG4gICAgICAgICAgICB0aGlzLmphc21pbmVIYW5kbGVyc1tlcnJvclR5cGVdXG4gICAgICAgICAgKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3JpZ2luYWxIYW5kbGVyc1tlcnJvclR5cGVdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBnbG9iYWwucHJvY2Vzcy5vbihlcnJvclR5cGUsIHRoaXMub3JpZ2luYWxIYW5kbGVyc1tlcnJvclR5cGVdW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVsZXRlIHRoaXMub3JpZ2luYWxIYW5kbGVyc1tlcnJvclR5cGVdO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmphc21pbmVIYW5kbGVyc1tlcnJvclR5cGVdO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB0aGlzLmluc3RhbGwgPSBmdW5jdGlvbiBpbnN0YWxsKCkge1xuICAgICAgaWYgKFxuICAgICAgICBnbG9iYWwucHJvY2VzcyAmJlxuICAgICAgICBnbG9iYWwucHJvY2Vzcy5saXN0ZW5lcnMgJiZcbiAgICAgICAgaiQuaXNGdW5jdGlvbl8oZ2xvYmFsLnByb2Nlc3Mub24pXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5pbnN0YWxsT25lXygndW5jYXVnaHRFeGNlcHRpb24nLCAnVW5jYXVnaHQgZXhjZXB0aW9uJyk7XG4gICAgICAgIHRoaXMuaW5zdGFsbE9uZV8oJ3VuaGFuZGxlZFJlamVjdGlvbicsICdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvcmlnaW5hbEhhbmRsZXIgPSBnbG9iYWwub25lcnJvcjtcbiAgICAgICAgZ2xvYmFsLm9uZXJyb3IgPSBvbmVycm9yO1xuXG4gICAgICAgIHZhciBicm93c2VyUmVqZWN0aW9uSGFuZGxlciA9IGZ1bmN0aW9uIGJyb3dzZXJSZWplY3Rpb25IYW5kbGVyKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKGokLmlzRXJyb3JfKGV2ZW50LnJlYXNvbikpIHtcbiAgICAgICAgICAgIGV2ZW50LnJlYXNvbi5qYXNtaW5lTWVzc2FnZSA9XG4gICAgICAgICAgICAgICdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb246ICcgKyBldmVudC5yZWFzb247XG4gICAgICAgICAgICBnbG9iYWwub25lcnJvcihldmVudC5yZWFzb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwub25lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uOiAnICsgZXZlbnQucmVhc29uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAndW5oYW5kbGVkcmVqZWN0aW9uJyxcbiAgICAgICAgICAgIGJyb3dzZXJSZWplY3Rpb25IYW5kbGVyXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudW5pbnN0YWxsID0gZnVuY3Rpb24gdW5pbnN0YWxsKCkge1xuICAgICAgICAgIGdsb2JhbC5vbmVycm9yID0gb3JpZ2luYWxIYW5kbGVyO1xuICAgICAgICAgIGlmIChnbG9iYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgICd1bmhhbmRsZWRyZWplY3Rpb24nLFxuICAgICAgICAgICAgICBicm93c2VyUmVqZWN0aW9uSGFuZGxlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMucHVzaExpc3RlbmVyID0gZnVuY3Rpb24gcHVzaExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICBoYW5kbGVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9O1xuXG4gICAgdGhpcy5wb3BMaXN0ZW5lciA9IGZ1bmN0aW9uIHBvcExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICBpZiAoIWxpc3RlbmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncG9wTGlzdGVuZXIgZXhwZWN0cyBhIGxpc3RlbmVyJyk7XG4gICAgICB9XG5cbiAgICAgIGhhbmRsZXJzLnBvcCgpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gR2xvYmFsRXJyb3JzO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlUGVuZGluZyA9IGZ1bmN0aW9uKGokKSB7XG4gIC8qKlxuICAgKiBFeHBlY3QgYSBwcm9taXNlIHRvIGJlIHBlbmRpbmcsIGkuZS4gdGhlIHByb21pc2UgaXMgbmVpdGhlciByZXNvbHZlZCBub3IgcmVqZWN0ZWQuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAYXN5bmNcbiAgICogQG5hbWUgYXN5bmMtbWF0Y2hlcnMjdG9CZVBlbmRpbmdcbiAgICogQHNpbmNlIDMuNlxuICAgKiBAZXhhbXBsZVxuICAgKiBhd2FpdCBleHBlY3RBc3luYyhhUHJvbWlzZSkudG9CZVBlbmRpbmcoKTtcbiAgICovXG4gIHJldHVybiBmdW5jdGlvbiB0b0JlUGVuZGluZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsKSB7XG4gICAgICAgIGlmICghaiQuaXNQcm9taXNlTGlrZShhY3R1YWwpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0b0JlUGVuZGluZyB0byBiZSBjYWxsZWQgb24gYSBwcm9taXNlLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3YW50ID0ge307XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW2FjdHVhbCwgUHJvbWlzZS5yZXNvbHZlKHdhbnQpXSkudGhlbihcbiAgICAgICAgICBmdW5jdGlvbihnb3QpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHBhc3M6IHdhbnQgPT09IGdvdCB9O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4geyBwYXNzOiBmYWxzZSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlUmVqZWN0ZWQgPSBmdW5jdGlvbihqJCkge1xuICAvKipcbiAgICogRXhwZWN0IGEgcHJvbWlzZSB0byBiZSByZWplY3RlZC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBhc3luY1xuICAgKiBAbmFtZSBhc3luYy1tYXRjaGVycyN0b0JlUmVqZWN0ZWRcbiAgICogQHNpbmNlIDMuMS4wXG4gICAqIEBleGFtcGxlXG4gICAqIGF3YWl0IGV4cGVjdEFzeW5jKGFQcm9taXNlKS50b0JlUmVqZWN0ZWQoKTtcbiAgICogQGV4YW1wbGVcbiAgICogcmV0dXJuIGV4cGVjdEFzeW5jKGFQcm9taXNlKS50b0JlUmVqZWN0ZWQoKTtcbiAgICovXG4gIHJldHVybiBmdW5jdGlvbiB0b0JlUmVqZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCkge1xuICAgICAgICBpZiAoIWokLmlzUHJvbWlzZUxpa2UoYWN0dWFsKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG9CZVJlamVjdGVkIHRvIGJlIGNhbGxlZCBvbiBhIHByb21pc2UuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjdHVhbC50aGVuKFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcGFzczogZmFsc2UgfTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcGFzczogdHJ1ZSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlUmVqZWN0ZWRXaXRoID0gZnVuY3Rpb24oaiQpIHtcbiAgLyoqXG4gICAqIEV4cGVjdCBhIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQgd2l0aCBhIHZhbHVlIGVxdWFsIHRvIHRoZSBleHBlY3RlZCwgdXNpbmcgZGVlcCBlcXVhbGl0eSBjb21wYXJpc29uLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQGFzeW5jXG4gICAqIEBuYW1lIGFzeW5jLW1hdGNoZXJzI3RvQmVSZWplY3RlZFdpdGhcbiAgICogQHNpbmNlIDMuMy4wXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHBlY3RlZCAtIFZhbHVlIHRoYXQgdGhlIHByb21pc2UgaXMgZXhwZWN0ZWQgdG8gYmUgcmVqZWN0ZWQgd2l0aFxuICAgKiBAZXhhbXBsZVxuICAgKiBhd2FpdCBleHBlY3RBc3luYyhhUHJvbWlzZSkudG9CZVJlamVjdGVkV2l0aCh7cHJvcDogJ3ZhbHVlJ30pO1xuICAgKiBAZXhhbXBsZVxuICAgKiByZXR1cm4gZXhwZWN0QXN5bmMoYVByb21pc2UpLnRvQmVSZWplY3RlZFdpdGgoe3Byb3A6ICd2YWx1ZSd9KTtcbiAgICovXG4gIHJldHVybiBmdW5jdGlvbiB0b0JlUmVqZWN0ZWRXaXRoKG1hdGNoZXJzVXRpbCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWxQcm9taXNlLCBleHBlY3RlZFZhbHVlKSB7XG4gICAgICAgIGlmICghaiQuaXNQcm9taXNlTGlrZShhY3R1YWxQcm9taXNlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdFeHBlY3RlZCB0b0JlUmVqZWN0ZWRXaXRoIHRvIGJlIGNhbGxlZCBvbiBhIHByb21pc2UuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwcmVmaXgocGFzc2VkKSB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICdFeHBlY3RlZCBhIHByb21pc2UgJyArXG4gICAgICAgICAgICAocGFzc2VkID8gJ25vdCAnIDogJycpICtcbiAgICAgICAgICAgICd0byBiZSByZWplY3RlZCB3aXRoICcgK1xuICAgICAgICAgICAgbWF0Y2hlcnNVdGlsLnBwKGV4cGVjdGVkVmFsdWUpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhY3R1YWxQcm9taXNlLnRoZW4oXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBwYXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgbWVzc2FnZTogcHJlZml4KGZhbHNlKSArICcgYnV0IGl0IHdhcyByZXNvbHZlZC4nXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oYWN0dWFsVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaGVyc1V0aWwuZXF1YWxzKGFjdHVhbFZhbHVlLCBleHBlY3RlZFZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBhc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogcHJlZml4KHRydWUpICsgJy4nXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBhc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAgICAgICBwcmVmaXgoZmFsc2UpICtcbiAgICAgICAgICAgICAgICAgICcgYnV0IGl0IHdhcyByZWplY3RlZCB3aXRoICcgK1xuICAgICAgICAgICAgICAgICAgbWF0Y2hlcnNVdGlsLnBwKGFjdHVhbFZhbHVlKSArXG4gICAgICAgICAgICAgICAgICAnLidcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZVJlamVjdGVkV2l0aEVycm9yID0gZnVuY3Rpb24oaiQpIHtcbiAgLyoqXG4gICAqIEV4cGVjdCBhIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQgd2l0aCBhIHZhbHVlIG1hdGNoZWQgdG8gdGhlIGV4cGVjdGVkXG4gICAqIEBmdW5jdGlvblxuICAgKiBAYXN5bmNcbiAgICogQG5hbWUgYXN5bmMtbWF0Y2hlcnMjdG9CZVJlamVjdGVkV2l0aEVycm9yXG4gICAqIEBzaW5jZSAzLjUuMFxuICAgKiBAcGFyYW0ge0Vycm9yfSBbZXhwZWN0ZWRdIC0gYEVycm9yYCBjb25zdHJ1Y3RvciB0aGUgb2JqZWN0IHRoYXQgd2FzIHRocm93biBuZWVkcyB0byBiZSBhbiBpbnN0YW5jZSBvZi4gSWYgbm90IHByb3ZpZGVkLCBgRXJyb3JgIHdpbGwgYmUgdXNlZC5cbiAgICogQHBhcmFtIHtSZWdFeHB8U3RyaW5nfSBbbWVzc2FnZV0gLSBUaGUgbWVzc2FnZSB0aGF0IHNob3VsZCBiZSBzZXQgb24gdGhlIHRocm93biBgRXJyb3JgXG4gICAqIEBleGFtcGxlXG4gICAqIGF3YWl0IGV4cGVjdEFzeW5jKGFQcm9taXNlKS50b0JlUmVqZWN0ZWRXaXRoRXJyb3IoTXlDdXN0b21FcnJvciwgJ0Vycm9yIG1lc3NhZ2UnKTtcbiAgICogYXdhaXQgZXhwZWN0QXN5bmMoYVByb21pc2UpLnRvQmVSZWplY3RlZFdpdGhFcnJvcihNeUN1c3RvbUVycm9yLCAvRXJyb3IgbWVzc2FnZS8pO1xuICAgKiBhd2FpdCBleHBlY3RBc3luYyhhUHJvbWlzZSkudG9CZVJlamVjdGVkV2l0aEVycm9yKE15Q3VzdG9tRXJyb3IpO1xuICAgKiBhd2FpdCBleHBlY3RBc3luYyhhUHJvbWlzZSkudG9CZVJlamVjdGVkV2l0aEVycm9yKCdFcnJvciBtZXNzYWdlJyk7XG4gICAqIHJldHVybiBleHBlY3RBc3luYyhhUHJvbWlzZSkudG9CZVJlamVjdGVkV2l0aEVycm9yKC9FcnJvciBtZXNzYWdlLyk7XG4gICAqL1xuICByZXR1cm4gZnVuY3Rpb24gdG9CZVJlamVjdGVkV2l0aEVycm9yKG1hdGNoZXJzVXRpbCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWxQcm9taXNlLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGlmICghaiQuaXNQcm9taXNlTGlrZShhY3R1YWxQcm9taXNlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdFeHBlY3RlZCB0b0JlUmVqZWN0ZWRXaXRoRXJyb3IgdG8gYmUgY2FsbGVkIG9uIGEgcHJvbWlzZS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBleHBlY3RlZCA9IGdldEV4cGVjdGVkRnJvbUFyZ3MoYXJnMSwgYXJnMiwgbWF0Y2hlcnNVdGlsKTtcblxuICAgICAgICByZXR1cm4gYWN0dWFsUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcGFzczogZmFsc2UsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdFeHBlY3RlZCBhIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQgYnV0IGl0IHdhcyByZXNvbHZlZC4nXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oYWN0dWFsVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaEVycm9yKGFjdHVhbFZhbHVlLCBleHBlY3RlZCwgbWF0Y2hlcnNVdGlsKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYXRjaEVycm9yKGFjdHVhbCwgZXhwZWN0ZWQsIG1hdGNoZXJzVXRpbCkge1xuICAgIGlmICghaiQuaXNFcnJvcl8oYWN0dWFsKSkge1xuICAgICAgcmV0dXJuIGZhaWwoZXhwZWN0ZWQsICdyZWplY3RlZCB3aXRoICcgKyBtYXRjaGVyc1V0aWwucHAoYWN0dWFsKSk7XG4gICAgfVxuXG4gICAgaWYgKCEoYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQuZXJyb3IpKSB7XG4gICAgICByZXR1cm4gZmFpbChcbiAgICAgICAgZXhwZWN0ZWQsXG4gICAgICAgICdyZWplY3RlZCB3aXRoIHR5cGUgJyArIGokLmZuTmFtZUZvcihhY3R1YWwuY29uc3RydWN0b3IpXG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBhY3R1YWxNZXNzYWdlID0gYWN0dWFsLm1lc3NhZ2U7XG5cbiAgICBpZiAoXG4gICAgICBhY3R1YWxNZXNzYWdlID09PSBleHBlY3RlZC5tZXNzYWdlIHx8XG4gICAgICB0eXBlb2YgZXhwZWN0ZWQubWVzc2FnZSA9PT0gJ3VuZGVmaW5lZCdcbiAgICApIHtcbiAgICAgIHJldHVybiBwYXNzKGV4cGVjdGVkKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBleHBlY3RlZC5tZXNzYWdlIGluc3RhbmNlb2YgUmVnRXhwICYmXG4gICAgICBleHBlY3RlZC5tZXNzYWdlLnRlc3QoYWN0dWFsTWVzc2FnZSlcbiAgICApIHtcbiAgICAgIHJldHVybiBwYXNzKGV4cGVjdGVkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFpbChleHBlY3RlZCwgJ3JlamVjdGVkIHdpdGggJyArIG1hdGNoZXJzVXRpbC5wcChhY3R1YWwpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhc3MoZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGFzczogdHJ1ZSxcbiAgICAgIG1lc3NhZ2U6XG4gICAgICAgICdFeHBlY3RlZCBhIHByb21pc2Ugbm90IHRvIGJlIHJlamVjdGVkIHdpdGggJyArXG4gICAgICAgIGV4cGVjdGVkLnByaW50VmFsdWUgK1xuICAgICAgICAnLCBidXQgaXQgd2FzLidcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZmFpbChleHBlY3RlZCwgbWVzc2FnZSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXNzOiBmYWxzZSxcbiAgICAgIG1lc3NhZ2U6XG4gICAgICAgICdFeHBlY3RlZCBhIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQgd2l0aCAnICtcbiAgICAgICAgZXhwZWN0ZWQucHJpbnRWYWx1ZSArXG4gICAgICAgICcgYnV0IGl0IHdhcyAnICtcbiAgICAgICAgbWVzc2FnZSArXG4gICAgICAgICcuJ1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFeHBlY3RlZEZyb21BcmdzKGFyZzEsIGFyZzIsIG1hdGNoZXJzVXRpbCkge1xuICAgIHZhciBlcnJvciwgbWVzc2FnZTtcblxuICAgIGlmIChpc0Vycm9yQ29uc3RydWN0b3IoYXJnMSkpIHtcbiAgICAgIGVycm9yID0gYXJnMTtcbiAgICAgIG1lc3NhZ2UgPSBhcmcyO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvciA9IEVycm9yO1xuICAgICAgbWVzc2FnZSA9IGFyZzE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBwcmludFZhbHVlOlxuICAgICAgICBqJC5mbk5hbWVGb3IoZXJyb3IpICtcbiAgICAgICAgKHR5cGVvZiBtZXNzYWdlID09PSAndW5kZWZpbmVkJyA/ICcnIDogJzogJyArIG1hdGNoZXJzVXRpbC5wcChtZXNzYWdlKSlcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNFcnJvckNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKHZhbHVlID09PSBFcnJvciB8fCBqJC5pc0Vycm9yXyh2YWx1ZS5wcm90b3R5cGUpKVxuICAgICk7XG4gIH1cbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZVJlc29sdmVkID0gZnVuY3Rpb24oaiQpIHtcbiAgLyoqXG4gICAqIEV4cGVjdCBhIHByb21pc2UgdG8gYmUgcmVzb2x2ZWQuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAYXN5bmNcbiAgICogQG5hbWUgYXN5bmMtbWF0Y2hlcnMjdG9CZVJlc29sdmVkXG4gICAqIEBzaW5jZSAzLjEuMFxuICAgKiBAZXhhbXBsZVxuICAgKiBhd2FpdCBleHBlY3RBc3luYyhhUHJvbWlzZSkudG9CZVJlc29sdmVkKCk7XG4gICAqIEBleGFtcGxlXG4gICAqIHJldHVybiBleHBlY3RBc3luYyhhUHJvbWlzZSkudG9CZVJlc29sdmVkKCk7XG4gICAqL1xuICByZXR1cm4gZnVuY3Rpb24gdG9CZVJlc29sdmVkKG1hdGNoZXJzVXRpbCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwpIHtcbiAgICAgICAgaWYgKCFqJC5pc1Byb21pc2VMaWtlKGFjdHVhbCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvQmVSZXNvbHZlZCB0byBiZSBjYWxsZWQgb24gYSBwcm9taXNlLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFjdHVhbC50aGVuKFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcGFzczogdHJ1ZSB9O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcGFzczogZmFsc2UsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAgICAgJ0V4cGVjdGVkIGEgcHJvbWlzZSB0byBiZSByZXNvbHZlZCBidXQgaXQgd2FzICcgK1xuICAgICAgICAgICAgICAgICdyZWplY3RlZCB3aXRoICcgK1xuICAgICAgICAgICAgICAgIG1hdGNoZXJzVXRpbC5wcChlKSArXG4gICAgICAgICAgICAgICAgJy4nXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlUmVzb2x2ZWRUbyA9IGZ1bmN0aW9uKGokKSB7XG4gIC8qKlxuICAgKiBFeHBlY3QgYSBwcm9taXNlIHRvIGJlIHJlc29sdmVkIHRvIGEgdmFsdWUgZXF1YWwgdG8gdGhlIGV4cGVjdGVkLCB1c2luZyBkZWVwIGVxdWFsaXR5IGNvbXBhcmlzb24uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAYXN5bmNcbiAgICogQG5hbWUgYXN5bmMtbWF0Y2hlcnMjdG9CZVJlc29sdmVkVG9cbiAgICogQHNpbmNlIDMuMS4wXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHBlY3RlZCAtIFZhbHVlIHRoYXQgdGhlIHByb21pc2UgaXMgZXhwZWN0ZWQgdG8gcmVzb2x2ZSB0b1xuICAgKiBAZXhhbXBsZVxuICAgKiBhd2FpdCBleHBlY3RBc3luYyhhUHJvbWlzZSkudG9CZVJlc29sdmVkVG8oe3Byb3A6ICd2YWx1ZSd9KTtcbiAgICogQGV4YW1wbGVcbiAgICogcmV0dXJuIGV4cGVjdEFzeW5jKGFQcm9taXNlKS50b0JlUmVzb2x2ZWRUbyh7cHJvcDogJ3ZhbHVlJ30pO1xuICAgKi9cbiAgcmV0dXJuIGZ1bmN0aW9uIHRvQmVSZXNvbHZlZFRvKG1hdGNoZXJzVXRpbCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWxQcm9taXNlLCBleHBlY3RlZFZhbHVlKSB7XG4gICAgICAgIGlmICghaiQuaXNQcm9taXNlTGlrZShhY3R1YWxQcm9taXNlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG9CZVJlc29sdmVkVG8gdG8gYmUgY2FsbGVkIG9uIGEgcHJvbWlzZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHByZWZpeChwYXNzZWQpIHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgJ0V4cGVjdGVkIGEgcHJvbWlzZSAnICtcbiAgICAgICAgICAgIChwYXNzZWQgPyAnbm90ICcgOiAnJykgK1xuICAgICAgICAgICAgJ3RvIGJlIHJlc29sdmVkIHRvICcgK1xuICAgICAgICAgICAgbWF0Y2hlcnNVdGlsLnBwKGV4cGVjdGVkVmFsdWUpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhY3R1YWxQcm9taXNlLnRoZW4oXG4gICAgICAgICAgZnVuY3Rpb24oYWN0dWFsVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaGVyc1V0aWwuZXF1YWxzKGFjdHVhbFZhbHVlLCBleHBlY3RlZFZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBhc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogcHJlZml4KHRydWUpICsgJy4nXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBhc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAgICAgICBwcmVmaXgoZmFsc2UpICtcbiAgICAgICAgICAgICAgICAgICcgYnV0IGl0IHdhcyByZXNvbHZlZCB0byAnICtcbiAgICAgICAgICAgICAgICAgIG1hdGNoZXJzVXRpbC5wcChhY3R1YWxWYWx1ZSkgK1xuICAgICAgICAgICAgICAgICAgJy4nXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBwYXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgICBwcmVmaXgoZmFsc2UpICtcbiAgICAgICAgICAgICAgICAnIGJ1dCBpdCB3YXMgcmVqZWN0ZWQgd2l0aCAnICtcbiAgICAgICAgICAgICAgICBtYXRjaGVyc1V0aWwucHAoZSkgK1xuICAgICAgICAgICAgICAgICcuJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuRGlmZkJ1aWxkZXIgPSBmdW5jdGlvbihqJCkge1xuICByZXR1cm4gZnVuY3Rpb24gRGlmZkJ1aWxkZXIoY29uZmlnKSB7XG4gICAgdmFyIHByZXR0eVByaW50ZXIgPSAoY29uZmlnIHx8IHt9KS5wcmV0dHlQcmludGVyIHx8IGokLm1ha2VQcmV0dHlQcmludGVyKCksXG4gICAgICBtaXNtYXRjaGVzID0gbmV3IGokLk1pc21hdGNoVHJlZSgpLFxuICAgICAgcGF0aCA9IG5ldyBqJC5PYmplY3RQYXRoKCksXG4gICAgICBhY3R1YWxSb290ID0gdW5kZWZpbmVkLFxuICAgICAgZXhwZWN0ZWRSb290ID0gdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNldFJvb3RzOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gICAgICAgIGFjdHVhbFJvb3QgPSBhY3R1YWw7XG4gICAgICAgIGV4cGVjdGVkUm9vdCA9IGV4cGVjdGVkO1xuICAgICAgfSxcblxuICAgICAgcmVjb3JkTWlzbWF0Y2g6IGZ1bmN0aW9uKGZvcm1hdHRlcikge1xuICAgICAgICBtaXNtYXRjaGVzLmFkZChwYXRoLCBmb3JtYXR0ZXIpO1xuICAgICAgfSxcblxuICAgICAgZ2V0TWVzc2FnZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtZXNzYWdlcyA9IFtdO1xuXG4gICAgICAgIG1pc21hdGNoZXMudHJhdmVyc2UoZnVuY3Rpb24ocGF0aCwgaXNMZWFmLCBmb3JtYXR0ZXIpIHtcbiAgICAgICAgICB2YXIgYWN0dWFsQ3VzdG9tLFxuICAgICAgICAgICAgZXhwZWN0ZWRDdXN0b20sXG4gICAgICAgICAgICB1c2VDdXN0b20sXG4gICAgICAgICAgICBkZXJlZlJlc3VsdCA9IGRlcmVmZXJlbmNlUGF0aChcbiAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgYWN0dWFsUm9vdCxcbiAgICAgICAgICAgICAgZXhwZWN0ZWRSb290LFxuICAgICAgICAgICAgICBwcmV0dHlQcmludGVyXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYWN0dWFsID0gZGVyZWZSZXN1bHQuYWN0dWFsLFxuICAgICAgICAgICAgZXhwZWN0ZWQgPSBkZXJlZlJlc3VsdC5leHBlY3RlZDtcblxuICAgICAgICAgIGlmIChmb3JtYXR0ZXIpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goZm9ybWF0dGVyKGFjdHVhbCwgZXhwZWN0ZWQsIHBhdGgsIHByZXR0eVByaW50ZXIpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFjdHVhbEN1c3RvbSA9IHByZXR0eVByaW50ZXIuY3VzdG9tRm9ybWF0XyhhY3R1YWwpO1xuICAgICAgICAgIGV4cGVjdGVkQ3VzdG9tID0gcHJldHR5UHJpbnRlci5jdXN0b21Gb3JtYXRfKGV4cGVjdGVkKTtcbiAgICAgICAgICB1c2VDdXN0b20gPSAhKFxuICAgICAgICAgICAgaiQudXRpbC5pc1VuZGVmaW5lZChhY3R1YWxDdXN0b20pICYmXG4gICAgICAgICAgICBqJC51dGlsLmlzVW5kZWZpbmVkKGV4cGVjdGVkQ3VzdG9tKVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAodXNlQ3VzdG9tKSB7XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKFxuICAgICAgICAgICAgICB3cmFwUHJldHR5UHJpbnRlZChhY3R1YWxDdXN0b20sIGV4cGVjdGVkQ3VzdG9tLCBwYXRoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gZG9uJ3QgcmVjdXJzZSBmdXJ0aGVyXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzTGVhZikge1xuICAgICAgICAgICAgbWVzc2FnZXMucHVzaChcbiAgICAgICAgICAgICAgZGVmYXVsdEZvcm1hdHRlcihhY3R1YWwsIGV4cGVjdGVkLCBwYXRoLCBwcmV0dHlQcmludGVyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VzLmpvaW4oJ1xcbicpO1xuICAgICAgfSxcblxuICAgICAgd2l0aFBhdGg6IGZ1bmN0aW9uKHBhdGhDb21wb25lbnQsIGJsb2NrKSB7XG4gICAgICAgIHZhciBvbGRQYXRoID0gcGF0aDtcbiAgICAgICAgcGF0aCA9IHBhdGguYWRkKHBhdGhDb21wb25lbnQpO1xuICAgICAgICBibG9jaygpO1xuICAgICAgICBwYXRoID0gb2xkUGF0aDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZGVmYXVsdEZvcm1hdHRlcihhY3R1YWwsIGV4cGVjdGVkLCBwYXRoLCBwcmV0dHlQcmludGVyKSB7XG4gICAgICByZXR1cm4gd3JhcFByZXR0eVByaW50ZWQoXG4gICAgICAgIHByZXR0eVByaW50ZXIoYWN0dWFsKSxcbiAgICAgICAgcHJldHR5UHJpbnRlcihleHBlY3RlZCksXG4gICAgICAgIHBhdGhcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd3JhcFByZXR0eVByaW50ZWQoYWN0dWFsLCBleHBlY3RlZCwgcGF0aCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgJ0V4cGVjdGVkICcgK1xuICAgICAgICBwYXRoICtcbiAgICAgICAgKHBhdGguZGVwdGgoKSA/ICcgPSAnIDogJycpICtcbiAgICAgICAgYWN0dWFsICtcbiAgICAgICAgJyB0byBlcXVhbCAnICtcbiAgICAgICAgZXhwZWN0ZWQgK1xuICAgICAgICAnLidcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGRlcmVmZXJlbmNlUGF0aChvYmplY3RQYXRoLCBhY3R1YWwsIGV4cGVjdGVkLCBwcCkge1xuICAgIGZ1bmN0aW9uIGhhbmRsZUFzeW1tZXRyaWNFeHBlY3RlZCgpIHtcbiAgICAgIGlmIChcbiAgICAgICAgaiQuaXNBc3ltbWV0cmljRXF1YWxpdHlUZXN0ZXJfKGV4cGVjdGVkKSAmJlxuICAgICAgICBqJC5pc0Z1bmN0aW9uXyhleHBlY3RlZC52YWx1ZXNGb3JEaWZmXylcbiAgICAgICkge1xuICAgICAgICB2YXIgYXN5bW1ldHJpY1Jlc3VsdCA9IGV4cGVjdGVkLnZhbHVlc0ZvckRpZmZfKGFjdHVhbCwgcHApO1xuICAgICAgICBleHBlY3RlZCA9IGFzeW1tZXRyaWNSZXN1bHQuc2VsZjtcbiAgICAgICAgYWN0dWFsID0gYXN5bW1ldHJpY1Jlc3VsdC5vdGhlcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICBoYW5kbGVBc3ltbWV0cmljRXhwZWN0ZWQoKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBvYmplY3RQYXRoLmNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFjdHVhbCA9IGFjdHVhbFtvYmplY3RQYXRoLmNvbXBvbmVudHNbaV1dO1xuICAgICAgZXhwZWN0ZWQgPSBleHBlY3RlZFtvYmplY3RQYXRoLmNvbXBvbmVudHNbaV1dO1xuICAgICAgaGFuZGxlQXN5bW1ldHJpY0V4cGVjdGVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgYWN0dWFsOiBhY3R1YWwsIGV4cGVjdGVkOiBleHBlY3RlZCB9O1xuICB9XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLk1hdGNoZXJzVXRpbCA9IGZ1bmN0aW9uKGokKSB7XG4gIC8qKlxuICAgKiBAY2xhc3MgTWF0Y2hlcnNVdGlsXG4gICAqIEBjbGFzc2Rlc2MgVXRpbGl0aWVzIGZvciB1c2UgaW4gaW1wbGVtZW50aW5nIG1hdGNoZXJzLjxicj5cbiAgICogX05vdGU6XyBEbyBub3QgY29uc3RydWN0IHRoaXMgZGlyZWN0bHkuIEphc21pbmUgd2lsbCBjb25zdHJ1Y3Qgb25lIGFuZFxuICAgKiBwYXNzIGl0IHRvIG1hdGNoZXJzIGFuZCBhc3ltbWV0cmljIGVxdWFsaXR5IHRlc3RlcnMuXG4gICAqIEBoaWRlY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIE1hdGNoZXJzVXRpbChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5jdXN0b21UZXN0ZXJzXyA9IG9wdGlvbnMuY3VzdG9tVGVzdGVycyB8fCBbXTtcbiAgICAvKipcbiAgICAgKiBGb3JtYXRzIGEgdmFsdWUgZm9yIHVzZSBpbiBtYXRjaGVyIGZhaWx1cmUgbWVzc2FnZXMgYW5kIHNpbWlsYXIgY29udGV4dHMsXG4gICAgICogdGFraW5nIGludG8gYWNjb3VudCB0aGUgY3VycmVudCBzZXQgb2YgY3VzdG9tIHZhbHVlIGZvcm1hdHRlcnMuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG5hbWUgTWF0Y2hlcnNVdGlsI3BwXG4gICAgICogQHNpbmNlIDMuNi4wXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJldHR5LXByaW50XG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgcHJldHR5LXByaW50ZWQgdmFsdWVcbiAgICAgKi9cbiAgICB0aGlzLnBwID0gb3B0aW9ucy5wcCB8fCBmdW5jdGlvbigpIHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciBgaGF5c3RhY2tgIGNvbnRhaW5zIGBuZWVkbGVgLCB1c2luZyB0aGUgc2FtZSBjb21wYXJpc29uXG4gICAqIGxvZ2ljIGFzIHtAbGluayBNYXRjaGVyc1V0aWwjZXF1YWxzfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIE1hdGNoZXJzVXRpbCNjb250YWluc1xuICAgKiBAc2luY2UgMi4wLjBcbiAgICogQHBhcmFtIHsqfSBoYXlzdGFjayBUaGUgY29sbGVjdGlvbiB0byBzZWFyY2hcbiAgICogQHBhcmFtIHsqfSBuZWVkbGUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3JcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYG5lZWRsZWAgd2FzIGZvdW5kIGluIGBoYXlzdGFja2BcbiAgICovXG4gIE1hdGNoZXJzVXRpbC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbihoYXlzdGFjaywgbmVlZGxlKSB7XG4gICAgaWYgKCFoYXlzdGFjaykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChqJC5pc1NldChoYXlzdGFjaykpIHtcbiAgICAgIC8vIFRyeSAuaGFzKCkgZmlyc3QuIEl0IHNob3VsZCBiZSBmYXN0ZXIgaW4gY2FzZXMgd2hlcmVcbiAgICAgIC8vIG5lZWRsZSA9PT0gc29tZXRoaW5nIGluIGhheXN0YWNrLiBGYWxsIGJhY2sgdG8gLmVxdWFscygpIGNvbXBhcmlzb25cbiAgICAgIC8vIGlmIHRoYXQgZmFpbHMuXG4gICAgICBpZiAoaGF5c3RhY2suaGFzKG5lZWRsZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGokLmlzSXRlcmFibGVfKGhheXN0YWNrKSAmJiAhaiQuaXNTdHJpbmdfKGhheXN0YWNrKSkge1xuICAgICAgLy8gQXJyYXlzLCBTZXRzLCBldGMuXG4gICAgICBmb3IgKGNvbnN0IGNhbmRpZGF0ZSBvZiBoYXlzdGFjaykge1xuICAgICAgICBpZiAodGhpcy5lcXVhbHMoY2FuZGlkYXRlLCBuZWVkbGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChoYXlzdGFjay5pbmRleE9mKSB7XG4gICAgICAvLyBNYWlubHkgc3RyaW5nc1xuICAgICAgcmV0dXJuIGhheXN0YWNrLmluZGV4T2YobmVlZGxlKSA+PSAwO1xuICAgIH1cblxuICAgIGlmIChqJC5pc051bWJlcl8oaGF5c3RhY2subGVuZ3RoKSkge1xuICAgICAgLy8gT2JqZWN0cyB0aGF0IGFyZSBzaGFwZWQgbGlrZSBhcnJheXMgYnV0IGFyZW4ndCBpdGVyYWJsZVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYXlzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5lcXVhbHMoaGF5c3RhY2tbaV0sIG5lZWRsZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBNYXRjaGVyc1V0aWwucHJvdG90eXBlLmJ1aWxkRmFpbHVyZU1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApLFxuICAgICAgbWF0Y2hlck5hbWUgPSBhcmdzWzBdLFxuICAgICAgaXNOb3QgPSBhcmdzWzFdLFxuICAgICAgYWN0dWFsID0gYXJnc1syXSxcbiAgICAgIGV4cGVjdGVkID0gYXJncy5zbGljZSgzKSxcbiAgICAgIGVuZ2xpc2h5UHJlZGljYXRlID0gbWF0Y2hlck5hbWUucmVwbGFjZSgvW0EtWl0vZywgZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gJyAnICsgcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgbWVzc2FnZSA9XG4gICAgICAnRXhwZWN0ZWQgJyArXG4gICAgICBzZWxmLnBwKGFjdHVhbCkgK1xuICAgICAgKGlzTm90ID8gJyBub3QgJyA6ICcgJykgK1xuICAgICAgZW5nbGlzaHlQcmVkaWNhdGU7XG5cbiAgICBpZiAoZXhwZWN0ZWQubGVuZ3RoID4gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBtZXNzYWdlICs9ICcsJztcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlICs9ICcgJyArIHNlbGYucHAoZXhwZWN0ZWRbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtZXNzYWdlICsgJy4nO1xuICB9O1xuXG4gIE1hdGNoZXJzVXRpbC5wcm90b3R5cGUuYXN5bW1ldHJpY0RpZmZfID0gZnVuY3Rpb24oXG4gICAgYSxcbiAgICBiLFxuICAgIGFTdGFjayxcbiAgICBiU3RhY2ssXG4gICAgZGlmZkJ1aWxkZXJcbiAgKSB7XG4gICAgaWYgKGokLmlzRnVuY3Rpb25fKGIudmFsdWVzRm9yRGlmZl8pKSB7XG4gICAgICB2YXIgdmFsdWVzID0gYi52YWx1ZXNGb3JEaWZmXyhhLCB0aGlzLnBwKTtcbiAgICAgIHRoaXMuZXFfKHZhbHVlcy5vdGhlciwgdmFsdWVzLnNlbGYsIGFTdGFjaywgYlN0YWNrLCBkaWZmQnVpbGRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpZmZCdWlsZGVyLnJlY29yZE1pc21hdGNoKCk7XG4gICAgfVxuICB9O1xuXG4gIE1hdGNoZXJzVXRpbC5wcm90b3R5cGUuYXN5bW1ldHJpY01hdGNoXyA9IGZ1bmN0aW9uKFxuICAgIGEsXG4gICAgYixcbiAgICBhU3RhY2ssXG4gICAgYlN0YWNrLFxuICAgIGRpZmZCdWlsZGVyXG4gICkge1xuICAgIHZhciBhc3ltbWV0cmljQSA9IGokLmlzQXN5bW1ldHJpY0VxdWFsaXR5VGVzdGVyXyhhKSxcbiAgICAgIGFzeW1tZXRyaWNCID0gaiQuaXNBc3ltbWV0cmljRXF1YWxpdHlUZXN0ZXJfKGIpLFxuICAgICAgcmVzdWx0O1xuXG4gICAgaWYgKGFzeW1tZXRyaWNBID09PSBhc3ltbWV0cmljQikge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoYXN5bW1ldHJpY0EpIHtcbiAgICAgIHJlc3VsdCA9IGEuYXN5bW1ldHJpY01hdGNoKGIsIHRoaXMpO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkTWlzbWF0Y2goKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKGFzeW1tZXRyaWNCKSB7XG4gICAgICByZXN1bHQgPSBiLmFzeW1tZXRyaWNNYXRjaChhLCB0aGlzKTtcbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHRoaXMuYXN5bW1ldHJpY0RpZmZfKGEsIGIsIGFTdGFjaywgYlN0YWNrLCBkaWZmQnVpbGRlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHR3byB2YWx1ZXMgYXJlIGRlZXBseSBlcXVhbCB0byBlYWNoIG90aGVyLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgTWF0Y2hlcnNVdGlsI2VxdWFsc1xuICAgKiBAc2luY2UgMi4wLjBcbiAgICogQHBhcmFtIHsqfSBhIFRoZSBmaXJzdCB2YWx1ZSB0byBjb21wYXJlXG4gICAqIEBwYXJhbSB7Kn0gYiBUaGUgc2Vjb25kIHZhbHVlIHRvIGNvbXBhcmVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlcyBhcmUgZXF1YWxcbiAgICovXG4gIE1hdGNoZXJzVXRpbC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24oYSwgYiwgZGlmZkJ1aWxkZXIpIHtcbiAgICBkaWZmQnVpbGRlciA9IGRpZmZCdWlsZGVyIHx8IGokLk51bGxEaWZmQnVpbGRlcigpO1xuICAgIGRpZmZCdWlsZGVyLnNldFJvb3RzKGEsIGIpO1xuXG4gICAgcmV0dXJuIHRoaXMuZXFfKGEsIGIsIFtdLCBbXSwgZGlmZkJ1aWxkZXIpO1xuICB9O1xuXG4gIC8vIEVxdWFsaXR5IGZ1bmN0aW9uIGxvdmluZ2x5IGFkYXB0ZWQgZnJvbSBpc0VxdWFsIGluXG4gIC8vICAgW1VuZGVyc2NvcmVdKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnKVxuICBNYXRjaGVyc1V0aWwucHJvdG90eXBlLmVxXyA9IGZ1bmN0aW9uKGEsIGIsIGFTdGFjaywgYlN0YWNrLCBkaWZmQnVpbGRlcikge1xuICAgIHZhciByZXN1bHQgPSB0cnVlLFxuICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICBpO1xuXG4gICAgdmFyIGFzeW1tZXRyaWNSZXN1bHQgPSB0aGlzLmFzeW1tZXRyaWNNYXRjaF8oXG4gICAgICBhLFxuICAgICAgYixcbiAgICAgIGFTdGFjayxcbiAgICAgIGJTdGFjayxcbiAgICAgIGRpZmZCdWlsZGVyXG4gICAgKTtcbiAgICBpZiAoIWokLnV0aWwuaXNVbmRlZmluZWQoYXN5bW1ldHJpY1Jlc3VsdCkpIHtcbiAgICAgIHJldHVybiBhc3ltbWV0cmljUmVzdWx0O1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmN1c3RvbVRlc3RlcnNfLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY3VzdG9tVGVzdGVyUmVzdWx0ID0gdGhpcy5jdXN0b21UZXN0ZXJzX1tpXShhLCBiKTtcbiAgICAgIGlmICghaiQudXRpbC5pc1VuZGVmaW5lZChjdXN0b21UZXN0ZXJSZXN1bHQpKSB7XG4gICAgICAgIGlmICghY3VzdG9tVGVzdGVyUmVzdWx0KSB7XG4gICAgICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkTWlzbWF0Y2goKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VzdG9tVGVzdGVyUmVzdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhIGluc3RhbmNlb2YgRXJyb3IgJiYgYiBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICByZXN1bHQgPSBhLm1lc3NhZ2UgPT0gYi5tZXNzYWdlO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkTWlzbWF0Y2goKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICAgIGlmIChhID09PSBiKSB7XG4gICAgICByZXN1bHQgPSBhICE9PSAwIHx8IDEgLyBhID09IDEgLyBiO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkTWlzbWF0Y2goKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEEgc3RyaWN0IGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5IGJlY2F1c2UgYG51bGwgPT0gdW5kZWZpbmVkYC5cbiAgICBpZiAoYSA9PT0gbnVsbCB8fCBiID09PSBudWxsKSB7XG4gICAgICByZXN1bHQgPSBhID09PSBiO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkTWlzbWF0Y2goKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHZhciBjbGFzc05hbWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSk7XG4gICAgaWYgKGNsYXNzTmFtZSAhPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYikpIHtcbiAgICAgIGRpZmZCdWlsZGVyLnJlY29yZE1pc21hdGNoKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICAvLyBTdHJpbmdzLCBudW1iZXJzLCBkYXRlcywgYW5kIGJvb2xlYW5zIGFyZSBjb21wYXJlZCBieSB2YWx1ZS5cbiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gYG5ldyBTdHJpbmcoXCI1XCIpYC5cbiAgICAgICAgcmVzdWx0ID0gYSA9PSBTdHJpbmcoYik7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkTWlzbWF0Y2goKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS4gQW4gYGVnYWxgIGNvbXBhcmlzb24gaXMgcGVyZm9ybWVkIGZvclxuICAgICAgICAvLyBvdGhlciBudW1lcmljIHZhbHVlcy5cbiAgICAgICAgcmVzdWx0ID1cbiAgICAgICAgICBhICE9ICthID8gYiAhPSArYiA6IGEgPT09IDAgJiYgYiA9PT0gMCA/IDEgLyBhID09IDEgLyBiIDogYSA9PSArYjtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICBkaWZmQnVpbGRlci5yZWNvcmRNaXNtYXRjaCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICByZXN1bHQgPSArYSA9PSArYjtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICBkaWZmQnVpbGRlci5yZWNvcmRNaXNtYXRjaCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICBjYXNlICdbb2JqZWN0IEFycmF5QnVmZmVyXSc6XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYW4gaW5zdGFuY2Ugb2YgQXJyYXlCdWZmZXIgdGhlIFVpbnQ4QXJyYXkgY3RvclxuICAgICAgICAvLyB3aWxsIGJlIGRlZmluZWQgYXMgd2VsbFxuICAgICAgICByZXR1cm4gc2VsZi5lcV8oXG4gICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoYSksXG4gICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoYiksXG4gICAgICAgICAgYVN0YWNrLFxuICAgICAgICAgIGJTdGFjayxcbiAgICAgICAgICBkaWZmQnVpbGRlclxuICAgICAgICApO1xuICAgICAgLy8gUmVnRXhwcyBhcmUgY29tcGFyZWQgYnkgdGhlaXIgc291cmNlIHBhdHRlcm5zIGFuZCBmbGFncy5cbiAgICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgYS5zb3VyY2UgPT0gYi5zb3VyY2UgJiZcbiAgICAgICAgICBhLmdsb2JhbCA9PSBiLmdsb2JhbCAmJlxuICAgICAgICAgIGEubXVsdGlsaW5lID09IGIubXVsdGlsaW5lICYmXG4gICAgICAgICAgYS5pZ25vcmVDYXNlID09IGIuaWdub3JlQ2FzZVxuICAgICAgICApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGEgIT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHtcbiAgICAgIGRpZmZCdWlsZGVyLnJlY29yZE1pc21hdGNoKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGFJc0RvbU5vZGUgPSBqJC5pc0RvbU5vZGUoYSk7XG4gICAgdmFyIGJJc0RvbU5vZGUgPSBqJC5pc0RvbU5vZGUoYik7XG4gICAgaWYgKGFJc0RvbU5vZGUgJiYgYklzRG9tTm9kZSkge1xuICAgICAgLy8gQXQgZmlyc3QgdHJ5IHRvIHVzZSBET00zIG1ldGhvZCBpc0VxdWFsTm9kZVxuICAgICAgcmVzdWx0ID0gYS5pc0VxdWFsTm9kZShiKTtcbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIGRpZmZCdWlsZGVyLnJlY29yZE1pc21hdGNoKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoYUlzRG9tTm9kZSB8fCBiSXNEb21Ob2RlKSB7XG4gICAgICBkaWZmQnVpbGRlci5yZWNvcmRNaXNtYXRjaCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBhSXNQcm9taXNlID0gaiQuaXNQcm9taXNlKGEpO1xuICAgIHZhciBiSXNQcm9taXNlID0gaiQuaXNQcm9taXNlKGIpO1xuICAgIGlmIChhSXNQcm9taXNlICYmIGJJc1Byb21pc2UpIHtcbiAgICAgIHJldHVybiBhID09PSBiO1xuICAgIH1cblxuICAgIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcbiAgICAvLyBzdHJ1Y3R1cmVzIGlzIGFkYXB0ZWQgZnJvbSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYC5cbiAgICB2YXIgbGVuZ3RoID0gYVN0YWNrLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIC8vIExpbmVhciBzZWFyY2guIFBlcmZvcm1hbmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZlxuICAgICAgLy8gdW5pcXVlIG5lc3RlZCBzdHJ1Y3R1cmVzLlxuICAgICAgaWYgKGFTdGFja1tsZW5ndGhdID09IGEpIHtcbiAgICAgICAgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09IGI7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcbiAgICB2YXIgc2l6ZSA9IDA7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgLy8gQ29tcGFyZSBhcnJheSBsZW5ndGhzIHRvIGRldGVybWluZSBpZiBhIGRlZXAgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkuXG4gICAgaWYgKGNsYXNzTmFtZSA9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICB2YXIgYUxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgdmFyIGJMZW5ndGggPSBiLmxlbmd0aDtcblxuICAgICAgZGlmZkJ1aWxkZXIud2l0aFBhdGgoJ2xlbmd0aCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoYUxlbmd0aCAhPT0gYkxlbmd0aCkge1xuICAgICAgICAgIGRpZmZCdWlsZGVyLnJlY29yZE1pc21hdGNoKCk7XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYUxlbmd0aCB8fCBpIDwgYkxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRpZmZCdWlsZGVyLndpdGhQYXRoKGksIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChpID49IGJMZW5ndGgpIHtcbiAgICAgICAgICAgIGRpZmZCdWlsZGVyLnJlY29yZE1pc21hdGNoKFxuICAgICAgICAgICAgICBhY3R1YWxBcnJheUlzTG9uZ2VyRm9ybWF0dGVyLmJpbmQobnVsbCwgc2VsZi5wcClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID1cbiAgICAgICAgICAgICAgc2VsZi5lcV8oXG4gICAgICAgICAgICAgICAgaSA8IGFMZW5ndGggPyBhW2ldIDogdm9pZCAwLFxuICAgICAgICAgICAgICAgIGkgPCBiTGVuZ3RoID8gYltpXSA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBhU3RhY2ssXG4gICAgICAgICAgICAgICAgYlN0YWNrLFxuICAgICAgICAgICAgICAgIGRpZmZCdWlsZGVyXG4gICAgICAgICAgICAgICkgJiYgcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChqJC5pc01hcChhKSAmJiBqJC5pc01hcChiKSkge1xuICAgICAgaWYgKGEuc2l6ZSAhPSBiLnNpemUpIHtcbiAgICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkTWlzbWF0Y2goKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIga2V5c0EgPSBbXTtcbiAgICAgIHZhciBrZXlzQiA9IFtdO1xuICAgICAgYS5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlQSwga2V5QSkge1xuICAgICAgICBrZXlzQS5wdXNoKGtleUEpO1xuICAgICAgfSk7XG4gICAgICBiLmZvckVhY2goZnVuY3Rpb24odmFsdWVCLCBrZXlCKSB7XG4gICAgICAgIGtleXNCLnB1c2goa2V5Qik7XG4gICAgICB9KTtcblxuICAgICAgLy8gRm9yIGJvdGggc2V0cyBvZiBrZXlzLCBjaGVjayB0aGV5IG1hcCB0byBlcXVhbCB2YWx1ZXMgaW4gYm90aCBtYXBzLlxuICAgICAgLy8gS2VlcCB0cmFjayBvZiBjb3JyZXNwb25kaW5nIGtleXMgKGluIGluc2VydGlvbiBvcmRlcikgaW4gb3JkZXIgdG8gaGFuZGxlIGFzeW1tZXRyaWMgb2JqIGtleXMuXG4gICAgICB2YXIgbWFwS2V5cyA9IFtrZXlzQSwga2V5c0JdO1xuICAgICAgdmFyIGNtcEtleXMgPSBba2V5c0IsIGtleXNBXTtcbiAgICAgIHZhciBtYXBJdGVyLCBtYXBLZXksIG1hcFZhbHVlQSwgbWFwVmFsdWVCO1xuICAgICAgdmFyIGNtcEl0ZXIsIGNtcEtleTtcbiAgICAgIGZvciAoaSA9IDA7IHJlc3VsdCAmJiBpIDwgbWFwS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXBJdGVyID0gbWFwS2V5c1tpXTtcbiAgICAgICAgY21wSXRlciA9IGNtcEtleXNbaV07XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IHJlc3VsdCAmJiBqIDwgbWFwSXRlci5sZW5ndGg7IGorKykge1xuICAgICAgICAgIG1hcEtleSA9IG1hcEl0ZXJbal07XG4gICAgICAgICAgY21wS2V5ID0gY21wSXRlcltqXTtcbiAgICAgICAgICBtYXBWYWx1ZUEgPSBhLmdldChtYXBLZXkpO1xuXG4gICAgICAgICAgLy8gT25seSB1c2UgdGhlIGNtcEtleSB3aGVuIG9uZSBvZiB0aGUga2V5cyBpcyBhc3ltbWV0cmljIGFuZCB0aGUgY29ycmVzcG9uZGluZyBrZXkgbWF0Y2hlcyxcbiAgICAgICAgICAvLyBvdGhlcndpc2UgZXhwbGljaXRseSBsb29rIHVwIHRoZSBtYXBLZXkgaW4gdGhlIG90aGVyIE1hcCBzaW5jZSB3ZSB3YW50IGtleXMgd2l0aCB1bmlxdWVcbiAgICAgICAgICAvLyBvYmogaWRlbnRpdHkgKHRoYXQgYXJlIG90aGVyd2lzZSBlcXVhbCkgdG8gbm90IG1hdGNoLlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGokLmlzQXN5bW1ldHJpY0VxdWFsaXR5VGVzdGVyXyhtYXBLZXkpIHx8XG4gICAgICAgICAgICAoaiQuaXNBc3ltbWV0cmljRXF1YWxpdHlUZXN0ZXJfKGNtcEtleSkgJiZcbiAgICAgICAgICAgICAgdGhpcy5lcV8obWFwS2V5LCBjbXBLZXksIGFTdGFjaywgYlN0YWNrLCBqJC5OdWxsRGlmZkJ1aWxkZXIoKSkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBtYXBWYWx1ZUIgPSBiLmdldChjbXBLZXkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXBWYWx1ZUIgPSBiLmdldChtYXBLZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSB0aGlzLmVxXyhcbiAgICAgICAgICAgIG1hcFZhbHVlQSxcbiAgICAgICAgICAgIG1hcFZhbHVlQixcbiAgICAgICAgICAgIGFTdGFjayxcbiAgICAgICAgICAgIGJTdGFjayxcbiAgICAgICAgICAgIGokLk51bGxEaWZmQnVpbGRlcigpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICBkaWZmQnVpbGRlci5yZWNvcmRNaXNtYXRjaCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChqJC5pc1NldChhKSAmJiBqJC5pc1NldChiKSkge1xuICAgICAgaWYgKGEuc2l6ZSAhPSBiLnNpemUpIHtcbiAgICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkTWlzbWF0Y2goKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVzQSA9IFtdO1xuICAgICAgYS5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlQSkge1xuICAgICAgICB2YWx1ZXNBLnB1c2godmFsdWVBKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHZhbHVlc0IgPSBbXTtcbiAgICAgIGIuZm9yRWFjaChmdW5jdGlvbih2YWx1ZUIpIHtcbiAgICAgICAgdmFsdWVzQi5wdXNoKHZhbHVlQik7XG4gICAgICB9KTtcblxuICAgICAgLy8gRm9yIGJvdGggc2V0cywgY2hlY2sgdGhleSBhcmUgYWxsIGNvbnRhaW5lZCBpbiB0aGUgb3RoZXIgc2V0XG4gICAgICB2YXIgc2V0UGFpcnMgPSBbW3ZhbHVlc0EsIHZhbHVlc0JdLCBbdmFsdWVzQiwgdmFsdWVzQV1dO1xuICAgICAgdmFyIHN0YWNrUGFpcnMgPSBbW2FTdGFjaywgYlN0YWNrXSwgW2JTdGFjaywgYVN0YWNrXV07XG4gICAgICB2YXIgYmFzZVZhbHVlcywgYmFzZVZhbHVlLCBiYXNlU3RhY2s7XG4gICAgICB2YXIgb3RoZXJWYWx1ZXMsIG90aGVyVmFsdWUsIG90aGVyU3RhY2s7XG4gICAgICB2YXIgZm91bmQ7XG4gICAgICB2YXIgcHJldlN0YWNrU2l6ZTtcbiAgICAgIGZvciAoaSA9IDA7IHJlc3VsdCAmJiBpIDwgc2V0UGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYmFzZVZhbHVlcyA9IHNldFBhaXJzW2ldWzBdO1xuICAgICAgICBvdGhlclZhbHVlcyA9IHNldFBhaXJzW2ldWzFdO1xuICAgICAgICBiYXNlU3RhY2sgPSBzdGFja1BhaXJzW2ldWzBdO1xuICAgICAgICBvdGhlclN0YWNrID0gc3RhY2tQYWlyc1tpXVsxXTtcbiAgICAgICAgLy8gRm9yIGVhY2ggdmFsdWUgaW4gdGhlIGJhc2Ugc2V0Li4uXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyByZXN1bHQgJiYgayA8IGJhc2VWYWx1ZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICBiYXNlVmFsdWUgPSBiYXNlVmFsdWVzW2tdO1xuICAgICAgICAgIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgLy8gLi4uIHRlc3QgdGhhdCBpdCBpcyBwcmVzZW50IGluIHRoZSBvdGhlciBzZXRcbiAgICAgICAgICBmb3IgKHZhciBsID0gMDsgIWZvdW5kICYmIGwgPCBvdGhlclZhbHVlcy5sZW5ndGg7IGwrKykge1xuICAgICAgICAgICAgb3RoZXJWYWx1ZSA9IG90aGVyVmFsdWVzW2xdO1xuICAgICAgICAgICAgcHJldlN0YWNrU2l6ZSA9IGJhc2VTdGFjay5sZW5ndGg7XG4gICAgICAgICAgICAvLyBjb21wYXJlIGJ5IHZhbHVlIGVxdWFsaXR5XG4gICAgICAgICAgICBmb3VuZCA9IHRoaXMuZXFfKFxuICAgICAgICAgICAgICBiYXNlVmFsdWUsXG4gICAgICAgICAgICAgIG90aGVyVmFsdWUsXG4gICAgICAgICAgICAgIGJhc2VTdGFjayxcbiAgICAgICAgICAgICAgb3RoZXJTdGFjayxcbiAgICAgICAgICAgICAgaiQuTnVsbERpZmZCdWlsZGVyKClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIWZvdW5kICYmIHByZXZTdGFja1NpemUgIT09IGJhc2VTdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgYmFzZVN0YWNrLnNwbGljZShwcmV2U3RhY2tTaXplKTtcbiAgICAgICAgICAgICAgb3RoZXJTdGFjay5zcGxpY2UocHJldlN0YWNrU2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCAmJiBmb3VuZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICBkaWZmQnVpbGRlci5yZWNvcmRNaXNtYXRjaCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChqJC5pc1VSTChhKSAmJiBqJC5pc1VSTChiKSkge1xuICAgICAgLy8gVVJMcyBoYXZlIG5vIGVudW1yYWJsZSBwcm9wZXJ0aWVzLCBzbyB0aGUgZGVmYXVsdCBvYmplY3QgY29tcGFyaXNvblxuICAgICAgLy8gd291bGQgY29uc2lkZXIgYW55IHR3byBVUkxzIHRvIGJlIGVxdWFsLlxuICAgICAgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHNcbiAgICAgIC8vIG9yIGBBcnJheWBzIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLFxuICAgICAgICBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgICBpZiAoXG4gICAgICAgIGFDdG9yICE9PSBiQ3RvciAmJlxuICAgICAgICBpc0Z1bmN0aW9uKGFDdG9yKSAmJlxuICAgICAgICBpc0Z1bmN0aW9uKGJDdG9yKSAmJlxuICAgICAgICBhIGluc3RhbmNlb2YgYUN0b3IgJiZcbiAgICAgICAgYiBpbnN0YW5jZW9mIGJDdG9yICYmXG4gICAgICAgICEoYUN0b3IgaW5zdGFuY2VvZiBhQ3RvciAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKVxuICAgICAgKSB7XG4gICAgICAgIGRpZmZCdWlsZGVyLnJlY29yZE1pc21hdGNoKFxuICAgICAgICAgIGNvbnN0cnVjdG9yc0FyZURpZmZlcmVudEZvcm1hdHRlci5iaW5kKG51bGwsIHRoaXMucHApXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWVwIGNvbXBhcmUgb2JqZWN0cy5cbiAgICB2YXIgYUtleXMgPSBrZXlzKGEsIGNsYXNzTmFtZSA9PSAnW29iamVjdCBBcnJheV0nKSxcbiAgICAgIGtleTtcbiAgICBzaXplID0gYUtleXMubGVuZ3RoO1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgYm90aCBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXMgYmVmb3JlIGNvbXBhcmluZyBkZWVwIGVxdWFsaXR5LlxuICAgIGlmIChrZXlzKGIsIGNsYXNzTmFtZSA9PSAnW29iamVjdCBBcnJheV0nKS5sZW5ndGggIT09IHNpemUpIHtcbiAgICAgIGRpZmZCdWlsZGVyLnJlY29yZE1pc21hdGNoKFxuICAgICAgICBvYmplY3RLZXlzQXJlRGlmZmVyZW50Rm9ybWF0dGVyLmJpbmQobnVsbCwgdGhpcy5wcClcbiAgICAgICk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAga2V5ID0gYUtleXNbaV07XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXJcbiAgICAgIGlmICghaiQudXRpbC5oYXMoYiwga2V5KSkge1xuICAgICAgICBkaWZmQnVpbGRlci5yZWNvcmRNaXNtYXRjaChcbiAgICAgICAgICBvYmplY3RLZXlzQXJlRGlmZmVyZW50Rm9ybWF0dGVyLmJpbmQobnVsbCwgdGhpcy5wcClcbiAgICAgICAgKTtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBkaWZmQnVpbGRlci53aXRoUGF0aChrZXksIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXNlbGYuZXFfKGFba2V5XSwgYltrZXldLCBhU3RhY2ssIGJTdGFjaywgZGlmZkJ1aWxkZXIpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnBvcCgpO1xuICAgIGJTdGFjay5wb3AoKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgZnVuY3Rpb24ga2V5cyhvYmosIGlzQXJyYXkpIHtcbiAgICB2YXIgYWxsS2V5cyA9IE9iamVjdC5rZXlzXG4gICAgICA/IE9iamVjdC5rZXlzKG9iailcbiAgICAgIDogKGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvKSB7XG4gICAgICAgICAgICBpZiAoaiQudXRpbC5oYXMobywga2V5KSkge1xuICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICAgIH0pKG9iaik7XG5cbiAgICBpZiAoIWlzQXJyYXkpIHtcbiAgICAgIHJldHVybiBhbGxLZXlzO1xuICAgIH1cblxuICAgIGlmIChhbGxLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGFsbEtleXM7XG4gICAgfVxuXG4gICAgdmFyIGV4dHJhS2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCEvXlswLTldKyQvLnRlc3QoYWxsS2V5c1tpXSkpIHtcbiAgICAgICAgZXh0cmFLZXlzLnB1c2goYWxsS2V5c1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4dHJhS2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICBmdW5jdGlvbiBvYmplY3RLZXlzQXJlRGlmZmVyZW50Rm9ybWF0dGVyKHBwLCBhY3R1YWwsIGV4cGVjdGVkLCBwYXRoKSB7XG4gICAgdmFyIG1pc3NpbmdQcm9wZXJ0aWVzID0gaiQudXRpbC5vYmplY3REaWZmZXJlbmNlKGV4cGVjdGVkLCBhY3R1YWwpLFxuICAgICAgZXh0cmFQcm9wZXJ0aWVzID0gaiQudXRpbC5vYmplY3REaWZmZXJlbmNlKGFjdHVhbCwgZXhwZWN0ZWQpLFxuICAgICAgbWlzc2luZ1Byb3BlcnRpZXNNZXNzYWdlID0gZm9ybWF0S2V5VmFsdWVQYWlycyhwcCwgbWlzc2luZ1Byb3BlcnRpZXMpLFxuICAgICAgZXh0cmFQcm9wZXJ0aWVzTWVzc2FnZSA9IGZvcm1hdEtleVZhbHVlUGFpcnMocHAsIGV4dHJhUHJvcGVydGllcyksXG4gICAgICBtZXNzYWdlcyA9IFtdO1xuXG4gICAgaWYgKCFwYXRoLmRlcHRoKCkpIHtcbiAgICAgIHBhdGggPSAnb2JqZWN0JztcbiAgICB9XG5cbiAgICBpZiAobWlzc2luZ1Byb3BlcnRpZXNNZXNzYWdlLmxlbmd0aCkge1xuICAgICAgbWVzc2FnZXMucHVzaChcbiAgICAgICAgJ0V4cGVjdGVkICcgKyBwYXRoICsgJyB0byBoYXZlIHByb3BlcnRpZXMnICsgbWlzc2luZ1Byb3BlcnRpZXNNZXNzYWdlXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChleHRyYVByb3BlcnRpZXNNZXNzYWdlLmxlbmd0aCkge1xuICAgICAgbWVzc2FnZXMucHVzaChcbiAgICAgICAgJ0V4cGVjdGVkICcgKyBwYXRoICsgJyBub3QgdG8gaGF2ZSBwcm9wZXJ0aWVzJyArIGV4dHJhUHJvcGVydGllc01lc3NhZ2VcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lc3NhZ2VzLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29uc3RydWN0b3JzQXJlRGlmZmVyZW50Rm9ybWF0dGVyKHBwLCBhY3R1YWwsIGV4cGVjdGVkLCBwYXRoKSB7XG4gICAgaWYgKCFwYXRoLmRlcHRoKCkpIHtcbiAgICAgIHBhdGggPSAnb2JqZWN0JztcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgJ0V4cGVjdGVkICcgK1xuICAgICAgcGF0aCArXG4gICAgICAnIHRvIGJlIGEga2luZCBvZiAnICtcbiAgICAgIGokLmZuTmFtZUZvcihleHBlY3RlZC5jb25zdHJ1Y3RvcikgK1xuICAgICAgJywgYnV0IHdhcyAnICtcbiAgICAgIHBwKGFjdHVhbCkgK1xuICAgICAgJy4nXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFjdHVhbEFycmF5SXNMb25nZXJGb3JtYXR0ZXIocHAsIGFjdHVhbCwgZXhwZWN0ZWQsIHBhdGgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgJ1VuZXhwZWN0ZWQgJyArXG4gICAgICBwYXRoICtcbiAgICAgIChwYXRoLmRlcHRoKCkgPyAnID0gJyA6ICcnKSArXG4gICAgICBwcChhY3R1YWwpICtcbiAgICAgICcgaW4gYXJyYXkuJ1xuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRLZXlWYWx1ZVBhaXJzKHBwLCBvYmopIHtcbiAgICB2YXIgZm9ybWF0dGVkID0gJyc7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgZm9ybWF0dGVkICs9ICdcXG4gICAgJyArIGtleSArICc6ICcgKyBwcChvYmpba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiBmb3JtYXR0ZWQ7XG4gIH1cblxuICByZXR1cm4gTWF0Y2hlcnNVdGlsO1xufTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEFzeW1tZXRyaWNFcXVhbGl0eVRlc3RlclxuICogQGNsYXNzZGVzYyBBbiBhc3ltbWV0cmljIGVxdWFsaXR5IHRlc3RlciBpcyBhbiBvYmplY3QgdGhhdCBjYW4gbWF0Y2ggbXVsdGlwbGVcbiAqIG9iamVjdHMuIEV4YW1wbGVzIGluY2x1ZGUgamFzbWluZS5hbnkoKSBhbmQgamFzbWluZS5zdHJpbmdNYXRjaGluZygpLiBKYXNtaW5lXG4gKiBpbmNsdWRlcyBhIG51bWJlciBvZiBidWlsdC1pbiBhc3ltbWV0cmljIGVxdWFsaXR5IHRlc3RlcnMsIHN1Y2ggYXNcbiAqIHtAbGluayBqYXNtaW5lLm9iamVjdENvbnRhaW5pbmd9LiBVc2VyLWRlZmluZWQgYXN5bW1ldHJpYyBlcXVhbGl0eSB0ZXN0ZXJzIGFyZVxuICogYWxzbyBzdXBwb3J0ZWQuXG4gKlxuICogQXN5bW1ldHJpYyBlcXVhbGl0eSB0ZXN0ZXJzIHdvcmsgd2l0aCBhbnkgbWF0Y2hlciwgaW5jbHVkaW5nIHVzZXItZGVmaW5lZFxuICogY3VzdG9tIG1hdGNoZXJzLCB0aGF0IHVzZXMge0BsaW5rIE1hdGNoZXJzVXRpbCNlcXVhbHN9IG9yXG4gKiB7QGxpbmsgTWF0Y2hlcnNVdGlsI2NvbnRhaW5zfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogZnVuY3Rpb24gbnVtYmVyRGl2aXNpYmxlQnkoZGl2aXNvcikge1xuICogICByZXR1cm4ge1xuICogICAgIGFzeW1tZXRyaWNNYXRjaDogZnVuY3Rpb24obikge1xuICogICAgICAgcmV0dXJuIHR5cGVvZiBuID09PSAnbnVtYmVyJyAmJiBuICUgZGl2aXNvciA9PT0gMDtcbiAqICAgICB9LFxuICogICAgIGphc21pbmVUb1N0cmluZzogZnVuY3Rpb24oKSB7XG4gKiAgICAgICByZXR1cm4gYDxhIG51bWJlciBkaXZpc2libGUgYnkgJHtkaXZpc29yfT5gO1xuICogICAgIH1cbiAqICAgfTtcbiAqIH1cbiAqXG4gKiB2YXIgYWN0dWFsID0ge1xuICogICBuOiAyLFxuICogICBvdGhlckZpZWxkczogXCJkb24ndCBjYXJlXCJcbiAqIH07XG4gKlxuICogZXhwZWN0KGFjdHVhbCkudG9FcXVhbChqYXNtaW5lLm9iamVjdENvbnRhaW5pbmcoe246IG51bWJlckRpdmlzaWJsZUJ5KDIpfSkpO1xuICogQHNlZSBjdXN0b21fYXN5bW1ldHJpY19lcXVhbGl0eV90ZXN0ZXJzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSB2YWx1ZSBtYXRjaGVzIHRoaXMgdGVzdGVyXG4gKiBAZnVuY3Rpb25cbiAqIEBuYW1lIEFzeW1tZXRyaWNFcXVhbGl0eVRlc3RlciNhc3ltbWV0cmljTWF0Y2hcbiAqIEBwYXJhbSB2YWx1ZSB7YW55fSBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHBhcmFtIG1hdGNoZXJzVXRpbCB7TWF0Y2hlcnNVdGlsfSB1dGlsaXRpZXMgZm9yIHRlc3RpbmcgZXF1YWxpdHksIGV0Y1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdGVzdGVyIHRvIHVzZSBpbiBtYXRjaGVyIGZhaWx1cmUgbWVzc2FnZXNcbiAqIEBmdW5jdGlvblxuICogQG5hbWUgQXN5bW1ldHJpY0VxdWFsaXR5VGVzdGVyI2phc21pbmVUb1N0cmluZ1xuICogQHBhcmFtIHBwIHtmdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCB0YWtlcyBhIHZhbHVlIGFuZCByZXR1cm5zIGEgcHJldHR5LXByaW50ZWQgcmVwcmVzZW50YXRpb25cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLk1pc21hdGNoVHJlZSA9IGZ1bmN0aW9uKGokKSB7XG4gIC8qXG4gICAgVG8gYmUgYWJsZSB0byBhcHBseSBjdXN0b20gb2JqZWN0IGZvcm1hdHRlcnMgYXQgYWxsIHBvc3NpYmxlIGxldmVscyBvZiBhblxuICAgIG9iamVjdCBncmFwaCwgRGlmZkJ1aWxkZXIgbmVlZHMgdG8gYmUgYWJsZSB0byBrbm93IG5vdCBqdXN0IHdoZXJlIHRoZVxuICAgIG1pc21hdGNoIG9jY3VycmVkIGJ1dCBhbHNvIGFsbCBhbmNlc3RvcnMgb2YgdGhlIG1pc21hdGNoZWQgdmFsdWUgaW4gYm90aFxuICAgIHRoZSBleHBlY3RlZCBhbmQgYWN0dWFsIG9iamVjdCBncmFwaHMuIE1pc21hdGNoVHJlZSBtYWludGFpbnMgdGhhdCBjb250ZXh0XG4gICAgYW5kIHByb3ZpZGVzIGl0IHZpYSB0aGUgdHJhdmVyc2UgbWV0aG9kLlxuICAgKi9cbiAgZnVuY3Rpb24gTWlzbWF0Y2hUcmVlKHBhdGgpIHtcbiAgICB0aGlzLnBhdGggPSBwYXRoIHx8IG5ldyBqJC5PYmplY3RQYXRoKFtdKTtcbiAgICB0aGlzLmZvcm1hdHRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdGhpcy5pc01pc21hdGNoID0gZmFsc2U7XG4gIH1cblxuICBNaXNtYXRjaFRyZWUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHBhdGgsIGZvcm1hdHRlcikge1xuICAgIHZhciBrZXksIGNoaWxkO1xuXG4gICAgaWYgKHBhdGguZGVwdGgoKSA9PT0gMCkge1xuICAgICAgdGhpcy5mb3JtYXR0ZXIgPSBmb3JtYXR0ZXI7XG4gICAgICB0aGlzLmlzTWlzbWF0Y2ggPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBwYXRoLmNvbXBvbmVudHNbMF07XG4gICAgICBwYXRoID0gcGF0aC5zaGlmdCgpO1xuICAgICAgY2hpbGQgPSB0aGlzLmNoaWxkKGtleSk7XG5cbiAgICAgIGlmICghY2hpbGQpIHtcbiAgICAgICAgY2hpbGQgPSBuZXcgTWlzbWF0Y2hUcmVlKHRoaXMucGF0aC5hZGQoa2V5KSk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkLmFkZChwYXRoLCBmb3JtYXR0ZXIpO1xuICAgIH1cbiAgfTtcblxuICBNaXNtYXRjaFRyZWUucHJvdG90eXBlLnRyYXZlcnNlID0gZnVuY3Rpb24odmlzaXQpIHtcbiAgICB2YXIgaSxcbiAgICAgIGhhc0NoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwO1xuXG4gICAgaWYgKHRoaXMuaXNNaXNtYXRjaCB8fCBoYXNDaGlsZHJlbikge1xuICAgICAgaWYgKHZpc2l0KHRoaXMucGF0aCwgIWhhc0NoaWxkcmVuLCB0aGlzLmZvcm1hdHRlcikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnRyYXZlcnNlKHZpc2l0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBNaXNtYXRjaFRyZWUucHJvdG90eXBlLmNoaWxkID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgdmFyIGksIHBhdGhFbHM7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgcGF0aEVscyA9IHRoaXMuY2hpbGRyZW5baV0ucGF0aC5jb21wb25lbnRzO1xuICAgICAgaWYgKHBhdGhFbHNbcGF0aEVscy5sZW5ndGggLSAxXSA9PT0ga2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gTWlzbWF0Y2hUcmVlO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5ub3RoaW5nID0gZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSBub3RoaW5nIGV4cGxpY2l0bHkuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyNub3RoaW5nXG4gICAqIEBzaW5jZSAyLjguMFxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QoKS5ub3RoaW5nKCk7XG4gICAqL1xuICBmdW5jdGlvbiBub3RoaW5nKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXNzOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBub3RoaW5nO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5OdWxsRGlmZkJ1aWxkZXIgPSBmdW5jdGlvbihqJCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpdGhQYXRoOiBmdW5jdGlvbihfLCBibG9jaykge1xuICAgICAgICBibG9jaygpO1xuICAgICAgfSxcbiAgICAgIHNldFJvb3RzOiBmdW5jdGlvbigpIHt9LFxuICAgICAgcmVjb3JkTWlzbWF0Y2g6IGZ1bmN0aW9uKCkge31cbiAgICB9O1xuICB9O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5PYmplY3RQYXRoID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gT2JqZWN0UGF0aChjb21wb25lbnRzKSB7XG4gICAgdGhpcy5jb21wb25lbnRzID0gY29tcG9uZW50cyB8fCBbXTtcbiAgfVxuXG4gIE9iamVjdFBhdGgucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAnJCcgKyBtYXAodGhpcy5jb21wb25lbnRzLCBmb3JtYXRQcm9wZXJ0eUFjY2Vzcykuam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH07XG5cbiAgT2JqZWN0UGF0aC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIG5ldyBPYmplY3RQYXRoKHRoaXMuY29tcG9uZW50cy5jb25jYXQoW2NvbXBvbmVudF0pKTtcbiAgfTtcblxuICBPYmplY3RQYXRoLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgT2JqZWN0UGF0aCh0aGlzLmNvbXBvbmVudHMuc2xpY2UoMSkpO1xuICB9O1xuXG4gIE9iamVjdFBhdGgucHJvdG90eXBlLmRlcHRoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcG9uZW50cy5sZW5ndGg7XG4gIH07XG5cbiAgZnVuY3Rpb24gZm9ybWF0UHJvcGVydHlBY2Nlc3MocHJvcCkge1xuICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiAnWycgKyBwcm9wICsgJ10nO1xuICAgIH1cblxuICAgIGlmIChpc1ZhbGlkSWRlbnRpZmllcihwcm9wKSkge1xuICAgICAgcmV0dXJuICcuJyArIHByb3A7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiWydcIiArIHByb3AgKyBcIiddXCI7XG4gIH1cblxuICBmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRzLnB1c2goZm4oYXJyYXlbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICBmdW5jdGlvbiBpc1ZhbGlkSWRlbnRpZmllcihzdHJpbmcpIHtcbiAgICByZXR1cm4gL15bQS1aYS16XFwkX11bQS1aYS16MC05XFwkX10qJC8udGVzdChzdHJpbmcpO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdFBhdGg7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnJlcXVpcmVBc3luY01hdGNoZXJzID0gZnVuY3Rpb24oalJlcXVpcmUsIGokKSB7XG4gIHZhciBhdmFpbGFibGVNYXRjaGVycyA9IFtcbiAgICAgICd0b0JlUGVuZGluZycsXG4gICAgICAndG9CZVJlc29sdmVkJyxcbiAgICAgICd0b0JlUmVqZWN0ZWQnLFxuICAgICAgJ3RvQmVSZXNvbHZlZFRvJyxcbiAgICAgICd0b0JlUmVqZWN0ZWRXaXRoJyxcbiAgICAgICd0b0JlUmVqZWN0ZWRXaXRoRXJyb3InXG4gICAgXSxcbiAgICBtYXRjaGVycyA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXZhaWxhYmxlTWF0Y2hlcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmFtZSA9IGF2YWlsYWJsZU1hdGNoZXJzW2ldO1xuICAgIG1hdGNoZXJzW25hbWVdID0galJlcXVpcmVbbmFtZV0oaiQpO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXJzO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlID0gZnVuY3Rpb24oaiQpIHtcbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgdmFsdWUgdG8gYmUgYD09PWAgdG8gdGhlIGV4cGVjdGVkIHZhbHVlLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9CZVxuICAgKiBAc2luY2UgMS4zLjBcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4cGVjdGVkIC0gVGhlIGV4cGVjdGVkIHZhbHVlIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KHRoaW5nKS50b0JlKHJlYWxUaGluZyk7XG4gICAqL1xuICBmdW5jdGlvbiB0b0JlKG1hdGNoZXJzVXRpbCkge1xuICAgIHZhciB0aXAgPVxuICAgICAgJyBUaXA6IFRvIGNoZWNrIGZvciBkZWVwIGVxdWFsaXR5LCB1c2UgLnRvRXF1YWwoKSBpbnN0ZWFkIG9mIC50b0JlKCkuJztcblxuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgcGFzczogYWN0dWFsID09PSBleHBlY3RlZFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPVxuICAgICAgICAgICAgbWF0Y2hlcnNVdGlsLmJ1aWxkRmFpbHVyZU1lc3NhZ2UoXG4gICAgICAgICAgICAgICd0b0JlJyxcbiAgICAgICAgICAgICAgcmVzdWx0LnBhc3MsXG4gICAgICAgICAgICAgIGFjdHVhbCxcbiAgICAgICAgICAgICAgZXhwZWN0ZWRcbiAgICAgICAgICAgICkgKyB0aXA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9CZTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZUNsb3NlVG8gPSBmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgdmFsdWUgdG8gYmUgd2l0aGluIGEgc3BlY2lmaWVkIHByZWNpc2lvbiBvZiB0aGUgZXhwZWN0ZWQgdmFsdWUuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0JlQ2xvc2VUb1xuICAgKiBAc2luY2UgMS4zLjBcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4cGVjdGVkIC0gVGhlIGV4cGVjdGVkIHZhbHVlIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwcmVjaXNpb249Ml0gLSBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzIHRvIGNoZWNrLlxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QobnVtYmVyKS50b0JlQ2xvc2VUbyg0Mi4yLCAzKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvQmVDbG9zZVRvKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkLCBwcmVjaXNpb24pIHtcbiAgICAgICAgaWYgKHByZWNpc2lvbiAhPT0gMCkge1xuICAgICAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4cGVjdGVkID09PSBudWxsIHx8IGFjdHVhbCA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDYW5ub3QgdXNlIHRvQmVDbG9zZVRvIHdpdGggbnVsbC4gQXJndW1lbnRzIGV2YWx1YXRlZCB0bzogJyArXG4gICAgICAgICAgICAgICdleHBlY3QoJyArXG4gICAgICAgICAgICAgIGFjdHVhbCArXG4gICAgICAgICAgICAgICcpLnRvQmVDbG9zZVRvKCcgK1xuICAgICAgICAgICAgICBleHBlY3RlZCArXG4gICAgICAgICAgICAgICcpLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvdyA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24gKyAxKTtcbiAgICAgICAgdmFyIGRlbHRhID0gTWF0aC5hYnMoZXhwZWN0ZWQgLSBhY3R1YWwpO1xuICAgICAgICB2YXIgbWF4RGVsdGEgPSBNYXRoLnBvdygxMCwgLXByZWNpc2lvbikgLyAyO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFzczogTWF0aC5yb3VuZChkZWx0YSAqIHBvdykgPD0gbWF4RGVsdGEgKiBwb3dcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvQmVDbG9zZVRvO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlRGVmaW5lZCA9IGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCB2YWx1ZSB0byBiZSBkZWZpbmVkLiAoTm90IGB1bmRlZmluZWRgKVxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9CZURlZmluZWRcbiAgICogQHNpbmNlIDEuMy4wXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdChyZXN1bHQpLnRvQmVEZWZpbmVkKCk7XG4gICAqL1xuICBmdW5jdGlvbiB0b0JlRGVmaW5lZCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFzczogdm9pZCAwICE9PSBhY3R1YWxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvQmVEZWZpbmVkO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlRmFsc2UgPSBmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgdmFsdWUgdG8gYmUgYGZhbHNlYC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvQmVGYWxzZVxuICAgKiBAc2luY2UgMy41LjBcbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KHJlc3VsdCkudG9CZUZhbHNlKCk7XG4gICAqL1xuICBmdW5jdGlvbiB0b0JlRmFsc2UoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhc3M6IGFjdHVhbCA9PT0gZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvQmVGYWxzZTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZUZhbHN5ID0gZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIHZhbHVlIHRvIGJlIGZhbHN5XG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0JlRmFsc3lcbiAgICogQHNpbmNlIDIuMC4wXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdChyZXN1bHQpLnRvQmVGYWxzeSgpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9CZUZhbHN5KCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXNzOiAhYWN0dWFsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0JlRmFsc3k7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVHcmVhdGVyVGhhbiA9IGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCB2YWx1ZSB0byBiZSBncmVhdGVyIHRoYW4gdGhlIGV4cGVjdGVkIHZhbHVlLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9CZUdyZWF0ZXJUaGFuXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKiBAcGFyYW0ge051bWJlcn0gZXhwZWN0ZWQgLSBUaGUgdmFsdWUgdG8gY29tcGFyZSBhZ2FpbnN0LlxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QocmVzdWx0KS50b0JlR3JlYXRlclRoYW4oMyk7XG4gICAqL1xuICBmdW5jdGlvbiB0b0JlR3JlYXRlclRoYW4oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXNzOiBhY3R1YWwgPiBleHBlY3RlZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9CZUdyZWF0ZXJUaGFuO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlR3JlYXRlclRoYW5PckVxdWFsID0gZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIHZhbHVlIHRvIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgZXhwZWN0ZWQgdmFsdWUuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0JlR3JlYXRlclRoYW5PckVxdWFsXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKiBAcGFyYW0ge051bWJlcn0gZXhwZWN0ZWQgLSBUaGUgZXhwZWN0ZWQgdmFsdWUgdG8gY29tcGFyZSBhZ2FpbnN0LlxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QocmVzdWx0KS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDI1KTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXNzOiBhY3R1YWwgPj0gZXhwZWN0ZWRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvQmVHcmVhdGVyVGhhbk9yRXF1YWw7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVJbnN0YW5jZU9mID0gZnVuY3Rpb24oaiQpIHtcbiAgdmFyIHVzYWdlRXJyb3IgPSBqJC5mb3JtYXRFcnJvck1zZyhcbiAgICAnPHRvQmVJbnN0YW5jZU9mPicsXG4gICAgJ2V4cGVjdCh2YWx1ZSkudG9CZUluc3RhbmNlT2YoPENvbnN0cnVjdG9yRnVuY3Rpb24+KSdcbiAgKTtcblxuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCB0byBiZSBhbiBpbnN0YW5jZSBvZiB0aGUgZXhwZWN0ZWQgY2xhc3NcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvQmVJbnN0YW5jZU9mXG4gICAqIEBzaW5jZSAzLjUuMFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXhwZWN0ZWQgLSBUaGUgY2xhc3Mgb3IgY29uc3RydWN0b3IgZnVuY3Rpb24gdG8gY2hlY2sgZm9yXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdCgnZm9vJykudG9CZUluc3RhbmNlT2YoU3RyaW5nKTtcbiAgICogZXhwZWN0KDMpLnRvQmVJbnN0YW5jZU9mKE51bWJlcik7XG4gICAqIGV4cGVjdChuZXcgRXJyb3IoKSkudG9CZUluc3RhbmNlT2YoRXJyb3IpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9CZUluc3RhbmNlT2YobWF0Y2hlcnNVdGlsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgICAgICAgdmFyIGFjdHVhbFR5cGUgPVxuICAgICAgICAgICAgYWN0dWFsICYmIGFjdHVhbC5jb25zdHJ1Y3RvclxuICAgICAgICAgICAgICA/IGokLmZuTmFtZUZvcihhY3R1YWwuY29uc3RydWN0b3IpXG4gICAgICAgICAgICAgIDogbWF0Y2hlcnNVdGlsLnBwKGFjdHVhbCksXG4gICAgICAgICAgZXhwZWN0ZWRUeXBlID0gZXhwZWN0ZWRcbiAgICAgICAgICAgID8gaiQuZm5OYW1lRm9yKGV4cGVjdGVkKVxuICAgICAgICAgICAgOiBtYXRjaGVyc1V0aWwucHAoZXhwZWN0ZWQpLFxuICAgICAgICAgIGV4cGVjdGVkTWF0Y2hlcixcbiAgICAgICAgICBwYXNzO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXhwZWN0ZWRNYXRjaGVyID0gbmV3IGokLkFueShleHBlY3RlZCk7XG4gICAgICAgICAgcGFzcyA9IGV4cGVjdGVkTWF0Y2hlci5hc3ltbWV0cmljTWF0Y2goYWN0dWFsKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICB1c2FnZUVycm9yKCdFeHBlY3RlZCB2YWx1ZSBpcyBub3QgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbicpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXNzKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhc3M6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgICAnRXhwZWN0ZWQgaW5zdGFuY2Ugb2YgJyArXG4gICAgICAgICAgICAgIGFjdHVhbFR5cGUgK1xuICAgICAgICAgICAgICAnIG5vdCB0byBiZSBhbiBpbnN0YW5jZSBvZiAnICtcbiAgICAgICAgICAgICAgZXhwZWN0ZWRUeXBlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGFzczogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgICAnRXhwZWN0ZWQgaW5zdGFuY2Ugb2YgJyArXG4gICAgICAgICAgICAgIGFjdHVhbFR5cGUgK1xuICAgICAgICAgICAgICAnIHRvIGJlIGFuIGluc3RhbmNlIG9mICcgK1xuICAgICAgICAgICAgICBleHBlY3RlZFR5cGVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0JlSW5zdGFuY2VPZjtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZUxlc3NUaGFuID0gZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIHZhbHVlIHRvIGJlIGxlc3MgdGhhbiB0aGUgZXhwZWN0ZWQgdmFsdWUuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0JlTGVzc1RoYW5cbiAgICogQHNpbmNlIDIuMC4wXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBleHBlY3RlZCAtIFRoZSBleHBlY3RlZCB2YWx1ZSB0byBjb21wYXJlIGFnYWluc3QuXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdChyZXN1bHQpLnRvQmVMZXNzVGhhbigwKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvQmVMZXNzVGhhbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhc3M6IGFjdHVhbCA8IGV4cGVjdGVkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0JlTGVzc1RoYW47XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVMZXNzVGhhbk9yRXF1YWwgPSBmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgdmFsdWUgdG8gYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBleHBlY3RlZCB2YWx1ZS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvQmVMZXNzVGhhbk9yRXF1YWxcbiAgICogQHNpbmNlIDIuMC4wXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBleHBlY3RlZCAtIFRoZSBleHBlY3RlZCB2YWx1ZSB0byBjb21wYXJlIGFnYWluc3QuXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdChyZXN1bHQpLnRvQmVMZXNzVGhhbk9yRXF1YWwoMTIzKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvQmVMZXNzVGhhbk9yRXF1YWwoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXNzOiBhY3R1YWwgPD0gZXhwZWN0ZWRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvQmVMZXNzVGhhbk9yRXF1YWw7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVOYU4gPSBmdW5jdGlvbihqJCkge1xuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCB2YWx1ZSB0byBiZSBgTmFOYCAoTm90IGEgTnVtYmVyKS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvQmVOYU5cbiAgICogQHNpbmNlIDEuMy4wXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdCh0aGluZykudG9CZU5hTigpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9CZU5hTihtYXRjaGVyc1V0aWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgcGFzczogYWN0dWFsICE9PSBhY3R1YWxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAocmVzdWx0LnBhc3MpIHtcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9ICdFeHBlY3RlZCBhY3R1YWwgbm90IHRvIGJlIE5hTi4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0V4cGVjdGVkICcgKyBtYXRjaGVyc1V0aWwucHAoYWN0dWFsKSArICcgdG8gYmUgTmFOLic7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0JlTmFOO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlTmVnYXRpdmVJbmZpbml0eSA9IGZ1bmN0aW9uKGokKSB7XG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIHZhbHVlIHRvIGJlIGAtSW5maW5pdHlgICgtaW5maW5pdHkpLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9CZU5lZ2F0aXZlSW5maW5pdHlcbiAgICogQHNpbmNlIDIuNi4wXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdCh0aGluZykudG9CZU5lZ2F0aXZlSW5maW5pdHkoKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvQmVOZWdhdGl2ZUluZmluaXR5KG1hdGNoZXJzVXRpbCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICBwYXNzOiBhY3R1YWwgPT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChyZXN1bHQucGFzcykge1xuICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID0gJ0V4cGVjdGVkIGFjdHVhbCBub3QgdG8gYmUgLUluZmluaXR5Lic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAnRXhwZWN0ZWQgJyArIG1hdGNoZXJzVXRpbC5wcChhY3R1YWwpICsgJyB0byBiZSAtSW5maW5pdHkuJztcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvQmVOZWdhdGl2ZUluZmluaXR5O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlTnVsbCA9IGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCB2YWx1ZSB0byBiZSBgbnVsbGAuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0JlTnVsbFxuICAgKiBAc2luY2UgMS4zLjBcbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvQmVOdWxsKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXNzOiBhY3R1YWwgPT09IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvQmVOdWxsO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlUG9zaXRpdmVJbmZpbml0eSA9IGZ1bmN0aW9uKGokKSB7XG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIHZhbHVlIHRvIGJlIGBJbmZpbml0eWAgKGluZmluaXR5KS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvQmVQb3NpdGl2ZUluZmluaXR5XG4gICAqIEBzaW5jZSAyLjYuMFxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QodGhpbmcpLnRvQmVQb3NpdGl2ZUluZmluaXR5KCk7XG4gICAqL1xuICBmdW5jdGlvbiB0b0JlUG9zaXRpdmVJbmZpbml0eShtYXRjaGVyc1V0aWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgcGFzczogYWN0dWFsID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAocmVzdWx0LnBhc3MpIHtcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9ICdFeHBlY3RlZCBhY3R1YWwgbm90IHRvIGJlIEluZmluaXR5Lic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAnRXhwZWN0ZWQgJyArIG1hdGNoZXJzVXRpbC5wcChhY3R1YWwpICsgJyB0byBiZSBJbmZpbml0eS4nO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9CZVBvc2l0aXZlSW5maW5pdHk7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVUcnVlID0gZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIHZhbHVlIHRvIGJlIGB0cnVlYC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvQmVUcnVlXG4gICAqIEBzaW5jZSAzLjUuMFxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QocmVzdWx0KS50b0JlVHJ1ZSgpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9CZVRydWUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhc3M6IGFjdHVhbCA9PT0gdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9CZVRydWU7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVUcnV0aHkgPSBmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgdmFsdWUgdG8gYmUgdHJ1dGh5LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9CZVRydXRoeVxuICAgKiBAc2luY2UgMi4wLjBcbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KHRoaW5nKS50b0JlVHJ1dGh5KCk7XG4gICAqL1xuICBmdW5jdGlvbiB0b0JlVHJ1dGh5KCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXNzOiAhIWFjdHVhbFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9CZVRydXRoeTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZVVuZGVmaW5lZCA9IGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCB2YWx1ZSB0byBiZSBgdW5kZWZpbmVkYC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvQmVVbmRlZmluZWRcbiAgICogQHNpbmNlIDEuMy4wXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdChyZXN1bHQpLnRvQmVVbmRlZmluZWQoKTpcbiAgICovXG4gIGZ1bmN0aW9uIHRvQmVVbmRlZmluZWQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhc3M6IHZvaWQgMCA9PT0gYWN0dWFsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0JlVW5kZWZpbmVkO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0NvbnRhaW4gPSBmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgdmFsdWUgdG8gY29udGFpbiBhIHNwZWNpZmljIHZhbHVlLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9Db250YWluXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXhwZWN0ZWQgLSBUaGUgdmFsdWUgdG8gbG9vayBmb3IuXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdChhcnJheSkudG9Db250YWluKGFuRWxlbWVudCk7XG4gICAqIGV4cGVjdChzdHJpbmcpLnRvQ29udGFpbihzdWJzdHJpbmcpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9Db250YWluKG1hdGNoZXJzVXRpbCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFzczogbWF0Y2hlcnNVdGlsLmNvbnRhaW5zKGFjdHVhbCwgZXhwZWN0ZWQpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0NvbnRhaW47XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvRXF1YWwgPSBmdW5jdGlvbihqJCkge1xuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCB2YWx1ZSB0byBiZSBlcXVhbCB0byB0aGUgZXhwZWN0ZWQsIHVzaW5nIGRlZXAgZXF1YWxpdHkgY29tcGFyaXNvbi5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvRXF1YWxcbiAgICogQHNpbmNlIDEuMy4wXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHBlY3RlZCAtIEV4cGVjdGVkIHZhbHVlXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdChiaWdPYmplY3QpLnRvRXF1YWwoe1wiZm9vXCI6IFsnYmFyJywgJ2JheiddfSk7XG4gICAqL1xuICBmdW5jdGlvbiB0b0VxdWFsKG1hdGNoZXJzVXRpbCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBwYXNzOiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGlmZkJ1aWxkZXIgPSBqJC5EaWZmQnVpbGRlcih7IHByZXR0eVByaW50ZXI6IG1hdGNoZXJzVXRpbC5wcCB9KTtcblxuICAgICAgICByZXN1bHQucGFzcyA9IG1hdGNoZXJzVXRpbC5lcXVhbHMoYWN0dWFsLCBleHBlY3RlZCwgZGlmZkJ1aWxkZXIpO1xuXG4gICAgICAgIC8vIFRPRE86IG9ubHkgc2V0IGVycm9yIG1lc3NhZ2UgaWYgdGVzdCBmYWlsc1xuICAgICAgICByZXN1bHQubWVzc2FnZSA9IGRpZmZCdWlsZGVyLmdldE1lc3NhZ2UoKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9FcXVhbDtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9IYXZlQmVlbkNhbGxlZCA9IGZ1bmN0aW9uKGokKSB7XG4gIHZhciBnZXRFcnJvck1zZyA9IGokLmZvcm1hdEVycm9yTXNnKFxuICAgICc8dG9IYXZlQmVlbkNhbGxlZD4nLFxuICAgICdleHBlY3QoPHNweU9iaj4pLnRvSGF2ZUJlZW5DYWxsZWQoKSdcbiAgKTtcblxuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCAoYSB7QGxpbmsgU3B5fSkgdG8gaGF2ZSBiZWVuIGNhbGxlZC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvSGF2ZUJlZW5DYWxsZWRcbiAgICogQHNpbmNlIDEuMy4wXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdChteVNweSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgKiBleHBlY3QobXlTcHkpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAqL1xuICBmdW5jdGlvbiB0b0hhdmVCZWVuQ2FsbGVkKG1hdGNoZXJzVXRpbCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgICAgIGlmICghaiQuaXNTcHkoYWN0dWFsKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGdldEVycm9yTXNnKFxuICAgICAgICAgICAgICAnRXhwZWN0ZWQgYSBzcHksIGJ1dCBnb3QgJyArIG1hdGNoZXJzVXRpbC5wcChhY3R1YWwpICsgJy4nXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGdldEVycm9yTXNnKCdEb2VzIG5vdCB0YWtlIGFyZ3VtZW50cywgdXNlIHRvSGF2ZUJlZW5DYWxsZWRXaXRoJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnBhc3MgPSBhY3R1YWwuY2FsbHMuYW55KCk7XG5cbiAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSByZXN1bHQucGFzc1xuICAgICAgICAgID8gJ0V4cGVjdGVkIHNweSAnICsgYWN0dWFsLmFuZC5pZGVudGl0eSArICcgbm90IHRvIGhhdmUgYmVlbiBjYWxsZWQuJ1xuICAgICAgICAgIDogJ0V4cGVjdGVkIHNweSAnICsgYWN0dWFsLmFuZC5pZGVudGl0eSArICcgdG8gaGF2ZSBiZWVuIGNhbGxlZC4nO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0hhdmVCZWVuQ2FsbGVkO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0hhdmVCZWVuQ2FsbGVkQmVmb3JlID0gZnVuY3Rpb24oaiQpIHtcbiAgdmFyIGdldEVycm9yTXNnID0gaiQuZm9ybWF0RXJyb3JNc2coXG4gICAgJzx0b0hhdmVCZWVuQ2FsbGVkQmVmb3JlPicsXG4gICAgJ2V4cGVjdCg8c3B5T2JqPikudG9IYXZlQmVlbkNhbGxlZEJlZm9yZSg8c3B5T2JqPiknXG4gICk7XG5cbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgdmFsdWUgKGEge0BsaW5rIFNweX0pIHRvIGhhdmUgYmVlbiBjYWxsZWQgYmVmb3JlIGFub3RoZXIge0BsaW5rIFNweX0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0hhdmVCZWVuQ2FsbGVkQmVmb3JlXG4gICAqIEBzaW5jZSAyLjYuMFxuICAgKiBAcGFyYW0ge1NweX0gZXhwZWN0ZWQgLSB7QGxpbmsgU3B5fSB0aGF0IHNob3VsZCBoYXZlIGJlZW4gY2FsbGVkIGFmdGVyIHRoZSBgYWN0dWFsYCB7QGxpbmsgU3B5fS5cbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KG15U3B5KS50b0hhdmVCZWVuQ2FsbGVkQmVmb3JlKG90aGVyU3B5KTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvSGF2ZUJlZW5DYWxsZWRCZWZvcmUobWF0Y2hlcnNVdGlsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGZpcnN0U3B5LCBsYXR0ZXJTcHkpIHtcbiAgICAgICAgaWYgKCFqJC5pc1NweShmaXJzdFNweSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBnZXRFcnJvck1zZyhcbiAgICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3B5LCBidXQgZ290ICcgKyBtYXRjaGVyc1V0aWwucHAoZmlyc3RTcHkpICsgJy4nXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWokLmlzU3B5KGxhdHRlclNweSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBnZXRFcnJvck1zZyhcbiAgICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3B5LCBidXQgZ290ICcgKyBtYXRjaGVyc1V0aWwucHAobGF0dGVyU3B5KSArICcuJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0geyBwYXNzOiBmYWxzZSB9O1xuXG4gICAgICAgIGlmICghZmlyc3RTcHkuY2FsbHMuY291bnQoKSkge1xuICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID1cbiAgICAgICAgICAgICdFeHBlY3RlZCBzcHkgJyArIGZpcnN0U3B5LmFuZC5pZGVudGl0eSArICcgdG8gaGF2ZSBiZWVuIGNhbGxlZC4nO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsYXR0ZXJTcHkuY2FsbHMuY291bnQoKSkge1xuICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID1cbiAgICAgICAgICAgICdFeHBlY3RlZCBzcHkgJyArIGxhdHRlclNweS5hbmQuaWRlbnRpdHkgKyAnIHRvIGhhdmUgYmVlbiBjYWxsZWQuJztcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhdGVzdDFzdFNweUNhbGwgPSBmaXJzdFNweS5jYWxscy5tb3N0UmVjZW50KCkuaW52b2NhdGlvbk9yZGVyO1xuICAgICAgICB2YXIgZmlyc3QybmRTcHlDYWxsID0gbGF0dGVyU3B5LmNhbGxzLmZpcnN0KCkuaW52b2NhdGlvbk9yZGVyO1xuXG4gICAgICAgIHJlc3VsdC5wYXNzID0gbGF0ZXN0MXN0U3B5Q2FsbCA8IGZpcnN0Mm5kU3B5Q2FsbDtcblxuICAgICAgICBpZiAocmVzdWx0LnBhc3MpIHtcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9XG4gICAgICAgICAgICAnRXhwZWN0ZWQgc3B5ICcgK1xuICAgICAgICAgICAgZmlyc3RTcHkuYW5kLmlkZW50aXR5ICtcbiAgICAgICAgICAgICcgdG8gbm90IGhhdmUgYmVlbiBjYWxsZWQgYmVmb3JlIHNweSAnICtcbiAgICAgICAgICAgIGxhdHRlclNweS5hbmQuaWRlbnRpdHkgK1xuICAgICAgICAgICAgJywgYnV0IGl0IHdhcyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGZpcnN0MXN0U3B5Q2FsbCA9IGZpcnN0U3B5LmNhbGxzLmZpcnN0KCkuaW52b2NhdGlvbk9yZGVyO1xuICAgICAgICAgIHZhciBsYXRlc3QybmRTcHlDYWxsID0gbGF0dGVyU3B5LmNhbGxzLm1vc3RSZWNlbnQoKS5pbnZvY2F0aW9uT3JkZXI7XG5cbiAgICAgICAgICBpZiAoZmlyc3Qxc3RTcHlDYWxsIDwgZmlyc3QybmRTcHlDYWxsKSB7XG4gICAgICAgICAgICByZXN1bHQubWVzc2FnZSA9XG4gICAgICAgICAgICAgICdFeHBlY3RlZCBsYXRlc3QgY2FsbCB0byBzcHkgJyArXG4gICAgICAgICAgICAgIGZpcnN0U3B5LmFuZC5pZGVudGl0eSArXG4gICAgICAgICAgICAgICcgdG8gaGF2ZSBiZWVuIGNhbGxlZCBiZWZvcmUgZmlyc3QgY2FsbCB0byBzcHkgJyArXG4gICAgICAgICAgICAgIGxhdHRlclNweS5hbmQuaWRlbnRpdHkgK1xuICAgICAgICAgICAgICAnIChubyBpbnRlcmxlYXZlZCBjYWxscyknO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGF0ZXN0Mm5kU3B5Q2FsbCA+IGxhdGVzdDFzdFNweUNhbGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID1cbiAgICAgICAgICAgICAgJ0V4cGVjdGVkIGZpcnN0IGNhbGwgdG8gc3B5ICcgK1xuICAgICAgICAgICAgICBsYXR0ZXJTcHkuYW5kLmlkZW50aXR5ICtcbiAgICAgICAgICAgICAgJyB0byBoYXZlIGJlZW4gY2FsbGVkIGFmdGVyIGxhdGVzdCBjYWxsIHRvIHNweSAnICtcbiAgICAgICAgICAgICAgZmlyc3RTcHkuYW5kLmlkZW50aXR5ICtcbiAgICAgICAgICAgICAgJyAobm8gaW50ZXJsZWF2ZWQgY2FsbHMpJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPVxuICAgICAgICAgICAgICAnRXhwZWN0ZWQgc3B5ICcgK1xuICAgICAgICAgICAgICBmaXJzdFNweS5hbmQuaWRlbnRpdHkgK1xuICAgICAgICAgICAgICAnIHRvIGhhdmUgYmVlbiBjYWxsZWQgYmVmb3JlIHNweSAnICtcbiAgICAgICAgICAgICAgbGF0dGVyU3B5LmFuZC5pZGVudGl0eTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9IYXZlQmVlbkNhbGxlZEJlZm9yZTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9IYXZlQmVlbkNhbGxlZE9uY2VXaXRoID0gZnVuY3Rpb24oaiQpIHtcbiAgdmFyIGdldEVycm9yTXNnID0gaiQuZm9ybWF0RXJyb3JNc2coXG4gICAgJzx0b0hhdmVCZWVuQ2FsbGVkT25jZVdpdGg+JyxcbiAgICAnZXhwZWN0KDxzcHlPYmo+KS50b0hhdmVCZWVuQ2FsbGVkT25jZVdpdGgoLi4uYXJndW1lbnRzKSdcbiAgKTtcblxuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCAoYSB7QGxpbmsgU3B5fSkgdG8gaGF2ZSBiZWVuIGNhbGxlZCBleGFjdGx5IG9uY2UsIGFuZCBleGFjdGx5IHdpdGggdGhlIHBhcnRpY3VsYXIgYXJndW1lbnRzLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9IYXZlQmVlbkNhbGxlZE9uY2VXaXRoXG4gICAqIEBzaW5jZSAzLjYuMFxuICAgKiBAcGFyYW0gey4uLk9iamVjdH0gLSBUaGUgYXJndW1lbnRzIHRvIGxvb2sgZm9yXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdChteVNweSkudG9IYXZlQmVlbkNhbGxlZE9uY2VXaXRoKCdmb28nLCAnYmFyJywgMik7XG4gICAqL1xuICBmdW5jdGlvbiB0b0hhdmVCZWVuQ2FsbGVkT25jZVdpdGgodXRpbCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApLFxuICAgICAgICAgIGFjdHVhbCA9IGFyZ3NbMF0sXG4gICAgICAgICAgZXhwZWN0ZWRBcmdzID0gYXJncy5zbGljZSgxKTtcblxuICAgICAgICBpZiAoIWokLmlzU3B5KGFjdHVhbCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBnZXRFcnJvck1zZygnRXhwZWN0ZWQgYSBzcHksIGJ1dCBnb3QgJyArIHV0aWwucHAoYWN0dWFsKSArICcuJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByZXR0eVByaW50ZWRDYWxscyA9IGFjdHVhbC5jYWxsc1xuICAgICAgICAgIC5hbGxBcmdzKClcbiAgICAgICAgICAubWFwKGZ1bmN0aW9uKGFyZ3NGb3JDYWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIHV0aWwucHAoYXJnc0ZvckNhbGwpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBhY3R1YWwuY2FsbHMuY291bnQoKSA9PT0gMSAmJlxuICAgICAgICAgIHV0aWwuY29udGFpbnMoYWN0dWFsLmNhbGxzLmFsbEFyZ3MoKSwgZXhwZWN0ZWRBcmdzKVxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGFzczogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAgICdFeHBlY3RlZCBzcHkgJyArXG4gICAgICAgICAgICAgIGFjdHVhbC5hbmQuaWRlbnRpdHkgK1xuICAgICAgICAgICAgICAnIHRvIGhhdmUgYmVlbiBjYWxsZWQgMCB0aW1lcywgbXVsdGlwbGUgdGltZXMsIG9yIG9uY2UsIGJ1dCB3aXRoIGFyZ3VtZW50cyBkaWZmZXJlbnQgZnJvbTpcXG4nICtcbiAgICAgICAgICAgICAgJyAgJyArXG4gICAgICAgICAgICAgIHV0aWwucHAoZXhwZWN0ZWRBcmdzKSArXG4gICAgICAgICAgICAgICdcXG4nICtcbiAgICAgICAgICAgICAgJ0J1dCB0aGUgYWN0dWFsIGNhbGwgd2FzOlxcbicgK1xuICAgICAgICAgICAgICBwcmV0dHlQcmludGVkQ2FsbHMuam9pbignLFxcbicpICtcbiAgICAgICAgICAgICAgJy5cXG5cXG4nXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldERpZmZzKCkge1xuICAgICAgICAgIHJldHVybiBhY3R1YWwuY2FsbHMuYWxsQXJncygpLm1hcChmdW5jdGlvbihhcmdzRm9yQ2FsbCwgY2FsbEl4KSB7XG4gICAgICAgICAgICB2YXIgZGlmZkJ1aWxkZXIgPSBuZXcgaiQuRGlmZkJ1aWxkZXIoKTtcbiAgICAgICAgICAgIHV0aWwuZXF1YWxzKGFyZ3NGb3JDYWxsLCBleHBlY3RlZEFyZ3MsIGRpZmZCdWlsZGVyKTtcbiAgICAgICAgICAgIHJldHVybiBkaWZmQnVpbGRlci5nZXRNZXNzYWdlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBidXRTdHJpbmcoKSB7XG4gICAgICAgICAgc3dpdGNoIChhY3R1YWwuY2FsbHMuY291bnQoKSkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICByZXR1cm4gJ0J1dCBpdCB3YXMgbmV2ZXIgY2FsbGVkLlxcblxcbic7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgJ0J1dCB0aGUgYWN0dWFsIGNhbGwgd2FzOlxcbicgK1xuICAgICAgICAgICAgICAgIHByZXR0eVByaW50ZWRDYWxscy5qb2luKCcsXFxuJykgK1xuICAgICAgICAgICAgICAgICcuXFxuJyArXG4gICAgICAgICAgICAgICAgZ2V0RGlmZnMoKS5qb2luKCdcXG4nKSArXG4gICAgICAgICAgICAgICAgJ1xcblxcbidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgJ0J1dCB0aGUgYWN0dWFsIGNhbGxzIHdlcmU6XFxuJyArXG4gICAgICAgICAgICAgICAgcHJldHR5UHJpbnRlZENhbGxzLmpvaW4oJyxcXG4nKSArXG4gICAgICAgICAgICAgICAgJy5cXG5cXG4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXNzOiBmYWxzZSxcbiAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgJ0V4cGVjdGVkIHNweSAnICtcbiAgICAgICAgICAgIGFjdHVhbC5hbmQuaWRlbnRpdHkgK1xuICAgICAgICAgICAgJyB0byBoYXZlIGJlZW4gY2FsbGVkIG9ubHkgb25jZSwgYW5kIHdpdGggZ2l2ZW4gYXJnczpcXG4nICtcbiAgICAgICAgICAgICcgICcgK1xuICAgICAgICAgICAgdXRpbC5wcChleHBlY3RlZEFyZ3MpICtcbiAgICAgICAgICAgICdcXG4nICtcbiAgICAgICAgICAgIGJ1dFN0cmluZygpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0hhdmVCZWVuQ2FsbGVkT25jZVdpdGg7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcyA9IGZ1bmN0aW9uKGokKSB7XG4gIHZhciBnZXRFcnJvck1zZyA9IGokLmZvcm1hdEVycm9yTXNnKFxuICAgICc8dG9IYXZlQmVlbkNhbGxlZFRpbWVzPicsXG4gICAgJ2V4cGVjdCg8c3B5T2JqPikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDxOdW1iZXI+KSdcbiAgKTtcblxuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCAoYSB7QGxpbmsgU3B5fSkgdG8gaGF2ZSBiZWVuIGNhbGxlZCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiB0aW1lcy5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvSGF2ZUJlZW5DYWxsZWRUaW1lc1xuICAgKiBAc2luY2UgMi40LjBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV4cGVjdGVkIC0gVGhlIG51bWJlciBvZiBpbnZvY2F0aW9ucyB0byBsb29rIGZvci5cbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KG15U3B5KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMyk7XG4gICAqL1xuICBmdW5jdGlvbiB0b0hhdmVCZWVuQ2FsbGVkVGltZXMobWF0Y2hlcnNVdGlsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgICAgICAgaWYgKCFqJC5pc1NweShhY3R1YWwpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgZ2V0RXJyb3JNc2coXG4gICAgICAgICAgICAgICdFeHBlY3RlZCBhIHNweSwgYnV0IGdvdCAnICsgbWF0Y2hlcnNVdGlsLnBwKGFjdHVhbCkgKyAnLidcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApLFxuICAgICAgICAgIHJlc3VsdCA9IHsgcGFzczogZmFsc2UgfTtcblxuICAgICAgICBpZiAoIWokLmlzTnVtYmVyXyhleHBlY3RlZCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBnZXRFcnJvck1zZyhcbiAgICAgICAgICAgICAgJ1RoZSBleHBlY3RlZCB0aW1lcyBmYWlsZWQgaXMgYSByZXF1aXJlZCBhcmd1bWVudCBhbmQgbXVzdCBiZSBhIG51bWJlci4nXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFjdHVhbCA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBjYWxscyA9IGFjdHVhbC5jYWxscy5jb3VudCgpO1xuICAgICAgICB2YXIgdGltZXNNZXNzYWdlID0gZXhwZWN0ZWQgPT09IDEgPyAnb25jZScgOiBleHBlY3RlZCArICcgdGltZXMnO1xuICAgICAgICByZXN1bHQucGFzcyA9IGNhbGxzID09PSBleHBlY3RlZDtcbiAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSByZXN1bHQucGFzc1xuICAgICAgICAgID8gJ0V4cGVjdGVkIHNweSAnICtcbiAgICAgICAgICAgIGFjdHVhbC5hbmQuaWRlbnRpdHkgK1xuICAgICAgICAgICAgJyBub3QgdG8gaGF2ZSBiZWVuIGNhbGxlZCAnICtcbiAgICAgICAgICAgIHRpbWVzTWVzc2FnZSArXG4gICAgICAgICAgICAnLiBJdCB3YXMgY2FsbGVkICcgK1xuICAgICAgICAgICAgY2FsbHMgK1xuICAgICAgICAgICAgJyB0aW1lcy4nXG4gICAgICAgICAgOiAnRXhwZWN0ZWQgc3B5ICcgK1xuICAgICAgICAgICAgYWN0dWFsLmFuZC5pZGVudGl0eSArXG4gICAgICAgICAgICAnIHRvIGhhdmUgYmVlbiBjYWxsZWQgJyArXG4gICAgICAgICAgICB0aW1lc01lc3NhZ2UgK1xuICAgICAgICAgICAgJy4gSXQgd2FzIGNhbGxlZCAnICtcbiAgICAgICAgICAgIGNhbGxzICtcbiAgICAgICAgICAgICcgdGltZXMuJztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvSGF2ZUJlZW5DYWxsZWRUaW1lcztcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9IYXZlQmVlbkNhbGxlZFdpdGggPSBmdW5jdGlvbihqJCkge1xuICB2YXIgZ2V0RXJyb3JNc2cgPSBqJC5mb3JtYXRFcnJvck1zZyhcbiAgICAnPHRvSGF2ZUJlZW5DYWxsZWRXaXRoPicsXG4gICAgJ2V4cGVjdCg8c3B5T2JqPikudG9IYXZlQmVlbkNhbGxlZFdpdGgoLi4uYXJndW1lbnRzKSdcbiAgKTtcblxuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCAoYSB7QGxpbmsgU3B5fSkgdG8gaGF2ZSBiZWVuIGNhbGxlZCB3aXRoIHBhcnRpY3VsYXIgYXJndW1lbnRzIGF0IGxlYXN0IG9uY2UuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0hhdmVCZWVuQ2FsbGVkV2l0aFxuICAgKiBAc2luY2UgMS4zLjBcbiAgICogQHBhcmFtIHsuLi5PYmplY3R9IC0gVGhlIGFyZ3VtZW50cyB0byBsb29rIGZvclxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QobXlTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdmb28nLCAnYmFyJywgMik7XG4gICAqL1xuICBmdW5jdGlvbiB0b0hhdmVCZWVuQ2FsbGVkV2l0aChtYXRjaGVyc1V0aWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSxcbiAgICAgICAgICBhY3R1YWwgPSBhcmdzWzBdLFxuICAgICAgICAgIGV4cGVjdGVkQXJncyA9IGFyZ3Muc2xpY2UoMSksXG4gICAgICAgICAgcmVzdWx0ID0geyBwYXNzOiBmYWxzZSB9O1xuXG4gICAgICAgIGlmICghaiQuaXNTcHkoYWN0dWFsKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGdldEVycm9yTXNnKFxuICAgICAgICAgICAgICAnRXhwZWN0ZWQgYSBzcHksIGJ1dCBnb3QgJyArIG1hdGNoZXJzVXRpbC5wcChhY3R1YWwpICsgJy4nXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYWN0dWFsLmNhbGxzLmFueSgpKSB7XG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICdFeHBlY3RlZCBzcHkgJyArXG4gICAgICAgICAgICAgIGFjdHVhbC5hbmQuaWRlbnRpdHkgK1xuICAgICAgICAgICAgICAnIHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aDpcXG4nICtcbiAgICAgICAgICAgICAgJyAgJyArXG4gICAgICAgICAgICAgIG1hdGNoZXJzVXRpbC5wcChleHBlY3RlZEFyZ3MpICtcbiAgICAgICAgICAgICAgJ1xcbmJ1dCBpdCB3YXMgbmV2ZXIgY2FsbGVkLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoZXJzVXRpbC5jb250YWlucyhhY3R1YWwuY2FsbHMuYWxsQXJncygpLCBleHBlY3RlZEFyZ3MpKSB7XG4gICAgICAgICAgcmVzdWx0LnBhc3MgPSB0cnVlO1xuICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAnRXhwZWN0ZWQgc3B5ICcgK1xuICAgICAgICAgICAgICBhY3R1YWwuYW5kLmlkZW50aXR5ICtcbiAgICAgICAgICAgICAgJyBub3QgdG8gaGF2ZSBiZWVuIGNhbGxlZCB3aXRoOlxcbicgK1xuICAgICAgICAgICAgICAnICAnICtcbiAgICAgICAgICAgICAgbWF0Y2hlcnNVdGlsLnBwKGV4cGVjdGVkQXJncykgK1xuICAgICAgICAgICAgICAnXFxuYnV0IGl0IHdhcy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwcmV0dHlQcmludGVkQ2FsbHMgPSBhY3R1YWwuY2FsbHNcbiAgICAgICAgICAgICAgLmFsbEFyZ3MoKVxuICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGFyZ3NGb3JDYWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcgICcgKyBtYXRjaGVyc1V0aWwucHAoYXJnc0ZvckNhbGwpO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGRpZmZzID0gYWN0dWFsLmNhbGxzXG4gICAgICAgICAgICAgIC5hbGxBcmdzKClcbiAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihhcmdzRm9yQ2FsbCwgY2FsbEl4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpZmZCdWlsZGVyID0gbmV3IGokLkRpZmZCdWlsZGVyKCk7XG4gICAgICAgICAgICAgICAgbWF0Y2hlcnNVdGlsLmVxdWFscyhhcmdzRm9yQ2FsbCwgZXhwZWN0ZWRBcmdzLCBkaWZmQnVpbGRlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICdDYWxsICcgK1xuICAgICAgICAgICAgICAgICAgY2FsbEl4ICtcbiAgICAgICAgICAgICAgICAgICc6XFxuJyArXG4gICAgICAgICAgICAgICAgICBkaWZmQnVpbGRlci5nZXRNZXNzYWdlKCkucmVwbGFjZSgvXi9nbSwgJyAgJylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgJ0V4cGVjdGVkIHNweSAnICtcbiAgICAgICAgICAgICAgYWN0dWFsLmFuZC5pZGVudGl0eSArXG4gICAgICAgICAgICAgICcgdG8gaGF2ZSBiZWVuIGNhbGxlZCB3aXRoOlxcbicgK1xuICAgICAgICAgICAgICAnICAnICtcbiAgICAgICAgICAgICAgbWF0Y2hlcnNVdGlsLnBwKGV4cGVjdGVkQXJncykgK1xuICAgICAgICAgICAgICAnXFxuJyArXG4gICAgICAgICAgICAgICcnICtcbiAgICAgICAgICAgICAgJ2J1dCBhY3R1YWwgY2FsbHMgd2VyZTpcXG4nICtcbiAgICAgICAgICAgICAgcHJldHR5UHJpbnRlZENhbGxzLmpvaW4oJyxcXG4nKSArXG4gICAgICAgICAgICAgICcuXFxuXFxuJyArXG4gICAgICAgICAgICAgIGRpZmZzLmpvaW4oJ1xcbicpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9IYXZlQmVlbkNhbGxlZFdpdGg7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvSGF2ZUNsYXNzID0gZnVuY3Rpb24oaiQpIHtcbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgdmFsdWUgdG8gYmUgYSBET00gZWxlbWVudCB0aGF0IGhhcyB0aGUgZXhwZWN0ZWQgY2xhc3NcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvSGF2ZUNsYXNzXG4gICAqIEBzaW5jZSAzLjAuMFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXhwZWN0ZWQgLSBUaGUgY2xhc3MgbmFtZSB0byB0ZXN0IGZvclxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICogZWwuY2xhc3NOYW1lID0gJ2ZvbyBiYXIgYmF6JztcbiAgICogZXhwZWN0KGVsKS50b0hhdmVDbGFzcygnYmFyJyk7XG4gICAqL1xuICBmdW5jdGlvbiB0b0hhdmVDbGFzcyhtYXRjaGVyc1V0aWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICAgICAgICBpZiAoIWlzRWxlbWVudChhY3R1YWwpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1hdGNoZXJzVXRpbC5wcChhY3R1YWwpICsgJyBpcyBub3QgYSBET00gZWxlbWVudCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXNzOiBhY3R1YWwuY2xhc3NMaXN0LmNvbnRhaW5zKGV4cGVjdGVkKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpc0VsZW1lbnQobWF5YmVFbCkge1xuICAgIHJldHVybiAoXG4gICAgICBtYXliZUVsICYmIG1heWJlRWwuY2xhc3NMaXN0ICYmIGokLmlzRnVuY3Rpb25fKG1heWJlRWwuY2xhc3NMaXN0LmNvbnRhaW5zKVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gdG9IYXZlQ2xhc3M7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvSGF2ZVNpemUgPSBmdW5jdGlvbihqJCkge1xuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCBzaXplIHRvIGJlIGVxdWFsIHRvIHRoZSBleHBlY3RlZCwgdXNpbmcgYXJyYXktbGlrZSBsZW5ndGggb3Igb2JqZWN0IGtleXMgc2l6ZS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvSGF2ZVNpemVcbiAgICogQHNpbmNlIDMuNi4wXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHBlY3RlZCAtIEV4cGVjdGVkIHNpemVcbiAgICogQGV4YW1wbGVcbiAgICogYXJyYXkgPSBbMSwyXTtcbiAgICogZXhwZWN0KGFycmF5KS50b0hhdmVTaXplKDIpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9IYXZlU2l6ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgIHBhc3M6IGZhbHNlXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIGokLmlzQV8oJ1dlYWtTZXQnLCBhY3R1YWwpIHx8XG4gICAgICAgICAgaiQuaXNXZWFrTWFwKGFjdHVhbCkgfHxcbiAgICAgICAgICBqJC5pc0RhdGFWaWV3KGFjdHVhbClcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZ2V0IHNpemUgb2YgJyArIGFjdHVhbCArICcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaiQuaXNTZXQoYWN0dWFsKSB8fCBqJC5pc01hcChhY3R1YWwpKSB7XG4gICAgICAgICAgcmVzdWx0LnBhc3MgPSBhY3R1YWwuc2l6ZSA9PT0gZXhwZWN0ZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNMZW5ndGgoYWN0dWFsLmxlbmd0aCkpIHtcbiAgICAgICAgICByZXN1bHQucGFzcyA9IGFjdHVhbC5sZW5ndGggPT09IGV4cGVjdGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wYXNzID0gT2JqZWN0LmtleXMoYWN0dWFsKS5sZW5ndGggPT09IGV4cGVjdGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIE1BWF9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCA5MDA3MTk5MjU0NzQwOTkxO1xuICBmdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICAgIHJldHVybiAoXG4gICAgICB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICAgIHZhbHVlID4gLTEgJiZcbiAgICAgIHZhbHVlICUgMSA9PT0gMCAmJlxuICAgICAgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUlxuICAgICk7XG4gIH1cblxuICByZXR1cm4gdG9IYXZlU2l6ZTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9NYXRjaCA9IGZ1bmN0aW9uKGokKSB7XG4gIHZhciBnZXRFcnJvck1zZyA9IGokLmZvcm1hdEVycm9yTXNnKFxuICAgICc8dG9NYXRjaD4nLFxuICAgICdleHBlY3QoPGV4cGVjdGF0aW9uPikudG9NYXRjaCg8c3RyaW5nPiB8fCA8cmVnZXhwPiknXG4gICk7XG5cbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgdmFsdWUgdG8gbWF0Y2ggYSByZWd1bGFyIGV4cHJlc3Npb25cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvTWF0Y2hcbiAgICogQHNpbmNlIDEuMy4wXG4gICAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gZXhwZWN0ZWQgLSBWYWx1ZSB0byBsb29rIGZvciBpbiB0aGUgc3RyaW5nLlxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QoXCJteSBzdHJpbmdcIikudG9NYXRjaCgvc3RyaW5nJC8pO1xuICAgKiBleHBlY3QoXCJvdGhlciBzdHJpbmdcIikudG9NYXRjaChcImhlclwiKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvTWF0Y2goKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgICAgICAgaWYgKCFqJC5pc1N0cmluZ18oZXhwZWN0ZWQpICYmICFqJC5pc0FfKCdSZWdFeHAnLCBleHBlY3RlZCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0RXJyb3JNc2coJ0V4cGVjdGVkIGlzIG5vdCBhIFN0cmluZyBvciBhIFJlZ0V4cCcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKGV4cGVjdGVkKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhc3M6IHJlZ2V4cC50ZXN0KGFjdHVhbClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvTWF0Y2g7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvVGhyb3cgPSBmdW5jdGlvbihqJCkge1xuICB2YXIgZ2V0RXJyb3JNc2cgPSBqJC5mb3JtYXRFcnJvck1zZyhcbiAgICAnPHRvVGhyb3c+JyxcbiAgICAnZXhwZWN0KGZ1bmN0aW9uKCkgezxleHBlY3RhdGlvbj59KS50b1Rocm93KCknXG4gICk7XG5cbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IGEgZnVuY3Rpb24gdG8gYHRocm93YCBzb21ldGhpbmcuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b1Rocm93XG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2V4cGVjdGVkXSAtIFZhbHVlIHRoYXQgc2hvdWxkIGJlIHRocm93bi4gSWYgbm90IHByb3ZpZGVkLCBzaW1wbHkgdGhlIGZhY3QgdGhhdCBzb21ldGhpbmcgd2FzIHRocm93biB3aWxsIGJlIGNoZWNrZWQuXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdChmdW5jdGlvbigpIHsgcmV0dXJuICd0aGluZ3MnOyB9KS50b1Rocm93KCdmb28nKTtcbiAgICogZXhwZWN0KGZ1bmN0aW9uKCkgeyByZXR1cm4gJ3N0dWZmJzsgfSkudG9UaHJvdygpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9UaHJvdyhtYXRjaGVyc1V0aWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0geyBwYXNzOiBmYWxzZSB9LFxuICAgICAgICAgIHRocmV3ID0gZmFsc2UsXG4gICAgICAgICAgdGhyb3duO1xuXG4gICAgICAgIGlmICh0eXBlb2YgYWN0dWFsICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0RXJyb3JNc2coJ0FjdHVhbCBpcyBub3QgYSBGdW5jdGlvbicpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYWN0dWFsKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJldyA9IHRydWU7XG4gICAgICAgICAgdGhyb3duID0gZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhyZXcpIHtcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9ICdFeHBlY3RlZCBmdW5jdGlvbiB0byB0aHJvdyBhbiBleGNlcHRpb24uJztcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIHJlc3VsdC5wYXNzID0gdHJ1ZTtcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgJ0V4cGVjdGVkIGZ1bmN0aW9uIG5vdCB0byB0aHJvdywgYnV0IGl0IHRocmV3ICcgK1xuICAgICAgICAgICAgICBtYXRjaGVyc1V0aWwucHAodGhyb3duKSArXG4gICAgICAgICAgICAgICcuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaGVyc1V0aWwuZXF1YWxzKHRocm93biwgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgcmVzdWx0LnBhc3MgPSB0cnVlO1xuICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAnRXhwZWN0ZWQgZnVuY3Rpb24gbm90IHRvIHRocm93ICcgK1xuICAgICAgICAgICAgICBtYXRjaGVyc1V0aWwucHAoZXhwZWN0ZWQpICtcbiAgICAgICAgICAgICAgJy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICdFeHBlY3RlZCBmdW5jdGlvbiB0byB0aHJvdyAnICtcbiAgICAgICAgICAgICAgbWF0Y2hlcnNVdGlsLnBwKGV4cGVjdGVkKSArXG4gICAgICAgICAgICAgICcsIGJ1dCBpdCB0aHJldyAnICtcbiAgICAgICAgICAgICAgbWF0Y2hlcnNVdGlsLnBwKHRocm93bikgK1xuICAgICAgICAgICAgICAnLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b1Rocm93O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b1Rocm93RXJyb3IgPSBmdW5jdGlvbihqJCkge1xuICB2YXIgZ2V0RXJyb3JNc2cgPSBqJC5mb3JtYXRFcnJvck1zZyhcbiAgICAnPHRvVGhyb3dFcnJvcj4nLFxuICAgICdleHBlY3QoZnVuY3Rpb24oKSB7PGV4cGVjdGF0aW9uPn0pLnRvVGhyb3dFcnJvcig8RXJyb3JDb25zdHJ1Y3Rvcj4sIDxtZXNzYWdlPiknXG4gICk7XG5cbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IGEgZnVuY3Rpb24gdG8gYHRocm93YCBhbiBgRXJyb3JgLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9UaHJvd0Vycm9yXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKiBAcGFyYW0ge0Vycm9yfSBbZXhwZWN0ZWRdIC0gYEVycm9yYCBjb25zdHJ1Y3RvciB0aGUgb2JqZWN0IHRoYXQgd2FzIHRocm93biBuZWVkcyB0byBiZSBhbiBpbnN0YW5jZSBvZi4gSWYgbm90IHByb3ZpZGVkLCBgRXJyb3JgIHdpbGwgYmUgdXNlZC5cbiAgICogQHBhcmFtIHtSZWdFeHB8U3RyaW5nfSBbbWVzc2FnZV0gLSBUaGUgbWVzc2FnZSB0aGF0IHNob3VsZCBiZSBzZXQgb24gdGhlIHRocm93biBgRXJyb3JgXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdChmdW5jdGlvbigpIHsgcmV0dXJuICd0aGluZ3MnOyB9KS50b1Rocm93RXJyb3IoTXlDdXN0b21FcnJvciwgJ21lc3NhZ2UnKTtcbiAgICogZXhwZWN0KGZ1bmN0aW9uKCkgeyByZXR1cm4gJ3RoaW5ncyc7IH0pLnRvVGhyb3dFcnJvcihNeUN1c3RvbUVycm9yLCAvYmFyLyk7XG4gICAqIGV4cGVjdChmdW5jdGlvbigpIHsgcmV0dXJuICdzdHVmZic7IH0pLnRvVGhyb3dFcnJvcihNeUN1c3RvbUVycm9yKTtcbiAgICogZXhwZWN0KGZ1bmN0aW9uKCkgeyByZXR1cm4gJ290aGVyJzsgfSkudG9UaHJvd0Vycm9yKC9mb28vKTtcbiAgICogZXhwZWN0KGZ1bmN0aW9uKCkgeyByZXR1cm4gJ290aGVyJzsgfSkudG9UaHJvd0Vycm9yKCk7XG4gICAqL1xuICBmdW5jdGlvbiB0b1Rocm93RXJyb3IobWF0Y2hlcnNVdGlsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCkge1xuICAgICAgICB2YXIgZXJyb3JNYXRjaGVyID0gZ2V0TWF0Y2hlci5hcHBseShudWxsLCBhcmd1bWVudHMpLFxuICAgICAgICAgIHRocm93bjtcblxuICAgICAgICBpZiAodHlwZW9mIGFjdHVhbCAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGdldEVycm9yTXNnKCdBY3R1YWwgaXMgbm90IGEgRnVuY3Rpb24nKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGFjdHVhbCgpO1xuICAgICAgICAgIHJldHVybiBmYWlsKCdFeHBlY3RlZCBmdW5jdGlvbiB0byB0aHJvdyBhbiBFcnJvci4nKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93biA9IGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWokLmlzRXJyb3JfKHRocm93bikpIHtcbiAgICAgICAgICByZXR1cm4gZmFpbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICdFeHBlY3RlZCBmdW5jdGlvbiB0byB0aHJvdyBhbiBFcnJvciwgYnV0IGl0IHRocmV3ICcgK1xuICAgICAgICAgICAgICBtYXRjaGVyc1V0aWwucHAodGhyb3duKSArXG4gICAgICAgICAgICAgICcuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlcnJvck1hdGNoZXIubWF0Y2godGhyb3duKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0TWF0Y2hlcigpIHtcbiAgICAgIHZhciBleHBlY3RlZCwgZXJyb3JUeXBlO1xuXG4gICAgICBpZiAoYXJndW1lbnRzWzJdKSB7XG4gICAgICAgIGVycm9yVHlwZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgZXhwZWN0ZWQgPSBhcmd1bWVudHNbMl07XG4gICAgICAgIGlmICghaXNBbkVycm9yVHlwZShlcnJvclR5cGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGdldEVycm9yTXNnKCdFeHBlY3RlZCBlcnJvciB0eXBlIGlzIG5vdCBhbiBFcnJvci4nKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhhY3RNYXRjaGVyKGV4cGVjdGVkLCBlcnJvclR5cGUpO1xuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMV0pIHtcbiAgICAgICAgZXhwZWN0ZWQgPSBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgaWYgKGlzQW5FcnJvclR5cGUoYXJndW1lbnRzWzFdKSkge1xuICAgICAgICAgIHJldHVybiBleGFjdE1hdGNoZXIobnVsbCwgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZXhhY3RNYXRjaGVyKGFyZ3VtZW50c1sxXSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhbnlNYXRjaGVyKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYW55TWF0Y2hlcigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hdGNoOiBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIHJldHVybiBwYXNzKFxuICAgICAgICAgICAgJ0V4cGVjdGVkIGZ1bmN0aW9uIG5vdCB0byB0aHJvdyBhbiBFcnJvciwgYnV0IGl0IHRocmV3ICcgK1xuICAgICAgICAgICAgICBqJC5mbk5hbWVGb3IoZXJyb3IpICtcbiAgICAgICAgICAgICAgJy4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleGFjdE1hdGNoZXIoZXhwZWN0ZWQsIGVycm9yVHlwZSkge1xuICAgICAgaWYgKGV4cGVjdGVkICYmICFpc1N0cmluZ09yUmVnRXhwKGV4cGVjdGVkKSkge1xuICAgICAgICBpZiAoZXJyb3JUeXBlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgZ2V0RXJyb3JNc2coJ0V4cGVjdGVkIGVycm9yIG1lc3NhZ2UgaXMgbm90IGEgc3RyaW5nIG9yIFJlZ0V4cC4nKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgZ2V0RXJyb3JNc2coJ0V4cGVjdGVkIGlzIG5vdCBhbiBFcnJvciwgc3RyaW5nLCBvciBSZWdFeHAuJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1lc3NhZ2VNYXRjaChtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQgPT0gbWVzc2FnZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQudGVzdChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZXJyb3JUeXBlRGVzY3JpcHRpb24gPSBlcnJvclR5cGVcbiAgICAgICAgPyBqJC5mbk5hbWVGb3IoZXJyb3JUeXBlKVxuICAgICAgICA6ICdhbiBleGNlcHRpb24nO1xuXG4gICAgICBmdW5jdGlvbiB0aHJvd25EZXNjcmlwdGlvbih0aHJvd24pIHtcbiAgICAgICAgdmFyIHRocm93bk5hbWUgPSBlcnJvclR5cGVcbiAgICAgICAgICAgID8gaiQuZm5OYW1lRm9yKHRocm93bi5jb25zdHJ1Y3RvcilcbiAgICAgICAgICAgIDogJ2FuIGV4Y2VwdGlvbicsXG4gICAgICAgICAgdGhyb3duTWVzc2FnZSA9ICcnO1xuXG4gICAgICAgIGlmIChleHBlY3RlZCkge1xuICAgICAgICAgIHRocm93bk1lc3NhZ2UgPSAnIHdpdGggbWVzc2FnZSAnICsgbWF0Y2hlcnNVdGlsLnBwKHRocm93bi5tZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aHJvd25OYW1lICsgdGhyb3duTWVzc2FnZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbWVzc2FnZURlc2NyaXB0aW9uKCkge1xuICAgICAgICBpZiAoZXhwZWN0ZWQgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICByZXR1cm4gJyB3aXRoIGEgbWVzc2FnZSBtYXRjaGluZyAnICsgbWF0Y2hlcnNVdGlsLnBwKGV4cGVjdGVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gJyB3aXRoIG1lc3NhZ2UgJyArIG1hdGNoZXJzVXRpbC5wcChleHBlY3RlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbWF0Y2hlcyhlcnJvcikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIChlcnJvclR5cGUgPT09IG51bGwgfHwgZXJyb3IgaW5zdGFuY2VvZiBlcnJvclR5cGUpICYmXG4gICAgICAgICAgKGV4cGVjdGVkID09PSBudWxsIHx8IG1lc3NhZ2VNYXRjaChlcnJvci5tZXNzYWdlKSlcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uKHRocm93bikge1xuICAgICAgICAgIGlmIChtYXRjaGVzKHRocm93bikpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXNzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICdFeHBlY3RlZCBmdW5jdGlvbiBub3QgdG8gdGhyb3cgJyArXG4gICAgICAgICAgICAgICAgZXJyb3JUeXBlRGVzY3JpcHRpb24gK1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VEZXNjcmlwdGlvbigpICtcbiAgICAgICAgICAgICAgICAnLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFpbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAnRXhwZWN0ZWQgZnVuY3Rpb24gdG8gdGhyb3cgJyArXG4gICAgICAgICAgICAgICAgZXJyb3JUeXBlRGVzY3JpcHRpb24gK1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VEZXNjcmlwdGlvbigpICtcbiAgICAgICAgICAgICAgICAnLCBidXQgaXQgdGhyZXcgJyArXG4gICAgICAgICAgICAgICAgdGhyb3duRGVzY3JpcHRpb24odGhyb3duKSArXG4gICAgICAgICAgICAgICAgJy4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTdHJpbmdPclJlZ0V4cChwb3RlbnRpYWwpIHtcbiAgICAgIHJldHVybiBwb3RlbnRpYWwgaW5zdGFuY2VvZiBSZWdFeHAgfHwgdHlwZW9mIHBvdGVudGlhbCA9PSAnc3RyaW5nJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FuRXJyb3JUeXBlKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBTdXJyb2dhdGUgPSBmdW5jdGlvbigpIHt9O1xuICAgICAgU3Vycm9nYXRlLnByb3RvdHlwZSA9IHR5cGUucHJvdG90eXBlO1xuICAgICAgcmV0dXJuIGokLmlzRXJyb3JfKG5ldyBTdXJyb2dhdGUoKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFzcyhtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhc3M6IHRydWUsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZhaWwobWVzc2FnZSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXNzOiBmYWxzZSxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvVGhyb3dFcnJvcjtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9UaHJvd01hdGNoaW5nID0gZnVuY3Rpb24oaiQpIHtcbiAgdmFyIHVzYWdlRXJyb3IgPSBqJC5mb3JtYXRFcnJvck1zZyhcbiAgICAnPHRvVGhyb3dNYXRjaGluZz4nLFxuICAgICdleHBlY3QoZnVuY3Rpb24oKSB7PGV4cGVjdGF0aW9uPn0pLnRvVGhyb3dNYXRjaGluZyg8UHJlZGljYXRlPiknXG4gICk7XG5cbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IGEgZnVuY3Rpb24gdG8gYHRocm93YCBzb21ldGhpbmcgbWF0Y2hpbmcgYSBwcmVkaWNhdGUuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b1Rocm93TWF0Y2hpbmdcbiAgICogQHNpbmNlIDMuMC4wXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSAtIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyB0aGUgdGhyb3duIGV4Y2VwdGlvbiBhcyBpdHMgcGFyYW1ldGVyIGFuZCByZXR1cm5zIHRydWUgaWYgaXQgbWF0Y2hlcy5cbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRXJyb3IoJ25vcGUnKTsgfSkudG9UaHJvd01hdGNoaW5nKGZ1bmN0aW9uKHRocm93bikgeyByZXR1cm4gdGhyb3duLm1lc3NhZ2UgPT09ICdub3BlJzsgfSk7XG4gICAqL1xuICBmdW5jdGlvbiB0b1Rocm93TWF0Y2hpbmcobWF0Y2hlcnNVdGlsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCwgcHJlZGljYXRlKSB7XG4gICAgICAgIHZhciB0aHJvd247XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhY3R1YWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXNhZ2VFcnJvcignQWN0dWFsIGlzIG5vdCBhIEZ1bmN0aW9uJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXNhZ2VFcnJvcignUHJlZGljYXRlIGlzIG5vdCBhIEZ1bmN0aW9uJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhY3R1YWwoKTtcbiAgICAgICAgICByZXR1cm4gZmFpbCgnRXhwZWN0ZWQgZnVuY3Rpb24gdG8gdGhyb3cgYW4gZXhjZXB0aW9uLicpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3duID0gZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmVkaWNhdGUodGhyb3duKSkge1xuICAgICAgICAgIHJldHVybiBwYXNzKFxuICAgICAgICAgICAgJ0V4cGVjdGVkIGZ1bmN0aW9uIG5vdCB0byB0aHJvdyBhbiBleGNlcHRpb24gbWF0Y2hpbmcgYSBwcmVkaWNhdGUuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhaWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAnRXhwZWN0ZWQgZnVuY3Rpb24gdG8gdGhyb3cgYW4gZXhjZXB0aW9uIG1hdGNoaW5nIGEgcHJlZGljYXRlLCAnICtcbiAgICAgICAgICAgICAgJ2J1dCBpdCB0aHJldyAnICtcbiAgICAgICAgICAgICAgdGhyb3duRGVzY3JpcHRpb24odGhyb3duKSArXG4gICAgICAgICAgICAgICcuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0aHJvd25EZXNjcmlwdGlvbih0aHJvd24pIHtcbiAgICAgIGlmICh0aHJvd24gJiYgdGhyb3duLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgaiQuZm5OYW1lRm9yKHRocm93bi5jb25zdHJ1Y3RvcikgK1xuICAgICAgICAgICcgd2l0aCBtZXNzYWdlICcgK1xuICAgICAgICAgIG1hdGNoZXJzVXRpbC5wcCh0aHJvd24ubWVzc2FnZSlcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVyc1V0aWwucHAodGhyb3duKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXNzKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGFzczogdHJ1ZSxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZmFpbChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhc3M6IGZhbHNlLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9UaHJvd01hdGNoaW5nO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5Nb2NrRGF0ZSA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIE1vY2tEYXRlKGdsb2JhbCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY3VycmVudFRpbWUgPSAwO1xuXG4gICAgaWYgKCFnbG9iYWwgfHwgIWdsb2JhbC5EYXRlKSB7XG4gICAgICBzZWxmLmluc3RhbGwgPSBmdW5jdGlvbigpIHt9O1xuICAgICAgc2VsZi50aWNrID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgIHNlbGYudW5pbnN0YWxsID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIHZhciBHbG9iYWxEYXRlID0gZ2xvYmFsLkRhdGU7XG5cbiAgICBzZWxmLmluc3RhbGwgPSBmdW5jdGlvbihtb2NrRGF0ZSkge1xuICAgICAgaWYgKG1vY2tEYXRlIGluc3RhbmNlb2YgR2xvYmFsRGF0ZSkge1xuICAgICAgICBjdXJyZW50VGltZSA9IG1vY2tEYXRlLmdldFRpbWUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaiQudXRpbC5pc1VuZGVmaW5lZChtb2NrRGF0ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnVGhlIGFyZ3VtZW50IHRvIGphc21pbmUuY2xvY2soKS5tb2NrRGF0ZSgpLCBpZiBzcGVjaWZpZWQsICcgK1xuICAgICAgICAgICAgICAnc2hvdWxkIGJlIGEgRGF0ZSBpbnN0YW5jZS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRUaW1lID0gbmV3IEdsb2JhbERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICB9XG5cbiAgICAgIGdsb2JhbC5EYXRlID0gRmFrZURhdGU7XG4gICAgfTtcblxuICAgIHNlbGYudGljayA9IGZ1bmN0aW9uKG1pbGxpcykge1xuICAgICAgbWlsbGlzID0gbWlsbGlzIHx8IDA7XG4gICAgICBjdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lICsgbWlsbGlzO1xuICAgIH07XG5cbiAgICBzZWxmLnVuaW5zdGFsbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgY3VycmVudFRpbWUgPSAwO1xuICAgICAgZ2xvYmFsLkRhdGUgPSBHbG9iYWxEYXRlO1xuICAgIH07XG5cbiAgICBjcmVhdGVEYXRlUHJvcGVydGllcygpO1xuXG4gICAgcmV0dXJuIHNlbGY7XG5cbiAgICBmdW5jdGlvbiBGYWtlRGF0ZSgpIHtcbiAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG5ldyBHbG9iYWxEYXRlKGN1cnJlbnRUaW1lKTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiBuZXcgR2xvYmFsRGF0ZShhcmd1bWVudHNbMF0pO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBHbG9iYWxEYXRlKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiBuZXcgR2xvYmFsRGF0ZShhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiBuZXcgR2xvYmFsRGF0ZShcbiAgICAgICAgICAgIGFyZ3VtZW50c1swXSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1syXSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1szXVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gbmV3IEdsb2JhbERhdGUoXG4gICAgICAgICAgICBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgICBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICBhcmd1bWVudHNbMl0sXG4gICAgICAgICAgICBhcmd1bWVudHNbM10sXG4gICAgICAgICAgICBhcmd1bWVudHNbNF1cbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgcmV0dXJuIG5ldyBHbG9iYWxEYXRlKFxuICAgICAgICAgICAgYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgYXJndW1lbnRzWzJdLFxuICAgICAgICAgICAgYXJndW1lbnRzWzNdLFxuICAgICAgICAgICAgYXJndW1lbnRzWzRdLFxuICAgICAgICAgICAgYXJndW1lbnRzWzVdXG4gICAgICAgICAgKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbmV3IEdsb2JhbERhdGUoXG4gICAgICAgICAgICBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgICBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICBhcmd1bWVudHNbMl0sXG4gICAgICAgICAgICBhcmd1bWVudHNbM10sXG4gICAgICAgICAgICBhcmd1bWVudHNbNF0sXG4gICAgICAgICAgICBhcmd1bWVudHNbNV0sXG4gICAgICAgICAgICBhcmd1bWVudHNbNl1cbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURhdGVQcm9wZXJ0aWVzKCkge1xuICAgICAgRmFrZURhdGUucHJvdG90eXBlID0gR2xvYmFsRGF0ZS5wcm90b3R5cGU7XG5cbiAgICAgIEZha2VEYXRlLm5vdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3VycmVudFRpbWU7XG4gICAgICB9O1xuXG4gICAgICBGYWtlRGF0ZS50b1NvdXJjZSA9IEdsb2JhbERhdGUudG9Tb3VyY2U7XG4gICAgICBGYWtlRGF0ZS50b1N0cmluZyA9IEdsb2JhbERhdGUudG9TdHJpbmc7XG4gICAgICBGYWtlRGF0ZS5wYXJzZSA9IEdsb2JhbERhdGUucGFyc2U7XG4gICAgICBGYWtlRGF0ZS5VVEMgPSBHbG9iYWxEYXRlLlVUQztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gTW9ja0RhdGU7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLk5ldmVyU2tpcFBvbGljeSA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIE5ldmVyU2tpcFBvbGljeShxdWV1ZWFibGVGbnMpIHt9XG5cbiAgTmV2ZXJTa2lwUG9saWN5LnByb3RvdHlwZS5za2lwVG8gPSBmdW5jdGlvbihsYXN0UmFuRm5JeCkge1xuICAgIHJldHVybiBsYXN0UmFuRm5JeCArIDE7XG4gIH07XG5cbiAgTmV2ZXJTa2lwUG9saWN5LnByb3RvdHlwZS5mbkVycm9yZWQgPSBmdW5jdGlvbihmbkl4KSB7fTtcblxuICByZXR1cm4gTmV2ZXJTa2lwUG9saWN5O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5tYWtlUHJldHR5UHJpbnRlciA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIFNpbmdsZVByZXR0eVByaW50UnVuKGN1c3RvbU9iamVjdEZvcm1hdHRlcnMsIHBwKSB7XG4gICAgdGhpcy5jdXN0b21PYmplY3RGb3JtYXR0ZXJzXyA9IGN1c3RvbU9iamVjdEZvcm1hdHRlcnM7XG4gICAgdGhpcy5wcE5lc3RMZXZlbF8gPSAwO1xuICAgIHRoaXMuc2VlbiA9IFtdO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnN0cmluZ1BhcnRzID0gW107XG4gICAgdGhpcy5wcF8gPSBwcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0N1c3RvbVRvU3RyaW5nKHZhbHVlKSB7XG4gICAgLy8gdmFsdWUudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgaWYgdmFsdWUgaGFzIG5vIGN1c3RvbSB0b1N0cmluZyBidXQgaXMgZnJvbSBhbm90aGVyIGNvbnRleHQgKGUuZy5cbiAgICAvLyBpZnJhbWUsIHdlYiB3b3JrZXIpXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGokLmlzRnVuY3Rpb25fKHZhbHVlLnRvU3RyaW5nKSAmJlxuICAgICAgICB2YWx1ZS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyAmJlxuICAgICAgICB2YWx1ZS50b1N0cmluZygpICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFRoZSBjdXN0b20gdG9TdHJpbmcoKSB0aHJldy5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIFNpbmdsZVByZXR0eVByaW50UnVuLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHRoaXMucHBOZXN0TGV2ZWxfKys7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBjdXN0b21Gb3JtYXRSZXN1bHQgPSB0aGlzLmFwcGx5Q3VzdG9tRm9ybWF0dGVyc18odmFsdWUpO1xuXG4gICAgICBpZiAoY3VzdG9tRm9ybWF0UmVzdWx0KSB7XG4gICAgICAgIHRoaXMuZW1pdFNjYWxhcihjdXN0b21Gb3JtYXRSZXN1bHQpO1xuICAgICAgfSBlbHNlIGlmIChqJC51dGlsLmlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICB0aGlzLmVtaXRTY2FsYXIoJ3VuZGVmaW5lZCcpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmVtaXRTY2FsYXIoJ251bGwnKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgdGhpcy5lbWl0U2NhbGFyKCctMCcpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gaiQuZ2V0R2xvYmFsKCkpIHtcbiAgICAgICAgdGhpcy5lbWl0U2NhbGFyKCc8Z2xvYmFsPicpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZS5qYXNtaW5lVG9TdHJpbmcpIHtcbiAgICAgICAgdGhpcy5lbWl0U2NhbGFyKHZhbHVlLmphc21pbmVUb1N0cmluZyh0aGlzLnBwXykpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuZW1pdFN0cmluZyh2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGokLmlzU3B5KHZhbHVlKSkge1xuICAgICAgICB0aGlzLmVtaXRTY2FsYXIoJ3NweSBvbiAnICsgdmFsdWUuYW5kLmlkZW50aXR5KTtcbiAgICAgIH0gZWxzZSBpZiAoaiQuaXNTcHkodmFsdWUudG9TdHJpbmcpKSB7XG4gICAgICAgIHRoaXMuZW1pdFNjYWxhcignc3B5IG9uICcgKyB2YWx1ZS50b1N0cmluZy5hbmQuaWRlbnRpdHkpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICB0aGlzLmVtaXRTY2FsYXIodmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmVtaXRTY2FsYXIoJ0Z1bmN0aW9uJyk7XG4gICAgICB9IGVsc2UgaWYgKGokLmlzRG9tTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHZhbHVlLnRhZ05hbWUpIHtcbiAgICAgICAgICB0aGlzLmVtaXREb21FbGVtZW50KHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVtaXRTY2FsYXIoJ0hUTUxOb2RlJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHRoaXMuZW1pdFNjYWxhcignRGF0ZSgnICsgdmFsdWUgKyAnKScpO1xuICAgICAgfSBlbHNlIGlmIChqJC5pc1NldCh2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5lbWl0U2V0KHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaiQuaXNNYXAodmFsdWUpKSB7XG4gICAgICAgIHRoaXMuZW1pdE1hcCh2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGokLmlzVHlwZWRBcnJheV8odmFsdWUpKSB7XG4gICAgICAgIHRoaXMuZW1pdFR5cGVkQXJyYXkodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgdmFsdWUudG9TdHJpbmcgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAhaiQuaXNBcnJheV8odmFsdWUpICYmXG4gICAgICAgIGhhc0N1c3RvbVRvU3RyaW5nKHZhbHVlKVxuICAgICAgKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5lbWl0U2NhbGFyKHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhpcy5lbWl0U2NhbGFyKCdoYXMtaW52YWxpZC10b1N0cmluZy1tZXRob2QnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChqJC51dGlsLmFycmF5Q29udGFpbnModGhpcy5zZWVuLCB2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5lbWl0U2NhbGFyKFxuICAgICAgICAgICc8Y2lyY3VsYXIgcmVmZXJlbmNlOiAnICtcbiAgICAgICAgICAgIChqJC5pc0FycmF5Xyh2YWx1ZSkgPyAnQXJyYXknIDogJ09iamVjdCcpICtcbiAgICAgICAgICAgICc+J1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChqJC5pc0FycmF5Xyh2YWx1ZSkgfHwgaiQuaXNBXygnT2JqZWN0JywgdmFsdWUpKSB7XG4gICAgICAgIHRoaXMuc2Vlbi5wdXNoKHZhbHVlKTtcbiAgICAgICAgaWYgKGokLmlzQXJyYXlfKHZhbHVlKSkge1xuICAgICAgICAgIHRoaXMuZW1pdEFycmF5KHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVtaXRPYmplY3QodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Vlbi5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW1pdFNjYWxhcih2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAodGhpcy5wcE5lc3RMZXZlbF8gPiAxIHx8ICEoZSBpbnN0YW5jZW9mIE1heENoYXJzUmVhY2hlZEVycm9yKSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnBwTmVzdExldmVsXy0tO1xuICAgIH1cbiAgfTtcblxuICBTaW5nbGVQcmV0dHlQcmludFJ1bi5wcm90b3R5cGUuYXBwbHlDdXN0b21Gb3JtYXR0ZXJzXyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGN1c3RvbUZvcm1hdCh2YWx1ZSwgdGhpcy5jdXN0b21PYmplY3RGb3JtYXR0ZXJzXyk7XG4gIH07XG5cbiAgU2luZ2xlUHJldHR5UHJpbnRSdW4ucHJvdG90eXBlLml0ZXJhdGVPYmplY3QgPSBmdW5jdGlvbihvYmosIGZuKSB7XG4gICAgdmFyIG9iaktleXMgPSBrZXlzKG9iaiwgaiQuaXNBcnJheV8ob2JqKSk7XG4gICAgdmFyIGlzR2V0dGVyID0gZnVuY3Rpb24gaXNHZXR0ZXIocHJvcCkge307XG5cbiAgICBpZiAob2JqLl9fbG9va3VwR2V0dGVyX18pIHtcbiAgICAgIGlzR2V0dGVyID0gZnVuY3Rpb24gaXNHZXR0ZXIocHJvcCkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gb2JqLl9fbG9va3VwR2V0dGVyX18ocHJvcCk7XG4gICAgICAgIHJldHVybiAhaiQudXRpbC5pc1VuZGVmaW5lZChnZXR0ZXIpICYmIGdldHRlciAhPT0gbnVsbDtcbiAgICAgIH07XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBNYXRoLm1pbihvYmpLZXlzLmxlbmd0aCwgaiQuTUFYX1BSRVRUWV9QUklOVF9BUlJBWV9MRU5HVEgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wZXJ0eSA9IG9iaktleXNbaV07XG4gICAgICBmbihwcm9wZXJ0eSwgaXNHZXR0ZXIocHJvcGVydHkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqS2V5cy5sZW5ndGggPiBsZW5ndGg7XG4gIH07XG5cbiAgU2luZ2xlUHJldHR5UHJpbnRSdW4ucHJvdG90eXBlLmVtaXRTY2FsYXIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuYXBwZW5kKHZhbHVlKTtcbiAgfTtcblxuICBTaW5nbGVQcmV0dHlQcmludFJ1bi5wcm90b3R5cGUuZW1pdFN0cmluZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5hcHBlbmQoXCInXCIgKyB2YWx1ZSArIFwiJ1wiKTtcbiAgfTtcblxuICBTaW5nbGVQcmV0dHlQcmludFJ1bi5wcm90b3R5cGUuZW1pdEFycmF5ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICBpZiAodGhpcy5wcE5lc3RMZXZlbF8gPiBqJC5NQVhfUFJFVFRZX1BSSU5UX0RFUFRIKSB7XG4gICAgICB0aGlzLmFwcGVuZCgnQXJyYXknKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGFycmF5Lmxlbmd0aCwgaiQuTUFYX1BSRVRUWV9QUklOVF9BUlJBWV9MRU5HVEgpO1xuICAgIHRoaXMuYXBwZW5kKCdbICcpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICB0aGlzLmFwcGVuZCgnLCAnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZm9ybWF0KGFycmF5W2ldKTtcbiAgICB9XG4gICAgaWYgKGFycmF5Lmxlbmd0aCA+IGxlbmd0aCkge1xuICAgICAgdGhpcy5hcHBlbmQoJywgLi4uJyk7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBmaXJzdCA9IGFycmF5Lmxlbmd0aCA9PT0gMDtcbiAgICB2YXIgdHJ1bmNhdGVkID0gdGhpcy5pdGVyYXRlT2JqZWN0KGFycmF5LCBmdW5jdGlvbihwcm9wZXJ0eSwgaXNHZXR0ZXIpIHtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5hcHBlbmQoJywgJyk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuZm9ybWF0UHJvcGVydHkoYXJyYXksIHByb3BlcnR5LCBpc0dldHRlcik7XG4gICAgfSk7XG5cbiAgICBpZiAodHJ1bmNhdGVkKSB7XG4gICAgICB0aGlzLmFwcGVuZCgnLCAuLi4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmFwcGVuZCgnIF0nKTtcbiAgfTtcblxuICBTaW5nbGVQcmV0dHlQcmludFJ1bi5wcm90b3R5cGUuZW1pdFNldCA9IGZ1bmN0aW9uKHNldCkge1xuICAgIGlmICh0aGlzLnBwTmVzdExldmVsXyA+IGokLk1BWF9QUkVUVFlfUFJJTlRfREVQVEgpIHtcbiAgICAgIHRoaXMuYXBwZW5kKCdTZXQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hcHBlbmQoJ1NldCggJyk7XG4gICAgdmFyIHNpemUgPSBNYXRoLm1pbihzZXQuc2l6ZSwgaiQuTUFYX1BSRVRUWV9QUklOVF9BUlJBWV9MRU5HVEgpO1xuICAgIHZhciBpID0gMDtcbiAgICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAoaSA+PSBzaXplKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICB0aGlzLmFwcGVuZCgnLCAnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZm9ybWF0KHZhbHVlKTtcblxuICAgICAgaSsrO1xuICAgIH0sIHRoaXMpO1xuICAgIGlmIChzZXQuc2l6ZSA+IHNpemUpIHtcbiAgICAgIHRoaXMuYXBwZW5kKCcsIC4uLicpO1xuICAgIH1cbiAgICB0aGlzLmFwcGVuZCgnICknKTtcbiAgfTtcblxuICBTaW5nbGVQcmV0dHlQcmludFJ1bi5wcm90b3R5cGUuZW1pdE1hcCA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIGlmICh0aGlzLnBwTmVzdExldmVsXyA+IGokLk1BWF9QUkVUVFlfUFJJTlRfREVQVEgpIHtcbiAgICAgIHRoaXMuYXBwZW5kKCdNYXAnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hcHBlbmQoJ01hcCggJyk7XG4gICAgdmFyIHNpemUgPSBNYXRoLm1pbihtYXAuc2l6ZSwgaiQuTUFYX1BSRVRUWV9QUklOVF9BUlJBWV9MRU5HVEgpO1xuICAgIHZhciBpID0gMDtcbiAgICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAoaSA+PSBzaXplKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICB0aGlzLmFwcGVuZCgnLCAnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZm9ybWF0KFtrZXksIHZhbHVlXSk7XG5cbiAgICAgIGkrKztcbiAgICB9LCB0aGlzKTtcbiAgICBpZiAobWFwLnNpemUgPiBzaXplKSB7XG4gICAgICB0aGlzLmFwcGVuZCgnLCAuLi4nKTtcbiAgICB9XG4gICAgdGhpcy5hcHBlbmQoJyApJyk7XG4gIH07XG5cbiAgU2luZ2xlUHJldHR5UHJpbnRSdW4ucHJvdG90eXBlLmVtaXRPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgY3RvciA9IG9iai5jb25zdHJ1Y3RvcixcbiAgICAgIGNvbnN0cnVjdG9yTmFtZTtcblxuICAgIGNvbnN0cnVjdG9yTmFtZSA9XG4gICAgICB0eXBlb2YgY3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmogaW5zdGFuY2VvZiBjdG9yXG4gICAgICAgID8gaiQuZm5OYW1lRm9yKG9iai5jb25zdHJ1Y3RvcilcbiAgICAgICAgOiAnbnVsbCc7XG5cbiAgICB0aGlzLmFwcGVuZChjb25zdHJ1Y3Rvck5hbWUpO1xuXG4gICAgaWYgKHRoaXMucHBOZXN0TGV2ZWxfID4gaiQuTUFYX1BSRVRUWV9QUklOVF9ERVBUSCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmFwcGVuZCgnKHsgJyk7XG4gICAgdmFyIGZpcnN0ID0gdHJ1ZTtcblxuICAgIHZhciB0cnVuY2F0ZWQgPSB0aGlzLml0ZXJhdGVPYmplY3Qob2JqLCBmdW5jdGlvbihwcm9wZXJ0eSwgaXNHZXR0ZXIpIHtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5hcHBlbmQoJywgJyk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuZm9ybWF0UHJvcGVydHkob2JqLCBwcm9wZXJ0eSwgaXNHZXR0ZXIpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRydW5jYXRlZCkge1xuICAgICAgdGhpcy5hcHBlbmQoJywgLi4uJyk7XG4gICAgfVxuXG4gICAgdGhpcy5hcHBlbmQoJyB9KScpO1xuICB9O1xuXG4gIFNpbmdsZVByZXR0eVByaW50UnVuLnByb3RvdHlwZS5lbWl0VHlwZWRBcnJheSA9IGZ1bmN0aW9uKGFycikge1xuICAgIHZhciBjb25zdHJ1Y3Rvck5hbWUgPSBqJC5mbk5hbWVGb3IoYXJyLmNvbnN0cnVjdG9yKSxcbiAgICAgIGxpbWl0ZWRBcnJheSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKFxuICAgICAgICBhcnIsXG4gICAgICAgIDAsXG4gICAgICAgIGokLk1BWF9QUkVUVFlfUFJJTlRfQVJSQVlfTEVOR1RIXG4gICAgICApLFxuICAgICAgaXRlbXNTdHJpbmcgPSBBcnJheS5wcm90b3R5cGUuam9pbi5jYWxsKGxpbWl0ZWRBcnJheSwgJywgJyk7XG5cbiAgICBpZiAobGltaXRlZEFycmF5Lmxlbmd0aCAhPT0gYXJyLmxlbmd0aCkge1xuICAgICAgaXRlbXNTdHJpbmcgKz0gJywgLi4uJztcbiAgICB9XG5cbiAgICB0aGlzLmFwcGVuZChjb25zdHJ1Y3Rvck5hbWUgKyAnIFsgJyArIGl0ZW1zU3RyaW5nICsgJyBdJyk7XG4gIH07XG5cbiAgU2luZ2xlUHJldHR5UHJpbnRSdW4ucHJvdG90eXBlLmVtaXREb21FbGVtZW50ID0gZnVuY3Rpb24oZWwpIHtcbiAgICB2YXIgdGFnTmFtZSA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgIGF0dHJzID0gZWwuYXR0cmlidXRlcyxcbiAgICAgIGksXG4gICAgICBsZW4gPSBhdHRycy5sZW5ndGgsXG4gICAgICBvdXQgPSAnPCcgKyB0YWdOYW1lLFxuICAgICAgYXR0cjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXR0ciA9IGF0dHJzW2ldO1xuICAgICAgb3V0ICs9ICcgJyArIGF0dHIubmFtZTtcblxuICAgICAgaWYgKGF0dHIudmFsdWUgIT09ICcnKSB7XG4gICAgICAgIG91dCArPSAnPVwiJyArIGF0dHIudmFsdWUgKyAnXCInO1xuICAgICAgfVxuICAgIH1cblxuICAgIG91dCArPSAnPic7XG5cbiAgICBpZiAoZWwuY2hpbGRFbGVtZW50Q291bnQgIT09IDAgfHwgZWwudGV4dENvbnRlbnQgIT09ICcnKSB7XG4gICAgICBvdXQgKz0gJy4uLjwvJyArIHRhZ05hbWUgKyAnPic7XG4gICAgfVxuXG4gICAgdGhpcy5hcHBlbmQob3V0KTtcbiAgfTtcblxuICBTaW5nbGVQcmV0dHlQcmludFJ1bi5wcm90b3R5cGUuZm9ybWF0UHJvcGVydHkgPSBmdW5jdGlvbihcbiAgICBvYmosXG4gICAgcHJvcGVydHksXG4gICAgaXNHZXR0ZXJcbiAgKSB7XG4gICAgdGhpcy5hcHBlbmQocHJvcGVydHkpO1xuICAgIHRoaXMuYXBwZW5kKCc6ICcpO1xuICAgIGlmIChpc0dldHRlcikge1xuICAgICAgdGhpcy5hcHBlbmQoJzxnZXR0ZXI+Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZm9ybWF0KG9ialtwcm9wZXJ0eV0pO1xuICAgIH1cbiAgfTtcblxuICBTaW5nbGVQcmV0dHlQcmludFJ1bi5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAvLyBUaGlzIGNoZWNrIHByb3RlY3RzIHVzIGZyb20gdGhlIHJhcmUgY2FzZSB3aGVyZSBhbiBvYmplY3QgaGFzIG92ZXJyaWRlblxuICAgIC8vIGB0b1N0cmluZygpYCB3aXRoIGFuIGludmFsaWQgaW1wbGVtZW50YXRpb24gKHJldHVybmluZyBhIG5vbi1zdHJpbmcpLlxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHRydW5jYXRlKHZhbHVlLCBqJC5NQVhfUFJFVFRZX1BSSU5UX0NIQVJTIC0gdGhpcy5sZW5ndGgpO1xuICAgIHRoaXMubGVuZ3RoICs9IHJlc3VsdC52YWx1ZS5sZW5ndGg7XG4gICAgdGhpcy5zdHJpbmdQYXJ0cy5wdXNoKHJlc3VsdC52YWx1ZSk7XG5cbiAgICBpZiAocmVzdWx0LnRydW5jYXRlZCkge1xuICAgICAgdGhyb3cgbmV3IE1heENoYXJzUmVhY2hlZEVycm9yKCk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHRydW5jYXRlKHMsIG1heGxlbikge1xuICAgIGlmIChzLmxlbmd0aCA8PSBtYXhsZW4pIHtcbiAgICAgIHJldHVybiB7IHZhbHVlOiBzLCB0cnVuY2F0ZWQ6IGZhbHNlIH07XG4gICAgfVxuXG4gICAgcyA9IHMuc3Vic3RyaW5nKDAsIG1heGxlbiAtIDQpICsgJyAuLi4nO1xuICAgIHJldHVybiB7IHZhbHVlOiBzLCB0cnVuY2F0ZWQ6IHRydWUgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIE1heENoYXJzUmVhY2hlZEVycm9yKCkge1xuICAgIHRoaXMubWVzc2FnZSA9XG4gICAgICAnRXhjZWVkZWQgJyArXG4gICAgICBqJC5NQVhfUFJFVFRZX1BSSU5UX0NIQVJTICtcbiAgICAgICcgY2hhcmFjdGVycyB3aGlsZSBwcmV0dHktcHJpbnRpbmcgYSB2YWx1ZSc7XG4gIH1cblxuICBNYXhDaGFyc1JlYWNoZWRFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcblxuICBmdW5jdGlvbiBrZXlzKG9iaiwgaXNBcnJheSkge1xuICAgIHZhciBhbGxLZXlzID0gT2JqZWN0LmtleXNcbiAgICAgID8gT2JqZWN0LmtleXMob2JqKVxuICAgICAgOiAoZnVuY3Rpb24obykge1xuICAgICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIG8pIHtcbiAgICAgICAgICAgIGlmIChqJC51dGlsLmhhcyhvLCBrZXkpKSB7XG4gICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgICAgfSkob2JqKTtcblxuICAgIGlmICghaXNBcnJheSkge1xuICAgICAgcmV0dXJuIGFsbEtleXM7XG4gICAgfVxuXG4gICAgaWYgKGFsbEtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYWxsS2V5cztcbiAgICB9XG5cbiAgICB2YXIgZXh0cmFLZXlzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIS9eWzAtOV0rJC8udGVzdChhbGxLZXlzW2ldKSkge1xuICAgICAgICBleHRyYUtleXMucHVzaChhbGxLZXlzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXh0cmFLZXlzO1xuICB9XG5cbiAgZnVuY3Rpb24gY3VzdG9tRm9ybWF0KHZhbHVlLCBjdXN0b21PYmplY3RGb3JtYXR0ZXJzKSB7XG4gICAgdmFyIGksIHJlc3VsdDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBjdXN0b21PYmplY3RGb3JtYXR0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHQgPSBjdXN0b21PYmplY3RGb3JtYXR0ZXJzW2ldKHZhbHVlKTtcblxuICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGN1c3RvbU9iamVjdEZvcm1hdHRlcnMpIHtcbiAgICBjdXN0b21PYmplY3RGb3JtYXR0ZXJzID0gY3VzdG9tT2JqZWN0Rm9ybWF0dGVycyB8fCBbXTtcblxuICAgIHZhciBwcCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgcHJldHR5UHJpbnRlciA9IG5ldyBTaW5nbGVQcmV0dHlQcmludFJ1bihjdXN0b21PYmplY3RGb3JtYXR0ZXJzLCBwcCk7XG4gICAgICBwcmV0dHlQcmludGVyLmZvcm1hdCh2YWx1ZSk7XG4gICAgICByZXR1cm4gcHJldHR5UHJpbnRlci5zdHJpbmdQYXJ0cy5qb2luKCcnKTtcbiAgICB9O1xuXG4gICAgcHAuY3VzdG9tRm9ybWF0XyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gY3VzdG9tRm9ybWF0KHZhbHVlLCBjdXN0b21PYmplY3RGb3JtYXR0ZXJzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHBwO1xuICB9O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5RdWV1ZVJ1bm5lciA9IGZ1bmN0aW9uKGokKSB7XG4gIHZhciBuZXh0aWQgPSAxO1xuXG4gIGZ1bmN0aW9uIFN0b3BFeGVjdXRpb25FcnJvcigpIHt9XG4gIFN0b3BFeGVjdXRpb25FcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgaiQuU3RvcEV4ZWN1dGlvbkVycm9yID0gU3RvcEV4ZWN1dGlvbkVycm9yO1xuXG4gIGZ1bmN0aW9uIG9uY2UoZm4sIG9uVHdpY2UpIHtcbiAgICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgICAgaWYgKGNhbGxlZCkge1xuICAgICAgICBpZiAob25Ud2ljZSkge1xuICAgICAgICAgIG9uVHdpY2UoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gRGlyZWN0IGNhbGwgdXNpbmcgc2luZ2xlIHBhcmFtZXRlciwgYmVjYXVzZSBjbGVhbnVwL25leHQgZG9lcyBub3QgbmVlZCBtb3JlXG4gICAgICAgIGZuKGFyZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZmFsbGJhY2tPbk11bHRpcGxlRG9uZSgpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgbmV3IEVycm9yKFxuICAgICAgICBcIkFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbiBjYWxsZWQgaXRzICdkb25lJyBcIiArXG4gICAgICAgICAgJ2NhbGxiYWNrIG1vcmUgdGhhbiBvbmNlLCBpbiBhIFF1ZXVlUnVubmVyIHdpdGhvdXQgYSBvbk11bHRpcGxlRG9uZSAnICtcbiAgICAgICAgICAnaGFuZGxlci4nXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Rm4oKSB7fVxuXG4gIGZ1bmN0aW9uIFF1ZXVlUnVubmVyKGF0dHJzKSB7XG4gICAgdGhpcy5pZF8gPSBuZXh0aWQrKztcbiAgICB0aGlzLnF1ZXVlYWJsZUZucyA9IGF0dHJzLnF1ZXVlYWJsZUZucyB8fCBbXTtcbiAgICB0aGlzLm9uQ29tcGxldGUgPSBhdHRycy5vbkNvbXBsZXRlIHx8IGVtcHR5Rm47XG4gICAgdGhpcy5jbGVhclN0YWNrID1cbiAgICAgIGF0dHJzLmNsZWFyU3RhY2sgfHxcbiAgICAgIGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9O1xuICAgIHRoaXMub25FeGNlcHRpb24gPSBhdHRycy5vbkV4Y2VwdGlvbiB8fCBlbXB0eUZuO1xuICAgIHRoaXMub25NdWx0aXBsZURvbmUgPSBhdHRycy5vbk11bHRpcGxlRG9uZSB8fCBmYWxsYmFja09uTXVsdGlwbGVEb25lO1xuICAgIHRoaXMudXNlckNvbnRleHQgPSBhdHRycy51c2VyQ29udGV4dCB8fCBuZXcgaiQuVXNlckNvbnRleHQoKTtcbiAgICB0aGlzLnRpbWVvdXQgPSBhdHRycy50aW1lb3V0IHx8IHtcbiAgICAgIHNldFRpbWVvdXQ6IHNldFRpbWVvdXQsXG4gICAgICBjbGVhclRpbWVvdXQ6IGNsZWFyVGltZW91dFxuICAgIH07XG4gICAgdGhpcy5mYWlsID0gYXR0cnMuZmFpbCB8fCBlbXB0eUZuO1xuICAgIHRoaXMuZ2xvYmFsRXJyb3JzID0gYXR0cnMuZ2xvYmFsRXJyb3JzIHx8IHtcbiAgICAgIHB1c2hMaXN0ZW5lcjogZW1wdHlGbixcbiAgICAgIHBvcExpc3RlbmVyOiBlbXB0eUZuXG4gICAgfTtcblxuICAgIGNvbnN0IFNraXBQb2xpY3kgPSBhdHRycy5Ta2lwUG9saWN5IHx8IGokLk5ldmVyU2tpcFBvbGljeTtcbiAgICB0aGlzLnNraXBQb2xpY3lfID0gbmV3IFNraXBQb2xpY3kodGhpcy5xdWV1ZWFibGVGbnMpO1xuICAgIHRoaXMuZXJyb3JlZF8gPSBmYWxzZTtcblxuICAgIGlmICh0eXBlb2YgdGhpcy5vbkNvbXBsZXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgb25Db21wbGV0ZSAnICsgSlNPTi5zdHJpbmdpZnkodGhpcy5vbkNvbXBsZXRlKSk7XG4gICAgfVxuICAgIHRoaXMuZGVwcmVjYXRlZCA9IGF0dHJzLmRlcHJlY2F0ZWQ7XG4gIH1cblxuICBRdWV1ZVJ1bm5lci5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmhhbmRsZUZpbmFsRXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlLCBzb3VyY2UsIGxpbmVubywgY29sbm8sIGVycm9yKSB7XG4gICAgICAvLyBPbGRlciBicm93c2VycyB3b3VsZCBzZW5kIHRoZSBlcnJvciBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyLiBIVE1MNVxuICAgICAgLy8gc3BlY2lmaWVzIHRoZSB0aGUgZml2ZSBwYXJhbWV0ZXJzIGFib3ZlLiBUaGUgZXJyb3IgaW5zdGFuY2Ugc2hvdWxkXG4gICAgICAvLyBiZSBwcmVmZmVyZWQsIG90aGVyd2lzZSB0aGUgY2FsbCBzdGFjayB3b3VsZCBnZXQgbG9zdC5cbiAgICAgIHNlbGYub25FeGNlcHRpb24oZXJyb3IgfHwgbWVzc2FnZSk7XG4gICAgfTtcbiAgICB0aGlzLmdsb2JhbEVycm9ycy5wdXNoTGlzdGVuZXIodGhpcy5oYW5kbGVGaW5hbEVycm9yKTtcbiAgICB0aGlzLnJ1bigwKTtcbiAgfTtcblxuICBRdWV1ZVJ1bm5lci5wcm90b3R5cGUuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24odGltZW91dElkKSB7XG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KHRoaXMudGltZW91dC5jbGVhclRpbWVvdXQsIFtcbiAgICAgIGokLmdldEdsb2JhbCgpLFxuICAgICAgW3RpbWVvdXRJZF1cbiAgICBdKTtcbiAgfTtcblxuICBRdWV1ZVJ1bm5lci5wcm90b3R5cGUuc2V0VGltZW91dCA9IGZ1bmN0aW9uKGZuLCB0aW1lb3V0KSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseSh0aGlzLnRpbWVvdXQuc2V0VGltZW91dCwgW1xuICAgICAgaiQuZ2V0R2xvYmFsKCksXG4gICAgICBbZm4sIHRpbWVvdXRdXG4gICAgXSk7XG4gIH07XG5cbiAgUXVldWVSdW5uZXIucHJvdG90eXBlLmF0dGVtcHQgPSBmdW5jdGlvbiBhdHRlbXB0KGl0ZXJhdGl2ZUluZGV4KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgY29tcGxldGVkU3luY2hyb25vdXNseSA9IHRydWUsXG4gICAgICBoYW5kbGVFcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycm9yKSB7XG4gICAgICAgIC8vIFRPRE8gcHJvYmFibHkgc2hvdWxkbid0IG5leHQoKSByaWdodCBhd2F5IGhlcmUuXG4gICAgICAgIC8vIFRoYXQgbWFrZXMgZGVidWdnaW5nIGFzeW5jIGZhaWx1cmVzIG11Y2ggbW9yZSBjb25mdXNpbmcuXG4gICAgICAgIG9uRXhjZXB0aW9uKGVycm9yKTtcbiAgICAgIH0sXG4gICAgICBjbGVhbnVwID0gb25jZShmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICBpZiAodGltZW91dElkICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBzZWxmLmNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuZ2xvYmFsRXJyb3JzLnBvcExpc3RlbmVyKGhhbmRsZUVycm9yKTtcbiAgICAgIH0pLFxuICAgICAgbmV4dCA9IG9uY2UoXG4gICAgICAgIGZ1bmN0aW9uIG5leHQoZXJyKSB7XG4gICAgICAgICAgY2xlYW51cCgpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBlcnIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBTdG9wRXhlY3V0aW9uRXJyb3IpICYmICFlcnIuamFzbWluZU1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgc2VsZi5mYWlsKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLnJlY29yZEVycm9yXyhpdGVyYXRpdmVJbmRleCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gcnVuTmV4dCgpIHtcbiAgICAgICAgICAgIHNlbGYucnVuKHNlbGYubmV4dEZuSXhfKGl0ZXJhdGl2ZUluZGV4KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbXBsZXRlZFN5bmNocm9ub3VzbHkpIHtcbiAgICAgICAgICAgIHNlbGYuc2V0VGltZW91dChydW5OZXh0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcnVuTmV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghdGltZWRPdXQpIHtcbiAgICAgICAgICAgICAgc2VsZi5vbk11bHRpcGxlRG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBBbnkgZXJyb3Igd2UgY2F0Y2ggaGVyZSBpcyBwcm9iYWJseSBkdWUgdG8gYSBidWcgaW4gSmFzbWluZSxcbiAgICAgICAgICAgIC8vIGFuZCBpdCdzIG5vdCBsaWtlbHkgdG8gZW5kIHVwIGFueXdoZXJlIHVzZWZ1bCBpZiB3ZSBsZXQgaXRcbiAgICAgICAgICAgIC8vIHByb3BhZ2F0ZS4gTG9nIGl0IHNvIGl0IGNhbiBhdCBsZWFzdCBzaG93IHVwIHdoZW4gZGVidWdnaW5nLlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApLFxuICAgICAgdGltZWRPdXQgPSBmYWxzZSxcbiAgICAgIHF1ZXVlYWJsZUZuID0gc2VsZi5xdWV1ZWFibGVGbnNbaXRlcmF0aXZlSW5kZXhdLFxuICAgICAgdGltZW91dElkLFxuICAgICAgbWF5YmVUaGVuYWJsZTtcblxuICAgIG5leHQuZmFpbCA9IGZ1bmN0aW9uIG5leHRGYWlsKCkge1xuICAgICAgc2VsZi5mYWlsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICBzZWxmLnJlY29yZEVycm9yXyhpdGVyYXRpdmVJbmRleCk7XG4gICAgICBuZXh0KCk7XG4gICAgfTtcblxuICAgIHNlbGYuZ2xvYmFsRXJyb3JzLnB1c2hMaXN0ZW5lcihoYW5kbGVFcnJvcik7XG5cbiAgICBpZiAocXVldWVhYmxlRm4udGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgdGltZW91dEludGVydmFsID0gcXVldWVhYmxlRm4udGltZW91dCB8fCBqJC5ERUZBVUxUX1RJTUVPVVRfSU5URVJWQUw7XG4gICAgICB0aW1lb3V0SWQgPSBzZWxmLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRpbWVkT3V0ID0gdHJ1ZTtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICdUaW1lb3V0IC0gQXN5bmMgZnVuY3Rpb24gZGlkIG5vdCBjb21wbGV0ZSB3aXRoaW4gJyArXG4gICAgICAgICAgICB0aW1lb3V0SW50ZXJ2YWwgK1xuICAgICAgICAgICAgJ21zICcgK1xuICAgICAgICAgICAgKHF1ZXVlYWJsZUZuLnRpbWVvdXRcbiAgICAgICAgICAgICAgPyAnKGN1c3RvbSB0aW1lb3V0KSdcbiAgICAgICAgICAgICAgOiAnKHNldCBieSBqYXNtaW5lLkRFRkFVTFRfVElNRU9VVF9JTlRFUlZBTCknKVxuICAgICAgICApO1xuICAgICAgICAvLyBUT0RPIE5lZWQgdG8gZGVjaWRlIHdoYXQgdG8gZG8gYWJvdXQgYSBzdWNjZXNzZnVsIGNvbXBsZXRpb24gYWZ0ZXIgYVxuICAgICAgICAvLyAgIHRpbWVvdXQuIFRoYXQgc2hvdWxkIHByb2JhYmx5IG5vdCBiZSBhIGRlcHJlY2F0aW9uLCBhbmQgbWF5YmUgbm90XG4gICAgICAgIC8vICAgYW4gZXJyb3IgaW4gNC4wLiAoQnV0IGEgZGlhZ25vc3RpYyBvZiBzb21lIHNvcnQgbWlnaHQgYmUgaGVscGZ1bC4pXG4gICAgICAgIG9uRXhjZXB0aW9uKGVycm9yKTtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfSwgdGltZW91dEludGVydmFsKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKHF1ZXVlYWJsZUZuLmZuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBtYXliZVRoZW5hYmxlID0gcXVldWVhYmxlRm4uZm4uY2FsbChzZWxmLnVzZXJDb250ZXh0KTtcblxuICAgICAgICBpZiAobWF5YmVUaGVuYWJsZSAmJiBqJC5pc0Z1bmN0aW9uXyhtYXliZVRoZW5hYmxlLnRoZW4pKSB7XG4gICAgICAgICAgbWF5YmVUaGVuYWJsZS50aGVuKFxuICAgICAgICAgICAgd3JhcEluUHJvbWlzZVJlc29sdXRpb25IYW5kbGVyKG5leHQpLFxuICAgICAgICAgICAgb25Qcm9taXNlUmVqZWN0aW9uXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb21wbGV0ZWRTeW5jaHJvbm91c2x5ID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIHsgY29tcGxldGVkU3luY2hyb25vdXNseTogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF5YmVUaGVuYWJsZSA9IHF1ZXVlYWJsZUZuLmZuLmNhbGwoc2VsZi51c2VyQ29udGV4dCwgbmV4dCk7XG4gICAgICAgIHRoaXMuZGlhZ25vc2VDb25mbGljdGluZ0FzeW5jXyhxdWV1ZWFibGVGbi5mbiwgbWF5YmVUaGVuYWJsZSk7XG4gICAgICAgIGNvbXBsZXRlZFN5bmNocm9ub3VzbHkgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHsgY29tcGxldGVkU3luY2hyb25vdXNseTogZmFsc2UgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBvbkV4Y2VwdGlvbihlKTtcbiAgICAgIHNlbGYucmVjb3JkRXJyb3JfKGl0ZXJhdGl2ZUluZGV4KTtcbiAgICB9XG5cbiAgICBjbGVhbnVwKCk7XG4gICAgcmV0dXJuIHsgY29tcGxldGVkU3luY2hyb25vdXNseTogdHJ1ZSB9O1xuXG4gICAgZnVuY3Rpb24gb25FeGNlcHRpb24oZSkge1xuICAgICAgc2VsZi5vbkV4Y2VwdGlvbihlKTtcbiAgICAgIHNlbGYucmVjb3JkRXJyb3JfKGl0ZXJhdGl2ZUluZGV4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblByb21pc2VSZWplY3Rpb24oZSkge1xuICAgICAgb25FeGNlcHRpb24oZSk7XG4gICAgICBuZXh0KCk7XG4gICAgfVxuICB9O1xuXG4gIFF1ZXVlUnVubmVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbihyZWN1cnNpdmVJbmRleCkge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLnF1ZXVlYWJsZUZucy5sZW5ndGgsXG4gICAgICBzZWxmID0gdGhpcyxcbiAgICAgIGl0ZXJhdGl2ZUluZGV4O1xuXG4gICAgZm9yIChcbiAgICAgIGl0ZXJhdGl2ZUluZGV4ID0gcmVjdXJzaXZlSW5kZXg7XG4gICAgICBpdGVyYXRpdmVJbmRleCA8IGxlbmd0aDtcbiAgICAgIGl0ZXJhdGl2ZUluZGV4ID0gdGhpcy5uZXh0Rm5JeF8oaXRlcmF0aXZlSW5kZXgpXG4gICAgKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5hdHRlbXB0KGl0ZXJhdGl2ZUluZGV4KTtcblxuICAgICAgaWYgKCFyZXN1bHQuY29tcGxldGVkU3luY2hyb25vdXNseSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jbGVhclN0YWNrKGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5nbG9iYWxFcnJvcnMucG9wTGlzdGVuZXIoc2VsZi5oYW5kbGVGaW5hbEVycm9yKTtcblxuICAgICAgaWYgKHNlbGYuZXJyb3JlZF8pIHtcbiAgICAgICAgc2VsZi5vbkNvbXBsZXRlKG5ldyBTdG9wRXhlY3V0aW9uRXJyb3IoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLm9uQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBRdWV1ZVJ1bm5lci5wcm90b3R5cGUubmV4dEZuSXhfID0gZnVuY3Rpb24oY3VycmVudEZuSXgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnNraXBQb2xpY3lfLnNraXBUbyhjdXJyZW50Rm5JeCk7XG5cbiAgICBpZiAocmVzdWx0ID09PSBjdXJyZW50Rm5JeCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgc2tpcCB0byB0aGUgc2FtZSBxdWV1ZWFibGUgZm4gdGhhdCBqdXN0IGZpbmlzaGVkXCIpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgUXVldWVSdW5uZXIucHJvdG90eXBlLnJlY29yZEVycm9yXyA9IGZ1bmN0aW9uKGN1cnJlbnRGbkl4KSB7XG4gICAgdGhpcy5lcnJvcmVkXyA9IHRydWU7XG4gICAgdGhpcy5za2lwUG9saWN5Xy5mbkVycm9yZWQoY3VycmVudEZuSXgpO1xuICB9O1xuXG4gIFF1ZXVlUnVubmVyLnByb3RvdHlwZS5kaWFnbm9zZUNvbmZsaWN0aW5nQXN5bmNfID0gZnVuY3Rpb24oZm4sIHJldHZhbCkge1xuICAgIHZhciBtc2c7XG5cbiAgICBpZiAocmV0dmFsICYmIGokLmlzRnVuY3Rpb25fKHJldHZhbC50aGVuKSkge1xuICAgICAgLy8gSXNzdWUgYSB3YXJuaW5nIHRoYXQgbWF0Y2hlcyB0aGUgdXNlcidzIGNvZGUuXG4gICAgICAvLyBPbWl0IHRoZSBzdGFjayB0cmFjZSBiZWNhdXNlIHRoZXJlJ3MgYWxtb3N0IGNlcnRhaW5seSBubyB1c2VyIGNvZGVcbiAgICAgIC8vIG9uIHRoZSBzdGFjayBhdCB0aGlzIHBvaW50LlxuICAgICAgaWYgKGokLmlzQXN5bmNGdW5jdGlvbl8oZm4pKSB7XG4gICAgICAgIHRoaXMub25FeGNlcHRpb24oXG4gICAgICAgICAgJ0FuIGFzeW5jaHJvbm91cyBiZWZvcmUvaXQvYWZ0ZXIgJyArXG4gICAgICAgICAgICAnZnVuY3Rpb24gd2FzIGRlZmluZWQgd2l0aCB0aGUgYXN5bmMga2V5d29yZCBidXQgYWxzbyB0b29rIGEgJyArXG4gICAgICAgICAgICAnZG9uZSBjYWxsYmFjay4gRWl0aGVyIHJlbW92ZSB0aGUgZG9uZSBjYWxsYmFjayAocmVjb21tZW5kZWQpIG9yICcgK1xuICAgICAgICAgICAgJ3JlbW92ZSB0aGUgYXN5bmMga2V5d29yZC4nXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uRXhjZXB0aW9uKFxuICAgICAgICAgICdBbiBhc3luY2hyb25vdXMgYmVmb3JlL2l0L2FmdGVyICcgK1xuICAgICAgICAgICAgJ2Z1bmN0aW9uIHRvb2sgYSBkb25lIGNhbGxiYWNrIGJ1dCBhbHNvIHJldHVybmVkIGEgcHJvbWlzZS4gJyArXG4gICAgICAgICAgICAnRWl0aGVyIHJlbW92ZSB0aGUgZG9uZSBjYWxsYmFjayAocmVjb21tZW5kZWQpIG9yIGNoYW5nZSB0aGUgJyArXG4gICAgICAgICAgICAnZnVuY3Rpb24gdG8gbm90IHJldHVybiBhIHByb21pc2UuJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRlcHJlY2F0ZWQobXNnLCB7IG9taXRTdGFja1RyYWNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiB3cmFwSW5Qcm9taXNlUmVzb2x1dGlvbkhhbmRsZXIoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24obWF5YmVBcmcpIHtcbiAgICAgIGlmIChqJC5pc0Vycm9yXyhtYXliZUFyZykpIHtcbiAgICAgICAgZm4obWF5YmVBcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIFF1ZXVlUnVubmVyO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5SZXBvcnREaXNwYXRjaGVyID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gUmVwb3J0RGlzcGF0Y2hlcihtZXRob2RzLCBxdWV1ZVJ1bm5lckZhY3RvcnksIG9uTGF0ZUVycm9yKSB7XG4gICAgdmFyIGRpc3BhdGNoZWRNZXRob2RzID0gbWV0aG9kcyB8fCBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hlZE1ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBtZXRob2QgPSBkaXNwYXRjaGVkTWV0aG9kc1tpXTtcbiAgICAgIHRoaXNbbWV0aG9kXSA9IChmdW5jdGlvbihtKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBkaXNwYXRjaChtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfSkobWV0aG9kKTtcbiAgICB9XG5cbiAgICB2YXIgcmVwb3J0ZXJzID0gW107XG4gICAgdmFyIGZhbGxiYWNrUmVwb3J0ZXIgPSBudWxsO1xuXG4gICAgdGhpcy5hZGRSZXBvcnRlciA9IGZ1bmN0aW9uKHJlcG9ydGVyKSB7XG4gICAgICByZXBvcnRlcnMucHVzaChyZXBvcnRlcik7XG4gICAgfTtcblxuICAgIHRoaXMucHJvdmlkZUZhbGxiYWNrUmVwb3J0ZXIgPSBmdW5jdGlvbihyZXBvcnRlcikge1xuICAgICAgZmFsbGJhY2tSZXBvcnRlciA9IHJlcG9ydGVyO1xuICAgIH07XG5cbiAgICB0aGlzLmNsZWFyUmVwb3J0ZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXBvcnRlcnMgPSBbXTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgICBmdW5jdGlvbiBkaXNwYXRjaChtZXRob2QsIGFyZ3MpIHtcbiAgICAgIGlmIChyZXBvcnRlcnMubGVuZ3RoID09PSAwICYmIGZhbGxiYWNrUmVwb3J0ZXIgIT09IG51bGwpIHtcbiAgICAgICAgcmVwb3J0ZXJzLnB1c2goZmFsbGJhY2tSZXBvcnRlcik7XG4gICAgICB9XG4gICAgICB2YXIgb25Db21wbGV0ZSA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgIGFyZ3MgPSBqJC51dGlsLmFyZ3NUb0FycmF5KGFyZ3MpLnNwbGljZSgwLCBhcmdzLmxlbmd0aCAtIDEpO1xuICAgICAgdmFyIGZucyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBvcnRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJlcG9ydGVyID0gcmVwb3J0ZXJzW2ldO1xuICAgICAgICBhZGRGbihmbnMsIHJlcG9ydGVyLCBtZXRob2QsIGFyZ3MpO1xuICAgICAgfVxuXG4gICAgICBxdWV1ZVJ1bm5lckZhY3Rvcnkoe1xuICAgICAgICBxdWV1ZWFibGVGbnM6IGZucyxcbiAgICAgICAgb25Db21wbGV0ZTogb25Db21wbGV0ZSxcbiAgICAgICAgaXNSZXBvcnRlcjogdHJ1ZSxcbiAgICAgICAgb25NdWx0aXBsZURvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG9uTGF0ZUVycm9yKFxuICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBcIkFuIGFzeW5jaHJvbm91cyByZXBvcnRlciBjYWxsYmFjayBjYWxsZWQgaXRzICdkb25lJyBjYWxsYmFjayBcIiArXG4gICAgICAgICAgICAgICAgJ21vcmUgdGhhbiBvbmNlLidcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRGbihmbnMsIHJlcG9ydGVyLCBtZXRob2QsIGFyZ3MpIHtcbiAgICAgIHZhciBmbiA9IHJlcG9ydGVyW21ldGhvZF07XG4gICAgICBpZiAoIWZuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHRoaXNBcmdzID0gaiQudXRpbC5jbG9uZUFyZ3MoYXJncyk7XG4gICAgICBpZiAoZm4ubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgZm5zLnB1c2goe1xuICAgICAgICAgIGZuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShyZXBvcnRlciwgdGhpc0FyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbnMucHVzaCh7XG4gICAgICAgICAgZm46IGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShyZXBvcnRlciwgdGhpc0FyZ3MuY29uY2F0KFtkb25lXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFJlcG9ydERpc3BhdGNoZXI7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLmludGVyZmFjZSA9IGZ1bmN0aW9uKGphc21pbmUsIGVudikge1xuICB2YXIgamFzbWluZUludGVyZmFjZSA9IHtcbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayBwYXNzZWQgdG8gcGFydHMgb2YgdGhlIEphc21pbmUgYmFzZSBpbnRlcmZhY2UuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0IEphc21pbmUgYXNzdW1lcyB0aGlzIGZ1bmN0aW9uIGNvbXBsZXRlcyBzeW5jaHJvbm91c2x5LlxuICAgICAqIElmIHlvdSBoYXZlIGNvZGUgdGhhdCB5b3UgbmVlZCB0byB0ZXN0IGFzeW5jaHJvbm91c2x5LCB5b3UgY2FuIGRlY2xhcmUgdGhhdCB5b3UgcmVjZWl2ZSBhIGBkb25lYCBjYWxsYmFjaywgcmV0dXJuIGEgUHJvbWlzZSwgb3IgdXNlIHRoZSBgYXN5bmNgIGtleXdvcmQgaWYgaXQgaXMgc3VwcG9ydGVkIGluIHlvdXIgZW52aXJvbm1lbnQuXG4gICAgICogQGNhbGxiYWNrIGltcGxlbWVudGF0aW9uQ2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZG9uZV0gVXNlZCB0byBzcGVjaWZ5IHRvIEphc21pbmUgdGhhdCB0aGlzIGNhbGxiYWNrIGlzIGFzeW5jaHJvbm91cyBhbmQgSmFzbWluZSBzaG91bGQgd2FpdCB1bnRpbCBpdCBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlIG1vdmluZyBvbi5cbiAgICAgKiBAcmV0dXJucyB7fSBPcHRpb25hbGx5IHJldHVybiBhIFByb21pc2UgaW5zdGVhZCBvZiB1c2luZyBgZG9uZWAgdG8gY2F1c2UgSmFzbWluZSB0byB3YWl0IGZvciBjb21wbGV0aW9uLlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZ3JvdXAgb2Ygc3BlY3MgKG9mdGVuIGNhbGxlZCBhIHN1aXRlKS5cbiAgICAgKlxuICAgICAqIENhbGxzIHRvIGBkZXNjcmliZWAgY2FuIGJlIG5lc3RlZCB3aXRoaW4gb3RoZXIgY2FsbHMgdG8gY29tcG9zZSB5b3VyIHN1aXRlIGFzIGEgdHJlZS5cbiAgICAgKiBAbmFtZSBkZXNjcmliZVxuICAgICAqIEBzaW5jZSAxLjMuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBnbG9iYWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVzY3JpcHRpb24gVGV4dHVhbCBkZXNjcmlwdGlvbiBvZiB0aGUgZ3JvdXBcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzcGVjRGVmaW5pdGlvbnMgRnVuY3Rpb24gZm9yIEphc21pbmUgdG8gaW52b2tlIHRoYXQgd2lsbCBkZWZpbmUgaW5uZXIgc3VpdGVzIGFuZCBzcGVjc1xuICAgICAqL1xuICAgIGRlc2NyaWJlOiBmdW5jdGlvbihkZXNjcmlwdGlvbiwgc3BlY0RlZmluaXRpb25zKSB7XG4gICAgICByZXR1cm4gZW52LmRlc2NyaWJlKGRlc2NyaXB0aW9uLCBzcGVjRGVmaW5pdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRlbXBvcmFyaWx5IGRpc2FibGVkIFtgZGVzY3JpYmVgXXtAbGluayBkZXNjcmliZX1cbiAgICAgKlxuICAgICAqIFNwZWNzIHdpdGhpbiBhbiBgeGRlc2NyaWJlYCB3aWxsIGJlIG1hcmtlZCBwZW5kaW5nIGFuZCBub3QgZXhlY3V0ZWRcbiAgICAgKiBAbmFtZSB4ZGVzY3JpYmVcbiAgICAgKiBAc2luY2UgMS4zLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZ2xvYmFsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlc2NyaXB0aW9uIFRleHR1YWwgZGVzY3JpcHRpb24gb2YgdGhlIGdyb3VwXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3BlY0RlZmluaXRpb25zIEZ1bmN0aW9uIGZvciBKYXNtaW5lIHRvIGludm9rZSB0aGF0IHdpbGwgZGVmaW5lIGlubmVyIHN1aXRlcyBhbmQgc3BlY3NcbiAgICAgKi9cbiAgICB4ZGVzY3JpYmU6IGZ1bmN0aW9uKGRlc2NyaXB0aW9uLCBzcGVjRGVmaW5pdGlvbnMpIHtcbiAgICAgIHJldHVybiBlbnYueGRlc2NyaWJlKGRlc2NyaXB0aW9uLCBzcGVjRGVmaW5pdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIGZvY3VzZWQgW2BkZXNjcmliZWBde0BsaW5rIGRlc2NyaWJlfVxuICAgICAqXG4gICAgICogSWYgc3VpdGVzIG9yIHNwZWNzIGFyZSBmb2N1c2VkLCBvbmx5IHRob3NlIHRoYXQgYXJlIGZvY3VzZWQgd2lsbCBiZSBleGVjdXRlZFxuICAgICAqIEBzZWUgZml0XG4gICAgICogQG5hbWUgZmRlc2NyaWJlXG4gICAgICogQHNpbmNlIDIuMS4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGdsb2JhbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkZXNjcmlwdGlvbiBUZXh0dWFsIGRlc2NyaXB0aW9uIG9mIHRoZSBncm91cFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNwZWNEZWZpbml0aW9ucyBGdW5jdGlvbiBmb3IgSmFzbWluZSB0byBpbnZva2UgdGhhdCB3aWxsIGRlZmluZSBpbm5lciBzdWl0ZXMgYW5kIHNwZWNzXG4gICAgICovXG4gICAgZmRlc2NyaWJlOiBmdW5jdGlvbihkZXNjcmlwdGlvbiwgc3BlY0RlZmluaXRpb25zKSB7XG4gICAgICByZXR1cm4gZW52LmZkZXNjcmliZShkZXNjcmlwdGlvbiwgc3BlY0RlZmluaXRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lIGEgc2luZ2xlIHNwZWMuIEEgc3BlYyBzaG91bGQgY29udGFpbiBvbmUgb3IgbW9yZSB7QGxpbmsgZXhwZWN0fGV4cGVjdGF0aW9uc30gdGhhdCB0ZXN0IHRoZSBzdGF0ZSBvZiB0aGUgY29kZS5cbiAgICAgKlxuICAgICAqIEEgc3BlYyB3aG9zZSBleHBlY3RhdGlvbnMgYWxsIHN1Y2NlZWQgd2lsbCBiZSBwYXNzaW5nIGFuZCBhIHNwZWMgd2l0aCBhbnkgZmFpbHVyZXMgd2lsbCBmYWlsLlxuICAgICAqIFRoZSBuYW1lIGBpdGAgaXMgYSBwcm9ub3VuIGZvciB0aGUgdGVzdCB0YXJnZXQsIG5vdCBhbiBhYmJyZXZpYXRpb24gb2YgYW55dGhpbmcuIEl0IG1ha2VzIHRoZVxuICAgICAqIHNwZWMgbW9yZSByZWFkYWJsZSBieSBjb25uZWN0aW5nIHRoZSBmdW5jdGlvbiBuYW1lIGBpdGAgYW5kIHRoZSBhcmd1bWVudCBgZGVzY3JpcHRpb25gIGFzIGFcbiAgICAgKiBjb21wbGV0ZSBzZW50ZW5jZS5cbiAgICAgKiBAbmFtZSBpdFxuICAgICAqIEBzaW5jZSAxLjMuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBnbG9iYWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVzY3JpcHRpb24gVGV4dHVhbCBkZXNjcmlwdGlvbiBvZiB3aGF0IHRoaXMgc3BlYyBpcyBjaGVja2luZ1xuICAgICAqIEBwYXJhbSB7aW1wbGVtZW50YXRpb25DYWxsYmFja30gW3Rlc3RGdW5jdGlvbl0gRnVuY3Rpb24gdGhhdCBjb250YWlucyB0aGUgY29kZSBvZiB5b3VyIHRlc3QuIElmIG5vdCBwcm92aWRlZCB0aGUgdGVzdCB3aWxsIGJlIGBwZW5kaW5nYC5cbiAgICAgKiBAcGFyYW0ge0ludH0gW3RpbWVvdXQ9e0BsaW5rIGphc21pbmUuREVGQVVMVF9USU1FT1VUX0lOVEVSVkFMfV0gQ3VzdG9tIHRpbWVvdXQgZm9yIGFuIGFzeW5jIHNwZWMuXG4gICAgICogQHNlZSBhc3luY1xuICAgICAqL1xuICAgIGl0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBlbnYuaXQuYXBwbHkoZW52LCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRlbXBvcmFyaWx5IGRpc2FibGVkIFtgaXRgXXtAbGluayBpdH1cbiAgICAgKlxuICAgICAqIFRoZSBzcGVjIHdpbGwgcmVwb3J0IGFzIGBwZW5kaW5nYCBhbmQgd2lsbCBub3QgYmUgZXhlY3V0ZWQuXG4gICAgICogQG5hbWUgeGl0XG4gICAgICogQHNpbmNlIDEuMy4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGdsb2JhbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkZXNjcmlwdGlvbiBUZXh0dWFsIGRlc2NyaXB0aW9uIG9mIHdoYXQgdGhpcyBzcGVjIGlzIGNoZWNraW5nLlxuICAgICAqIEBwYXJhbSB7aW1wbGVtZW50YXRpb25DYWxsYmFja30gW3Rlc3RGdW5jdGlvbl0gRnVuY3Rpb24gdGhhdCBjb250YWlucyB0aGUgY29kZSBvZiB5b3VyIHRlc3QuIFdpbGwgbm90IGJlIGV4ZWN1dGVkLlxuICAgICAqL1xuICAgIHhpdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZW52LnhpdC5hcHBseShlbnYsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgZm9jdXNlZCBbYGl0YF17QGxpbmsgaXR9XG4gICAgICpcbiAgICAgKiBJZiBzdWl0ZXMgb3Igc3BlY3MgYXJlIGZvY3VzZWQsIG9ubHkgdGhvc2UgdGhhdCBhcmUgZm9jdXNlZCB3aWxsIGJlIGV4ZWN1dGVkLlxuICAgICAqIEBuYW1lIGZpdFxuICAgICAqIEBzaW5jZSAyLjEuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBnbG9iYWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVzY3JpcHRpb24gVGV4dHVhbCBkZXNjcmlwdGlvbiBvZiB3aGF0IHRoaXMgc3BlYyBpcyBjaGVja2luZy5cbiAgICAgKiBAcGFyYW0ge2ltcGxlbWVudGF0aW9uQ2FsbGJhY2t9IHRlc3RGdW5jdGlvbiBGdW5jdGlvbiB0aGF0IGNvbnRhaW5zIHRoZSBjb2RlIG9mIHlvdXIgdGVzdC5cbiAgICAgKiBAcGFyYW0ge0ludH0gW3RpbWVvdXQ9e0BsaW5rIGphc21pbmUuREVGQVVMVF9USU1FT1VUX0lOVEVSVkFMfV0gQ3VzdG9tIHRpbWVvdXQgZm9yIGFuIGFzeW5jIHNwZWMuXG4gICAgICogQHNlZSBhc3luY1xuICAgICAqL1xuICAgIGZpdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZW52LmZpdC5hcHBseShlbnYsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJ1biBzb21lIHNoYXJlZCBzZXR1cCBiZWZvcmUgZWFjaCBvZiB0aGUgc3BlY3MgaW4gdGhlIHtAbGluayBkZXNjcmliZX0gaW4gd2hpY2ggaXQgaXMgY2FsbGVkLlxuICAgICAqIEBuYW1lIGJlZm9yZUVhY2hcbiAgICAgKiBAc2luY2UgMS4zLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZ2xvYmFsXG4gICAgICogQHBhcmFtIHtpbXBsZW1lbnRhdGlvbkNhbGxiYWNrfSBbZnVuY3Rpb25dIEZ1bmN0aW9uIHRoYXQgY29udGFpbnMgdGhlIGNvZGUgdG8gc2V0dXAgeW91ciBzcGVjcy5cbiAgICAgKiBAcGFyYW0ge0ludH0gW3RpbWVvdXQ9e0BsaW5rIGphc21pbmUuREVGQVVMVF9USU1FT1VUX0lOVEVSVkFMfV0gQ3VzdG9tIHRpbWVvdXQgZm9yIGFuIGFzeW5jIGJlZm9yZUVhY2guXG4gICAgICogQHNlZSBhc3luY1xuICAgICAqL1xuICAgIGJlZm9yZUVhY2g6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGVudi5iZWZvcmVFYWNoLmFwcGx5KGVudiwgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUnVuIHNvbWUgc2hhcmVkIHRlYXJkb3duIGFmdGVyIGVhY2ggb2YgdGhlIHNwZWNzIGluIHRoZSB7QGxpbmsgZGVzY3JpYmV9IGluIHdoaWNoIGl0IGlzIGNhbGxlZC5cbiAgICAgKiBAbmFtZSBhZnRlckVhY2hcbiAgICAgKiBAc2luY2UgMS4zLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZ2xvYmFsXG4gICAgICogQHBhcmFtIHtpbXBsZW1lbnRhdGlvbkNhbGxiYWNrfSBbZnVuY3Rpb25dIEZ1bmN0aW9uIHRoYXQgY29udGFpbnMgdGhlIGNvZGUgdG8gdGVhcmRvd24geW91ciBzcGVjcy5cbiAgICAgKiBAcGFyYW0ge0ludH0gW3RpbWVvdXQ9e0BsaW5rIGphc21pbmUuREVGQVVMVF9USU1FT1VUX0lOVEVSVkFMfV0gQ3VzdG9tIHRpbWVvdXQgZm9yIGFuIGFzeW5jIGFmdGVyRWFjaC5cbiAgICAgKiBAc2VlIGFzeW5jXG4gICAgICovXG4gICAgYWZ0ZXJFYWNoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBlbnYuYWZ0ZXJFYWNoLmFwcGx5KGVudiwgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUnVuIHNvbWUgc2hhcmVkIHNldHVwIG9uY2UgYmVmb3JlIGFsbCBvZiB0aGUgc3BlY3MgaW4gdGhlIHtAbGluayBkZXNjcmliZX0gYXJlIHJ1bi5cbiAgICAgKlxuICAgICAqIF9Ob3RlOl8gQmUgY2FyZWZ1bCwgc2hhcmluZyB0aGUgc2V0dXAgZnJvbSBhIGJlZm9yZUFsbCBtYWtlcyBpdCBlYXN5IHRvIGFjY2lkZW50YWxseSBsZWFrIHN0YXRlIGJldHdlZW4geW91ciBzcGVjcyBzbyB0aGF0IHRoZXkgZXJyb25lb3VzbHkgcGFzcyBvciBmYWlsLlxuICAgICAqIEBuYW1lIGJlZm9yZUFsbFxuICAgICAqIEBzaW5jZSAyLjEuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBnbG9iYWxcbiAgICAgKiBAcGFyYW0ge2ltcGxlbWVudGF0aW9uQ2FsbGJhY2t9IFtmdW5jdGlvbl0gRnVuY3Rpb24gdGhhdCBjb250YWlucyB0aGUgY29kZSB0byBzZXR1cCB5b3VyIHNwZWNzLlxuICAgICAqIEBwYXJhbSB7SW50fSBbdGltZW91dD17QGxpbmsgamFzbWluZS5ERUZBVUxUX1RJTUVPVVRfSU5URVJWQUx9XSBDdXN0b20gdGltZW91dCBmb3IgYW4gYXN5bmMgYmVmb3JlQWxsLlxuICAgICAqIEBzZWUgYXN5bmNcbiAgICAgKi9cbiAgICBiZWZvcmVBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGVudi5iZWZvcmVBbGwuYXBwbHkoZW52LCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSdW4gc29tZSBzaGFyZWQgdGVhcmRvd24gb25jZSBhZnRlciBhbGwgb2YgdGhlIHNwZWNzIGluIHRoZSB7QGxpbmsgZGVzY3JpYmV9IGFyZSBydW4uXG4gICAgICpcbiAgICAgKiBfTm90ZTpfIEJlIGNhcmVmdWwsIHNoYXJpbmcgdGhlIHRlYXJkb3duIGZyb20gYSBhZnRlckFsbCBtYWtlcyBpdCBlYXN5IHRvIGFjY2lkZW50YWxseSBsZWFrIHN0YXRlIGJldHdlZW4geW91ciBzcGVjcyBzbyB0aGF0IHRoZXkgZXJyb25lb3VzbHkgcGFzcyBvciBmYWlsLlxuICAgICAqIEBuYW1lIGFmdGVyQWxsXG4gICAgICogQHNpbmNlIDIuMS4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGdsb2JhbFxuICAgICAqIEBwYXJhbSB7aW1wbGVtZW50YXRpb25DYWxsYmFja30gW2Z1bmN0aW9uXSBGdW5jdGlvbiB0aGF0IGNvbnRhaW5zIHRoZSBjb2RlIHRvIHRlYXJkb3duIHlvdXIgc3BlY3MuXG4gICAgICogQHBhcmFtIHtJbnR9IFt0aW1lb3V0PXtAbGluayBqYXNtaW5lLkRFRkFVTFRfVElNRU9VVF9JTlRFUlZBTH1dIEN1c3RvbSB0aW1lb3V0IGZvciBhbiBhc3luYyBhZnRlckFsbC5cbiAgICAgKiBAc2VlIGFzeW5jXG4gICAgICovXG4gICAgYWZ0ZXJBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGVudi5hZnRlckFsbC5hcHBseShlbnYsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgYSB1c2VyLWRlZmluZWQgcHJvcGVydHkgdGhhdCB3aWxsIGJlIHByb3ZpZGVkIHRvIHJlcG9ydGVycyBhcyBwYXJ0IG9mIHRoZSBwcm9wZXJ0aWVzIGZpZWxkIG9mIHtAbGluayBTcGVjUmVzdWx0fVxuICAgICAqIEBuYW1lIHNldFNwZWNQcm9wZXJ0eVxuICAgICAqIEBzaW5jZSAzLjYuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICovXG4gICAgc2V0U3BlY1Byb3BlcnR5OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gZW52LnNldFNwZWNQcm9wZXJ0eShrZXksIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIHVzZXItZGVmaW5lZCBwcm9wZXJ0eSB0aGF0IHdpbGwgYmUgcHJvdmlkZWQgdG8gcmVwb3J0ZXJzIGFzIHBhcnQgb2YgdGhlIHByb3BlcnRpZXMgZmllbGQgb2Yge0BsaW5rIFN1aXRlUmVzdWx0fVxuICAgICAqIEBuYW1lIHNldFN1aXRlUHJvcGVydHlcbiAgICAgKiBAc2luY2UgMy42LjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAqL1xuICAgIHNldFN1aXRlUHJvcGVydHk6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBlbnYuc2V0U3VpdGVQcm9wZXJ0eShrZXksIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGV4cGVjdGF0aW9uIGZvciBhIHNwZWMuXG4gICAgICogQG5hbWUgZXhwZWN0XG4gICAgICogQHNpbmNlIDEuMy4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGdsb2JhbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY3R1YWwgLSBBY3R1YWwgY29tcHV0ZWQgdmFsdWUgdG8gdGVzdCBleHBlY3RhdGlvbnMgYWdhaW5zdC5cbiAgICAgKiBAcmV0dXJuIHttYXRjaGVyc31cbiAgICAgKi9cbiAgICBleHBlY3Q6IGZ1bmN0aW9uKGFjdHVhbCkge1xuICAgICAgcmV0dXJuIGVudi5leHBlY3QoYWN0dWFsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGFzeW5jaHJvbm91cyBleHBlY3RhdGlvbiBmb3IgYSBzcGVjLiBOb3RlIHRoYXQgdGhlIG1hdGNoZXJzXG4gICAgICogdGhhdCBhcmUgcHJvdmlkZWQgYnkgYW4gYXN5bmNocm9ub3VzIGV4cGVjdGF0aW9uIGFsbCByZXR1cm4gcHJvbWlzZXNcbiAgICAgKiB3aGljaCBtdXN0IGJlIGVpdGhlciByZXR1cm5lZCBmcm9tIHRoZSBzcGVjIG9yIHdhaXRlZCBmb3IgdXNpbmcgYGF3YWl0YFxuICAgICAqIGluIG9yZGVyIGZvciBKYXNtaW5lIHRvIGFzc29jaWF0ZSB0aGVtIHdpdGggdGhlIGNvcnJlY3Qgc3BlYy5cbiAgICAgKiBAbmFtZSBleHBlY3RBc3luY1xuICAgICAqIEBzaW5jZSAzLjMuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBnbG9iYWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWN0dWFsIC0gQWN0dWFsIGNvbXB1dGVkIHZhbHVlIHRvIHRlc3QgZXhwZWN0YXRpb25zIGFnYWluc3QuXG4gICAgICogQHJldHVybiB7YXN5bmMtbWF0Y2hlcnN9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBhd2FpdCBleHBlY3RBc3luYyhzb21lUHJvbWlzZSkudG9CZVJlc29sdmVkKCk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiByZXR1cm4gZXhwZWN0QXN5bmMoc29tZVByb21pc2UpLnRvQmVSZXNvbHZlZCgpO1xuICAgICAqL1xuICAgIGV4cGVjdEFzeW5jOiBmdW5jdGlvbihhY3R1YWwpIHtcbiAgICAgIHJldHVybiBlbnYuZXhwZWN0QXN5bmMoYWN0dWFsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFyayBhIHNwZWMgYXMgcGVuZGluZywgZXhwZWN0YXRpb24gcmVzdWx0cyB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICogQG5hbWUgcGVuZGluZ1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBnbG9iYWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIC0gUmVhc29uIHRoZSBzcGVjIGlzIHBlbmRpbmcuXG4gICAgICovXG4gICAgcGVuZGluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZW52LnBlbmRpbmcuYXBwbHkoZW52LCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeHBsaWNpdGx5IG1hcmsgYSBzcGVjIGFzIGZhaWxlZC5cbiAgICAgKiBAbmFtZSBmYWlsXG4gICAgICogQHNpbmNlIDIuMS4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGdsb2JhbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEVycm9yfSBbZXJyb3JdIC0gUmVhc29uIGZvciB0aGUgZmFpbHVyZS5cbiAgICAgKi9cbiAgICBmYWlsOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBlbnYuZmFpbC5hcHBseShlbnYsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc3RhbGwgYSBzcHkgb250byBhbiBleGlzdGluZyBvYmplY3QuXG4gICAgICogQG5hbWUgc3B5T25cbiAgICAgKiBAc2luY2UgMS4zLjBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZ2xvYmFsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIFRoZSBvYmplY3QgdXBvbiB3aGljaCB0byBpbnN0YWxsIHRoZSB7QGxpbmsgU3B5fS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdG8gcmVwbGFjZSB3aXRoIGEge0BsaW5rIFNweX0uXG4gICAgICogQHJldHVybnMge1NweX1cbiAgICAgKi9cbiAgICBzcHlPbjogZnVuY3Rpb24ob2JqLCBtZXRob2ROYW1lKSB7XG4gICAgICByZXR1cm4gZW52LnNweU9uKG9iaiwgbWV0aG9kTmFtZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc3RhbGwgYSBzcHkgb24gYSBwcm9wZXJ0eSBpbnN0YWxsZWQgd2l0aCBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBvbnRvIGFuIGV4aXN0aW5nIG9iamVjdC5cbiAgICAgKiBAbmFtZSBzcHlPblByb3BlcnR5XG4gICAgICogQHNpbmNlIDIuNi4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGdsb2JhbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBUaGUgb2JqZWN0IHVwb24gd2hpY2ggdG8gaW5zdGFsbCB0aGUge0BsaW5rIFNweX1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHJlcGxhY2Ugd2l0aCBhIHtAbGluayBTcHl9LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbYWNjZXNzVHlwZT1nZXRdIC0gVGhlIGFjY2VzcyB0eXBlIChnZXR8c2V0KSBvZiB0aGUgcHJvcGVydHkgdG8ge0BsaW5rIFNweX0gb24uXG4gICAgICogQHJldHVybnMge1NweX1cbiAgICAgKi9cbiAgICBzcHlPblByb3BlcnR5OiBmdW5jdGlvbihvYmosIG1ldGhvZE5hbWUsIGFjY2Vzc1R5cGUpIHtcbiAgICAgIHJldHVybiBlbnYuc3B5T25Qcm9wZXJ0eShvYmosIG1ldGhvZE5hbWUsIGFjY2Vzc1R5cGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnN0YWxscyBzcGllcyBvbiBhbGwgd3JpdGFibGUgYW5kIGNvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdC5cbiAgICAgKiBAbmFtZSBzcHlPbkFsbEZ1bmN0aW9uc1xuICAgICAqIEBzaW5jZSAzLjIuMVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBnbG9iYWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gVGhlIG9iamVjdCB1cG9uIHdoaWNoIHRvIGluc3RhbGwgdGhlIHtAbGluayBTcHl9c1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZU5vbkVudW1lcmFibGUgLSBXaGV0aGVyIG9yIG5vdCB0byBhZGQgc3BpZXMgdG8gbm9uLWVudW1lcmFibGUgcHJvcGVydGllc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBzcGllZCBvYmplY3RcbiAgICAgKi9cbiAgICBzcHlPbkFsbEZ1bmN0aW9uczogZnVuY3Rpb24ob2JqLCBpbmNsdWRlTm9uRW51bWVyYWJsZSkge1xuICAgICAgcmV0dXJuIGVudi5zcHlPbkFsbEZ1bmN0aW9ucyhvYmosIGluY2x1ZGVOb25FbnVtZXJhYmxlKTtcbiAgICB9LFxuXG4gICAganNBcGlSZXBvcnRlcjogbmV3IGphc21pbmUuSnNBcGlSZXBvcnRlcih7XG4gICAgICB0aW1lcjogbmV3IGphc21pbmUuVGltZXIoKVxuICAgIH0pLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZSBqYXNtaW5lXG4gICAgICovXG4gICAgamFzbWluZTogamFzbWluZVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBjdXN0b20gZXF1YWxpdHkgdGVzdGVyIGZvciB0aGUgY3VycmVudCBzY29wZSBvZiBzcGVjcy5cbiAgICpcbiAgICogX05vdGU6XyBUaGlzIGlzIG9ubHkgY2FsbGFibGUgZnJvbSB3aXRoaW4gYSB7QGxpbmsgYmVmb3JlRWFjaH0sIHtAbGluayBpdH0sIG9yIHtAbGluayBiZWZvcmVBbGx9LlxuICAgKiBAbmFtZSBqYXNtaW5lLmFkZEN1c3RvbUVxdWFsaXR5VGVzdGVyXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gdGVzdGVyIC0gQSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0d28gYXJndW1lbnRzIHRvIGNvbXBhcmUgYW5kIHJldHVybnMgYSBgdHJ1ZWAgb3IgYGZhbHNlYCBjb21wYXJpc29uIHJlc3VsdCBpZiBpdCBrbm93cyBob3cgdG8gY29tcGFyZSB0aGVtLCBhbmQgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlLlxuICAgKiBAc2VlIGN1c3RvbV9lcXVhbGl0eVxuICAgKi9cbiAgamFzbWluZS5hZGRDdXN0b21FcXVhbGl0eVRlc3RlciA9IGZ1bmN0aW9uKHRlc3Rlcikge1xuICAgIGVudi5hZGRDdXN0b21FcXVhbGl0eVRlc3Rlcih0ZXN0ZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgY3VzdG9tIG1hdGNoZXJzIGZvciB0aGUgY3VycmVudCBzY29wZSBvZiBzcGVjcy5cbiAgICpcbiAgICogX05vdGU6XyBUaGlzIGlzIG9ubHkgY2FsbGFibGUgZnJvbSB3aXRoaW4gYSB7QGxpbmsgYmVmb3JlRWFjaH0sIHtAbGluayBpdH0sIG9yIHtAbGluayBiZWZvcmVBbGx9LlxuICAgKiBAbmFtZSBqYXNtaW5lLmFkZE1hdGNoZXJzXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG1hdGNoZXJzIC0gS2V5cyBmcm9tIHRoaXMgb2JqZWN0IHdpbGwgYmUgdGhlIG5ldyBtYXRjaGVyIG5hbWVzLlxuICAgKiBAc2VlIGN1c3RvbV9tYXRjaGVyXG4gICAqL1xuICBqYXNtaW5lLmFkZE1hdGNoZXJzID0gZnVuY3Rpb24obWF0Y2hlcnMpIHtcbiAgICByZXR1cm4gZW52LmFkZE1hdGNoZXJzKG1hdGNoZXJzKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGN1c3RvbSBhc3luYyBtYXRjaGVycyBmb3IgdGhlIGN1cnJlbnQgc2NvcGUgb2Ygc3BlY3MuXG4gICAqXG4gICAqIF9Ob3RlOl8gVGhpcyBpcyBvbmx5IGNhbGxhYmxlIGZyb20gd2l0aGluIGEge0BsaW5rIGJlZm9yZUVhY2h9LCB7QGxpbmsgaXR9LCBvciB7QGxpbmsgYmVmb3JlQWxsfS5cbiAgICogQG5hbWUgamFzbWluZS5hZGRBc3luY01hdGNoZXJzXG4gICAqIEBzaW5jZSAzLjUuMFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG1hdGNoZXJzIC0gS2V5cyBmcm9tIHRoaXMgb2JqZWN0IHdpbGwgYmUgdGhlIG5ldyBhc3luYyBtYXRjaGVyIG5hbWVzLlxuICAgKiBAc2VlIGN1c3RvbV9tYXRjaGVyXG4gICAqL1xuICBqYXNtaW5lLmFkZEFzeW5jTWF0Y2hlcnMgPSBmdW5jdGlvbihtYXRjaGVycykge1xuICAgIHJldHVybiBlbnYuYWRkQXN5bmNNYXRjaGVycyhtYXRjaGVycyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIGN1c3RvbSBvYmplY3QgZm9ybWF0dGVyIGZvciB0aGUgY3VycmVudCBzY29wZSBvZiBzcGVjcy5cbiAgICpcbiAgICogX05vdGU6XyBUaGlzIGlzIG9ubHkgY2FsbGFibGUgZnJvbSB3aXRoaW4gYSB7QGxpbmsgYmVmb3JlRWFjaH0sIHtAbGluayBpdH0sIG9yIHtAbGluayBiZWZvcmVBbGx9LlxuICAgKiBAbmFtZSBqYXNtaW5lLmFkZEN1c3RvbU9iamVjdEZvcm1hdHRlclxuICAgKiBAc2luY2UgMy42LjBcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZvcm1hdHRlciAtIEEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgYSB2YWx1ZSB0byBmb3JtYXQgYW5kIHJldHVybnMgYSBzdHJpbmcgaWYgaXQga25vd3MgaG93IHRvIGZvcm1hdCBpdCwgYW5kIGB1bmRlZmluZWRgIG90aGVyd2lzZS5cbiAgICogQHNlZSBjdXN0b21fb2JqZWN0X2Zvcm1hdHRlcnNcbiAgICovXG4gIGphc21pbmUuYWRkQ3VzdG9tT2JqZWN0Rm9ybWF0dGVyID0gZnVuY3Rpb24oZm9ybWF0dGVyKSB7XG4gICAgcmV0dXJuIGVudi5hZGRDdXN0b21PYmplY3RGb3JtYXR0ZXIoZm9ybWF0dGVyKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50bHkgYm9vdGVkIG1vY2sge0Nsb2NrfSBmb3IgdGhpcyBKYXNtaW5lIGVudmlyb25tZW50LlxuICAgKiBAbmFtZSBqYXNtaW5lLmNsb2NrXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHJldHVybnMge0Nsb2NrfVxuICAgKi9cbiAgamFzbWluZS5jbG9jayA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlbnYuY2xvY2s7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGJhcmUge0BsaW5rIFNweX0gb2JqZWN0LiBUaGlzIHdvbid0IGJlIGluc3RhbGxlZCBhbnl3aGVyZSBhbmQgd2lsbCBub3QgaGF2ZSBhbnkgaW1wbGVtZW50YXRpb24gYmVoaW5kIGl0LlxuICAgKiBAbmFtZSBqYXNtaW5lLmNyZWF0ZVNweVxuICAgKiBAc2luY2UgMS4zLjBcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZV0gLSBOYW1lIHRvIGdpdmUgdGhlIHNweS4gVGhpcyB3aWxsIGJlIGRpc3BsYXllZCBpbiBmYWlsdXJlIG1lc3NhZ2VzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3JpZ2luYWxGbl0gLSBGdW5jdGlvbiB0byBhY3QgYXMgdGhlIHJlYWwgaW1wbGVtZW50YXRpb24uXG4gICAqIEByZXR1cm4ge1NweX1cbiAgICovXG4gIGphc21pbmUuY3JlYXRlU3B5ID0gZnVuY3Rpb24obmFtZSwgb3JpZ2luYWxGbikge1xuICAgIHJldHVybiBlbnYuY3JlYXRlU3B5KG5hbWUsIG9yaWdpbmFsRm4pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gb2JqZWN0IHdpdGggbXVsdGlwbGUge0BsaW5rIFNweX1zIGFzIGl0cyBtZW1iZXJzLlxuICAgKiBAbmFtZSBqYXNtaW5lLmNyZWF0ZVNweU9ialxuICAgKiBAc2luY2UgMS4zLjBcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbYmFzZU5hbWVdIC0gQmFzZSBuYW1lIGZvciB0aGUgc3BpZXMgaW4gdGhlIG9iamVjdC5cbiAgICogQHBhcmFtIHtTdHJpbmdbXXxPYmplY3R9IG1ldGhvZE5hbWVzIC0gQXJyYXkgb2YgbWV0aG9kIG5hbWVzIHRvIGNyZWF0ZSBzcGllcyBmb3IsIG9yIE9iamVjdCB3aG9zZSBrZXlzIHdpbGwgYmUgbWV0aG9kIG5hbWVzIGFuZCB2YWx1ZXMgdGhlIHtAbGluayBTcHkjYW5kI3JldHVyblZhbHVlfHJldHVyblZhbHVlfS5cbiAgICogQHBhcmFtIHtTdHJpbmdbXXxPYmplY3R9IFtwcm9wZXJ0eU5hbWVzXSAtIEFycmF5IG9mIHByb3BlcnR5IG5hbWVzIHRvIGNyZWF0ZSBzcGllcyBmb3IsIG9yIE9iamVjdCB3aG9zZSBrZXlzIHdpbGwgYmUgcHJvcGVydHluYW1lcyBhbmQgdmFsdWVzIHRoZSB7QGxpbmsgU3B5I2FuZCNyZXR1cm5WYWx1ZXxyZXR1cm5WYWx1ZX0uXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGphc21pbmUuY3JlYXRlU3B5T2JqID0gZnVuY3Rpb24oYmFzZU5hbWUsIG1ldGhvZE5hbWVzLCBwcm9wZXJ0eU5hbWVzKSB7XG4gICAgcmV0dXJuIGVudi5jcmVhdGVTcHlPYmooYmFzZU5hbWUsIG1ldGhvZE5hbWVzLCBwcm9wZXJ0eU5hbWVzKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgY3VzdG9tIHNweSBzdHJhdGVneSBmb3IgdGhlIGN1cnJlbnQgc2NvcGUgb2Ygc3BlY3MuXG4gICAqXG4gICAqIF9Ob3RlOl8gVGhpcyBpcyBvbmx5IGNhbGxhYmxlIGZyb20gd2l0aGluIGEge0BsaW5rIGJlZm9yZUVhY2h9LCB7QGxpbmsgaXR9LCBvciB7QGxpbmsgYmVmb3JlQWxsfS5cbiAgICogQG5hbWUgamFzbWluZS5hZGRTcHlTdHJhdGVneVxuICAgKiBAc2luY2UgMy41LjBcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHN0cmF0ZWd5IChpLmUuIHdoYXQgeW91IGNhbGwgZnJvbSBgYW5kYClcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZmFjdG9yeSAtIEZhY3RvcnkgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBwbGFuIHRvIGJlIGV4ZWN1dGVkLlxuICAgKi9cbiAgamFzbWluZS5hZGRTcHlTdHJhdGVneSA9IGZ1bmN0aW9uKG5hbWUsIGZhY3RvcnkpIHtcbiAgICByZXR1cm4gZW52LmFkZFNweVN0cmF0ZWd5KG5hbWUsIGZhY3RvcnkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRlZmF1bHQgc3B5IHN0cmF0ZWd5IGZvciB0aGUgY3VycmVudCBzY29wZSBvZiBzcGVjcy5cbiAgICpcbiAgICogX05vdGU6XyBUaGlzIGlzIG9ubHkgY2FsbGFibGUgZnJvbSB3aXRoaW4gYSB7QGxpbmsgYmVmb3JlRWFjaH0sIHtAbGluayBpdH0sIG9yIHtAbGluayBiZWZvcmVBbGx9LlxuICAgKiBAbmFtZSBqYXNtaW5lLnNldERlZmF1bHRTcHlTdHJhdGVneVxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZGVmYXVsdFN0cmF0ZWd5Rm4gLSBhIGZ1bmN0aW9uIHRoYXQgYXNzaWducyBhIHN0cmF0ZWd5XG4gICAqIEBleGFtcGxlXG4gICAqIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG4gICAqICAgamFzbWluZS5zZXREZWZhdWx0U3B5U3RyYXRlZ3koYW5kID0+IGFuZC5yZXR1cm5WYWx1ZSh0cnVlKSk7XG4gICAqIH0pO1xuICAgKi9cbiAgamFzbWluZS5zZXREZWZhdWx0U3B5U3RyYXRlZ3kgPSBmdW5jdGlvbihkZWZhdWx0U3RyYXRlZ3lGbikge1xuICAgIHJldHVybiBlbnYuc2V0RGVmYXVsdFNweVN0cmF0ZWd5KGRlZmF1bHRTdHJhdGVneUZuKTtcbiAgfTtcblxuICByZXR1cm4gamFzbWluZUludGVyZmFjZTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuU2tpcEFmdGVyQmVmb3JlQWxsRXJyb3JQb2xpY3kgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBTa2lwQWZ0ZXJCZWZvcmVBbGxFcnJvclBvbGljeShxdWV1ZWFibGVGbnMpIHtcbiAgICB0aGlzLnF1ZXVlYWJsZUZuc18gPSBxdWV1ZWFibGVGbnM7XG4gICAgdGhpcy5za2lwcGluZ18gPSBmYWxzZTtcbiAgfVxuXG4gIFNraXBBZnRlckJlZm9yZUFsbEVycm9yUG9saWN5LnByb3RvdHlwZS5za2lwVG8gPSBmdW5jdGlvbihsYXN0UmFuRm5JeCkge1xuICAgIGlmICh0aGlzLnNraXBwaW5nXykge1xuICAgICAgcmV0dXJuIHRoaXMubmV4dEFmdGVyQWxsQWZ0ZXJfKGxhc3RSYW5Gbkl4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxhc3RSYW5Gbkl4ICsgMTtcbiAgICB9XG4gIH07XG5cbiAgU2tpcEFmdGVyQmVmb3JlQWxsRXJyb3JQb2xpY3kucHJvdG90eXBlLm5leHRBZnRlckFsbEFmdGVyXyA9IGZ1bmN0aW9uKGkpIHtcbiAgICBmb3IgKFxuICAgICAgaSsrO1xuICAgICAgaSA8IHRoaXMucXVldWVhYmxlRm5zXy5sZW5ndGggJiZcbiAgICAgIHRoaXMucXVldWVhYmxlRm5zX1tpXS50eXBlICE9PSAnYWZ0ZXJBbGwnO1xuICAgICAgaSsrXG4gICAgKSB7fVxuICAgIHJldHVybiBpO1xuICB9O1xuXG4gIFNraXBBZnRlckJlZm9yZUFsbEVycm9yUG9saWN5LnByb3RvdHlwZS5mbkVycm9yZWQgPSBmdW5jdGlvbihmbkl4KSB7XG4gICAgaWYgKHRoaXMucXVldWVhYmxlRm5zX1tmbkl4XS50eXBlID09PSAnYmVmb3JlQWxsJykge1xuICAgICAgdGhpcy5za2lwcGluZ18gPSB0cnVlO1xuICAgICAgLy8gRmFpbHVyZXMgbmVlZCB0byBiZSByZXBvcnRlZCBmb3IgZWFjaCBjb250YWluZWQgc3BlYy4gQnV0IHdlIGNhbid0IGRvXG4gICAgICAvLyB0aGF0IGZyb20gaGVyZSBiZWNhdXNlIHJlcG9ydGluZyBpcyBhc3luYy4gVGhpcyBmdW5jdGlvbiBpc24ndCBhc3luY1xuICAgICAgLy8gKGFuZCBjYW4ndCBiZSB3aXRob3V0IGdyZWF0bHkgY29tcGxpY2F0aW5nIFF1ZXVlUnVubmVyKS4gTWFyayB0aGVcbiAgICAgIC8vIGZhaWx1cmUgc28gdGhhdCB0aGUgY29kZSB0aGF0IHJlcG9ydHMgdGhlIHN1aXRlIHJlc3VsdCAod2hpY2ggaXNcbiAgICAgIC8vIGFscmVhZHkgYXN5bmMpIGNhbiBkZXRlY3QgdGhlIGZhaWx1cmUgYW5kIHJlcG9ydCB0aGUgc3BlY3MuXG4gICAgICB0aGlzLnF1ZXVlYWJsZUZuc19bZm5JeF0uc3VpdGUuaGFkQmVmb3JlQWxsRmFpbHVyZSA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBTa2lwQWZ0ZXJCZWZvcmVBbGxFcnJvclBvbGljeTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuU3B5ID0gZnVuY3Rpb24oaiQpIHtcbiAgdmFyIG5leHRPcmRlciA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgb3JkZXIgPSAwO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG9yZGVyKys7XG4gICAgfTtcbiAgfSkoKTtcblxuICAvKipcbiAgICogQGNsYXNzZGVzYyBfTm90ZTpfIERvIG5vdCBjb25zdHJ1Y3QgdGhpcyBkaXJlY3RseS4gVXNlIHtAbGluayBzcHlPbn0sXG4gICAqIHtAbGluayBzcHlPblByb3BlcnR5fSwge0BsaW5rIGphc21pbmUuY3JlYXRlU3B5fSwgb3JcbiAgICoge0BsaW5rIGphc21pbmUuY3JlYXRlU3B5T2JqfSBpbnN0ZWFkLlxuICAgKiBAY2xhc3MgU3B5XG4gICAqIEBoaWRlY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIFNweShuYW1lLCBtYXRjaGVyc1V0aWwsIG9wdGlvbmFscykge1xuICAgIGNvbnN0IHsgb3JpZ2luYWxGbiwgY3VzdG9tU3RyYXRlZ2llcywgZGVmYXVsdFN0cmF0ZWd5Rm4gfSA9IG9wdGlvbmFscyB8fCB7fTtcblxuICAgIHZhciBudW1BcmdzID0gdHlwZW9mIG9yaWdpbmFsRm4gPT09ICdmdW5jdGlvbicgPyBvcmlnaW5hbEZuLmxlbmd0aCA6IDAsXG4gICAgICB3cmFwcGVyID0gbWFrZUZ1bmMobnVtQXJncywgZnVuY3Rpb24oY29udGV4dCwgYXJncywgaW52b2tlTmV3KSB7XG4gICAgICAgIHJldHVybiBzcHkoY29udGV4dCwgYXJncywgaW52b2tlTmV3KTtcbiAgICAgIH0pLFxuICAgICAgc3RyYXRlZ3lEaXNwYXRjaGVyID0gbmV3IFNweVN0cmF0ZWd5RGlzcGF0Y2hlcihcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgZm46IG9yaWdpbmFsRm4sXG4gICAgICAgICAgZ2V0U3B5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY3VzdG9tU3RyYXRlZ2llczogY3VzdG9tU3RyYXRlZ2llc1xuICAgICAgICB9LFxuICAgICAgICBtYXRjaGVyc1V0aWxcbiAgICAgICksXG4gICAgICBjYWxsVHJhY2tlciA9IG5ldyBqJC5DYWxsVHJhY2tlcigpLFxuICAgICAgc3B5ID0gZnVuY3Rpb24oY29udGV4dCwgYXJncywgaW52b2tlTmV3KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSBTcHkuY2FsbERhdGFcbiAgICAgICAgICogQHByb3BlcnR5IHtvYmplY3R9IG9iamVjdCAtIGB0aGlzYCBjb250ZXh0IGZvciB0aGUgaW52b2NhdGlvbi5cbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGludm9jYXRpb25PcmRlciAtIE9yZGVyIG9mIHRoZSBpbnZvY2F0aW9uLlxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5fSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBwYXNzZWQgZm9yIHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgICogQHByb3BlcnR5IHJldHVyblZhbHVlIC0gVGhlIHZhbHVlIHRoYXQgd2FzIHJldHVybmVkIGZyb20gdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGNhbGxEYXRhID0ge1xuICAgICAgICAgIG9iamVjdDogY29udGV4dCxcbiAgICAgICAgICBpbnZvY2F0aW9uT3JkZXI6IG5leHRPcmRlcigpLFxuICAgICAgICAgIGFyZ3M6IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcmdzKVxuICAgICAgICB9O1xuXG4gICAgICAgIGNhbGxUcmFja2VyLnRyYWNrKGNhbGxEYXRhKTtcbiAgICAgICAgdmFyIHJldHVyblZhbHVlID0gc3RyYXRlZ3lEaXNwYXRjaGVyLmV4ZWMoY29udGV4dCwgYXJncywgaW52b2tlTmV3KTtcbiAgICAgICAgY2FsbERhdGEucmV0dXJuVmFsdWUgPSByZXR1cm5WYWx1ZTtcblxuICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWFrZUZ1bmMobGVuZ3RoLCBmbikge1xuICAgICAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiB3cmFwMShhKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4odGhpcywgYXJndW1lbnRzLCB0aGlzIGluc3RhbmNlb2Ygd3JhcDEpO1xuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gd3JhcDIoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHRoaXMsIGFyZ3VtZW50cywgdGhpcyBpbnN0YW5jZW9mIHdyYXAyKTtcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAzKGEsIGIsIGMpIHtcbiAgICAgICAgICAgIHJldHVybiBmbih0aGlzLCBhcmd1bWVudHMsIHRoaXMgaW5zdGFuY2VvZiB3cmFwMyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiB3cmFwNChhLCBiLCBjLCBkKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4odGhpcywgYXJndW1lbnRzLCB0aGlzIGluc3RhbmNlb2Ygd3JhcDQpO1xuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gd3JhcDUoYSwgYiwgYywgZCwgZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHRoaXMsIGFyZ3VtZW50cywgdGhpcyBpbnN0YW5jZW9mIHdyYXA1KTtcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHdyYXA2KGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAgICAgICAgIHJldHVybiBmbih0aGlzLCBhcmd1bWVudHMsIHRoaXMgaW5zdGFuY2VvZiB3cmFwNik7XG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiB3cmFwNyhhLCBiLCBjLCBkLCBlLCBmLCBnKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4odGhpcywgYXJndW1lbnRzLCB0aGlzIGluc3RhbmNlb2Ygd3JhcDcpO1xuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gd3JhcDgoYSwgYiwgYywgZCwgZSwgZiwgZywgaCkge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHRoaXMsIGFyZ3VtZW50cywgdGhpcyBpbnN0YW5jZW9mIHdyYXA4KTtcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHdyYXA5KGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBmbih0aGlzLCBhcmd1bWVudHMsIHRoaXMgaW5zdGFuY2VvZiB3cmFwOSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICAgICAgICAgIHJldHVybiBmbih0aGlzLCBhcmd1bWVudHMsIHRoaXMgaW5zdGFuY2VvZiB3cmFwKTtcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIHByb3AgaW4gb3JpZ2luYWxGbikge1xuICAgICAgaWYgKHByb3AgPT09ICdhbmQnIHx8IHByb3AgPT09ICdjYWxscycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiSmFzbWluZSBzcGllcyB3b3VsZCBvdmVyd3JpdGUgdGhlICdhbmQnIGFuZCAnY2FsbHMnIHByb3BlcnRpZXMgb24gdGhlIG9iamVjdCBiZWluZyBzcGllZCB1cG9uXCJcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgd3JhcHBlcltwcm9wXSA9IG9yaWdpbmFsRm5bcHJvcF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7U3B5U3RyYXRlZ3l9IC0gQWNjZXNzZXMgdGhlIGRlZmF1bHQgc3RyYXRlZ3kgZm9yIHRoZSBzcHkuIFRoaXMgc3RyYXRlZ3kgd2lsbCBiZSB1c2VkXG4gICAgICogd2hlbmV2ZXIgdGhlIHNweSBpcyBjYWxsZWQgd2l0aCBhcmd1bWVudHMgdGhhdCBkb24ndCBtYXRjaCBhbnkgc3RyYXRlZ3lcbiAgICAgKiBjcmVhdGVkIHdpdGgge0BsaW5rIFNweSN3aXRoQXJnc30uXG4gICAgICogQG5hbWUgU3B5I2FuZFxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBleGFtcGxlXG4gICAgICogc3B5T24oc29tZU9iaiwgJ2Z1bmMnKS5hbmQucmV0dXJuVmFsdWUoNDIpO1xuICAgICAqL1xuICAgIHdyYXBwZXIuYW5kID0gc3RyYXRlZ3lEaXNwYXRjaGVyLmFuZDtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgYSBzdHJhdGVneSB0byBiZSB1c2VkIGZvciBjYWxscyB0byB0aGUgc3B5IHRoYXQgaGF2ZSB0aGVcbiAgICAgKiBzcGVjaWZpZWQgYXJndW1lbnRzLlxuICAgICAqIEBuYW1lIFNweSN3aXRoQXJnc1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncyAtIFRoZSBhcmd1bWVudHMgdG8gbWF0Y2hcbiAgICAgKiBAdHlwZSB7U3B5U3RyYXRlZ3l9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBzcHlPbihzb21lT2JqLCAnZnVuYycpLndpdGhBcmdzKDEsIDIsIDMpLmFuZC5yZXR1cm5WYWx1ZSg0Mik7XG4gICAgICogc29tZU9iai5mdW5jKDEsIDIsIDMpOyAvLyByZXR1cm5zIDQyXG4gICAgICovXG4gICAgd3JhcHBlci53aXRoQXJncyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0cmF0ZWd5RGlzcGF0Y2hlci53aXRoQXJncy5hcHBseShzdHJhdGVneURpc3BhdGNoZXIsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICB3cmFwcGVyLmNhbGxzID0gY2FsbFRyYWNrZXI7XG5cbiAgICBpZiAoZGVmYXVsdFN0cmF0ZWd5Rm4pIHtcbiAgICAgIGRlZmF1bHRTdHJhdGVneUZuKHdyYXBwZXIuYW5kKTtcbiAgICB9XG5cbiAgICByZXR1cm4gd3JhcHBlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIFNweVN0cmF0ZWd5RGlzcGF0Y2hlcihzdHJhdGVneUFyZ3MsIG1hdGNoZXJzVXRpbCkge1xuICAgIHZhciBiYXNlU3RyYXRlZ3kgPSBuZXcgaiQuU3B5U3RyYXRlZ3koc3RyYXRlZ3lBcmdzKTtcbiAgICB2YXIgYXJnc1N0cmF0ZWdpZXMgPSBuZXcgU3RyYXRlZ3lEaWN0KGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBqJC5TcHlTdHJhdGVneShzdHJhdGVneUFyZ3MpO1xuICAgIH0sIG1hdGNoZXJzVXRpbCk7XG5cbiAgICB0aGlzLmFuZCA9IGJhc2VTdHJhdGVneTtcblxuICAgIHRoaXMuZXhlYyA9IGZ1bmN0aW9uKHNweSwgYXJncywgaW52b2tlTmV3KSB7XG4gICAgICB2YXIgc3RyYXRlZ3kgPSBhcmdzU3RyYXRlZ2llcy5nZXQoYXJncyk7XG5cbiAgICAgIGlmICghc3RyYXRlZ3kpIHtcbiAgICAgICAgaWYgKGFyZ3NTdHJhdGVnaWVzLmFueSgpICYmICFiYXNlU3RyYXRlZ3kuaXNDb25maWd1cmVkKCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIlNweSAnXCIgK1xuICAgICAgICAgICAgICBzdHJhdGVneUFyZ3MubmFtZSArXG4gICAgICAgICAgICAgIFwiJyByZWNlaXZlZCBhIGNhbGwgd2l0aCBhcmd1bWVudHMgXCIgK1xuICAgICAgICAgICAgICBqJC5iYXNpY1ByZXR0eVByaW50ZXJfKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpKSArXG4gICAgICAgICAgICAgICcgYnV0IGFsbCBjb25maWd1cmVkIHN0cmF0ZWdpZXMgc3BlY2lmeSBvdGhlciBhcmd1bWVudHMuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyYXRlZ3kgPSBiYXNlU3RyYXRlZ3k7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cmF0ZWd5LmV4ZWMoc3B5LCBhcmdzLCBpbnZva2VOZXcpO1xuICAgIH07XG5cbiAgICB0aGlzLndpdGhBcmdzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4geyBhbmQ6IGFyZ3NTdHJhdGVnaWVzLmdldE9yQ3JlYXRlKGFyZ3VtZW50cykgfTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gU3RyYXRlZ3lEaWN0KHN0cmF0ZWd5RmFjdG9yeSwgbWF0Y2hlcnNVdGlsKSB7XG4gICAgdGhpcy5zdHJhdGVnaWVzID0gW107XG4gICAgdGhpcy5zdHJhdGVneUZhY3RvcnkgPSBzdHJhdGVneUZhY3Rvcnk7XG4gICAgdGhpcy5tYXRjaGVyc1V0aWwgPSBtYXRjaGVyc1V0aWw7XG4gIH1cblxuICBTdHJhdGVneURpY3QucHJvdG90eXBlLmFueSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmF0ZWdpZXMubGVuZ3RoID4gMDtcbiAgfTtcblxuICBTdHJhdGVneURpY3QucHJvdG90eXBlLmdldE9yQ3JlYXRlID0gZnVuY3Rpb24oYXJncykge1xuICAgIHZhciBzdHJhdGVneSA9IHRoaXMuZ2V0KGFyZ3MpO1xuXG4gICAgaWYgKCFzdHJhdGVneSkge1xuICAgICAgc3RyYXRlZ3kgPSB0aGlzLnN0cmF0ZWd5RmFjdG9yeSgpO1xuICAgICAgdGhpcy5zdHJhdGVnaWVzLnB1c2goe1xuICAgICAgICBhcmdzOiBhcmdzLFxuICAgICAgICBzdHJhdGVneTogc3RyYXRlZ3lcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJhdGVneTtcbiAgfTtcblxuICBTdHJhdGVneURpY3QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnN0cmF0ZWdpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLm1hdGNoZXJzVXRpbC5lcXVhbHMoYXJncywgdGhpcy5zdHJhdGVnaWVzW2ldLmFyZ3MpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmF0ZWdpZXNbaV0uc3RyYXRlZ3k7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBTcHk7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlNweUZhY3RvcnkgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBTcHlGYWN0b3J5KFxuICAgIGdldEN1c3RvbVN0cmF0ZWdpZXMsXG4gICAgZ2V0RGVmYXVsdFN0cmF0ZWd5Rm4sXG4gICAgZ2V0TWF0Y2hlcnNVdGlsXG4gICkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuY3JlYXRlU3B5ID0gZnVuY3Rpb24obmFtZSwgb3JpZ2luYWxGbikge1xuICAgICAgcmV0dXJuIGokLlNweShuYW1lLCBnZXRNYXRjaGVyc1V0aWwoKSwge1xuICAgICAgICBvcmlnaW5hbEZuLFxuICAgICAgICBjdXN0b21TdHJhdGVnaWVzOiBnZXRDdXN0b21TdHJhdGVnaWVzKCksXG4gICAgICAgIGRlZmF1bHRTdHJhdGVneUZuOiBnZXREZWZhdWx0U3RyYXRlZ3lGbigpXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5jcmVhdGVTcHlPYmogPSBmdW5jdGlvbihiYXNlTmFtZSwgbWV0aG9kTmFtZXMsIHByb3BlcnR5TmFtZXMpIHtcbiAgICAgIHZhciBiYXNlTmFtZUlzQ29sbGVjdGlvbiA9XG4gICAgICAgIGokLmlzT2JqZWN0XyhiYXNlTmFtZSkgfHwgaiQuaXNBcnJheV8oYmFzZU5hbWUpO1xuXG4gICAgICBpZiAoYmFzZU5hbWVJc0NvbGxlY3Rpb24pIHtcbiAgICAgICAgcHJvcGVydHlOYW1lcyA9IG1ldGhvZE5hbWVzO1xuICAgICAgICBtZXRob2ROYW1lcyA9IGJhc2VOYW1lO1xuICAgICAgICBiYXNlTmFtZSA9ICd1bmtub3duJztcbiAgICAgIH1cblxuICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgdmFyIHNweSwgZGVzY3JpcHRvcjtcblxuICAgICAgdmFyIG1ldGhvZHMgPSBub3JtYWxpemVLZXlWYWx1ZXMobWV0aG9kTmFtZXMpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNweSA9IG9ialttZXRob2RzW2ldWzBdXSA9IHNlbGYuY3JlYXRlU3B5KFxuICAgICAgICAgIGJhc2VOYW1lICsgJy4nICsgbWV0aG9kc1tpXVswXVxuICAgICAgICApO1xuICAgICAgICBpZiAobWV0aG9kc1tpXS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgc3B5LmFuZC5yZXR1cm5WYWx1ZShtZXRob2RzW2ldWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcHJvcGVydGllcyA9IG5vcm1hbGl6ZUtleVZhbHVlcyhwcm9wZXJ0eU5hbWVzKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZXNjcmlwdG9yID0ge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBzZWxmLmNyZWF0ZVNweShiYXNlTmFtZSArICcuJyArIHByb3BlcnRpZXNbaV1bMF0gKyAnLmdldCcpLFxuICAgICAgICAgIHNldDogc2VsZi5jcmVhdGVTcHkoYmFzZU5hbWUgKyAnLicgKyBwcm9wZXJ0aWVzW2ldWzBdICsgJy5zZXQnKVxuICAgICAgICB9O1xuICAgICAgICBpZiAocHJvcGVydGllc1tpXS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgZGVzY3JpcHRvci5nZXQuYW5kLnJldHVyblZhbHVlKHByb3BlcnRpZXNbaV1bMV0pO1xuICAgICAgICAgIGRlc2NyaXB0b3Iuc2V0LmFuZC5yZXR1cm5WYWx1ZShwcm9wZXJ0aWVzW2ldWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wZXJ0aWVzW2ldWzBdLCBkZXNjcmlwdG9yKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1ldGhvZHMubGVuZ3RoID09PSAwICYmIHByb3BlcnRpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93ICdjcmVhdGVTcHlPYmogcmVxdWlyZXMgYSBub24tZW1wdHkgYXJyYXkgb3Igb2JqZWN0IG9mIG1ldGhvZCBuYW1lcyB0byBjcmVhdGUgc3BpZXMgZm9yJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplS2V5VmFsdWVzKG9iamVjdCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBpZiAoaiQuaXNBcnJheV8ob2JqZWN0KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2goW29iamVjdFtpXV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaiQuaXNPYmplY3RfKG9iamVjdCkpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goW2tleSwgb2JqZWN0W2tleV1dKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIFNweUZhY3Rvcnk7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlNweVJlZ2lzdHJ5ID0gZnVuY3Rpb24oaiQpIHtcbiAgdmFyIHNweU9uTXNnID0gaiQuZm9ybWF0RXJyb3JNc2coJzxzcHlPbj4nLCAnc3B5T24oPG9iamVjdD4sIDxtZXRob2ROYW1lPiknKTtcbiAgdmFyIHNweU9uUHJvcGVydHlNc2cgPSBqJC5mb3JtYXRFcnJvck1zZyhcbiAgICAnPHNweU9uUHJvcGVydHk+JyxcbiAgICAnc3B5T25Qcm9wZXJ0eSg8b2JqZWN0PiwgPHByb3BOYW1lPiwgW2FjY2Vzc1R5cGVdKSdcbiAgKTtcblxuICBmdW5jdGlvbiBTcHlSZWdpc3RyeShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGdsb2JhbCA9IG9wdGlvbnMuZ2xvYmFsIHx8IGokLmdldEdsb2JhbCgpO1xuICAgIHZhciBjcmVhdGVTcHkgPSBvcHRpb25zLmNyZWF0ZVNweTtcbiAgICB2YXIgY3VycmVudFNwaWVzID1cbiAgICAgIG9wdGlvbnMuY3VycmVudFNwaWVzIHx8XG4gICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfTtcblxuICAgIHRoaXMuYWxsb3dSZXNweSA9IGZ1bmN0aW9uKGFsbG93KSB7XG4gICAgICB0aGlzLnJlc3B5ID0gYWxsb3c7XG4gICAgfTtcblxuICAgIHRoaXMuc3B5T24gPSBmdW5jdGlvbihvYmosIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBnZXRFcnJvck1zZyA9IHNweU9uTXNnO1xuXG4gICAgICBpZiAoaiQudXRpbC5pc1VuZGVmaW5lZChvYmopIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgZ2V0RXJyb3JNc2coXG4gICAgICAgICAgICAnY291bGQgbm90IGZpbmQgYW4gb2JqZWN0IHRvIHNweSB1cG9uIGZvciAnICsgbWV0aG9kTmFtZSArICcoKSdcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChqJC51dGlsLmlzVW5kZWZpbmVkKG1ldGhvZE5hbWUpIHx8IG1ldGhvZE5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGdldEVycm9yTXNnKCdObyBtZXRob2QgbmFtZSBzdXBwbGllZCcpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGokLnV0aWwuaXNVbmRlZmluZWQob2JqW21ldGhvZE5hbWVdKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0RXJyb3JNc2cobWV0aG9kTmFtZSArICcoKSBtZXRob2QgZG9lcyBub3QgZXhpc3QnKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmpbbWV0aG9kTmFtZV0gJiYgaiQuaXNTcHkob2JqW21ldGhvZE5hbWVdKSkge1xuICAgICAgICBpZiAodGhpcy5yZXNweSkge1xuICAgICAgICAgIHJldHVybiBvYmpbbWV0aG9kTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgZ2V0RXJyb3JNc2cobWV0aG9kTmFtZSArICcgaGFzIGFscmVhZHkgYmVlbiBzcGllZCB1cG9uJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIG1ldGhvZE5hbWUpO1xuXG4gICAgICBpZiAoZGVzY3JpcHRvciAmJiAhKGRlc2NyaXB0b3Iud3JpdGFibGUgfHwgZGVzY3JpcHRvci5zZXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBnZXRFcnJvck1zZyhtZXRob2ROYW1lICsgJyBpcyBub3QgZGVjbGFyZWQgd3JpdGFibGUgb3IgaGFzIG5vIHNldHRlcicpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHZhciBvcmlnaW5hbE1ldGhvZCA9IG9ialttZXRob2ROYW1lXSxcbiAgICAgICAgc3BpZWRNZXRob2QgPSBjcmVhdGVTcHkobWV0aG9kTmFtZSwgb3JpZ2luYWxNZXRob2QpLFxuICAgICAgICByZXN0b3JlU3RyYXRlZ3k7XG5cbiAgICAgIGlmIChcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgbWV0aG9kTmFtZSkgfHxcbiAgICAgICAgKG9iaiA9PT0gZ2xvYmFsICYmIG1ldGhvZE5hbWUgPT09ICdvbmVycm9yJylcbiAgICAgICkge1xuICAgICAgICByZXN0b3JlU3RyYXRlZ3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBvYmpbbWV0aG9kTmFtZV0gPSBvcmlnaW5hbE1ldGhvZDtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3RvcmVTdHJhdGVneSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICghZGVsZXRlIG9ialttZXRob2ROYW1lXSkge1xuICAgICAgICAgICAgb2JqW21ldGhvZE5hbWVdID0gb3JpZ2luYWxNZXRob2Q7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50U3BpZXMoKS5wdXNoKHtcbiAgICAgICAgcmVzdG9yZU9iamVjdFRvT3JpZ2luYWxTdGF0ZTogcmVzdG9yZVN0cmF0ZWd5XG4gICAgICB9KTtcblxuICAgICAgb2JqW21ldGhvZE5hbWVdID0gc3BpZWRNZXRob2Q7XG5cbiAgICAgIHJldHVybiBzcGllZE1ldGhvZDtcbiAgICB9O1xuXG4gICAgdGhpcy5zcHlPblByb3BlcnR5ID0gZnVuY3Rpb24ob2JqLCBwcm9wZXJ0eU5hbWUsIGFjY2Vzc1R5cGUpIHtcbiAgICAgIHZhciBnZXRFcnJvck1zZyA9IHNweU9uUHJvcGVydHlNc2c7XG5cbiAgICAgIGFjY2Vzc1R5cGUgPSBhY2Nlc3NUeXBlIHx8ICdnZXQnO1xuXG4gICAgICBpZiAoaiQudXRpbC5pc1VuZGVmaW5lZChvYmopKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBnZXRFcnJvck1zZyhcbiAgICAgICAgICAgICdzcHlPbiBjb3VsZCBub3QgZmluZCBhbiBvYmplY3QgdG8gc3B5IHVwb24gZm9yICcgK1xuICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWUgK1xuICAgICAgICAgICAgICAnJ1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGokLnV0aWwuaXNVbmRlZmluZWQocHJvcGVydHlOYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0RXJyb3JNc2coJ05vIHByb3BlcnR5IG5hbWUgc3VwcGxpZWQnKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZXNjcmlwdG9yID0gaiQudXRpbC5nZXRQcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBwcm9wZXJ0eU5hbWUpO1xuXG4gICAgICBpZiAoIWRlc2NyaXB0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGdldEVycm9yTXNnKHByb3BlcnR5TmFtZSArICcgcHJvcGVydHkgZG9lcyBub3QgZXhpc3QnKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGdldEVycm9yTXNnKHByb3BlcnR5TmFtZSArICcgaXMgbm90IGRlY2xhcmVkIGNvbmZpZ3VyYWJsZScpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZGVzY3JpcHRvclthY2Nlc3NUeXBlXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgZ2V0RXJyb3JNc2coXG4gICAgICAgICAgICAnUHJvcGVydHkgJyArXG4gICAgICAgICAgICAgIHByb3BlcnR5TmFtZSArXG4gICAgICAgICAgICAgICcgZG9lcyBub3QgaGF2ZSBhY2Nlc3MgdHlwZSAnICtcbiAgICAgICAgICAgICAgYWNjZXNzVHlwZVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGokLmlzU3B5KGRlc2NyaXB0b3JbYWNjZXNzVHlwZV0pKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc3B5KSB7XG4gICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3JbYWNjZXNzVHlwZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgZ2V0RXJyb3JNc2coXG4gICAgICAgICAgICAgIHByb3BlcnR5TmFtZSArICcjJyArIGFjY2Vzc1R5cGUgKyAnIGhhcyBhbHJlYWR5IGJlZW4gc3BpZWQgdXBvbidcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBvcmlnaW5hbERlc2NyaXB0b3IgPSBqJC51dGlsLmNsb25lKGRlc2NyaXB0b3IpLFxuICAgICAgICBzcHkgPSBjcmVhdGVTcHkocHJvcGVydHlOYW1lLCBkZXNjcmlwdG9yW2FjY2Vzc1R5cGVdKSxcbiAgICAgICAgcmVzdG9yZVN0cmF0ZWd5O1xuXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcGVydHlOYW1lKSkge1xuICAgICAgICByZXN0b3JlU3RyYXRlZ3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wZXJ0eU5hbWUsIG9yaWdpbmFsRGVzY3JpcHRvcik7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN0b3JlU3RyYXRlZ3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBkZWxldGUgb2JqW3Byb3BlcnR5TmFtZV07XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRTcGllcygpLnB1c2goe1xuICAgICAgICByZXN0b3JlT2JqZWN0VG9PcmlnaW5hbFN0YXRlOiByZXN0b3JlU3RyYXRlZ3lcbiAgICAgIH0pO1xuXG4gICAgICBkZXNjcmlwdG9yW2FjY2Vzc1R5cGVdID0gc3B5O1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wZXJ0eU5hbWUsIGRlc2NyaXB0b3IpO1xuXG4gICAgICByZXR1cm4gc3B5O1xuICAgIH07XG5cbiAgICB0aGlzLnNweU9uQWxsRnVuY3Rpb25zID0gZnVuY3Rpb24ob2JqLCBpbmNsdWRlTm9uRW51bWVyYWJsZSkge1xuICAgICAgaWYgKGokLnV0aWwuaXNVbmRlZmluZWQob2JqKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ3NweU9uQWxsRnVuY3Rpb25zIGNvdWxkIG5vdCBmaW5kIGFuIG9iamVjdCB0byBzcHkgdXBvbidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvaW50ZXIgPSBvYmosXG4gICAgICAgIHByb3BzVG9TcHlPbiA9IFtdLFxuICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICBwcm9wZXJ0aWVzVG9Ta2lwID0gW107XG5cbiAgICAgIHdoaWxlIChcbiAgICAgICAgcG9pbnRlciAmJlxuICAgICAgICAoIWluY2x1ZGVOb25FbnVtZXJhYmxlIHx8IHBvaW50ZXIgIT09IE9iamVjdC5wcm90b3R5cGUpXG4gICAgICApIHtcbiAgICAgICAgcHJvcGVydGllcyA9IGdldFByb3BzKHBvaW50ZXIsIGluY2x1ZGVOb25FbnVtZXJhYmxlKTtcbiAgICAgICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMuZmlsdGVyKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgICByZXR1cm4gcHJvcGVydGllc1RvU2tpcC5pbmRleE9mKHByb3ApID09PSAtMTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb3BlcnRpZXNUb1NraXAgPSBwcm9wZXJ0aWVzVG9Ta2lwLmNvbmNhdChwcm9wZXJ0aWVzKTtcbiAgICAgICAgcHJvcHNUb1NweU9uID0gcHJvcHNUb1NweU9uLmNvbmNhdChcbiAgICAgICAgICBnZXRTcHlhYmxlRnVuY3Rpb25Qcm9wcyhwb2ludGVyLCBwcm9wZXJ0aWVzKVxuICAgICAgICApO1xuICAgICAgICBwb2ludGVyID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHBvaW50ZXIpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzVG9TcHlPbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnNweU9uKG9iaiwgcHJvcHNUb1NweU9uW2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuXG4gICAgdGhpcy5jbGVhclNwaWVzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3BpZXMgPSBjdXJyZW50U3BpZXMoKTtcbiAgICAgIGZvciAodmFyIGkgPSBzcGllcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgc3B5RW50cnkgPSBzcGllc1tpXTtcbiAgICAgICAgc3B5RW50cnkucmVzdG9yZU9iamVjdFRvT3JpZ2luYWxTdGF0ZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQcm9wcyhvYmosIGluY2x1ZGVOb25FbnVtZXJhYmxlKSB7XG4gICAgdmFyIGVudW1lcmFibGVQcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMob2JqKTtcblxuICAgIGlmICghaW5jbHVkZU5vbkVudW1lcmFibGUpIHtcbiAgICAgIHJldHVybiBlbnVtZXJhYmxlUHJvcGVydGllcztcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5maWx0ZXIoZnVuY3Rpb24ocHJvcCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgcHJvcCAhPT0gJ2NvbnN0cnVjdG9yJyB8fFxuICAgICAgICBlbnVtZXJhYmxlUHJvcGVydGllcy5pbmRleE9mKCdjb25zdHJ1Y3RvcicpID4gLTFcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTcHlhYmxlRnVuY3Rpb25Qcm9wcyhvYmosIHByb3BlcnRpZXNUb0NoZWNrKSB7XG4gICAgdmFyIHByb3BzID0gW10sXG4gICAgICBwcm9wO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllc1RvQ2hlY2subGVuZ3RoOyBpKyspIHtcbiAgICAgIHByb3AgPSBwcm9wZXJ0aWVzVG9DaGVja1tpXTtcbiAgICAgIGlmIChcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkgJiZcbiAgICAgICAgaXNTcHlhYmxlUHJvcChvYmosIHByb3ApXG4gICAgICApIHtcbiAgICAgICAgcHJvcHMucHVzaChwcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BzO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTcHlhYmxlUHJvcChvYmosIHByb3ApIHtcbiAgICB2YXIgdmFsdWUsIGRlc2NyaXB0b3I7XG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlID0gb2JqW3Byb3BdO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCk7XG4gICAgICByZXR1cm4gKGRlc2NyaXB0b3Iud3JpdGFibGUgfHwgZGVzY3JpcHRvci5zZXQpICYmIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gU3B5UmVnaXN0cnk7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlNweVN0cmF0ZWd5ID0gZnVuY3Rpb24oaiQpIHtcbiAgLyoqXG4gICAqIEBpbnRlcmZhY2UgU3B5U3RyYXRlZ3lcbiAgICovXG4gIGZ1bmN0aW9uIFNweVN0cmF0ZWd5KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaWRlbnRpZnlpbmcgaW5mb3JtYXRpb24gZm9yIHRoZSBzcHkuXG4gICAgICogQG5hbWUgU3B5U3RyYXRlZ3kjaWRlbnRpdHlcbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAbWVtYmVyXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmlkZW50aXR5ID0gb3B0aW9ucy5uYW1lIHx8ICd1bmtub3duJztcbiAgICB0aGlzLm9yaWdpbmFsRm4gPSBvcHRpb25zLmZuIHx8IGZ1bmN0aW9uKCkge307XG4gICAgdGhpcy5nZXRTcHkgPSBvcHRpb25zLmdldFNweSB8fCBmdW5jdGlvbigpIHt9O1xuICAgIHRoaXMucGxhbiA9IHRoaXMuX2RlZmF1bHRQbGFuID0gZnVuY3Rpb24oKSB7fTtcblxuICAgIHZhciBrLFxuICAgICAgY3MgPSBvcHRpb25zLmN1c3RvbVN0cmF0ZWdpZXMgfHwge307XG4gICAgZm9yIChrIGluIGNzKSB7XG4gICAgICBpZiAoaiQudXRpbC5oYXMoY3MsIGspICYmICF0aGlzW2tdKSB7XG4gICAgICAgIHRoaXNba10gPSBjcmVhdGVDdXN0b21QbGFuKGNzW2tdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZWxsIHRoZSBzcHkgdG8gcmV0dXJuIGEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHNwZWNpZmllZCB2YWx1ZSB3aGVuIGludm9rZWQuXG4gICAgICogQG5hbWUgU3B5U3RyYXRlZ3kjcmVzb2x2ZVRvXG4gICAgICogQHNpbmNlIDMuNS4wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuLlxuICAgICAqL1xuICAgIHRoaXMucmVzb2x2ZVRvID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHNlbGYucGxhbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gc2VsZi5nZXRTcHkoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGVsbCB0aGUgc3B5IHRvIHJldHVybiBhIHByb21pc2UgcmVqZWN0aW5nIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZSB3aGVuIGludm9rZWQuXG4gICAgICogQG5hbWUgU3B5U3RyYXRlZ3kjcmVqZWN0V2l0aFxuICAgICAqIEBzaW5jZSAzLjUuMFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybi5cbiAgICAgKi9cbiAgICB0aGlzLnJlamVjdFdpdGggPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgc2VsZi5wbGFuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHNlbGYuZ2V0U3B5KCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUN1c3RvbVBsYW4oZmFjdG9yeSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwbGFuID0gZmFjdG9yeS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuXG4gICAgICBpZiAoIWokLmlzRnVuY3Rpb25fKHBsYW4pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU3B5IHN0cmF0ZWd5IG11c3QgcmV0dXJuIGEgZnVuY3Rpb24nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wbGFuID0gcGxhbjtcbiAgICAgIHJldHVybiB0aGlzLmdldFNweSgpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSB0aGUgY3VycmVudCBzcHkgc3RyYXRlZ3kuXG4gICAqIEBuYW1lIFNweVN0cmF0ZWd5I2V4ZWNcbiAgICogQHNpbmNlIDIuMC4wXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgU3B5U3RyYXRlZ3kucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjb250ZXh0LCBhcmdzLCBpbnZva2VOZXcpIHtcbiAgICB2YXIgY29udGV4dEFyZ3MgPSBbY29udGV4dF0uY29uY2F0KFxuICAgICAgYXJncyA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpIDogW11cbiAgICApO1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLnBsYW4uYmluZC5hcHBseSh0aGlzLnBsYW4sIGNvbnRleHRBcmdzKTtcblxuICAgIHJldHVybiBpbnZva2VOZXcgPyBuZXcgdGFyZ2V0KCkgOiB0YXJnZXQoKTtcbiAgfTtcblxuICAvKipcbiAgICogVGVsbCB0aGUgc3B5IHRvIGNhbGwgdGhyb3VnaCB0byB0aGUgcmVhbCBpbXBsZW1lbnRhdGlvbiB3aGVuIGludm9rZWQuXG4gICAqIEBuYW1lIFNweVN0cmF0ZWd5I2NhbGxUaHJvdWdoXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIFNweVN0cmF0ZWd5LnByb3RvdHlwZS5jYWxsVGhyb3VnaCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucGxhbiA9IHRoaXMub3JpZ2luYWxGbjtcbiAgICByZXR1cm4gdGhpcy5nZXRTcHkoKTtcbiAgfTtcblxuICAvKipcbiAgICogVGVsbCB0aGUgc3B5IHRvIHJldHVybiB0aGUgdmFsdWUgd2hlbiBpbnZva2VkLlxuICAgKiBAbmFtZSBTcHlTdHJhdGVneSNyZXR1cm5WYWx1ZVxuICAgKiBAc2luY2UgMi4wLjBcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybi5cbiAgICovXG4gIFNweVN0cmF0ZWd5LnByb3RvdHlwZS5yZXR1cm5WYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5wbGFuID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5nZXRTcHkoKTtcbiAgfTtcblxuICAvKipcbiAgICogVGVsbCB0aGUgc3B5IHRvIHJldHVybiBvbmUgb2YgdGhlIHNwZWNpZmllZCB2YWx1ZXMgKHNlcXVlbnRpYWxseSkgZWFjaCB0aW1lIHRoZSBzcHkgaXMgaW52b2tlZC5cbiAgICogQG5hbWUgU3B5U3RyYXRlZ3kjcmV0dXJuVmFsdWVzXG4gICAqIEBzaW5jZSAyLjEuMFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHsuLi4qfSB2YWx1ZXMgLSBWYWx1ZXMgdG8gYmUgcmV0dXJuZWQgb24gc3Vic2VxdWVudCBjYWxscyB0byB0aGUgc3B5LlxuICAgKi9cbiAgU3B5U3RyYXRlZ3kucHJvdG90eXBlLnJldHVyblZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHRoaXMucGxhbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHZhbHVlcy5zaGlmdCgpO1xuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3B5KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRlbGwgdGhlIHNweSB0byB0aHJvdyBhbiBlcnJvciB3aGVuIGludm9rZWQuXG4gICAqIEBuYW1lIFNweVN0cmF0ZWd5I3Rocm93RXJyb3JcbiAgICogQHNpbmNlIDIuMC4wXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0Vycm9yfE9iamVjdHxTdHJpbmd9IHNvbWV0aGluZyBUaGluZyB0byB0aHJvd1xuICAgKi9cbiAgU3B5U3RyYXRlZ3kucHJvdG90eXBlLnRocm93RXJyb3IgPSBmdW5jdGlvbihzb21ldGhpbmcpIHtcbiAgICB2YXIgZXJyb3IgPSBqJC5pc1N0cmluZ18oc29tZXRoaW5nKSA/IG5ldyBFcnJvcihzb21ldGhpbmcpIDogc29tZXRoaW5nO1xuICAgIHRoaXMucGxhbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5nZXRTcHkoKTtcbiAgfTtcblxuICAvKipcbiAgICogVGVsbCB0aGUgc3B5IHRvIGNhbGwgYSBmYWtlIGltcGxlbWVudGF0aW9uIHdoZW4gaW52b2tlZC5cbiAgICogQG5hbWUgU3B5U3RyYXRlZ3kjY2FsbEZha2VcbiAgICogQHNpbmNlIDIuMC4wXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gaW52b2tlIHdpdGggdGhlIHBhc3NlZCBwYXJhbWV0ZXJzLlxuICAgKi9cbiAgU3B5U3RyYXRlZ3kucHJvdG90eXBlLmNhbGxGYWtlID0gZnVuY3Rpb24oZm4pIHtcbiAgICBpZiAoXG4gICAgICAhKFxuICAgICAgICBqJC5pc0Z1bmN0aW9uXyhmbikgfHxcbiAgICAgICAgaiQuaXNBc3luY0Z1bmN0aW9uXyhmbikgfHxcbiAgICAgICAgaiQuaXNHZW5lcmF0b3JGdW5jdGlvbl8oZm4pXG4gICAgICApXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdBcmd1bWVudCBwYXNzZWQgdG8gY2FsbEZha2Ugc2hvdWxkIGJlIGEgZnVuY3Rpb24sIGdvdCAnICsgZm5cbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMucGxhbiA9IGZuO1xuICAgIHJldHVybiB0aGlzLmdldFNweSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZWxsIHRoZSBzcHkgdG8gZG8gbm90aGluZyB3aGVuIGludm9rZWQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXG4gICAqIEBuYW1lIFNweVN0cmF0ZWd5I3N0dWJcbiAgICogQHNpbmNlIDIuMC4wXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgU3B5U3RyYXRlZ3kucHJvdG90eXBlLnN0dWIgPSBmdW5jdGlvbihmbikge1xuICAgIHRoaXMucGxhbiA9IGZ1bmN0aW9uKCkge307XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3B5KCk7XG4gIH07XG5cbiAgU3B5U3RyYXRlZ3kucHJvdG90eXBlLmlzQ29uZmlndXJlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBsYW4gIT09IHRoaXMuX2RlZmF1bHRQbGFuO1xuICB9O1xuXG4gIHJldHVybiBTcHlTdHJhdGVneTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuU3RhY2tUcmFjZSA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIFN0YWNrVHJhY2UoZXJyb3IpIHtcbiAgICB2YXIgbGluZXMgPSBlcnJvci5zdGFjay5zcGxpdCgnXFxuJykuZmlsdGVyKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHJldHVybiBsaW5lICE9PSAnJztcbiAgICB9KTtcblxuICAgIHZhciBleHRyYWN0UmVzdWx0ID0gZXh0cmFjdE1lc3NhZ2UoZXJyb3IubWVzc2FnZSwgbGluZXMpO1xuXG4gICAgaWYgKGV4dHJhY3RSZXN1bHQpIHtcbiAgICAgIHRoaXMubWVzc2FnZSA9IGV4dHJhY3RSZXN1bHQubWVzc2FnZTtcbiAgICAgIGxpbmVzID0gZXh0cmFjdFJlc3VsdC5yZW1haW5kZXI7XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlUmVzdWx0ID0gdHJ5UGFyc2VGcmFtZXMobGluZXMpO1xuICAgIHRoaXMuZnJhbWVzID0gcGFyc2VSZXN1bHQuZnJhbWVzO1xuICAgIHRoaXMuc3R5bGUgPSBwYXJzZVJlc3VsdC5zdHlsZTtcbiAgfVxuXG4gIHZhciBmcmFtZVBhdHRlcm5zID0gW1xuICAgIC8vIE5vZGUsIENocm9tZSwgRWRnZVxuICAgIC8vIGUuZy4gXCIgICBhdCBRdWV1ZVJ1bm5lci5ydW4gKGh0dHA6Ly9sb2NhbGhvc3Q6ODg4OC9fX2phc21pbmVfXy9qYXNtaW5lLmpzOjQzMjA6MjApXCJcbiAgICAvLyBOb3RlIHRoYXQgdGhlIFwiZnVuY3Rpb24gbmFtZVwiIGNhbiBpbmNsdWRlIGEgc3VycHJpc2luZ2x5IGxhcmdlIHNldCBvZlxuICAgIC8vIGNoYXJhY3RlcnMsIGluY2x1ZGluZyBhbmdsZSBicmFja2V0cyBhbmQgc3F1YXJlIGJyYWNrZXRzLlxuICAgIHtcbiAgICAgIHJlOiAvXlxccyphdCAoW15cXCldKykgXFwoKFteXFwpXSspXFwpJC8sXG4gICAgICBmbkl4OiAxLFxuICAgICAgZmlsZUxpbmVDb2xJeDogMixcbiAgICAgIHN0eWxlOiAndjgnXG4gICAgfSxcblxuICAgIC8vIE5vZGVKUyBhbHRlcm5hdGUgZm9ybSwgb2Z0ZW4gbWl4ZWQgaW4gd2l0aCB0aGUgQ2hyb21lIHN0eWxlXG4gICAgLy8gZS5nLiBcIiAgYXQgL3NvbWUvcGF0aDo0MzIwOjIwXG4gICAgeyByZTogL1xccyphdCAoLispJC8sIGZpbGVMaW5lQ29sSXg6IDEsIHN0eWxlOiAndjgnIH0sXG5cbiAgICAvLyBQaGFudG9tSlMgb24gT1MgWCwgU2FmYXJpLCBGaXJlZm94XG4gICAgLy8gZS5nLiBcInJ1bkBodHRwOi8vbG9jYWxob3N0Ojg4ODgvX19qYXNtaW5lX18vamFzbWluZS5qczo0MzIwOjI3XCJcbiAgICAvLyBvciBcImh0dHA6Ly9sb2NhbGhvc3Q6ODg4OC9fX2phc21pbmVfXy9qYXNtaW5lLmpzOjQzMjA6MjdcIlxuICAgIHtcbiAgICAgIHJlOiAvXig/OigoW15AXFxzXSspQCl8QCk/KFteXFxzXSspJC8sXG4gICAgICBmbkl4OiAyLFxuICAgICAgZmlsZUxpbmVDb2xJeDogMyxcbiAgICAgIHN0eWxlOiAnd2Via2l0J1xuICAgIH1cbiAgXTtcblxuICAvLyByZWdleGVzIHNob3VsZCBjYXB0dXJlIHRoZSBmdW5jdGlvbiBuYW1lIChpZiBhbnkpIGFzIGdyb3VwIDFcbiAgLy8gYW5kIHRoZSBmaWxlLCBsaW5lLCBhbmQgY29sdW1uIGFzIGdyb3VwIDIuXG4gIGZ1bmN0aW9uIHRyeVBhcnNlRnJhbWVzKGxpbmVzKSB7XG4gICAgdmFyIHN0eWxlID0gbnVsbDtcbiAgICB2YXIgZnJhbWVzID0gbGluZXMubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHZhciBjb252ZXJ0ZWRMaW5lID0gZmlyc3QoZnJhbWVQYXR0ZXJucywgZnVuY3Rpb24ocGF0dGVybikge1xuICAgICAgICB2YXIgb3ZlcmFsbE1hdGNoID0gbGluZS5tYXRjaChwYXR0ZXJuLnJlKSxcbiAgICAgICAgICBmaWxlTGluZUNvbE1hdGNoO1xuICAgICAgICBpZiAoIW92ZXJhbGxNYXRjaCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZmlsZUxpbmVDb2xNYXRjaCA9IG92ZXJhbGxNYXRjaFtwYXR0ZXJuLmZpbGVMaW5lQ29sSXhdLm1hdGNoKFxuICAgICAgICAgIC9eKC4qKTooXFxkKyk6XFxkKyQvXG4gICAgICAgICk7XG4gICAgICAgIGlmICghZmlsZUxpbmVDb2xNYXRjaCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgc3R5bGUgPSBzdHlsZSB8fCBwYXR0ZXJuLnN0eWxlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJhdzogbGluZSxcbiAgICAgICAgICBmaWxlOiBmaWxlTGluZUNvbE1hdGNoWzFdLFxuICAgICAgICAgIGxpbmU6IHBhcnNlSW50KGZpbGVMaW5lQ29sTWF0Y2hbMl0sIDEwKSxcbiAgICAgICAgICBmdW5jOiBvdmVyYWxsTWF0Y2hbcGF0dGVybi5mbkl4XVxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBjb252ZXJ0ZWRMaW5lIHx8IHsgcmF3OiBsaW5lIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgZnJhbWVzOiBmcmFtZXNcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZmlyc3QoaXRlbXMsIGZuKSB7XG4gICAgdmFyIGksIHJlc3VsdDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0ID0gZm4oaXRlbXNbaV0pO1xuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZXh0cmFjdE1lc3NhZ2UobWVzc2FnZSwgc3RhY2tMaW5lcykge1xuICAgIHZhciBsZW4gPSBtZXNzYWdlUHJlZml4TGVuZ3RoKG1lc3NhZ2UsIHN0YWNrTGluZXMpO1xuXG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1lc3NhZ2U6IHN0YWNrTGluZXMuc2xpY2UoMCwgbGVuKS5qb2luKCdcXG4nKSxcbiAgICAgICAgcmVtYWluZGVyOiBzdGFja0xpbmVzLnNsaWNlKGxlbilcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWVzc2FnZVByZWZpeExlbmd0aChtZXNzYWdlLCBzdGFja0xpbmVzKSB7XG4gICAgaWYgKCFzdGFja0xpbmVzWzBdLm1hdGNoKC9eXFx3KkVycm9yLykpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciBtZXNzYWdlTGluZXMgPSBtZXNzYWdlLnNwbGl0KCdcXG4nKTtcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDE7IGkgPCBtZXNzYWdlTGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChtZXNzYWdlTGluZXNbaV0gIT09IHN0YWNrTGluZXNbaV0pIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lc3NhZ2VMaW5lcy5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gU3RhY2tUcmFjZTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuU3VpdGUgPSBmdW5jdGlvbihqJCkge1xuICAvKipcbiAgICogQGludGVyZmFjZSBTdWl0ZVxuICAgKiBAc2VlIEVudiN0b3BTdWl0ZVxuICAgKiBAc2luY2UgMi4wLjBcbiAgICovXG4gIGZ1bmN0aW9uIFN1aXRlKGF0dHJzKSB7XG4gICAgdGhpcy5lbnYgPSBhdHRycy5lbnY7XG4gICAgLyoqXG4gICAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGlzIHN1aXRlLlxuICAgICAqIEBuYW1lIFN1aXRlI2lkXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKi9cbiAgICB0aGlzLmlkID0gYXR0cnMuaWQ7XG4gICAgdGhpcy5wYXJlbnRTdWl0ZSA9IGF0dHJzLnBhcmVudFN1aXRlO1xuICAgIC8qKlxuICAgICAqIFRoZSBkZXNjcmlwdGlvbiBwYXNzZWQgdG8gdGhlIHtAbGluayBkZXNjcmliZX0gdGhhdCBjcmVhdGVkIHRoaXMgc3VpdGUuXG4gICAgICogQG5hbWUgU3VpdGUjZGVzY3JpcHRpb25cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqL1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBhdHRycy5kZXNjcmlwdGlvbjtcbiAgICB0aGlzLmV4cGVjdGF0aW9uRmFjdG9yeSA9IGF0dHJzLmV4cGVjdGF0aW9uRmFjdG9yeTtcbiAgICB0aGlzLmFzeW5jRXhwZWN0YXRpb25GYWN0b3J5ID0gYXR0cnMuYXN5bmNFeHBlY3RhdGlvbkZhY3Rvcnk7XG4gICAgdGhpcy5leHBlY3RhdGlvblJlc3VsdEZhY3RvcnkgPSBhdHRycy5leHBlY3RhdGlvblJlc3VsdEZhY3Rvcnk7XG4gICAgdGhpcy50aHJvd09uRXhwZWN0YXRpb25GYWlsdXJlID0gISFhdHRycy50aHJvd09uRXhwZWN0YXRpb25GYWlsdXJlO1xuICAgIHRoaXMuYXV0b0NsZWFuQ2xvc3VyZXMgPVxuICAgICAgYXR0cnMuYXV0b0NsZWFuQ2xvc3VyZXMgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIWF0dHJzLmF1dG9DbGVhbkNsb3N1cmVzO1xuICAgIHRoaXMub25MYXRlRXJyb3IgPSBhdHRycy5vbkxhdGVFcnJvcjtcblxuICAgIHRoaXMuYmVmb3JlRm5zID0gW107XG4gICAgdGhpcy5hZnRlckZucyA9IFtdO1xuICAgIHRoaXMuYmVmb3JlQWxsRm5zID0gW107XG4gICAgdGhpcy5hZnRlckFsbEZucyA9IFtdO1xuICAgIHRoaXMudGltZXIgPSBhdHRycy50aW1lciB8fCBuZXcgaiQuVGltZXIoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdWl0ZSdzIGNoaWxkcmVuLlxuICAgICAqIEBuYW1lIFN1aXRlI2NoaWxkcmVuXG4gICAgICogQHR5cGUge0FycmF5LjwoU3BlY3xTdWl0ZSk+fVxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqL1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcblxuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuXG4gIFN1aXRlLnByb3RvdHlwZS5zZXRTdWl0ZVByb3BlcnR5ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMucmVzdWx0LnByb3BlcnRpZXMgPSB0aGlzLnJlc3VsdC5wcm9wZXJ0aWVzIHx8IHt9O1xuICAgIHRoaXMucmVzdWx0LnByb3BlcnRpZXNba2V5XSA9IHZhbHVlO1xuICB9O1xuXG4gIFN1aXRlLnByb3RvdHlwZS5leHBlY3QgPSBmdW5jdGlvbihhY3R1YWwpIHtcbiAgICByZXR1cm4gdGhpcy5leHBlY3RhdGlvbkZhY3RvcnkoYWN0dWFsLCB0aGlzKTtcbiAgfTtcblxuICBTdWl0ZS5wcm90b3R5cGUuZXhwZWN0QXN5bmMgPSBmdW5jdGlvbihhY3R1YWwpIHtcbiAgICByZXR1cm4gdGhpcy5hc3luY0V4cGVjdGF0aW9uRmFjdG9yeShhY3R1YWwsIHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgZnVsbCBkZXNjcmlwdGlvbiBpbmNsdWRpbmcgYWxsIGFuY2VzdG9ycyBvZiB0aGlzIHN1aXRlLlxuICAgKiBAbmFtZSBTdWl0ZSNnZXRGdWxsTmFtZVxuICAgKiBAZnVuY3Rpb25cbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQHNpbmNlIDIuMC4wXG4gICAqL1xuICBTdWl0ZS5wcm90b3R5cGUuZ2V0RnVsbE5hbWUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZnVsbE5hbWUgPSBbXTtcbiAgICBmb3IgKFxuICAgICAgdmFyIHBhcmVudFN1aXRlID0gdGhpcztcbiAgICAgIHBhcmVudFN1aXRlO1xuICAgICAgcGFyZW50U3VpdGUgPSBwYXJlbnRTdWl0ZS5wYXJlbnRTdWl0ZVxuICAgICkge1xuICAgICAgaWYgKHBhcmVudFN1aXRlLnBhcmVudFN1aXRlKSB7XG4gICAgICAgIGZ1bGxOYW1lLnVuc2hpZnQocGFyZW50U3VpdGUuZGVzY3JpcHRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVsbE5hbWUuam9pbignICcpO1xuICB9O1xuXG4gIC8qXG4gICAqIE1hcmsgdGhlIHN1aXRlIHdpdGggXCJwZW5kaW5nXCIgc3RhdHVzXG4gICAqL1xuICBTdWl0ZS5wcm90b3R5cGUucGVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubWFya2VkUGVuZGluZyA9IHRydWU7XG4gIH07XG5cbiAgLypcbiAgICogTGlrZSB7QGxpbmsgU3VpdGUjcGVuZH0sIGJ1dCBwZW5kaW5nIHN0YXRlIHdpbGwgc3Vydml2ZSB7QGxpbmsgU3BlYyNyZXNldH1cbiAgICogVXNlZnVsIGZvciBmZGVzY3JpYmUsIHhkZXNjcmliZSwgd2hlcmUgcGVuZGluZyBzdGF0ZSBzaG91bGQgcmVtYWluLlxuICAgKi9cbiAgU3VpdGUucHJvdG90eXBlLmV4Y2x1ZGUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnBlbmQoKTtcbiAgICB0aGlzLm1hcmtlZEV4Y2x1ZGluZyA9IHRydWU7XG4gIH07XG5cbiAgU3VpdGUucHJvdG90eXBlLmJlZm9yZUVhY2ggPSBmdW5jdGlvbihmbikge1xuICAgIHRoaXMuYmVmb3JlRm5zLnVuc2hpZnQoeyAuLi5mbiwgc3VpdGU6IHRoaXMgfSk7XG4gIH07XG5cbiAgU3VpdGUucHJvdG90eXBlLmJlZm9yZUFsbCA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgdGhpcy5iZWZvcmVBbGxGbnMucHVzaCh7IC4uLmZuLCB0eXBlOiAnYmVmb3JlQWxsJywgc3VpdGU6IHRoaXMgfSk7XG4gIH07XG5cbiAgU3VpdGUucHJvdG90eXBlLmFmdGVyRWFjaCA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgdGhpcy5hZnRlckZucy51bnNoaWZ0KHsgLi4uZm4sIHN1aXRlOiB0aGlzLCB0eXBlOiAnYWZ0ZXJFYWNoJyB9KTtcbiAgfTtcblxuICBTdWl0ZS5wcm90b3R5cGUuYWZ0ZXJBbGwgPSBmdW5jdGlvbihmbikge1xuICAgIHRoaXMuYWZ0ZXJBbGxGbnMudW5zaGlmdCh7IC4uLmZuLCB0eXBlOiAnYWZ0ZXJBbGwnIH0pO1xuICB9O1xuXG4gIFN1aXRlLnByb3RvdHlwZS5zdGFydFRpbWVyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50aW1lci5zdGFydCgpO1xuICB9O1xuXG4gIFN1aXRlLnByb3RvdHlwZS5lbmRUaW1lciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVzdWx0LmR1cmF0aW9uID0gdGhpcy50aW1lci5lbGFwc2VkKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRm5zKHF1ZXVlYWJsZUZucykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWVhYmxlRm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBxdWV1ZWFibGVGbnNbaV0uZm4gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIFN1aXRlLnByb3RvdHlwZS5jbGVhbnVwQmVmb3JlQWZ0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5hdXRvQ2xlYW5DbG9zdXJlcykge1xuICAgICAgcmVtb3ZlRm5zKHRoaXMuYmVmb3JlQWxsRm5zKTtcbiAgICAgIHJlbW92ZUZucyh0aGlzLmFmdGVyQWxsRm5zKTtcbiAgICAgIHJlbW92ZUZucyh0aGlzLmJlZm9yZUZucyk7XG4gICAgICByZW1vdmVGbnModGhpcy5hZnRlckZucyk7XG4gICAgfVxuICB9O1xuXG4gIFN1aXRlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIFN1aXRlUmVzdWx0XG4gICAgICogQHByb3BlcnR5IHtJbnR9IGlkIC0gVGhlIHVuaXF1ZSBpZCBvZiB0aGlzIHN1aXRlLlxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkZXNjcmlwdGlvbiAtIFRoZSBkZXNjcmlwdGlvbiB0ZXh0IHBhc3NlZCB0byB0aGUge0BsaW5rIGRlc2NyaWJlfSB0aGF0IG1hZGUgdGhpcyBzdWl0ZS5cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gZnVsbE5hbWUgLSBUaGUgZnVsbCBkZXNjcmlwdGlvbiBpbmNsdWRpbmcgYWxsIGFuY2VzdG9ycyBvZiB0aGlzIHN1aXRlLlxuICAgICAqIEBwcm9wZXJ0eSB7RXhwZWN0YXRpb25bXX0gZmFpbGVkRXhwZWN0YXRpb25zIC0gVGhlIGxpc3Qgb2YgZXhwZWN0YXRpb25zIHRoYXQgZmFpbGVkIGluIGFuIHtAbGluayBhZnRlckFsbH0gZm9yIHRoaXMgc3VpdGUuXG4gICAgICogQHByb3BlcnR5IHtFeHBlY3RhdGlvbltdfSBkZXByZWNhdGlvbldhcm5pbmdzIC0gVGhlIGxpc3Qgb2YgZGVwcmVjYXRpb24gd2FybmluZ3MgdGhhdCBvY2N1cnJlZCBvbiB0aGlzIHN1aXRlLlxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzdGF0dXMgLSBPbmNlIHRoZSBzdWl0ZSBoYXMgY29tcGxldGVkLCB0aGlzIHN0cmluZyByZXByZXNlbnRzIHRoZSBwYXNzL2ZhaWwgc3RhdHVzIG9mIHRoaXMgc3VpdGUuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIHRpbWUgaW4gbXMgZm9yIFN1aXRlIGV4ZWN1dGlvbiwgaW5jbHVkaW5nIGFueSBiZWZvcmUvYWZ0ZXJBbGwsIGJlZm9yZS9hZnRlckVhY2guXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IHByb3BlcnRpZXMgLSBVc2VyLXN1cHBsaWVkIHByb3BlcnRpZXMsIGlmIGFueSwgdGhhdCB3ZXJlIHNldCB1c2luZyB7QGxpbmsgRW52I3NldFN1aXRlUHJvcGVydHl9XG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICovXG4gICAgdGhpcy5yZXN1bHQgPSB7XG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgZnVsbE5hbWU6IHRoaXMuZ2V0RnVsbE5hbWUoKSxcbiAgICAgIGZhaWxlZEV4cGVjdGF0aW9uczogW10sXG4gICAgICBkZXByZWNhdGlvbldhcm5pbmdzOiBbXSxcbiAgICAgIGR1cmF0aW9uOiBudWxsLFxuICAgICAgcHJvcGVydGllczogbnVsbFxuICAgIH07XG4gICAgdGhpcy5tYXJrZWRQZW5kaW5nID0gdGhpcy5tYXJrZWRFeGNsdWRpbmc7XG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICBjaGlsZC5yZXNldCgpO1xuICAgIH0pO1xuICB9O1xuXG4gIFN1aXRlLnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgfTtcblxuICBTdWl0ZS5wcm90b3R5cGUuc3RhdHVzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMubWFya2VkUGVuZGluZykge1xuICAgICAgcmV0dXJuICdwZW5kaW5nJztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiAnZmFpbGVkJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICdwYXNzZWQnO1xuICAgIH1cbiAgfTtcblxuICBTdWl0ZS5wcm90b3R5cGUuY2FuQmVSZWVudGVyZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5iZWZvcmVBbGxGbnMubGVuZ3RoID09PSAwICYmIHRoaXMuYWZ0ZXJBbGxGbnMubGVuZ3RoID09PSAwO1xuICB9O1xuXG4gIFN1aXRlLnByb3RvdHlwZS5nZXRSZXN1bHQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlc3VsdC5zdGF0dXMgPSB0aGlzLnN0YXR1cygpO1xuICAgIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgfTtcblxuICBTdWl0ZS5wcm90b3R5cGUuc2hhcmVkVXNlckNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuc2hhcmVkQ29udGV4dCkge1xuICAgICAgdGhpcy5zaGFyZWRDb250ZXh0ID0gdGhpcy5wYXJlbnRTdWl0ZVxuICAgICAgICA/IHRoaXMucGFyZW50U3VpdGUuY2xvbmVkU2hhcmVkVXNlckNvbnRleHQoKVxuICAgICAgICA6IG5ldyBqJC5Vc2VyQ29udGV4dCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNoYXJlZENvbnRleHQ7XG4gIH07XG5cbiAgU3VpdGUucHJvdG90eXBlLmNsb25lZFNoYXJlZFVzZXJDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGokLlVzZXJDb250ZXh0LmZyb21FeGlzdGluZyh0aGlzLnNoYXJlZFVzZXJDb250ZXh0KCkpO1xuICB9O1xuXG4gIFN1aXRlLnByb3RvdHlwZS5vbkV4Y2VwdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBqJC5lcnJvcnMuRXhwZWN0YXRpb25GYWlsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIG1hdGNoZXJOYW1lOiAnJyxcbiAgICAgIHBhc3NlZDogZmFsc2UsXG4gICAgICBleHBlY3RlZDogJycsXG4gICAgICBhY3R1YWw6ICcnLFxuICAgICAgZXJyb3I6IGFyZ3VtZW50c1swXVxuICAgIH07XG4gICAgdmFyIGZhaWxlZEV4cGVjdGF0aW9uID0gdGhpcy5leHBlY3RhdGlvblJlc3VsdEZhY3RvcnkoZGF0YSk7XG5cbiAgICBpZiAoIXRoaXMucGFyZW50U3VpdGUpIHtcbiAgICAgIGZhaWxlZEV4cGVjdGF0aW9uLmdsb2JhbEVycm9yVHlwZSA9ICdhZnRlckFsbCc7XG4gICAgfVxuXG4gICAgdGhpcy5yZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zLnB1c2goZmFpbGVkRXhwZWN0YXRpb24pO1xuICB9O1xuXG4gIFN1aXRlLnByb3RvdHlwZS5vbk11bHRpcGxlRG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIGxldCBtc2c7XG5cbiAgICAvLyBJc3N1ZSBhIGRlcHJlY2F0aW9uLiBJbmNsdWRlIHRoZSBjb250ZXh0IG91cnNlbHZlcyBhbmQgcGFzc1xuICAgIC8vIGlnbm9yZVJ1bm5hYmxlOiB0cnVlLCBzaW5jZSBnZXR0aW5nIGhlcmUgYWx3YXlzIG1lYW5zIHRoYXQgd2UndmUgYWxyZWFkeVxuICAgIC8vIG1vdmVkIG9uIGFuZCB0aGUgY3VycmVudCBydW5uYWJsZSBpc24ndCB0aGUgb25lIHRoYXQgY2F1c2VkIHRoZSBwcm9ibGVtLlxuICAgIGlmICh0aGlzLnBhcmVudFN1aXRlKSB7XG4gICAgICBtc2cgPVxuICAgICAgICBcIkFuIGFzeW5jaHJvbm91cyBiZWZvcmVBbGwgb3IgYWZ0ZXJBbGwgZnVuY3Rpb24gY2FsbGVkIGl0cyAnZG9uZScgXCIgK1xuICAgICAgICAnY2FsbGJhY2sgbW9yZSB0aGFuIG9uY2UuXFxuJyArXG4gICAgICAgICcoaW4gc3VpdGU6ICcgK1xuICAgICAgICB0aGlzLmdldEZ1bGxOYW1lKCkgK1xuICAgICAgICAnKSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1zZyA9XG4gICAgICAgICdBIHRvcC1sZXZlbCBiZWZvcmVBbGwgb3IgYWZ0ZXJBbGwgZnVuY3Rpb24gY2FsbGVkIGl0cyAnICtcbiAgICAgICAgXCInZG9uZScgY2FsbGJhY2sgbW9yZSB0aGFuIG9uY2UuXCI7XG4gICAgfVxuXG4gICAgdGhpcy5vbkxhdGVFcnJvcihuZXcgRXJyb3IobXNnKSk7XG4gIH07XG5cbiAgU3VpdGUucHJvdG90eXBlLmFkZEV4cGVjdGF0aW9uUmVzdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGlzRmFpbHVyZShhcmd1bWVudHMpKSB7XG4gICAgICB2YXIgZGF0YSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHRoaXMucmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9ucy5wdXNoKHRoaXMuZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5KGRhdGEpKTtcbiAgICAgIGlmICh0aGlzLnRocm93T25FeHBlY3RhdGlvbkZhaWx1cmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IGokLmVycm9ycy5FeHBlY3RhdGlvbkZhaWxlZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBTdWl0ZS5wcm90b3R5cGUuYWRkRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24oZGVwcmVjYXRpb24pIHtcbiAgICBpZiAodHlwZW9mIGRlcHJlY2F0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgZGVwcmVjYXRpb24gPSB7IG1lc3NhZ2U6IGRlcHJlY2F0aW9uIH07XG4gICAgfVxuICAgIHRoaXMucmVzdWx0LmRlcHJlY2F0aW9uV2FybmluZ3MucHVzaChcbiAgICAgIHRoaXMuZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5KGRlcHJlY2F0aW9uKVxuICAgICk7XG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN1aXRlLnByb3RvdHlwZSwgJ21ldGFkYXRhJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMubWV0YWRhdGFfKSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGFfID0gbmV3IFN1aXRlTWV0YWRhdGEodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLm1ldGFkYXRhXztcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJmYWNlIFN1aXRlXG4gICAqIEBzZWUgRW52I3RvcFN1aXRlXG4gICAqL1xuICBmdW5jdGlvbiBTdWl0ZU1ldGFkYXRhKHN1aXRlKSB7XG4gICAgdGhpcy5zdWl0ZV8gPSBzdWl0ZTtcbiAgICAvKipcbiAgICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoaXMgc3VpdGUuXG4gICAgICogQG5hbWUgU3VpdGUjaWRcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBzdWl0ZS5pZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwYXJlbnQgb2YgdGhpcyBzdWl0ZSwgb3IgbnVsbCBpZiB0aGlzIGlzIHRoZSB0b3Agc3VpdGUuXG4gICAgICogQG5hbWUgU3VpdGUjcGFyZW50U3VpdGVcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7U3VpdGV9XG4gICAgICovXG4gICAgdGhpcy5wYXJlbnRTdWl0ZSA9IHN1aXRlLnBhcmVudFN1aXRlID8gc3VpdGUucGFyZW50U3VpdGUubWV0YWRhdGEgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlc2NyaXB0aW9uIHBhc3NlZCB0byB0aGUge0BsaW5rIGRlc2NyaWJlfSB0aGF0IGNyZWF0ZWQgdGhpcyBzdWl0ZS5cbiAgICAgKiBAbmFtZSBTdWl0ZSNkZXNjcmlwdGlvblxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IHN1aXRlLmRlc2NyaXB0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBmdWxsIGRlc2NyaXB0aW9uIGluY2x1ZGluZyBhbGwgYW5jZXN0b3JzIG9mIHRoaXMgc3VpdGUuXG4gICAqIEBuYW1lIFN1aXRlI2dldEZ1bGxOYW1lXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgU3VpdGVNZXRhZGF0YS5wcm90b3R5cGUuZ2V0RnVsbE5hbWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zdWl0ZV8uZ2V0RnVsbE5hbWUoKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIHN1aXRlJ3MgY2hpbGRyZW4uXG4gICAqIEBuYW1lIFN1aXRlI2NoaWxkcmVuXG4gICAqIEB0eXBlIHtBcnJheS48KFNwZWN8U3VpdGUpPn1cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdWl0ZU1ldGFkYXRhLnByb3RvdHlwZSwgJ2NoaWxkcmVuJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdWl0ZV8uY2hpbGRyZW4ubWFwKGNoaWxkID0+IGNoaWxkLm1ldGFkYXRhKTtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGlzRmFpbHVyZShhcmdzKSB7XG4gICAgcmV0dXJuICFhcmdzWzBdO1xuICB9XG5cbiAgcmV0dXJuIFN1aXRlO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5UaW1lciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZGVmYXVsdE5vdyA9IChmdW5jdGlvbihEYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH07XG4gIH0pKERhdGUpO1xuXG4gIGZ1bmN0aW9uIFRpbWVyKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBub3cgPSBvcHRpb25zLm5vdyB8fCBkZWZhdWx0Tm93LFxuICAgICAgc3RhcnRUaW1lO1xuXG4gICAgdGhpcy5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgc3RhcnRUaW1lID0gbm93KCk7XG4gICAgfTtcblxuICAgIHRoaXMuZWxhcHNlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5vdygpIC0gc3RhcnRUaW1lO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gVGltZXI7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlRyZWVQcm9jZXNzb3IgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gVHJlZVByb2Nlc3NvcihhdHRycykge1xuICAgIHZhciB0cmVlID0gYXR0cnMudHJlZSxcbiAgICAgIHJ1bm5hYmxlSWRzID0gYXR0cnMucnVubmFibGVJZHMsXG4gICAgICBxdWV1ZVJ1bm5lckZhY3RvcnkgPSBhdHRycy5xdWV1ZVJ1bm5lckZhY3RvcnksXG4gICAgICBub2RlU3RhcnQgPSBhdHRycy5ub2RlU3RhcnQgfHwgZnVuY3Rpb24oKSB7fSxcbiAgICAgIG5vZGVDb21wbGV0ZSA9IGF0dHJzLm5vZGVDb21wbGV0ZSB8fCBmdW5jdGlvbigpIHt9LFxuICAgICAgZmFpbFNwZWNXaXRoTm9FeHBlY3RhdGlvbnMgPSAhIWF0dHJzLmZhaWxTcGVjV2l0aE5vRXhwZWN0YXRpb25zLFxuICAgICAgb3JkZXJDaGlsZHJlbiA9XG4gICAgICAgIGF0dHJzLm9yZGVyQ2hpbGRyZW4gfHxcbiAgICAgICAgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuO1xuICAgICAgICB9LFxuICAgICAgZXhjbHVkZU5vZGUgPVxuICAgICAgICBhdHRycy5leGNsdWRlTm9kZSB8fFxuICAgICAgICBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgc3RhdHMgPSB7IHZhbGlkOiB0cnVlIH0sXG4gICAgICBwcm9jZXNzZWQgPSBmYWxzZSxcbiAgICAgIGRlZmF1bHRNaW4gPSBJbmZpbml0eSxcbiAgICAgIGRlZmF1bHRNYXggPSAxIC0gSW5maW5pdHk7XG5cbiAgICB0aGlzLnByb2Nlc3NUcmVlID0gZnVuY3Rpb24oKSB7XG4gICAgICBwcm9jZXNzTm9kZSh0cmVlLCB0cnVlKTtcbiAgICAgIHByb2Nlc3NlZCA9IHRydWU7XG4gICAgICByZXR1cm4gc3RhdHM7XG4gICAgfTtcblxuICAgIHRoaXMuZXhlY3V0ZSA9IGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgIGlmICghcHJvY2Vzc2VkKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc1RyZWUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzdGF0cy52YWxpZCkge1xuICAgICAgICB0aHJvdyAnaW52YWxpZCBvcmRlcic7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGlsZEZucyA9IHdyYXBDaGlsZHJlbih0cmVlLCAwKTtcblxuICAgICAgcXVldWVSdW5uZXJGYWN0b3J5KHtcbiAgICAgICAgcXVldWVhYmxlRm5zOiBjaGlsZEZucyxcbiAgICAgICAgdXNlckNvbnRleHQ6IHRyZWUuc2hhcmVkVXNlckNvbnRleHQoKSxcbiAgICAgICAgb25FeGNlcHRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRyZWUub25FeGNlcHRpb24uYXBwbHkodHJlZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Db21wbGV0ZTogZG9uZSxcbiAgICAgICAgb25NdWx0aXBsZURvbmU6IHRyZWUub25NdWx0aXBsZURvbmVcbiAgICAgICAgICA/IHRyZWUub25NdWx0aXBsZURvbmUuYmluZCh0cmVlKVxuICAgICAgICAgIDogbnVsbFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJ1bm5hYmxlSW5kZXgoaWQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVubmFibGVJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJ1bm5hYmxlSWRzW2ldID09PSBpZCkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc05vZGUobm9kZSwgcGFyZW50RXhjbHVkZWQpIHtcbiAgICAgIHZhciBleGVjdXRhYmxlSW5kZXggPSBydW5uYWJsZUluZGV4KG5vZGUuaWQpO1xuXG4gICAgICBpZiAoZXhlY3V0YWJsZUluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyZW50RXhjbHVkZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBleGNsdWRlZCA9IHBhcmVudEV4Y2x1ZGVkIHx8IGV4Y2x1ZGVOb2RlKG5vZGUpO1xuICAgICAgICBzdGF0c1tub2RlLmlkXSA9IHtcbiAgICAgICAgICBleGNsdWRlZDogZXhjbHVkZWQsXG4gICAgICAgICAgd2lsbEV4ZWN1dGU6ICFleGNsdWRlZCAmJiAhbm9kZS5tYXJrZWRQZW5kaW5nLFxuICAgICAgICAgIHNlZ21lbnRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgICAgICBvd25lcjogbm9kZSxcbiAgICAgICAgICAgICAgbm9kZXM6IFtub2RlXSxcbiAgICAgICAgICAgICAgbWluOiBzdGFydGluZ01pbihleGVjdXRhYmxlSW5kZXgpLFxuICAgICAgICAgICAgICBtYXg6IHN0YXJ0aW5nTWF4KGV4ZWN1dGFibGVJbmRleClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaGFzRXhlY3V0YWJsZUNoaWxkID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIG9yZGVyZWRDaGlsZHJlbiA9IG9yZGVyQ2hpbGRyZW4obm9kZSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlcmVkQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBvcmRlcmVkQ2hpbGRyZW5baV07XG5cbiAgICAgICAgICBwcm9jZXNzTm9kZShjaGlsZCwgcGFyZW50RXhjbHVkZWQpO1xuXG4gICAgICAgICAgaWYgKCFzdGF0cy52YWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjaGlsZFN0YXRzID0gc3RhdHNbY2hpbGQuaWRdO1xuXG4gICAgICAgICAgaGFzRXhlY3V0YWJsZUNoaWxkID0gaGFzRXhlY3V0YWJsZUNoaWxkIHx8IGNoaWxkU3RhdHMud2lsbEV4ZWN1dGU7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0c1tub2RlLmlkXSA9IHtcbiAgICAgICAgICBleGNsdWRlZDogcGFyZW50RXhjbHVkZWQsXG4gICAgICAgICAgd2lsbEV4ZWN1dGU6IGhhc0V4ZWN1dGFibGVDaGlsZFxuICAgICAgICB9O1xuXG4gICAgICAgIHNlZ21lbnRDaGlsZHJlbihub2RlLCBvcmRlcmVkQ2hpbGRyZW4sIHN0YXRzW25vZGUuaWRdLCBleGVjdXRhYmxlSW5kZXgpO1xuXG4gICAgICAgIGlmICghbm9kZS5jYW5CZVJlZW50ZXJlZCgpICYmIHN0YXRzW25vZGUuaWRdLnNlZ21lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBzdGF0cyA9IHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydGluZ01pbihleGVjdXRhYmxlSW5kZXgpIHtcbiAgICAgIHJldHVybiBleGVjdXRhYmxlSW5kZXggPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRNaW4gOiBleGVjdXRhYmxlSW5kZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRpbmdNYXgoZXhlY3V0YWJsZUluZGV4KSB7XG4gICAgICByZXR1cm4gZXhlY3V0YWJsZUluZGV4ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0TWF4IDogZXhlY3V0YWJsZUluZGV4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlZ21lbnRDaGlsZHJlbihcbiAgICAgIG5vZGUsXG4gICAgICBvcmRlcmVkQ2hpbGRyZW4sXG4gICAgICBub2RlU3RhdHMsXG4gICAgICBleGVjdXRhYmxlSW5kZXhcbiAgICApIHtcbiAgICAgIHZhciBjdXJyZW50U2VnbWVudCA9IHtcbiAgICAgICAgICBpbmRleDogMCxcbiAgICAgICAgICBvd25lcjogbm9kZSxcbiAgICAgICAgICBub2RlczogW10sXG4gICAgICAgICAgbWluOiBzdGFydGluZ01pbihleGVjdXRhYmxlSW5kZXgpLFxuICAgICAgICAgIG1heDogc3RhcnRpbmdNYXgoZXhlY3V0YWJsZUluZGV4KVxuICAgICAgICB9LFxuICAgICAgICByZXN1bHQgPSBbY3VycmVudFNlZ21lbnRdLFxuICAgICAgICBsYXN0TWF4ID0gZGVmYXVsdE1heCxcbiAgICAgICAgb3JkZXJlZENoaWxkU2VnbWVudHMgPSBvcmRlckNoaWxkU2VnbWVudHMob3JkZXJlZENoaWxkcmVuKTtcblxuICAgICAgZnVuY3Rpb24gaXNTZWdtZW50Qm91bmRhcnkobWluSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBsYXN0TWF4ICE9PSBkZWZhdWx0TWF4ICYmXG4gICAgICAgICAgbWluSW5kZXggIT09IGRlZmF1bHRNaW4gJiZcbiAgICAgICAgICBsYXN0TWF4IDwgbWluSW5kZXggLSAxXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXJlZENoaWxkU2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkU2VnbWVudCA9IG9yZGVyZWRDaGlsZFNlZ21lbnRzW2ldLFxuICAgICAgICAgIG1heEluZGV4ID0gY2hpbGRTZWdtZW50Lm1heCxcbiAgICAgICAgICBtaW5JbmRleCA9IGNoaWxkU2VnbWVudC5taW47XG5cbiAgICAgICAgaWYgKGlzU2VnbWVudEJvdW5kYXJ5KG1pbkluZGV4KSkge1xuICAgICAgICAgIGN1cnJlbnRTZWdtZW50ID0ge1xuICAgICAgICAgICAgaW5kZXg6IHJlc3VsdC5sZW5ndGgsXG4gICAgICAgICAgICBvd25lcjogbm9kZSxcbiAgICAgICAgICAgIG5vZGVzOiBbXSxcbiAgICAgICAgICAgIG1pbjogZGVmYXVsdE1pbixcbiAgICAgICAgICAgIG1heDogZGVmYXVsdE1heFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudFNlZ21lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudFNlZ21lbnQubm9kZXMucHVzaChjaGlsZFNlZ21lbnQpO1xuICAgICAgICBjdXJyZW50U2VnbWVudC5taW4gPSBNYXRoLm1pbihjdXJyZW50U2VnbWVudC5taW4sIG1pbkluZGV4KTtcbiAgICAgICAgY3VycmVudFNlZ21lbnQubWF4ID0gTWF0aC5tYXgoY3VycmVudFNlZ21lbnQubWF4LCBtYXhJbmRleCk7XG4gICAgICAgIGxhc3RNYXggPSBtYXhJbmRleDtcbiAgICAgIH1cblxuICAgICAgbm9kZVN0YXRzLnNlZ21lbnRzID0gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9yZGVyQ2hpbGRTZWdtZW50cyhjaGlsZHJlbikge1xuICAgICAgdmFyIHNwZWNpZmllZE9yZGVyID0gW10sXG4gICAgICAgIHVuc3BlY2lmaWVkT3JkZXIgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXSxcbiAgICAgICAgICBzZWdtZW50cyA9IHN0YXRzW2NoaWxkLmlkXS5zZWdtZW50cztcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlZ21lbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIHNlZyA9IHNlZ21lbnRzW2pdO1xuXG4gICAgICAgICAgaWYgKHNlZy5taW4gPT09IGRlZmF1bHRNaW4pIHtcbiAgICAgICAgICAgIHVuc3BlY2lmaWVkT3JkZXIucHVzaChzZWcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzcGVjaWZpZWRPcmRlci5wdXNoKHNlZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNwZWNpZmllZE9yZGVyLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gYS5taW4gLSBiLm1pbjtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gc3BlY2lmaWVkT3JkZXIuY29uY2F0KHVuc3BlY2lmaWVkT3JkZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4ZWN1dGVOb2RlKG5vZGUsIHNlZ21lbnROdW1iZXIpIHtcbiAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZm46IGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIHZhciBvblN0YXJ0ID0ge1xuICAgICAgICAgICAgICBmbjogZnVuY3Rpb24obmV4dCkge1xuICAgICAgICAgICAgICAgIG5vZGVTdGFydChub2RlLCBuZXh0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcXVldWVSdW5uZXJGYWN0b3J5KHtcbiAgICAgICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIFswXSk7XG4gICAgICAgICAgICAgICAgbm9kZS5jbGVhbnVwQmVmb3JlQWZ0ZXIoKTtcbiAgICAgICAgICAgICAgICBub2RlQ29tcGxldGUobm9kZSwgbm9kZS5nZXRSZXN1bHQoKSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBkb25lLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHF1ZXVlYWJsZUZuczogW29uU3RhcnRdLmNvbmNhdCh3cmFwQ2hpbGRyZW4obm9kZSwgc2VnbWVudE51bWJlcikpLFxuICAgICAgICAgICAgICB1c2VyQ29udGV4dDogbm9kZS5zaGFyZWRVc2VyQ29udGV4dCgpLFxuICAgICAgICAgICAgICBvbkV4Y2VwdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5vbkV4Y2VwdGlvbi5hcHBseShub2RlLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvbk11bHRpcGxlRG9uZTogbm9kZS5vbk11bHRpcGxlRG9uZVxuICAgICAgICAgICAgICAgID8gbm9kZS5vbk11bHRpcGxlRG9uZS5iaW5kKG5vZGUpXG4gICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGZuOiBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICBub2RlLmV4ZWN1dGUoXG4gICAgICAgICAgICAgIGRvbmUsXG4gICAgICAgICAgICAgIHN0YXRzW25vZGUuaWRdLmV4Y2x1ZGVkLFxuICAgICAgICAgICAgICBmYWlsU3BlY1dpdGhOb0V4cGVjdGF0aW9uc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd3JhcENoaWxkcmVuKG5vZGUsIHNlZ21lbnROdW1iZXIpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgc2VnbWVudENoaWxkcmVuID0gc3RhdHNbbm9kZS5pZF0uc2VnbWVudHNbc2VnbWVudE51bWJlcl0ubm9kZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgIGV4ZWN1dGVOb2RlKHNlZ21lbnRDaGlsZHJlbltpXS5vd25lciwgc2VnbWVudENoaWxkcmVuW2ldLmluZGV4KVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXN0YXRzW25vZGUuaWRdLndpbGxFeGVjdXRlKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlLmJlZm9yZUFsbEZucy5jb25jYXQocmVzdWx0KS5jb25jYXQobm9kZS5hZnRlckFsbEZucyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFRyZWVQcm9jZXNzb3I7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlVzZXJDb250ZXh0ID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gVXNlckNvbnRleHQoKSB7fVxuXG4gIFVzZXJDb250ZXh0LmZyb21FeGlzdGluZyA9IGZ1bmN0aW9uKG9sZENvbnRleHQpIHtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBVc2VyQ29udGV4dCgpO1xuXG4gICAgZm9yICh2YXIgcHJvcCBpbiBvbGRDb250ZXh0KSB7XG4gICAgICBpZiAob2xkQ29udGV4dC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICBjb250ZXh0W3Byb3BdID0gb2xkQ29udGV4dFtwcm9wXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gVXNlckNvbnRleHQ7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnZlcnNpb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICc0LjAuMSc7XG59O1xuIiwiZXhwb3J0IGRlZmF1bHQgXCJzdHJ1Y3QgUGVybXV0YXRpb25zIHtcXG4gIFBlcm0gOiBhcnJheTxpMzIsIDUxMj4sXFxufTtcXG5cXG5AYmluZGluZygwKSBAZ3JvdXAoMClcXG52YXI8c3RvcmFnZSwgcmVhZD4gcGVybSA6IFBlcm11dGF0aW9ucztcXG5cXG5zdHJ1Y3QgQ29ybmVyTWF0ZXJpYWxzIHtcXG4gIGNvcm5lck1hdGVyaWFscyA6IGFycmF5PHUzMj4sXFxufTtcXG5cXG5AYmluZGluZygxKSBAZ3JvdXAoMClcXG52YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gY29ybmVyTWF0ZXJpYWxzOiBDb3JuZXJNYXRlcmlhbHM7XFxuXFxuc3RydWN0IFZveGVsTWF0ZXJpYWxzIHtcXG4gIHZveGVsTWF0ZXJpYWxzIDogYXJyYXk8dTMyPixcXG59O1xcblxcbkBiaW5kaW5nKDIpIEBncm91cCgwKVxcbnZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiB2b3hlbE1hdGVyaWFsczogVm94ZWxNYXRlcmlhbHM7XFxuXFxuc3RydWN0IENvcm5lckluZGV4IHtcXG4gIGNvcm5lckNvdW50IDogdTMyLFxcbiAgY29ybmVySW5kZXhlcyA6IGFycmF5PHUzMj5cXG59O1xcblxcbkBiaW5kaW5nKDMpIEBncm91cCgwKVxcbnZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBjb3JuZXJJbmRleDogQ29ybmVySW5kZXg7XFxuXFxuc3RydWN0IEdQVVZPWFxcbntcXG5cXHR2b3hNaW46IHZlYzM8ZjMyPixcXG5cXHRjb3JuZXJzOiBmMzIsXFxuXFx0dmVydFBvaW50OiB2ZWMzPGYzMj4sXFxuXFx0YXZnTm9ybWFsOiB2ZWMzPGYzMj4sXFxuXFx0bnVtUG9pbnRzOiBmMzJcXG59O1xcbnN0cnVjdCBHUFVWT1hTIHtcXG4gIHZveGVscyA6IGFycmF5PEdQVVZPWD4sXFxufTtcXG5cXG5AYmluZGluZyg0KSBAZ3JvdXAoMClcXG52YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gdm94ZWxzOiBHUFVWT1hTO1xcblxcbnN0cnVjdCBVbmlmb3JtQnVmZmVyT2JqZWN0IHtcXG4gIGNodW5rUG9zaXRpb24gOiB2ZWMzPGYzMj4sXFxuICBzdHJpZGUgOiBmMzIsXFxuXFx0d2lkdGg6IHUzMlxcbn07XFxuXFxuQGJpbmRpbmcoNSkgQGdyb3VwKDApXFxudmFyPHVuaWZvcm0+IHVuaWZvcm1zIDogVW5pZm9ybUJ1ZmZlck9iamVjdDtcXG5cXG5jb25zdCBDSElMRF9NSU5fT0ZGU0VUUzogYXJyYXk8dmVjMzx1MzI+LCA4PiA9IGFycmF5PHZlYzM8dTMyPiwgOD5cXG4oXFxuICB2ZWMzPHUzMj4oMHUsIDB1LCAwdSksXFxuICB2ZWMzPHUzMj4oMHUsIDB1LCAxdSksXFxuICB2ZWMzPHUzMj4oMHUsIDF1LCAwdSksXFxuICB2ZWMzPHUzMj4oMHUsIDF1LCAxdSksXFxuICB2ZWMzPHUzMj4oMXUsIDB1LCAwdSksXFxuICB2ZWMzPHUzMj4oMXUsIDB1LCAxdSksXFxuICB2ZWMzPHUzMj4oMXUsIDF1LCAwdSksXFxuICB2ZWMzPHUzMj4oMXUsIDF1LCAxdSlcXG4pO1xcblxcbmNvbnN0IGVkZ2V2bWFwOiBhcnJheTx2ZWMyPGkzMj4sIDEyPiA9IGFycmF5PHZlYzI8aTMyPiwgMTI+XFxuKFxcblxcdHZlYzI8aTMyPigwLDQpLCB2ZWMyPGkzMj4oMSw1KSwgdmVjMjxpMzI+KDIsNiksIHZlYzI8aTMyPigzLDcpLFxcblxcdHZlYzI8aTMyPigwLDIpLCB2ZWMyPGkzMj4oMSwzKSwgdmVjMjxpMzI+KDQsNiksIHZlYzI8aTMyPig1LDcpLFxcblxcdHZlYzI8aTMyPigwLDEpLCB2ZWMyPGkzMj4oMiwzKSwgdmVjMjxpMzI+KDQsNSksIHZlYzI8aTMyPig2LDcpXFxuKTtcXG5cXG5mbiByYW5kb20oaTogdmVjMjxmMzI+KSAtPiBmMzIge1xcbiAgcmV0dXJuIGZyYWN0KHNpbihkb3QoaSx2ZWMyKDEyLjk4OTgsNzguMjMzKSkpKjQzNzU4LjU0NTMxMjMpO1xcbn1cXG5cXG5mbiBWZWMzRG90KGE6IHZlYzM8ZjMyPiwgYjogdmVjMzxmMzI+KSAtPiBmMzJcXG57XFxuXFx0cmV0dXJuIChhLnggKiBiLngpICsgKGEueSAqIGIueSkgKyAoYS56ICogYi56KTtcXG59XFxuXFxuY29uc3QgR3JhZDM6IGFycmF5PHZlYzM8ZjMyPiwgMTI+ID0gYXJyYXk8dmVjMzxmMzI+LCAxMj4oXFxuXFx0dmVjMzxmMzI+KDEuMCwxLjAsMC4wKSwgdmVjMzxmMzI+KC0xLjAsMS4wLDAuMCksIHZlYzM8ZjMyPigxLjAsLTEuMCwwLjApLCB2ZWMzPGYzMj4oLTEuMCwtMS4wLDAuMCksXFxuXFx0dmVjMzxmMzI+KDEuMCwwLjAsMS4wKSwgdmVjMzxmMzI+KC0xLjAsMC4wLDEuMCksIHZlYzM8ZjMyPigxLjAsMC4wLC0xLjApLCB2ZWMzPGYzMj4oLTEuMCwwLjAsLTEuMCksXFxuXFx0dmVjMzxmMzI+KDAuMCwxLjAsMS4wKSwgdmVjMzxmMzI+KDAuMCwtMS4wLDEuMCksIHZlYzM8ZjMyPigwLjAsMS4wLC0xLjApLCB2ZWMzPGYzMj4oMC4wLC0xLjAsLTEuMClcXG4pO1xcblxcbmZuIFBlcmxpbih4MTogZjMyLCB5MTogZjMyLCB6MTogZjMyKSAtPiBmMzJcXG57XFxuXFx0dmFyIFg6IGkzMiA9IDA7XFxuXFx0aWYgKHgxID4gMC4wKSB7XFxuXFx0XFx0WCA9IGkzMih4MSk7XFxuXFx0fSBlbHNlIHtcXG5cXHRcXHRYID0gaTMyKHgxKSAtIDE7XFxuXFx0fVxcblxcblxcdHZhciBZOiBpMzIgPSAwO1xcblxcdGlmICh5MSA+IDAuMCkge1xcblxcdFxcdFkgPSBpMzIoeTEpO1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0WSA9IGkzMih5MSkgLSAxO1xcblxcdH1cXG5cXG5cXHR2YXIgWjogaTMyID0gMDtcXG5cXHRpZiAoejEgPiAwLjApIHtcXG5cXHRcXHRaID0gaTMyKHoxKTtcXG5cXHR9IGVsc2Uge1xcblxcdFxcdFogPSBpMzIoejEpIC0gMTtcXG5cXHR9XFxuXFx0XFxuXFx0bGV0IHg6IGYzMiA9IHgxIC0gZjMyKFgpO1xcblxcdGxldCB5OiBmMzIgPSB5MSAtIGYzMihZKTtcXG5cXHRsZXQgejogZjMyID0gejEgLSBmMzIoWik7XFxuXFx0XFxuXFx0WCA9IFggJiAyNTU7XFxuXFx0WSA9IFkgJiAyNTU7XFxuXFx0WiA9IFogJiAyNTU7XFxuXFx0XFxuXFx0bGV0IGdpMDAwOiBpMzIgPSAocGVybS5QZXJtW1ggKyBwZXJtLlBlcm1bWSArIHBlcm0uUGVybVtaXSBdIF0gJSAxMik7XFxuXFx0bGV0IGdpMDAxOiBpMzIgPSAocGVybS5QZXJtW1ggKyBwZXJtLlBlcm1bWSArIHBlcm0uUGVybVtaICsgMV0gXSBdICUgMTIpO1xcblxcdGxldCBnaTAxMDogaTMyID0gKHBlcm0uUGVybVtYICsgcGVybS5QZXJtW1kgKyAxICsgcGVybS5QZXJtW1pdIF0gXSAlIDEyKTtcXG5cXHRsZXQgZ2kwMTE6IGkzMiA9IChwZXJtLlBlcm1bWCArIHBlcm0uUGVybVtZICsgMSArIHBlcm0uUGVybVtaICsgMV0gXSBdICUgMTIpO1xcblxcdGxldCBnaTEwMDogaTMyID0gKHBlcm0uUGVybVtYICsgMSArIHBlcm0uUGVybVtZICsgcGVybS5QZXJtW1pdIF0gXSAlIDEyKTtcXG5cXHRsZXQgZ2kxMDE6IGkzMiA9IChwZXJtLlBlcm1bWCArIDEgKyBwZXJtLlBlcm1bWSArIHBlcm0uUGVybVtaICsgMV0gXSBdICUgMTIpO1xcblxcdGxldCBnaTExMDogaTMyID0gKHBlcm0uUGVybVtYICsgMSArIHBlcm0uUGVybVtZICsgMSArIHBlcm0uUGVybVtaXSBdIF0gJSAxMik7XFxuXFx0bGV0IGdpMTExOiBpMzIgPSAocGVybS5QZXJtW1ggKyAxICsgcGVybS5QZXJtW1kgKyAxICsgcGVybS5QZXJtW1ogKyAxXSBdIF0gJSAxMik7XFxuXFxuXFx0bGV0IG4wMDA6IGYzMiA9IGRvdChHcmFkM1tnaTAwMF0sIHZlYzM8ZjMyPih4LCB5LCB6KSk7XFxuXFx0bGV0IG4xMDA6IGYzMiA9IGRvdChHcmFkM1tnaTEwMF0sIHZlYzM8ZjMyPih4IC0gMS4wLCB5LCB6KSk7XFxuXFx0bGV0IG4wMTA6IGYzMiA9IGRvdChHcmFkM1tnaTAxMF0sIHZlYzM8ZjMyPih4LCB5IC0gMS4wLCB6KSk7XFxuXFx0bGV0IG4xMTA6IGYzMiA9IGRvdChHcmFkM1tnaTExMF0sIHZlYzM8ZjMyPih4IC0gMS4wLCB5IC0gMS4wLCB6KSk7XFxuXFx0bGV0IG4wMDE6IGYzMiA9IGRvdChHcmFkM1tnaTAwMV0sIHZlYzM8ZjMyPih4LCB5LCB6IC0gMS4wKSk7XFxuXFx0bGV0IG4xMDE6IGYzMiA9IGRvdChHcmFkM1tnaTEwMV0sIHZlYzM8ZjMyPih4IC0gMS4wLCB5LCB6IC0gMS4wKSk7XFxuXFx0bGV0IG4wMTE6IGYzMiA9IGRvdChHcmFkM1tnaTAxMV0sIHZlYzM8ZjMyPih4LCB5IC0gMS4wLCB6IC0gMS4wKSk7XFxuXFx0bGV0IG4xMTE6IGYzMiA9IGRvdChHcmFkM1tnaTExMV0sIHZlYzM8ZjMyPih4IC0gMS4wLCB5IC0gMS4wLCB6IC0gMS4wKSk7XFxuXFx0XFxuXFx0bGV0IHU6IGYzMiA9IGYzMih4ICogeCAqIHggKiAoeCAqICh4ICogNi4wIC0gMTUuMCkgKyAxMC4wKSk7XFxuXFx0bGV0IHY6IGYzMiA9IGYzMih5ICogeSAqIHkgKiAoeSAqICh5ICogNi4wIC0gMTUuMCkgKyAxMC4wKSk7XFxuXFx0bGV0IHc6IGYzMiA9IGYzMih6ICogeiAqIHogKiAoeiAqICh6ICogNi4wIC0gMTUuMCkgKyAxMC4wKSk7XFxuXFx0bGV0IG54MDA6IGYzMiA9IG1peChuMDAwLCBuMTAwLCB1KTtcXG5cXHRsZXQgbngwMTogZjMyID0gbWl4KG4wMDEsIG4xMDEsIHUpO1xcblxcdGxldCBueDEwOiBmMzIgPSBtaXgobjAxMCwgbjExMCwgdSk7XFxuXFx0bGV0IG54MTE6IGYzMiA9IG1peChuMDExLCBuMTExLCB1KTtcXG5cXHRsZXQgbnh5MDogZjMyID0gbWl4KG54MDAsIG54MTAsIHYpO1xcblxcdGxldCBueHkxOiBmMzIgPSBtaXgobngwMSwgbngxMSwgdik7XFxuXFx0bGV0IG54eXo6IGYzMiA9IG1peChueHkwLCBueHkxLCB3KTtcXG5cXHRcXG5cXHRyZXR1cm4gbnh5ejtcXG59XFxuXFxuZm4gRnJhY3RhbE5vaXNlKG9jdGF2ZXM6IGkzMiwgZnJlcXVlbmN5OiBmMzIsIGxhY3VuYXJpdHk6IGYzMiwgcGVyc2lzdGVuY2U6IGYzMiwgcG9zaXRpb246IHZlYzM8ZjMyPikgLT4gZjMyXFxue1xcblxcdGxldCBTQ0FMRTogZjMyID0gMS4wIC8gMTI4LjA7XFxuXFx0dmFyIHA6IHZlYzM8ZjMyPiA9IHBvc2l0aW9uICogU0NBTEU7XFxuXFx0dmFyIG5vaXM6IGYzMiA9IDAuMDtcXG5cXG5cXHR2YXIgYW1wbGl0dWRlOiBmMzIgPSAxLjA7XFxuXFx0cCA9IHAgKiBmcmVxdWVuY3k7XFxuXFxuXFx0dmFyIGk6IGkzMiA9IDA7XFxuXFx0bG9vcCB7XFxuXFx0XFx0aWYgKGkgPj0gb2N0YXZlcykgeyBicmVhazsgfVxcblxcblxcdFxcdG5vaXMgPSBub2lzICsgUGVybGluKHAueCwgcC55LCBwLnopICogYW1wbGl0dWRlO1xcblxcdFxcdHAgPSBwICogbGFjdW5hcml0eTtcXG5cXHRcXHRhbXBsaXR1ZGUgPSBhbXBsaXR1ZGUgKiBwZXJzaXN0ZW5jZTtcXG5cXG5cXHRcXHRjb250aW51aW5nIHtcXG5cXHRcXHRcXHRpID0gaSArIDE7XFxuXFx0XFx0fVxcblxcdH1cXG5cXHRcXG5cXHRyZXR1cm4gbm9pcztcXG59XFxuXFxuZm4gRnJhY3RhbE5vaXNlMShmcmVxdWVuY3k6IGYzMiwgbGFjdW5hcml0eTogZjMyLCBwZXJzaXN0ZW5jZTogZjMyLCBwb3NpdGlvbjogdmVjMzxmMzI+KSAtPiBmMzJcXG57XFxuXFx0bGV0IFNDQUxFOiBmMzIgPSAxLjAgLyAxMjguMDtcXG5cXHR2YXIgcDogdmVjMzxmMzI+ID0gcG9zaXRpb24gKiBTQ0FMRTtcXG5cXHR2YXIgbm9pczogZjMyID0gMC4wO1xcblxcblxcdHZhciBhbXBsaXR1ZGU6IGYzMiA9IDEuMDtcXG5cXHRwID0gcCAqIGZyZXF1ZW5jeTtcXG5cXHRcXG5cXHRub2lzID0gbm9pcyArIFBlcmxpbihwLngsIHAueSwgcC56KSAqIGFtcGxpdHVkZTtcXG5cXHRwID0gcCAqIGxhY3VuYXJpdHk7XFxuXFx0YW1wbGl0dWRlID0gYW1wbGl0dWRlICogcGVyc2lzdGVuY2U7XFxuXFx0XFxuXFx0cmV0dXJuIG5vaXM7XFxufVxcblxcbmZuIENhbGN1bGF0ZU5vaXNlVmFsdWUocG9zOiB2ZWMzPGYzMj4sIHNjYWxlOiBmMzIpIC0+IGYzMlxcbntcXG5cXHRyZXR1cm4gRnJhY3RhbE5vaXNlKDQsIDAuNTM0MywgMi4yMzI0LCAwLjY4MzI0LCBwb3MgKiBzY2FsZSk7XFxufVxcblxcbmZuIENMZXJwKGE6IGYzMiwgYjogZjMyLCB0OiBmMzIpIC0+IGYzMlxcbntcXG5cXHRyZXR1cm4gKDEuMCAtIHQpICogYSArIHQgKiBiO1xcbn1cXG5cXG4vLyBTVkRcXG5cXG5jb25zdCBTVkRfTlVNX1NXRUVQUzogaTMyID0gNDtcXG5jb25zdCBQU1VFRE9fSU5WRVJTRV9USFJFU0hPTEQ6IGYzMiA9IDAuMDAwMDAwMDE7XFxuXFxuZm4gc3ZkX211bF9tYXRyaXhfdmVjKG06IG1hdDN4MzxmMzI+LCBiOiB2ZWM0PGYzMj4pIC0+IHZlYzQ8ZjMyPlxcbntcXG5cXHR2YXIgYTogbWF0M3gzPGYzMj4gPSBtO1xcblxcdFxcblxcdHJldHVybiB2ZWM0PGYzMj4oXFxuXFx0XFx0ZG90KHZlYzQ8ZjMyPihhWzBdWzBdLCBhWzBdWzFdLCBhWzBdWzJdLCAwLjApLCBiKSxcXG5cXHRcXHRkb3QodmVjNDxmMzI+KGFbMV1bMF0sIGFbMV1bMV0sIGFbMV1bMl0sIDAuMCksIGIpLFxcblxcdFxcdGRvdCh2ZWM0PGYzMj4oYVsyXVswXSwgYVsyXVsxXSwgYVsyXVsyXSwgMC4wKSwgYiksXFxuXFx0XFx0MC4wXFxuXFx0KTtcXG59XFxuXFxuZm4gZ2l2ZW5zX2NvZWZmc19zeW0oYV9wcDogZjMyLCBhX3BxOiBmMzIsIGFfcXE6IGYzMikgLT4gdmVjMjxmMzI+XFxue1xcblxcdGlmIChhX3BxID09IDAuMCkge1xcblxcdFxcdHJldHVybiB2ZWMyPGYzMj4oMS4wLCAwLjApO1xcblxcdH1cXG5cXHRcXG5cXHRsZXQgdGF1OiBmMzIgPSAoYV9xcSAtIGFfcHApIC8gKDIuMCAqIGFfcHEpO1xcblxcdGxldCBzdHQ6IGYzMiA9IHNxcnQoMS4wICsgdGF1ICogdGF1KTtcXG5cXHR2YXIgdGFuOiBmMzI7XFxuXFx0aWYgKCh0YXUgPj0gMC4wKSkge1xcblxcdFxcdHRhbiA9ICh0YXUgKyBzdHQpO1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0dGFuID0gKHRhdSAtIHN0dCk7XFxuXFx0fVxcblxcdHRhbiA9IDEuMCAvIHRhbjtcXG5cXG5cXHRsZXQgYzogZjMyID0gaW52ZXJzZVNxcnQoMS4wICsgdGFuICogdGFuKTtcXG5cXHRsZXQgczogZjMyID0gdGFuICogYztcXG5cXG5cXHRyZXR1cm4gdmVjMjxmMzI+KGMsIHMpO1xcbn1cXG5cXG5mbiBzdmRfcm90YXRlX3h5KHg6IGYzMiwgeTogZjMyLCBjOiBmMzIsIHM6IGYzMikgLT4gdmVjMjxmMzI+XFxue1xcblxcdHJldHVybiB2ZWMyPGYzMj4oYyAqIHggLSBzICogeSwgcyAqIHggKyBjICogeSk7XFxufVxcblxcbmZuIHN2ZF9yb3RhdGVxX3h5KHg6IGYzMiwgeTogZjMyLCB6OiBmMzIsIGM6IGYzMiwgczogZjMyKSAtPiB2ZWMyPGYzMj5cXG57XFxuXFx0bGV0IGNjOiBmMzIgPSBjICogYztcXG5cXHRsZXQgc3M6IGYzMiA9IHMgKiBzO1xcblxcdGxldCBteDogZjMyID0gMi4wICogYyAqIHMgKiB6O1xcblxcblxcdHJldHVybiB2ZWMyPGYzMj4oXFxuXFx0XFx0Y2MgKiB4IC0gbXggKyBzcyAqIHksXFxuXFx0XFx0c3MgKiB4ICsgbXggKyBjYyAqIHpcXG5cXHQpO1xcbn1cXG5cXG52YXI8cHJpdmF0ZT4gdnRhdjogbWF0M3gzPGYzMj47XFxudmFyPHByaXZhdGU+IHY6IG1hdDN4MzxmMzI+O1xcbnZhcjxwcml2YXRlPiBBVEE6IGFycmF5PGYzMiwgNj47XFxudmFyPHByaXZhdGU+IEF0YjogdmVjNDxmMzI+O1xcbnZhcjxwcml2YXRlPiBwb2ludGFjY3VtOiB2ZWM0PGYzMj47XFxudmFyPHByaXZhdGU+IGJ0YjogZjMyO1xcblxcbmZuIHN2ZF9yb3RhdGUoYTogaTMyLCBiOiBpMzIpXFxue1xcblxcdGlmICh2dGF2W2FdW2JdID09IDAuMCkgeyByZXR1cm47IH1cXG5cXG5cXG5cXHRcXG5cXHRsZXQgY29lZmZzOiB2ZWMyPGYzMj4gPSBnaXZlbnNfY29lZmZzX3N5bSh2dGF2W2FdW2FdLCB2dGF2W2FdW2JdLCB2dGF2W2JdW2JdKTtcXG5cXHRsZXQgYzogZjMyID0gY29lZmZzLng7XFxuXFx0bGV0IHM6IGYzMiA9IGNvZWZmcy55O1xcblxcdFxcblxcdGxldCByb3QxOiB2ZWMyPGYzMj4gPSBzdmRfcm90YXRlcV94eSh2dGF2W2FdW2FdLCB2dGF2W2JdW2JdLCB2dGF2W2FdW2JdLCBjLCBzKTtcXG5cXHR2dGF2W2FdW2FdID0gcm90MS54O1xcblxcdHZ0YXZbYl1bYl0gPSByb3QxLnk7XFxuXFx0XFxuXFx0bGV0IHJvdDI6IHZlYzI8ZjMyPiA9IHN2ZF9yb3RhdGVfeHkodnRhdlswXVszLWJdLCB2dGF2WzEtYV1bMl0sIGMsIHMpO1xcblxcdHZ0YXZbMF1bMy1iXSA9IHJvdDIueDsgXFxuXFx0dnRhdlsxLWFdWzJdID0gcm90Mi55O1xcblxcdFxcblxcdHZ0YXZbYV1bYl0gPSAwLjA7XFxuXFx0XFxuXFx0bGV0IHJvdDM6IHZlYzI8ZjMyPiA9IHN2ZF9yb3RhdGVfeHkodlswXVthXSwgdlswXVtiXSwgYywgcyk7XFxuXFx0dlswXVthXSA9IHJvdDMueDsgdlswXVtiXSA9IHJvdDMueTtcXG5cXHRcXG5cXHRsZXQgcm90NDogdmVjMjxmMzI+ID0gc3ZkX3JvdGF0ZV94eSh2WzFdW2FdLCB2WzFdW2JdLCBjLCBzKTtcXG5cXHR2WzFdW2FdID0gcm90NC54OyB2WzFdW2JdID0gcm90NC55O1xcblxcdFxcblxcdGxldCByb3Q1OiB2ZWMyPGYzMj4gPSBzdmRfcm90YXRlX3h5KHZbMl1bYV0sIHZbMl1bYl0sIGMsIHMpO1xcblxcdHZbMl1bYV0gPSByb3Q1Lng7IHZbMl1bYl0gPSByb3Q1Lnk7XFxufVxcblxcbmZuIHN2ZF9zb2x2ZV9zeW0oYjogYXJyYXk8ZjMyLCA2PikgLT4gdmVjNDxmMzI+XFxue1xcblxcdHZhciBhOiBhcnJheTxmMzIsIDY+ID0gYjtcXG5cXHRcXG5cXHR2dGF2ID0gbWF0M3gzPGYzMj4oIFxcblxcdFxcdHZlYzM8ZjMyPihhWzBdLCBhWzFdLCBhWzJdKSwgXFxuXFx0XFx0dmVjMzxmMzI+KDAuMCwgYVszXSwgYVs0XSksIFxcblxcdFxcdHZlYzM8ZjMyPigwLjAsIDAuMCwgYVs1XSlcXG5cXHQpO1xcblxcblxcdHZhciBpOiBpMzI7XFxuXFx0bG9vcCB7XFxuXFx0XFx0aWYgKGkgPj0gU1ZEX05VTV9TV0VFUFMpIHsgYnJlYWs7IH1cXG5cXG5cXHRcXHRzdmRfcm90YXRlKDAsIDEpO1xcblxcdFxcdHN2ZF9yb3RhdGUoMCwgMik7XFxuXFx0XFx0c3ZkX3JvdGF0ZSgxLCAyKTtcXG5cXG5cXHRcXHRjb250aW51aW5nIHtcXG5cXHRcXHRcXHRpID0gaSArIDE7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHR2YXIgY29weTogbWF0M3gzPGYzMj4gPSB2dGF2O1xcblxcdHJldHVybiB2ZWM0PGYzMj4oY29weVswXVswXSwgY29weVsxXVsxXSwgY29weVsyXVsyXSwgMC4wKTtcXG59XFxuXFxuXFxuZm4gc3ZkX2ludmRldCh4OiBmMzIsIHRvbDogZjMyKSAtPiBmMzJcXG57XFxuXFx0aWYgKGFicyh4KSA8IHRvbCB8fCBhYnMoMS4wIC8geCkgPCB0b2wpIHtcXG5cXHRcXHRyZXR1cm4gMC4wO1xcblxcdH1cXG5cXHRyZXR1cm4gKDEuMCAvIHgpO1xcbn1cXG5cXG5mbiBzdmRfcHNldWRvaW52ZXJzZShzaWdtYTogdmVjNDxmMzI+LCBjOiBtYXQzeDM8ZjMyPikgLT4gbWF0M3gzPGYzMj5cXG57XFxuXFx0bGV0IGQwOiBmMzIgPSBzdmRfaW52ZGV0KHNpZ21hLngsIFBTVUVET19JTlZFUlNFX1RIUkVTSE9MRCk7XFxuXFx0bGV0IGQxOiBmMzIgPSBzdmRfaW52ZGV0KHNpZ21hLnksIFBTVUVET19JTlZFUlNFX1RIUkVTSE9MRCk7XFxuXFx0bGV0IGQyOiBmMzIgPSBzdmRfaW52ZGV0KHNpZ21hLnosIFBTVUVET19JTlZFUlNFX1RIUkVTSE9MRCk7XFxuXFxuXFx0dmFyIGNvcHk6IG1hdDN4MzxmMzI+ID0gYztcXG5cXG5cXHRyZXR1cm4gbWF0M3gzPGYzMj4gKFxcblxcdFxcdHZlYzM8ZjMyPihcXG5cXHRcXHRcXHRjb3B5WzBdWzBdICogZDAgKiBjb3B5WzBdWzBdICsgY29weVswXVsxXSAqIGQxICogY29weVswXVsxXSArIGNvcHlbMF1bMl0gKiBkMiAqIGNvcHlbMF1bMl0sXFxuXFx0XFx0XFx0Y29weVswXVswXSAqIGQwICogY29weVsxXVswXSArIGNvcHlbMF1bMV0gKiBkMSAqIGNvcHlbMV1bMV0gKyBjb3B5WzBdWzJdICogZDIgKiBjb3B5WzFdWzJdLFxcblxcdFxcdFxcdGNvcHlbMF1bMF0gKiBkMCAqIGNvcHlbMl1bMF0gKyBjb3B5WzBdWzFdICogZDEgKiBjb3B5WzJdWzFdICsgY29weVswXVsyXSAqIGQyICogY29weVsyXVsyXVxcblxcdFxcdCksXFxuXFx0XFx0dmVjMzxmMzI+KFxcblxcdFxcdFxcdGNvcHlbMV1bMF0gKiBkMCAqIGNvcHlbMF1bMF0gKyBjb3B5WzFdWzFdICogZDEgKiBjb3B5WzBdWzFdICsgY29weVsxXVsyXSAqIGQyICogY29weVswXVsyXSxcXG5cXHRcXHRcXHRjb3B5WzFdWzBdICogZDAgKiBjb3B5WzFdWzBdICsgY29weVsxXVsxXSAqIGQxICogY29weVsxXVsxXSArIGNvcHlbMV1bMl0gKiBkMiAqIGNvcHlbMV1bMl0sXFxuXFx0XFx0XFx0Y29weVsxXVswXSAqIGQwICogY29weVsyXVswXSArIGNvcHlbMV1bMV0gKiBkMSAqIGNvcHlbMl1bMV0gKyBjb3B5WzFdWzJdICogZDIgKiBjb3B5WzJdWzJdXFxuXFx0XFx0KSxcXG5cXHRcXHR2ZWMzPGYzMj4oXFxuXFx0XFx0XFx0Y29weVsyXVswXSAqIGQwICogY29weVswXVswXSArIGNvcHlbMl1bMV0gKiBkMSAqIGNvcHlbMF1bMV0gKyBjb3B5WzJdWzJdICogZDIgKiBjb3B5WzBdWzJdLFxcblxcdFxcdFxcdGNvcHlbMl1bMF0gKiBkMCAqIGNvcHlbMV1bMF0gKyBjb3B5WzJdWzFdICogZDEgKiBjb3B5WzFdWzFdICsgY29weVsyXVsyXSAqIGQyICogY29weVsxXVsyXSxcXG5cXHRcXHRcXHRjb3B5WzJdWzBdICogZDAgKiBjb3B5WzJdWzBdICsgY29weVsyXVsxXSAqIGQxICogY29weVsyXVsxXSArIGNvcHlbMl1bMl0gKiBkMiAqIGNvcHlbMl1bMl1cXG5cXHRcXHQpLFxcblxcdCk7XFxufVxcblxcbmZuIHN2ZF9zb2x2ZV9BVEFfQXRiKGE6IHZlYzQ8ZjMyPikgLT4gdmVjNDxmMzI+XFxue1xcblxcdHYgPSBtYXQzeDM8ZjMyPih2ZWMzPGYzMj4oMS4wLCAwLjAsIDAuMCksIHZlYzM8ZjMyPigwLjAsIDEuMCwgMC4wKSwgdmVjMzxmMzI+KDAuMCwgMC4wLCAxLjApKTtcXG5cXHRcXG5cXHRsZXQgc2lnbWE6IHZlYzQ8ZjMyPiA9IHN2ZF9zb2x2ZV9zeW0oQVRBKTtcXG5cXHRcXG5cXHRsZXQgVmludjogbWF0M3gzPGYzMj4gPSBzdmRfcHNldWRvaW52ZXJzZShzaWdtYSwgdik7XFxuXFx0cmV0dXJuIHN2ZF9tdWxfbWF0cml4X3ZlYyhWaW52LCBhKTtcXG59XFxuXFxuZm4gc3ZkX3ZtdWxfc3ltKHY6IHZlYzQ8ZjMyPikgLT4gdmVjNDxmMzI+XFxue1xcblxcdGxldCBBX3Jvd194OiB2ZWM0PGYzMj4gPSB2ZWM0PGYzMj4oQVRBWzBdLCBBVEFbMV0sIEFUQVsyXSwgMC4wKTtcXG5cXHRyZXR1cm4gdmVjNDxmMzI+IChcXG5cXHRcXHRkb3QoQV9yb3dfeCwgdiksXFxuXFx0XFx0QVRBWzFdICogdi54ICsgQVRBWzNdICogdi55ICsgQVRBWzRdICogdi56LFxcblxcdFxcdEFUQVsyXSAqIHYueCArIEFUQVs0XSAqIHYueSArIEFUQVs1XSAqIHYueixcXG5cXHRcXHQwLjBcXG5cXHQpO1xcbn1cXG5cXG5cXG4vLyAvLyBRRUZcXG5cXG5mbiBxZWZfYWRkKG46IHZlYzQ8ZjMyPiwgcDogdmVjNDxmMzI+KVxcbntcXG5cXHRBVEFbMF0gPSBBVEFbMF0gKyBuLnggKiBuLng7XFxuXFx0QVRBWzFdID0gQVRBWzFdICsgbi54ICogbi55O1xcblxcdEFUQVsyXSA9IEFUQVsyXSArIG4ueCAqIG4uejtcXG5cXHRBVEFbM10gPSBBVEFbM10gKyBuLnkgKiBuLnk7XFxuXFx0QVRBWzRdID0gQVRBWzRdICsgbi55ICogbi56O1xcblxcdEFUQVs1XSA9IEFUQVs1XSArIG4ueiAqIG4uejtcXG5cXHRcXG5cXHRsZXQgYjogZjMyID0gZG90KHAsIG4pO1xcblxcdEF0Yi54ID0gQXRiLnggK24ueCAqIGI7XFxuXFx0QXRiLnkgPSBBdGIueSArbi55ICogYjtcXG5cXHRBdGIueiA9IEF0Yi56ICtuLnogKiBiO1xcblxcdGJ0YiA9IGJ0YiArIGIgKiBiO1xcblxcdFxcblxcdHBvaW50YWNjdW0ueCA9IHBvaW50YWNjdW0ueCArcC54O1xcblxcdHBvaW50YWNjdW0ueSA9IHBvaW50YWNjdW0ueSArcC55O1xcblxcdHBvaW50YWNjdW0ueiA9IHBvaW50YWNjdW0ueiArcC56O1xcblxcdHBvaW50YWNjdW0udyA9IHBvaW50YWNjdW0udyArMS4wO1xcbn1cXG5cXG5mbiBxZWZfY2FsY19lcnJvcih4OiB2ZWM0PGYzMj4pIC0+IGYzMlxcbntcXG5cXHR2YXIgdG1wOiB2ZWM0PGYzMj4gPSBzdmRfdm11bF9zeW0oeCk7XFxuXFx0dG1wID0gQXRiIC0gdG1wO1xcblxcdFxcblxcdHJldHVybiBkb3QodG1wLCB0bXApO1xcbn1cXG5cXG5mbiBxZWZfc29sdmUoKSAtPiB2ZWM0PGYzMj5cXG57XFxuXFx0bGV0IG1hc3Nwb2ludDogdmVjNDxmMzI+ID0gdmVjNDxmMzI+KHBvaW50YWNjdW0ueCAvIHBvaW50YWNjdW0udywgcG9pbnRhY2N1bS55IC8gcG9pbnRhY2N1bS53LCBwb2ludGFjY3VtLnogLyBwb2ludGFjY3VtLncsIHBvaW50YWNjdW0udyAvIHBvaW50YWNjdW0udyk7XFxuXFx0XFxuXFx0dmFyIEFfbXA6IHZlYzQ8ZjMyPiA9IHN2ZF92bXVsX3N5bShtYXNzcG9pbnQpO1xcblxcdEFfbXAgPSBBdGIgLSBBX21wO1xcblxcdFxcblxcdGxldCB4OiB2ZWM0PGYzMj4gPSBzdmRfc29sdmVfQVRBX0F0YihBX21wKTtcXG5cXHRcXG5cXHRsZXQgZXJyb3I6IGYzMiA9IHFlZl9jYWxjX2Vycm9yKHgpO1xcblxcdGxldCByOiB2ZWM0PGYzMj4gPSB4ICsgbWFzc3BvaW50O1xcblxcdFxcblxcdHJldHVybiB2ZWM0PGYzMj4oci54LCByLnksIHIueiwgZXJyb3IpO1xcbn1cXG5cXG4jaW1wb3J0IGRlbnNpdHlcXG5cXG5mbiBBcHByb3hpbWF0ZVplcm9Dcm9zc2luZ1Bvc2l0aW9uKHAwOiB2ZWMzPGYzMj4sIHAxOiB2ZWMzPGYzMj4pIC0+IHZlYzM8ZjMyPlxcbntcXG5cXHR2YXIgbWluVmFsdWU6IGYzMiA9IDEwMDAwMC4wO1xcblxcdHZhciB0OiBmMzIgPSAwLjA7XFxuXFx0dmFyIGN1cnJlbnRUOiBmMzIgPSAwLjA7XFxuXFx0bGV0IHN0ZXBzOiBmMzIgPSA4LjA7XFxuXFx0bGV0IGluY3JlbWVudDogZjMyID0gMS4wIC8gc3RlcHM7XFxuXFx0bG9vcCB7XFxuXFx0XFx0aWYgKGN1cnJlbnRUID4gMS4wKSB7IGJyZWFrOyB9XFxuXFxuXFx0XFx0bGV0IHA6IHZlYzM8ZjMyPiA9IHAwICsgKChwMSAtIHAwKSAqIGN1cnJlbnRUKTtcXG5cXHRcXHRsZXQgZGVuc2l0eTogZjMyID0gYWJzKGdldERlbnNpdHkocCkpO1xcblxcdFxcdGlmIChkZW5zaXR5IDwgbWluVmFsdWUpXFxuXFx0XFx0e1xcblxcdFxcdFxcdG1pblZhbHVlID0gZGVuc2l0eTtcXG5cXHRcXHRcXHR0ID0gY3VycmVudFQ7XFxuXFx0XFx0fVxcblxcblxcdFxcdGNvbnRpbnVpbmcge1xcblxcdFxcdFxcdGN1cnJlbnRUID0gY3VycmVudFQgKyBpbmNyZW1lbnQ7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRyZXR1cm4gcDAgKyAoKHAxIC0gcDApICogdCk7XFxufVxcblxcbmZuIENhbGN1bGF0ZVN1cmZhY2VOb3JtYWwocDogdmVjMzxmMzI+KSAtPiB2ZWMzPGYzMj5cXG57XFxuXFx0bGV0IEg6IGYzMiA9IHVuaWZvcm1zLnN0cmlkZTsgLy8gVGhpcyBuZWVkcyB0byBzY2FsZSBiYXNlZCBvbiBzb21ldGhpbmcuLi5cXG5cXHRsZXQgZHg6IGYzMiA9IGdldERlbnNpdHkocCArIHZlYzM8ZjMyPihILCAwLjAsIDAuMCkpIC0gZ2V0RGVuc2l0eShwIC0gdmVjMzxmMzI+KEgsIDAuMCwgMC4wKSk7XFxuXFx0bGV0IGR5OiBmMzIgPSBnZXREZW5zaXR5KHAgKyB2ZWMzPGYzMj4oMC4wLCBILCAwLjApKSAtIGdldERlbnNpdHkocCAtIHZlYzM8ZjMyPigwLjAsIEgsIDAuMCkpO1xcblxcdGxldCBkejogZjMyID0gZ2V0RGVuc2l0eShwICsgdmVjMzxmMzI+KDAuMCwgMC4wLCBIKSkgLSBnZXREZW5zaXR5KHAgLSB2ZWMzPGYzMj4oMC4wLCAwLjAsIEgpKTtcXG5cXG5cXHRyZXR1cm4gbm9ybWFsaXplKHZlYzM8ZjMyPihkeCwgZHksIGR6KSk7XFxufVxcblxcbkBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgxMjgpXFxuZm4gbWFpbihAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgR2xvYmFsSW52b2NhdGlvbklEIDogdmVjMzx1MzI+KSB7XFxuXFx0bGV0IHRydWVJbmRleDogdTMyID0gR2xvYmFsSW52b2NhdGlvbklELng7XFxuXFxuXFx0aWYgKHRydWVJbmRleCA8IGNvcm5lckluZGV4LmNvcm5lckNvdW50KVxcblxcdHtcXG5cXHRcXHRsZXQgdXJlczogdTMyID0gMzJ1O1xcblxcblxcdFxcdGxldCBub2RlU2l6ZTogdTMyID0gdTMyKHVuaWZvcm1zLnN0cmlkZSk7XFxuXFxuXFx0XFx0bGV0IHZveGVsSW5kZXg6IHUzMiA9IGNvcm5lckluZGV4LmNvcm5lckluZGV4ZXNbdHJ1ZUluZGV4XTtcXG5cXHRcXHRsZXQgejogdTMyID0gdm94ZWxJbmRleCAvICh1cmVzICogdXJlcyk7XFxuXFx0XFx0bGV0IHk6IHUzMiA9ICh2b3hlbEluZGV4IC0gKHogKiB1cmVzICogdXJlcykpIC8gdXJlcztcXG5cXHRcXHRsZXQgeDogdTMyID0gdm94ZWxJbmRleCAtICh6ICogdXJlcyAqIHVyZXMpIC0gKHkgKiB1cmVzKTtcXG5cXG5cXHRcXHRsZXQgY29ybmVyczogdTMyID0gdm94ZWxNYXRlcmlhbHMudm94ZWxNYXRlcmlhbHNbdm94ZWxJbmRleF07XFxuXFxuXFx0XFx0bGV0IG5vZGVQb3M6IHZlYzM8ZjMyPiA9ICh2ZWMzPGYzMj4oZjMyKHgpLCBmMzIoeSksIGYzMiAoeikpICogdW5pZm9ybXMuc3RyaWRlKSArIHVuaWZvcm1zLmNodW5rUG9zaXRpb247XFxuXFx0XFx0dm94ZWxzLnZveGVsc1t0cnVlSW5kZXhdLnZveE1pbiA9IG5vZGVQb3M7XFxuXFx0XFx0bGV0IE1BWF9DUk9TU0lOR1M6IGkzMiA9IDY7XFxuXFx0XFx0dmFyIGVkZ2VDb3VudDogaTMyID0gMDtcXG5cXG5cXHRcXHRwb2ludGFjY3VtID0gdmVjNDxmMzI+KDAuMCwgMC4wLCAwLjAsIDAuMCk7XFxuXFx0XFx0QVRBID0gYXJyYXk8ZjMyLCA2PigwLjAsIDAuMCwgMC4wLCAwLjAsIDAuMCwgMC4wKTtcXG5cXHRcXHRBdGIgPSB2ZWM0PGYzMj4oMC4wLCAwLjAsIDAuMCwgMC4wKTtcXG5cXHRcXHR2YXIgYXZlcmFnZU5vcm1hbDogdmVjMzxmMzI+ID0gdmVjMzxmMzI+KDAuMCwgMC4wLCAwLjApO1xcblxcdFxcdGJ0YiA9IDAuMDtcXG5cXG5cXHRcXHR2YXIgajogaTMyID0gMDtcXG5cXHRcXHRsb29wIHtcXG5cXHRcXHRcXHRpZiAoIShqIDwgMTIgJiYgZWRnZUNvdW50IDw9IE1BWF9DUk9TU0lOR1MpKSB7XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGxldCBjMTogaTMyID0gZWRnZXZtYXBbal0ueDtcXG5cXHRcXHRcXHRsZXQgYzI6IGkzMiA9IGVkZ2V2bWFwW2pdLnk7XFxuXFxuXFx0XFx0XFx0bGV0IG0xOiB1MzIgPSAoY29ybmVycyA+PiB1MzIoYzEpKSAmIDF1O1xcblxcdFxcdFxcdGxldCBtMjogdTMyID0gKGNvcm5lcnMgPj4gdTMyKGMyKSkgJiAxdTtcXG5cXG5cXHRcXHRcXHRpZiAoISgobTEgPT0gMHUgJiYgbTIgPT0gMHUpIHx8IChtMSA9PSAxdSAmJiBtMiA9PSAxdSkpKVxcblxcdFxcdFxcdHtcXG5cXHRcXHRcXHRcXHRsZXQgcDE6IHZlYzM8ZjMyPiA9IG5vZGVQb3MgKyB2ZWMzPGYzMj4oZjMyKENISUxEX01JTl9PRkZTRVRTW2MxXS54ICogbm9kZVNpemUpLCBmMzIoQ0hJTERfTUlOX09GRlNFVFNbYzFdLnkgKiBub2RlU2l6ZSksIGYzMihDSElMRF9NSU5fT0ZGU0VUU1tjMV0ueiAqIG5vZGVTaXplKSk7XFxuXFx0XFx0XFx0XFx0bGV0IHAyOiB2ZWMzPGYzMj4gPSBub2RlUG9zICsgdmVjMzxmMzI+KGYzMihDSElMRF9NSU5fT0ZGU0VUU1tjMl0ueCAqIG5vZGVTaXplKSwgZjMyKENISUxEX01JTl9PRkZTRVRTW2MyXS55ICogbm9kZVNpemUpLCBmMzIoQ0hJTERfTUlOX09GRlNFVFNbYzJdLnogKiBub2RlU2l6ZSkpO1xcblxcdFxcdFxcdFxcdGxldCBwOiB2ZWMzPGYzMj4gPSBBcHByb3hpbWF0ZVplcm9Dcm9zc2luZ1Bvc2l0aW9uKHAxLCBwMik7XFxuXFx0XFx0XFx0XFx0bGV0IG46IHZlYzM8ZjMyPiA9IENhbGN1bGF0ZVN1cmZhY2VOb3JtYWwocCk7XFxuXFxuXFx0XFx0XFx0XFx0cWVmX2FkZCh2ZWM0PGYzMj4obi54LCBuLnksIG4ueiwgMC4wKSwgdmVjNDxmMzI+KHAueCwgcC55LCBwLnosIDAuMCkpO1xcblxcblxcdFxcdFxcdFxcdGF2ZXJhZ2VOb3JtYWwgPSBhdmVyYWdlTm9ybWFsICsgbjtcXG5cXG5cXHRcXHRcXHRcXHRlZGdlQ291bnQgPSBlZGdlQ291bnQgKyAxO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRjb250aW51aW5nIHtcXG5cXHRcXHRcXHRcXHRqID0gaiArIDE7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXG5cXHRcXHRhdmVyYWdlTm9ybWFsID0gbm9ybWFsaXplKGF2ZXJhZ2VOb3JtYWwgLyB2ZWMzPGYzMj4oZjMyKGVkZ2VDb3VudCksIGYzMihlZGdlQ291bnQpLCBmMzIoZWRnZUNvdW50KSkpO1xcblxcblxcdFxcdGxldCBjb206IHZlYzM8ZjMyPiA9IHZlYzM8ZjMyPihwb2ludGFjY3VtLnggLyBwb2ludGFjY3VtLncsIHBvaW50YWNjdW0ueSAvIHBvaW50YWNjdW0udywgcG9pbnRhY2N1bS56IC8gcG9pbnRhY2N1bS53KTtcXG5cXG5cXHRcXHRsZXQgcmVzdWx0OiB2ZWM0PGYzMj4gPSBxZWZfc29sdmUoKTtcXG5cXHRcXHR2YXIgc29sdmVkX3Bvc2l0aW9uOiB2ZWMzPGYzMj4gPSByZXN1bHQueHl6O1xcblxcdFxcdGxldCBlcnJvcjogZjMyID0gcmVzdWx0Lnc7XFxuXFxuXFxuXFx0XFx0bGV0IE1pbjogdmVjMzxmMzI+ID0gbm9kZVBvcztcXG5cXHRcXHRsZXQgTWF4OiB2ZWMzPGYzMj4gPSBub2RlUG9zICsgdmVjMzxmMzI+KDEuMCwgMS4wLCAxLjApO1xcblxcdFxcdGlmIChzb2x2ZWRfcG9zaXRpb24ueCA8IE1pbi54IHx8IHNvbHZlZF9wb3NpdGlvbi54ID4gTWF4LnggfHxcXG5cXHRcXHRcXHRcXHRzb2x2ZWRfcG9zaXRpb24ueSA8IE1pbi55IHx8IHNvbHZlZF9wb3NpdGlvbi55ID4gTWF4LnkgfHxcXG5cXHRcXHRcXHRcXHRzb2x2ZWRfcG9zaXRpb24ueiA8IE1pbi56IHx8IHNvbHZlZF9wb3NpdGlvbi56ID4gTWF4LnopXFxuXFx0XFx0e1xcblxcdFxcdFxcdHNvbHZlZF9wb3NpdGlvbiA9IGNvbTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dm94ZWxzLnZveGVsc1t0cnVlSW5kZXhdLnZlcnRQb2ludCA9IHNvbHZlZF9wb3NpdGlvbjtcXG5cXHRcXHR2b3hlbHMudm94ZWxzW3RydWVJbmRleF0uYXZnTm9ybWFsID0gYXZlcmFnZU5vcm1hbDtcXG5cXHRcXHR2b3hlbHMudm94ZWxzW3RydWVJbmRleF0ubnVtUG9pbnRzID0gZjMyKGVkZ2VDb3VudCk7XFxuXFx0XFx0dm94ZWxzLnZveGVsc1t0cnVlSW5kZXhdLmNvcm5lcnMgPSBmMzIodm94ZWxNYXRlcmlhbHMudm94ZWxNYXRlcmlhbHNbdm94ZWxJbmRleF0pO1xcblxcdH1cXG59XFxuXFxuQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKDEpXFxuZm4gY29tcHV0ZU1hdGVyaWFscyhAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgR2xvYmFsSW52b2NhdGlvbklEIDogdmVjMzx1MzI+KSB7XFxuXFx0XFx0bGV0IHdpZHRoID0gdW5pZm9ybXMud2lkdGg7XFxuICAgIGxldCBpbmRleDogdTMyID0gR2xvYmFsSW52b2NhdGlvbklELnogKiB3aWR0aCAqIHdpZHRoICsgR2xvYmFsSW52b2NhdGlvbklELnkgKiB3aWR0aCArIEdsb2JhbEludm9jYXRpb25JRC54O1xcbiAgICBsZXQgY29ybmVyUG9zOiB2ZWMzPGYzMj4gPSB2ZWMzPGYzMj4oZjMyKEdsb2JhbEludm9jYXRpb25JRC54KSAqIHVuaWZvcm1zLnN0cmlkZSwgZjMyKEdsb2JhbEludm9jYXRpb25JRC55KSAqIHVuaWZvcm1zLnN0cmlkZSwgZjMyKEdsb2JhbEludm9jYXRpb25JRC56KSAqIHVuaWZvcm1zLnN0cmlkZSk7XFxuXFxuICAgIGxldCBkZW5zaXR5OiBmMzIgPSBnZXREZW5zaXR5KGNvcm5lclBvcyArIHVuaWZvcm1zLmNodW5rUG9zaXRpb24pO1xcblxcblxcdFxcdGlmIChkZW5zaXR5IDwgMC4wKSB7XFxuXFx0XFx0XFx0aWYgKGxlbmd0aChjb3JuZXJQb3MgKyB1bmlmb3Jtcy5jaHVua1Bvc2l0aW9uKSA8IDIwMDAuMCkge1xcbiAgICAgICAgLy9jb3JuZXJNYXRlcmlhbHMuY29ybmVyTWF0ZXJpYWxzW2luZGV4XSA9IHUzMihyYW5kb20odmVjMihmMzIoaW5kZXgpKSkgKiAyNTUuMCkgKyAxO1xcblxcdFxcdFxcdCAgY29ybmVyTWF0ZXJpYWxzLmNvcm5lck1hdGVyaWFsc1tpbmRleF0gPSAyNTZ1O1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuICAgICAgICBjb3JuZXJNYXRlcmlhbHMuY29ybmVyTWF0ZXJpYWxzW2luZGV4XSA9IHUzMihsZW5ndGgoY29ybmVyUG9zKSAvIHVuaWZvcm1zLnN0cmlkZSAqIDI1Ni4wKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRjb3JuZXJNYXRlcmlhbHMuY29ybmVyTWF0ZXJpYWxzW2luZGV4XSA9IDB1O1xcblxcdFxcdH1cXG59XCI7IiwiLy8gQSBsaWJyYXJ5IG9mIHNlZWRhYmxlIFJOR3MgaW1wbGVtZW50ZWQgaW4gSmF2YXNjcmlwdC5cbi8vXG4vLyBVc2FnZTpcbi8vXG4vLyB2YXIgc2VlZHJhbmRvbSA9IHJlcXVpcmUoJ3NlZWRyYW5kb20nKTtcbi8vIHZhciByYW5kb20gPSBzZWVkcmFuZG9tKDEpOyAvLyBvciBhbnkgc2VlZC5cbi8vIHZhciB4ID0gcmFuZG9tKCk7ICAgICAgIC8vIDAgPD0geCA8IDEuICBFdmVyeSBiaXQgaXMgcmFuZG9tLlxuLy8gdmFyIHggPSByYW5kb20ucXVpY2soKTsgLy8gMCA8PSB4IDwgMS4gIDMyIGJpdHMgb2YgcmFuZG9tbmVzcy5cblxuLy8gYWxlYSwgYSA1My1iaXQgbXVsdGlwbHktd2l0aC1jYXJyeSBnZW5lcmF0b3IgYnkgSm9oYW5uZXMgQmFhZ8O4ZS5cbi8vIFBlcmlvZDogfjJeMTE2XG4vLyBSZXBvcnRlZCB0byBwYXNzIGFsbCBCaWdDcnVzaCB0ZXN0cy5cbnZhciBhbGVhID0gcmVxdWlyZSgnLi9saWIvYWxlYScpO1xuXG4vLyB4b3IxMjgsIGEgcHVyZSB4b3Itc2hpZnQgZ2VuZXJhdG9yIGJ5IEdlb3JnZSBNYXJzYWdsaWEuXG4vLyBQZXJpb2Q6IDJeMTI4LTEuXG4vLyBSZXBvcnRlZCB0byBmYWlsOiBNYXRyaXhSYW5rIGFuZCBMaW5lYXJDb21wLlxudmFyIHhvcjEyOCA9IHJlcXVpcmUoJy4vbGliL3hvcjEyOCcpO1xuXG4vLyB4b3J3b3csIEdlb3JnZSBNYXJzYWdsaWEncyAxNjAtYml0IHhvci1zaGlmdCBjb21iaW5lZCBwbHVzIHdleWwuXG4vLyBQZXJpb2Q6IDJeMTkyLTJeMzJcbi8vIFJlcG9ydGVkIHRvIGZhaWw6IENvbGxpc2lvbk92ZXIsIFNpbXBQb2tlciwgYW5kIExpbmVhckNvbXAuXG52YXIgeG9yd293ID0gcmVxdWlyZSgnLi9saWIveG9yd293Jyk7XG5cbi8vIHhvcnNoaWZ0NywgYnkgRnJhbsOnb2lzIFBhbm5ldG9uIGFuZCBQaWVycmUgTCdlY3V5ZXIsIHRha2VzXG4vLyBhIGRpZmZlcmVudCBhcHByb2FjaDogaXQgYWRkcyByb2J1c3RuZXNzIGJ5IGFsbG93aW5nIG1vcmUgc2hpZnRzXG4vLyB0aGFuIE1hcnNhZ2xpYSdzIG9yaWdpbmFsIHRocmVlLiAgSXQgaXMgYSA3LXNoaWZ0IGdlbmVyYXRvclxuLy8gd2l0aCAyNTYgYml0cywgdGhhdCBwYXNzZXMgQmlnQ3J1c2ggd2l0aCBubyBzeXN0bWF0aWMgZmFpbHVyZXMuXG4vLyBQZXJpb2QgMl4yNTYtMS5cbi8vIE5vIHN5c3RlbWF0aWMgQmlnQ3J1c2ggZmFpbHVyZXMgcmVwb3J0ZWQuXG52YXIgeG9yc2hpZnQ3ID0gcmVxdWlyZSgnLi9saWIveG9yc2hpZnQ3Jyk7XG5cbi8vIHhvcjQwOTYsIGJ5IFJpY2hhcmQgQnJlbnQsIGlzIGEgNDA5Ni1iaXQgeG9yLXNoaWZ0IHdpdGggYVxuLy8gdmVyeSBsb25nIHBlcmlvZCB0aGF0IGFsc28gYWRkcyBhIFdleWwgZ2VuZXJhdG9yLiBJdCBhbHNvIHBhc3Nlc1xuLy8gQmlnQ3J1c2ggd2l0aCBubyBzeXN0ZW1hdGljIGZhaWx1cmVzLiAgSXRzIGxvbmcgcGVyaW9kIG1heVxuLy8gYmUgdXNlZnVsIGlmIHlvdSBoYXZlIG1hbnkgZ2VuZXJhdG9ycyBhbmQgbmVlZCB0byBhdm9pZFxuLy8gY29sbGlzaW9ucy5cbi8vIFBlcmlvZDogMl40MTI4LTJeMzIuXG4vLyBObyBzeXN0ZW1hdGljIEJpZ0NydXNoIGZhaWx1cmVzIHJlcG9ydGVkLlxudmFyIHhvcjQwOTYgPSByZXF1aXJlKCcuL2xpYi94b3I0MDk2Jyk7XG5cbi8vIFR5Y2hlLWksIGJ5IFNhbXVlbCBOZXZlcyBhbmQgRmlsaXBlIEFyYXVqbywgaXMgYSBiaXQtc2hpZnRpbmcgcmFuZG9tXG4vLyBudW1iZXIgZ2VuZXJhdG9yIGRlcml2ZWQgZnJvbSBDaGFDaGEsIGEgbW9kZXJuIHN0cmVhbSBjaXBoZXIuXG4vLyBodHRwczovL2VkZW4uZGVpLnVjLnB0L35zbmV2ZXMvcHVicy8yMDExLXNuZmEyLnBkZlxuLy8gUGVyaW9kOiB+Ml4xMjdcbi8vIE5vIHN5c3RlbWF0aWMgQmlnQ3J1c2ggZmFpbHVyZXMgcmVwb3J0ZWQuXG52YXIgdHljaGVpID0gcmVxdWlyZSgnLi9saWIvdHljaGVpJyk7XG5cbi8vIFRoZSBvcmlnaW5hbCBBUkM0LWJhc2VkIHBybmcgaW5jbHVkZWQgaW4gdGhpcyBsaWJyYXJ5LlxuLy8gUGVyaW9kOiB+Ml4xNjAwXG52YXIgc3IgPSByZXF1aXJlKCcuL3NlZWRyYW5kb20nKTtcblxuc3IuYWxlYSA9IGFsZWE7XG5zci54b3IxMjggPSB4b3IxMjg7XG5zci54b3J3b3cgPSB4b3J3b3c7XG5zci54b3JzaGlmdDcgPSB4b3JzaGlmdDc7XG5zci54b3I0MDk2ID0geG9yNDA5NjtcbnNyLnR5Y2hlaSA9IHR5Y2hlaTtcblxubW9kdWxlLmV4cG9ydHMgPSBzcjtcbiIsIi8vIEEgcG9ydCBvZiBhbiBhbGdvcml0aG0gYnkgSm9oYW5uZXMgQmFhZ8O4ZSA8YmFhZ29lQGJhYWdvZS5jb20+LCAyMDEwXG4vLyBodHRwOi8vYmFhZ29lLmNvbS9lbi9SYW5kb21NdXNpbmdzL2phdmFzY3JpcHQvXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbnF1aW5sYW4vYmV0dGVyLXJhbmRvbS1udW1iZXJzLWZvci1qYXZhc2NyaXB0LW1pcnJvclxuLy8gT3JpZ2luYWwgd29yayBpcyB1bmRlciBNSVQgbGljZW5zZSAtXG5cbi8vIENvcHlyaWdodCAoQykgMjAxMCBieSBKb2hhbm5lcyBCYWFnw7hlIDxiYWFnb2VAYmFhZ29lLm9yZz5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5cblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gQWxlYShzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXMsIG1hc2ggPSBNYXNoKCk7XG5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gMjA5MTYzOSAqIG1lLnMwICsgbWUuYyAqIDIuMzI4MzA2NDM2NTM4Njk2M2UtMTA7IC8vIDJeLTMyXG4gICAgbWUuczAgPSBtZS5zMTtcbiAgICBtZS5zMSA9IG1lLnMyO1xuICAgIHJldHVybiBtZS5zMiA9IHQgLSAobWUuYyA9IHQgfCAwKTtcbiAgfTtcblxuICAvLyBBcHBseSB0aGUgc2VlZGluZyBhbGdvcml0aG0gZnJvbSBCYWFnb2UuXG4gIG1lLmMgPSAxO1xuICBtZS5zMCA9IG1hc2goJyAnKTtcbiAgbWUuczEgPSBtYXNoKCcgJyk7XG4gIG1lLnMyID0gbWFzaCgnICcpO1xuICBtZS5zMCAtPSBtYXNoKHNlZWQpO1xuICBpZiAobWUuczAgPCAwKSB7IG1lLnMwICs9IDE7IH1cbiAgbWUuczEgLT0gbWFzaChzZWVkKTtcbiAgaWYgKG1lLnMxIDwgMCkgeyBtZS5zMSArPSAxOyB9XG4gIG1lLnMyIC09IG1hc2goc2VlZCk7XG4gIGlmIChtZS5zMiA8IDApIHsgbWUuczIgKz0gMTsgfVxuICBtYXNoID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuYyA9IGYuYztcbiAgdC5zMCA9IGYuczA7XG4gIHQuczEgPSBmLnMxO1xuICB0LnMyID0gZi5zMjtcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICB2YXIgeGcgPSBuZXcgQWxlYShzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IHhnLm5leHQ7XG4gIHBybmcuaW50MzIgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgKiAweDEwMDAwMDAwMCkgfCAwOyB9XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHBybmcoKSArIChwcm5nKCkgKiAweDIwMDAwMCB8IDApICogMS4xMTAyMjMwMjQ2MjUxNTY1ZS0xNjsgLy8gMl4tNTNcbiAgfTtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmICh0eXBlb2Yoc3RhdGUpID09ICdvYmplY3QnKSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmZ1bmN0aW9uIE1hc2goKSB7XG4gIHZhciBuID0gMHhlZmM4MjQ5ZDtcblxuICB2YXIgbWFzaCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBkYXRhID0gU3RyaW5nKGRhdGEpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgbiArPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgICB2YXIgaCA9IDAuMDI1MTk2MDMyODI0MTY5MzggKiBuO1xuICAgICAgbiA9IGggPj4+IDA7XG4gICAgICBoIC09IG47XG4gICAgICBoICo9IG47XG4gICAgICBuID0gaCA+Pj4gMDtcbiAgICAgIGggLT0gbjtcbiAgICAgIG4gKz0gaCAqIDB4MTAwMDAwMDAwOyAvLyAyXjMyXG4gICAgfVxuICAgIHJldHVybiAobiA+Pj4gMCkgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxuICB9O1xuXG4gIHJldHVybiBtYXNoO1xufVxuXG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMuYWxlYSA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cblxuIiwiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgdGhlIFwiVHljaGUtaVwiIHBybmcgYWxnb3JpdGhtIGJ5XG4vLyBTYW11ZWwgTmV2ZXMgYW5kIEZpbGlwZSBBcmF1am8uXG4vLyBTZWUgaHR0cHM6Ly9lZGVuLmRlaS51Yy5wdC9+c25ldmVzL3B1YnMvMjAxMS1zbmZhMi5wZGZcblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gWG9yR2VuKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcywgc3Ryc2VlZCA9ICcnO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYiA9IG1lLmIsIGMgPSBtZS5jLCBkID0gbWUuZCwgYSA9IG1lLmE7XG4gICAgYiA9IChiIDw8IDI1KSBeIChiID4+PiA3KSBeIGM7XG4gICAgYyA9IChjIC0gZCkgfCAwO1xuICAgIGQgPSAoZCA8PCAyNCkgXiAoZCA+Pj4gOCkgXiBhO1xuICAgIGEgPSAoYSAtIGIpIHwgMDtcbiAgICBtZS5iID0gYiA9IChiIDw8IDIwKSBeIChiID4+PiAxMikgXiBjO1xuICAgIG1lLmMgPSBjID0gKGMgLSBkKSB8IDA7XG4gICAgbWUuZCA9IChkIDw8IDE2KSBeIChjID4+PiAxNikgXiBhO1xuICAgIHJldHVybiBtZS5hID0gKGEgLSBiKSB8IDA7XG4gIH07XG5cbiAgLyogVGhlIGZvbGxvd2luZyBpcyBub24taW52ZXJ0ZWQgdHljaGUsIHdoaWNoIGhhcyBiZXR0ZXIgaW50ZXJuYWxcbiAgICogYml0IGRpZmZ1c2lvbiwgYnV0IHdoaWNoIGlzIGFib3V0IDI1JSBzbG93ZXIgdGhhbiB0eWNoZS1pIGluIEpTLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGEgPSBtZS5hLCBiID0gbWUuYiwgYyA9IG1lLmMsIGQgPSBtZS5kO1xuICAgIGEgPSAobWUuYSArIG1lLmIgfCAwKSA+Pj4gMDtcbiAgICBkID0gbWUuZCBeIGE7IGQgPSBkIDw8IDE2IF4gZCA+Pj4gMTY7XG4gICAgYyA9IG1lLmMgKyBkIHwgMDtcbiAgICBiID0gbWUuYiBeIGM7IGIgPSBiIDw8IDEyIF4gZCA+Pj4gMjA7XG4gICAgbWUuYSA9IGEgPSBhICsgYiB8IDA7XG4gICAgZCA9IGQgXiBhOyBtZS5kID0gZCA9IGQgPDwgOCBeIGQgPj4+IDI0O1xuICAgIG1lLmMgPSBjID0gYyArIGQgfCAwO1xuICAgIGIgPSBiIF4gYztcbiAgICByZXR1cm4gbWUuYiA9IChiIDw8IDcgXiBiID4+PiAyNSk7XG4gIH1cbiAgKi9cblxuICBtZS5hID0gMDtcbiAgbWUuYiA9IDA7XG4gIG1lLmMgPSAyNjU0NDM1NzY5IHwgMDtcbiAgbWUuZCA9IDEzNjcxMzA1NTE7XG5cbiAgaWYgKHNlZWQgPT09IE1hdGguZmxvb3Ioc2VlZCkpIHtcbiAgICAvLyBJbnRlZ2VyIHNlZWQuXG4gICAgbWUuYSA9IChzZWVkIC8gMHgxMDAwMDAwMDApIHwgMDtcbiAgICBtZS5iID0gc2VlZCB8IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RyaW5nIHNlZWQuXG4gICAgc3Ryc2VlZCArPSBzZWVkO1xuICB9XG5cbiAgLy8gTWl4IGluIHN0cmluZyBzZWVkLCB0aGVuIGRpc2NhcmQgYW4gaW5pdGlhbCBiYXRjaCBvZiA2NCB2YWx1ZXMuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgc3Ryc2VlZC5sZW5ndGggKyAyMDsgaysrKSB7XG4gICAgbWUuYiBePSBzdHJzZWVkLmNoYXJDb2RlQXQoaykgfCAwO1xuICAgIG1lLm5leHQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC5hID0gZi5hO1xuICB0LmIgPSBmLmI7XG4gIHQuYyA9IGYuYztcbiAgdC5kID0gZi5kO1xuICByZXR1cm4gdDtcbn07XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICB2YXIgeGcgPSBuZXcgWG9yR2VuKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwOyB9O1xuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvIHtcbiAgICAgIHZhciB0b3AgPSB4Zy5uZXh0KCkgPj4+IDExLFxuICAgICAgICAgIGJvdCA9ICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDAsXG4gICAgICAgICAgcmVzdWx0ID0gKHRvcCArIGJvdCkgLyAoMSA8PCAyMSk7XG4gICAgfSB3aGlsZSAocmVzdWx0ID09PSAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm5nLmludDMyID0geGcubmV4dDtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmICh0eXBlb2Yoc3RhdGUpID09ICdvYmplY3QnKSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMudHljaGVpID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcblxuXG4iLCIvLyBBIEphdmFzY3JpcHQgaW1wbGVtZW50YWlvbiBvZiB0aGUgXCJ4b3IxMjhcIiBwcm5nIGFsZ29yaXRobSBieVxuLy8gR2VvcmdlIE1hcnNhZ2xpYS4gIFNlZSBodHRwOi8vd3d3LmpzdGF0c29mdC5vcmcvdjA4L2kxNC9wYXBlclxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBYb3JHZW4oc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzLCBzdHJzZWVkID0gJyc7XG5cbiAgbWUueCA9IDA7XG4gIG1lLnkgPSAwO1xuICBtZS56ID0gMDtcbiAgbWUudyA9IDA7XG5cbiAgLy8gU2V0IHVwIGdlbmVyYXRvciBmdW5jdGlvbi5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gbWUueCBeIChtZS54IDw8IDExKTtcbiAgICBtZS54ID0gbWUueTtcbiAgICBtZS55ID0gbWUuejtcbiAgICBtZS56ID0gbWUudztcbiAgICByZXR1cm4gbWUudyBePSAobWUudyA+Pj4gMTkpIF4gdCBeICh0ID4+PiA4KTtcbiAgfTtcblxuICBpZiAoc2VlZCA9PT0gKHNlZWQgfCAwKSkge1xuICAgIC8vIEludGVnZXIgc2VlZC5cbiAgICBtZS54ID0gc2VlZDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdHJpbmcgc2VlZC5cbiAgICBzdHJzZWVkICs9IHNlZWQ7XG4gIH1cblxuICAvLyBNaXggaW4gc3RyaW5nIHNlZWQsIHRoZW4gZGlzY2FyZCBhbiBpbml0aWFsIGJhdGNoIG9mIDY0IHZhbHVlcy5cbiAgZm9yICh2YXIgayA9IDA7IGsgPCBzdHJzZWVkLmxlbmd0aCArIDY0OyBrKyspIHtcbiAgICBtZS54IF49IHN0cnNlZWQuY2hhckNvZGVBdChrKSB8IDA7XG4gICAgbWUubmV4dCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LnggPSBmLng7XG4gIHQueSA9IGYueTtcbiAgdC56ID0gZi56O1xuICB0LncgPSBmLnc7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnhvcjEyOCA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cblxuIiwiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgUmljaGFyZCBCcmVudCdzIFhvcmdlbnMgeG9yNDA5NiBhbGdvcml0aG0uXG4vL1xuLy8gVGhpcyBmYXN0IG5vbi1jcnlwdG9ncmFwaGljIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIGlzIGRlc2lnbmVkIGZvclxuLy8gdXNlIGluIE1vbnRlLUNhcmxvIGFsZ29yaXRobXMuIEl0IGNvbWJpbmVzIGEgbG9uZy1wZXJpb2QgeG9yc2hpZnRcbi8vIGdlbmVyYXRvciB3aXRoIGEgV2V5bCBnZW5lcmF0b3IsIGFuZCBpdCBwYXNzZXMgYWxsIGNvbW1vbiBiYXR0ZXJpZXNcbi8vIG9mIHN0YXN0aWNpYWwgdGVzdHMgZm9yIHJhbmRvbW5lc3Mgd2hpbGUgY29uc3VtaW5nIG9ubHkgYSBmZXcgbmFub3NlY29uZHNcbi8vIGZvciBlYWNoIHBybmcgZ2VuZXJhdGVkLiAgRm9yIGJhY2tncm91bmQgb24gdGhlIGdlbmVyYXRvciwgc2VlIEJyZW50J3Ncbi8vIHBhcGVyOiBcIlNvbWUgbG9uZy1wZXJpb2QgcmFuZG9tIG51bWJlciBnZW5lcmF0b3JzIHVzaW5nIHNoaWZ0cyBhbmQgeG9ycy5cIlxuLy8gaHR0cDovL2FyeGl2Lm9yZy9wZGYvMTAwNC4zMTE1djEucGRmXG4vL1xuLy8gVXNhZ2U6XG4vL1xuLy8gdmFyIHhvcjQwOTYgPSByZXF1aXJlKCd4b3I0MDk2Jyk7XG4vLyByYW5kb20gPSB4b3I0MDk2KDEpOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZWQgd2l0aCBpbnQzMiBvciBzdHJpbmcuXG4vLyBhc3NlcnQuZXF1YWwocmFuZG9tKCksIDAuMTUyMDQzNjQ1MDUzODU0Nyk7IC8vICgwLCAxKSByYW5nZSwgNTMgYml0cy5cbi8vIGFzc2VydC5lcXVhbChyYW5kb20uaW50MzIoKSwgMTgwNjUzNDg5Nyk7ICAgLy8gc2lnbmVkIGludDMyLCAzMiBiaXRzLlxuLy9cbi8vIEZvciBub256ZXJvIG51bWVyaWMga2V5cywgdGhpcyBpbXBlbGVtZW50YXRpb24gcHJvdmlkZXMgYSBzZXF1ZW5jZVxuLy8gaWRlbnRpY2FsIHRvIHRoYXQgYnkgQnJlbnQncyB4b3JnZW5zIDMgaW1wbGVtZW50YWlvbiBpbiBDLiAgVGhpc1xuLy8gaW1wbGVtZW50YXRpb24gYWxzbyBwcm92aWRlcyBmb3IgaW5pdGFsaXppbmcgdGhlIGdlbmVyYXRvciB3aXRoXG4vLyBzdHJpbmcgc2VlZHMsIG9yIGZvciBzYXZpbmcgYW5kIHJlc3RvcmluZyB0aGUgc3RhdGUgb2YgdGhlIGdlbmVyYXRvci5cbi8vXG4vLyBPbiBDaHJvbWUsIHRoaXMgcHJuZyBiZW5jaG1hcmtzIGFib3V0IDIuMSB0aW1lcyBzbG93ZXIgdGhhblxuLy8gSmF2YXNjcmlwdCdzIGJ1aWx0LWluIE1hdGgucmFuZG9tKCkuXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXM7XG5cbiAgLy8gU2V0IHVwIGdlbmVyYXRvciBmdW5jdGlvbi5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB3ID0gbWUudyxcbiAgICAgICAgWCA9IG1lLlgsIGkgPSBtZS5pLCB0LCB2O1xuICAgIC8vIFVwZGF0ZSBXZXlsIGdlbmVyYXRvci5cbiAgICBtZS53ID0gdyA9ICh3ICsgMHg2MWM4ODY0NykgfCAwO1xuICAgIC8vIFVwZGF0ZSB4b3IgZ2VuZXJhdG9yLlxuICAgIHYgPSBYWyhpICsgMzQpICYgMTI3XTtcbiAgICB0ID0gWFtpID0gKChpICsgMSkgJiAxMjcpXTtcbiAgICB2IF49IHYgPDwgMTM7XG4gICAgdCBePSB0IDw8IDE3O1xuICAgIHYgXj0gdiA+Pj4gMTU7XG4gICAgdCBePSB0ID4+PiAxMjtcbiAgICAvLyBVcGRhdGUgWG9yIGdlbmVyYXRvciBhcnJheSBzdGF0ZS5cbiAgICB2ID0gWFtpXSA9IHYgXiB0O1xuICAgIG1lLmkgPSBpO1xuICAgIC8vIFJlc3VsdCBpcyB0aGUgY29tYmluYXRpb24uXG4gICAgcmV0dXJuICh2ICsgKHcgXiAodyA+Pj4gMTYpKSkgfCAwO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGluaXQobWUsIHNlZWQpIHtcbiAgICB2YXIgdCwgdiwgaSwgaiwgdywgWCA9IFtdLCBsaW1pdCA9IDEyODtcbiAgICBpZiAoc2VlZCA9PT0gKHNlZWQgfCAwKSkge1xuICAgICAgLy8gTnVtZXJpYyBzZWVkcyBpbml0aWFsaXplIHYsIHdoaWNoIGlzIHVzZWQgdG8gZ2VuZXJhdGVzIFguXG4gICAgICB2ID0gc2VlZDtcbiAgICAgIHNlZWQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdHJpbmcgc2VlZHMgYXJlIG1peGVkIGludG8gdiBhbmQgWCBvbmUgY2hhcmFjdGVyIGF0IGEgdGltZS5cbiAgICAgIHNlZWQgPSBzZWVkICsgJ1xcMCc7XG4gICAgICB2ID0gMDtcbiAgICAgIGxpbWl0ID0gTWF0aC5tYXgobGltaXQsIHNlZWQubGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gSW5pdGlhbGl6ZSBjaXJjdWxhciBhcnJheSBhbmQgd2V5bCB2YWx1ZS5cbiAgICBmb3IgKGkgPSAwLCBqID0gLTMyOyBqIDwgbGltaXQ7ICsraikge1xuICAgICAgLy8gUHV0IHRoZSB1bmljb2RlIGNoYXJhY3RlcnMgaW50byB0aGUgYXJyYXksIGFuZCBzaHVmZmxlIHRoZW0uXG4gICAgICBpZiAoc2VlZCkgdiBePSBzZWVkLmNoYXJDb2RlQXQoKGogKyAzMikgJSBzZWVkLmxlbmd0aCk7XG4gICAgICAvLyBBZnRlciAzMiBzaHVmZmxlcywgdGFrZSB2IGFzIHRoZSBzdGFydGluZyB3IHZhbHVlLlxuICAgICAgaWYgKGogPT09IDApIHcgPSB2O1xuICAgICAgdiBePSB2IDw8IDEwO1xuICAgICAgdiBePSB2ID4+PiAxNTtcbiAgICAgIHYgXj0gdiA8PCA0O1xuICAgICAgdiBePSB2ID4+PiAxMztcbiAgICAgIGlmIChqID49IDApIHtcbiAgICAgICAgdyA9ICh3ICsgMHg2MWM4ODY0NykgfCAwOyAgICAgLy8gV2V5bC5cbiAgICAgICAgdCA9IChYW2ogJiAxMjddIF49ICh2ICsgdykpOyAgLy8gQ29tYmluZSB4b3IgYW5kIHdleWwgdG8gaW5pdCBhcnJheS5cbiAgICAgICAgaSA9ICgwID09IHQpID8gaSArIDEgOiAwOyAgICAgLy8gQ291bnQgemVyb2VzLlxuICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSBoYXZlIGRldGVjdGVkIGFsbCB6ZXJvZXM7IG1ha2UgdGhlIGtleSBub256ZXJvLlxuICAgIGlmIChpID49IDEyOCkge1xuICAgICAgWFsoc2VlZCAmJiBzZWVkLmxlbmd0aCB8fCAwKSAmIDEyN10gPSAtMTtcbiAgICB9XG4gICAgLy8gUnVuIHRoZSBnZW5lcmF0b3IgNTEyIHRpbWVzIHRvIGZ1cnRoZXIgbWl4IHRoZSBzdGF0ZSBiZWZvcmUgdXNpbmcgaXQuXG4gICAgLy8gRmFjdG9yaW5nIHRoaXMgYXMgYSBmdW5jdGlvbiBzbG93cyB0aGUgbWFpbiBnZW5lcmF0b3IsIHNvIGl0IGlzIGp1c3RcbiAgICAvLyB1bnJvbGxlZCBoZXJlLiAgVGhlIHdleWwgZ2VuZXJhdG9yIGlzIG5vdCBhZHZhbmNlZCB3aGlsZSB3YXJtaW5nIHVwLlxuICAgIGkgPSAxMjc7XG4gICAgZm9yIChqID0gNCAqIDEyODsgaiA+IDA7IC0taikge1xuICAgICAgdiA9IFhbKGkgKyAzNCkgJiAxMjddO1xuICAgICAgdCA9IFhbaSA9ICgoaSArIDEpICYgMTI3KV07XG4gICAgICB2IF49IHYgPDwgMTM7XG4gICAgICB0IF49IHQgPDwgMTc7XG4gICAgICB2IF49IHYgPj4+IDE1O1xuICAgICAgdCBePSB0ID4+PiAxMjtcbiAgICAgIFhbaV0gPSB2IF4gdDtcbiAgICB9XG4gICAgLy8gU3RvcmluZyBzdGF0ZSBhcyBvYmplY3QgbWVtYmVycyBpcyBmYXN0ZXIgdGhhbiB1c2luZyBjbG9zdXJlIHZhcmlhYmxlcy5cbiAgICBtZS53ID0gdztcbiAgICBtZS5YID0gWDtcbiAgICBtZS5pID0gaTtcbiAgfVxuXG4gIGluaXQobWUsIHNlZWQpO1xufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC5pID0gZi5pO1xuICB0LncgPSBmLnc7XG4gIHQuWCA9IGYuWC5zbGljZSgpO1xuICByZXR1cm4gdDtcbn07XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICBpZiAoc2VlZCA9PSBudWxsKSBzZWVkID0gKyhuZXcgRGF0ZSk7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLlgpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy54b3I0MDk2ID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbmRvdyBvYmplY3Qgb3IgZ2xvYmFsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcbiIsIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIHRoZSBcInhvcnNoaWZ0N1wiIGFsZ29yaXRobSBieVxuLy8gRnJhbsOnb2lzIFBhbm5ldG9uIGFuZCBQaWVycmUgTCdlY3V5ZXI6XG4vLyBcIk9uIHRoZSBYb3Jnc2hpZnQgUmFuZG9tIE51bWJlciBHZW5lcmF0b3JzXCJcbi8vIGh0dHA6Ly9zYWx1Yy5lbmdyLnVjb25uLmVkdS9yZWZzL2NyeXB0by9ybmcvcGFubmV0b24wNW9udGhleG9yc2hpZnQucGRmXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXM7XG5cbiAgLy8gU2V0IHVwIGdlbmVyYXRvciBmdW5jdGlvbi5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFVwZGF0ZSB4b3IgZ2VuZXJhdG9yLlxuICAgIHZhciBYID0gbWUueCwgaSA9IG1lLmksIHQsIHYsIHc7XG4gICAgdCA9IFhbaV07IHQgXj0gKHQgPj4+IDcpOyB2ID0gdCBeICh0IDw8IDI0KTtcbiAgICB0ID0gWFsoaSArIDEpICYgN107IHYgXj0gdCBeICh0ID4+PiAxMCk7XG4gICAgdCA9IFhbKGkgKyAzKSAmIDddOyB2IF49IHQgXiAodCA+Pj4gMyk7XG4gICAgdCA9IFhbKGkgKyA0KSAmIDddOyB2IF49IHQgXiAodCA8PCA3KTtcbiAgICB0ID0gWFsoaSArIDcpICYgN107IHQgPSB0IF4gKHQgPDwgMTMpOyB2IF49IHQgXiAodCA8PCA5KTtcbiAgICBYW2ldID0gdjtcbiAgICBtZS5pID0gKGkgKyAxKSAmIDc7XG4gICAgcmV0dXJuIHY7XG4gIH07XG5cbiAgZnVuY3Rpb24gaW5pdChtZSwgc2VlZCkge1xuICAgIHZhciBqLCB3LCBYID0gW107XG5cbiAgICBpZiAoc2VlZCA9PT0gKHNlZWQgfCAwKSkge1xuICAgICAgLy8gU2VlZCBzdGF0ZSBhcnJheSB1c2luZyBhIDMyLWJpdCBpbnRlZ2VyLlxuICAgICAgdyA9IFhbMF0gPSBzZWVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZWVkIHN0YXRlIHVzaW5nIGEgc3RyaW5nLlxuICAgICAgc2VlZCA9ICcnICsgc2VlZDtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBzZWVkLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIFhbaiAmIDddID0gKFhbaiAmIDddIDw8IDE1KSBeXG4gICAgICAgICAgICAoc2VlZC5jaGFyQ29kZUF0KGopICsgWFsoaiArIDEpICYgN10gPDwgMTMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBFbmZvcmNlIGFuIGFycmF5IGxlbmd0aCBvZiA4LCBub3QgYWxsIHplcm9lcy5cbiAgICB3aGlsZSAoWC5sZW5ndGggPCA4KSBYLnB1c2goMCk7XG4gICAgZm9yIChqID0gMDsgaiA8IDggJiYgWFtqXSA9PT0gMDsgKytqKTtcbiAgICBpZiAoaiA9PSA4KSB3ID0gWFs3XSA9IC0xOyBlbHNlIHcgPSBYW2pdO1xuXG4gICAgbWUueCA9IFg7XG4gICAgbWUuaSA9IDA7XG5cbiAgICAvLyBEaXNjYXJkIGFuIGluaXRpYWwgMjU2IHZhbHVlcy5cbiAgICBmb3IgKGogPSAyNTY7IGogPiAwOyAtLWopIHtcbiAgICAgIG1lLm5leHQoKTtcbiAgICB9XG4gIH1cblxuICBpbml0KG1lLCBzZWVkKTtcbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQueCA9IGYueC5zbGljZSgpO1xuICB0LmkgPSBmLmk7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgaWYgKHNlZWQgPT0gbnVsbCkgc2VlZCA9ICsobmV3IERhdGUpO1xuICB2YXIgeGcgPSBuZXcgWG9yR2VuKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwOyB9O1xuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvIHtcbiAgICAgIHZhciB0b3AgPSB4Zy5uZXh0KCkgPj4+IDExLFxuICAgICAgICAgIGJvdCA9ICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDAsXG4gICAgICAgICAgcmVzdWx0ID0gKHRvcCArIGJvdCkgLyAoMSA8PCAyMSk7XG4gICAgfSB3aGlsZSAocmVzdWx0ID09PSAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm5nLmludDMyID0geGcubmV4dDtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS54KSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMueG9yc2hpZnQ3ID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcblxuIiwiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgdGhlIFwieG9yd293XCIgcHJuZyBhbGdvcml0aG0gYnlcbi8vIEdlb3JnZSBNYXJzYWdsaWEuICBTZWUgaHR0cDovL3d3dy5qc3RhdHNvZnQub3JnL3YwOC9pMTQvcGFwZXJcblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gWG9yR2VuKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcywgc3Ryc2VlZCA9ICcnO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IChtZS54IF4gKG1lLnggPj4+IDIpKTtcbiAgICBtZS54ID0gbWUueTsgbWUueSA9IG1lLno7IG1lLnogPSBtZS53OyBtZS53ID0gbWUudjtcbiAgICByZXR1cm4gKG1lLmQgPSAobWUuZCArIDM2MjQzNyB8IDApKSArXG4gICAgICAgKG1lLnYgPSAobWUudiBeIChtZS52IDw8IDQpKSBeICh0IF4gKHQgPDwgMSkpKSB8IDA7XG4gIH07XG5cbiAgbWUueCA9IDA7XG4gIG1lLnkgPSAwO1xuICBtZS56ID0gMDtcbiAgbWUudyA9IDA7XG4gIG1lLnYgPSAwO1xuXG4gIGlmIChzZWVkID09PSAoc2VlZCB8IDApKSB7XG4gICAgLy8gSW50ZWdlciBzZWVkLlxuICAgIG1lLnggPSBzZWVkO1xuICB9IGVsc2Uge1xuICAgIC8vIFN0cmluZyBzZWVkLlxuICAgIHN0cnNlZWQgKz0gc2VlZDtcbiAgfVxuXG4gIC8vIE1peCBpbiBzdHJpbmcgc2VlZCwgdGhlbiBkaXNjYXJkIGFuIGluaXRpYWwgYmF0Y2ggb2YgNjQgdmFsdWVzLlxuICBmb3IgKHZhciBrID0gMDsgayA8IHN0cnNlZWQubGVuZ3RoICsgNjQ7IGsrKykge1xuICAgIG1lLnggXj0gc3Ryc2VlZC5jaGFyQ29kZUF0KGspIHwgMDtcbiAgICBpZiAoayA9PSBzdHJzZWVkLmxlbmd0aCkge1xuICAgICAgbWUuZCA9IG1lLnggPDwgMTAgXiBtZS54ID4+PiA0O1xuICAgIH1cbiAgICBtZS5uZXh0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQueCA9IGYueDtcbiAgdC55ID0gZi55O1xuICB0LnogPSBmLno7XG4gIHQudyA9IGYudztcbiAgdC52ID0gZi52O1xuICB0LmQgPSBmLmQ7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnhvcndvdyA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cblxuIiwiLypcbkNvcHlyaWdodCAyMDE5IERhdmlkIEJhdS5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG5hIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcblwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xud2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG5wZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbnRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG5NRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuXG5JTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWVxuQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCxcblRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFXG5TT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIHBvb2wsIG1hdGgpIHtcbi8vXG4vLyBUaGUgZm9sbG93aW5nIGNvbnN0YW50cyBhcmUgcmVsYXRlZCB0byBJRUVFIDc1NCBsaW1pdHMuXG4vL1xuXG52YXIgd2lkdGggPSAyNTYsICAgICAgICAvLyBlYWNoIFJDNCBvdXRwdXQgaXMgMCA8PSB4IDwgMjU2XG4gICAgY2h1bmtzID0gNiwgICAgICAgICAvLyBhdCBsZWFzdCBzaXggUkM0IG91dHB1dHMgZm9yIGVhY2ggZG91YmxlXG4gICAgZGlnaXRzID0gNTIsICAgICAgICAvLyB0aGVyZSBhcmUgNTIgc2lnbmlmaWNhbnQgZGlnaXRzIGluIGEgZG91YmxlXG4gICAgcm5nbmFtZSA9ICdyYW5kb20nLCAvLyBybmduYW1lOiBuYW1lIGZvciBNYXRoLnJhbmRvbSBhbmQgTWF0aC5zZWVkcmFuZG9tXG4gICAgc3RhcnRkZW5vbSA9IG1hdGgucG93KHdpZHRoLCBjaHVua3MpLFxuICAgIHNpZ25pZmljYW5jZSA9IG1hdGgucG93KDIsIGRpZ2l0cyksXG4gICAgb3ZlcmZsb3cgPSBzaWduaWZpY2FuY2UgKiAyLFxuICAgIG1hc2sgPSB3aWR0aCAtIDEsXG4gICAgbm9kZWNyeXB0bzsgICAgICAgICAvLyBub2RlLmpzIGNyeXB0byBtb2R1bGUsIGluaXRpYWxpemVkIGF0IHRoZSBib3R0b20uXG5cbi8vXG4vLyBzZWVkcmFuZG9tKClcbi8vIFRoaXMgaXMgdGhlIHNlZWRyYW5kb20gZnVuY3Rpb24gZGVzY3JpYmVkIGFib3ZlLlxuLy9cbmZ1bmN0aW9uIHNlZWRyYW5kb20oc2VlZCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIGtleSA9IFtdO1xuICBvcHRpb25zID0gKG9wdGlvbnMgPT0gdHJ1ZSkgPyB7IGVudHJvcHk6IHRydWUgfSA6IChvcHRpb25zIHx8IHt9KTtcblxuICAvLyBGbGF0dGVuIHRoZSBzZWVkIHN0cmluZyBvciBidWlsZCBvbmUgZnJvbSBsb2NhbCBlbnRyb3B5IGlmIG5lZWRlZC5cbiAgdmFyIHNob3J0c2VlZCA9IG1peGtleShmbGF0dGVuKFxuICAgIG9wdGlvbnMuZW50cm9weSA/IFtzZWVkLCB0b3N0cmluZyhwb29sKV0gOlxuICAgIChzZWVkID09IG51bGwpID8gYXV0b3NlZWQoKSA6IHNlZWQsIDMpLCBrZXkpO1xuXG4gIC8vIFVzZSB0aGUgc2VlZCB0byBpbml0aWFsaXplIGFuIEFSQzQgZ2VuZXJhdG9yLlxuICB2YXIgYXJjNCA9IG5ldyBBUkM0KGtleSk7XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgcmFuZG9tIGRvdWJsZSBpbiBbMCwgMSkgdGhhdCBjb250YWluc1xuICAvLyByYW5kb21uZXNzIGluIGV2ZXJ5IGJpdCBvZiB0aGUgbWFudGlzc2Egb2YgdGhlIElFRUUgNzU0IHZhbHVlLlxuICB2YXIgcHJuZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuID0gYXJjNC5nKGNodW5rcyksICAgICAgICAgICAgIC8vIFN0YXJ0IHdpdGggYSBudW1lcmF0b3IgbiA8IDIgXiA0OFxuICAgICAgICBkID0gc3RhcnRkZW5vbSwgICAgICAgICAgICAgICAgIC8vICAgYW5kIGRlbm9taW5hdG9yIGQgPSAyIF4gNDguXG4gICAgICAgIHggPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBhbmQgbm8gJ2V4dHJhIGxhc3QgYnl0ZScuXG4gICAgd2hpbGUgKG4gPCBzaWduaWZpY2FuY2UpIHsgICAgICAgICAgLy8gRmlsbCB1cCBhbGwgc2lnbmlmaWNhbnQgZGlnaXRzIGJ5XG4gICAgICBuID0gKG4gKyB4KSAqIHdpZHRoOyAgICAgICAgICAgICAgLy8gICBzaGlmdGluZyBudW1lcmF0b3IgYW5kXG4gICAgICBkICo9IHdpZHRoOyAgICAgICAgICAgICAgICAgICAgICAgLy8gICBkZW5vbWluYXRvciBhbmQgZ2VuZXJhdGluZyBhXG4gICAgICB4ID0gYXJjNC5nKDEpOyAgICAgICAgICAgICAgICAgICAgLy8gICBuZXcgbGVhc3Qtc2lnbmlmaWNhbnQtYnl0ZS5cbiAgICB9XG4gICAgd2hpbGUgKG4gPj0gb3ZlcmZsb3cpIHsgICAgICAgICAgICAgLy8gVG8gYXZvaWQgcm91bmRpbmcgdXAsIGJlZm9yZSBhZGRpbmdcbiAgICAgIG4gLz0gMjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGxhc3QgYnl0ZSwgc2hpZnQgZXZlcnl0aGluZ1xuICAgICAgZCAvPSAyOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgcmlnaHQgdXNpbmcgaW50ZWdlciBtYXRoIHVudGlsXG4gICAgICB4ID4+Pj0gMTsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICB3ZSBoYXZlIGV4YWN0bHkgdGhlIGRlc2lyZWQgYml0cy5cbiAgICB9XG4gICAgcmV0dXJuIChuICsgeCkgLyBkOyAgICAgICAgICAgICAgICAgLy8gRm9ybSB0aGUgbnVtYmVyIHdpdGhpbiBbMCwgMSkuXG4gIH07XG5cbiAgcHJuZy5pbnQzMiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJjNC5nKDQpIHwgMDsgfVxuICBwcm5nLnF1aWNrID0gZnVuY3Rpb24oKSB7IHJldHVybiBhcmM0LmcoNCkgLyAweDEwMDAwMDAwMDsgfVxuICBwcm5nLmRvdWJsZSA9IHBybmc7XG5cbiAgLy8gTWl4IHRoZSByYW5kb21uZXNzIGludG8gYWNjdW11bGF0ZWQgZW50cm9weS5cbiAgbWl4a2V5KHRvc3RyaW5nKGFyYzQuUyksIHBvb2wpO1xuXG4gIC8vIENhbGxpbmcgY29udmVudGlvbjogd2hhdCB0byByZXR1cm4gYXMgYSBmdW5jdGlvbiBvZiBwcm5nLCBzZWVkLCBpc19tYXRoLlxuICByZXR1cm4gKG9wdGlvbnMucGFzcyB8fCBjYWxsYmFjayB8fFxuICAgICAgZnVuY3Rpb24ocHJuZywgc2VlZCwgaXNfbWF0aF9jYWxsLCBzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAvLyBMb2FkIHRoZSBhcmM0IHN0YXRlIGZyb20gdGhlIGdpdmVuIHN0YXRlIGlmIGl0IGhhcyBhbiBTIGFycmF5LlxuICAgICAgICAgIGlmIChzdGF0ZS5TKSB7IGNvcHkoc3RhdGUsIGFyYzQpOyB9XG4gICAgICAgICAgLy8gT25seSBwcm92aWRlIHRoZSAuc3RhdGUgbWV0aG9kIGlmIHJlcXVlc3RlZCB2aWEgb3B0aW9ucy5zdGF0ZS5cbiAgICAgICAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KGFyYzQsIHt9KTsgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgY2FsbGVkIGFzIGEgbWV0aG9kIG9mIE1hdGggKE1hdGguc2VlZHJhbmRvbSgpKSwgbXV0YXRlXG4gICAgICAgIC8vIE1hdGgucmFuZG9tIGJlY2F1c2UgdGhhdCBpcyBob3cgc2VlZHJhbmRvbS5qcyBoYXMgd29ya2VkIHNpbmNlIHYxLjAuXG4gICAgICAgIGlmIChpc19tYXRoX2NhbGwpIHsgbWF0aFtybmduYW1lXSA9IHBybmc7IHJldHVybiBzZWVkOyB9XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdCBpcyBhIG5ld2VyIGNhbGxpbmcgY29udmVudGlvbiwgc28gcmV0dXJuIHRoZVxuICAgICAgICAvLyBwcm5nIGRpcmVjdGx5LlxuICAgICAgICBlbHNlIHJldHVybiBwcm5nO1xuICAgICAgfSkoXG4gIHBybmcsXG4gIHNob3J0c2VlZCxcbiAgJ2dsb2JhbCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMuZ2xvYmFsIDogKHRoaXMgPT0gbWF0aCksXG4gIG9wdGlvbnMuc3RhdGUpO1xufVxuXG4vL1xuLy8gQVJDNFxuLy9cbi8vIEFuIEFSQzQgaW1wbGVtZW50YXRpb24uICBUaGUgY29uc3RydWN0b3IgdGFrZXMgYSBrZXkgaW4gdGhlIGZvcm0gb2Zcbi8vIGFuIGFycmF5IG9mIGF0IG1vc3QgKHdpZHRoKSBpbnRlZ2VycyB0aGF0IHNob3VsZCBiZSAwIDw9IHggPCAod2lkdGgpLlxuLy9cbi8vIFRoZSBnKGNvdW50KSBtZXRob2QgcmV0dXJucyBhIHBzZXVkb3JhbmRvbSBpbnRlZ2VyIHRoYXQgY29uY2F0ZW5hdGVzXG4vLyB0aGUgbmV4dCAoY291bnQpIG91dHB1dHMgZnJvbSBBUkM0LiAgSXRzIHJldHVybiB2YWx1ZSBpcyBhIG51bWJlciB4XG4vLyB0aGF0IGlzIGluIHRoZSByYW5nZSAwIDw9IHggPCAod2lkdGggXiBjb3VudCkuXG4vL1xuZnVuY3Rpb24gQVJDNChrZXkpIHtcbiAgdmFyIHQsIGtleWxlbiA9IGtleS5sZW5ndGgsXG4gICAgICBtZSA9IHRoaXMsIGkgPSAwLCBqID0gbWUuaSA9IG1lLmogPSAwLCBzID0gbWUuUyA9IFtdO1xuXG4gIC8vIFRoZSBlbXB0eSBrZXkgW10gaXMgdHJlYXRlZCBhcyBbMF0uXG4gIGlmICgha2V5bGVuKSB7IGtleSA9IFtrZXlsZW4rK107IH1cblxuICAvLyBTZXQgdXAgUyB1c2luZyB0aGUgc3RhbmRhcmQga2V5IHNjaGVkdWxpbmcgYWxnb3JpdGhtLlxuICB3aGlsZSAoaSA8IHdpZHRoKSB7XG4gICAgc1tpXSA9IGkrKztcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgIHNbaV0gPSBzW2ogPSBtYXNrICYgKGogKyBrZXlbaSAlIGtleWxlbl0gKyAodCA9IHNbaV0pKV07XG4gICAgc1tqXSA9IHQ7XG4gIH1cblxuICAvLyBUaGUgXCJnXCIgbWV0aG9kIHJldHVybnMgdGhlIG5leHQgKGNvdW50KSBvdXRwdXRzIGFzIG9uZSBudW1iZXIuXG4gIChtZS5nID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICAvLyBVc2luZyBpbnN0YW5jZSBtZW1iZXJzIGluc3RlYWQgb2YgY2xvc3VyZSBzdGF0ZSBuZWFybHkgZG91YmxlcyBzcGVlZC5cbiAgICB2YXIgdCwgciA9IDAsXG4gICAgICAgIGkgPSBtZS5pLCBqID0gbWUuaiwgcyA9IG1lLlM7XG4gICAgd2hpbGUgKGNvdW50LS0pIHtcbiAgICAgIHQgPSBzW2kgPSBtYXNrICYgKGkgKyAxKV07XG4gICAgICByID0gciAqIHdpZHRoICsgc1ttYXNrICYgKChzW2ldID0gc1tqID0gbWFzayAmIChqICsgdCldKSArIChzW2pdID0gdCkpXTtcbiAgICB9XG4gICAgbWUuaSA9IGk7IG1lLmogPSBqO1xuICAgIHJldHVybiByO1xuICAgIC8vIEZvciByb2J1c3QgdW5wcmVkaWN0YWJpbGl0eSwgdGhlIGZ1bmN0aW9uIGNhbGwgYmVsb3cgYXV0b21hdGljYWxseVxuICAgIC8vIGRpc2NhcmRzIGFuIGluaXRpYWwgYmF0Y2ggb2YgdmFsdWVzLiAgVGhpcyBpcyBjYWxsZWQgUkM0LWRyb3BbMjU2XS5cbiAgICAvLyBTZWUgaHR0cDovL2dvb2dsZS5jb20vc2VhcmNoP3E9cnNhK2ZsdWhyZXIrcmVzcG9uc2UmYnRuSVxuICB9KSh3aWR0aCk7XG59XG5cbi8vXG4vLyBjb3B5KClcbi8vIENvcGllcyBpbnRlcm5hbCBzdGF0ZSBvZiBBUkM0IHRvIG9yIGZyb20gYSBwbGFpbiBvYmplY3QuXG4vL1xuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuaSA9IGYuaTtcbiAgdC5qID0gZi5qO1xuICB0LlMgPSBmLlMuc2xpY2UoKTtcbiAgcmV0dXJuIHQ7XG59O1xuXG4vL1xuLy8gZmxhdHRlbigpXG4vLyBDb252ZXJ0cyBhbiBvYmplY3QgdHJlZSB0byBuZXN0ZWQgYXJyYXlzIG9mIHN0cmluZ3MuXG4vL1xuZnVuY3Rpb24gZmxhdHRlbihvYmosIGRlcHRoKSB7XG4gIHZhciByZXN1bHQgPSBbXSwgdHlwID0gKHR5cGVvZiBvYmopLCBwcm9wO1xuICBpZiAoZGVwdGggJiYgdHlwID09ICdvYmplY3QnKSB7XG4gICAgZm9yIChwcm9wIGluIG9iaikge1xuICAgICAgdHJ5IHsgcmVzdWx0LnB1c2goZmxhdHRlbihvYmpbcHJvcF0sIGRlcHRoIC0gMSkpOyB9IGNhdGNoIChlKSB7fVxuICAgIH1cbiAgfVxuICByZXR1cm4gKHJlc3VsdC5sZW5ndGggPyByZXN1bHQgOiB0eXAgPT0gJ3N0cmluZycgPyBvYmogOiBvYmogKyAnXFwwJyk7XG59XG5cbi8vXG4vLyBtaXhrZXkoKVxuLy8gTWl4ZXMgYSBzdHJpbmcgc2VlZCBpbnRvIGEga2V5IHRoYXQgaXMgYW4gYXJyYXkgb2YgaW50ZWdlcnMsIGFuZFxuLy8gcmV0dXJucyBhIHNob3J0ZW5lZCBzdHJpbmcgc2VlZCB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gdGhlIHJlc3VsdCBrZXkuXG4vL1xuZnVuY3Rpb24gbWl4a2V5KHNlZWQsIGtleSkge1xuICB2YXIgc3RyaW5nc2VlZCA9IHNlZWQgKyAnJywgc21lYXIsIGogPSAwO1xuICB3aGlsZSAoaiA8IHN0cmluZ3NlZWQubGVuZ3RoKSB7XG4gICAga2V5W21hc2sgJiBqXSA9XG4gICAgICBtYXNrICYgKChzbWVhciBePSBrZXlbbWFzayAmIGpdICogMTkpICsgc3RyaW5nc2VlZC5jaGFyQ29kZUF0KGorKykpO1xuICB9XG4gIHJldHVybiB0b3N0cmluZyhrZXkpO1xufVxuXG4vL1xuLy8gYXV0b3NlZWQoKVxuLy8gUmV0dXJucyBhbiBvYmplY3QgZm9yIGF1dG9zZWVkaW5nLCB1c2luZyB3aW5kb3cuY3J5cHRvIGFuZCBOb2RlIGNyeXB0b1xuLy8gbW9kdWxlIGlmIGF2YWlsYWJsZS5cbi8vXG5mdW5jdGlvbiBhdXRvc2VlZCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3V0O1xuICAgIGlmIChub2RlY3J5cHRvICYmIChvdXQgPSBub2RlY3J5cHRvLnJhbmRvbUJ5dGVzKSkge1xuICAgICAgLy8gVGhlIHVzZSBvZiAnb3V0JyB0byByZW1lbWJlciByYW5kb21CeXRlcyBtYWtlcyB0aWdodCBtaW5pZmllZCBjb2RlLlxuICAgICAgb3V0ID0gb3V0KHdpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkod2lkdGgpO1xuICAgICAgKGdsb2JhbC5jcnlwdG8gfHwgZ2xvYmFsLm1zQ3J5cHRvKS5nZXRSYW5kb21WYWx1ZXMob3V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvc3RyaW5nKG91dCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIgYnJvd3NlciA9IGdsb2JhbC5uYXZpZ2F0b3IsXG4gICAgICAgIHBsdWdpbnMgPSBicm93c2VyICYmIGJyb3dzZXIucGx1Z2lucztcbiAgICByZXR1cm4gWytuZXcgRGF0ZSwgZ2xvYmFsLCBwbHVnaW5zLCBnbG9iYWwuc2NyZWVuLCB0b3N0cmluZyhwb29sKV07XG4gIH1cbn1cblxuLy9cbi8vIHRvc3RyaW5nKClcbi8vIENvbnZlcnRzIGFuIGFycmF5IG9mIGNoYXJjb2RlcyB0byBhIHN0cmluZ1xuLy9cbmZ1bmN0aW9uIHRvc3RyaW5nKGEpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoMCwgYSk7XG59XG5cbi8vXG4vLyBXaGVuIHNlZWRyYW5kb20uanMgaXMgbG9hZGVkLCB3ZSBpbW1lZGlhdGVseSBtaXggYSBmZXcgYml0c1xuLy8gZnJvbSB0aGUgYnVpbHQtaW4gUk5HIGludG8gdGhlIGVudHJvcHkgcG9vbC4gIEJlY2F1c2Ugd2UgZG9cbi8vIG5vdCB3YW50IHRvIGludGVyZmVyZSB3aXRoIGRldGVybWluaXN0aWMgUFJORyBzdGF0ZSBsYXRlcixcbi8vIHNlZWRyYW5kb20gd2lsbCBub3QgY2FsbCBtYXRoLnJhbmRvbSBvbiBpdHMgb3duIGFnYWluIGFmdGVyXG4vLyBpbml0aWFsaXphdGlvbi5cbi8vXG5taXhrZXkobWF0aC5yYW5kb20oKSwgcG9vbCk7XG5cbi8vXG4vLyBOb2RlanMgYW5kIEFNRCBzdXBwb3J0OiBleHBvcnQgdGhlIGltcGxlbWVudGF0aW9uIGFzIGEgbW9kdWxlIHVzaW5nXG4vLyBlaXRoZXIgY29udmVudGlvbi5cbi8vXG5pZiAoKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gc2VlZHJhbmRvbTtcbiAgLy8gV2hlbiBpbiBub2RlLmpzLCB0cnkgdXNpbmcgY3J5cHRvIHBhY2thZ2UgZm9yIGF1dG9zZWVkaW5nLlxuICB0cnkge1xuICAgIG5vZGVjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbiAgfSBjYXRjaCAoZXgpIHt9XG59IGVsc2UgaWYgKCh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VlZHJhbmRvbTsgfSk7XG59IGVsc2Uge1xuICAvLyBXaGVuIGluY2x1ZGVkIGFzIGEgcGxhaW4gc2NyaXB0LCBzZXQgdXAgTWF0aC5zZWVkcmFuZG9tIGdsb2JhbC5cbiAgbWF0aFsnc2VlZCcgKyBybmduYW1lXSA9IHNlZWRyYW5kb207XG59XG5cblxuLy8gRW5kIGFub255bW91cyBzY29wZSwgYW5kIHBhc3MgaW5pdGlhbCB2YWx1ZXMuXG59KShcbiAgLy8gZ2xvYmFsOiBgc2VsZmAgaW4gYnJvd3NlcnMgKGluY2x1ZGluZyBzdHJpY3QgbW9kZSBhbmQgd2ViIHdvcmtlcnMpLFxuICAvLyBvdGhlcndpc2UgYHRoaXNgIGluIE5vZGUgYW5kIG90aGVyIGVudmlyb25tZW50c1xuICAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSA/IHNlbGYgOiB0aGlzLFxuICBbXSwgICAgIC8vIHBvb2w6IGVudHJvcHkgcG9vbCBzdGFydHMgZW1wdHlcbiAgTWF0aCAgICAvLyBtYXRoOiBwYWNrYWdlIGNvbnRhaW5pbmcgcmFuZG9tLCBwb3csIGFuZCBzZWVkcmFuZG9tXG4pO1xuIiwiXG4gICAgICBpbXBvcnQgQVBJIGZyb20gXCIhLi4vLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgIGltcG9ydCBkb21BUEkgZnJvbSBcIiEuLi8uLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0Rm4gZnJvbSBcIiEuLi8uLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanNcIjtcbiAgICAgIGltcG9ydCBzZXRBdHRyaWJ1dGVzIGZyb20gXCIhLi4vLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRTdHlsZUVsZW1lbnQgZnJvbSBcIiEuLi8uLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qc1wiO1xuICAgICAgaW1wb3J0IHN0eWxlVGFnVHJhbnNmb3JtRm4gZnJvbSBcIiEuLi8uLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzXCI7XG4gICAgICBpbXBvcnQgY29udGVudCwgKiBhcyBuYW1lZEV4cG9ydCBmcm9tIFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vamFzbWluZS5jc3NcIjtcbiAgICAgIFxuICAgICAgXG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0gPSBzdHlsZVRhZ1RyYW5zZm9ybUZuO1xub3B0aW9ucy5zZXRBdHRyaWJ1dGVzID0gc2V0QXR0cmlidXRlcztcblxuICAgICAgb3B0aW9ucy5pbnNlcnQgPSBpbnNlcnRGbi5iaW5kKG51bGwsIFwiaGVhZFwiKTtcbiAgICBcbm9wdGlvbnMuZG9tQVBJID0gZG9tQVBJO1xub3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7XG5cbnZhciB1cGRhdGUgPSBBUEkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgKiBmcm9tIFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vamFzbWluZS5jc3NcIjtcbiAgICAgICBleHBvcnQgZGVmYXVsdCBjb250ZW50ICYmIGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB1bmRlZmluZWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHN0eWxlc0luRE9NID0gW107XG5cbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5ET00ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5ET01baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleEJ5SWRlbnRpZmllciA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXSxcbiAgICAgIHN1cHBvcnRzOiBpdGVtWzRdLFxuICAgICAgbGF5ZXI6IGl0ZW1bNV1cbiAgICB9O1xuXG4gICAgaWYgKGluZGV4QnlJZGVudGlmaWVyICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB1cGRhdGVyID0gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLmJ5SW5kZXggPSBpO1xuICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKGksIDAsIHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgdXBkYXRlcjogdXBkYXRlcixcbiAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfVxuXG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cblxuZnVuY3Rpb24gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgYXBpID0gb3B0aW9ucy5kb21BUEkob3B0aW9ucyk7XG4gIGFwaS51cGRhdGUob2JqKTtcblxuICB2YXIgdXBkYXRlciA9IGZ1bmN0aW9uIHVwZGF0ZXIobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCAmJiBuZXdPYmouc3VwcG9ydHMgPT09IG9iai5zdXBwb3J0cyAmJiBuZXdPYmoubGF5ZXIgPT09IG9iai5sYXllcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGFwaS51cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbW92ZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdXBkYXRlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cblxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcblxuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcblxuICAgICAgaWYgKHN0eWxlc0luRE9NW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRPTVtfaW5kZXhdLnVwZGF0ZXIoKTtcblxuICAgICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgbWVtbyA9IHt9O1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cbmZ1bmN0aW9uIGdldFRhcmdldCh0YXJnZXQpIHtcbiAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7IC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cbiAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gIH1cblxuICByZXR1cm4gbWVtb1t0YXJnZXRdO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxuZnVuY3Rpb24gaW5zZXJ0QnlTZWxlY3RvcihpbnNlcnQsIHN0eWxlKSB7XG4gIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQoaW5zZXJ0KTtcblxuICBpZiAoIXRhcmdldCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gIH1cblxuICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydEJ5U2VsZWN0b3I7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIG9wdGlvbnMuc2V0QXR0cmlidXRlcyhlbGVtZW50LCBvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICBvcHRpb25zLmluc2VydChlbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xuICByZXR1cm4gZWxlbWVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzKHN0eWxlRWxlbWVudCkge1xuICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG5cbiAgaWYgKG5vbmNlKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlczsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gXCJcIjtcblxuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQob2JqLnN1cHBvcnRzLCBcIikge1wiKTtcbiAgfVxuXG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKTtcbiAgfVxuXG4gIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2Ygb2JqLmxheWVyICE9PSBcInVuZGVmaW5lZFwiO1xuXG4gIGlmIChuZWVkTGF5ZXIpIHtcbiAgICBjc3MgKz0gXCJAbGF5ZXJcIi5jb25jYXQob2JqLmxheWVyLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQob2JqLmxheWVyKSA6IFwiXCIsIFwiIHtcIik7XG4gIH1cblxuICBjc3MgKz0gb2JqLmNzcztcblxuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG5cbiAgaWYgKG9iai5tZWRpYSkge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuXG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cblxuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIG9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZUVsZW1lbnQucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG5mdW5jdGlvbiBkb21BUEkob3B0aW9ucykge1xuICB2YXIgc3R5bGVFbGVtZW50ID0gb3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUob2JqKSB7XG4gICAgICBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaik7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkb21BUEk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQpIHtcbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5bGVUYWdUcmFuc2Zvcm07IiwiaW1wb3J0IENvbXB1dGVWb3hlbHMgZnJvbSAnISFyYXctbG9hZGVyIS4vY29tcHV0ZS12b3hlbHMud2dzbCc7XG5pbXBvcnQgUmFuZG9tIGZyb20gJ3NlZWRyYW5kb20nO1xuXG5kZXNjcmliZSgnY29tcHV0ZS12b3hlbHMnLCAoKSA9PiB7XG4gIGRlc2NyaWJlKCdjb21wdXRlTWF0ZXJpYWxzJywgKCkgPT4ge1xuICAgIGxldCBtYXRlcmlhbHM6IFVpbnQzMkFycmF5O1xuXG4gICAgYmVmb3JlQWxsKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGFkYXB0ZXIgPSBhd2FpdCBuYXZpZ2F0b3IuZ3B1LnJlcXVlc3RBZGFwdGVyKCk7XG4gICAgICBjb25zdCBkZXZpY2UgPSBhd2FpdCBhZGFwdGVyLnJlcXVlc3REZXZpY2UoKTtcblxuICAgICAgY29uc3QgZGVuc2l0eSA9IGBmbiBnZXREZW5zaXR5KHdvcmxkUG9zaXRpb246IHZlYzM8ZjMyPikgLT4gZjMyIHsgXG4gICAgICAgIGlmICh3b3JsZFBvc2l0aW9uLnkgPCAzLjApIHtcbiAgICAgICAgICByZXR1cm4gLTEuMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gMS4wO1xuICAgICAgICB9XG4gICAgICAgfWA7XG5cbiAgICAgIGNvbnN0IGNvbXB1dGVWb3hlbHMgPSBDb21wdXRlVm94ZWxzLnJlcGxhY2UoXCIjaW1wb3J0IGRlbnNpdHlcIiwgZGVuc2l0eSlcbiAgICAgIGNvbnN0IGNvbXB1dGVQaXBlbGluZSA9IGF3YWl0IGRldmljZS5jcmVhdGVDb21wdXRlUGlwZWxpbmVBc3luYyh7XG4gICAgICAgIGxheW91dDogJ2F1dG8nLFxuICAgICAgICBjb21wdXRlOiB7XG4gICAgICAgICAgbW9kdWxlOiBkZXZpY2UuY3JlYXRlU2hhZGVyTW9kdWxlKHtcbiAgICAgICAgICAgIGNvZGU6IGNvbXB1dGVWb3hlbHMsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgZW50cnlQb2ludDogJ2NvbXB1dGVNYXRlcmlhbHMnLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHBlcm11dGF0aW9ucyA9IG5ldyBJbnQzMkFycmF5KDUxMik7XG5cbiAgICAgIGNvbnN0IHJhbmRvbSA9IG5ldyBSYW5kb20oNjQ1Mik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKVxuICAgICAgICBwZXJtdXRhdGlvbnNbaV0gPSAoMjU2ICogKHJhbmRvbSgpKSk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAyNTY7IGkgPCA1MTI7IGkrKylcbiAgICAgICAgcGVybXV0YXRpb25zW2ldID0gcGVybXV0YXRpb25zW2kgLSAyNTZdO1xuXG4gICAgICBjb25zdCBwZXJtdXRhdGlvbnNCdWZmZXIgPSBkZXZpY2UuY3JlYXRlQnVmZmVyKHtcbiAgICAgICAgc2l6ZTogcGVybXV0YXRpb25zLmJ5dGVMZW5ndGgsXG4gICAgICAgIHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5TVE9SQUdFIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QsXG4gICAgICAgIG1hcHBlZEF0Q3JlYXRpb246IHRydWUsXG4gICAgICB9KTtcblxuICAgICAgbmV3IEludDMyQXJyYXkocGVybXV0YXRpb25zQnVmZmVyLmdldE1hcHBlZFJhbmdlKCkpLnNldChcbiAgICAgICAgcGVybXV0YXRpb25zXG4gICAgICApO1xuICAgICAgcGVybXV0YXRpb25zQnVmZmVyLnVubWFwKCk7XG5cbiAgICAgIGNvbnN0IGNvcm5lck1hdGVyaWFscyA9IGRldmljZS5jcmVhdGVCdWZmZXIoe1xuICAgICAgICBzaXplOiBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCAqIDUgKiA1ICogNSxcbiAgICAgICAgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UgfCBHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQyxcbiAgICAgICAgbWFwcGVkQXRDcmVhdGlvbjogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgY29ybmVyTWF0ZXJpYWxzUmVhZCA9IGRldmljZS5jcmVhdGVCdWZmZXIoe1xuICAgICAgICBzaXplOiBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCAqIDUgKiA1ICogNSxcbiAgICAgICAgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUIHwgR1BVQnVmZmVyVXNhZ2UuTUFQX1JFQUQsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdW5pZm9ybUJ1ZmZlclNpemUgPSA0ICogNTtcbiAgICAgIGNvbnN0IHVuaWZvcm1CdWZmZXIgPSBkZXZpY2UuY3JlYXRlQnVmZmVyKHtcbiAgICAgICAgc2l6ZTogdW5pZm9ybUJ1ZmZlclNpemUsXG4gICAgICAgIHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5VTklGT1JNIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgY29tcHV0ZUJpbmRHcm91cCA9IGRldmljZS5jcmVhdGVCaW5kR3JvdXAoe1xuICAgICAgICBsYXlvdXQ6IGNvbXB1dGVQaXBlbGluZS5nZXRCaW5kR3JvdXBMYXlvdXQoMCksXG4gICAgICAgIGVudHJpZXM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBiaW5kaW5nOiAxLFxuICAgICAgICAgICAgcmVzb3VyY2U6IHtcbiAgICAgICAgICAgICAgYnVmZmVyOiBjb3JuZXJNYXRlcmlhbHNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmluZGluZzogNSxcbiAgICAgICAgICAgIHJlc291cmNlOiB7XG4gICAgICAgICAgICAgIGJ1ZmZlcjogdW5pZm9ybUJ1ZmZlclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBjb21wdXRlRW5jb2RlciA9IGRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlcigpO1xuICAgICAgY29uc3QgY29tcHV0ZVBhc3NFbmNvZGVyID0gY29tcHV0ZUVuY29kZXIuYmVnaW5Db21wdXRlUGFzcygpO1xuICAgICAgY29tcHV0ZVBhc3NFbmNvZGVyLnNldFBpcGVsaW5lKGNvbXB1dGVQaXBlbGluZSk7XG4gICAgICBjb21wdXRlUGFzc0VuY29kZXIuc2V0QmluZEdyb3VwKDAsIGNvbXB1dGVCaW5kR3JvdXApO1xuICAgICAgY29tcHV0ZVBhc3NFbmNvZGVyLmRpc3BhdGNoV29ya2dyb3Vwcyg1LCA1LCA1KTtcbiAgICAgIGNvbXB1dGVQYXNzRW5jb2Rlci5lbmQoKTtcblxuICAgICAgY29uc3QgY29weUVuY29kZXIgPSBkZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoKTtcbiAgICAgIGNvcHlFbmNvZGVyLmNvcHlCdWZmZXJUb0J1ZmZlcihcbiAgICAgICAgY29ybmVyTWF0ZXJpYWxzLFxuICAgICAgICAwLFxuICAgICAgICBjb3JuZXJNYXRlcmlhbHNSZWFkLFxuICAgICAgICAwLFxuICAgICAgICBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCAqIDUgKiA1ICogNVxuICAgICAgKTtcblxuICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcig0ICogNSk7XG4gICAgICBjb25zdCB1bmlmb3JtID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIsIDAsIDQpO1xuICAgICAgdW5pZm9ybVszXSA9IDE7XG5cbiAgICAgIG5ldyBVaW50MzJBcnJheShidWZmZXIsIDE2LCAxKVswXSA9IDU7XG5cbiAgICAgIGRldmljZS5xdWV1ZS53cml0ZUJ1ZmZlcihcbiAgICAgICAgICB1bmlmb3JtQnVmZmVyLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgYnVmZmVyLmJ5dGVMZW5ndGhcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHF1ZXVlID0gZGV2aWNlLnF1ZXVlLm9uU3VibWl0dGVkV29ya0RvbmUoKTtcblxuICAgICAgZGV2aWNlLnF1ZXVlLnN1Ym1pdChbY29tcHV0ZUVuY29kZXIuZmluaXNoKCksIGNvcHlFbmNvZGVyLmZpbmlzaCgpXSk7XG5cbiAgICAgIGF3YWl0IHF1ZXVlO1xuXG4gICAgICBhd2FpdCBjb3JuZXJNYXRlcmlhbHNSZWFkLm1hcEFzeW5jKEdQVU1hcE1vZGUuUkVBRClcbiAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gY29ybmVyTWF0ZXJpYWxzUmVhZC5nZXRNYXBwZWRSYW5nZSgpO1xuICAgICAgbWF0ZXJpYWxzID0gbmV3IFVpbnQzMkFycmF5KGFycmF5QnVmZmVyKS5zbGljZSgpO1xuICAgICAgY29ybmVyTWF0ZXJpYWxzUmVhZC51bm1hcCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3RoZW4gbWF0ZXJpYWxzIGlzIG5vdCBudWxsJywgKCkgPT4ge1xuICAgICAgY29uc3QgZXhwZWN0ZWRSZXN1bHQgPSBuZXcgVWludDMyQXJyYXkoNSo1KjUpO1xuXG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDU7IHgrKylcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTsgeSsrKVxuICAgICAgZm9yIChsZXQgeiA9IDA7IHogPCA1OyB6KyspIHtcbiAgICAgICAgZXhwZWN0ZWRSZXN1bHRbeiAqIDUgKiA1ICsgeSAqIDUgKyB4XSA9IHkgPCAzID8gMSA6IDA7XG4gICAgICB9XG5cbiAgICAgIGV4cGVjdChtYXRlcmlhbHMpLnRvRXF1YWwoZXhwZWN0ZWRSZXN1bHQpO1xuICAgIH0pO1xuICB9KTtcbn0pOyIsImltcG9ydCBSZW5kZXJlciBmcm9tIFwiLi9yZW5kZXJlclwiO1xuXG5kZXNjcmliZSgnUmVuZGVyZXInLCAoKSA9PiB7XG4gIGxldCBjYW52YXM7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbnZhcycpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIG5vdCB0aHJvdyB3aGVuIGluaXRpYWxpemVkJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKCk7XG4gICAgYXdhaXQgZXhwZWN0QXN5bmMgKHJlbmRlcmVyLmluaXQoY2FudmFzKSkudG9CZVJlc29sdmVkKCk7XG4gICAgZXhwZWN0KCgpID0+IHJlbmRlcmVyLmNvbmZpZ3VyZShjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpKS5ub3QudG9UaHJvdygpO1xuICAgIGV4cGVjdCgoKSA9PiByZW5kZXJlci5yZW5kZXIoKCkgPT4ge30pKS5ub3QudG9UaHJvdygpO1xuICB9KTtcbn0pOyIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmVyIHtcbiAgcHJpdmF0ZSBjb250ZXh0OiBHUFVDYW52YXNDb250ZXh0O1xuICBkZXZpY2U6IEdQVURldmljZTtcbiAgcHJpdmF0ZSBwcmVzZW50YXRpb25Gb3JtYXQ6IEdQVVRleHR1cmVGb3JtYXRcbiAgcHJpdmF0ZSBkZXB0aFRleHR1cmU6IEdQVVRleHR1cmVcblxuICBhc3luYyBpbml0KGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gYXdhaXQgbmF2aWdhdG9yLmdwdS5yZXF1ZXN0QWRhcHRlcigpO1xuICAgIHRoaXMuZGV2aWNlID0gYXdhaXQgYWRhcHRlci5yZXF1ZXN0RGV2aWNlKCk7XG5cbiAgICB0aGlzLmNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ3B1Jyk7XG4gICAgdGhpcy5wcmVzZW50YXRpb25Gb3JtYXQgPSAgbmF2aWdhdG9yLmdwdS5nZXRQcmVmZXJyZWRDYW52YXNGb3JtYXQoKTtcbiAgfVxuXG4gIGNvbmZpZ3VyZSh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikge1xuICAgIHRoaXMuY29udGV4dC5jb25maWd1cmUoe1xuICAgICAgZGV2aWNlOiB0aGlzLmRldmljZSxcbiAgICAgIGZvcm1hdDogdGhpcy5wcmVzZW50YXRpb25Gb3JtYXQsXG4gICAgICBhbHBoYU1vZGU6ICdvcGFxdWUnXG4gICAgfSk7XG5cbiAgICB0aGlzLmRlcHRoVGV4dHVyZSA9IHRoaXMuZGV2aWNlLmNyZWF0ZVRleHR1cmUoe1xuICAgICAgc2l6ZTogeyB3aWR0aCwgaGVpZ2h0IH0sXG4gICAgICBmb3JtYXQ6ICdkZXB0aDI0cGx1cy1zdGVuY2lsOCcsXG4gICAgICB1c2FnZTogR1BVVGV4dHVyZVVzYWdlLlJFTkRFUl9BVFRBQ0hNRU5ULFxuICAgIH0pO1xuICB9XG5cbiAgcmVuZGVyKGNhbGxiYWNrOiAoR1BVUmVuZGVyUGFzc0Rlc2NyaXB0b3IpID0+IHZvaWQpIHtcbiAgICBjb25zdCBjb21tYW5kRW5jb2RlciA9IHRoaXMuZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCk7XG4gICAgY29uc3QgdGV4dHVyZVZpZXcgPSB0aGlzLmNvbnRleHQuZ2V0Q3VycmVudFRleHR1cmUoKS5jcmVhdGVWaWV3KCk7XG5cbiAgICBjb25zdCByZW5kZXJQYXNzRGVzY3JpcHRvcjogR1BVUmVuZGVyUGFzc0Rlc2NyaXB0b3IgPSB7XG4gICAgICBjb2xvckF0dGFjaG1lbnRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICB2aWV3OiB0ZXh0dXJlVmlldyxcbiAgICAgICAgICBjbGVhclZhbHVlOiB7cjogNzUvMjU1LCBnOiAwLzI1NSwgYjogMTMwLzI1NSwgYTogMS4wfSxcbiAgICAgICAgICBsb2FkT3A6ICdjbGVhcicgYXMgY29uc3QsXG4gICAgICAgICAgc3RvcmVPcDogJ3N0b3JlJyBhcyBjb25zdFxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgZGVwdGhTdGVuY2lsQXR0YWNobWVudDoge1xuICAgICAgICB2aWV3OiB0aGlzLmRlcHRoVGV4dHVyZS5jcmVhdGVWaWV3KCksXG5cbiAgICAgICAgZGVwdGhDbGVhclZhbHVlOiAxLjAsXG4gICAgICAgIGRlcHRoTG9hZE9wOiAnY2xlYXInLFxuICAgICAgICBkZXB0aFN0b3JlT3A6ICdzdG9yZScsXG5cbiAgICAgICAgc3RlbmNpbENsZWFyVmFsdWU6IDAsXG4gICAgICAgIHN0ZW5jaWxMb2FkT3A6ICdjbGVhcicsXG4gICAgICAgIHN0ZW5jaWxTdG9yZU9wOiAnc3RvcmUnLFxuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBwYXNzRW5jb2RlciA9IGNvbW1hbmRFbmNvZGVyLmJlZ2luUmVuZGVyUGFzcyhyZW5kZXJQYXNzRGVzY3JpcHRvcik7XG4gICAgY2FsbGJhY2socGFzc0VuY29kZXIpO1xuICAgIHBhc3NFbmNvZGVyLmVuZCgpO1xuXG4gICAgdGhpcy5kZXZpY2UucXVldWUuc3VibWl0KFtjb21tYW5kRW5jb2Rlci5maW5pc2goKV0pO1xuICB9XG59XG4iLCJpbXBvcnQgJ2phc21pbmUtY29yZS9saWIvamFzbWluZS1jb3JlL2phc21pbmUuY3NzJ1xuXG5pbXBvcnQgJ2phc21pbmUtY29yZS9saWIvamFzbWluZS1jb3JlL2phc21pbmUtaHRtbC5qcydcbmltcG9ydCAnamFzbWluZS1jb3JlL2xpYi9qYXNtaW5lLWNvcmUvYm9vdDAuanMnXG5pbXBvcnQgJ2phc21pbmUtY29yZS9saWIvamFzbWluZS1jb3JlL2Jvb3QxLmpzJ1xuXG4vLyBAdHMtaWdub3JlXG5jb25zdCB0ZXN0cyA9IHJlcXVpcmUuY29udGV4dChcbiAgICBcIi4vXCIsIC8vIGNvbnRleHQgZm9sZGVyXG4gICAgdHJ1ZSwgLy8gaW5jbHVkZSBzdWJkaXJlY3Rvcmllc1xuICAgIC8udGVzdC4oanx0KXMkLyAvLyBSZWdFeHBcbik7XG5cbmNvbnN0IHRlc3RGaWxlcyA9IHRlc3RzLmtleXMoKTtcbmZvciAobGV0IHRlc3QgaW4gdGVzdEZpbGVzKSB7XG4gICAgdGVzdHModGVzdEZpbGVzW3Rlc3RdKTtcbn1cbiIsImltcG9ydCBXb3JsZEdlbmVyYXRvciwge2dlbmVyYXRlUG9pbnRzfSBmcm9tICcuL3dvcmxkLWdlbmVyYXRvcic7XG5cbmRlc2NyaWJlKCdXb3JsZCBHZW5lcmF0b3InLCAoKSA9PiB7XG4gIGxldCB3b3JsZEdlbmVyYXRvcjogV29ybGRHZW5lcmF0b3I7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgd29ybGRHZW5lcmF0b3IgPSBuZXcgV29ybGRHZW5lcmF0b3IoOCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCd3aGVuIGluaXQgaXMgY2FsbGVkJywgKCkgPT4ge1xuICAgIGxldCBpbmZvO1xuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgaW5mbyA9IHdvcmxkR2VuZXJhdG9yLmluaXQoMywgMjAsIDQzKTtcbiAgICB9KTtcblxuICAgIGl0KCdwb3NpdGlvbiBpcyByb3VuZGVkIHRvIG5lYXJlc3Qgc3RyaWRlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgZXhwZWN0KGluZm8ueCkudG9FcXVhbCgwKTtcbiAgICAgIGV4cGVjdChpbmZvLnkpLnRvRXF1YWwoMjQpO1xuICAgICAgZXhwZWN0KGluZm8ueikudG9FcXVhbCg0MCk7XG4gICAgfSk7XG5cbiAgICBpdCgnY3VycmVudCBzdHJpZGUgZGVmYXVsdHMgdG8gbWluaW11bSBzdHJpZGUnLCAoKSA9PiB7XG4gICAgICBleHBlY3QoaW5mby5zdHJpZGUpLnRvRXF1YWwoOCk7XG4gICAgfSk7XG5cbiAgICBpdCgncHJldmlvdXNPZmZzZXQgaXMgY29ycmVjdCcsICgpID0+IHtcbiAgICAgIGV4cGVjdChpbmZvLnByZXZpb3VzT2Zmc2V0KS50b0VxdWFsKC00KTtcbiAgICB9KTtcblxuICAgIGl0KCdsYXllciBpcyBjb3JyZWN0JywgKCkgPT4ge1xuICAgICAgZXhwZWN0KGluZm8ubGF5ZXIpLnRvRXF1YWwoMSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCd3aGVuIG5leHQgaXMgY2FsbGVkJywgKCkgPT4ge1xuICAgIGl0KCdyZXR1cm5zIG9yaWdpbiBwb3NpdGlvbicsICgpID0+IHtcbiAgICAgIGxldCBbcmVzdWx0LCBpbmZvXSA9IHdvcmxkR2VuZXJhdG9yLm5leHQoe1xuICAgICAgICB4OiAwLCB5OiAwLCB6OiAwLCBzdHJpZGU6IDgsIGl0ZXJhdGlvbjogMCwgbGF5ZXI6IDEsIHByZXZpb3VzT2Zmc2V0OiAtNFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgICB4OiAtNCwgeTogLTQsIHo6IC00LCBzdHJpZGU6IDhcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoaW5mbykudG9FcXVhbCh7XG4gICAgICAgIHg6IDAsIHk6IDAsIHo6IDAsIHN0cmlkZTogOCwgaXRlcmF0aW9uOiAxLCBsYXllcjogMSwgcHJldmlvdXNPZmZzZXQ6IC00XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdyZXR1cm5zIG9yaWdpbiBwb3NpdGlvbiBmb3IgaXRlcmF0aW9uIDEnLCAoKSA9PiB7XG4gICAgICBsZXQgW3Jlc3VsdCwgaW5mb10gPSB3b3JsZEdlbmVyYXRvci5uZXh0KHtcbiAgICAgICAgeDogMCwgeTogMCwgejogMCwgc3RyaWRlOiA4LCBpdGVyYXRpb246IDEsIGxheWVyOiAxLCBwcmV2aW91c09mZnNldDogLTRcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHtcbiAgICAgICAgeDogLTQsIHk6IC00LCB6OiA0LCBzdHJpZGU6IDhcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoaW5mbykudG9FcXVhbCh7XG4gICAgICAgIHg6IDAsIHk6IDAsIHo6IDAsIHN0cmlkZTogOCwgaXRlcmF0aW9uOiAyLCBsYXllcjogMSwgcHJldmlvdXNPZmZzZXQ6IC00XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdyZXR1cm5zIG9yaWdpbiBwb3NpdGlvbiBmb3Igc2Vjb25kIGxheWVyJywgKCkgPT4ge1xuICAgICAgbGV0IFtyZXN1bHQsIGluZm9dID0gd29ybGRHZW5lcmF0b3IubmV4dCh7XG4gICAgICAgIHg6IDAsIHk6IDAsIHo6IDAsIHN0cmlkZTogOCwgaXRlcmF0aW9uOiAwLCBsYXllcjogMiwgcHJldmlvdXNPZmZzZXQ6IC00XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7XG4gICAgICAgIHg6IC0xMiwgeTogLTEyLCB6OiAtMTIsIHN0cmlkZTogOFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChpbmZvKS50b0VxdWFsKHtcbiAgICAgICAgeDogMCwgeTogMCwgejogMCwgc3RyaWRlOiA4LCBpdGVyYXRpb246IDEsIGxheWVyOiAyLCBwcmV2aW91c09mZnNldDogLTRcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3JldHVybnMgb3JpZ2luIHBvc2l0aW9uIGZvciBzZWNvbmQgbGF5ZXIgc2Vjb25kIGl0ZXJhdGlvbicsICgpID0+IHtcbiAgICAgIGxldCBbcmVzdWx0LCBpbmZvXSA9IHdvcmxkR2VuZXJhdG9yLm5leHQoe1xuICAgICAgICB4OiAwLCB5OiAwLCB6OiAwLCBzdHJpZGU6IDgsIGl0ZXJhdGlvbjogNiwgbGF5ZXI6IDIsIHByZXZpb3VzT2Zmc2V0OiAtNFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgICB4OiAtMTIsIHk6IC00LCB6OiA0LCBzdHJpZGU6IDhcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoaW5mbykudG9FcXVhbCh7XG4gICAgICAgIHg6IDAsIHk6IDAsIHo6IDAsIHN0cmlkZTogOCwgaXRlcmF0aW9uOiA3LCBsYXllcjogMiwgcHJldmlvdXNPZmZzZXQ6IC00XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdvZmZzZXRzIHBvc2l0aW9uIGJ5IHJvb3QnLCAoKSA9PiB7XG4gICAgICBsZXQgW3Jlc3VsdCwgaW5mb10gPSB3b3JsZEdlbmVyYXRvci5uZXh0KHtcbiAgICAgICAgeDogNDAsIHk6IDI0LCB6OiAzMiwgc3RyaWRlOiA4LCBpdGVyYXRpb246IDAsIGxheWVyOiAxLCBwcmV2aW91c09mZnNldDogLTRcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHtcbiAgICAgICAgeDogMzYsIHk6IDIwLCB6OiAyOCwgc3RyaWRlOiA4XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KGluZm8pLnRvRXF1YWwoe1xuICAgICAgICB4OiA0MCwgeTogMjQsIHo6IDMyLCBzdHJpZGU6IDgsIGl0ZXJhdGlvbjogMSwgbGF5ZXI6IDEsIHByZXZpb3VzT2Zmc2V0OiAtNFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnb2Zmc2V0cyBwb3NpdGlvbiBieSBpdGVyYXRpb24nLCAoKSA9PiB7XG4gICAgICBsZXQgW3Jlc3VsdCwgaW5mb10gPSB3b3JsZEdlbmVyYXRvci5uZXh0KHtcbiAgICAgICAgeDogNDAsIHk6IDI0LCB6OiAzMiwgc3RyaWRlOiA4LCBpdGVyYXRpb246IDEsIGxheWVyOiAxLCBwcmV2aW91c09mZnNldDogLTRcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHtcbiAgICAgICAgeDogMzYsIHk6IDIwLCB6OiAzNiwgc3RyaWRlOiA4XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KGluZm8pLnRvRXF1YWwoe1xuICAgICAgICB4OiA0MCwgeTogMjQsIHo6IDMyLCBzdHJpZGU6IDgsIGl0ZXJhdGlvbjogMiwgbGF5ZXI6IDEsIHByZXZpb3VzT2Zmc2V0OiAtNFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnb2Zmc2V0cyBwb3NpdGlvbiBieSBsYXN0IGl0ZXJhdGlvbicsICgpID0+IHtcbiAgICAgIGxldCBbcmVzdWx0LCBpbmZvXSA9IHdvcmxkR2VuZXJhdG9yLm5leHQoe1xuICAgICAgICB4OiA0MCwgeTogMjQsIHo6IDMyLCBzdHJpZGU6IDgsIGl0ZXJhdGlvbjogNywgbGF5ZXI6IDEsIHByZXZpb3VzT2Zmc2V0OiAtNFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgICB4OiA0NCwgeTogMjgsIHo6IDM2LCBzdHJpZGU6IDhcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoaW5mbykudG9FcXVhbCh7XG4gICAgICAgIHg6IDQwLCB5OiAyNCwgejogMzIsIHN0cmlkZTogOCwgaXRlcmF0aW9uOiAwLCBsYXllcjogMiwgcHJldmlvdXNPZmZzZXQ6IC00XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdvZmZzZXRzIHBvc2l0aW9uIGJ5IGxhc3QgbGF5ZXInLCAoKSA9PiB7XG4gICAgICBsZXQgW3Jlc3VsdCwgaW5mb10gPSB3b3JsZEdlbmVyYXRvci5uZXh0KHtcbiAgICAgICAgeDogNDAsIHk6IDI0LCB6OiAzMiwgc3RyaWRlOiA4LCBpdGVyYXRpb246IDU1LCBsYXllcjogMiwgcHJldmlvdXNPZmZzZXQ6IC00XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7XG4gICAgICAgIHg6IDUyLCB5OiAzNiwgejogNDQsIHN0cmlkZTogOFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChpbmZvKS50b0VxdWFsKHtcbiAgICAgICAgeDogNDAsIHk6IDI0LCB6OiAzMiwgc3RyaWRlOiAxNiwgaXRlcmF0aW9uOiAwLCBsYXllcjogMSwgcHJldmlvdXNPZmZzZXQ6IDhcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3JldHVybnMgY29ycmVjdCBwb3NpdGlvbiBmb3IgbmV4dCBzdHJpZGUnLCAoKSA9PiB7XG4gICAgICBsZXQgW3Jlc3VsdCwgaW5mb10gPSB3b3JsZEdlbmVyYXRvci5uZXh0KHtcbiAgICAgICAgeDogMCwgeTogMCwgejogMCwgc3RyaWRlOiAxNiwgaXRlcmF0aW9uOiAwLCBsYXllcjogMSwgcHJldmlvdXNPZmZzZXQ6IDhcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHtcbiAgICAgICAgeDogLTI0LCB5OiAtMjQsIHo6IC0yNCwgc3RyaWRlOiAxNlxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChpbmZvKS50b0VxdWFsKHtcbiAgICAgICAgeDogMCwgeTogMCwgejogMCwgc3RyaWRlOiAxNiwgaXRlcmF0aW9uOiAxLCBsYXllcjogMSwgcHJldmlvdXNPZmZzZXQ6IDhcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3JldHVybnMgY29ycmVjdCBwb3NpdGlvbiAzMi8wLzEnLCAoKSA9PiB7XG4gICAgICBsZXQgW3Jlc3VsdCwgaW5mb10gPSB3b3JsZEdlbmVyYXRvci5uZXh0KHtcbiAgICAgICAgeDogMCwgeTogMCwgejogMCwgc3RyaWRlOiAzMiwgaXRlcmF0aW9uOiAwLCBsYXllcjogMSwgcHJldmlvdXNPZmZzZXQ6IDQ4XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7XG4gICAgICAgIHg6IC04MCwgeTogLTgwLCB6OiAtODAsIHN0cmlkZTogMzJcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoaW5mbykudG9FcXVhbCh7XG4gICAgICAgIHg6IDAsIHk6IDAsIHo6IDAsIHN0cmlkZTogMzIsIGl0ZXJhdGlvbjogMSwgbGF5ZXI6IDEsIHByZXZpb3VzT2Zmc2V0OiA0OFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCd3aGVuIHJhZGl1cyBpcyBjYWxsZWQnLCAoKSA9PiB7XG4gICAgbGV0IGV4cGVjdGVkUmVzdWx0cyA9IFtcbiAgICAgIHsgbGF5ZXI6IDEsIHN0cmlkZTogOCwgcHJldmlvdXNPZmZzZXQ6IC00LCByZXN1bHQ6IDR9LFxuICAgICAgeyBsYXllcjogMiwgc3RyaWRlOiA4LCBwcmV2aW91c09mZnNldDogLTQsIHJlc3VsdDogMTJ9LFxuICAgICAgeyBsYXllcjogMSwgc3RyaWRlOiAxNiwgcHJldmlvdXNPZmZzZXQ6IDgsIHJlc3VsdDogMjR9LFxuICAgICAgeyBsYXllcjogMiwgc3RyaWRlOiAxNiwgcHJldmlvdXNPZmZzZXQ6IDgsIHJlc3VsdDogNDB9LFxuICAgICAgeyBsYXllcjogLTIsIHN0cmlkZTogMTYsIHByZXZpb3VzT2Zmc2V0OiA4LCByZXN1bHQ6IC00MH0sXG4gICAgXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwZWN0ZWRSZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB7bGF5ZXIsIHN0cmlkZSwgcHJldmlvdXNPZmZzZXQsIHJlc3VsdH0gPSBleHBlY3RlZFJlc3VsdHNbaV07XG4gICAgICBpdChgdGhlbiByaW5nICR7aSsxfSBpcyBjb3JyZWN0YCwgKCkgPT4ge1xuICAgICAgICBleHBlY3Qod29ybGRHZW5lcmF0b3IucmFkaXVzKGxheWVyLCBzdHJpZGUsIHByZXZpb3VzT2Zmc2V0KSkudG9FcXVhbChyZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICBkZXNjcmliZSgnd2hlbiBsYXllclJhZGl1cyBpcyBjYWxsZWQnLCAoKSA9PiB7XG4gICAgbGV0IGV4cGVjdGVkUmVzdWx0cyA9IFtcbiAgICAgIHsgbGF5ZXI6IDEsIHN0cmlkZTogOCwgcmVzdWx0OiAxfSxcbiAgICAgIHsgbGF5ZXI6IDIsIHN0cmlkZTogOCwgcmVzdWx0OiAyfSxcbiAgICAgIHsgbGF5ZXI6IDEsIHN0cmlkZTogMTYsIHJlc3VsdDogMn0sXG4gICAgICB7IGxheWVyOiAyLCBzdHJpZGU6IDE2LCByZXN1bHQ6IDN9LFxuICAgICAgeyBsYXllcjogMywgc3RyaWRlOiAxNiwgcmVzdWx0OiA0fSxcbiAgICAgIHsgbGF5ZXI6IDEsIHN0cmlkZTogMzIsIHJlc3VsdDogM30sXG4gICAgICB7IGxheWVyOiAyLCBzdHJpZGU6IDMyLCByZXN1bHQ6IDR9LFxuICAgIF07XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cGVjdGVkUmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qge2xheWVyLCBzdHJpZGUsIHJlc3VsdH0gPSBleHBlY3RlZFJlc3VsdHNbaV07XG4gICAgICBpdChgdGhlbiByaW5nICR7aSsxfSBpcyBjb3JyZWN0YCwgKCkgPT4ge1xuICAgICAgICBleHBlY3Qod29ybGRHZW5lcmF0b3IubGF5ZXJSYWRpdXMobGF5ZXIsIHN0cmlkZSkpLnRvRXF1YWwocmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3doZW4gbGF5ZXJDb3VudCBpcyBjYWxsZWQnLCAoKSA9PiB7XG4gICAgaXQoJ3JldHVybnMgMiBmb3IgZmlyc3Qgc3RyaWRlJywgKCkgPT4ge1xuICAgICAgZXhwZWN0KHdvcmxkR2VuZXJhdG9yLmxheWVyQ291bnQoOCkpLnRvRXF1YWwoMik7XG4gICAgfSk7XG5cbiAgICBpdCgncmV0dXJucyAzIGZvciBzZWNvbmQgc3RyaWRlJywgKCkgPT4ge1xuICAgICAgZXhwZWN0KHdvcmxkR2VuZXJhdG9yLmxheWVyQ291bnQoMTYpKS50b0VxdWFsKDMpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3JldHVybnMgMiBmb3Igc3Vic2VxdWVudCBzdHJpZGVzJywgKCkgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDMyOyBpIDwgMTAyNDsgaSs9aSkge1xuICAgICAgICBleHBlY3Qod29ybGRHZW5lcmF0b3IubGF5ZXJDb3VudChpKSkudG9FcXVhbCgyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dlbmVyYXRlIHBvaW50cycsICgpID0+IHtcbiAgICBpdCgncmV0dXJucyB0aGUgY29ycmVjdCB2YWx1ZXMnLCAoKSA9PiB7XG4gICAgICBleHBlY3QoZ2VuZXJhdGVQb2ludHMoMSkpLnRvRXF1YWwoW1xuICAgICAgICB7IHg6IC0xLCB5OiAtMSwgejogLTEgfSxcbiAgICAgICAgeyB4OiAtMSwgeTogLTEsIHo6IDEgfSxcbiAgICAgICAgeyB4OiAtMSwgeTogMSwgejogLTEgfSxcbiAgICAgICAgeyB4OiAtMSwgeTogMSwgejogMSB9LFxuICAgICAgICB7IHg6IDEsIHk6IC0xLCB6OiAtMSB9LFxuICAgICAgICB7IHg6IDEsIHk6IC0xLCB6OiAxIH0sXG4gICAgICAgIHsgeDogMSwgeTogMSwgejogLTEgfSxcbiAgICAgICAgeyB4OiAxLCB5OiAxLCB6OiAxIH0sXG4gICAgICBdKTtcbiAgICB9KTtcblxuICAgIGl0KCdyZXR1cm5zIHRoZSBjb3JyZWN0IHZhbHVlcyAyJywgKCkgPT4ge1xuICAgICAgZXhwZWN0KGdlbmVyYXRlUG9pbnRzKDIpLmxlbmd0aCkudG9FcXVhbCg1Nik7XG4gICAgfSk7XG4gIH0pXG59KTsiLCJleHBvcnQgaW50ZXJmYWNlIFdvcmxkR2VuZXJhdG9ySW5mbyB7XG4gIHg6IG51bWJlcjtcbiAgeTogbnVtYmVyO1xuICB6OiBudW1iZXI7XG4gIHN0cmlkZTogbnVtYmVyO1xuICBpdGVyYXRpb246IG51bWJlcjtcbiAgbGF5ZXI6IG51bWJlcjtcbiAgcHJldmlvdXNPZmZzZXQ6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIFdvcmxkUG9zaXRpb24ge1xuICB4OiBudW1iZXI7XG4gIHk6IG51bWJlcjtcbiAgejogbnVtYmVyO1xuICBzdHJpZGU6IG51bWJlcjtcblxuICBzdGF0aWMgZXF1YWwoYTogV29ybGRQb3NpdGlvbiwgYjogV29ybGRQb3NpdGlvbik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBhLnN0cmlkZSA9PSBiLnN0cmlkZSAmJiBhLnggPT0gYi54ICYmIGEueSA9PSBiLnkgJiYgYS56ID09IGIuejtcbiAgfVxufVxuXG5pbnRlcmZhY2UgUG9pbnQge1xuICB4OiBudW1iZXI7XG4gIHk6IG51bWJlcjtcbiAgejogbnVtYmVyO1xufVxuXG5mdW5jdGlvbiBmaXhQb2ludChpOiBudW1iZXIpOiBudW1iZXIge1xuICBpZiAoaSA+PSAwKSByZXR1cm4gaSArIDE7XG4gIHJldHVybiBpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVQb2ludHMocmFkaXVzOiBudW1iZXIpOiBQb2ludFtdIHtcbiAgbGV0IHBvaW50czogUG9pbnRbXSA9IFtdO1xuXG4gIGxldCBkaWFtZXRlciA9IHJhZGl1cyAqIDI7XG5cbiAgZm9yIChsZXQgeCA9IDA7IHggPCBkaWFtZXRlcjsgeCsrKVxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgZGlhbWV0ZXI7IHkrKylcbiAgICAgIGZvciAobGV0IHogPSAwOyB6IDwgZGlhbWV0ZXI7IHorKykge1xuICAgICAgICBpZiAoISh4ID09PSAwIHx8IHggPT09IGRpYW1ldGVyIC0gMSB8fCB5ID09PSAwIHx8IHkgPT09IGRpYW1ldGVyIC0gMSB8fCB6ID09PSAwIHx8IHogPT09IGRpYW1ldGVyIC0gMSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcG9pbnQgPSB7XG4gICAgICAgICAgeDogZml4UG9pbnQoeCAtIHJhZGl1cyksXG4gICAgICAgICAgeTogZml4UG9pbnQoeSAtIHJhZGl1cyksXG4gICAgICAgICAgejogZml4UG9pbnQoeiAtIHJhZGl1cylcbiAgICAgICAgfTtcblxuICAgICAgICBwb2ludHMucHVzaChwb2ludCk7XG4gICAgICB9XG5cbiAgcmV0dXJuIHBvaW50cztcbn1cblxuY29uc3QgcG9pbnRzID0gW107XG5cbmZvciAobGV0IGkgPSAwOyBpIDw9IDY7IGkrKykge1xuICBwb2ludHNbaV0gPSBnZW5lcmF0ZVBvaW50cyhpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV29ybGRHZW5lcmF0b3Ige1xuICBwcml2YXRlIHJlYWRvbmx5IG1pblN0cmlkZTogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKG1pblN0cmlkZTogbnVtYmVyKSB7XG4gICAgdGhpcy5taW5TdHJpZGUgPSBtaW5TdHJpZGU7XG4gIH1cblxuICBpbml0KHg6IG51bWJlciwgeTogbnVtYmVyLCB6OiBudW1iZXIpOiBXb3JsZEdlbmVyYXRvckluZm8ge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBNYXRoLnJvdW5kKHggLyB0aGlzLm1pblN0cmlkZSkgKiB0aGlzLm1pblN0cmlkZSxcbiAgICAgIHk6IE1hdGgucm91bmQoeSAvIHRoaXMubWluU3RyaWRlKSAqIHRoaXMubWluU3RyaWRlLFxuICAgICAgejogTWF0aC5yb3VuZCh6IC8gdGhpcy5taW5TdHJpZGUpICogdGhpcy5taW5TdHJpZGUsXG4gICAgICBzdHJpZGU6IHRoaXMubWluU3RyaWRlLFxuICAgICAgaXRlcmF0aW9uOiAwLFxuICAgICAgbGF5ZXI6IDEsXG4gICAgICBwcmV2aW91c09mZnNldDogLTEgKiB0aGlzLm1pblN0cmlkZSAvIDJcbiAgICB9O1xuICB9XG5cbiAgbGF5ZXJSYWRpdXMobGF5ZXI6IG51bWJlciwgc3RyaWRlOiBudW1iZXIpIHtcbiAgICBpZiAoc3RyaWRlID09PSB0aGlzLm1pblN0cmlkZSkge1xuICAgICAgcmV0dXJuIGxheWVyO1xuICAgIH1cbiAgICBpZiAoc3RyaWRlID09PSB0aGlzLm1pblN0cmlkZSAqIDIpIHtcbiAgICAgIHJldHVybiBsYXllciArIDE7XG4gICAgfVxuICAgIHJldHVybiBsYXllciArIDI7XG4gIH1cblxuICByYWRpdXMobGF5ZXI6IG51bWJlciwgc3RyaWRlOiBudW1iZXIsIHByZXZpb3VzT2Zmc2V0OiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiBNYXRoLnNpZ24obGF5ZXIpICogKHByZXZpb3VzT2Zmc2V0ICsgKE1hdGguYWJzKGxheWVyKSAqIHN0cmlkZSkpO1xuICB9XG5cbiAgbGF5ZXJDb3VudChzdHJpZGU6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKHN0cmlkZSA9PSB0aGlzLm1pblN0cmlkZSAqIDIpXG4gICAgICByZXR1cm4gMztcbiAgICByZXR1cm4gMjtcbiAgfVxuXG4gIG5leHQoaW5mbzogV29ybGRHZW5lcmF0b3JJbmZvKTogW1dvcmxkUG9zaXRpb24sIFdvcmxkR2VuZXJhdG9ySW5mb10ge1xuICAgIGNvbnN0IG9mZnNldHMgPSBwb2ludHNbdGhpcy5sYXllclJhZGl1cyhpbmZvLmxheWVyLCBpbmZvLnN0cmlkZSldO1xuXG4gICAgY29uc3Qgb2Zmc2V0ID0gb2Zmc2V0c1tpbmZvLml0ZXJhdGlvbl07XG4gICAgY29uc3QgaGFsZlN0cmlkZSA9IGluZm8uc3RyaWRlIC8gMjtcblxuICAgIGxldCBpdGVyYXRpb24gPSBpbmZvLml0ZXJhdGlvbiArIDE7XG4gICAgbGV0IGxheWVyID0gaW5mby5sYXllcjtcbiAgICBsZXQgc3RyaWRlID0gaW5mby5zdHJpZGU7XG4gICAgbGV0IHByZXZpb3VzT2Zmc2V0ID0gaW5mby5wcmV2aW91c09mZnNldDtcblxuICAgIGlmIChpdGVyYXRpb24gPj0gb2Zmc2V0cy5sZW5ndGgpIHtcbiAgICAgIGl0ZXJhdGlvbiA9IDA7XG4gICAgICBsYXllcisrO1xuXG4gICAgICBjb25zdCBsYXllckNvdW50ID0gdGhpcy5sYXllckNvdW50KGluZm8uc3RyaWRlKTtcbiAgICAgIGlmIChsYXllciA+IGxheWVyQ291bnQpIHtcbiAgICAgICAgbGF5ZXIgPSAxO1xuICAgICAgICBzdHJpZGUgKj0gMjtcbiAgICAgICAgcHJldmlvdXNPZmZzZXQgPSB0aGlzLnJhZGl1cyhpbmZvLmxheWVyLCBpbmZvLnN0cmlkZSwgaW5mby5wcmV2aW91c09mZnNldCkgLSBpbmZvLnN0cmlkZSAvIDI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHg6IGluZm8uc3RyaWRlICogb2Zmc2V0LnggKyBpbmZvLnggLSBNYXRoLnNpZ24ob2Zmc2V0LngpICogaGFsZlN0cmlkZSxcbiAgICAgICAgeTogaW5mby5zdHJpZGUgKiBvZmZzZXQueSArIGluZm8ueSAtIE1hdGguc2lnbihvZmZzZXQueSkgKiBoYWxmU3RyaWRlLFxuICAgICAgICB6OiBpbmZvLnN0cmlkZSAqIG9mZnNldC56ICsgaW5mby56IC0gTWF0aC5zaWduKG9mZnNldC56KSAqIGhhbGZTdHJpZGUsXG4gICAgICAgIHN0cmlkZTogaW5mby5zdHJpZGVcbiAgICAgIH0sXG4gICAgICB7IC4uLmluZm8sIGl0ZXJhdGlvbiwgbGF5ZXIsIHN0cmlkZSwgcHJldmlvdXNPZmZzZXQgfVxuICAgIF07XG4gIH1cbn0iLCJ2YXIgbWFwID0ge1xuXHRcIi4vY29tcHV0ZS12b3hlbHMudGVzdC50c1wiOiBcIi4vc3JjL2NvbXB1dGUtdm94ZWxzLnRlc3QudHNcIixcblx0XCIuL3JlbmRlcmVyLnRlc3QudHNcIjogXCIuL3NyYy9yZW5kZXJlci50ZXN0LnRzXCIsXG5cdFwiLi93b3JsZC1nZW5lcmF0b3IudGVzdC50c1wiOiBcIi4vc3JjL3dvcmxkLWdlbmVyYXRvci50ZXN0LnRzXCJcbn07XG5cblxuZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XG5cdHZhciBpZCA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpO1xuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhpZCk7XG59XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7XG5cdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8obWFwLCByZXEpKSB7XG5cdFx0dmFyIGUgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInXCIpO1xuXHRcdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0XHR0aHJvdyBlO1xuXHR9XG5cdHJldHVybiBtYXBbcmVxXTtcbn1cbndlYnBhY2tDb250ZXh0LmtleXMgPSBmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dEtleXMoKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xufTtcbndlYnBhY2tDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmU7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tDb250ZXh0O1xud2VicGFja0NvbnRleHQuaWQgPSBcIi4vc3JjIHN5bmMgcmVjdXJzaXZlIC50ZXN0LihqfHQpcyRcIjsiLCIvKiAoaWdub3JlZCkgKi8iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHRpZihfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdKSB7XG5cdFx0cmV0dXJuIF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0uZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHRpZDogbW9kdWxlSWQsXG5cdFx0bG9hZGVkOiBmYWxzZSxcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG5cdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiX193ZWJwYWNrX3JlcXVpcmVfXy5hbWREID0gZnVuY3Rpb24gKCkge1xuXHR0aHJvdyBuZXcgRXJyb3IoJ2RlZmluZSBjYW5ub3QgYmUgdXNlZCBpbmRpcmVjdCcpO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmFtZE8gPSB7fTsiLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubm1kID0gKG1vZHVsZSkgPT4ge1xuXHRtb2R1bGUucGF0aHMgPSBbXTtcblx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRyZXR1cm4gbW9kdWxlO1xufTsiLCIvLyBzdGFydHVwXG4vLyBMb2FkIGVudHJ5IG1vZHVsZVxuX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL3Rlc3RzLnRzXCIpO1xuLy8gVGhpcyBlbnRyeSBtb2R1bGUgdXNlZCAnZXhwb3J0cycgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxuIl0sInNvdXJjZVJvb3QiOiIifQ==